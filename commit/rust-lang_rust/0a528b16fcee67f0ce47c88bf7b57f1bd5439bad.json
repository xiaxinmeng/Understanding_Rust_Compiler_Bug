{"sha": "0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "node_id": "C_kwDOAAsO6NoAKDBhNTI4YjE2ZmNlZTY3ZjBjZTQ3Yzg4YmY3YjU3ZjFiZDU0MzliYWQ", "commit": {"author": {"name": "Kagami Sascha Rosylight", "email": "saschanaz@outlook.com", "date": "2022-11-15T20:16:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-15T20:16:11Z"}, "message": "Merge branch 'master' into patch-2", "tree": {"sha": "dcb70343d026bbf64a6a6b262b1c4ac003d7919c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcb70343d026bbf64a6a6b262b1c4ac003d7919c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjc/OLCRBK7hj4Ov3rIwAAXe4IAFYRFGkx7apvZa4hSmqm6Lpo\nQQbRTSPsSgfkFZcoHyDw5j9KnY1QSITtGjd30sWjMIJ4poGPqT5h0zhPslXpZyTV\nt5uK3cw8azIcNJldJ/CZnIogtJpNb+t7YfVjjbN8yXL0eJSDZOlKUAkOd1VeNUz6\nh3Ye3chjvjUdjOe/0DNj/LKBsUruFYTY0qnIE9Obuw1Ar+WUvLVtgTr0MYgfpkf9\nLTNYF1s2eRYFoKiOqv/Q/raVVUWFwxlvLJd7I8614jULkXGBFM5rOo1xvBhN+Rgr\nwnSuhXzL9a7Yuu1waKZVoGxinUPZ4aqhg5X8GF+O2GCcFXu8lb81luG4kM7uPVo=\n=Bsvt\n-----END PGP SIGNATURE-----\n", "payload": "tree dcb70343d026bbf64a6a6b262b1c4ac003d7919c\nparent 30b522365bf3a2be8248c1572054e5988db0e1fd\nparent 6d651a295e0e0c331153288b10b78344a4ede20b\nauthor Kagami Sascha Rosylight <saschanaz@outlook.com> 1668543371 +0100\ncommitter GitHub <noreply@github.com> 1668543371 +0100\n\nMerge branch 'master' into patch-2"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "html_url": "https://github.com/rust-lang/rust/commit/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/comments", "author": {"login": "saschanaz", "id": 3396686, "node_id": "MDQ6VXNlcjMzOTY2ODY=", "avatar_url": "https://avatars.githubusercontent.com/u/3396686?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saschanaz", "html_url": "https://github.com/saschanaz", "followers_url": "https://api.github.com/users/saschanaz/followers", "following_url": "https://api.github.com/users/saschanaz/following{/other_user}", "gists_url": "https://api.github.com/users/saschanaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/saschanaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saschanaz/subscriptions", "organizations_url": "https://api.github.com/users/saschanaz/orgs", "repos_url": "https://api.github.com/users/saschanaz/repos", "events_url": "https://api.github.com/users/saschanaz/events{/privacy}", "received_events_url": "https://api.github.com/users/saschanaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30b522365bf3a2be8248c1572054e5988db0e1fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/30b522365bf3a2be8248c1572054e5988db0e1fd", "html_url": "https://github.com/rust-lang/rust/commit/30b522365bf3a2be8248c1572054e5988db0e1fd"}, {"sha": "6d651a295e0e0c331153288b10b78344a4ede20b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d651a295e0e0c331153288b10b78344a4ede20b", "html_url": "https://github.com/rust-lang/rust/commit/6d651a295e0e0c331153288b10b78344a4ede20b"}], "stats": {"total": 88986, "additions": 58005, "deletions": 30981}, "files": [{"sha": "b40066d05d355ec05aef4c9c018aa56586bea2bd", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,3 +4,5 @@ a06baa56b95674fc626b3c3fd680d6a65357fe60\n 95e00bfed801e264e9c4ac817004153ca0f19eb6\n # reformat with new rustfmt\n 971c549ca334b7b7406e61e958efcca9c4152822\n+# refactor infcx building\n+283abbf0e7d20176f76006825b5c52e9a4234e4c"}, {"sha": "f887d29096e038fe5eab11d838095fe916dfa97c", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -217,7 +217,7 @@ Hsiang-Cheng Yang <rick68@users.noreply.github.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ian.jackson@citrix.com>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <ijackson+github@slimy.greenend.org.uk>\n Ian Jackson <ijackson@chiark.greenend.org.uk> <iwj@xenproject.org>\n-Ibraheem Ahmed <ibrah1440@gmail.com>\n+Ibraheem Ahmed <ibraheem@ibraheem.ca> <ibrah1440@gmail.com>\n Ilyong Cho <ilyoan@gmail.com>\n inquisitivecrystal <22333129+inquisitivecrystal@users.noreply.github.com>\n Irina Popa <irinagpopa@gmail.com>"}, {"sha": "5135f92a9d82ef47d0c4650c0f295b51dd80a3fc", "filename": ".reuse/dep5", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,11 +6,6 @@ Files: *\n Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n License: MIT or Apache-2.0\n \n-Files: library/std/src/sync/mpsc/mpsc_queue.rs\n-       library/std/src/sync/mpsc/spsc_queue.rs\n-Copyright: 2010-2011 Dmitry Vyukov\n-License: BSD-2-Clause\n-\n Files: src/librustdoc/html/static/fonts/FiraSans*\n Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n License: OFL-1.1"}, {"sha": "05993830a0fb4ab5d30336f75be3e5001e1fc770", "filename": "COPYRIGHT", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -339,3 +339,53 @@ their own copyright notices and license terms:\n     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n+\n+* Portions of internationalization code use code or data from Unicode, which\n+  carry the following license:\n+\n+      UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+    See Terms of Use <https://www.unicode.org/copyright.html>\n+    for definitions of Unicode Inc.\u2019s Data Files and Software.\n+\n+    NOTICE TO USER: Carefully read the following legal agreement.\n+    BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S\n+    DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"),\n+    YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE\n+    TERMS AND CONDITIONS OF THIS AGREEMENT.\n+    IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE\n+    THE DATA FILES OR SOFTWARE.\n+\n+    COPYRIGHT AND PERMISSION NOTICE\n+\n+    Copyright \u00a9 1991-2022 Unicode, Inc. All rights reserved.\n+    Distributed under the Terms of Use in https://www.unicode.org/copyright.html.\n+\n+    Permission is hereby granted, free of charge, to any person obtaining\n+    a copy of the Unicode data files and any associated documentation\n+    (the \"Data Files\") or Unicode software and any associated documentation\n+    (the \"Software\") to deal in the Data Files or Software\n+    without restriction, including without limitation the rights to use,\n+    copy, modify, merge, publish, distribute, and/or sell copies of\n+    the Data Files or Software, and to permit persons to whom the Data Files\n+    or Software are furnished to do so, provided that either\n+    (a) this copyright and permission notice appear with all copies\n+    of the Data Files or Software, or\n+    (b) this copyright and permission notice appear in associated\n+    Documentation.\n+\n+    THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n+    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+    NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n+    IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS\n+    NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL\n+    DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,\n+    DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n+    TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n+    PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+    Except as contained in this notice, the name of a copyright holder\n+    shall not be used in advertising or otherwise to promote the sale,\n+    use or other dealings in these Data Files or Software without prior\n+    written authorization of the copyright holder."}, {"sha": "9f64aa44314db553a78cacab3826a95a45e66f22", "filename": "Cargo.lock", "status": "modified", "additions": 191, "deletions": 142, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,41 +4,26 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n dependencies = [\n  \"compiler_builtins\",\n- \"gimli 0.25.0\",\n+ \"gimli\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"addr2line\"\n-version = \"0.17.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n-dependencies = [\n- \"gimli 0.26.1\",\n-]\n-\n [[package]]\n name = \"adler\"\n-version = \"0.2.3\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"adler\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n-\n [[package]]\n name = \"ahash\"\n version = \"0.7.4\"\n@@ -185,12 +170,12 @@ version = \"0.3.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cab84319d616cfb654d03394f38ab7e6f0919e181b1b57e1fd15e7fb4077d9a7\"\n dependencies = [\n- \"addr2line 0.17.0\",\n+ \"addr2line\",\n  \"cc\",\n  \"cfg-if 1.0.0\",\n  \"libc\",\n- \"miniz_oxide 0.5.3\",\n- \"object 0.29.0\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"rustc-demangle\",\n ]\n \n@@ -288,7 +273,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.67.0\"\n+version = \"0.68.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -427,7 +412,6 @@ dependencies = [\n  \"glob\",\n  \"itertools\",\n  \"lazy_static\",\n- \"remove_dir_all\",\n  \"serde_json\",\n  \"snapbox\",\n  \"tar\",\n@@ -449,7 +433,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.4.0\",\n  \"same-file\",\n  \"shell-escape\",\n  \"tempfile\",\n@@ -489,9 +473,9 @@ version = \"0.1.0\"\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.73\"\n+version = \"1.0.76\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+checksum = \"76a284da2e6fe2092f2353e51713435363112dfd60030e22add80be333fb928f\"\n dependencies = [\n  \"jobserver\",\n ]\n@@ -518,9 +502,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d0001adf0cf12361e08b65e1898ea138f8f77d8f5177cbf29b6b3b3532252bd6\"\n+checksum = \"d552b2fa341f5fc35c6b917b1d289d3c3a34d0b74e579390ea6192d6152a8cdb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -530,9 +514,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c44ee96f2d67cb5193d1503f185db1abad9933a1c6e6b4169c176f90baecd393\"\n+checksum = \"7e54ac43048cb31c470d7b3e3acd409090ef4a5abddfe02455187aebc3d6879f\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -543,9 +527,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"92d8a95548f23618fda86426e4304e563ec2bb7ba0216139f0748d63c107b5f1\"\n+checksum = \"43aa55deff4e7fbdb09fa014543372f2c95a06835ac487b9ce57b5099b950838\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -554,9 +538,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.80.0\"\n+version = \"0.87.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f37f492dacfafe2e21319b80827da2779932909bb392f0cc86b2bd5c07c1b4e1\"\n+checksum = \"61213deefc36ba265ad01c4d997e18bcddf7922862a4594a47ca4575afb3dab4\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -815,7 +799,8 @@ dependencies = [\n  \"lazy_static\",\n  \"lazycell\",\n  \"libc\",\n- \"miow\",\n+ \"miow 0.3.7\",\n+ \"miropt-test-tools\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -839,7 +824,7 @@ dependencies = [\n  \"lazy_static\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.3.7\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -852,9 +837,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor\"\n-version = \"0.0.8\"\n+version = \"0.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"015267563b1df20adccdd00cb05257b1dfbea70a04928e9cf88ffb850c1a40af\"\n+checksum = \"b90f9dcd9490a97db91a85ccd79e38a87e14323f0bb824659ee3274e9143ba37\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n@@ -863,9 +848,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor-query\"\n-version = \"0.0.5\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d6417fe6fc03a8b533fd2177742eeb39a90c7233eedec7bac96d4d6b69a09449\"\n+checksum = \"82a90734b3d5dcf656e7624cca6bce9c3a90ee11f900e80141a7427ccfb3d317\"\n \n [[package]]\n name = \"content_inspector\"\n@@ -1035,9 +1020,9 @@ dependencies = [\n \n [[package]]\n name = \"curl\"\n-version = \"0.4.43\"\n+version = \"0.4.44\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"37d855aeef205b43f65a5001e0997d81f8efca7badad4fad7d897aa7f0d0651f\"\n+checksum = \"509bd11746c7ac09ebd19f0b17782eae80aadee26237658a6b4808afb5c11a22\"\n dependencies = [\n  \"curl-sys\",\n  \"libc\",\n@@ -1050,9 +1035,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.55+curl-7.83.1\"\n+version = \"0.4.59+curl-7.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"23734ec77368ec583c2e61dd3f0b0e5c98b93abe6d2a004ca06b91dd7e3e2762\"\n+checksum = \"6cfce34829f448b08f55b7db6d0009e23e2e86a34e8c2b366269bf5799b4a407\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1153,6 +1138,17 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"displaydoc\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"dlmalloc\"\n version = \"0.2.3\"\n@@ -1284,15 +1280,15 @@ checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.16\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n+checksum = \"b39522e96686d38f4bc984b9198e3a0613264abaebaff2c5c918bfa6b6da09af\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"crc32fast\",\n  \"libc\",\n  \"libz-sys\",\n- \"miniz_oxide 0.4.0\",\n+ \"miniz_oxide\",\n ]\n \n [[package]]\n@@ -1514,11 +1510,11 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.14\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n+checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n@@ -1534,25 +1530,17 @@ dependencies = [\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n-[[package]]\n-name = \"gimli\"\n-version = \"0.25.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n-]\n-\n [[package]]\n name = \"gimli\"\n version = \"0.26.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n dependencies = [\n+ \"compiler_builtins\",\n  \"fallible-iterator\",\n  \"indexmap\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n  \"stable_deref_trait\",\n ]\n \n@@ -1833,11 +1821,10 @@ dependencies = [\n \n [[package]]\n name = \"intl_pluralrules\"\n-version = \"7.0.1\"\n+version = \"7.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b18f988384267d7066cc2be425e6faf352900652c046b6971d2e228d3b1c5ecf\"\n+checksum = \"078ea7b7c29a2b4df841a7f6ac8775ff6074020c6776d48491ce2268e068f972\"\n dependencies = [\n- \"tinystr\",\n  \"unic-langid\",\n ]\n \n@@ -2218,32 +2205,32 @@ checksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.0\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0f75932c1f6cfae3c04000e40114adf955636e19040f9c0a2c380702aa1c7f\"\n+checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n dependencies = [\n- \"adler 0.2.3\",\n+ \"adler\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n-name = \"miniz_oxide\"\n-version = \"0.5.3\"\n+name = \"miow\"\n+version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+checksum = \"b9f1c5b025cda876f66ef43a113f91ebc9f4ccef34843000e0adf6ebbab84e21\"\n dependencies = [\n- \"adler 1.0.2\",\n+ \"winapi\",\n ]\n \n [[package]]\n name = \"miow\"\n-version = \"0.3.7\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9f1c5b025cda876f66ef43a113f91ebc9f4ccef34843000e0adf6ebbab84e21\"\n+checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n dependencies = [\n- \"winapi\",\n+ \"windows-sys 0.28.0\",\n ]\n \n [[package]]\n@@ -2262,11 +2249,19 @@ dependencies = [\n  \"rand 0.8.5\",\n  \"regex\",\n  \"rustc-workspace-hack\",\n+ \"rustc_version\",\n  \"shell-escape\",\n  \"smallvec\",\n  \"ui_test\",\n ]\n \n+[[package]]\n+name = \"miropt-test-tools\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"regex\",\n+]\n+\n [[package]]\n name = \"new_debug_unreachable\"\n version = \"1.0.4\"\n@@ -2319,29 +2314,20 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"object\"\n-version = \"0.26.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"memchr\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n-]\n-\n [[package]]\n name = \"object\"\n version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n+ \"compiler_builtins\",\n  \"crc32fast\",\n  \"flate2\",\n  \"hashbrown\",\n  \"indexmap\",\n  \"memchr\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -2459,7 +2445,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2470,7 +2456,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2495,7 +2481,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -2514,15 +2500,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -2747,9 +2733,9 @@ dependencies = [\n \n [[package]]\n name = \"psm\"\n-version = \"0.1.16\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd136ff4382c4753fc061cb9e4712ab2af263376b95bbd5bd8cd50c020b78e69\"\n+checksum = \"5787f7cda34e3033a72192c018bc5883100330f362ef279a8cbccfce8bb4e874\"\n dependencies = [\n  \"cc\",\n ]\n@@ -2798,7 +2784,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n  \"libc\",\n  \"rand_chacha 0.2.2\",\n  \"rand_core 0.5.1\",\n@@ -2842,7 +2828,7 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n ]\n \n [[package]]\n@@ -3278,7 +3264,7 @@ dependencies = [\n  \"cstr\",\n  \"libc\",\n  \"measureme\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3312,7 +3298,7 @@ dependencies = [\n  \"itertools\",\n  \"jobserver\",\n  \"libc\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_arena\",\n@@ -3645,7 +3631,6 @@ dependencies = [\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n- \"libc\",\n  \"libloading\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3688,7 +3673,6 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"smallvec\",\n  \"tracing\",\n- \"winapi\",\n ]\n \n [[package]]\n@@ -4108,6 +4092,7 @@ name = \"rustc_session\"\n version = \"0.0.0\"\n dependencies = [\n  \"getopts\",\n+ \"libc\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -4119,7 +4104,9 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"smallvec\",\n  \"tracing\",\n+ \"winapi\",\n ]\n \n [[package]]\n@@ -4609,9 +4596,9 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"snapbox\"\n-version = \"0.3.3\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44d199ccf8f606592df2d145db26f2aa45344e23c64b074cc5a4047f1d99b0f7\"\n+checksum = \"827c00e91b15e2674d8a5270bae91f898693cbf9561cbb58d8eaa31974597293\"\n dependencies = [\n  \"concolor\",\n  \"content_inspector\",\n@@ -4649,9 +4636,9 @@ checksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n \n [[package]]\n name = \"stacker\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90939d5171a4420b3ff5fbc8954d641e7377335454c259dcb80786f3f21dc9b4\"\n+checksum = \"c886bd4480155fd3ef527d45e9ac8dd7118a898a46530b7b94c3e21866259fce\"\n dependencies = [\n  \"cc\",\n  \"cfg-if 1.0.0\",\n@@ -4670,7 +4657,7 @@ checksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n- \"addr2line 0.16.0\",\n+ \"addr2line\",\n  \"alloc\",\n  \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n@@ -4680,8 +4667,8 @@ dependencies = [\n  \"hashbrown\",\n  \"hermit-abi 0.2.6\",\n  \"libc\",\n- \"miniz_oxide 0.4.0\",\n- \"object 0.26.2\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -4868,9 +4855,9 @@ checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thin-vec\"\n-version = \"0.2.8\"\n+version = \"0.2.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"104c2cb3180b6fb6d5b2278768e9b88b578d32ba751ea6e8d026688a40d7ed87\"\n+checksum = \"ceb05e71730d396f960f8f3901cdb41be2d339b303e9d7d3a07c5ff0536e671b\"\n \n [[package]]\n name = \"thiserror\"\n@@ -4898,9 +4885,9 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e6cb0c7868d7f90407531108ab03263d9452a8811b7cdd87675343a40d4aa254\"\n dependencies = [\n- \"gimli 0.26.1\",\n+ \"gimli\",\n  \"hashbrown\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"tracing\",\n ]\n \n@@ -4918,7 +4905,9 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n+ \"ignore\",\n  \"lazy_static\",\n+ \"miropt-test-tools\",\n  \"regex\",\n  \"walkdir\",\n ]\n@@ -4939,9 +4928,12 @@ dependencies = [\n \n [[package]]\n name = \"tinystr\"\n-version = \"0.3.4\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n+checksum = \"f8aeafdfd935e4a7fe16a91ab711fa52d54df84f9c8f7ca5837a9d1d902ef4c2\"\n+dependencies = [\n+ \"displaydoc\",\n+]\n \n [[package]]\n name = \"tinyvec\"\n@@ -5177,28 +5169,28 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"73328fcd730a030bdb19ddf23e192187a6b01cd98be6d3140622a89129459ce5\"\n+checksum = \"398f9ad7239db44fd0f80fe068d12ff22d78354080332a5077dc6f52f14dcf2f\"\n dependencies = [\n  \"unic-langid-impl\",\n  \"unic-langid-macros\",\n ]\n \n [[package]]\n name = \"unic-langid-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a4a8eeaf0494862c1404c95ec2f4c33a2acff5076f64314b465e3ddae1b934d\"\n+checksum = \"e35bfd2f2b8796545b55d7d3fd3e89a0613f68a0d1c8bc28cb7ff96b411a35ff\"\n dependencies = [\n  \"tinystr\",\n ]\n \n [[package]]\n name = \"unic-langid-macros\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18f980d6d87e8805f2836d64b4138cc95aa7986fa63b1f51f67d5fbff64dd6e5\"\n+checksum = \"055e618bf694161ffff0466d95cef3e1a5edc59f6ba1888e97801f2b4ebdc4fe\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"tinystr\",\n@@ -5208,9 +5200,9 @@ dependencies = [\n \n [[package]]\n name = \"unic-langid-macros-impl\"\n-version = \"0.9.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"29396ffd97e27574c3e01368b1a64267d3064969e4848e2e130ff668be9daa9f\"\n+checksum = \"1f5cdec05b907f4e2f6843f4354f4ce6a5bebe1a56df320a49134944477ce4d8\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"quote\",\n@@ -5334,7 +5326,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -5453,46 +5445,103 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n+dependencies = [\n+ \"windows_aarch64_msvc 0.28.0\",\n+ \"windows_i686_gnu 0.28.0\",\n+ \"windows_i686_msvc 0.28.0\",\n+ \"windows_x86_64_gnu 0.28.0\",\n+ \"windows_x86_64_msvc 0.28.0\",\n+]\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n- \"windows_aarch64_msvc\",\n- \"windows_i686_gnu\",\n- \"windows_i686_msvc\",\n- \"windows_x86_64_gnu\",\n- \"windows_x86_64_msvc\",\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc 0.42.0\",\n+ \"windows_i686_gnu 0.42.0\",\n+ \"windows_i686_msvc 0.42.0\",\n+ \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc 0.42.0\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.28.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.28.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.28.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n \n [[package]]\n name = \"xattr\""}, {"sha": "13a98eedde86704608ea81167f78ea3e3f5cae69", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -11,6 +11,7 @@ members = [\n   \"src/tools/error_index_generator\",\n   \"src/tools/linkchecker\",\n   \"src/tools/lint-docs\",\n+  \"src/tools/miropt-test-tools\",\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\","}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30b522365bf3a2be8248c1572054e5988db0e1fd/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/30b522365bf3a2be8248c1572054e5988db0e1fd/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=30b522365bf3a2be8248c1572054e5988db0e1fd", "patch": "@@ -1,9 +0,0 @@\n-Copyright (c) <year> <owner> \n-\n-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n-\n-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n-\n-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n-\n-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "5c1990bb6c97bca9952a7bdefe4151cf24511a56", "filename": "RELEASES.md", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,109 @@\n+Version 1.65.0 (2022-11-03)\n+==========================\n+\n+Language\n+--------\n+- [Error on `as` casts of enums with `#[non_exhaustive]` variants](https://github.com/rust-lang/rust/pull/92744/)\n+- [Stabilize `let else`](https://github.com/rust-lang/rust/pull/93628/)\n+- [Stabilize generic associated types (GATs)](https://github.com/rust-lang/rust/pull/96709/)\n+- [Add lints `let_underscore_drop` and `let_underscore_lock` from Clippy](https://github.com/rust-lang/rust/pull/97739/)\n+- [Stabilize `break`ing from arbitrary labeled blocks (\"label-break-value\")](https://github.com/rust-lang/rust/pull/99332/)\n+- [Uninitialized integers, floats, and raw pointers are now considered immediate UB](https://github.com/rust-lang/rust/pull/98919/).\n+  Usage of `MaybeUninit` is the correct way to work with uninitialized memory.\n+- [Stabilize raw-dylib for Windows x86_64, aarch64, and thumbv7a](https://github.com/rust-lang/rust/pull/99916/)\n+- [Do not allow `Drop` impl on foreign ADTs](https://github.com/rust-lang/rust/pull/99576/)\n+\n+Compiler\n+--------\n+- [Stabilize -Csplit-debuginfo on Linux](https://github.com/rust-lang/rust/pull/98051/)\n+- [Use niche-filling optimization even when multiple variants have data](https://github.com/rust-lang/rust/pull/94075/)\n+- [Associated type projections are now verified to be well-formed prior to resolving the underlying type](https://github.com/rust-lang/rust/pull/99217/#issuecomment-1209365630)\n+- [Stringify non-shorthand visibility correctly](https://github.com/rust-lang/rust/pull/100350/)\n+- [Normalize struct field types when unsizing](https://github.com/rust-lang/rust/pull/101831/)\n+- [Update to LLVM 15](https://github.com/rust-lang/rust/pull/99464/)\n+- [Fix aarch64 call abi to correctly zeroext when needed](https://github.com/rust-lang/rust/pull/97800/)\n+- [debuginfo: Generalize C++-like encoding for enums](https://github.com/rust-lang/rust/pull/98393/)\n+- [Add `special_module_name` lint](https://github.com/rust-lang/rust/pull/94467/)\n+- [Add support for generating unique profraw files by default when using `-C instrument-coverage`](https://github.com/rust-lang/rust/pull/100384/)\n+- [Allow dynamic linking for iOS/tvOS targets](https://github.com/rust-lang/rust/pull/100636/)\n+\n+New targets:\n+\n+- [Add armv4t-none-eabi as a tier 3 target](https://github.com/rust-lang/rust/pull/100244/)\n+- [Add powerpc64-unknown-openbsd and riscv64-unknown-openbsd as tier 3 targets](https://github.com/rust-lang/rust/pull/101025/)\n+  - Refer to Rust's [platform support page][platform-support-doc] for more\n+    information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+\n+- [Don't generate `PartialEq::ne` in derive(PartialEq)](https://github.com/rust-lang/rust/pull/98655/)\n+- [Windows RNG: Use `BCRYPT_RNG_ALG_HANDLE` by default](https://github.com/rust-lang/rust/pull/101325/)\n+- [Forbid mixing `System` with direct system allocator calls](https://github.com/rust-lang/rust/pull/101394/)\n+- [Document no support for writing to non-blocking stdio/stderr](https://github.com/rust-lang/rust/pull/101416/)\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295)\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+\n+Stabilized APIs\n+---------------\n+\n+- [`std::backtrace::Backtrace`](https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html)\n+- [`Bound::as_ref`](https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref)\n+- [`std::io::read_to_string`](https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html)\n+- [`<*const T>::cast_mut`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut)\n+- [`<*mut T>::cast_const`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`<*const T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+- [`<*mut T>::offset_from`](https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from)\n+\n+Cargo\n+-----\n+\n+- [Apply GitHub fast path even for partial hashes](https://github.com/rust-lang/cargo/pull/10807/)\n+- [Do not add home bin path to PATH if it's already there](https://github.com/rust-lang/cargo/pull/11023/)\n+- [Take priority into account within the pending queue](https://github.com/rust-lang/cargo/pull/11032/).\n+  This slightly optimizes job scheduling by Cargo, with typically small improvements on larger crate graph builds.\n+\n+Compatibility Notes\n+-------------------\n+\n+- [`std::layout::Layout` size must not overflow `isize::MAX` when rounded up to `align`](https://github.com/rust-lang/rust/pull/95295).\n+  This also changes the safety conditions on `Layout::from_size_align_unchecked`.\n+- [`PollFn` now only implements `Unpin` if the closure is `Unpin`](https://github.com/rust-lang/rust/pull/102737).\n+  This is a possible breaking change if users were relying on the blanket unpin implementation.\n+  See discussion on the PR for details of why this change was made.\n+- [Drop ExactSizeIterator impl from std::char::EscapeAscii](https://github.com/rust-lang/rust/pull/99880)\n+  This is a backwards-incompatible change to the standard library's surface\n+  area, but is unlikely to affect real world usage.\n+- [Do not consider a single repeated lifetime eligible for elision in the return type](https://github.com/rust-lang/rust/pull/103450)\n+  This behavior was unintentionally changed in 1.64.0, and this release reverts that change by making this an error again.\n+- [Reenable disabled early syntax gates as future-incompatibility lints](https://github.com/rust-lang/rust/pull/99935/)\n+- [Update the minimum external LLVM to 13](https://github.com/rust-lang/rust/pull/100460/)\n+- [Don't duplicate file descriptors into stdio fds](https://github.com/rust-lang/rust/pull/101426/)\n+- [Sunset RLS](https://github.com/rust-lang/rust/pull/100863/)\n+- [Deny usage of `#![cfg_attr(..., crate_type = ...)]` to set the crate type](https://github.com/rust-lang/rust/pull/99784/)\n+  This strengthens the forward compatibility lint deprecated_cfg_attr_crate_type_name to deny.\n+- [`llvm-has-rust-patches` allows setting the build system to treat the LLVM as having Rust-specific patches](https://github.com/rust-lang/rust/pull/101072)\n+  This option may need to be set for distributions that are building Rust with a patched LLVM via `llvm-config`, not the built-in LLVM.\n+- Combining three or more languages (e.g. Objective C, C++ and Rust) into one binary may hit linker limitations when using `lld`. For more information, see [issue 102754][102754].\n+\n+[102754]: https://github.com/rust-lang/rust/issues/102754\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Add `x.sh` and `x.ps1` shell scripts](https://github.com/rust-lang/rust/pull/99992/)\n+- [compiletest: use target cfg instead of hard-coded tables](https://github.com/rust-lang/rust/pull/100260/)\n+- [Use object instead of LLVM for reading bitcode from rlibs](https://github.com/rust-lang/rust/pull/98100/)\n+- [Enable MIR inlining for optimized compilations](https://github.com/rust-lang/rust/pull/91743)\n+  This provides a 3-10% improvement in compiletimes for real world crates. See [perf results](https://perf.rust-lang.org/compare.html?start=aedf78e56b2279cc869962feac5153b6ba7001ed&end=0075bb4fad68e64b6d1be06bf2db366c30bc75e1&stat=instructions:u).\n+\n Version 1.64.0 (2022-09-22)\n ===========================\n "}, {"sha": "e21c9b660444083c001c5ca26c6087d956157a36", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![feature(unix_sigpipe)]\n+\n // A note about jemalloc: rustc uses jemalloc when built for CI and\n // distribution. The obvious way to do this is with the `#[global_allocator]`\n // mechanism. However, for complicated reasons (see\n@@ -23,6 +25,7 @@\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n \n+#[unix_sigpipe = \"sig_dfl\"]\n fn main() {\n     // See the comment at the top of this file for an explanation of this.\n     #[cfg(feature = \"jemalloc-sys\")]\n@@ -58,6 +61,5 @@ fn main() {\n         }\n     }\n \n-    rustc_driver::set_sigpipe_handler();\n     rustc_driver::main()\n }"}, {"sha": "9253b7e6891a25db4592b74ce72c513da14482bb", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -14,5 +14,5 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "2cbab90aa61a2ca9b657661095b8d0054ff378bb", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -392,15 +392,7 @@ pub struct Generics {\n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() -> Generics {\n-        Generics {\n-            params: Vec::new(),\n-            where_clause: WhereClause {\n-                has_where_token: false,\n-                predicates: Vec::new(),\n-                span: DUMMY_SP,\n-            },\n-            span: DUMMY_SP,\n-        }\n+        Generics { params: Vec::new(), where_clause: Default::default(), span: DUMMY_SP }\n     }\n }\n \n@@ -415,6 +407,12 @@ pub struct WhereClause {\n     pub span: Span,\n }\n \n+impl Default for WhereClause {\n+    fn default() -> WhereClause {\n+        WhereClause { has_where_token: false, predicates: Vec::new(), span: DUMMY_SP }\n+    }\n+}\n+\n /// A single predicate in a where-clause.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {\n@@ -1112,24 +1110,6 @@ pub struct Expr {\n }\n \n impl Expr {\n-    /// Returns `true` if this expression would be valid somewhere that expects a value;\n-    /// for example, an `if` condition.\n-    pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block, _) = self.kind {\n-            match block.stmts.last().map(|last_stmt| &last_stmt.kind) {\n-                // Implicit return\n-                Some(StmtKind::Expr(_)) => true,\n-                // Last statement is an explicit return?\n-                Some(StmtKind::Semi(expr)) => matches!(expr.kind, ExprKind::Ret(_)),\n-                // This is a block that doesn't end in either an implicit or explicit return.\n-                _ => false,\n-            }\n-        } else {\n-            // This is not a block, it is a value.\n-            true\n-        }\n-    }\n-\n     /// Is this expr either `N`, or `{ N }`.\n     ///\n     /// If this is not the case, name resolution does not resolve `N` when using\n@@ -1226,7 +1206,7 @@ impl Expr {\n             ExprKind::Tup(_) => ExprPrecedence::Tup,\n             ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n             ExprKind::Unary(..) => ExprPrecedence::Unary,\n-            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Lit(_) | ExprKind::IncludedBytes(..) => ExprPrecedence::Lit,\n             ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n             ExprKind::Let(..) => ExprPrecedence::Let,\n             ExprKind::If(..) => ExprPrecedence::If,\n@@ -1464,6 +1444,12 @@ pub enum ExprKind {\n     /// with an optional value to be returned.\n     Yeet(Option<P<Expr>>),\n \n+    /// Bytes included via `include_bytes!`\n+    /// Added for optimization purposes to avoid the need to escape\n+    /// large binary blobs - should always behave like [`ExprKind::Lit`]\n+    /// with a `ByteStr` literal.\n+    IncludedBytes(Lrc<[u8]>),\n+\n     /// Placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n }"}, {"sha": "9c1dfeb1a61428920e20e4ac69f61e9913701094", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -29,6 +29,7 @@ extern crate rustc_macros;\n extern crate tracing;\n \n pub mod util {\n+    pub mod case;\n     pub mod classify;\n     pub mod comments;\n     pub mod literal;"}, {"sha": "3ab8267263d116506ba99ab75cc0e7096675dfc6", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -152,6 +152,12 @@ pub trait MutVisitor: Sized {\n         noop_visit_expr(e, self);\n     }\n \n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &mut P<Expr>) {\n+        self.visit_expr(ex)\n+    }\n+\n     fn filter_map_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n         noop_filter_map_expr(e, self)\n     }\n@@ -1301,7 +1307,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n             visit_opt(args, |args| vis.visit_generic_args(args));\n-            vis.visit_expr(receiver);\n+            vis.visit_method_receiver_expr(receiver);\n             visit_exprs(exprs, vis);\n             vis.visit_span(span);\n         }\n@@ -1422,7 +1428,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::Try(expr) => vis.visit_expr(expr),\n         ExprKind::TryBlock(body) => vis.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n     vis.visit_id(id);\n     vis.visit_span(span);\n@@ -1589,3 +1595,9 @@ impl DummyAstNode for Crate {\n         }\n     }\n }\n+\n+impl<N: DummyAstNode, T: DummyAstNode> DummyAstNode for crate::ast_traits::AstNodeWrapper<N, T> {\n+    fn dummy() -> Self {\n+        crate::ast_traits::AstNodeWrapper::new(N::dummy(), T::dummy())\n+    }\n+}"}, {"sha": "f6aac0b55f1ab56c391159e517f3dc92f6aa45f0", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,6 +5,7 @@ pub use TokenKind::*;\n \n use crate::ast;\n use crate::ptr::P;\n+use crate::util::case::Case;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -615,6 +616,15 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n+    /// Returns `true` if the token is a given keyword, `kw` or if `case` is `Insensitive` and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case: Case) -> bool {\n+        self.is_keyword(kw)\n+            || (case == Case::Insensitive\n+                && self.is_non_raw_ident_where(|id| {\n+                    id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n+                }))\n+    }\n+\n     pub fn is_path_segment_keyword(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }"}, {"sha": "1afd7dea7408ecb9c247e101ac7f4f951c636cf3", "filename": "compiler/rustc_ast/src/util/case.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcase.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -0,0 +1,6 @@\n+/// Whatever to ignore case (`fn` vs `Fn` vs `FN`) or not. Used for recovering.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub enum Case {\n+    Sensitive,\n+    Insensitive,\n+}"}, {"sha": "e267f8cd10027d349f8dacb4a8d808cc88df76f9", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -2,12 +2,10 @@\n \n use crate::ast::{self, Lit, LitKind};\n use crate::token::{self, Token};\n-\n-use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-\n use std::ascii;\n \n pub enum LitError {\n@@ -109,13 +107,11 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n-                    match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(err) => {\n-                            if err.is_fatal() {\n-                                error = Err(LitError::LexerError);\n-                            }\n+                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                    Ok(c) => buf.push(byte_from_char(c)),\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n                         }\n                     }\n                 });\n@@ -127,13 +123,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n-                        match unescaped_byte {\n-                            Ok(c) => buf.push(c),\n-                            Err(err) => {\n-                                if err.is_fatal() {\n-                                    error = Err(LitError::LexerError);\n-                                }\n+                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                        Ok(c) => buf.push(byte_from_char(c)),\n+                        Err(err) => {\n+                            if err.is_fatal() {\n+                                error = Err(LitError::LexerError);\n                             }\n                         }\n                     });\n@@ -238,6 +232,13 @@ impl Lit {\n         Lit { token_lit: kind.to_token_lit(), kind, span }\n     }\n \n+    /// Recovers an AST literal from a string of bytes produced by `include_bytes!`.\n+    /// This requires ASCII-escaping the string, which can result in poor performance\n+    /// for very large strings of bytes.\n+    pub fn from_included_bytes(bytes: &Lrc<[u8]>, span: Span) -> Lit {\n+        Self::from_lit_kind(LitKind::ByteStr(bytes.clone()), span)\n+    }\n+\n     /// Losslessly convert an AST literal into a token.\n     pub fn to_token(&self) -> Token {\n         let kind = match self.token_lit.kind {"}, {"sha": "da0545ce80c373f3e94ddd4c4a6c08b70333b2db", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -140,6 +140,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) {\n         walk_expr(self, ex)\n     }\n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &'ast Expr) {\n+        self.visit_expr(ex)\n+    }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) {}\n     fn visit_ty(&mut self, t: &'ast Ty) {\n         walk_ty(self, t)\n@@ -246,7 +251,7 @@ pub trait Visitor<'ast>: Sized {\n macro_rules! walk_list {\n     ($visitor: expr, $method: ident, $list: expr $(, $($extra_args: expr),* )?) => {\n         {\n-            #[cfg_attr(not(bootstrap), allow(for_loops_over_fallibles))]\n+            #[allow(for_loops_over_fallibles)]\n             for elem in $list {\n                 $visitor.$method(elem $(, $($extra_args,)* )?)\n             }\n@@ -896,7 +901,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        ExprKind::Lit(_) | ExprKind::IncludedBytes(..) | ExprKind::Err => {}\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "6a59b9e6151ce13554f9901e95e88ca75d06153d", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -21,5 +21,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "21c6a2d26f4c2e54f95ba1e0b99c6c8ac0dac71e", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -277,8 +277,9 @@ pub struct RegisterConflict<'a> {\n pub struct SubTupleBinding<'a> {\n     #[primary_span]\n     #[label]\n-    #[suggestion_verbose(\n+    #[suggestion(\n         ast_lowering_sub_tuple_binding_suggestion,\n+        style = \"verbose\",\n         code = \"..\",\n         applicability = \"maybe-incorrect\"\n     )]"}, {"sha": "a4ae493af86bf6a23fc3b0df42d6138c6454e85d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -87,6 +87,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::Lit(ref l) => {\n                     hir::ExprKind::Lit(respan(self.lower_span(l.span), l.kind.clone()))\n                 }\n+                ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n+                    self.lower_span(e.span),\n+                    LitKind::ByteStr(bytes.clone()),\n+                )),\n                 ExprKind::Cast(ref expr, ref ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty ="}, {"sha": "f1851d7b40ea27a4dae8f979300d4e1892bc926d", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -112,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id.def_id);\n+        self.insert_nested(item.owner_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id.def_id);\n+        self.insert_nested(foreign_id.owner_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n@@ -143,7 +143,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n-        debug_assert_eq!(i.def_id, self.owner);\n+        debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n@@ -157,7 +157,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        debug_assert_eq!(fi.def_id, self.owner);\n+        debug_assert_eq!(fi.owner_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n@@ -176,15 +176,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        debug_assert_eq!(ti.def_id, self.owner);\n+        debug_assert_eq!(ti.owner_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        debug_assert_eq!(ii.def_id, self.owner);\n+        debug_assert_eq!(ii.owner_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });"}, {"sha": "76316a574acb7033c2311b45e32d06a84e9f3a2d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n-            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n+            smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -195,7 +195,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n@@ -206,7 +206,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                 }\n             }\n@@ -220,7 +220,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, vis_span, &i.kind);\n         let item = hir::Item {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis_span,\n@@ -562,7 +562,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_id },\n+                            owner_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -640,7 +640,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_hir_id },\n+                            owner_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -660,10 +660,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n-        let def_id = hir_id.expect_owner();\n+        let owner_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ForeignItem {\n-            def_id,\n+            owner_id,\n             ident: self.lower_ident(i.ident),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n@@ -702,7 +702,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ForeignItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -845,7 +845,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n-            def_id: trait_item_def_id,\n+            owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -864,7 +864,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n+        let id = hir::TraitItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -931,7 +931,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -944,7 +944,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ImplItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {"}, {"sha": "ff29d15f1b525aae9208cd40bcbc5b15adef37ed", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1574,7 +1574,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n         hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             lifetimes,\n             in_trait,\n         )\n@@ -1593,7 +1593,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: hir::OwnerId { def_id: opaque_ty_id },\n+            owner_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -2044,7 +2044,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             generic_args,\n             in_trait,\n         );"}, {"sha": "7fdfc79164b48fba2142824f1b829ace1af07094", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -323,7 +323,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // ```\n     fn lower_expr_within_pat(&mut self, expr: &Expr, allow_paths: bool) -> &'hir hir::Expr<'hir> {\n         match expr.kind {\n-            ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Err => {}\n+            ExprKind::Lit(..)\n+            | ExprKind::ConstBlock(..)\n+            | ExprKind::IncludedBytes(..)\n+            | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {"}, {"sha": "c6955741fd4c2961be0d6b732910770783c9fbf9", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -191,7 +191,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Ok => {\n+                        self.lower_parenthesized_parameter_data(data, itctx)\n+                    }\n                     ParenthesizedGenericArgs::Err => {\n                         // Suggest replacing parentheses with angle brackets `Trait(params...)` to `Trait<params...>`\n                         let sub = if !data.inputs.is_empty() {\n@@ -344,6 +346,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n+        itctx: &ImplTraitContext,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n@@ -355,6 +358,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_ty_direct(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n         }));\n         let output_ty = match output {\n+            // Only allow `impl Trait` in return position. i.e.:\n+            // ```rust\n+            // fn f(_: impl Fn() -> impl Debug) -> impl Fn() -> impl Debug\n+            // //      disallowed --^^^^^^^^^^        allowed --^^^^^^^^^^\n+            // ```\n+            FnRetTy::Ty(ty)\n+                if matches!(itctx, ImplTraitContext::ReturnPositionOpaqueTy { .. })\n+                    && self.tcx.features().impl_trait_in_fn_trait_return =>\n+            {\n+                self.lower_ty(&ty, itctx)\n+            }\n             FnRetTy::Ty(ty) => {\n                 self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n             }"}, {"sha": "712fb5ac71f976c80ce84d9e06a996762fab9921", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1051,6 +1051,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n \n                     walk_list!(this, visit_assoc_item, items, AssocCtxt::Impl);\n                 });\n+                walk_list!(self, visit_attribute, &item.attrs);\n                 return; // Avoid visiting again.\n             }\n             ItemKind::Impl(box Impl {\n@@ -1168,7 +1169,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 });\n                 walk_list!(self, visit_assoc_item, items, AssocCtxt::Trait);\n                 walk_list!(self, visit_attribute, &item.attrs);\n-                return;\n+                return; // Avoid visiting again\n             }\n             ItemKind::Mod(unsafety, ref mod_kind) => {\n                 if let Unsafe::Yes(span) = unsafety {"}, {"sha": "546010135a72532fa0324c2adbaa4bc1a16781c6", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n-use rustc_ast::{PatKind, RangeEnd, VariantData};\n+use rustc_ast::{PatKind, RangeEnd};\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n@@ -116,46 +116,6 @@ impl<'a> PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn maybe_report_invalid_custom_discriminants(&self, variants: &[ast::Variant]) {\n-        let has_fields = variants.iter().any(|variant| match variant.data {\n-            VariantData::Tuple(..) | VariantData::Struct(..) => true,\n-            VariantData::Unit(..) => false,\n-        });\n-\n-        let discriminant_spans = variants\n-            .iter()\n-            .filter(|variant| match variant.data {\n-                VariantData::Tuple(..) | VariantData::Struct(..) => false,\n-                VariantData::Unit(..) => true,\n-            })\n-            .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n-            .collect::<Vec<_>>();\n-\n-        if !discriminant_spans.is_empty() && has_fields {\n-            let mut err = feature_err(\n-                &self.sess.parse_sess,\n-                sym::arbitrary_enum_discriminant,\n-                discriminant_spans.clone(),\n-                \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n-            );\n-            for sp in discriminant_spans {\n-                err.span_label(sp, \"disallowed custom discriminant\");\n-            }\n-            for variant in variants.iter() {\n-                match &variant.data {\n-                    VariantData::Struct(..) => {\n-                        err.span_label(variant.span, \"struct variant defined here\");\n-                    }\n-                    VariantData::Tuple(..) => {\n-                        err.span_label(variant.span, \"tuple variant defined here\");\n-                    }\n-                    VariantData::Unit(..) => {}\n-                }\n-            }\n-            err.emit();\n-        }\n-    }\n-\n     /// Feature gate `impl Trait` inside `type Alias = $type_expr;`.\n     fn check_impl_trait(&self, ty: &ast::Ty) {\n         struct ImplTraitVisitor<'a> {\n@@ -273,26 +233,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Enum(ast::EnumDef { ref variants, .. }, ..) => {\n-                for variant in variants {\n-                    match (&variant.data, &variant.disr_expr) {\n-                        (ast::VariantData::Unit(..), _) => {}\n-                        (_, Some(disr_expr)) => gate_feature_post!(\n-                            &self,\n-                            arbitrary_enum_discriminant,\n-                            disr_expr.value.span,\n-                            \"discriminants on non-unit variants are experimental\"\n-                        ),\n-                        _ => {}\n-                    }\n-                }\n-\n-                let has_feature = self.features.arbitrary_enum_discriminant;\n-                if !has_feature && !i.span.allows_unstable(sym::arbitrary_enum_discriminant) {\n-                    self.maybe_report_invalid_custom_discriminants(&variants);\n-                }\n-            }\n-\n             ast::ItemKind::Impl(box ast::Impl { polarity, defaultness, ref of_trait, .. }) => {\n                 if let ast::ImplPolarity::Negative(span) = polarity {\n                     gate_feature_post!("}, {"sha": "930276242c3c361f9e72f525348ff09335ba5031", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -322,6 +322,10 @@ impl<'a> State<'a> {\n             ast::ExprKind::Lit(ref lit) => {\n                 self.print_literal(lit);\n             }\n+            ast::ExprKind::IncludedBytes(ref bytes) => {\n+                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n+                self.print_literal(&lit)\n+            }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 let prec = AssocOp::As.precedence() as i8;\n                 self.print_expr_maybe_paren(expr, prec);"}, {"sha": "563ff056ae467245b67f5bacee32f7c2b5817ff0", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;"}, {"sha": "01be379120dc7483c088daa4005b744bb386dfb8", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -8,9 +8,18 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     pub(crate) fn cannot_move_when_borrowed(\n         &self,\n         span: Span,\n-        desc: &str,\n+        borrow_span: Span,\n+        place: &str,\n+        borrow_place: &str,\n+        value_place: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n+        self.infcx.tcx.sess.create_err(crate::session_diagnostics::MoveBorrow {\n+            place,\n+            span,\n+            borrow_place,\n+            value_place,\n+            borrow_span,\n+        })\n     }\n \n     pub(crate) fn cannot_use_when_mutably_borrowed("}, {"sha": "11b31c3f14028e72dbe20df6d6e3db3a6ec21f1a", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::visit::TyContext;\n use rustc_middle::mir::visit::Visitor;"}, {"sha": "385f153174c3c2a9170b7b41957d67682efe0e17", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -163,6 +163,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n                 span: DUMMY_SP,\n                 category: ConstraintCategory::Internal,\n                 variance_info: VarianceDiagInfo::default(),\n+                from_closure: false,\n             })\n         } else {\n             None"}, {"sha": "84a93e5f72e9dd3b508782306ea15fc46d653995", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n@@ -92,10 +95,13 @@ pub struct OutlivesConstraint<'tcx> {\n     pub span: Span,\n \n     /// What caused this constraint?\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,\n+\n+    /// If this constraint is promoted from closure requirements.\n+    pub from_closure: bool,\n }\n \n impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {"}, {"sha": "86da767f322738fae52365b52cc0366d1b6fe311", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;"}, {"sha": "8070c0e6710ee0e1288cb9a0284fab5d47f8617f", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, Place};"}, {"sha": "8e62a0198be46987733c4ad7c0608aff65cc84bf", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_middle::mir::visit::{\n     MutatingUseContext, NonMutatingUseContext, NonUseContext, PlaceContext,\n };"}, {"sha": "b99bfda1a51fe661c6366505486bca5d9c8f76b8", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,18 +1,21 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_infer::infer::region_constraints::Constraint;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n-use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::RegionVid;\n use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n-use rustc_trait_selection::traits::{SelectionContext, TraitEngineExt as _};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_traits::{type_op_ascribe_user_type_with_span, type_op_prove_predicate_with_cause};\n \n use std::fmt;\n@@ -158,6 +161,7 @@ trait TypeOpInfo<'tcx> {\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n \n+    #[instrument(level = \"debug\", skip(self, mbcx))]\n     fn report_error(\n         &self,\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n@@ -167,6 +171,7 @@ trait TypeOpInfo<'tcx> {\n     ) {\n         let tcx = mbcx.infcx.tcx;\n         let base_universe = self.base_universe();\n+        debug!(?base_universe);\n \n         let Some(adjusted_universe) =\n             placeholder.universe.as_u32().checked_sub(base_universe.as_u32())\n@@ -240,9 +245,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_prove_predicate_with_cause(&ocx, key, cause);\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -281,9 +286,7 @@ where\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-        let mut selcx = SelectionContext::new(infcx);\n+        let ocx = ObligationCtxt::new(infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -292,11 +295,9 @@ where\n         // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n         // after #85499 lands to see if its fixes have erased this difference.\n         let (param_env, value) = key.into_parts();\n-        let Normalized { value: _, obligations } =\n-            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n-        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+        let _ = ocx.normalize(cause, param_env, value.value);\n \n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -329,9 +330,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         let (ref infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n-        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n+        let ocx = ObligationCtxt::new(infcx);\n+        type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n }\n \n@@ -372,28 +373,28 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n     }\n }\n \n-#[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n+#[instrument(skip(ocx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n-    mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n-    let _errors = fulfill_cx.select_all_or_error(infcx);\n-    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    let _errors = ocx.select_all_or_error();\n+    let region_constraints = ocx.infcx.with_region_constraints(|r| r.clone());\n     try_extract_error_from_region_constraints(\n-        infcx,\n+        ocx.infcx,\n         placeholder_region,\n         error_region,\n         &region_constraints,\n-        |vid| infcx.region_var_origin(vid),\n-        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+        |vid| ocx.infcx.region_var_origin(vid),\n+        |vid| ocx.infcx.universe_of_region(ocx.infcx.tcx.mk_region(ty::ReVar(vid))),\n     )\n }\n \n+#[instrument(level = \"debug\", skip(infcx, region_var_origin, universe_of_region))]\n fn try_extract_error_from_region_constraints<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,"}, {"sha": "9e0aa57b2553fba87dfbab9ef2f19689da0a12ce", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -23,7 +23,6 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -225,10 +224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n \n-            use_spans.var_span_label_path_only(\n-                &mut err,\n-                format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-            );\n+            use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n             if !is_loop_move {\n                 err.span_label(\n@@ -405,10 +401,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let used = desired_action.as_general_verb_in_past_tense();\n         let mut err =\n             struct_span_err!(self, span, E0381, \"{used} binding {desc}{isnt_initialized}\");\n-        use_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"{} occurs due to use{}\", desired_action.as_noun(), use_spans.describe()),\n-        );\n+        use_spans.var_path_only_subdiag(&mut err, desired_action);\n \n         if let InitializationRequiringAction::PartialAssignment\n         | InitializationRequiringAction::Assignment = desired_action\n@@ -613,24 +606,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n         let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n         let cause = ObligationCause::new(\n             span,\n             self.mir_hir_id(),\n             rustc_infer::traits::ObligationCauseCode::MiscObligation,\n         );\n-        fulfill_cx.register_bound(\n+        let errors = rustc_trait_selection::traits::fully_solve_bound(\n             &infcx,\n+            cause,\n             self.param_env,\n             // Erase any region vids from the type, which may not be resolved\n             infcx.tcx.erase_regions(ty),\n             copy_did,\n-            cause,\n         );\n-        // Select all, including ambiguous predicates\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors\n@@ -678,16 +667,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let move_spans = self.move_spans(place.as_ref(), location);\n         let span = move_spans.args_or_use();\n \n-        let mut err =\n-            self.cannot_move_when_borrowed(span, &self.describe_any_place(place.as_ref()));\n-        err.span_label(borrow_span, format!(\"borrow of {} occurs here\", borrow_msg));\n-        err.span_label(span, format!(\"move out of {} occurs here\", value_msg));\n-\n-        borrow_spans.var_span_label_path_only(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", borrow_spans.describe()),\n+        let mut err = self.cannot_move_when_borrowed(\n+            span,\n+            borrow_span,\n+            &self.describe_any_place(place.as_ref()),\n+            &borrow_msg,\n+            &value_msg,\n         );\n \n+        borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n+\n         move_spans.var_span_label(\n             &mut err,\n             format!(\"move occurs due to use{}\", move_spans.describe()),\n@@ -729,16 +718,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-\n-        borrow_spans.var_span_label(\n-            &mut err,\n-            {\n-                let place = &borrow.borrowed_place;\n-                let desc_place = self.describe_any_place(place.as_ref());\n-                format!(\"borrow occurs due to use of {}{}\", desc_place, borrow_spans.describe())\n-            },\n-            \"mutable\",\n-        );\n+        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            let place = &borrow.borrowed_place;\n+            let desc_place = self.describe_any_place(place.as_ref());\n+            match kind {\n+                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n@@ -983,7 +971,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err: &mut Diagnostic,\n         location: Location,\n         issued_borrow: &BorrowData<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) {\n         let used_in_call = matches!(\n             explanation,\n@@ -1333,7 +1321,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n@@ -1539,7 +1527,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n-        explanation: BorrowExplanation,\n+        explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n@@ -1556,7 +1544,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         let mut err = self.temporary_value_borrowed_for_too_long(proper_span);\n-        err.span_label(proper_span, \"creates a temporary which is freed while still in use\");\n+        err.span_label(proper_span, \"creates a temporary value which is freed while still in use\");\n         err.span_label(drop_span, \"temporary value is freed at the end of this statement\");\n \n         match explanation {\n@@ -1653,7 +1641,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         borrow_span: Span,\n         return_span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx, ErrorGuaranteed>> {\n         let return_kind = match category {\n@@ -1748,7 +1736,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraint_span: Span,\n         captured_var: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {"}, {"sha": "582d683dd359320679164d3aff5c75991122b2a7", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -21,7 +21,7 @@ use crate::{\n use super::{find_use, RegionName, UseSpans};\n \n #[derive(Debug)]\n-pub(crate) enum BorrowExplanation {\n+pub(crate) enum BorrowExplanation<'tcx> {\n     UsedLater(LaterUseKind, Span, Option<Span>),\n     UsedLaterInLoop(LaterUseKind, Span, Option<Span>),\n     UsedLaterWhenDropped {\n@@ -30,7 +30,7 @@ pub(crate) enum BorrowExplanation {\n         should_note_order: bool,\n     },\n     MustBeValidFor {\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         from_closure: bool,\n         span: Span,\n         region_name: RegionName,\n@@ -49,7 +49,7 @@ pub(crate) enum LaterUseKind {\n     Other,\n }\n \n-impl<'tcx> BorrowExplanation {\n+impl<'tcx> BorrowExplanation<'tcx> {\n     pub(crate) fn is_explained(&self) -> bool {\n         !matches!(self, BorrowExplanation::Unexplained)\n     }\n@@ -284,7 +284,7 @@ impl<'tcx> BorrowExplanation {\n     fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n         err: &mut Diagnostic,\n-        category: &ConstraintCategory,\n+        category: &ConstraintCategory<'tcx>,\n         span: Span,\n         region_name: &RegionName,\n     ) {\n@@ -316,7 +316,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n         let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n             borrow_region,\n             NllRegionVariableOrigin::FreeRegion,\n@@ -348,7 +348,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n-    ) -> BorrowExplanation {\n+    ) -> BorrowExplanation<'tcx> {\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;"}, {"sha": "498e9834354b7ff851da549230f7b2707ef43c28", "filename": "compiler/rustc_borrowck/src/diagnostics/find_all_local_uses.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_all_local_uses.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::BTreeSet;\n \n use rustc_middle::mir::visit::{PlaceContext, Visitor};"}, {"sha": "15f42e26cbf4a7aeca1bac947ac0b58b4836c3aa", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use std::collections::VecDeque;\n use std::rc::Rc;\n "}, {"sha": "7f26af67c71b214485777b90ea0e97029650bafb", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -595,11 +595,34 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    // Add a span label to the use of the captured variable, if it exists.\n-    // only adds label to the `path_span`\n-    pub(super) fn var_span_label_path_only(self, err: &mut Diagnostic, message: impl Into<String>) {\n-        if let UseSpans::ClosureUse { path_span, .. } = self {\n-            err.span_label(path_span, message);\n+    /// Add a span label to the use of the captured variable, if it exists.\n+    /// only adds label to the `path_span`\n+    pub(super) fn var_path_only_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        action: crate::InitializationRequiringAction,\n+    ) {\n+        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n+        use crate::InitializationRequiringAction::*;\n+        if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n+            match generator_kind {\n+                Some(_) => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInGenerator { path_span },\n+                        MatchOn | Use => UseInGenerator { path_span },\n+                        Assignment => AssignInGenerator { path_span },\n+                        PartialAssignment => AssignPartInGenerator { path_span },\n+                    });\n+                }\n+                None => {\n+                    err.subdiagnostic(match action {\n+                        Borrow => BorrowInClosure { path_span },\n+                        MatchOn | Use => UseInClosure { path_span },\n+                        Assignment => AssignInClosure { path_span },\n+                        PartialAssignment => AssignPartInClosure { path_span },\n+                    });\n+                }\n+            }\n         }\n     }\n \n@@ -623,6 +646,35 @@ impl UseSpans<'_> {\n         }\n     }\n \n+    /// Add a subdiagnostic to the use of the captured variable, if it exists.\n+    pub(super) fn var_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        kind: Option<rustc_middle::mir::BorrowKind>,\n+        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n+    ) {\n+        use crate::session_diagnostics::CaptureVarKind::*;\n+        if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n+            if capture_kind_span != path_span {\n+                err.subdiagnostic(match kind {\n+                    Some(kd) => match kd {\n+                        rustc_middle::mir::BorrowKind::Shared\n+                        | rustc_middle::mir::BorrowKind::Shallow\n+                        | rustc_middle::mir::BorrowKind::Unique => {\n+                            Immute { kind_span: capture_kind_span }\n+                        }\n+\n+                        rustc_middle::mir::BorrowKind::Mut { .. } => {\n+                            Mut { kind_span: capture_kind_span }\n+                        }\n+                    },\n+                    None => Move { kind_span: capture_kind_span },\n+                });\n+            };\n+            err.subdiagnostic(f(generator_kind, path_span));\n+        }\n+    }\n+\n     /// Returns `false` if this place is not used in a closure.\n     pub(super) fn for_closure(&self) -> bool {\n         match *self {"}, {"sha": "7457369aa58cb42bad748f68492f6d9c79462e88", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,6 +1,4 @@\n-use rustc_errors::{\n-    Applicability, Diagnostic, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed,\n-};\n+use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n@@ -629,25 +627,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         self.buffer_error(err);\n     }\n \n-    fn suggest_map_index_mut_alternatives(\n-        &self,\n-        ty: Ty<'_>,\n-        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n-        span: Span,\n-    ) {\n+    fn suggest_map_index_mut_alternatives(&self, ty: Ty<'tcx>, err: &mut Diagnostic, span: Span) {\n         let Some(adt) = ty.ty_adt_def() else { return };\n         let did = adt.did();\n         if self.infcx.tcx.is_diagnostic_item(sym::HashMap, did)\n             || self.infcx.tcx.is_diagnostic_item(sym::BTreeMap, did)\n         {\n-            struct V<'a, 'b, 'tcx, G: EmissionGuarantee> {\n+            struct V<'a, 'tcx> {\n                 assign_span: Span,\n-                err: &'a mut DiagnosticBuilder<'b, G>,\n+                err: &'a mut Diagnostic,\n                 ty: Ty<'tcx>,\n                 suggested: bool,\n             }\n-            impl<'a, 'b: 'a, 'hir, 'tcx, G: EmissionGuarantee> Visitor<'hir> for V<'a, 'b, 'tcx, G> {\n-                fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'hir>) {\n+            impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+                fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n                     hir::intravisit::walk_stmt(self, stmt);\n                     let expr = match stmt.kind {\n                         hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n@@ -705,7 +698,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                     ),\n                                     (rv.span.shrink_to_hi(), \")\".to_string()),\n                                 ],\n-                            ].into_iter(),\n+                            ],\n                             Applicability::MachineApplicable,\n                         );\n                         self.suggested = true;"}, {"sha": "35c3df768995a0d2907db1cb174122666596a9cc", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -161,7 +161,7 @@ impl OutlivesSuggestionBuilder {\n     pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'_>,\n         diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note."}, {"sha": "76f249dac5181439f4a437402e0d0aa68a38eb0a", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -2,8 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n-use either::Either;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n@@ -17,7 +16,7 @@ use rustc_infer::infer::{\n     NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n-use rustc_middle::mir::{ConstraintCategory, ReturnConstraint, TerminatorKind};\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n@@ -40,7 +39,7 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-impl ConstraintDescription for ConstraintCategory {\n+impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n@@ -116,15 +115,15 @@ pub(crate) enum RegionErrorKind<'tcx> {\n \n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n-pub struct ErrorConstraintInfo {\n+pub struct ErrorConstraintInfo<'tcx> {\n     // fr: outlived_fr\n     pub(super) fr: RegionVid,\n     pub(super) fr_is_local: bool,\n     pub(super) outlived_fr: RegionVid,\n     pub(super) outlived_fr_is_local: bool,\n \n     // Category and span for best blame constraint\n-    pub(super) category: ConstraintCategory,\n+    pub(super) category: ConstraintCategory<'tcx>,\n     pub(super) span: Span,\n }\n \n@@ -182,7 +181,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     // Try to convert the lower-bound region into something named we can print for the user.\n                     let lower_bound_region = self.to_error_region(type_test.lower_bound);\n \n-                    let type_test_span = type_test.locations.span(&self.body);\n+                    let type_test_span = type_test.span;\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n@@ -277,7 +276,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,\n-        trait_objects: &FxHashSet<DefId>,\n+        trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.infcx.tcx;\n         match tcx.hir().get_if_local(def_id) {\n@@ -499,7 +498,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n         kind: ReturnConstraint,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n@@ -572,7 +571,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n@@ -676,7 +675,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errci: &ErrorConstraintInfo,\n+        errci: &ErrorConstraintInfo<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo {\n             fr,\n@@ -789,20 +788,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag: &mut Diagnostic,\n         f: Region<'tcx>,\n         o: Region<'tcx>,\n-        category: &ConstraintCategory,\n+        category: &ConstraintCategory<'tcx>,\n     ) {\n         if !o.is_static() {\n             return;\n         }\n \n         let tcx = self.infcx.tcx;\n \n-        let instance =\n-            if let ConstraintCategory::CallArgument(location) = category\n-                && let Either::Right(term) = self.body.stmt_at(*location)\n-                && let TerminatorKind::Call { func, .. } = &term.kind\n-        {\n-            let func_ty = func.ty(self.body, tcx);\n+        let instance = if let ConstraintCategory::CallArgument(Some(func_ty)) = category {\n             let (fn_did, substs) = match func_ty.kind() {\n                 ty::FnDef(fn_did, substs) => (fn_did, substs),\n                 _ => return,\n@@ -836,7 +830,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         debug!(?param);\n \n-        let mut visitor = TraitObjectVisitor(FxHashSet::default());\n+        let mut visitor = TraitObjectVisitor(FxIndexSet::default());\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n@@ -849,7 +843,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n         err: &mut Diagnostic,\n-        found_dids: &FxHashSet<DefId>,\n+        found_dids: &FxIndexSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,\n     ) -> bool {"}, {"sha": "f9741bacd17028bf46d0d7f04a9c61f7b8feca6a", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 93, "deletions": 9, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -251,7 +251,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr));\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n         if let Some(ref value) = value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n@@ -354,7 +355,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     })\n                 }\n \n-                ty::BoundRegionKind::BrAnon(_) => None,\n+                ty::BoundRegionKind::BrAnon(..) => None,\n             },\n \n             ty::ReLateBound(..) | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReErased => None,\n@@ -869,13 +870,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             return None;\n         }\n \n-        let mut found = false;\n-        tcx.fold_regions(tcx.type_of(region_parent), |r: ty::Region<'tcx>, _| {\n-            if *r == ty::ReEarlyBound(region) {\n-                found = true;\n-            }\n-            r\n-        });\n+        let found = tcx\n+            .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));\n \n         Some(RegionName {\n             name: self.synthesize_region_name(),\n@@ -888,4 +884,92 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             ),\n         })\n     }\n+\n+    fn give_name_if_anonymous_region_appears_in_arg_position_impl_trait(\n+        &self,\n+        fr: RegionVid,\n+    ) -> Option<RegionName> {\n+        let ty::ReEarlyBound(region) = *self.to_error_region(fr)? else {\n+            return None;\n+        };\n+        if region.has_name() {\n+            return None;\n+        };\n+\n+        let predicates = self\n+            .infcx\n+            .tcx\n+            .predicates_of(self.body.source.def_id())\n+            .instantiate_identity(self.infcx.tcx)\n+            .predicates;\n+\n+        if let Some(upvar_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .defining_ty\n+            .upvar_tys()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, ty, region))\n+        {\n+            let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n+                self.infcx.tcx,\n+                &self.upvars,\n+                upvar_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name),\n+            })\n+        } else if let Some(arg_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .unnormalized_input_tys\n+            .iter()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, *ty, region))\n+        {\n+            let (arg_name, arg_span) = self.regioncx.get_argument_name_and_span_for_region(\n+                self.body,\n+                &self.local_names,\n+                arg_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromArgument(\n+                    RegionNameHighlight::CannotMatchHirTy(arg_span, arg_name?.to_string()),\n+                ),\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn any_param_predicate_mentions(\n+        &self,\n+        predicates: &[ty::Predicate<'tcx>],\n+        ty: Ty<'tcx>,\n+        region: ty::EarlyBoundRegion,\n+    ) -> bool {\n+        let tcx = self.infcx.tcx;\n+        ty.walk().any(|arg| {\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Param(_) = ty.kind()\n+            {\n+                predicates.iter().any(|pred| {\n+                    match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(data) if data.self_ty() == ty => {}\n+                        ty::PredicateKind::Projection(data) if data.projection_ty.self_ty() == ty => {}\n+                        _ => return false,\n+                    }\n+                    tcx.any_free_region_meets(pred, |r| {\n+                        *r == ty::ReEarlyBound(region)\n+                    })\n+                })\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }"}, {"sha": "b385f95b67c6f992a12841c02b77b7bed01b8f35", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,6 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+\n use crate::Upvar;\n use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n use rustc_index::vec::{Idx, IndexVec};"}, {"sha": "51ed27c167d3844971e445036bb0a4584524e210", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::location::{LocationIndex, LocationTable};\n use crate::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusFacts;"}, {"sha": "f5317a143aed7157d0801da0e688c7bd7a090246", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, NonDivergingIntrinsic, Place, Rvalue};"}, {"sha": "4a4887f19702f91149c053108308eaf0333c77d0", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -18,6 +18,7 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -129,6 +130,19 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+\n+    if input_body.borrow().should_skip() {\n+        debug!(\"Skipping borrowck because of injected body\");\n+        // Let's make up a borrowck result! Fun times!\n+        let result = BorrowCheckResult {\n+            concrete_opaque_types: VecMap::new(),\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+            tainted_by_errors: None,\n+        };\n+        return tcx.arena.alloc(result);\n+    }\n+\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n     let infcx ="}, {"sha": "9fa7e218b1b6f65ceb09a92420043f5f823f41f1", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::{BasicBlock, Body, Location};\n "}, {"sha": "b48f9f97daad8d76dc07b541f445206f55fa7e8c", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;"}, {"sha": "f8856b56d140bae139a7d069159b8bb813b28dd6", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n use rustc_data_structures::vec_map::VecMap;\n@@ -242,7 +244,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         mut liveness_constraints,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n     } = constraints;\n@@ -264,7 +265,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n         liveness_constraints,"}, {"sha": "f8a99a2699e6ff0cf3c89c3c62ab576f6278e72c", "filename": "compiler/rustc_borrowck/src/path_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::places_conflict;\n use crate::AccessDepth;"}, {"sha": "9f6b1fdfcb54085853bb49c34a070b95c3358ec7", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::borrow_set::LocalsStateAtExit;\n use rustc_hir as hir;\n use rustc_middle::mir::ProjectionElem;"}, {"sha": "8a87d1972ebf35613c8673285a0e43880112a666", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::ArtificialField;\n use crate::Overlap;\n use crate::{AccessDepth, Deep, Shallow};"}, {"sha": "6f281349863763f0cbb578f0a93102ef6ec19b81", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n //! place are formed by stripping away fields and derefs, except that\n //! we stop when we reach the deref of a shared reference. [...] \""}, {"sha": "6524b594e44dc02083d629688966c151ae0965c5", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! As part of generating the regions, if you enable `-Zdump-mir=nll`,\n //! we will generate an annotated copy of the MIR that includes the\n //! state of region inference. This code handles emitting the region\n@@ -74,8 +76,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort_by_key(|c| (c.sup, c.sub));\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category, span, variance_info: _ } =\n-                constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, span, .. } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "2e15586e03b3bb49ec35331d11cdeaa9d9026b25", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This module provides linkage between RegionInferenceContext and\n //! `rustc_graphviz` traits, specialized to attaching borrowck analysis\n //! data to rendered labels."}, {"sha": "94e9e05e5d640936be66ffb5bec23018b3d0a82f", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 19, "deletions": 147, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,10 +6,9 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n@@ -19,9 +18,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::{\n-    self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_span::Span;\n \n use crate::{\n@@ -89,10 +86,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// `member_region_scc`.\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n-    /// Map closure bounds to a `Span` that should be used for error reporting.\n-    closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n-\n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -221,8 +214,8 @@ pub struct TypeTest<'tcx> {\n     /// The region `'x` that the type must outlive.\n     pub lower_bound: RegionVid,\n \n-    /// Where did this constraint arise and why?\n-    pub locations: Locations,\n+    /// The span to blame.\n+    pub span: Span,\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n@@ -265,10 +258,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        closure_bounds_mapping: FxHashMap<\n-            Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n-        >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n@@ -310,7 +299,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n-            closure_bounds_mapping,\n             universe_causes,\n             scc_universes,\n             scc_representatives,\n@@ -882,13 +870,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if deduplicate_errors.insert((\n                 erased_generic_kind,\n                 type_test.lower_bound,\n-                type_test.locations,\n+                type_test.span,\n             )) {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n-                     type_test.locations={:?}\",\n-                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n+                     type_test.span={:?}\",\n+                    erased_generic_kind, type_test.lower_bound, type_test.span,\n                 );\n \n                 errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n@@ -931,7 +919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n+        let TypeTest { generic_kind, lower_bound, span: _, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let Some(subject) = self.try_promote_type_test_subject(infcx, generic_ty) else {\n@@ -959,7 +947,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                 subject,\n                 outlived_free_region: static_r,\n-                blame_span: locations.span(body),\n+                blame_span: type_test.span,\n                 category: ConstraintCategory::Boring,\n             });\n \n@@ -1011,7 +999,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let requirement = ClosureOutlivesRequirement {\n                     subject,\n                     outlived_free_region: upper_bound,\n-                    blame_span: locations.span(body),\n+                    blame_span: type_test.span,\n                     category: ConstraintCategory::Boring,\n                 };\n                 debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n@@ -1804,25 +1792,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn retrieve_closure_constraint_info(\n-        &self,\n-        constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory, Span)> {\n-        match constraint.locations {\n-            Locations::All(_) => None,\n-            Locations::Single(loc) => {\n-                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n-            }\n-        }\n-    }\n-\n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n-    ) -> (ConstraintCategory, ObligationCause<'tcx>) {\n+    ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n         let BlameConstraint { category, cause, .. } = self\n             .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n             .0;\n@@ -1921,6 +1897,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span: p_c.definition_span,\n                     category: ConstraintCategory::OpaqueType,\n                     variance_info: ty::VarianceDiagInfo::default(),\n+                    from_closure: false,\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -2066,31 +2043,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n-            .map(|constraint| {\n-                let (category, span, from_closure, cause_code) =\n-                    if constraint.category == ConstraintCategory::ClosureBounds {\n-                        if let Some((category, span)) =\n-                            self.retrieve_closure_constraint_info(*constraint)\n-                        {\n-                            (category, span, true, ObligationCauseCode::MiscObligation)\n-                        } else {\n-                            (\n-                                constraint.category,\n-                                constraint.span,\n-                                false,\n-                                ObligationCauseCode::MiscObligation,\n-                            )\n-                        }\n-                    } else {\n-                        (constraint.category, constraint.span, false, cause_code.clone())\n-                    };\n-                BlameConstraint {\n-                    category,\n-                    from_closure,\n-                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n-                    variance_info: constraint.variance_info,\n-                    outlives_constraint: *constraint,\n-                }\n+            .map(|constraint| BlameConstraint {\n+                category: constraint.category,\n+                from_closure: constraint.from_closure,\n+                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                variance_info: constraint.variance_info,\n+                outlives_constraint: *constraint,\n             })\n             .collect();\n         debug!(\"categorized_path={:#?}\", categorized_path);\n@@ -2274,95 +2232,9 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'tcx> {\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n-}\n-\n-impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n-    /// Given an instance T of the closure type, this method\n-    /// instantiates the \"extra\" requirements that we computed for the\n-    /// closure into the inference context. This has the effect of\n-    /// adding new outlives obligations to existing variables.\n-    ///\n-    /// As described on `ClosureRegionRequirements`, the extra\n-    /// requirements are expressed in terms of regionvids that index\n-    /// into the free regions that appear on the closure type. So, to\n-    /// do this, we first copy those regions out from the type T into\n-    /// a vector. Then we can just index into that vector to extract\n-    /// out the corresponding region from T and apply the\n-    /// requirements.\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n-        debug!(\n-            \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n-            closure_def_id, closure_substs\n-        );\n-\n-        // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n-        // relating to one another.\n-        let closure_mapping = &UniversalRegions::closure_mapping(\n-            tcx,\n-            closure_substs,\n-            self.num_external_vids,\n-            tcx.typeck_root_def_id(closure_def_id),\n-        );\n-        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n-\n-        // Create the predicates.\n-        self.outlives_requirements\n-            .iter()\n-            .map(|outlives_requirement| {\n-                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-                match outlives_requirement.subject {\n-                    ClosureOutlivesSubject::Region(region) => {\n-                        let region = closure_mapping[region];\n-                        debug!(\n-                            \"apply_requirements: region={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            region, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(\n-                                region.into(),\n-                                outlived_region,\n-                            )),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-\n-                    ClosureOutlivesSubject::Ty(ty) => {\n-                        debug!(\n-                            \"apply_requirements: ty={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            ty, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n-    pub category: ConstraintCategory,\n+    pub category: ConstraintCategory<'tcx>,\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,"}, {"sha": "dd222485daf2c01b3188ff5abaa564065fa69246", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,15 +4,15 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use super::RegionInferenceContext;\n \n@@ -252,50 +252,45 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // type-alias-impl-trait/issue-67844-nested-opaque.rs\n         let infcx =\n             self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n         // hidden type is well formed even without those bounds.\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n             .to_predicate(infcx.tcx);\n-        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n-        match infcx.register_hidden_type(\n-            OpaqueTypeKey { def_id, substs: id_substs },\n-            ObligationCause::misc(instantiated_ty.span, body_id),\n+        let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n+        if let Err(err) = ocx.eq(\n+            &ObligationCause::misc(instantiated_ty.span, body_id),\n             param_env,\n+            opaque_ty,\n             definition_ty,\n-            origin,\n         ) {\n-            Ok(infer_ok) => {\n-                for obligation in infer_ok.obligations {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                }\n-            }\n-            Err(err) => {\n-                infcx\n-                    .err_ctxt()\n-                    .report_mismatched_types(\n-                        &ObligationCause::misc(instantiated_ty.span, body_id),\n-                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                        definition_ty,\n-                        err,\n-                    )\n-                    .emit();\n-            }\n+            infcx\n+                .err_ctxt()\n+                .report_mismatched_types(\n+                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                    opaque_ty,\n+                    definition_ty,\n+                    err,\n+                )\n+                .emit();\n         }\n \n-        fulfillment_cx.register_predicate_obligation(\n-            &infcx,\n-            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-        );\n+        ocx.register_obligation(Obligation::misc(\n+            instantiated_ty.span,\n+            body_id,\n+            param_env,\n+            predicate,\n+        ));\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n \n         // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n         // tests to pass\n@@ -304,8 +299,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if errors.is_empty() {\n             definition_ty\n         } else {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            self.tcx.ty_error()\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            self.tcx.ty_error_with_guaranteed(reported)\n         }\n     }\n }"}, {"sha": "167f664609698e8b26011e134c887d85855f7e79", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use crate::constraints::ConstraintSccIndex;\n use crate::RegionInferenceContext;\n use itertools::Itertools;"}, {"sha": "7498ddccf196a1fc136f07cac6e20768c606ce60", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::SparseBitMatrix;\n use rustc_index::interval::IntervalSet;"}, {"sha": "084754830bdbfa8dda894e2f0621e6dd7ebe575d", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};"}, {"sha": "577332c0744b84dd8447af7ab3519a33ef18abe0", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -49,7 +49,7 @@ pub(crate) struct GenericDoesNotLiveLongEnough {\n #[derive(LintDiagnostic)]\n #[diag(borrowck_var_does_not_need_mut)]\n pub(crate) struct VarNeedNotMut {\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n #[derive(Diagnostic)]\n@@ -148,3 +148,95 @@ pub(crate) enum RequireStaticErr {\n         multi_span: MultiSpan,\n     },\n }\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarPathUseCause {\n+    #[label(borrowck_borrow_due_to_use_generator)]\n+    BorrowInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_generator)]\n+    UseInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_generator)]\n+    AssignInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_generator)]\n+    AssignPartInGenerator {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_borrow_due_to_use_closure)]\n+    BorrowInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_use_due_to_use_closure)]\n+    UseInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_due_to_use_closure)]\n+    AssignInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+    #[label(borrowck_assign_part_due_to_use_closure)]\n+    AssignPartInClosure {\n+        #[primary_span]\n+        path_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarKind {\n+    #[label(borrowck_capture_immute)]\n+    Immute {\n+        #[primary_span]\n+        kind_span: Span,\n+    },\n+    #[label(borrowck_capture_mut)]\n+    Mut {\n+        #[primary_span]\n+        kind_span: Span,\n+    },\n+    #[label(borrowck_capture_move)]\n+    Move {\n+        #[primary_span]\n+        kind_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarCause {\n+    #[label(borrowck_var_borrow_by_use_place_in_generator)]\n+    BorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_place_in_closure)]\n+    BorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(borrowck_cannot_move_when_borrowed, code = \"E0505\")]\n+pub(crate) struct MoveBorrow<'a> {\n+    pub place: &'a str,\n+    pub borrow_place: &'a str,\n+    pub value_place: &'a str,\n+    #[primary_span]\n+    #[label(move_label)]\n+    pub span: Span,\n+    #[label]\n+    pub borrow_span: Span,\n+}"}, {"sha": "a581726a15c9c4ff6bfc77e9d241074a365b3a62", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         op: Op,\n     ) -> Fallible<R>\n     where\n@@ -85,7 +85,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         trait_ref: ty::TraitRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         for predicate in predicates {\n             let predicate = predicate.to_predicate(self.tcx());\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicate: ty::Predicate<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n@@ -164,7 +164,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         value: T,\n         location: impl NormalizeLocation,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,"}, {"sha": "ce7f857e27310aa64b01f6d2529c08cd96ff00de", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 65, "deletions": 25, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,10 +1,10 @@\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, ConstraintCategory};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -37,7 +37,8 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     span: Span,\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n+    from_closure: bool,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -50,7 +51,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         span: Span,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {\n@@ -64,6 +65,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             span,\n             category,\n             constraints,\n+            from_closure: false,\n         }\n     }\n \n@@ -81,30 +83,70 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for query_constraint in outlives {\n-            self.convert(query_constraint);\n+        for (predicate, constraint_category) in outlives {\n+            // At the moment, we never generate any \"higher-ranked\"\n+            // region constraints like `for<'a> 'a: 'b`. At some point\n+            // when we move to universes, we will, and this assertion\n+            // will start to fail.\n+            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n+            });\n+\n+            self.convert(predicate, *constraint_category);\n+        }\n+    }\n+\n+    /// Given an instance of the closure type, this method instantiates the \"extra\" requirements\n+    /// that we computed for the closure. This has the effect of adding new outlives obligations\n+    /// to existing region variables in `closure_substs`.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn apply_closure_requirements(\n+        &mut self,\n+        closure_requirements: &ClosureRegionRequirements<'tcx>,\n+        closure_def_id: DefId,\n+        closure_substs: ty::SubstsRef<'tcx>,\n+    ) {\n+        // Extract the values of the free regions in `closure_substs`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping = &UniversalRegions::closure_mapping(\n+            self.tcx,\n+            closure_substs,\n+            closure_requirements.num_external_vids,\n+            closure_def_id.expect_local(),\n+        );\n+        debug!(?closure_mapping);\n+\n+        // Create the predicates.\n+        let backup = (self.category, self.span, self.from_closure);\n+        self.from_closure = true;\n+        for outlives_requirement in &closure_requirements.outlives_requirements {\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            let subject = match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n+                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+            };\n+\n+            self.category = outlives_requirement.category;\n+            self.span = outlives_requirement.blame_span;\n+            self.convert(ty::OutlivesPredicate(subject, outlived_region), self.category);\n         }\n+        (self.category, self.span, self.from_closure) = backup;\n     }\n \n-    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    fn convert(\n+        &mut self,\n+        predicate: ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>,\n+        constraint_category: ConstraintCategory<'tcx>,\n+    ) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n         let ConstraintConversion {\n             tcx, region_bound_pairs, implicit_region_bound, param_env, ..\n         } = *self;\n \n-        // At the moment, we never generate any \"higher-ranked\"\n-        // region constraints like `for<'a> 'a: 'b`. At some point\n-        // when we move to universes, we will, and this assertion\n-        // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-            });\n-\n-        let constraint_category = query_constraint.1;\n-\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n@@ -127,10 +169,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n-            GenericArgKind::Const(_) => {\n-                // Consts cannot outlive one another, so we\n-                // don't need to handle any relations here.\n-            }\n+            GenericArgKind::Const(_) => unreachable!(),\n         }\n     }\n \n@@ -160,7 +199,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n-        TypeTest { generic_kind, lower_bound, locations: self.locations, verify_bound }\n+        TypeTest { generic_kind, lower_bound, span: self.span, verify_bound }\n     }\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n@@ -175,7 +214,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         &mut self,\n         sup: ty::RegionVid,\n         sub: ty::RegionVid,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) {\n         let category = match self.category {\n             ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n@@ -188,6 +227,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             sub,\n             sup,\n             variance_info: ty::VarianceDiagInfo::default(),\n+            from_closure: self.from_closure,\n         });\n     }\n \n@@ -203,7 +243,7 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory,\n+        constraint_category: ConstraintCategory<'tcx>,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);"}, {"sha": "14cfc3613bf0c890357dc20e8e4d4db2846f41aa", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -247,12 +247,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n                     .unwrap_or_else(|_| {\n-                        self.infcx\n+                        let reported = self\n+                            .infcx\n                             .tcx\n                             .sess\n                             .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                         TypeOpOutput {\n-                            output: self.infcx.tcx.ty_error(),\n+                            output: self.infcx.tcx.ty_error_with_guaranteed(reported),\n                             constraints: None,\n                             error_info: None,\n                         }"}, {"sha": "6ccc29b09c0a5d9646acb03f130f29ec579530a0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 35, "deletions": 95, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n //! This pass type-checks the MIR to ensure it is not broken.\n \n use std::rc::Rc;\n@@ -27,7 +29,7 @@ use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n+use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n@@ -61,7 +63,7 @@ use crate::{\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n-    region_infer::{ClosureRegionRequirementsExt, TypeTest},\n+    region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n     Upvar,\n@@ -144,7 +146,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n-        closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n         universe_causes: FxHashMap::default(),\n     };\n@@ -234,11 +235,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n             trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n             if hidden_type.has_non_region_infer() {\n-                infcx.tcx.sess.delay_span_bug(\n+                let reported = infcx.tcx.sess.delay_span_bug(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                 );\n-                hidden_type.ty = infcx.tcx.ty_error();\n+                hidden_type.ty = infcx.tcx.ty_error_with_guaranteed(reported);\n             }\n \n             (opaque_type_key, (hidden_type, decl.origin))\n@@ -584,8 +585,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n-        let mut type_tests = Default::default();\n-        let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n         // Don't try to add borrow_region facts for the promoted MIR\n@@ -596,11 +595,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n                 &mut constraints,\n             );\n-            mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n-            mem::swap(\n-                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n-                &mut closure_bounds,\n-            );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.liveness_constraints,\n                 &mut liveness_constraints,\n@@ -621,13 +615,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         swap_constraints(self);\n \n         let locations = location.to_locations();\n-\n-        // Use location of promoted const in collected constraints\n-        for type_test in type_tests.iter() {\n-            let mut type_test = type_test.clone();\n-            type_test.locations = locations;\n-            self.cx.borrowck_context.constraints.type_tests.push(type_test)\n-        }\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = constraint.clone();\n             constraint.locations = locations;\n@@ -653,18 +640,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     .add_element(region, location);\n             }\n         }\n-\n-        if !closure_bounds.is_empty() {\n-            let combined_bounds_mapping =\n-                closure_bounds.into_iter().flat_map(|(_, value)| value).collect();\n-            let existing = self\n-                .cx\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, combined_bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple promoteds/closures at the same location.\");\n-        }\n     }\n \n     fn sanitize_projection(\n@@ -941,9 +916,6 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n-\n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n@@ -1133,7 +1105,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\"constraints generated: {:#?}\", data);\n@@ -1158,7 +1130,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         // Use this order of parameters because the sup type is usually the\n         // \"expected\" type in diagnostics.\n@@ -1171,7 +1143,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n@@ -1183,7 +1155,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         user_ty: &UserTypeProjection,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n@@ -1618,12 +1590,19 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n \n+        let func_ty = if let TerminatorKind::Call { func, .. } = &term.kind {\n+            Some(func.ty(body, self.infcx.tcx))\n+        } else {\n+            None\n+        };\n+        debug!(?func_ty);\n+\n         for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n \n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {\n-                ConstraintCategory::CallArgument(term_location)\n+                ConstraintCategory::CallArgument(self.infcx.tcx.erase_regions(func_ty))\n             } else {\n                 ConstraintCategory::Boring\n             };\n@@ -1776,7 +1755,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);\n-        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx, self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough\n@@ -2555,6 +2534,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 span: location.to_locations().span(body),\n                                 category,\n                                 variance_info: ty::VarianceDiagInfo::default(),\n+                                from_closure: false,\n                             });\n \n                             match mutbl {\n@@ -2672,62 +2652,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = QueryRegionConstraints {\n-                outlives: closure_region_requirements.apply_requirements(\n-                    tcx,\n-                    def_id.to_def_id(),\n-                    substs,\n-                ),\n-\n-                // Presently, closures never propagate member\n-                // constraints to their parents -- they are enforced\n-                // locally.  This is largely a non-issue as member\n-                // constraints only come from `-> impl Trait` and\n-                // friends which don't appear (thus far...) in\n-                // closures.\n-                member_constraints: vec![],\n-            };\n-\n-            let bounds_mapping = closure_constraints\n-                .outlives\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(idx, constraint)| {\n-                    let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                        });\n-\n-                    match k1.unpack() {\n-                        GenericArgKind::Lifetime(r1) => {\n-                            // constraint is r1: r2\n-                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n-                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n-                            let outlives_requirements =\n-                                &closure_region_requirements.outlives_requirements[idx];\n-                            Some((\n-                                (r1_vid, r2_vid),\n-                                (outlives_requirements.category, outlives_requirements.blame_span),\n-                            ))\n-                        }\n-                        GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                    }\n-                })\n-                .collect();\n-\n-            let existing = self\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple closures at the same location.\");\n-\n-            self.push_region_constraints(\n+        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx,\n+                self.borrowck_context.universal_regions,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n                 location.to_locations(),\n-                ConstraintCategory::ClosureBounds,\n-                &closure_constraints,\n+                DUMMY_SP,                   // irrelevant; will be overrided.\n+                ConstraintCategory::Boring, // same as above.\n+                &mut self.borrowck_context.constraints,\n+            )\n+            .apply_closure_requirements(\n+                &closure_requirements,\n+                def_id.to_def_id(),\n+                substs,\n             );\n         }\n "}, {"sha": "94d51032866098954d19b99b974014e9b6189625", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,6 +1,6 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         b: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         a: ty::SubstsRef<'tcx>,\n         b: ty::SubstsRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -64,7 +64,7 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     locations: Locations,\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n-    category: ConstraintCategory,\n+    category: ConstraintCategory<'tcx>,\n \n     /// Information so that error reporting knows what types we are relating\n     /// when reporting a bound region error.\n@@ -75,7 +75,7 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n         type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory,\n+        category: ConstraintCategory<'tcx>,\n         universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n         Self { type_checker, locations, category, universe_info }\n@@ -136,6 +136,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 span: self.locations.span(self.type_checker.body),\n                 category: self.category,\n                 variance_info: info,\n+                from_closure: false,\n             },\n         );\n     }\n@@ -155,27 +156,16 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type(\n+    fn register_opaque_type_obligations(\n         &mut self,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        a_is_expected: bool,\n+        obligations: PredicateObligations<'tcx>,\n     ) -> Result<(), TypeError<'tcx>> {\n-        let param_env = self.param_env();\n-        let span = self.span();\n-        let def_id = self.type_checker.body.source.def_id().expect_local();\n-        let body_id = self.type_checker.tcx().hir().local_def_id_to_hir_id(def_id);\n-        let cause = ObligationCause::misc(span, body_id);\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n                 self.category,\n                 InstantiateOpaqueType {\n-                    obligations: self\n-                        .type_checker\n-                        .infcx\n-                        .handle_opaque_type(a, b, a_is_expected, &cause, param_env)?\n-                        .obligations,\n+                    obligations,\n                     // These fields are filled in during execution of the operation\n                     base_universe: None,\n                     region_constraints: None,"}, {"sha": "618da9e3253252886807c2413eb32a57a5d55af4", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 93, "deletions": 34, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -22,7 +22,9 @@ use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n+use rustc_middle::ty::{\n+    self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n+};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use std::iter;\n \n@@ -241,15 +243,15 @@ impl<'tcx> UniversalRegions<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         closure_substs: SubstsRef<'tcx>,\n         expected_num_vars: usize,\n-        typeck_root_def_id: DefId,\n+        closure_def_id: LocalDefId,\n     ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n         let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n         region_mapping.push(tcx.lifetimes.re_static);\n         tcx.for_each_free_region(&closure_substs, |fr| {\n             region_mapping.push(fr);\n         });\n \n-        for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_recursive_scope(tcx, tcx.local_parent(closure_def_id), |r| {\n             region_mapping.push(r);\n         });\n \n@@ -339,9 +341,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // tests, and the resulting print-outs include def-ids\n                 // and other things that are not stable across tests!\n                 // So we just include the region-vid. Annoying.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::Generator(def_id, substs, _) => {\n@@ -354,9 +355,8 @@ impl<'tcx> UniversalRegions<'tcx> {\n                 // FIXME: As above, we'd like to print out the region\n                 // `r` but doing so is not stable across architectures\n                 // and so forth.\n-                let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-                for_each_late_bound_region_defined_on(tcx, typeck_root_def_id, |r| {\n-                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r),));\n+                for_each_late_bound_region_in_recursive_scope(tcx, def_id.expect_local(), |r| {\n+                    err.note(&format!(\"late-bound region is {:?}\", self.to_region_vid(r)));\n                 });\n             }\n             DefiningTy::FnDef(def_id, substs) => {\n@@ -421,13 +421,24 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             first_extern_index\n         } else {\n             // If this is a closure, generator, or inline-const, then the late-bound regions from the enclosing\n-            // function are actually external regions to us. For example, here, 'a is not local\n+            // function/closures are actually external regions to us. For example, here, 'a is not local\n             // to the closure c (although it is local to the fn foo):\n             // fn foo<'a>() {\n             //     let c = || { let x: &'a u32 = ...; }\n             // }\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n+            for_each_late_bound_region_in_recursive_scope(\n+                self.infcx.tcx,\n+                self.infcx.tcx.local_parent(self.mir_def.did),\n+                |r| {\n+                    debug!(?r);\n+                    if !indices.indices.contains_key(&r) {\n+                        let region_vid = self.infcx.next_nll_region_var(FR);\n+                        debug!(?region_vid);\n+                        indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+                    }\n+                },\n+            );\n+\n             // Any regions created during the execution of `defining_ty` or during the above\n             // late-bound region replacement are all considered 'extern' regions\n             self.infcx.num_region_vars()\n@@ -444,12 +455,16 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             bound_inputs_and_output,\n             &mut indices,\n         );\n-        // Converse of above, if this is a function then the late-bound regions declared on its\n-        // signature are local to the fn.\n-        if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-            self.infcx\n-                .replace_late_bound_regions_with_nll_infer_vars(self.mir_def.did, &mut indices);\n-        }\n+        // Converse of above, if this is a function/closure then the late-bound regions declared on its\n+        // signature are local.\n+        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.infcx.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n \n         let (unnormalized_output_ty, mut unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n@@ -692,7 +707,13 @@ trait InferCtxtExt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>;\n \n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    );\n+\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n@@ -746,13 +767,28 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n     #[instrument(skip(self, indices))]\n-    fn replace_late_bound_regions_with_nll_infer_vars(\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    ) {\n+        for_each_late_bound_region_in_recursive_scope(self.tcx, mir_def_id, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let region_vid = self.next_nll_region_var(FR);\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n+    }\n+\n+    #[instrument(skip(self, indices))]\n+    fn replace_late_bound_regions_with_nll_infer_vars_in_item(\n         &self,\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n-        let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n-        for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n+        for_each_late_bound_region_in_item(self.tcx, mir_def_id, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n@@ -803,21 +839,44 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n }\n \n-/// Iterates over the late-bound regions defined on fn_def_id and\n-/// invokes `f` with the liberated form of each one.\n-fn for_each_late_bound_region_defined_on<'tcx>(\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_recursive_scope<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    fn_def_id: DefId,\n+    mut mir_def_id: LocalDefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n-        for &region_def_id in late_bounds.iter() {\n-            let name = tcx.item_name(region_def_id.to_def_id());\n-            let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: fn_def_id,\n-                bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n-            }));\n-            f(liberated_region);\n+    let typeck_root_def_id = tcx.typeck_root_def_id(mir_def_id.to_def_id());\n+\n+    // Walk up the tree, collecting late-bound regions until we hit the typeck root\n+    loop {\n+        for_each_late_bound_region_in_item(tcx, mir_def_id, &mut f);\n+\n+        if mir_def_id.to_def_id() == typeck_root_def_id {\n+            break;\n+        } else {\n+            mir_def_id = tcx.local_parent(mir_def_id);\n         }\n     }\n }\n+\n+/// Iterates over the late-bound regions defined on `mir_def_id` and all of its\n+/// parents, up to the typeck root, and invokes `f` with the liberated form\n+/// of each one.\n+fn for_each_late_bound_region_in_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mir_def_id: LocalDefId,\n+    mut f: impl FnMut(ty::Region<'tcx>),\n+) {\n+    if !tcx.def_kind(mir_def_id).is_fn_like() {\n+        return;\n+    }\n+\n+    for bound_var in tcx.late_bound_vars(tcx.hir().local_def_id_to_hir_id(mir_def_id)) {\n+        let ty::BoundVariableKind::Region(bound_region) = bound_var else { continue; };\n+        let liberated_region = tcx\n+            .mk_region(ty::ReFree(ty::FreeRegion { scope: mir_def_id.to_def_id(), bound_region }));\n+        f(liberated_region);\n+    }\n+}"}, {"sha": "e297b1230ea0c58b2bf273cc8dbf886c9e495cb4", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{"}, {"sha": "467fa932a1567c49eaf9fb927002da8bf95dc44d", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -23,5 +23,5 @@ rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "eaf1b1167cf21863153e14be1900acf6220f9e68", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -0,0 +1,104 @@\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, FnHeader, FnSig, Generics, StmtKind};\n+use rustc_ast::{Fn, ItemKind, Stmt, TyKind, Unsafe};\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Span;\n+use thin_vec::thin_vec;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n+\n+    let orig_item = item.clone();\n+    let not_function = || {\n+        ecx.sess\n+            .parse_sess\n+            .span_diagnostic\n+            .span_err(item.span(), \"alloc_error_handler must be a function\");\n+        vec![orig_item.clone()]\n+    };\n+\n+    // Allow using `#[alloc_error_handler]` on an item statement\n+    // FIXME - if we get deref patterns, use them to reduce duplication here\n+    let (item, is_stmt, sig_span) = match &item {\n+        Annotatable::Item(item) => match item.kind {\n+            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n+            _ => return not_function(),\n+        },\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            StmtKind::Item(item_) => match item_.kind {\n+                ItemKind::Fn(ref fn_kind) => {\n+                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+                }\n+                _ => return not_function(),\n+            },\n+            _ => return not_function(),\n+        },\n+        _ => return not_function(),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = ecx.with_def_site_ctxt(item.span);\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = vec![generate_handler(ecx, item.ident, span, sig_span)];\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(sig_span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item = ecx.item_const(span, Ident::new(kw::Underscore, span), const_ty, const_body);\n+    let const_item = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(span, const_item)))\n+    } else {\n+        Annotatable::Item(const_item)\n+    };\n+\n+    // Return the original item and the new methods.\n+    vec![orig_item, const_item]\n+}\n+\n+// #[rustc_std_internal_symbol]\n+// unsafe fn __rg_oom(size: usize, align: usize) -> ! {\n+//     handler(core::alloc::Layout::from_size_align_unchecked(size, align))\n+// }\n+fn generate_handler(cx: &ExtCtxt<'_>, handler: Ident, span: Span, sig_span: Span) -> Stmt {\n+    let usize = cx.path_ident(span, Ident::new(sym::usize, span));\n+    let ty_usize = cx.ty_path(usize);\n+    let size = Ident::from_str_and_span(\"size\", span);\n+    let align = Ident::from_str_and_span(\"align\", span);\n+\n+    let layout_new = cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n+    let layout_new = cx.expr_path(cx.path(span, layout_new));\n+    let layout =\n+        cx.expr_call(span, layout_new, vec![cx.expr_ident(span, size), cx.expr_ident(span, align)]);\n+\n+    let call = cx.expr_call_ident(sig_span, handler, vec![layout]);\n+\n+    let never = ast::FnRetTy::Ty(cx.ty(span, TyKind::Never));\n+    let params = vec![cx.param(span, size, ty_usize.clone()), cx.param(span, align, ty_usize)];\n+    let decl = cx.fn_decl(params, never);\n+    let header = FnHeader { unsafety: Unsafe::Yes(span), ..FnHeader::default() };\n+    let sig = FnSig { decl, header, span: span };\n+\n+    let body = Some(cx.block_expr(call));\n+    let kind = ItemKind::Fn(Box::new(Fn {\n+        defaultness: ast::Defaultness::Final,\n+        sig,\n+        generics: Generics::default(),\n+        body,\n+    }));\n+\n+    let special = sym::rustc_std_internal_symbol;\n+    let special = cx.meta_word(span, special);\n+    let attrs = thin_vec![cx.attribute(special)];\n+\n+    let item = cx.item(span, Ident::from_str_and_span(\"__rg_oom\", span), attrs, kind);\n+    cx.stmt_item(sig_span, item)\n+}"}, {"sha": "f72cd14bea0436e574a7a0f90ee26af58552fe72", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -303,6 +303,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Field(_, _)\n             | ExprKind::ForLoop(_, _, _, _)\n             | ExprKind::If(_, _, _)\n+            | ExprKind::IncludedBytes(..)\n             | ExprKind::InlineAsm(_)\n             | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)"}, {"sha": "86df3c44eb334e7b51aa65ad268417f170162c4b", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -34,6 +34,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());"}, {"sha": "750f1fe121f6d90a368ee38a7a4f7b3bc0a1aa66", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -210,8 +210,15 @@ impl CfgEval<'_, '_> {\n }\n \n impl MutVisitor for CfgEval<'_, '_> {\n+    #[instrument(level = \"trace\", skip(self))]\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n+        self.cfg.configure_expr(expr, false);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr, true);\n         mut_visit::noop_visit_expr(expr, self);\n     }\n "}, {"sha": "01454d0e98e699cc14096654cc5c50ebd780f0d9", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -43,6 +43,9 @@ pub fn expand_concat(\n                     has_errors = true;\n                 }\n             },\n+            ast::ExprKind::IncludedBytes(..) => {\n+                cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n+            }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n             }"}, {"sha": "4886ca786a588bc5de61de819a1f49e4884bb25e", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -108,6 +108,16 @@ fn handle_array_element(\n                 None\n             }\n         },\n+        ast::ExprKind::IncludedBytes(..) => {\n+            if !*has_errors {\n+                cx.struct_span_err(expr.span, \"cannot concatenate doubly nested array\")\n+                    .note(\"byte strings are treated as arrays of bytes\")\n+                    .help(\"try flattening the array\")\n+                    .emit();\n+            }\n+            *has_errors = true;\n+            None\n+        }\n         _ => {\n             missing_literals.push(expr.span);\n             None\n@@ -167,6 +177,9 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n+            ast::ExprKind::IncludedBytes(ref bytes) => {\n+                accumulator.extend_from_slice(bytes);\n+            }\n             ast::ExprKind::Err => {\n                 has_errors = true;\n             }"}, {"sha": "01f237e6ab5fa3d085a9b1e09ab103bc31e97dc9", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n-pub(crate) struct Expander;\n+pub(crate) struct Expander(pub bool);\n \n impl MultiItemModifier for Expander {\n     fn expand(\n@@ -19,6 +19,7 @@ impl MultiItemModifier for Expander {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let sess = ecx.sess;\n         if report_bad_target(sess, &item, span) {\n@@ -58,20 +59,20 @@ impl MultiItemModifier for Expander {\n                         report_path_args(sess, &meta);\n                         meta.path\n                     })\n-                    .map(|path| (path, dummy_annotatable(), None))\n+                    .map(|path| (path, dummy_annotatable(), None, self.0))\n                     .collect();\n \n                 // Do not configure or clone items unless necessary.\n                 match &mut resolutions[..] {\n                     [] => {}\n-                    [(_, first_item, _), others @ ..] => {\n+                    [(_, first_item, ..), others @ ..] => {\n                         *first_item = cfg_eval(\n                             sess,\n                             features,\n                             item.clone(),\n                             ecx.current_expansion.lint_node_id,\n                         );\n-                        for (_, item, _) in others {\n+                        for (_, item, _, _) in others {\n                             *item = first_item.clone();\n                         }\n                     }"}, {"sha": "240167146e1f134c08cf93a1fe4514c53ff41a42", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,4 +1,3 @@\n-use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n@@ -12,16 +11,17 @@ pub fn expand_deriving_copy(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(marker::Copy),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push);"}, {"sha": "2f19fbcac7d72299f4d3218760960e765b803868", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_clone(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // The simple form is `fn clone(&self) -> Self { *self }`, possibly with\n     // some additional `AssertParamIsClone` assertions.\n@@ -74,7 +75,6 @@ pub fn expand_deriving_clone(\n         path: path_std!(clone::Clone),\n         skip_path_as_bound: false,\n         additional_bounds: bounds,\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::clone,\n@@ -87,6 +87,7 @@ pub fn expand_deriving_clone(\n             combine_substructure: substructure,\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand_ext(cx, mitem, item, push, is_simple)"}, {"sha": "a0b836171bea995b3cbe3424c619ddc81e465d9f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,6 +15,7 @@ pub fn expand_deriving_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let span = cx.with_def_site_ctxt(span);\n     let inline = cx.meta_word(span, sym::inline);\n@@ -27,7 +28,6 @@ pub fn expand_deriving_eq(\n         path: path_std!(cmp::Eq),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::assert_receiver_is_total_eq,\n@@ -42,6 +42,7 @@ pub fn expand_deriving_eq(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     super::inject_impl_of_structural_trait(cx, span, item, path_std!(marker::StructuralEq), push);"}, {"sha": "52780981248b9b8ba13eff913a6977e5bc1f45c6", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let inline = cx.meta_word(span, sym::inline);\n     let attrs = thin_vec![cx.attribute(inline)];\n@@ -21,7 +22,6 @@ pub fn expand_deriving_ord(\n         path: path_std!(cmp::Ord),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::cmp,\n@@ -34,6 +34,7 @@ pub fn expand_deriving_ord(\n             combine_substructure: combine_substructure(Box::new(|a, b, c| cs_cmp(a, b, c))),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "34de4a620b462b67d47a1332c22dfbbbdac4073e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -14,6 +14,7 @@ pub fn expand_deriving_partial_eq(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> BlockOrExpr {\n         let base = true;\n@@ -85,10 +86,10 @@ pub fn expand_deriving_partial_eq(\n         path: path_std!(cmp::PartialEq),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods,\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "6cc8f26df559c2b33d18782a5e62cc14c9d82d18", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_partial_ord(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let ordering_ty = Path(path_std!(cmp::Ordering));\n     let ret_ty =\n@@ -39,10 +40,10 @@ pub fn expand_deriving_partial_ord(\n         path: path_std!(cmp::PartialOrd),\n         skip_path_as_bound: false,\n         additional_bounds: vec![],\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "544d971b27a5d9473a375d0c2b692a16912fac6a", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_debug(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ref(Box::new(Path(path_std!(fmt::Formatter))), ast::Mutability::Mut);\n@@ -22,7 +23,6 @@ pub fn expand_deriving_debug(\n         path: path_std!(fmt::Debug),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::fmt,\n@@ -37,6 +37,7 @@ pub fn expand_deriving_debug(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "6d14875a9832293f7d238fdd7e525c385b57326a", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_rustc_decodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__D;\n@@ -25,7 +26,6 @@ pub fn expand_deriving_rustc_decodable(\n         path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::decode,\n@@ -55,6 +55,7 @@ pub fn expand_deriving_rustc_decodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "93f297ad88b5fc4dfc371512fee69a9ea99bce33", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_default(\n     mitem: &ast::MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     item.visit_with(&mut DetectNonVariantDefaultAttr { cx });\n \n@@ -26,7 +27,6 @@ pub fn expand_deriving_default(\n         path: Path::new(vec![kw::Default, sym::Default]),\n         skip_path_as_bound: has_a_default_variant(item),\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: kw::Default,\n@@ -47,6 +47,7 @@ pub fn expand_deriving_default(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n     trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "9a46ca815372653ab4696303896d31ea5a34cd5e", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -100,6 +100,7 @@ pub fn expand_deriving_rustc_encodable(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let krate = sym::rustc_serialize;\n     let typaram = sym::__S;\n@@ -109,7 +110,6 @@ pub fn expand_deriving_rustc_encodable(\n         path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::encode,\n@@ -139,6 +139,7 @@ pub fn expand_deriving_rustc_encodable(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "f48c49f411ce822c02222c6107b616044cb41507", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 35, "deletions": 40, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -171,7 +171,7 @@ use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use std::cell::RefCell;\n use std::iter;\n use std::ops::Not;\n@@ -195,15 +195,14 @@ pub struct TraitDef<'a> {\n     /// other than the current trait\n     pub additional_bounds: Vec<Ty>,\n \n-    /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n-    pub generics: Bounds,\n-\n     /// Can this trait be derived for unions?\n     pub supports_unions: bool,\n \n     pub methods: Vec<MethodDef<'a>>,\n \n     pub associated_types: Vec<(Ident, Ty)>,\n+\n+    pub is_const: bool,\n }\n \n pub struct MethodDef<'a> {\n@@ -581,19 +580,21 @@ impl<'a> TraitDef<'a> {\n             })\n         });\n \n-        let Generics { mut params, mut where_clause, .. } =\n-            self.generics.to_generics(cx, self.span, type_ident, generics);\n+        let mut where_clause = ast::WhereClause::default();\n         where_clause.span = generics.where_clause.span;\n         let ctxt = self.span.ctxt();\n         let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| match &param.kind {\n-            GenericParamKind::Lifetime { .. } => param.clone(),\n-            GenericParamKind::Type { .. } => {\n-                // I don't think this can be moved out of the loop, since\n-                // a GenericBound requires an ast id\n-                let bounds: Vec<_> =\n+        let params: Vec<_> = generics\n+            .params\n+            .iter()\n+            .map(|param| match &param.kind {\n+                GenericParamKind::Lifetime { .. } => param.clone(),\n+                GenericParamKind::Type { .. } => {\n+                    // I don't think this can be moved out of the loop, since\n+                    // a GenericBound requires an ast id\n+                    let bounds: Vec<_> =\n                     // extra restrictions on the generics parameters to the\n                     // type being derived upon\n                     self.additional_bounds.iter().map(|p| {\n@@ -606,21 +607,22 @@ impl<'a> TraitDef<'a> {\n                         param.bounds.iter().cloned()\n                     ).collect();\n \n-                cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n-            }\n-            GenericParamKind::Const { ty, kw_span, .. } => {\n-                let const_nodefault_kind = GenericParamKind::Const {\n-                    ty: ty.clone(),\n-                    kw_span: kw_span.with_ctxt(ctxt),\n-\n-                    // We can't have default values inside impl block\n-                    default: None,\n-                };\n-                let mut param_clone = param.clone();\n-                param_clone.kind = const_nodefault_kind;\n-                param_clone\n-            }\n-        }));\n+                    cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n+                }\n+                GenericParamKind::Const { ty, kw_span, .. } => {\n+                    let const_nodefault_kind = GenericParamKind::Const {\n+                        ty: ty.clone(),\n+                        kw_span: kw_span.with_ctxt(ctxt),\n+\n+                        // We can't have default values inside impl block\n+                        default: None,\n+                    };\n+                    let mut param_clone = param.clone();\n+                    param_clone.kind = const_nodefault_kind;\n+                    param_clone\n+                }\n+            })\n+            .collect();\n \n         // and similarly for where clauses\n         where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n@@ -730,7 +732,7 @@ impl<'a> TraitDef<'a> {\n                 unsafety: ast::Unsafe::No,\n                 polarity: ast::ImplPolarity::Positive,\n                 defaultness: ast::Defaultness::Final,\n-                constness: ast::Const::No,\n+                constness: if self.is_const { ast::Const::Yes(DUMMY_SP) } else { ast::Const::No },\n                 generics: trait_generics,\n                 of_trait: opt_trait_ref,\n                 self_ty: self_type,\n@@ -1060,18 +1062,15 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n             mk_body(cx, selflike_fields)\n         } else {\n-            // Neither packed nor copy. Need to use ref patterns.\n+            // Packed and not copy. Need to use ref patterns.\n             let prefixes: Vec<_> =\n                 (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let addr_of = always_copy;\n-            let selflike_fields =\n-                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, addr_of);\n+            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let by_ref = ByRef::from(is_packed && !always_copy);\n             let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, by_ref);\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n@@ -1252,9 +1251,7 @@ impl<'a> MethodDef<'a> {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n \n-                let addr_of = false; // because enums can't be repr(packed)\n-                let fields =\n-                    trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes, addr_of);\n+                let fields = trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes);\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n@@ -1517,15 +1514,13 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        addr_of: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, _struct_field, sp| {\n             prefixes\n                 .iter()\n                 .map(|prefix| {\n                     let ident = self.mk_pattern_ident(prefix, i);\n-                    let expr = cx.expr_path(cx.path_ident(sp, ident));\n-                    if addr_of { cx.expr_addr_of(sp, expr) } else { expr }\n+                    cx.expr_path(cx.path_ident(sp, ident))\n                 })\n                 .collect()\n         })"}, {"sha": "c136bb7141ab9eef3f4b0896e20fc08a47816503", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,6 +13,7 @@ pub fn expand_deriving_hash(\n     mitem: &MetaItem,\n     item: &Annotatable,\n     push: &mut dyn FnMut(Annotatable),\n+    is_const: bool,\n ) {\n     let path = Path::new_(pathvec_std!(hash::Hash), vec![], PathKind::Std);\n \n@@ -24,7 +25,6 @@ pub fn expand_deriving_hash(\n         path,\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::hash,\n@@ -39,6 +39,7 @@ pub fn expand_deriving_hash(\n             })),\n         }],\n         associated_types: Vec::new(),\n+        is_const,\n     };\n \n     hash_trait_def.expand(cx, mitem, item, push);"}, {"sha": "73a1df5d426d264fdb5ad7a1d008c2a575418449", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -38,9 +38,10 @@ pub mod partial_ord;\n \n pub mod generic;\n \n-pub(crate) struct BuiltinDerive(\n-    pub(crate) fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n-);\n+pub(crate) type BuiltinDeriveFn =\n+    fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable), bool);\n+\n+pub(crate) struct BuiltinDerive(pub(crate) BuiltinDeriveFn);\n \n impl MultiItemModifier for BuiltinDerive {\n     fn expand(\n@@ -49,6 +50,7 @@ impl MultiItemModifier for BuiltinDerive {\n         span: Span,\n         meta_item: &MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // FIXME: Built-in derives often forget to give spans contexts,\n         // so we are doing it here in a centralized way.\n@@ -57,21 +59,28 @@ impl MultiItemModifier for BuiltinDerive {\n         match item {\n             Annotatable::Stmt(stmt) => {\n                 if let ast::StmtKind::Item(item) = stmt.into_inner().kind {\n-                    (self.0)(ecx, span, meta_item, &Annotatable::Item(item), &mut |a| {\n-                        // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n-                        // to the function\n-                        items.push(Annotatable::Stmt(P(ast::Stmt {\n-                            id: ast::DUMMY_NODE_ID,\n-                            kind: ast::StmtKind::Item(a.expect_item()),\n-                            span,\n-                        })));\n-                    });\n+                    (self.0)(\n+                        ecx,\n+                        span,\n+                        meta_item,\n+                        &Annotatable::Item(item),\n+                        &mut |a| {\n+                            // Cannot use 'ecx.stmt_item' here, because we need to pass 'ecx'\n+                            // to the function\n+                            items.push(Annotatable::Stmt(P(ast::Stmt {\n+                                id: ast::DUMMY_NODE_ID,\n+                                kind: ast::StmtKind::Item(a.expect_item()),\n+                                span,\n+                            })));\n+                        },\n+                        is_derive_const,\n+                    );\n                 } else {\n                     unreachable!(\"should have already errored on non-item statement\")\n                 }\n             }\n             _ => {\n-                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+                (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a), is_derive_const);\n             }\n         }\n         ExpandResult::Ready(items)"}, {"sha": "1cbbfb432647cebca15bfa72ac207eac463fb1da", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -25,6 +25,7 @@ use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n use rustc_span::symbol::sym;\n \n+mod alloc_error_handler;\n mod assert;\n mod cfg;\n mod cfg_accessible;\n@@ -94,10 +95,12 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     }\n \n     register_attr! {\n+        alloc_error_handler: alloc_error_handler::expand,\n         bench: test::expand_bench,\n         cfg_accessible: cfg_accessible::Expander,\n         cfg_eval: cfg_eval::expand,\n-        derive: derive::Expander,\n+        derive: derive::Expander(false),\n+        derive_const: derive::Expander(true),\n         global_allocator: global_allocator::expand,\n         test: test::expand_test,\n         test_case: test::expand_test_case,"}, {"sha": "3411bd40c9de553ec6e192aafb8350f0d55f6282", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -216,7 +216,10 @@ pub fn expand_include_bytes(\n         }\n     };\n     match cx.source_map().load_binary_file(&file) {\n-        Ok(bytes) => base::MacEager::expr(cx.expr_byte_str(sp, bytes)),\n+        Ok(bytes) => {\n+            let expr = cx.expr(sp, ast::ExprKind::IncludedBytes(bytes.into()));\n+            base::MacEager::expr(expr)\n+        }\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n             DummyResult::any(sp)"}, {"sha": "b62840d4bc8221d72d4a45d5d5e3144a3a050d01", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -112,7 +112,7 @@ pub fn expand_test_or_bench(\n     };\n \n     // Note: non-associated fn items are already handled by `expand_test_or_bench`\n-    if !matches!(item.kind, ast::ItemKind::Fn(_)) {\n+    let ast::ItemKind::Fn(fn_) = &item.kind else {\n         let diag = &cx.sess.parse_sess.span_diagnostic;\n         let msg = \"the `#[test]` attribute may only be used on a non-associated function\";\n         let mut err = match item.kind {\n@@ -130,7 +130,7 @@ pub fn expand_test_or_bench(\n             .emit();\n \n         return vec![Annotatable::Item(item)];\n-    }\n+    };\n \n     // has_*_signature will report any errors in the type so compilation\n     // will fail. We shouldn't try to expand in this case because the errors\n@@ -141,12 +141,14 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n+    let sp = cx.with_def_site_ctxt(item.span);\n+    let ret_ty_sp = cx.with_def_site_ctxt(fn_.sig.decl.output.span());\n+    let attr_sp = cx.with_def_site_ctxt(attr_sp);\n \n     let test_id = Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n-    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n+    let test_path = |name| cx.path(ret_ty_sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n \n     // creates test::ShouldPanic::$name\n     let should_panic_path = |name| {\n@@ -192,7 +194,7 @@ pub fn expand_test_or_bench(\n                         vec![\n                             // super::$test_fn(b)\n                             cx.expr_call(\n-                                sp,\n+                                ret_ty_sp,\n                                 cx.expr_path(cx.path(sp, vec![item.ident])),\n                                 vec![cx.expr_ident(sp, b)],\n                             ),\n@@ -216,7 +218,11 @@ pub fn expand_test_or_bench(\n                         cx.expr_path(test_path(\"assert_test_result\")),\n                         vec![\n                             // $test_fn()\n-                            cx.expr_call(sp, cx.expr_path(cx.path(sp, vec![item.ident])), vec![]), // )\n+                            cx.expr_call(\n+                                ret_ty_sp,\n+                                cx.expr_path(cx.path(sp, vec![item.ident])),\n+                                vec![],\n+                            ), // )\n                         ],\n                     ), // }\n                 ), // )"}, {"sha": "12bb00d346db42c42c88adfad2d5939df371c1f6", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,6 +5,7 @@ use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_session::config::OomStrategy;\n+use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -23,7 +24,7 @@ pub(crate) fn codegen(\n             module,\n             unwind_context,\n             kind,\n-            tcx.lang_items().oom().is_some(),\n+            tcx.alloc_error_handler_kind(()).unwrap(),\n             tcx.sess.opts.unstable_opts.oom,\n         );\n         true\n@@ -36,7 +37,7 @@ fn codegen_inner(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n     oom_strategy: OomStrategy,\n ) {\n     let usize_ty = module.target_config().pointer_type();\n@@ -108,12 +109,12 @@ fn codegen_inner(\n         returns: vec![],\n     };\n \n-    let callee_name = if has_alloc_error_handler { \"__rg_oom\" } else { \"__rdl_oom\" };\n+    let callee_name = alloc_error_handler_kind.fn_name(sym::oom);\n \n     let func_id =\n         module.declare_function(\"__rust_alloc_error_handler\", Linkage::Export, &sig).unwrap();\n \n-    let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n+    let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n     ctx.func.signature = sig;"}, {"sha": "f2e3bf16e61842bae2d73b66ac42c0cec2a01e6e", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -38,6 +38,7 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _lib_name: &str,\n         _dll_imports: &[rustc_session::cstore::DllImport],\n         _tmpdir: &Path,\n+        _is_direct_dependency: bool,\n     ) -> PathBuf {\n         bug!(\"creating dll imports is not supported\");\n     }"}, {"sha": "1db44502742e921b4bcbbdff9d76bce7e1e5e849", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -770,11 +770,7 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n                 Rvalue::NullaryOp(null_op, ty) => {\n-                    assert!(\n-                        lval.layout()\n-                            .ty\n-                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n-                    );\n+                    assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),"}, {"sha": "df1150ec0b8ce266e610de2a0a52052ebd9dc992", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_span::DUMMY_SP;\n \n use cranelift_module::*;\n \n@@ -129,7 +128,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     ty: Ty<'tcx>,\n ) -> CValue<'tcx> {\n     let layout = fx.layout_of(ty);\n-    assert!(!layout.is_unsized(), \"sized const value\");\n+    assert!(layout.is_sized(), \"unsized const value\");\n \n     if layout.is_zst() {\n         return CValue::by_ref(crate::Pointer::dangling(layout.align.pref), layout);\n@@ -291,7 +290,7 @@ fn data_id_for_static(\n     let is_mutable = if tcx.is_mutable_static(def_id) {\n         true\n     } else {\n-        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        !ty.is_freeze(tcx, ParamEnv::reveal_all())\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n "}, {"sha": "2ba012a77b0a908788f0272705f82f7c875cb1a7", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -59,7 +59,7 @@ impl DebugContext {\n \n         let producer = format!(\n             \"cg_clif (rustc {}, cranelift {})\",\n-            rustc_interface::util::version_str().unwrap_or(\"unknown version\"),\n+            rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n             cranelift_codegen::VERSION,\n         );\n         let comp_dir = tcx"}, {"sha": "c5bd574623df68d2644ce5908d136d696b12e979", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -19,7 +19,7 @@ fn codegen_field<'tcx>(\n     };\n \n     if let Some(extra) = extra {\n-        if !field_layout.is_unsized() {\n+        if field_layout.is_sized() {\n             return simple(fx);\n         }\n         match field_layout.ty.kind() {\n@@ -364,7 +364,7 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n     ) -> CPlace<'tcx> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         if layout.size.bytes() == 0 {\n             return CPlace {\n                 inner: CPlaceInner::Addr(Pointer::dangling(layout.align.pref), None),\n@@ -825,7 +825,7 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &FunctionCx<'_, '_, 'tcx>,\n         variant: VariantIdx,\n     ) -> Self {\n-        assert!(!self.layout().is_unsized());\n+        assert!(self.layout().is_sized());\n         let layout = self.layout().for_variant(fx, variant);\n         CPlace { inner: self.inner, layout }\n     }"}, {"sha": "e2c9ffe9c1c301dedb200c88e8d8dfb2cd649ef7", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -7,7 +7,7 @@ use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) {\n     let context = &mods.context;\n     let usize =\n         match tcx.sess.target.pointer_width {\n@@ -90,14 +90,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n-    let kind =\n-        if has_alloc_error_handler {\n-            AllocatorKind::Global\n-        }\n-        else {\n-            AllocatorKind::Default\n-        };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();"}, {"sha": "f18ae7ea5e9b0ff75a07d9567562c9663e5a1f7c", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -47,6 +47,7 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _lib_name: &str,\n         _dll_imports: &[DllImport],\n         _tmpdir: &Path,\n+        _is_direct_dependency: bool,\n     ) -> PathBuf {\n         unimplemented!();\n     }"}, {"sha": "dd0daf2c38b109c9775edf7ca5d70056b9e4c699", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -153,11 +153,11 @@ impl CodegenBackend for GccCodegenBackend {\n }\n \n impl ExtraBackendMethods for GccCodegenBackend {\n-    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, has_alloc_error_handler: bool) -> Self::Module {\n+    fn codegen_allocator<'tcx>(&self, tcx: TyCtxt<'tcx>, module_name: &str, kind: AllocatorKind, alloc_error_handler_kind: AllocatorKind) -> Self::Module {\n         let mut mods = GccContext {\n             context: Context::default(),\n         };\n-        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, has_alloc_error_handler); }\n+        unsafe { allocator::codegen(tcx, &mut mods, module_name, kind, alloc_error_handler_kind); }\n         mods\n     }\n "}, {"sha": "bdf7318ce48c9505887b2287c0201bf66742bc54", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -201,6 +201,27 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {\n         value.get_type()\n     }\n+\n+    fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n+        if let Some(struct_type) = ty.is_struct() {\n+            if struct_type.get_field_count() == 0 {\n+                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n+                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n+                // zero for ZSTs.\n+                // FIXME(antoyo): fix gccjit API.\n+                len = 0;\n+            }\n+        }\n+\n+        // NOTE: see note above. Some other test uses usize::MAX.\n+        if len == u64::MAX {\n+            len = 0;\n+        }\n+\n+        let len: i32 = len.try_into().expect(\"array len\");\n+\n+        self.context.new_array_type(None, ty, len)\n+    }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -227,27 +248,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n \n-    pub fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n-            if struct_type.get_field_count() == 0 {\n-                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n-                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n-                // zero for ZSTs.\n-                // FIXME(antoyo): fix gccjit API.\n-                len = 0;\n-            }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n-\n-        self.context.new_array_type(None, ty, len)\n-    }\n-\n     pub fn type_bool(&self) -> Type<'gcc> {\n         self.context.new_type::<bool>()\n     }\n@@ -277,7 +277,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }\n-    if !layout.is_unsized() && field_count > 0 {\n+    if layout.is_sized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }"}, {"sha": "fed56cdd43821e6cb2dd76a0918e7dcc5c55bf32", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,7 +15,7 @@ pub(crate) unsafe fn codegen(\n     module_llvm: &mut ModuleLlvm,\n     module_name: &str,\n     kind: AllocatorKind,\n-    has_alloc_error_handler: bool,\n+    alloc_error_handler_kind: AllocatorKind,\n ) {\n     let llcx = &*module_llvm.llcx;\n     let llmod = module_llvm.llmod();\n@@ -117,8 +117,7 @@ pub(crate) unsafe fn codegen(\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n-    let kind = if has_alloc_error_handler { AllocatorKind::Global } else { AllocatorKind::Default };\n-    let callee = kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n     attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);"}, {"sha": "219a4f8fa89594a909cfb3936557c950067fdac9", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -130,15 +130,24 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                     op_idx.insert(idx, constraints.len());\n                     constraints.push(reg_to_llvm(reg, Some(&value.layout)));\n                 }\n-                InlineAsmOperandRef::InOut { reg, late: _, in_value, out_place: _ } => {\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place: _ } => {\n                     let value = llvm_fixup_input(\n                         self,\n                         in_value.immediate(),\n                         reg.reg_class(),\n                         &in_value.layout,\n                     );\n                     inputs.push(value);\n-                    constraints.push(format!(\"{}\", op_idx[&idx]));\n+\n+                    // In the case of fixed registers, we have the choice of\n+                    // either using a tied operand or duplicating the constraint.\n+                    // We prefer the latter because it matches the behavior of\n+                    // Clang.\n+                    if late && matches!(reg, InlineAsmRegOrRegClass::Reg(_)) {\n+                        constraints.push(format!(\"{}\", reg_to_llvm(reg, Some(&in_value.layout))));\n+                    } else {\n+                        constraints.push(format!(\"{}\", op_idx[&idx]));\n+                    }\n                 }\n                 InlineAsmOperandRef::SymFn { instance } => {\n                     inputs.push(self.cx.get_fn(instance));\n@@ -276,13 +285,13 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         let mut attrs = SmallVec::<[_; 2]>::new();\n         if options.contains(InlineAsmOptions::PURE) {\n             if options.contains(InlineAsmOptions::NOMEM) {\n-                attrs.push(llvm::AttributeKind::ReadNone.create_attr(self.cx.llcx));\n+                attrs.push(llvm::MemoryEffects::None.create_attr(self.cx.llcx));\n             } else if options.contains(InlineAsmOptions::READONLY) {\n-                attrs.push(llvm::AttributeKind::ReadOnly.create_attr(self.cx.llcx));\n+                attrs.push(llvm::MemoryEffects::ReadOnly.create_attr(self.cx.llcx));\n             }\n             attrs.push(llvm::AttributeKind::WillReturn.create_attr(self.cx.llcx));\n         } else if options.contains(InlineAsmOptions::NOMEM) {\n-            attrs.push(llvm::AttributeKind::InaccessibleMemOnly.create_attr(self.cx.llcx));\n+            attrs.push(llvm::MemoryEffects::InaccessibleMemOnly.create_attr(self.cx.llcx));\n         } else {\n             // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n         }\n@@ -496,6 +505,44 @@ fn xmm_reg_index(reg: InlineAsmReg) -> Option<u32> {\n     }\n }\n \n+/// If the register is an AArch64 integer register then return its index.\n+fn a64_reg_index(reg: InlineAsmReg) -> Option<u32> {\n+    match reg {\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x0) => Some(0),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x1) => Some(1),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x2) => Some(2),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x3) => Some(3),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x4) => Some(4),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x5) => Some(5),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x6) => Some(6),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x7) => Some(7),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x8) => Some(8),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x9) => Some(9),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x10) => Some(10),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x11) => Some(11),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x12) => Some(12),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x13) => Some(13),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x14) => Some(14),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x15) => Some(15),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x16) => Some(16),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x17) => Some(17),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x18) => Some(18),\n+        // x19 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x20) => Some(20),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x21) => Some(21),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x22) => Some(22),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x23) => Some(23),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x24) => Some(24),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x25) => Some(25),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x26) => Some(26),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x27) => Some(27),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x28) => Some(28),\n+        // x29 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) => Some(30),\n+        _ => None,\n+    }\n+}\n+\n /// If the register is an AArch64 vector register then return its index.\n fn a64_vreg_index(reg: InlineAsmReg) -> Option<u32> {\n     match reg {\n@@ -526,6 +573,22 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'x'\n                 };\n                 format!(\"{{{}mm{}}}\", class, idx)\n+            } else if let Some(idx) = a64_reg_index(reg) {\n+                let class = if let Some(layout) = layout {\n+                    match layout.size.bytes() {\n+                        8 => 'x',\n+                        _ => 'w',\n+                    }\n+                } else {\n+                    // We use i32 as the type for discarded outputs\n+                    'w'\n+                };\n+                if class == 'x' && reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n+                    // LLVM doesn't recognize x30. use lr instead.\n+                    \"{lr}\".to_string()\n+                } else {\n+                    format!(\"{{{}{}}}\", class, idx)\n+                }\n             } else if let Some(idx) = a64_vreg_index(reg) {\n                 let class = if let Some(layout) = layout {\n                     match layout.size.bytes() {\n@@ -541,9 +604,6 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'q'\n                 };\n                 format!(\"{{{}{}}}\", class, idx)\n-            } else if reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n-                // LLVM doesn't recognize x30\n-                \"{lr}\".to_string()\n             } else if reg == InlineAsmReg::Arm(ArmInlineAsmReg::r14) {\n                 // LLVM doesn't recognize r14\n                 \"{lr}\".to_string()"}, {"sha": "a8b47633519aabc39689ab19a7138c269b11440c", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,8 +12,9 @@ use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtec\n use smallvec::SmallVec;\n \n use crate::attributes;\n+use crate::errors::{MissingFeatures, SanitizerMemtagRequiresMte, TargetFeatureDisableOrEnable};\n use crate::llvm::AttributePlace::Function;\n-use crate::llvm::{self, AllocKindFlags, Attribute, AttributeKind, AttributePlace};\n+use crate::llvm::{self, AllocKindFlags, Attribute, AttributeKind, AttributePlace, MemoryEffects};\n use crate::llvm_util;\n pub use rustc_attr::{InlineAttr, InstructionSetAttr, OptimizeAttr};\n \n@@ -82,7 +83,7 @@ pub fn sanitize_attrs<'ll>(\n         let mte_feature =\n             features.iter().map(|s| &s[..]).rfind(|n| [\"+mte\", \"-mte\"].contains(&&n[..]));\n         if let None | Some(\"-mte\") = mte_feature {\n-            cx.tcx.sess.err(\"`-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\");\n+            cx.tcx.sess.emit_err(SanitizerMemtagRequiresMte);\n         }\n \n         attrs.push(llvm::AttributeKind::SanitizeMemTag.create_attr(cx.llcx));\n@@ -303,10 +304,10 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n         to_add.push(AttributeKind::ReturnsTwice.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_PURE) {\n-        to_add.push(AttributeKind::ReadOnly.create_attr(cx.llcx));\n+        to_add.push(MemoryEffects::ReadOnly.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::FFI_CONST) {\n-        to_add.push(AttributeKind::ReadNone.create_attr(cx.llcx));\n+        to_add.push(MemoryEffects::None.create_attr(cx.llcx));\n     }\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n         to_add.push(AttributeKind::Naked.create_attr(cx.llcx));\n@@ -393,13 +394,14 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n             .get_attrs(instance.def_id(), sym::target_feature)\n             .next()\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n-        let msg = format!(\n-            \"the target features {} must all be either enabled or disabled together\",\n-            f.join(\", \")\n-        );\n-        let mut err = cx.tcx.sess.struct_span_err(span, &msg);\n-        err.help(\"add the missing features in a `target_feature` attribute\");\n-        err.emit();\n+        cx.tcx\n+            .sess\n+            .create_err(TargetFeatureDisableOrEnable {\n+                features: f,\n+                span: Some(span),\n+                missing_features: Some(MissingFeatures),\n+            })\n+            .emit();\n         return;\n     }\n "}, {"sha": "5c68abeb08baf288532e48c162926b39f92fce26", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,6 +12,10 @@ use std::str;\n use object::read::macho::FatArch;\n \n use crate::common;\n+use crate::errors::{\n+    ArchiveBuildFailure, DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary,\n+    ErrorWritingDEFFile, UnknownArchiveKind,\n+};\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n@@ -147,7 +151,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     fn build(mut self: Box<Self>, output: &Path) -> bool {\n         match self.build_with_llvm(output) {\n             Ok(any_members) => any_members,\n-            Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n+            Err(e) => self.sess.emit_fatal(ArchiveBuildFailure { error: e }),\n         }\n     }\n }\n@@ -165,10 +169,12 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n+        is_direct_dependency: bool,\n     ) -> PathBuf {\n+        let name_suffix = if is_direct_dependency { \"_imports\" } else { \"_imports_indirect\" };\n         let output_path = {\n             let mut output_path: PathBuf = tmpdir.to_path_buf();\n-            output_path.push(format!(\"{}_imports\", lib_name));\n+            output_path.push(format!(\"{}{}\", lib_name, name_suffix));\n             output_path.with_extension(\"lib\")\n         };\n \n@@ -195,7 +201,8 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             // that loaded but crashed with an AV upon calling one of the imported\n             // functions.  Therefore, use binutils to create the import library instead,\n             // by writing a .DEF file to the temp dir and calling binutils's dlltool.\n-            let def_file_path = tmpdir.join(format!(\"{}_imports\", lib_name)).with_extension(\"def\");\n+            let def_file_path =\n+                tmpdir.join(format!(\"{}{}\", lib_name, name_suffix)).with_extension(\"def\");\n \n             let def_file_content = format!(\n                 \"EXPORTS\\n{}\",\n@@ -214,7 +221,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             match std::fs::write(&def_file_path, def_file_content) {\n                 Ok(_) => {}\n                 Err(e) => {\n-                    sess.fatal(&format!(\"Error writing .DEF file: {}\", e));\n+                    sess.emit_fatal(ErrorWritingDEFFile { error: e });\n                 }\n             };\n \n@@ -236,13 +243,14 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             match result {\n                 Err(e) => {\n-                    sess.fatal(&format!(\"Error calling dlltool: {}\", e));\n+                    sess.emit_fatal(ErrorCallingDllTool { error: e });\n+                }\n+                Ok(output) if !output.status.success() => {\n+                    sess.emit_fatal(DlltoolFailImportLibrary {\n+                        stdout: String::from_utf8_lossy(&output.stdout),\n+                        stderr: String::from_utf8_lossy(&output.stderr),\n+                    })\n                 }\n-                Ok(output) if !output.status.success() => sess.fatal(&format!(\n-                    \"Dlltool could not create import library: {}\\n{}\",\n-                    String::from_utf8_lossy(&output.stdout),\n-                    String::from_utf8_lossy(&output.stderr)\n-                )),\n                 _ => {}\n             }\n         } else {\n@@ -290,11 +298,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             };\n \n             if result == crate::llvm::LLVMRustResult::Failure {\n-                sess.fatal(&format!(\n-                    \"Error creating import library for {}: {}\",\n+                sess.emit_fatal(ErrorCreatingImportLibrary {\n                     lib_name,\n-                    llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string())\n-                ));\n+                    error: llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string()),\n+                });\n             }\n         };\n \n@@ -305,9 +312,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n impl<'a> LlvmArchiveBuilder<'a> {\n     fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;\n-        let kind = kind.parse::<ArchiveKind>().map_err(|_| kind).unwrap_or_else(|kind| {\n-            self.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n-        });\n+        let kind = kind\n+            .parse::<ArchiveKind>()\n+            .map_err(|_| kind)\n+            .unwrap_or_else(|kind| self.sess.emit_fatal(UnknownArchiveKind { kind }));\n \n         let mut additions = mem::take(&mut self.additions);\n         let mut strings = Vec::new();"}, {"sha": "3fa21355b7f4c9b46349591904aac80717541976", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,4 +1,5 @@\n use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::errors::DynamicLinkingWithLTO;\n use crate::llvm::{self, build_string};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n@@ -90,13 +91,7 @@ fn prepare_lto(\n         }\n \n         if cgcx.opts.cg.prefer_dynamic && !cgcx.opts.unstable_opts.dylib_lto {\n-            diag_handler\n-                .struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-                .note(\n-                    \"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                               supported with LTO\",\n-                )\n-                .emit();\n+            diag_handler.emit_err(DynamicLinkingWithLTO);\n             return Err(FatalError);\n         }\n "}, {"sha": "97d0de47b3a6e7fbff4484c5e74c393bea3891a2", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -765,11 +765,21 @@ pub(crate) unsafe fn codegen(\n         drop(handlers);\n     }\n \n+    // `.dwo` files are only emitted if:\n+    //\n+    // - Object files are being emitted (i.e. bitcode only or metadata only compilations will not\n+    //   produce dwarf objects, even if otherwise enabled)\n+    // - Target supports Split DWARF\n+    // - Split debuginfo is enabled\n+    // - Split DWARF kind is `split` (i.e. debuginfo is split into `.dwo` files, not different\n+    //   sections in the `.o` files).\n+    let dwarf_object_emitted = matches!(config.emit_obj, EmitObj::ObjectCode(_))\n+        && cgcx.target_can_use_split_dwarf\n+        && cgcx.split_debuginfo != SplitDebuginfo::Off\n+        && cgcx.split_dwarf_kind == SplitDwarfKind::Split;\n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n-        cgcx.target_can_use_split_dwarf\n-            && cgcx.split_debuginfo != SplitDebuginfo::Off\n-            && cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n+        dwarf_object_emitted,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "9cb36ce7f1890b967d8ca7f4b948b98c0b4f53bd", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -365,11 +365,14 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 Int(I64) => \"llvm.ssub.with.overflow.i64\",\n                 Int(I128) => \"llvm.ssub.with.overflow.i128\",\n \n-                Uint(U8) => \"llvm.usub.with.overflow.i8\",\n-                Uint(U16) => \"llvm.usub.with.overflow.i16\",\n-                Uint(U32) => \"llvm.usub.with.overflow.i32\",\n-                Uint(U64) => \"llvm.usub.with.overflow.i64\",\n-                Uint(U128) => \"llvm.usub.with.overflow.i128\",\n+                Uint(_) => {\n+                    // Emit sub and icmp instead of llvm.usub.with.overflow. LLVM considers these\n+                    // to be the canonical form. It will attempt to reform llvm.usub.with.overflow\n+                    // in the backend if profitable.\n+                    let sub = self.sub(lhs, rhs);\n+                    let cmp = self.icmp(IntPredicate::IntULT, lhs, rhs);\n+                    return (sub, cmp);\n+                }\n \n                 _ => unreachable!(),\n             },"}, {"sha": "3b504d3a7df7589fc7f13a0027584d4cb51d6638", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,6 +1,7 @@\n use crate::base;\n use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n+use crate::errors::{InvalidMinimumAlignment, LinkageConstOrMutType, SymbolAlreadyDefined};\n use crate::llvm::{self, True};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -19,6 +20,7 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n+use rustc_session::config::Lto;\n use rustc_target::abi::{\n     AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n };\n@@ -145,7 +147,7 @@ fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align:\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n             }\n         }\n     }\n@@ -173,10 +175,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n         let llty2 = if let ty::RawPtr(ref mt) = ty.kind() {\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n-            cx.sess().span_fatal(\n-                cx.tcx.def_span(def_id),\n-                \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-            )\n+            cx.sess().emit_fatal(LinkageConstOrMutType { span: cx.tcx.def_span(def_id) })\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n@@ -192,10 +191,10 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n-                cx.sess().span_fatal(\n-                    cx.tcx.def_span(def_id),\n-                    &format!(\"symbol `{}` is already defined\", &sym),\n-                )\n+                cx.sess().emit_fatal(SymbolAlreadyDefined {\n+                    span: cx.tcx.def_span(def_id),\n+                    symbol_name: sym,\n+                })\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n             llvm::LLVMSetInitializer(g2, g1);\n@@ -303,7 +302,8 @@ impl<'ll> CodegenCx<'ll, '_> {\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n                 // dynamic linking when linker plugin based LTO is enabled.\n-                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled();\n+                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled() &&\n+                self.tcx.sess.lto() != Lto::Thin;\n \n             // If this assertion triggers, there's something wrong with commandline\n             // argument validation."}, {"sha": "eaa2ccfc835c5f2564a58d53ff9522d87e3320e7", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -3,6 +3,7 @@ use crate::back::write::to_llvm_code_model;\n use crate::callee::get_fn;\n use crate::coverageinfo;\n use crate::debuginfo;\n+use crate::errors::BranchProtectionRequiresAArch64;\n use crate::llvm;\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -26,6 +27,7 @@ use rustc_session::config::{BranchProtection, CFGuard, CFProtection};\n use rustc_session::config::{CrateType, DebugInfo, PAuthKey, PacRet};\n use rustc_session::Session;\n use rustc_span::source_map::Span;\n+use rustc_span::source_map::Spanned;\n use rustc_target::abi::{\n     call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx,\n };\n@@ -158,6 +160,10 @@ pub unsafe fn create_module<'ll>(\n         if sess.target.arch == \"s390x\" {\n             target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n         }\n+\n+        if sess.target.arch == \"riscv64\" {\n+            target_data_layout = target_data_layout.replace(\"-n32:64-\", \"-n64-\");\n+        }\n     }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n@@ -271,7 +277,7 @@ pub unsafe fn create_module<'ll>(\n \n     if let Some(BranchProtection { bti, pac_ret }) = sess.opts.unstable_opts.branch_protection {\n         if sess.target.arch != \"aarch64\" {\n-            sess.err(\"-Zbranch-protection is only supported on aarch64\");\n+            sess.emit_err(BranchProtectionRequiresAArch64);\n         } else {\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n@@ -947,7 +953,7 @@ impl<'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(Spanned { span, node: err })\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -965,7 +971,7 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(Spanned { span, node: err })\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "8a8d889a29865960e9c1337873d5ab54879b783e", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,5 +1,6 @@\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n+use crate::errors::InstrumentCoverageRequiresLLVM12;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n@@ -37,7 +38,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // LLVM 12.\n     let version = coverageinfo::mapping_version();\n     if version < 4 {\n-        tcx.sess.fatal(\"rustc option `-C instrument-coverage` requires LLVM 12 or higher.\");\n+        tcx.sess.emit_fatal(InstrumentCoverageRequiresLLVM12);\n     }\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());"}, {"sha": "5cd0e1cb63ae1b6b2c602272ba506cbf45dc1c45", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -72,7 +72,7 @@ pub(crate) fn fat_pointer_kind<'ll, 'tcx>(\n         layout.is_unsized()\n     );\n \n-    if !layout.is_unsized() {\n+    if layout.is_sized() {\n         return None;\n     }\n "}, {"sha": "0fafc214f2f5ebdc6144ff8dbd8f154d3a3b2814", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -0,0 +1,139 @@\n+use std::borrow::Cow;\n+\n+use rustc_errors::fluent;\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::Handler;\n+use rustc_errors::IntoDiagnostic;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::Span;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_ctarget_feature_prefix)]\n+#[note]\n+pub(crate) struct UnknownCTargetFeaturePrefix<'a> {\n+    pub feature: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_ctarget_feature)]\n+#[note]\n+pub(crate) struct UnknownCTargetFeature<'a> {\n+    pub feature: &'a str,\n+    #[subdiagnostic]\n+    pub rust_feature: PossibleFeature<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum PossibleFeature<'a> {\n+    #[help(possible_feature)]\n+    Some { rust_feature: &'a str },\n+    #[help(consider_filing_feature_request)]\n+    None,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_creating_import_library)]\n+pub(crate) struct ErrorCreatingImportLibrary<'a> {\n+    pub lib_name: &'a str,\n+    pub error: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_instrument_coverage_requires_llvm_12)]\n+pub(crate) struct InstrumentCoverageRequiresLLVM12;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_symbol_already_defined)]\n+pub(crate) struct SymbolAlreadyDefined<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub symbol_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_branch_protection_requires_aarch64)]\n+pub(crate) struct BranchProtectionRequiresAArch64;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_linkage_const_or_mut_type)]\n+pub(crate) struct LinkageConstOrMutType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_sanitizer_memtag_requires_mte)]\n+pub(crate) struct SanitizerMemtagRequiresMte;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_archive_build_failure)]\n+pub(crate) struct ArchiveBuildFailure {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_writing_def_file)]\n+pub(crate) struct ErrorWritingDEFFile {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_calling_dlltool)]\n+pub(crate) struct ErrorCallingDllTool {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_dlltool_fail_import_library)]\n+pub(crate) struct DlltoolFailImportLibrary<'a> {\n+    pub stdout: Cow<'a, str>,\n+    pub stderr: Cow<'a, str>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_archive_kind)]\n+pub(crate) struct UnknownArchiveKind<'a> {\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_dynamic_linking_with_lto)]\n+#[note]\n+pub(crate) struct DynamicLinkingWithLTO;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_fail_parsing_target_machine_config_to_target_machine)]\n+pub(crate) struct FailParsingTargetMachineConfigToTargetMachine {\n+    pub error: String,\n+}\n+\n+pub(crate) struct TargetFeatureDisableOrEnable<'a> {\n+    pub features: &'a [&'a str],\n+    pub span: Option<Span>,\n+    pub missing_features: Option<MissingFeatures>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(codegen_llvm_missing_features)]\n+pub(crate) struct MissingFeatures;\n+\n+impl IntoDiagnostic<'_, ErrorGuaranteed> for TargetFeatureDisableOrEnable<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(fluent::codegen_llvm_target_feature_disable_or_enable);\n+        if let Some(span) = self.span {\n+            diag.set_span(span);\n+        };\n+        if let Some(missing_features) = self.missing_features {\n+            diag.subdiagnostic(missing_features);\n+        }\n+        diag.set_arg(\"features\", self.features.join(\", \"));\n+        diag\n+    }\n+}"}, {"sha": "cf590a43826e53407aab00b691ad66fe0744a3cd", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -340,17 +340,26 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n \n             sym::black_box => {\n                 args[0].val.store(self, result);\n-\n+                let result_val_span = [result.llval];\n                 // We need to \"use\" the argument in some way LLVM can't introspect, and on\n                 // targets that support it we can typically leverage inline assembly to do\n                 // this. LLVM's interpretation of inline assembly is that it's, well, a black\n                 // box. This isn't the greatest implementation since it probably deoptimizes\n                 // more than we want, but it's so far good enough.\n+                //\n+                // For zero-sized types, the location pointed to by the result may be\n+                // uninitialized. Do not \"use\" the result in this case; instead just clobber\n+                // the memory.\n+                let (constraint, inputs): (&str, &[_]) = if result.layout.is_zst() {\n+                    (\"~{memory}\", &[])\n+                } else {\n+                    (\"r,~{memory}\", &result_val_span)\n+                };\n                 crate::asm::inline_asm_call(\n                     self,\n                     \"\",\n-                    \"r,~{memory}\",\n-                    &[result.llval],\n+                    constraint,\n+                    inputs,\n                     self.type_void(),\n                     true,\n                     false,"}, {"sha": "246e82545c874811fa6552bc2286da98bc113476", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,6 +12,8 @@\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -20,6 +22,7 @@ extern crate tracing;\n \n use back::write::{create_informational_target_machine, create_target_machine};\n \n+use errors::FailParsingTargetMachineConfigToTargetMachine;\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n@@ -62,6 +65,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod intrinsic;\n \n // The following is a work around that replaces `pub mod llvm;` and that fixes issue 53912.\n@@ -108,11 +112,11 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> ModuleLlvm {\n         let mut module_llvm = ModuleLlvm::new_metadata(tcx, module_name);\n         unsafe {\n-            allocator::codegen(tcx, &mut module_llvm, module_name, kind, has_alloc_error_handler);\n+            allocator::codegen(tcx, &mut module_llvm, module_name, kind, alloc_error_handler_kind);\n         }\n         module_llvm\n     }\n@@ -412,7 +416,7 @@ impl ModuleLlvm {\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n-                    handler.struct_err(&e).emit();\n+                    handler.emit_err(FailParsingTargetMachineConfigToTargetMachine { error: e });\n                     return Err(FatalError);\n                 }\n             };"}, {"sha": "e2d0390821d1eb780fb387f5412cc225f325586c", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -183,7 +183,6 @@ pub enum AttributeKind {\n     OptimizeNone = 24,\n     ReturnsTwice = 25,\n     ReadNone = 26,\n-    InaccessibleMemOnly = 27,\n     SanitizeHWAddress = 28,\n     WillReturn = 29,\n     StackProtectReq = 30,\n@@ -590,6 +589,15 @@ pub enum ChecksumKind {\n     SHA256,\n }\n \n+/// LLVMRustMemoryEffects\n+#[derive(Copy, Clone)]\n+#[repr(C)]\n+pub enum MemoryEffects {\n+    None,\n+    ReadOnly,\n+    InaccessibleMemOnly,\n+}\n+\n extern \"C\" {\n     type Opaque;\n }\n@@ -1175,6 +1183,7 @@ extern \"C\" {\n     pub fn LLVMRustCreateUWTableAttr(C: &Context, async_: bool) -> &Attribute;\n     pub fn LLVMRustCreateAllocSizeAttr(C: &Context, size_arg: u32) -> &Attribute;\n     pub fn LLVMRustCreateAllocKindAttr(C: &Context, size_arg: u64) -> &Attribute;\n+    pub fn LLVMRustCreateMemoryEffectsAttr(C: &Context, effects: MemoryEffects) -> &Attribute;\n \n     // Operations on functions\n     pub fn LLVMRustGetOrInsertFunction<'a>("}, {"sha": "f820e7523712ce541fc32cb1a71dd69623e8a639", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -185,6 +185,13 @@ impl AttributeKind {\n     }\n }\n \n+impl MemoryEffects {\n+    /// Create an LLVM Attribute with these memory effects.\n+    pub fn create_attr(self, llcx: &Context) -> &Attribute {\n+        unsafe { LLVMRustCreateMemoryEffectsAttr(llcx, self) }\n+    }\n+}\n+\n pub fn set_section(llglobal: &Value, section_name: &str) {\n     let section_name_cstr = CString::new(section_name).expect(\"unexpected CString error\");\n     unsafe {"}, {"sha": "e1f54356228d3ea60163ec928322caf5d82fbc88", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,4 +1,8 @@\n use crate::back::write::create_informational_target_machine;\n+use crate::errors::{\n+    PossibleFeature, TargetFeatureDisableOrEnable, UnknownCTargetFeature,\n+    UnknownCTargetFeaturePrefix,\n+};\n use crate::llvm;\n use libc::c_int;\n use rustc_codegen_ssa::target_features::{\n@@ -434,12 +438,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n                 Some(c @ '+' | c @ '-') => c,\n                 Some(_) => {\n                     if diagnostics {\n-                        let mut diag = sess.struct_warn(&format!(\n-                            \"unknown feature specified for `-Ctarget-feature`: `{}`\",\n-                            s\n-                        ));\n-                        diag.note(\"features must begin with a `+` to enable or `-` to disable it\");\n-                        diag.emit();\n+                        sess.emit_warning(UnknownCTargetFeaturePrefix { feature: s });\n                     }\n                     return None;\n                 }\n@@ -456,17 +455,15 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n                         None\n                     }\n                 });\n-                let mut diag = sess.struct_warn(&format!(\n-                    \"unknown feature specified for `-Ctarget-feature`: `{}`\",\n-                    feature\n-                ));\n-                diag.note(\"it is still passed through to the codegen backend\");\n-                if let Some(rust_feature) = rust_feature {\n-                    diag.help(&format!(\"you might have meant: `{}`\", rust_feature));\n+                let unknown_feature = if let Some(rust_feature) = rust_feature {\n+                    UnknownCTargetFeature {\n+                        feature,\n+                        rust_feature: PossibleFeature::Some { rust_feature },\n+                    }\n                 } else {\n-                    diag.note(\"consider filing a feature request\");\n-                }\n-                diag.emit();\n+                    UnknownCTargetFeature { feature, rust_feature: PossibleFeature::None }\n+                };\n+                sess.emit_warning(unknown_feature);\n             }\n \n             if diagnostics {\n@@ -492,10 +489,11 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n     features.extend(feats);\n \n     if diagnostics && let Some(f) = check_tied_features(sess, &featsmap) {\n-        sess.err(&format!(\n-            \"target features {} must all be enabled or disabled together\",\n-            f.join(\", \")\n-        ));\n+        sess.emit_err(TargetFeatureDisableOrEnable {\n+            features: f,\n+            span: None,\n+            missing_features: None,\n+        });\n     }\n \n     features"}, {"sha": "76f692b2016fd5ff64d4824206b856fc12811969", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,6 +1,7 @@\n use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::SymbolAlreadyDefined;\n use crate::llvm;\n use crate::type_of::LayoutLlvmExt;\n use rustc_codegen_ssa::traits::*;\n@@ -25,10 +26,8 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         let llty = self.layout_of(ty).llvm_type(self);\n \n         let g = self.define_global(symbol_name, llty).unwrap_or_else(|| {\n-            self.sess().span_fatal(\n-                self.tcx.def_span(def_id),\n-                &format!(\"symbol `{}` is already defined\", symbol_name),\n-            )\n+            self.sess()\n+                .emit_fatal(SymbolAlreadyDefined { span: self.tcx.def_span(def_id), symbol_name })\n         });\n \n         unsafe {"}, {"sha": "5eec7dc613028e3e25f6a50296399f20a6d8f34d", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -127,10 +127,6 @@ impl<'ll> CodegenCx<'ll, '_> {\n     pub(crate) fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n         unsafe { llvm::LLVMFunctionType(ret, args.as_ptr(), args.len() as c_uint, True) }\n     }\n-\n-    pub(crate) fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n-        unsafe { llvm::LLVMRustArrayType(ty, len) }\n-    }\n }\n \n impl<'ll, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -231,6 +227,10 @@ impl<'ll, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n         common::val_ty(v)\n     }\n+\n+    fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+        unsafe { llvm::LLVMRustArrayType(ty, len) }\n+    }\n }\n \n impl Type {"}, {"sha": "182adf81785716fe5abea7b91e0571dc6bda7a8b", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -140,7 +140,7 @@ fn struct_llfields<'a, 'tcx>(\n         prev_effective_align = effective_field_align;\n     }\n     let padding_used = result.len() > field_count;\n-    if !layout.is_unsized() && field_count > 0 {\n+    if layout.is_sized() && field_count > 0 {\n         if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }"}, {"sha": "2b1b06d1644c9062656d3cc52ce816dc2bb72eff", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,13 +4,17 @@ use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n \n+use super::metadata::search_for_section;\n+\n use object::read::archive::ArchiveFile;\n \n-use std::fmt::Display;\n+use std::error::Error;\n use std::fs::File;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::ExtractBundledLibsError;\n+\n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n@@ -25,34 +29,41 @@ pub trait ArchiveBuilderBuilder {\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n+        is_direct_dependency: bool,\n     ) -> PathBuf;\n \n-    fn extract_bundled_libs(\n-        &self,\n-        rlib: &Path,\n+    fn extract_bundled_libs<'a>(\n+        &'a self,\n+        rlib: &'a Path,\n         outdir: &Path,\n         bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) -> Result<(), String> {\n-        let message = |msg: &str, e: &dyn Display| format!(\"{} '{}': {}\", msg, &rlib.display(), e);\n+    ) -> Result<(), ExtractBundledLibsError<'_>> {\n         let archive_map = unsafe {\n-            Mmap::map(File::open(rlib).map_err(|e| message(\"failed to open file\", &e))?)\n-                .map_err(|e| message(\"failed to mmap file\", &e))?\n+            Mmap::map(\n+                File::open(rlib)\n+                    .map_err(|e| ExtractBundledLibsError::OpenFile { rlib, error: Box::new(e) })?,\n+            )\n+            .map_err(|e| ExtractBundledLibsError::MmapFile { rlib, error: Box::new(e) })?\n         };\n         let archive = ArchiveFile::parse(&*archive_map)\n-            .map_err(|e| message(\"failed to parse archive\", &e))?;\n+            .map_err(|e| ExtractBundledLibsError::ParseArchive { rlib, error: Box::new(e) })?;\n \n         for entry in archive.members() {\n-            let entry = entry.map_err(|e| message(\"failed to read entry\", &e))?;\n+            let entry = entry\n+                .map_err(|e| ExtractBundledLibsError::ReadEntry { rlib, error: Box::new(e) })?;\n             let data = entry\n                 .data(&*archive_map)\n-                .map_err(|e| message(\"failed to get data from archive member\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ArchiveMember { rlib, error: Box::new(e) })?;\n             let name = std::str::from_utf8(entry.name())\n-                .map_err(|e| message(\"failed to convert name\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ConvertName { rlib, error: Box::new(e) })?;\n             if !bundled_lib_file_names.contains(&Symbol::intern(name)) {\n                 continue; // We need to extract only native libraries.\n             }\n+            let data = search_for_section(rlib, data, \".bundled_lib\").map_err(|e| {\n+                ExtractBundledLibsError::ExtractSection { rlib, error: Box::<dyn Error>::from(e) }\n+            })?;\n             std::fs::write(&outdir.join(&name), data)\n-                .map_err(|e| message(\"failed to write file\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::WriteFile { rlib, error: Box::new(e) })?;\n         }\n         Ok(())\n     }"}, {"sha": "4445e5f6c3a64e3d24c0d9379f15cfd74337eda1", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 428, "deletions": 476, "changes": 904, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,9 +6,9 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_hir::def_id::CrateNum;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_metadata::find_native_static_library;\n-use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n+use rustc_metadata::fs::{emit_wrapper_file, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Lto, Strip};\n@@ -24,12 +24,12 @@ use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, Target};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo};\n \n use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n-use super::metadata::{create_rmeta_file, MetadataPosition};\n+use super::metadata::{create_wrapper_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n use crate::{\n     errors, looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n@@ -44,7 +44,7 @@ use std::borrow::Borrow;\n use std::cell::OnceCell;\n use std::collections::BTreeSet;\n use std::ffi::OsString;\n-use std::fs::{File, OpenOptions};\n+use std::fs::{read, File, OpenOptions};\n use std::io::{BufWriter, Write};\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n@@ -292,8 +292,8 @@ fn link_rlib<'a>(\n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n             let (metadata, metadata_position) =\n-                create_rmeta_file(sess, codegen_results.metadata.raw_data());\n-            let metadata = emit_metadata(sess, &metadata, tmpdir);\n+                create_wrapper_file(sess, b\".rmeta\".to_vec(), codegen_results.metadata.raw_data());\n+            let metadata = emit_wrapper_file(sess, &metadata, tmpdir, METADATA_FILENAME);\n             match metadata_position {\n                 MetadataPosition::First => {\n                     // Most of the time metadata in rlib files is wrapped in a \"dummy\" object\n@@ -376,12 +376,18 @@ fn link_rlib<'a>(\n             let location =\n                 find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             if sess.opts.unstable_opts.packed_bundled_libs && flavor == RlibFlavor::Normal {\n-                packed_bundled_libs.push(find_native_static_library(\n-                    lib.filename.unwrap().as_str(),\n+                let filename = lib.filename.unwrap();\n+                let lib_path = find_native_static_library(\n+                    filename.as_str(),\n                     Some(true),\n                     &lib_search_paths,\n                     sess,\n-                ));\n+                );\n+                let src = read(lib_path)\n+                    .map_err(|e| sess.emit_fatal(errors::ReadFileError { message: e }))?;\n+                let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n+                let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n+                packed_bundled_libs.push(wrapper_file);\n                 continue;\n             }\n             ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n@@ -391,13 +397,14 @@ fn link_rlib<'a>(\n     }\n \n     for (raw_dylib_name, raw_dylib_imports) in\n-        collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n+        collate_raw_dylibs(sess, codegen_results.crate_info.used_libraries.iter())?\n     {\n         let output_path = archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n             tmpdir.as_ref(),\n+            true,\n         );\n \n         ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|error| {\n@@ -449,9 +456,9 @@ fn link_rlib<'a>(\n /// then the CodegenResults value contains one NativeLib instance for each block.  However, the\n /// linker appears to expect only a single import library for each library used, so we need to\n /// collate the symbols together by library name before generating the import libraries.\n-fn collate_raw_dylibs(\n-    sess: &Session,\n-    used_libraries: &[NativeLib],\n+fn collate_raw_dylibs<'a, 'b>(\n+    sess: &'a Session,\n+    used_libraries: impl IntoIterator<Item = &'b NativeLib>,\n ) -> Result<Vec<(String, Vec<DllImport>)>, ErrorGuaranteed> {\n     // Use index maps to preserve original order of imports and libraries.\n     let mut dylib_table = FxIndexMap::<String, FxIndexMap<Symbol, &DllImport>>::default();\n@@ -918,29 +925,17 @@ fn link_natively<'a>(\n                         )\n                         .is_some();\n \n-                        sess.note_without_error(\"`link.exe` returned an unexpected error\");\n+                        sess.emit_note(errors::LinkExeUnexpectedError);\n                         if is_vs_installed && has_linker {\n                             // the linker is broken\n-                            sess.note_without_error(\n-                                \"the Visual Studio build tools may need to be repaired \\\n-                                using the Visual Studio installer\",\n-                            );\n-                            sess.note_without_error(\n-                                \"or a necessary component may be missing from the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::RepairVSBuildTools);\n+                            sess.emit_note(errors::MissingCppBuildToolComponent);\n                         } else if is_vs_installed {\n                             // the linker is not installed\n-                            sess.note_without_error(\n-                                \"in the Visual Studio installer, ensure the \\\n-                                \\\"C++ build tools\\\" workload is selected\",\n-                            );\n+                            sess.emit_note(errors::SelectCppBuildToolWorkload);\n                         } else {\n                             // visual studio is not installed\n-                            sess.note_without_error(\n-                                \"you may need to install Visual Studio build tools with the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::VisualStudioNotInstalled);\n                         }\n                     }\n                 }\n@@ -953,35 +948,20 @@ fn link_natively<'a>(\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n \n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n-                } else {\n-                    sess.struct_err(&format!(\n-                        \"could not exec the linker `{}`\",\n-                        linker_path.display()\n-                    ))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n+            if linker_not_found {\n+                sess.emit_err(errors::LinkerNotFound { linker_path, error: e });\n+            } else {\n+                sess.emit_err(errors::UnableToExeLinker {\n+                    linker_path,\n+                    error: e,\n+                    command_formatted: format!(\"{:?}\", &cmd),\n+                });\n             }\n \n-            linker_error.emit();\n-\n             if sess.target.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\n-                    \"the msvc targets depend on the msvc linker \\\n-                     but `link.exe` was not found\",\n-                );\n-                sess.note_without_error(\n-                    \"please ensure that Visual Studio 2017 or later, or Build Tools \\\n-                     for Visual Studio were installed with the Visual C++ option.\",\n-                );\n-                sess.note_without_error(\"VS Code is a different product, and is not sufficient.\");\n+                sess.emit_note(errors::MsvcMissingLinker);\n+                sess.emit_note(errors::CheckInstalledVisualStudio);\n+                sess.emit_note(errors::UnsufficientVSCodeProduct);\n             }\n             sess.abort_if_errors();\n         }\n@@ -1006,15 +986,13 @@ fn link_natively<'a>(\n                     if !prog.status.success() {\n                         let mut output = prog.stderr.clone();\n                         output.extend_from_slice(&prog.stdout);\n-                        sess.struct_warn(&format!(\n-                            \"processing debug info with `dsymutil` failed: {}\",\n-                            prog.status\n-                        ))\n-                        .note(&escape_string(&output))\n-                        .emit();\n+                        sess.emit_warning(errors::ProcessingDymutilFailed {\n+                            status: prog.status,\n+                            output: escape_string(&output),\n+                        });\n                     }\n                 }\n-                Err(e) => sess.fatal(&format!(\"unable to run `dsymutil`: {}\", e)),\n+                Err(error) => sess.emit_fatal(errors::UnableToRunDsymutil { error }),\n             }\n         }\n \n@@ -1091,15 +1069,14 @@ fn strip_symbols_with_external_utility<'a>(\n             if !prog.status.success() {\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n-                sess.struct_warn(&format!(\n-                    \"stripping debug info with `{}` failed: {}\",\n-                    util, prog.status\n-                ))\n-                .note(&escape_string(&output))\n-                .emit();\n+                sess.emit_warning(errors::StrippingDebugInfoFailed {\n+                    util,\n+                    status: prog.status,\n+                    output: escape_string(&output),\n+                });\n             }\n         }\n-        Err(e) => sess.fatal(&format!(\"unable to run `{}`: {}\", util, e)),\n+        Err(error) => sess.emit_fatal(errors::UnableToRun { util, error }),\n     }\n }\n \n@@ -1152,7 +1129,8 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n         if path.exists() {\n             return session_tlib;\n         } else {\n-            let default_sysroot = filesearch::get_or_default_sysroot();\n+            let default_sysroot =\n+                filesearch::get_or_default_sysroot().expect(\"Failed finding sysroot\");\n             let default_tlib = filesearch::make_target_lib_path(\n                 &default_sysroot,\n                 sess.opts.target_triple.triple(),\n@@ -1250,7 +1228,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n             )),\n             (Some(linker), None) => {\n                 let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                    sess.emit_fatal(errors::LinkerFileStem);\n                 });\n \n                 let flavor = if stem == \"emcc\" {\n@@ -1377,13 +1355,9 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         })\n         .collect();\n     if !lib_args.is_empty() {\n-        sess.note_without_error(\n-            \"Link against the following native artifacts when linking \\\n-                                 against this static library. The order and any duplication \\\n-                                 can be significant on some platforms.\",\n-        );\n+        sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+        sess.emit_note(errors::NativeStaticLibs { arguments: lib_args.join(\" \") });\n     }\n }\n \n@@ -1687,14 +1661,14 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     match (crate_type, &sess.target.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n             if !sess.target.linker_flavor.is_gnu() {\n-                sess.fatal(\"can only use link script when linking with GNU-like linker\");\n+                sess.emit_fatal(errors::LinkScriptUnavailable);\n             }\n \n             let file_name = [\"rustc\", &sess.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n \n             let path = tmpdir.join(file_name);\n-            if let Err(e) = fs::write(&path, script.as_ref()) {\n-                sess.fatal(&format!(\"failed to write link script to {}: {}\", path.display(), e));\n+            if let Err(error) = fs::write(&path, script.as_ref()) {\n+                sess.emit_fatal(errors::LinkScriptWriteFailure { path, error });\n             }\n \n             cmd.arg(\"--script\");\n@@ -1840,8 +1814,8 @@ fn add_linked_symbol_object(\n \n     let path = tmpdir.join(\"symbols.o\");\n     let result = std::fs::write(&path, file.write().unwrap());\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", path.display(), e));\n+    if let Err(error) = result {\n+        sess.emit_fatal(errors::FailedToWrite { path, error });\n     }\n     cmd.add_object(&path);\n }\n@@ -2039,15 +2013,9 @@ fn linker_with_args<'a>(\n     cmd.add_as_needed();\n \n     // Local native libraries of all kinds.\n-    //\n-    // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_local_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n-    // Upstream rust libraries and their (possibly bundled) static native libraries.\n+    // Upstream rust crates and their non-dynamic native libraries.\n     add_upstream_rust_crates(\n         cmd,\n         sess,\n@@ -2058,23 +2026,47 @@ fn linker_with_args<'a>(\n     );\n \n     // Dynamic native libraries from upstream crates.\n-    //\n-    // FIXME: Merge this to `add_upstream_rust_crates` so that all native libraries are linked\n-    // together with their respective upstream crates, and in their originally specified order.\n-    // This may be slightly breaking due to our use of `--as-needed` and needs a crater run.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_upstream_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_upstream_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n     // Link with the import library generated for any raw-dylib functions.\n     for (raw_dylib_name, raw_dylib_imports) in\n-        collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n+        collate_raw_dylibs(sess, codegen_results.crate_info.used_libraries.iter())?\n     {\n         cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n             tmpdir,\n+            true,\n+        ));\n+    }\n+    // As with add_upstream_native_libraries, we need to add the upstream raw-dylib symbols in case\n+    // they are used within inlined functions or instantiated generic functions. We do this *after*\n+    // handling the raw-dylib symbols in the current crate to make sure that those are chosen first\n+    // by the linker.\n+    let (_, dependency_linkage) = codegen_results\n+        .crate_info\n+        .dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n+    let native_libraries_from_nonstatics = codegen_results\n+        .crate_info\n+        .native_libraries\n+        .iter()\n+        .filter_map(|(cnum, libraries)| {\n+            (dependency_linkage[cnum.as_usize() - 1] != Linkage::Static).then(|| libraries)\n+        })\n+        .flatten();\n+    for (raw_dylib_name, raw_dylib_imports) in\n+        collate_raw_dylibs(sess, native_libraries_from_nonstatics)?\n+    {\n+        cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n+            sess,\n+            &raw_dylib_name,\n+            &raw_dylib_imports,\n+            tmpdir,\n+            false,\n         ));\n     }\n \n@@ -2268,56 +2260,56 @@ fn collect_natvis_visualizers(\n                 visualizer_paths.push(visualizer_out_file);\n             }\n             Err(error) => {\n-                sess.warn(\n-                    format!(\n-                        \"Unable to write debugger visualizer file `{}`: {} \",\n-                        visualizer_out_file.display(),\n-                        error\n-                    )\n-                    .as_str(),\n-                );\n+                sess.emit_warning(errors::UnableToWriteDebuggerVisualizer {\n+                    path: visualizer_out_file,\n+                    error,\n+                });\n             }\n         };\n     }\n     visualizer_paths\n }\n \n-/// # Native library linking\n-///\n-/// User-supplied library search paths (-L on the command line). These are the same paths used to\n-/// find Rust crates, so some of them may have been added already by the previous crate linking\n-/// code. This only allows them to be found at compile time so it is still entirely up to outside\n-/// forces to make sure that library can be found at runtime.\n-///\n-/// Also note that the native libraries linked here are only the ones located in the current crate.\n-/// Upstream crates with native library dependencies may have their native library pulled in above.\n-fn add_local_native_libraries(\n+fn add_native_libs_from_crate(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    search_paths: &OnceCell<Vec<PathBuf>>,\n+    bundled_libs: &FxHashSet<Symbol>,\n+    cnum: CrateNum,\n+    link_static: bool,\n+    link_dynamic: bool,\n ) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => {\n-                cmd.framework_path(&search_path.dir);\n-            }\n-            _ => {\n-                cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir));\n-            }\n-        }\n+    if !sess.opts.unstable_opts.link_native_libraries {\n+        // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n+        // external build system already has the native dependencies defined, and it\n+        // will provide them to the linker itself.\n+        return;\n     }\n \n-    let relevant_libs =\n-        codegen_results.crate_info.used_libraries.iter().filter(|l| relevant_lib(sess, l));\n+    if link_static && cnum != LOCAL_CRATE && !bundled_libs.is_empty() {\n+        // If rlib contains native libs as archives, unpack them to tmpdir.\n+        let rlib = &codegen_results.crate_info.used_crate_source[&cnum].rlib.as_ref().unwrap().0;\n+        archive_builder_builder\n+            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n+            .unwrap_or_else(|e| sess.emit_fatal(e));\n+    }\n+\n+    let native_libs = match cnum {\n+        LOCAL_CRATE => &codegen_results.crate_info.used_libraries,\n+        _ => &codegen_results.crate_info.native_libraries[&cnum],\n+    };\n \n-    let search_path = OnceCell::new();\n     let mut last = (None, NativeLibKind::Unspecified, None);\n-    for lib in relevant_libs {\n+    for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n         };\n-        let name = name.as_str();\n+        if !relevant_lib(sess, lib) {\n+            continue;\n+        }\n \n         // Skip if this library is the same as the last.\n         last = if (lib.name, lib.kind, lib.verbatim) == last {\n@@ -2326,46 +2318,119 @@ fn add_local_native_libraries(\n             (lib.name, lib.kind, lib.verbatim)\n         };\n \n+        let name = name.as_str();\n         let verbatim = lib.verbatim.unwrap_or(false);\n         match lib.kind {\n+            NativeLibKind::Static { bundle, whole_archive } => {\n+                if link_static {\n+                    let bundle = bundle.unwrap_or(true);\n+                    let whole_archive = whole_archive == Some(true)\n+                        // Backward compatibility case: this can be a rlib (so `+whole-archive`\n+                        // cannot be added explicitly if necessary, see the error in `fn link_rlib`)\n+                        // compiled as an executable due to `--test`. Use whole-archive implicitly,\n+                        // like before the introduction of native lib modifiers.\n+                        || (whole_archive == None\n+                            && bundle\n+                            && cnum == LOCAL_CRATE\n+                            && sess.opts.test);\n+\n+                    if bundle && cnum != LOCAL_CRATE {\n+                        if let Some(filename) = lib.filename {\n+                            // If rlib contains native libs as archives, they are unpacked to tmpdir.\n+                            let path = tmpdir.join(filename.as_str());\n+                            if whole_archive {\n+                                cmd.link_whole_rlib(&path);\n+                            } else {\n+                                cmd.link_rlib(&path);\n+                            }\n+                        }\n+                    } else {\n+                        if whole_archive {\n+                            cmd.link_whole_staticlib(\n+                                name,\n+                                verbatim,\n+                                &search_paths.get_or_init(|| archive_search_paths(sess)),\n+                            );\n+                        } else {\n+                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n+                            // with glibc. This logic should be moved to the libc crate.\n+                            if cnum != LOCAL_CRATE\n+                                && sess.target.os == \"linux\"\n+                                && sess.target.env == \"gnu\"\n+                                && name == \"c\"\n+                            {\n+                                cmd.link_staticlib(\"gcc\", false);\n+                            }\n+                            cmd.link_staticlib(name, verbatim)\n+                        }\n+                    }\n+                }\n+            }\n             NativeLibKind::Dylib { as_needed } => {\n-                cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                }\n             }\n-            NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-            NativeLibKind::Framework { as_needed } => {\n-                cmd.link_framework(name, as_needed.unwrap_or(true))\n+            NativeLibKind::Unspecified => {\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, true);\n+                }\n             }\n-            NativeLibKind::Static { whole_archive, bundle, .. } => {\n-                if whole_archive == Some(true)\n-                    // Backward compatibility case: this can be a rlib (so `+whole-archive` cannot\n-                    // be added explicitly if necessary, see the error in `fn link_rlib`) compiled\n-                    // as an executable due to `--test`. Use whole-archive implicitly, like before\n-                    // the introduction of native lib modifiers.\n-                    || (whole_archive == None && bundle != Some(false) && sess.opts.test)\n-                {\n-                    cmd.link_whole_staticlib(\n-                        name,\n-                        verbatim,\n-                        &search_path.get_or_init(|| archive_search_paths(sess)),\n-                    );\n-                } else {\n-                    cmd.link_staticlib(name, verbatim)\n+            NativeLibKind::Framework { as_needed } => {\n+                if link_dynamic {\n+                    cmd.link_framework(name, as_needed.unwrap_or(true))\n                 }\n             }\n             NativeLibKind::RawDylib => {\n-                // Ignore RawDylib here, they are handled separately in linker_with_args().\n+                // Handled separately in `linker_with_args`.\n             }\n             NativeLibKind::LinkArg => {\n-                cmd.arg(name);\n+                if link_static {\n+                    cmd.arg(name);\n+                }\n             }\n         }\n     }\n }\n \n-/// # Linking Rust crates and their non-bundled static libraries\n-///\n-/// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n-/// linked when producing the final output (instead of the intermediate rlib version).\n+fn add_local_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    if sess.opts.unstable_opts.link_native_libraries {\n+        // User-supplied library search paths (-L on the command line). These are the same paths\n+        // used to find Rust crates, so some of them may have been added already by the previous\n+        // crate linking code. This only allows them to be found at compile time so it is still\n+        // entirely up to outside forces to make sure that library can be found at runtime.\n+        for search_path in sess.target_filesearch(PathKind::All).search_paths() {\n+            match search_path.kind {\n+                PathKind::Framework => cmd.framework_path(&search_path.dir),\n+                _ => cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)),\n+            }\n+        }\n+    }\n+\n+    let search_paths = OnceCell::new();\n+    // All static and dynamic native library dependencies are linked to the local crate.\n+    let link_static = true;\n+    let link_dynamic = true;\n+    add_native_libs_from_crate(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        tmpdir,\n+        &search_paths,\n+        &Default::default(),\n+        LOCAL_CRATE,\n+        link_static,\n+        link_dynamic,\n+    );\n+}\n+\n fn add_upstream_rust_crates<'a>(\n     cmd: &mut dyn Linker,\n     sess: &'a Session,\n@@ -2381,354 +2446,241 @@ fn add_upstream_rust_crates<'a>(\n     // Linking to a rlib involves just passing it to the linker (the linker\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n-\n     let (_, data) = codegen_results\n         .crate_info\n         .dependency_formats\n         .iter()\n         .find(|(ty, _)| *ty == crate_type)\n         .expect(\"failed to find crate type in dependency format list\");\n \n-    // Invoke get_used_crates to ensure that we get a topological sorting of\n-    // crates.\n-    let deps = &codegen_results.crate_info.used_crates;\n-\n-    let mut compiler_builtins = None;\n-    let search_path = OnceCell::new();\n-\n-    for &cnum in deps.iter() {\n-        // We may not pass all crates through to the linker. Some crates may\n-        // appear statically in an existing dylib, meaning we'll pick up all the\n-        // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n-            _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &Default::default(),\n-                );\n-            }\n-            // compiler-builtins are always placed last to ensure that they're\n-            // linked correctly.\n-            _ if codegen_results.crate_info.compiler_builtins == Some(cnum) => {\n-                assert!(compiler_builtins.is_none());\n-                compiler_builtins = Some(cnum);\n-            }\n-            Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                let bundled_libs = if sess.opts.unstable_opts.packed_bundled_libs {\n-                    codegen_results.crate_info.native_libraries[&cnum]\n+    let search_paths = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // We may not pass all crates through to the linker. Some crates may appear statically in\n+        // an existing dylib, meaning we'll pick up all the symbols from the dylib.\n+        // We must always link crates `compiler_builtins` and `profiler_builtins` statically.\n+        // Even if they were already included into a dylib\n+        // (e.g. `libstd` when `-C prefer-dynamic` is used).\n+        // FIXME: `dependency_formats` can report `profiler_builtins` as `NotLinked` for some\n+        // reason, it shouldn't do that because `profiler_builtins` should indeed be linked.\n+        let linkage = data[cnum.as_usize() - 1];\n+        let link_static_crate = linkage == Linkage::Static\n+            || (linkage == Linkage::IncludedFromDylib || linkage == Linkage::NotLinked)\n+                && (codegen_results.crate_info.compiler_builtins == Some(cnum)\n+                    || codegen_results.crate_info.profiler_runtime == Some(cnum));\n+\n+        let mut bundled_libs = Default::default();\n+        match linkage {\n+            Linkage::Static | Linkage::IncludedFromDylib | Linkage::NotLinked => {\n+                if link_static_crate {\n+                    bundled_libs = codegen_results.crate_info.native_libraries[&cnum]\n                         .iter()\n                         .filter_map(|lib| lib.filename)\n-                        .collect::<FxHashSet<_>>()\n-                } else {\n-                    Default::default()\n-                };\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &bundled_libs,\n-                );\n-\n-                // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n-                // is being linked statically to the current crate.  If it's linked dynamically\n-                // or is an rlib already included via some other dylib crate, the symbols from\n-                // native libs will have already been included in that dylib.\n-                //\n-                // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-                // external build system already has the native dependencies defined, and it\n-                // will provide them to the linker itself.\n-                if sess.opts.unstable_opts.link_native_libraries {\n-                    if sess.opts.unstable_opts.packed_bundled_libs {\n-                        // If rlib contains native libs as archives, unpack them to tmpdir.\n-                        let rlib = &src.rlib.as_ref().unwrap().0;\n-                        archive_builder_builder\n-                            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.fatal(e));\n-                    }\n-\n-                    let mut last = (None, NativeLibKind::Unspecified, None);\n-                    for lib in &codegen_results.crate_info.native_libraries[&cnum] {\n-                        let Some(name) = lib.name else {\n-                            continue;\n-                        };\n-                        let name = name.as_str();\n-                        if !relevant_lib(sess, lib) {\n-                            continue;\n-                        }\n-\n-                        // Skip if this library is the same as the last.\n-                        last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                            continue;\n-                        } else {\n-                            (lib.name, lib.kind, lib.verbatim)\n-                        };\n-\n-                        match lib.kind {\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(true),\n-                            } => {\n-                                cmd.link_whole_staticlib(\n-                                    name,\n-                                    lib.verbatim.unwrap_or(false),\n-                                    search_path.get_or_init(|| archive_search_paths(sess)),\n-                                );\n-                            }\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(false) | None,\n-                            } => {\n-                                // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                                // with glibc. This logic should be moved to the libc crate.\n-                                if sess.target.os == \"linux\"\n-                                    && sess.target.env == \"gnu\"\n-                                    && name == \"c\"\n-                                {\n-                                    cmd.link_staticlib(\"gcc\", false);\n-                                }\n-                                cmd.link_staticlib(name, lib.verbatim.unwrap_or(false));\n-                            }\n-                            NativeLibKind::LinkArg => {\n-                                cmd.arg(name);\n-                            }\n-                            NativeLibKind::Dylib { .. }\n-                            | NativeLibKind::Framework { .. }\n-                            | NativeLibKind::Unspecified\n-                            | NativeLibKind::RawDylib => {}\n-                            NativeLibKind::Static { bundle: Some(true) | None, whole_archive } => {\n-                                if sess.opts.unstable_opts.packed_bundled_libs {\n-                                    // If rlib contains native libs as archives, they are unpacked to tmpdir.\n-                                    let path = tmpdir.join(lib.filename.unwrap().as_str());\n-                                    if whole_archive == Some(true) {\n-                                        cmd.link_whole_rlib(&path);\n-                                    } else {\n-                                        cmd.link_rlib(&path);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n+                        .collect();\n+                    add_static_crate(\n+                        cmd,\n+                        sess,\n+                        archive_builder_builder,\n+                        codegen_results,\n+                        tmpdir,\n+                        cnum,\n+                        &bundled_libs,\n+                    );\n                 }\n             }\n-            Linkage::Dynamic => add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0),\n+            Linkage::Dynamic => {\n+                let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0);\n+            }\n         }\n-    }\n \n-    // compiler-builtins are always placed last to ensure that they're\n-    // linked correctly.\n-    // We must always link the `compiler_builtins` crate statically. Even if it\n-    // was already \"included\" in a dylib (e.g., `libstd` when `-C prefer-dynamic`\n-    // is used)\n-    if let Some(cnum) = compiler_builtins {\n-        add_static_crate(\n+        // Static libraries are linked for a subset of linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we do not link\n+        // the native library because it is already linked into the dylib, and even if\n+        // inline/const/generic functions from the dylib can refer to symbols from the native\n+        // library, those symbols should be exported and available from the dylib anyway.\n+        // 3. Libraries bundled into `(compiler,profiler)_builtins` are special, see above.\n+        let link_static = link_static_crate;\n+        // Dynamic libraries are not linked here, see the FIXME in `add_upstream_native_libraries`.\n+        let link_dynamic = false;\n+        add_native_libs_from_crate(\n             cmd,\n             sess,\n             archive_builder_builder,\n             codegen_results,\n             tmpdir,\n+            &search_paths,\n+            &bundled_libs,\n             cnum,\n-            &Default::default(),\n+            link_static,\n+            link_dynamic,\n         );\n     }\n+}\n \n-    // Converts a library file-stem into a cc -l argument\n-    fn unlib<'a>(target: &Target, stem: &'a str) -> &'a str {\n-        if stem.starts_with(\"lib\") && !target.is_like_windows { &stem[3..] } else { stem }\n+fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    let search_path = OnceCell::new();\n+    for &cnum in &codegen_results.crate_info.used_crates {\n+        // Static libraries are not linked here, they are linked in `add_upstream_rust_crates`.\n+        // FIXME: Merge this function to `add_upstream_rust_crates` so that all native libraries\n+        // are linked together with their respective upstream crates, and in their originally\n+        // specified order. This is slightly breaking due to our use of `--as-needed` (see crater\n+        // results in https://github.com/rust-lang/rust/pull/102832#issuecomment-1279772306).\n+        let link_static = false;\n+        // Dynamic libraries are linked for all linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we have to link\n+        // the native library too because inline/const/generic functions from the dylib can refer\n+        // to symbols from the native library, so the native library providing those symbols should\n+        // be available when linking our final binary.\n+        let link_dynamic = true;\n+        add_native_libs_from_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            &search_path,\n+            &Default::default(),\n+            cnum,\n+            link_static,\n+            link_dynamic,\n+        );\n     }\n+}\n \n-    // Adds the static \"rlib\" versions of all crates to the command line.\n-    // There's a bit of magic which happens here specifically related to LTO,\n-    // namely that we remove upstream object files.\n-    //\n-    // When performing LTO, almost(*) all of the bytecode from the upstream\n-    // libraries has already been included in our object file output. As a\n-    // result we need to remove the object files in the upstream libraries so\n-    // the linker doesn't try to include them twice (or whine about duplicate\n-    // symbols). We must continue to include the rest of the rlib, however, as\n-    // it may contain static native libraries which must be linked in.\n-    //\n-    // (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n-    // their bytecode wasn't included. The object files in those libraries must\n-    // still be passed to the linker.\n-    //\n-    // Note, however, that if we're not doing LTO we can just pass the rlib\n-    // blindly to the linker (fast) because it's fine if it's not actually\n-    // included as we're at the end of the dependency chain.\n-    fn add_static_crate<'a>(\n-        cmd: &mut dyn Linker,\n-        sess: &'a Session,\n-        archive_builder_builder: &dyn ArchiveBuilderBuilder,\n-        codegen_results: &CodegenResults,\n-        tmpdir: &Path,\n-        cnum: CrateNum,\n-        bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) {\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        let cratepath = &src.rlib.as_ref().unwrap().0;\n-\n-        let mut link_upstream = |path: &Path| {\n-            cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n-        };\n-\n-        // See the comment above in `link_staticlib` and `link_rlib` for why if\n-        // there's a static library that's not relevant we skip all object\n-        // files.\n-        let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n-        let skip_native = native_libs.iter().any(|lib| {\n-            matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n-                && !relevant_lib(sess, lib)\n-        });\n-\n-        if (!are_upstream_rust_objects_already_included(sess)\n-            || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n-            && !skip_native\n-        {\n-            link_upstream(cratepath);\n-            return;\n-        }\n-\n-        let dst = tmpdir.join(cratepath.file_name().unwrap());\n-        let name = cratepath.file_name().unwrap().to_str().unwrap();\n-        let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n-        let bundled_lib_file_names = bundled_lib_file_names.clone();\n-\n-        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n-            let canonical_name = name.replace('-', \"_\");\n-            let upstream_rust_objects_already_included =\n-                are_upstream_rust_objects_already_included(sess);\n-            let is_builtins = sess.target.no_builtins\n-                || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n-\n-            let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(e) = archive.add_archive(\n-                cratepath,\n-                Box::new(move |f| {\n-                    if f == METADATA_FILENAME {\n-                        return true;\n-                    }\n+// Adds the static \"rlib\" versions of all crates to the command line.\n+// There's a bit of magic which happens here specifically related to LTO,\n+// namely that we remove upstream object files.\n+//\n+// When performing LTO, almost(*) all of the bytecode from the upstream\n+// libraries has already been included in our object file output. As a\n+// result we need to remove the object files in the upstream libraries so\n+// the linker doesn't try to include them twice (or whine about duplicate\n+// symbols). We must continue to include the rest of the rlib, however, as\n+// it may contain static native libraries which must be linked in.\n+//\n+// (*) Crates marked with `#![no_builtins]` don't participate in LTO and\n+// their bytecode wasn't included. The object files in those libraries must\n+// still be passed to the linker.\n+//\n+// Note, however, that if we're not doing LTO we can just pass the rlib\n+// blindly to the linker (fast) because it's fine if it's not actually\n+// included as we're at the end of the dependency chain.\n+fn add_static_crate<'a>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    cnum: CrateNum,\n+    bundled_lib_file_names: &FxHashSet<Symbol>,\n+) {\n+    let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+    let cratepath = &src.rlib.as_ref().unwrap().0;\n \n-                    let canonical = f.replace('-', \"_\");\n-\n-                    let is_rust_object =\n-                        canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n-\n-                    // If we've been requested to skip all native object files\n-                    // (those not generated by the rust compiler) then we can skip\n-                    // this file. See above for why we may want to do this.\n-                    let skip_because_cfg_say_so = skip_native && !is_rust_object;\n-\n-                    // If we're performing LTO and this is a rust-generated object\n-                    // file, then we don't need the object file as it's part of the\n-                    // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n-                    // though, so we let that object file slide.\n-                    let skip_because_lto =\n-                        upstream_rust_objects_already_included && is_rust_object && is_builtins;\n-\n-                    // We skip native libraries because:\n-                    // 1. This native libraries won't be used from the generated rlib,\n-                    //    so we can throw them away to avoid the copying work.\n-                    // 2. We can't allow it to be a single remaining entry in archive\n-                    //    as some linkers may complain on that.\n-                    if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n-                        return true;\n-                    }\n+    let mut link_upstream = |path: &Path| {\n+        cmd.link_rlib(&fix_windows_verbatim_for_gcc(path));\n+    };\n \n-                    if skip_because_cfg_say_so || skip_because_lto {\n-                        return true;\n-                    }\n+    // See the comment above in `link_staticlib` and `link_rlib` for why if\n+    // there's a static library that's not relevant we skip all object\n+    // files.\n+    let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n+    let skip_native = native_libs.iter().any(|lib| {\n+        matches!(lib.kind, NativeLibKind::Static { bundle: None | Some(true), .. })\n+            && !relevant_lib(sess, lib)\n+    });\n \n-                    false\n-                }),\n-            ) {\n-                sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n-            }\n-            if archive.build(&dst) {\n-                link_upstream(&dst);\n-            }\n-        });\n+    if (!are_upstream_rust_objects_already_included(sess)\n+        || ignored_for_lto(sess, &codegen_results.crate_info, cnum))\n+        && !skip_native\n+    {\n+        link_upstream(cratepath);\n+        return;\n     }\n \n-    // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n-        // Just need to tell the linker about where the library lives and\n-        // what its name is\n-        let parent = cratepath.parent();\n-        if let Some(dir) = parent {\n-            cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n-        }\n-        let filestem = cratepath.file_stem().unwrap().to_str().unwrap();\n-        cmd.link_rust_dylib(\n-            &unlib(&sess.target, filestem),\n-            parent.unwrap_or_else(|| Path::new(\"\")),\n-        );\n-    }\n-}\n+    let dst = tmpdir.join(cratepath.file_name().unwrap());\n+    let name = cratepath.file_name().unwrap().to_str().unwrap();\n+    let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n+    let bundled_lib_file_names = bundled_lib_file_names.clone();\n \n-/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n-/// native dependencies are all non-static dependencies. We've got two cases then:\n-///\n-/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n-/// the rlib is just an archive.\n-///\n-/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n-/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n-/// dynamic dependency to this crate as well.\n-///\n-/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n-/// purely an implementation detail of the crate itself, but the problem arises with generic and\n-/// inlined functions. If a generic function calls a native function, then the generic function\n-/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n-/// in the target crate.\n-fn add_upstream_native_libraries(\n-    cmd: &mut dyn Linker,\n-    sess: &Session,\n-    codegen_results: &CodegenResults,\n-) {\n-    let mut last = (None, NativeLibKind::Unspecified, None);\n-    for &cnum in &codegen_results.crate_info.used_crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let Some(name) = lib.name else {\n-                continue;\n-            };\n-            let name = name.as_str();\n-            if !relevant_lib(sess, &lib) {\n-                continue;\n-            }\n+    sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n+        let canonical_name = name.replace('-', \"_\");\n+        let upstream_rust_objects_already_included =\n+            are_upstream_rust_objects_already_included(sess);\n+        let is_builtins =\n+            sess.target.no_builtins || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n-            // Skip if this library is the same as the last.\n-            last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                continue;\n-            } else {\n-                (lib.name, lib.kind, lib.verbatim)\n-            };\n+        let mut archive = archive_builder_builder.new_archive_builder(sess);\n+        if let Err(e) = archive.add_archive(\n+            cratepath,\n+            Box::new(move |f| {\n+                if f == METADATA_FILENAME {\n+                    return true;\n+                }\n \n-            let verbatim = lib.verbatim.unwrap_or(false);\n-            match lib.kind {\n-                NativeLibKind::Dylib { as_needed } => {\n-                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                let canonical = f.replace('-', \"_\");\n+\n+                let is_rust_object =\n+                    canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n+\n+                // If we've been requested to skip all native object files\n+                // (those not generated by the rust compiler) then we can skip\n+                // this file. See above for why we may want to do this.\n+                let skip_because_cfg_say_so = skip_native && !is_rust_object;\n+\n+                // If we're performing LTO and this is a rust-generated object\n+                // file, then we don't need the object file as it's part of the\n+                // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n+                // though, so we let that object file slide.\n+                let skip_because_lto =\n+                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n+\n+                // We skip native libraries because:\n+                // 1. This native libraries won't be used from the generated rlib,\n+                //    so we can throw them away to avoid the copying work.\n+                // 2. We can't allow it to be a single remaining entry in archive\n+                //    as some linkers may complain on that.\n+                if bundled_lib_file_names.contains(&Symbol::intern(f)) {\n+                    return true;\n                 }\n-                NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-                NativeLibKind::Framework { as_needed } => {\n-                    cmd.link_framework(name, as_needed.unwrap_or(true))\n+\n+                if skip_because_cfg_say_so || skip_because_lto {\n+                    return true;\n                 }\n-                // ignore static native libraries here as we've\n-                // already included them in add_local_native_libraries and\n-                // add_upstream_rust_crates\n-                NativeLibKind::Static { .. } => {}\n-                NativeLibKind::RawDylib | NativeLibKind::LinkArg => {}\n-            }\n+\n+                false\n+            }),\n+        ) {\n+            sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n         }\n-    }\n+        if archive.build(&dst) {\n+            link_upstream(&dst);\n+        }\n+    });\n+}\n+\n+// Same thing as above, but for dynamic crates instead of static crates.\n+fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n+    // Just need to tell the linker about where the library lives and\n+    // what its name is\n+    let parent = cratepath.parent();\n+    if let Some(dir) = parent {\n+        cmd.include_path(&fix_windows_verbatim_for_gcc(dir));\n+    }\n+    let stem = cratepath.file_stem().unwrap().to_str().unwrap();\n+    // Convert library file-stem into a cc -l argument.\n+    let prefix = if stem.starts_with(\"lib\") && !sess.target.is_like_windows { 3 } else { 0 };\n+    cmd.link_rust_dylib(&stem[prefix..], parent.unwrap_or_else(|| Path::new(\"\")));\n }\n \n fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n@@ -2782,14 +2734,14 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         (\"arm\", \"watchos\") => \"watchos\",\n         (_, \"macos\") => \"macosx\",\n         _ => {\n-            sess.err(&format!(\"unsupported arch `{}` for os `{}`\", arch, os));\n+            sess.emit_err(errors::UnsupportedArch { arch, os });\n             return;\n         }\n     };\n     let sdk_root = match get_apple_sdk_root(sdk_name) {\n         Ok(s) => s,\n         Err(e) => {\n-            sess.err(&e);\n+            sess.emit_err(e);\n             return;\n         }\n     };\n@@ -2805,7 +2757,7 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     }\n }\n \n-fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n+fn get_apple_sdk_root(sdk_name: &str) -> Result<String, errors::AppleSdkRootError<'_>> {\n     // Following what clang does\n     // (https://github.com/llvm/llvm-project/blob/\n     // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n@@ -2855,7 +2807,7 @@ fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n \n     match res {\n         Ok(output) => Ok(output.trim().to_string()),\n-        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n+        Err(error) => Err(errors::AppleSdkRootError::SdkPath { sdk_name, error }),\n     }\n }\n \n@@ -2888,7 +2840,7 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n                 }\n             }\n         } else {\n-            sess.fatal(\"option `-Z gcc-ld` is used even though linker flavor is not gcc\");\n+            sess.emit_fatal(errors::OptionGccOnly);\n         }\n     }\n }"}, {"sha": "7f0c2861f7e29014de16da9d8817dc50a7c8c6c6", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1260,11 +1260,11 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n \n     fn link_whole_staticlib(&mut self, lib: &str, _verbatim: bool, _search_path: &[PathBuf]) {\n-        self.cmd.arg(\"-l\").arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(\"-l\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n-        self.cmd.arg(lib);\n+        self.cmd.arg(\"--whole-archive\").arg(lib).arg(\"--no-whole-archive\");\n     }\n \n     fn gc_sections(&mut self, _keep_metadata: bool) {"}, {"sha": "780a3850036816c00f50dcb623b89cc47d3bc8de", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -60,7 +60,7 @@ impl MetadataLoader for DefaultMetadataLoader {\n                     let data = entry\n                         .data(data)\n                         .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n-                    return search_for_metadata(path, data, \".rmeta\");\n+                    return search_for_section(path, data, \".rmeta\");\n                 }\n             }\n \n@@ -69,11 +69,11 @@ impl MetadataLoader for DefaultMetadataLoader {\n     }\n \n     fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<MetadataRef, String> {\n-        load_metadata_with(path, |data| search_for_metadata(path, data, \".rustc\"))\n+        load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n     }\n }\n \n-fn search_for_metadata<'a>(\n+pub(super) fn search_for_section<'a>(\n     path: &Path,\n     bytes: &'a [u8],\n     section: &str,\n@@ -223,7 +223,11 @@ pub enum MetadataPosition {\n // * ELF - All other targets are similar to Windows in that there's a\n //   `SHF_EXCLUDE` flag we can set on sections in an object file to get\n //   automatically removed from the final output.\n-pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataPosition) {\n+pub fn create_wrapper_file(\n+    sess: &Session,\n+    section_name: Vec<u8>,\n+    data: &[u8],\n+) -> (Vec<u8>, MetadataPosition) {\n     let Some(mut file) = create_object_file(sess) else {\n         // This is used to handle all \"other\" targets. This includes targets\n         // in two categories:\n@@ -241,11 +245,11 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataP\n         // WebAssembly and for targets not supported by the `object` crate\n         // yet it means that work will need to be done in the `object` crate\n         // to add a case above.\n-        return (metadata.to_vec(), MetadataPosition::Last);\n+        return (data.to_vec(), MetadataPosition::Last);\n     };\n     let section = file.add_section(\n         file.segment_name(StandardSegment::Debug).to_vec(),\n-        b\".rmeta\".to_vec(),\n+        section_name,\n         SectionKind::Debug,\n     );\n     match file.format() {\n@@ -259,7 +263,7 @@ pub fn create_rmeta_file(sess: &Session, metadata: &[u8]) -> (Vec<u8>, MetadataP\n         }\n         _ => {}\n     };\n-    file.append_section_data(section, metadata, 1);\n+    file.append_section_data(section, data, 1);\n     (file.write().unwrap(), MetadataPosition::First)\n }\n "}, {"sha": "752f6b1ef40c92fcdd64994d03c715f9ad6ee90b", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -193,8 +193,11 @@ fn exported_symbols_provider_local<'tcx>(\n     }\n \n     if tcx.allocator_kind(()).is_some() {\n-        for method in ALLOCATOR_METHODS {\n-            let symbol_name = format!(\"__rust_{}\", method.name);\n+        for symbol_name in ALLOCATOR_METHODS\n+            .iter()\n+            .map(|method| format!(\"__rust_{}\", method.name))\n+            .chain([\"__rust_alloc_error_handler\".to_string(), OomStrategy::SYMBOL.to_string()])\n+        {\n             let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(tcx, &symbol_name));\n \n             symbols.push(("}, {"sha": "e3d28a1aca20eacfc1dc08ad628a58bb06b0d1a8", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,10 +15,8 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{\n-    translation::{to_fluent_args, Translate},\n-    DiagnosticId, FatalError, Handler, Level,\n-};\n+use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{DiagnosticMessage, Style};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -38,6 +36,7 @@ use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n use rustc_target::spec::{MergeFunctions, SanitizerSet};\n \n use std::any::Any;\n+use std::borrow::Cow;\n use std::fs;\n use std::io;\n use std::marker::PhantomData;\n@@ -969,8 +968,11 @@ pub enum Message<B: WriteBackendMethods> {\n     CodegenAborted,\n }\n \n+type DiagnosticArgName<'source> = Cow<'source, str>;\n+\n struct Diagnostic {\n-    msg: String,\n+    msg: Vec<(DiagnosticMessage, Style)>,\n+    args: FxHashMap<DiagnosticArgName<'static>, rustc_errors::DiagnosticArgValue<'static>>,\n     code: Option<DiagnosticId>,\n     lvl: Level,\n }\n@@ -1743,15 +1745,18 @@ impl Translate for SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n-        let fluent_args = to_fluent_args(diag.args());\n+        let args: FxHashMap<Cow<'_, str>, rustc_errors::DiagnosticArgValue<'_>> =\n+            diag.args().map(|(name, arg)| (name.clone(), arg.clone())).collect();\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n+            msg: diag.message.clone(),\n+            args: args.clone(),\n             code: diag.code.clone(),\n             lvl: diag.level(),\n         })));\n         for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-                msg: self.translate_messages(&child.message, &fluent_args).to_string(),\n+                msg: child.message.clone(),\n+                args: args.clone(),\n                 code: None,\n                 lvl: child.level,\n             })));\n@@ -1782,10 +1787,11 @@ impl SharedEmitterMain {\n             match message {\n                 Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n                     let handler = sess.diagnostic();\n-                    let mut d = rustc_errors::Diagnostic::new(diag.lvl, &diag.msg);\n+                    let mut d = rustc_errors::Diagnostic::new_with_messages(diag.lvl, diag.msg);\n                     if let Some(code) = diag.code {\n                         d.code(code);\n                     }\n+                    d.replace_args(diag.args);\n                     handler.emit_diagnostic(&mut d);\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, level, source)) => {"}, {"sha": "4f396e970ad70969228cae3756eec5273af4a483", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -22,7 +22,6 @@ use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::weak_lang_items::WEAK_ITEMS_SYMBOLS;\n use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n@@ -337,40 +336,26 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n pub fn cast_shift_expr_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-) -> Bx::Value {\n-    cast_shift_rhs(bx, op, lhs, rhs)\n-}\n-\n-fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    op: hir::BinOpKind,\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n     // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = bx.cx().val_ty(rhs);\n-        let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n-            rhs_llty = bx.cx().element_type(rhs_llty)\n-        }\n-        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n-            lhs_llty = bx.cx().element_type(lhs_llty)\n-        }\n-        let rhs_sz = bx.cx().int_width(rhs_llty);\n-        let lhs_sz = bx.cx().int_width(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            bx.trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            bx.zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n+    let mut rhs_llty = bx.cx().val_ty(rhs);\n+    let mut lhs_llty = bx.cx().val_ty(lhs);\n+    if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+        rhs_llty = bx.cx().element_type(rhs_llty)\n+    }\n+    if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+        lhs_llty = bx.cx().element_type(lhs_llty)\n+    }\n+    let rhs_sz = bx.cx().int_width(rhs_llty);\n+    let lhs_sz = bx.cx().int_width(lhs_llty);\n+    if lhs_sz < rhs_sz {\n+        bx.trunc(rhs, lhs_llty)\n+    } else if lhs_sz > rhs_sz {\n+        // FIXME (#1877: If in the future shifting by negative\n+        // values is no longer undefined then this is wrong.\n+        bx.zext(rhs, lhs_llty)\n     } else {\n         rhs\n     }\n@@ -653,7 +638,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n-            backend.codegen_allocator(tcx, &llmod_id, kind, tcx.lang_items().oom().is_some())\n+            backend.codegen_allocator(\n+                tcx,\n+                &llmod_id,\n+                kind,\n+                // If allocator_kind is Some then alloc_error_handler_kind must\n+                // also be Some.\n+                tcx.alloc_error_handler_kind(()).unwrap(),\n+            )\n         });\n \n         Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })\n@@ -841,20 +833,30 @@ impl CrateInfo {\n         //\n         // In order to get this left-to-right dependency ordering, we use the reverse\n         // postorder of all crates putting the leaves at the right-most positions.\n-        let used_crates = tcx\n+        let mut compiler_builtins = None;\n+        let mut used_crates: Vec<_> = tcx\n             .postorder_cnums(())\n             .iter()\n             .rev()\n             .copied()\n-            .filter(|&cnum| !tcx.dep_kind(cnum).macros_only())\n+            .filter(|&cnum| {\n+                let link = !tcx.dep_kind(cnum).macros_only();\n+                if link && tcx.is_compiler_builtins(cnum) {\n+                    compiler_builtins = Some(cnum);\n+                    return false;\n+                }\n+                link\n+            })\n             .collect();\n+        // `compiler_builtins` are always placed last to ensure that they're linked correctly.\n+        used_crates.extend(compiler_builtins);\n \n         let mut info = CrateInfo {\n             target_cpu,\n             exported_symbols,\n             linked_symbols,\n             local_crate_name,\n-            compiler_builtins: None,\n+            compiler_builtins,\n             profiler_runtime: None,\n             is_no_builtins: Default::default(),\n             native_libraries: Default::default(),\n@@ -880,9 +882,6 @@ impl CrateInfo {\n \n             let used_crate_source = tcx.used_crate_source(cnum);\n             info.used_crate_source.insert(cnum, used_crate_source.clone());\n-            if tcx.is_compiler_builtins(cnum) {\n-                info.compiler_builtins = Some(cnum);\n-            }\n             if tcx.is_profiler_runtime(cnum) {\n                 info.profiler_runtime = Some(cnum);\n             }\n@@ -901,14 +900,14 @@ impl CrateInfo {\n         // by the compiler, but that's ok because all this stuff is unstable anyway.\n         let target = &tcx.sess.target;\n         if !are_upstream_rust_objects_already_included(tcx.sess) {\n-            let missing_weak_lang_items: FxHashSet<&Symbol> = info\n+            let missing_weak_lang_items: FxHashSet<Symbol> = info\n                 .used_crates\n                 .iter()\n-                .flat_map(|cnum| {\n-                    tcx.missing_lang_items(*cnum)\n-                        .iter()\n-                        .filter(|l| lang_items::required(tcx, **l))\n-                        .filter_map(|item| WEAK_ITEMS_SYMBOLS.get(item))\n+                .flat_map(|&cnum| tcx.missing_lang_items(cnum))\n+                .filter(|l| l.is_weak())\n+                .filter_map(|&l| {\n+                    let name = l.link_name()?;\n+                    lang_items::required(tcx, l).then_some(name)\n                 })\n                 .collect();\n             let prefix = if target.is_like_windows && target.arch == \"x86\" { \"_\" } else { \"\" };"}, {"sha": "71f9179d02cca4d8755242083bf1e43b0e27812a", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n@@ -140,7 +139,7 @@ pub fn build_unchecked_lshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -152,7 +151,7 @@ pub fn build_unchecked_rshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "8647fbace2a75458988d8589c1c1c498c39f7d5d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -59,7 +59,13 @@ fn push_debuginfo_type_name<'tcx>(\n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n-        ty::Str => output.push_str(\"str\"),\n+        ty::Str => {\n+            if cpp_like_debuginfo {\n+                output.push_str(\"str$\")\n+            } else {\n+                output.push_str(\"str\")\n+            }\n+        }\n         ty::Never => {\n             if cpp_like_debuginfo {\n                 output.push_str(\"never$\");\n@@ -152,25 +158,19 @@ fn push_debuginfo_type_name<'tcx>(\n             }\n         }\n         ty::Ref(_, inner_type, mutbl) => {\n-            // Slices and `&str` are treated like C++ pointers when computing debug\n-            // info for MSVC debugger. However, wrapping these types' names in a synthetic type\n-            // causes the .natvis engine for WinDbg to fail to display their data, so we opt these\n-            // types out to aid debugging in MSVC.\n-            let is_slice_or_str = matches!(*inner_type.kind(), ty::Slice(_) | ty::Str);\n-\n-            if !cpp_like_debuginfo {\n-                output.push('&');\n-                output.push_str(mutbl.prefix_str());\n-            } else if !is_slice_or_str {\n+            if cpp_like_debuginfo {\n                 match mutbl {\n                     Mutability::Not => output.push_str(\"ref$<\"),\n                     Mutability::Mut => output.push_str(\"ref_mut$<\"),\n                 }\n+            } else {\n+                output.push('&');\n+                output.push_str(mutbl.prefix_str());\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_debuginfo && !is_slice_or_str {\n+            if cpp_like_debuginfo {\n                 push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n@@ -195,7 +195,7 @@ fn push_debuginfo_type_name<'tcx>(\n         }\n         ty::Slice(inner_type) => {\n             if cpp_like_debuginfo {\n-                output.push_str(\"slice$<\");\n+                output.push_str(\"slice2$<\");\n             } else {\n                 output.push('[');\n             }"}, {"sha": "bfc4515de0984405ecb640911b802296ab1a109a", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -354,3 +354,179 @@ impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_exe_unexpected_error)]\n+pub struct LinkExeUnexpectedError;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_repair_vs_build_tools)]\n+pub struct RepairVSBuildTools;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_cpp_build_tool_component)]\n+pub struct MissingCppBuildToolComponent;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_select_cpp_build_tool_workload)]\n+pub struct SelectCppBuildToolWorkload;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_visual_studio_not_installed)]\n+pub struct VisualStudioNotInstalled;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_not_found)]\n+#[note]\n+pub struct LinkerNotFound {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_exe_linker)]\n+#[note]\n+#[note(command_note)]\n+pub struct UnableToExeLinker {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+    pub command_formatted: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_msvc_missing_linker)]\n+pub struct MsvcMissingLinker;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_check_installed_visual_studio)]\n+pub struct CheckInstalledVisualStudio;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsufficient_vs_code_product)]\n+pub struct UnsufficientVSCodeProduct;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_processing_dymutil_failed)]\n+#[note]\n+pub struct ProcessingDymutilFailed {\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run_dsymutil)]\n+#[note]\n+pub struct UnableToRunDsymutil {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_stripping_debu_info_failed)]\n+#[note]\n+pub struct StrippingDebugInfoFailed<'a> {\n+    pub util: &'a str,\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run)]\n+pub struct UnableToRun<'a> {\n+    pub util: &'a str,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_file_stem)]\n+pub struct LinkerFileStem;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_static_library_native_artifacts)]\n+pub struct StaticLibraryNativeArtifacts;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_native_static_libs)]\n+pub struct NativeStaticLibs {\n+    pub arguments: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_unavailable)]\n+pub struct LinkScriptUnavailable;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_write_failure)]\n+pub struct LinkScriptWriteFailure {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_failed_to_write)]\n+pub struct FailedToWrite {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_write_debugger_visualizer)]\n+pub struct UnableToWriteDebuggerVisualizer {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_rlib_archive_build_failure)]\n+pub struct RlibArchiveBuildFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_option_gcc_only)]\n+pub struct OptionGccOnly;\n+\n+#[derive(Diagnostic)]\n+pub enum ExtractBundledLibsError<'a> {\n+    #[diag(codegen_ssa_extract_bundled_libs_open_file)]\n+    OpenFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_mmap_file)]\n+    MmapFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_parse_archive)]\n+    ParseArchive { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_read_entry)]\n+    ReadEntry { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_archive_member)]\n+    ArchiveMember { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_convert_name)]\n+    ConvertName { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n+    WriteFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n+    ExtractSection { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsupported_arch)]\n+pub struct UnsupportedArch<'a> {\n+    pub arch: &'a str,\n+    pub os: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum AppleSdkRootError<'a> {\n+    #[diag(codegen_ssa_apple_sdk_error_sdk_path)]\n+    SdkPath { sdk_name: &'a str, error: Error },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_read_file)]\n+pub struct ReadFileError {\n+    pub message: std::io::Error,\n+}"}, {"sha": "6015d48decae930ac7cfc764663680d25d830c8b", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,7 +15,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) -> (Bx::Value, Bx::Value) {\n     let layout = bx.layout_of(t);\n     debug!(\"size_and_align_of_dst(ty={}, info={:?}): layout: {:?}\", t, info, layout);\n-    if !layout.is_unsized() {\n+    if layout.is_sized() {\n         let size = bx.const_usize(layout.size.bytes());\n         let align = bx.const_usize(layout.align.abi.bytes());\n         return (size, align);"}, {"sha": "0802067cde65d85478612cfa1021312d89cfe3f3", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 75, "deletions": 41, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::{self, Instance, Ty, TypeVisitable};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n@@ -63,7 +64,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with a landing\n+    /// pad next to it.\n+    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n@@ -73,32 +76,36 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n-            (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n-                (lltarget, false)\n-            }\n             // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n             (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (lltarget, false)\n+                } else {\n+                    (fx.landing_pad_for(target), true)\n+                }\n+            }\n         }\n     }\n \n-    /// Create a basic block.\n-    fn llblock<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with cleanup\n+    /// stuff in it or next to it.\n+    fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n-\n-            debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n+            debug!(\"llbb_with_cleanup: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n-            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            let trampoline_llbb = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline_llbb);\n             trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline\n+            trampoline_llbb\n         } else {\n             lltarget\n         }\n@@ -110,10 +117,11 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n-            // micro-optimization: generate a `ret` rather than a jump\n+            // MSVC micro-optimization: generate a `ret` rather than a jump\n             // to a trampoline.\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n             bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n         } else {\n             bx.br(lltarget);\n@@ -138,7 +146,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n         let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llblock(fx, cleanup))\n+            Some(self.llbb_with_cleanup(fx, cleanup))\n         } else if fx.mir[self.bb].is_cleanup\n             && fn_abi.can_unwind\n             && !base::wants_msvc_seh(fx.cx.tcx().sess)\n@@ -231,7 +239,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llblock(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n@@ -279,12 +287,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         assert_eq!(discr.layout.ty, switch_ty);\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n-            // If there are two targets (one conditional, one fallback), emit br instead of switch\n+            // If there are two targets (one conditional, one fallback), emit `br` instead of\n+            // `switch`.\n             let (test_value, target) = target_iter.next().unwrap();\n-            let lltrue = helper.llblock(self, target);\n-            let llfalse = helper.llblock(self, targets.otherwise());\n+            let lltrue = helper.llbb_with_cleanup(self, target);\n+            let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n-                // Don't generate trivial icmps when switching on bool\n+                // Don't generate trivial icmps when switching on bool.\n                 match test_value {\n                     0 => bx.cond_br(discr.immediate(), llfalse, lltrue),\n                     1 => bx.cond_br(discr.immediate(), lltrue, llfalse),\n@@ -296,11 +305,35 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                 bx.cond_br(cmp, lltrue, llfalse);\n             }\n+        } else if self.cx.sess().opts.optimize == OptLevel::No\n+            && target_iter.len() == 2\n+            && self.mir[targets.otherwise()].is_empty_unreachable()\n+        {\n+            // In unoptimized builds, if there are two normal targets and the `otherwise` target is\n+            // an unreachable BB, emit `br` instead of `switch`. This leaves behind the unreachable\n+            // BB, which will usually (but not always) be dead code.\n+            //\n+            // Why only in unoptimized builds?\n+            // - In unoptimized builds LLVM uses FastISel which does not support switches, so it\n+            //   must fall back to the to the slower SelectionDAG isel. Therefore, using `br` gives\n+            //   significant compile time speedups for unoptimized builds.\n+            // - In optimized builds the above doesn't hold, and using `br` sometimes results in\n+            //   worse generated code because LLVM can no longer tell that the value being switched\n+            //   on can only have two values, e.g. 0 and 1.\n+            //\n+            let (test_value1, target1) = target_iter.next().unwrap();\n+            let (_test_value2, target2) = target_iter.next().unwrap();\n+            let ll1 = helper.llbb_with_cleanup(self, target1);\n+            let ll2 = helper.llbb_with_cleanup(self, target2);\n+            let switch_llty = bx.immediate_backend_type(bx.layout_of(switch_ty));\n+            let llval = bx.const_uint_big(switch_llty, test_value1);\n+            let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n+            bx.cond_br(cmp, ll1, ll2);\n         } else {\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, targets.otherwise()),\n-                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n+                helper.llbb_with_cleanup(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llbb_with_cleanup(self, target))),\n             );\n         }\n     }\n@@ -530,7 +563,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cond = bx.expect(cond, expected);\n \n         // Create the failure block and the conditional branch to it.\n-        let lltarget = helper.llblock(self, target);\n+        let lltarget = helper.llbb_with_cleanup(self, target);\n         let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block);\n@@ -1459,20 +1492,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_bb =\n+                    let cs_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_bb =\n+                    let cp_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bb;\n+                    ret_llbb = cs_llbb;\n \n-                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n+                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1481,30 +1514,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let cleanup_bb =\n+                    let cleanup_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+                    ret_llbb = cleanup_llbb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n-            let mut bx = Bx::build(self.cx, bb);\n+            let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n-            let lp = bx.cleanup_landing_pad(llretty, llpersonality);\n+            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n \n-            let slot = self.get_personality_slot(&mut bx);\n-            slot.storage_live(&mut bx);\n-            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut cleanup_bx);\n+            slot.storage_live(&mut cleanup_bx);\n+            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n+                .store(&mut cleanup_bx, slot);\n \n-            bx.br(llbb);\n-            bx.llbb()\n+            cleanup_bx.br(llbb);\n+            cleanup_llbb\n         }\n     }\n "}, {"sha": "da9aaf00ecf6e83f4e9c62af5df4e1d054d5a08c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -148,10 +148,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n-    let mut bx = Bx::build(cx, start_llbb);\n+    let mut start_bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n-        bx.set_personality_fn(cx.eh_personality());\n+        start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -180,7 +180,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut start_bx);\n \n     // Evaluate all required consts; codegen later assumes that CTFE will never fail.\n     let mut all_consts_ok = true;\n@@ -206,29 +206,29 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n+        let args = arg_local_refs(&mut start_bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n+            let layout = start_bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n-                let llretptr = bx.get_param(0);\n+                let llretptr = start_bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n             if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut start_bx, layout))\n                 } else {\n-                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n+                    LocalRef::Place(PlaceRef::alloca(&mut start_bx, layout))\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut bx, layout)\n+                LocalRef::new_operand(&mut start_bx, layout)\n             }\n         };\n \n@@ -240,7 +240,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_introduce_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut start_bx);\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {"}, {"sha": "908555385891d85417e4710ad4b860b790e43676", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 149, "deletions": 53, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -29,7 +29,7 @@ pub struct PlaceRef<'tcx, V> {\n \n impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     pub fn new_sized(llval: V, layout: TyAndLayout<'tcx>) -> PlaceRef<'tcx, V> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n     }\n \n@@ -38,7 +38,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         layout: TyAndLayout<'tcx>,\n         align: Align,\n     ) -> PlaceRef<'tcx, V> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n \n@@ -48,7 +48,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         layout: TyAndLayout<'tcx>,\n     ) -> Self {\n-        assert!(!layout.is_unsized(), \"tried to statically allocate unsized place\");\n+        assert!(layout.is_sized(), \"tried to statically allocate unsized place\");\n         let tmp = bx.alloca(bx.cx().backend_type(layout), layout.align.abi);\n         Self::new_sized(tmp, layout)\n     }\n@@ -145,7 +145,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 );\n                 return simple();\n             }\n-            _ if !field.is_unsized() => return simple(),\n+            _ if field.is_sized() => return simple(),\n             ty::Slice(..) | ty::Str | ty::Foreign(..) => return simple(),\n             ty::Adt(def, _) => {\n                 if def.repr().packed() {\n@@ -209,7 +209,9 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         bx: &mut Bx,\n         cast_to: Ty<'tcx>,\n     ) -> V {\n-        let cast_to = bx.cx().immediate_backend_type(bx.cx().layout_of(cast_to));\n+        let cast_to_layout = bx.cx().layout_of(cast_to);\n+        let cast_to_size = cast_to_layout.layout.size();\n+        let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_undef(cast_to);\n         }\n@@ -229,7 +231,8 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n \n         // Read the tag/niche-encoded discriminant from memory.\n         let tag = self.project_field(bx, tag_field);\n-        let tag = bx.load_operand(tag);\n+        let tag_op = bx.load_operand(tag);\n+        let tag_imm = tag_op.immediate();\n \n         // Decode the discriminant (specifically if it's niche-encoded).\n         match *tag_encoding {\n@@ -242,68 +245,161 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     Int(_, signed) => !tag_scalar.is_bool() && signed,\n                     _ => false,\n                 };\n-                bx.intcast(tag.immediate(), cast_to, signed)\n+                bx.intcast(tag_imm, cast_to, signed)\n             }\n             TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-                // Rebase from niche values to discriminants, and check\n-                // whether the result is in range for the niche variants.\n-                let niche_llty = bx.cx().immediate_backend_type(tag.layout);\n-                let tag = tag.immediate();\n-\n-                // We first compute the \"relative discriminant\" (wrt `niche_variants`),\n-                // that is, if `n = niche_variants.end() - niche_variants.start()`,\n-                // we remap `niche_start..=niche_start + n` (which may wrap around)\n-                // to (non-wrap-around) `0..=n`, to be able to check whether the\n-                // discriminant corresponds to a niche variant with one comparison.\n-                // We also can't go directly to the (variant index) discriminant\n-                // and check that it is in the range `niche_variants`, because\n-                // that might not fit in the same type, on top of needing an extra\n-                // comparison (see also the comment on `let niche_discr`).\n-                let relative_discr = if niche_start == 0 {\n-                    // Avoid subtracting `0`, which wouldn't work for pointers.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    tag\n+                // Cast to an integer so we don't have to treat a pointer as a\n+                // special case.\n+                let (tag, tag_llty) = if tag_scalar.primitive().is_ptr() {\n+                    let t = bx.type_isize();\n+                    let tag = bx.ptrtoint(tag_imm, t);\n+                    (tag, t)\n                 } else {\n-                    bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n+                    (tag_imm, bx.cx().immediate_backend_type(tag_op.layout))\n                 };\n+\n+                let tag_size = tag_scalar.size(bx.cx());\n+                let max_unsigned = tag_size.unsigned_int_max();\n+                let max_signed = tag_size.signed_int_max() as u128;\n+                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let is_niche = if relative_max == 0 {\n-                    // Avoid calling `const_uint`, which wouldn't work for pointers.\n-                    // Also use canonical == 0 instead of non-canonical u<= 0.\n-                    // FIXME(eddyb) check the actual primitive type here.\n-                    bx.icmp(IntPredicate::IntEQ, relative_discr, bx.cx().const_null(niche_llty))\n+                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n+                let range = tag_scalar.valid_range(bx.cx());\n+\n+                let sle = |lhs: u128, rhs: u128| -> bool {\n+                    // Signed and unsigned comparisons give the same results,\n+                    // except that in signed comparisons an integer with the\n+                    // sign bit set is less than one with the sign bit clear.\n+                    // Toggle the sign bit to do a signed comparison.\n+                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n+                };\n+\n+                // We have a subrange `niche_start..=niche_end` inside `range`.\n+                // If the value of the tag is inside this subrange, it's a\n+                // \"niche value\", an increment of the discriminant. Otherwise it\n+                // indicates the untagged variant.\n+                // A general algorithm to extract the discriminant from the tag\n+                // is:\n+                // relative_tag = tag - niche_start\n+                // is_niche = relative_tag <= (ule) relative_max\n+                // discr = if is_niche {\n+                //     cast(relative_tag) + niche_variants.start()\n+                // } else {\n+                //     untagged_variant\n+                // }\n+                // However, we will likely be able to emit simpler code.\n+\n+                // Find the least and greatest values in `range`, considered\n+                // both as signed and unsigned.\n+                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n+                    (range.start, range.end)\n+                } else {\n+                    (0, max_unsigned)\n+                };\n+                let (low_signed, high_signed) = if sle(range.start, range.end) {\n+                    (range.start, range.end)\n                 } else {\n-                    let relative_max = bx.cx().const_uint(niche_llty, relative_max as u64);\n-                    bx.icmp(IntPredicate::IntULE, relative_discr, relative_max)\n+                    (min_signed, max_signed)\n+                };\n+\n+                let niches_ule = niche_start <= niche_end;\n+                let niches_sle = sle(niche_start, niche_end);\n+                let cast_smaller = cast_to_size <= tag_size;\n+\n+                // In the algorithm above, we can change\n+                // cast(relative_tag) + niche_variants.start()\n+                // into\n+                // cast(tag) + (niche_variants.start() - niche_start)\n+                // if either the casted type is no larger than the original\n+                // type, or if the niche values are contiguous (in either the\n+                // signed or unsigned sense).\n+                let can_incr_after_cast = cast_smaller || niches_ule || niches_sle;\n+\n+                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n+                    if !can_incr_after_cast {\n+                        None\n+                    } else if niche_start == low_unsigned {\n+                        Some((IntPredicate::IntULE, niche_end))\n+                    } else if niche_end == high_unsigned {\n+                        Some((IntPredicate::IntUGE, niche_start))\n+                    } else if niche_start == low_signed {\n+                        Some((IntPredicate::IntSLE, niche_end))\n+                    } else if niche_end == high_signed {\n+                        Some((IntPredicate::IntSGE, niche_start))\n+                    } else {\n+                        None\n+                    }\n                 };\n \n-                // NOTE(eddyb) this addition needs to be performed on the final\n-                // type, in case the niche itself can't represent all variant\n-                // indices (e.g. `u8` niche with more than `256` variants,\n-                // but enough uninhabited variants so that the remaining variants\n-                // fit in the niche).\n-                // In other words, `niche_variants.end - niche_variants.start`\n-                // is representable in the niche, but `niche_variants.end`\n-                // might not be, in extreme cases.\n-                let niche_discr = {\n-                    let relative_discr = if relative_max == 0 {\n-                        // HACK(eddyb) since we have only one niche, we know which\n-                        // one it is, and we can avoid having a dynamic value here.\n-                        bx.cx().const_uint(cast_to, 0)\n+                let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n+                    // Best case scenario: only one tagged variant. This will\n+                    // likely become just a comparison and a jump.\n+                    // The algorithm is:\n+                    // is_niche = tag == niche_start\n+                    // discr = if is_niche {\n+                    //     niche_start\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    let niche_start = bx.cx().const_uint_big(tag_llty, niche_start);\n+                    let is_niche = bx.icmp(IntPredicate::IntEQ, tag, niche_start);\n+                    let tagged_discr =\n+                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n+                    (is_niche, tagged_discr, 0)\n+                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n+                    // The niche values are either the lowest or the highest in\n+                    // `range`. We can avoid the first subtraction in the\n+                    // algorithm.\n+                    // The algorithm is now this:\n+                    // is_niche = tag <= niche_end\n+                    // discr = if is_niche {\n+                    //     cast(tag) + (niche_variants.start() - niche_start)\n+                    // } else {\n+                    //     untagged_variant\n+                    // }\n+                    // (the first line may instead be tag >= niche_start,\n+                    // and may be a signed or unsigned comparison)\n+                    let is_niche =\n+                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n+                    let cast_tag = if cast_smaller {\n+                        bx.intcast(tag, cast_to, false)\n+                    } else if niches_ule {\n+                        bx.zext(tag, cast_to)\n                     } else {\n-                        bx.intcast(relative_discr, cast_to, false)\n+                        bx.sext(tag, cast_to)\n                     };\n-                    bx.add(\n+\n+                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n+                    (is_niche, cast_tag, delta)\n+                } else {\n+                    // The special cases don't apply, so we'll have to go with\n+                    // the general algorithm.\n+                    let relative_discr = bx.sub(tag, bx.cx().const_uint_big(tag_llty, niche_start));\n+                    let cast_tag = bx.intcast(relative_discr, cast_to, false);\n+                    let is_niche = bx.icmp(\n+                        IntPredicate::IntULE,\n                         relative_discr,\n-                        bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                    )\n+                        bx.cx().const_uint(tag_llty, relative_max as u64),\n+                    );\n+                    (is_niche, cast_tag, niche_variants.start().as_u32() as u128)\n                 };\n \n-                bx.select(\n+                let tagged_discr = if delta == 0 {\n+                    tagged_discr\n+                } else {\n+                    bx.add(tagged_discr, bx.cx().const_uint_big(cast_to, delta))\n+                };\n+\n+                let discr = bx.select(\n                     is_niche,\n-                    niche_discr,\n+                    tagged_discr,\n                     bx.cx().const_uint(cast_to, untagged_variant.as_u32() as u64),\n-                )\n+                );\n+\n+                // In principle we could insert assumes on the possible range of `discr`, but\n+                // currently in LLVM this seems to be a pessimization.\n+\n+                discr\n             }\n         }\n     }"}, {"sha": "a4368303de5762eb549ab50bd5bac8989333ce58", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -267,6 +267,7 @@ const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     // tidy-alphabetical-start\n     (\"atomics\", Some(sym::wasm_target_feature)),\n     (\"bulk-memory\", Some(sym::wasm_target_feature)),\n+    (\"multivalue\", Some(sym::wasm_target_feature)),\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n     (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),"}, {"sha": "5c35070ea66f4f1ffca07091755333058e6f146e", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -119,7 +119,7 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         tcx: TyCtxt<'tcx>,\n         module_name: &str,\n         kind: AllocatorKind,\n-        has_alloc_error_handler: bool,\n+        alloc_error_handler_kind: AllocatorKind,\n     ) -> Self::Module;\n     /// This generates the codegen unit and returns it along with\n     /// a `u64` giving an estimate of the unit's processing cost."}, {"sha": "86481d5d758d6d251c5b916163079905a8dd805f", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,7 +5,6 @@ use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n use rustc_target::abi::{AddressSpace, Integer};\n \n@@ -23,6 +22,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n \n+    fn type_array(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn type_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;\n@@ -75,16 +75,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_sized(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         let param_env = ty::ParamEnv::reveal_all();\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n+        if ty.is_sized(self.tcx(), param_env) {\n             return false;\n         }\n "}, {"sha": "8f5e503d659dad30b1d16c7199bfcb7dc7276bfd", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -46,7 +46,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         ecx.tcx.def_kind(cid.instance.def_id())\n     );\n     let layout = ecx.layout_of(body.bound_return_ty().subst(tcx, cid.instance.substs))?;\n-    assert!(!layout.is_unsized());\n+    assert!(layout.is_sized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n \n     trace!("}, {"sha": "f1674d04f8d15f16be1f3011eaead81daad003e7", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 16, "deletions": 56, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -25,10 +25,12 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n /// report whether said intrinsic has a `rustc_const_{un,}stable` attribute. Otherwise, return\n /// `Constness::NotConst`.\n fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    match tcx.hir().get(hir_id) {\n-        hir::Node::Ctor(_) => hir::Constness::Const,\n+    let def_id = def_id.expect_local();\n+    let node = tcx.hir().get_by_def_id(def_id);\n \n+    match node {\n+        hir::Node::Ctor(_) => hir::Constness::Const,\n+        hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.constness,\n         hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) => {\n             // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n             // foreign items cannot be evaluated at compile-time.\n@@ -39,62 +41,20 @@ fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n             };\n             if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n+        _ => {\n+            if let Some(fn_kind) = node.fn_kind() {\n+                if fn_kind.constness() == hir::Constness::Const {\n+                    return hir::Constness::Const;\n+                }\n \n-        hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-            if tcx.is_const_default_method(def_id) =>\n-        {\n-            hir::Constness::Const\n-        }\n-\n-        hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n-        | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n-        | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Const(..), .. })\n-        | hir::Node::AnonConst(_)\n-        | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n-        | hir::Node::ImplItem(hir::ImplItem {\n-            kind:\n-                hir::ImplItemKind::Fn(\n-                    hir::FnSig {\n-                        header: hir::FnHeader { constness: hir::Constness::Const, .. },\n-                        ..\n-                    },\n-                    ..,\n-                ),\n-            ..\n-        }) => hir::Constness::Const,\n-\n-        hir::Node::ImplItem(hir::ImplItem {\n-            kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n-            ..\n-        }) => {\n-            let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n-            match tcx.hir().get(parent_hir_id) {\n-                hir::Node::Item(hir::Item {\n-                    kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-                    ..\n-                }) => *constness,\n-                _ => span_bug!(\n-                    tcx.def_span(parent_hir_id.owner),\n-                    \"impl item's parent node is not an impl\",\n-                ),\n+                // If the function itself is not annotated with `const`, it may still be a `const fn`\n+                // if it resides in a const trait impl.\n+                let is_const = is_parent_const_impl_raw(tcx, def_id);\n+                if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n+            } else {\n+                hir::Constness::NotConst\n             }\n         }\n-\n-        hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n-            ..\n-        })\n-        | hir::Node::TraitItem(hir::TraitItem {\n-            kind:\n-                hir::TraitItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n-            ..\n-        })\n-        | hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n-            ..\n-        }) => *constness,\n-\n-        _ => hir::Constness::NotConst,\n     }\n }\n "}, {"sha": "35d58d2f638bfceb56d3699deba074b0c8bcc76c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -2,10 +2,10 @@ use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::borrow::Borrow;\n-use std::collections::hash_map::Entry;\n use std::hash::Hash;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::fx::IndexEntry;\n use std::fmt;\n \n use rustc_ast::Mutability;\n@@ -107,26 +107,26 @@ impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     }\n }\n \n-impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n+impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxIndexMap<K, V> {\n     #[inline(always)]\n     fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n     where\n         K: Borrow<Q>,\n     {\n-        FxHashMap::contains_key(self, k)\n+        FxIndexMap::contains_key(self, k)\n     }\n \n     #[inline(always)]\n     fn insert(&mut self, k: K, v: V) -> Option<V> {\n-        FxHashMap::insert(self, k, v)\n+        FxIndexMap::insert(self, k, v)\n     }\n \n     #[inline(always)]\n     fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n     where\n         K: Borrow<Q>,\n     {\n-        FxHashMap::remove(self, k)\n+        FxIndexMap::remove(self, k)\n     }\n \n     #[inline(always)]\n@@ -148,8 +148,8 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     #[inline(always)]\n     fn get_mut_or<E>(&mut self, k: K, vacant: impl FnOnce() -> Result<V, E>) -> Result<&mut V, E> {\n         match self.entry(k) {\n-            Entry::Occupied(e) => Ok(e.into_mut()),\n-            Entry::Vacant(e) => {\n+            IndexEntry::Occupied(e) => Ok(e.into_mut()),\n+            IndexEntry::Vacant(e) => {\n                 let v = vacant()?;\n                 Ok(e.insert(v))\n             }"}, {"sha": "f4da11883957a73f0376d35c2202c659a2d1a8ab", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -212,7 +212,7 @@ fn create_pointee_place<'tcx>(\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx.tcx;\n \n-    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+    if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty()) {\n         // We need to create `Allocation`s for custom DSTs\n \n         let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n@@ -398,7 +398,7 @@ fn valtree_into_mplace<'tcx>(\n \n                 let mut place_inner = match ty.kind() {\n                     ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n-                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                    _ if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty())\n                         && i == branches.len() - 1 =>\n                     {\n                         // Note: For custom DSTs we need to manually process the last unsized field."}, {"sha": "269ae15d4974547f929544764313ce900982ecc0", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -42,10 +42,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let res = self.pointer_from_exposed_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n-            // FIXME: We shouldn't use `misc_cast` for these but handle them separately.\n-            IntToInt | FloatToInt | FloatToFloat | IntToFloat | FnPtrToPtr | PtrToPtr => {\n+\n+            IntToInt | IntToFloat => {\n+                let src = self.read_immediate(src)?;\n+                let res = self.int_to_int_or_float(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FloatToFloat | FloatToInt => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.misc_cast(&src, cast_ty)?;\n+                let res = self.float_to_float_or_int(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FnPtrToPtr | PtrToPtr => {\n+                let src = self.read_immediate(&src)?;\n+                let res = self.ptr_to_ptr(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -126,13 +138,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn misc_cast(\n-        &mut self,\n+    /// Handles 'IntToInt' and 'IntToFloat' casts.\n+    pub fn int_to_int_or_float(\n+        &self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        assert!(src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool());\n+        assert!(cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char());\n+\n+        Ok(self.cast_from_int_like(src.to_scalar(), src.layout, cast_ty)?.into())\n+    }\n+\n+    /// Handles 'FloatToFloat' and 'FloatToInt' casts.\n+    pub fn float_to_float_or_int(\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         use rustc_type_ir::sty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n             // Floating point\n@@ -142,47 +166,42 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts\n-            _ => assert!(\n-                src.layout.ty.is_bool()\n-                    || src.layout.ty.is_char()\n-                    || src.layout.ty.is_integral()\n-                    || src.layout.ty.is_any_ptr(),\n-                \"Unexpected cast from type {:?}\",\n-                src.layout.ty\n-            ),\n+            _ => {\n+                bug!(\"Can't cast 'Float' type into {:?}\", cast_ty);\n+            }\n         }\n+    }\n \n-        // # First handle non-scalar source values.\n-\n+    /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n+    pub fn ptr_to_ptr(\n+        &self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        assert!(src.layout.ty.is_any_ptr());\n+        assert!(cast_ty.is_unsafe_ptr());\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n-        if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n-            let dest_layout = self.layout_of(cast_ty)?;\n-            if dest_layout.size == src.layout.size {\n-                // Thin or fat pointer that just hast the ptr kind of target type changed.\n-                return Ok(**src);\n-            } else {\n-                // Casting the metadata away from a fat ptr.\n-                assert_eq!(src.layout.size, 2 * self.pointer_size());\n-                assert_eq!(dest_layout.size, self.pointer_size());\n-                assert!(src.layout.ty.is_unsafe_ptr());\n-                return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n-                    Immediate::Scalar(..) => span_bug!(\n-                        self.cur_span(),\n-                        \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n-                        *src,\n-                        src.layout.ty,\n-                        cast_ty\n-                    ),\n-                    Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n-                };\n-            }\n+        let dest_layout = self.layout_of(cast_ty)?;\n+        if dest_layout.size == src.layout.size {\n+            // Thin or fat pointer that just hast the ptr kind of target type changed.\n+            return Ok(**src);\n+        } else {\n+            // Casting the metadata away from a fat ptr.\n+            assert_eq!(src.layout.size, 2 * self.pointer_size());\n+            assert_eq!(dest_layout.size, self.pointer_size());\n+            assert!(src.layout.ty.is_unsafe_ptr());\n+            return match **src {\n+                Immediate::ScalarPair(data, _) => Ok(data.into()),\n+                Immediate::Scalar(..) => span_bug!(\n+                    self.cur_span(),\n+                    \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n+                    *src,\n+                    src.layout.ty,\n+                    cast_ty\n+                ),\n+                Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n+            };\n         }\n-\n-        // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar();\n-        Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n     pub fn pointer_expose_address_cast(\n@@ -203,7 +222,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn pointer_from_exposed_address_cast(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -220,6 +239,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(Scalar::from_maybe_pointer(ptr, self).into())\n     }\n \n+    /// Low-level cast helper function. This works directly on scalars and can take 'int-like' input\n+    /// type (basically everything with a scalar layout) to int/float/char types.\n     pub fn cast_from_int_like(\n         &self,\n         scalar: Scalar<M::Provenance>, // input value (there is no ScalarTy so we separate data+layout)\n@@ -259,6 +280,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    /// Low-level cast helper function. Converts an apfloat `f` into int or float types.\n     fn cast_from_float<F>(&self, f: F, dest_ty: Ty<'tcx>) -> Scalar<M::Provenance>\n     where\n         F: Float + Into<Scalar<M::Provenance>> + FloatConvert<Single> + FloatConvert<Double>,"}, {"sha": "ab82268dde3ab5898bce8cb11ccda94b43ec7bf9", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -468,7 +468,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env)\n+        ty.is_freeze(*self.tcx, self.param_env)\n     }\n \n     pub fn load_mir(\n@@ -572,7 +572,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         metadata: &MemPlaceMeta<M::Provenance>,\n         layout: &TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, Option<(Size, Align)>> {\n-        if !layout.is_unsized() {\n+        if layout.is_sized() {\n             return Ok(Some((layout.size, layout.align.abi)));\n         }\n         match layout.ty.kind() {\n@@ -598,7 +598,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // the last field).  Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n-                let Some((unsized_size, unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n+                let Some((unsized_size, mut unsized_align)) = self.size_and_align_of(metadata, &field)? else {\n                     // A field with an extern type. We don't know the actual dynamic size\n                     // or the alignment.\n                     return Ok(None);\n@@ -614,6 +614,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Return the sum of sizes and max of aligns.\n                 let size = sized_size + unsized_size; // `Size` addition\n \n+                // Packed types ignore the alignment of their fields.\n+                if let ty::Adt(def, _) = layout.ty.kind() {\n+                    if def.repr().packed() {\n+                        unsized_align = sized_align;\n+                    }\n+                }\n+\n                 // Choose max of two known alignments (combined value must\n                 // be aligned according to more restrictive of the two).\n                 let align = sized_align.max(unsized_align);"}, {"sha": "6809a42dc45364b78a5fecbc3bfa218f304daec9", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,7 +15,7 @@\n //! that contains allocations whose mutability we cannot identify.)\n \n use super::validity::RefTracking;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_middle::mir::interpret::InterpResult;\n@@ -37,7 +37,7 @@ pub trait CompileTimeMachine<'mir, 'tcx, T> = Machine<\n     ExtraFnVal = !,\n     FrameExtra = (),\n     AllocExtra = (),\n-    MemoryMap = FxHashMap<AllocId, (MemoryKind<T>, Allocation)>,\n+    MemoryMap = FxIndexMap<AllocId, (MemoryKind<T>, Allocation)>,\n >;\n \n struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>> {\n@@ -47,7 +47,7 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_ev\n     ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, InternMode)>,\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n-    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    leftover_allocations: &'rt mut FxIndexSet<AllocId>,\n     /// The root kind of the value that we're looking at. This field is never mutated for a\n     /// particular allocation. It is primarily used to make as many allocations as possible\n     /// read-only so LLVM can place them in const memory.\n@@ -79,7 +79,7 @@ struct IsStaticOrFn;\n /// to account for (e.g. for vtables).\n fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval::MemoryKind>>(\n     ecx: &'rt mut InterpCx<'mir, 'tcx, M>,\n-    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n+    leftover_allocations: &'rt mut FxIndexSet<AllocId>,\n     alloc_id: AllocId,\n     mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n@@ -114,7 +114,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env));\n         // For statics, allocation mutability is the combination of place mutability and\n         // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n@@ -355,7 +355,7 @@ pub fn intern_const_alloc_recursive<\n     // `leftover_allocations` collects *all* allocations we see, because some might not\n     // be available in a typed way. They get interned at the end.\n     let mut ref_tracking = RefTracking::empty();\n-    let leftover_allocations = &mut FxHashSet::default();\n+    let leftover_allocations = &mut FxIndexSet::default();\n \n     // start with the outermost allocation\n     intern_shallow("}, {"sha": "e68456a1d731a2989ceace8449d42c7bdc406982", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -7,7 +7,9 @@ use std::convert::TryFrom;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar},\n+    interpret::{\n+        Allocation, ConstAllocation, ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar,\n+    },\n     BinOp, NonDivergingIntrinsic,\n };\n use rustc_middle::ty;\n@@ -23,7 +25,6 @@ use super::{\n };\n \n mod caller_location;\n-mod type_name;\n \n fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Prov> {\n     let size = match kind {\n@@ -42,6 +43,13 @@ fn numeric_intrinsic<Prov>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<\n     Scalar::from_uint(bits_out, size)\n }\n \n+/// Directly returns an `Allocation` containing an absolute path representation of the given type.\n+pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n+    let path = crate::util::type_name(tcx, ty);\n+    let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n+    tcx.intern_const_alloc(alloc)\n+}\n+\n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n /// inside an `InterpCx` and instead have their value computed directly from rustc internal info.\n pub(crate) fn eval_nullary_intrinsic<'tcx>(\n@@ -55,7 +63,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n     Ok(match name {\n         sym::type_name => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n-            let alloc = type_name::alloc_type_name(tcx, tp_ty);\n+            let alloc = alloc_type_name(tcx, tp_ty);\n             ConstValue::Slice { data: alloc, start: 0, end: alloc.inner().len() }\n         }\n         sym::needs_drop => {\n@@ -705,7 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         rhs: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n     ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n \n         let get_bytes = |this: &InterpCx<'mir, 'tcx, M>,\n                          op: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,"}, {"sha": "351152eba01f6ae219c2034ff8ffacb37b0ca054", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -426,7 +426,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type ExtraFnVal = !;\n \n     type MemoryMap =\n-        rustc_data_structures::fx::FxHashMap<AllocId, (MemoryKind<Self::MemoryKind>, Allocation)>;\n+        rustc_data_structures::fx::FxIndexMap<AllocId, (MemoryKind<Self::MemoryKind>, Allocation)>;\n     const GLOBAL_KIND: Option<Self::MemoryKind> = None; // no copying of globals from `tcx` to machine memory\n \n     type AllocExtra = ();"}, {"sha": "a529972db9d6fec739332ae5b9ad2ee8f1dc5dda", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -683,7 +683,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Use size and align of the type.\n                 let ty = self.tcx.type_of(def_id);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                assert!(!layout.is_unsized());\n+                assert!(layout.is_sized());\n                 (layout.size, layout.align.abi, AllocKind::LiveData)\n             }\n             Some(GlobalAlloc::Memory(alloc)) => {"}, {"sha": "f0a83b7a02689d4607e545b325e8a0ae803878e3", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,7 +4,7 @@\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n-use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n+use rustc_middle::ty::{ConstInt, Ty};\n use rustc_middle::{mir, ty};\n use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n use rustc_target::abi::{VariantIdx, Variants};\n@@ -280,7 +280,7 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n     }\n }\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Read an immediate from a place, asserting that that is possible with the given layout.\n     ///\n-    /// If this suceeds, the `ImmTy` is never `Uninit`.\n+    /// If this succeeds, the `ImmTy` is never `Uninit`.\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n@@ -554,13 +554,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         val: &mir::ConstantKind<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n+        // FIXME(const_prop): normalization needed b/c const prop lint in\n+        // `mir_drops_elaborated_and_const_checked`, which happens before\n+        // optimized MIR. Only after optimizing the MIR can we guarantee\n+        // that the `RevealAll` pass has happened and that the body's consts\n+        // are normalized, so any call to resolve before that needs to be\n+        // manually normalized.\n+        let val = self.tcx.normalize_erasing_regions(self.param_env, *val);\n         match val {\n             mir::ConstantKind::Ty(ct) => {\n                 match ct.kind() {\n                     ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n                         throw_inval!(TooGeneric)\n                     }\n-                    ty::ConstKind::Error(DelaySpanBugEmitted { reported, .. }) => {\n+                    ty::ConstKind::Error(reported) => {\n                         throw_inval!(AlreadyReported(reported))\n                     }\n                     ty::ConstKind::Unevaluated(uv) => {\n@@ -585,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n             }\n-            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(*val, *ty, layout),\n+            mir::ConstantKind::Val(val, ty) => self.const_val_to_op(val, ty, layout),\n             mir::ConstantKind::Unevaluated(uv, _) => {\n                 let instance = self.resolve(uv.def, uv.substs)?;\n                 Ok(self.eval_to_allocation(GlobalId { instance, promoted: uv.promoted })?.into())"}, {"sha": "29d2312612ea9fb8fa5d5dc7e5de03b54baa5320", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -201,7 +201,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n     }\n \n@@ -316,8 +316,7 @@ where\n         Ok(MPlaceTy { mplace, layout, align })\n     }\n \n-    /// Take an operand, representing a pointer, and dereference it to a place -- that\n-    /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    /// Take an operand, representing a pointer, and dereference it to a place.\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn deref_operand(\n         &self,\n@@ -331,7 +330,7 @@ where\n         }\n \n         let mplace = self.ref_to_mplace(&val)?;\n-        self.check_mplace_access(mplace, CheckInAllocMsg::DerefTest)?;\n+        self.check_mplace(mplace)?;\n         Ok(mplace)\n     }\n \n@@ -340,7 +339,7 @@ where\n         &self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        assert!(!place.layout.is_unsized());\n+        assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n         self.get_ptr_alloc(place.ptr, size, place.align)\n@@ -351,24 +350,25 @@ where\n         &mut self,\n         place: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::Provenance, M::AllocExtra>>> {\n-        assert!(!place.layout.is_unsized());\n+        assert!(place.layout.is_sized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n         self.get_ptr_alloc_mut(place.ptr, size, place.align)\n     }\n \n     /// Check if this mplace is dereferenceable and sufficiently aligned.\n-    fn check_mplace_access(\n-        &self,\n-        mplace: MPlaceTy<'tcx, M::Provenance>,\n-        msg: CheckInAllocMsg,\n-    ) -> InterpResult<'tcx> {\n+    pub fn check_mplace(&self, mplace: MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n         let (size, align) = self\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n         let align = M::enforce_alignment(self).then_some(align);\n-        self.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n+        self.check_ptr_access_align(\n+            mplace.ptr,\n+            size,\n+            align.unwrap_or(Align::ONE),\n+            CheckInAllocMsg::DerefTest,\n+        )?;\n         Ok(())\n     }\n \n@@ -485,7 +485,7 @@ where\n         src: Immediate<M::Provenance>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n-        assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n+        assert!(dest.layout.is_sized(), \"Cannot write unsized data\");\n         trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `read_immediate_raw`,\n@@ -746,7 +746,7 @@ where\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        assert!(!layout.is_unsized());\n+        assert!(layout.is_sized());\n         let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }"}, {"sha": "3c286fa61bec5c9cb1a9501924ceded45ab5d13b", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -209,7 +209,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Repeat(ref operand, _) => {\n                 let src = self.eval_operand(operand, None)?;\n-                assert!(!src.layout.is_unsized());\n+                assert!(src.layout.is_sized());\n                 let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n "}, {"sha": "fa15d466ac125cf910f3e2cbd13e27c362ee6154", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -53,7 +53,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, (Size, Align)> {\n         let (ty, _trait_ref) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"there are no vtables for unsized types\");\n+        assert!(layout.is_sized(), \"there are no vtables for unsized types\");\n         Ok((layout.size, layout.align.abi))\n     }\n }"}, {"sha": "8aa56c275d91b93c51b1618c87687a9146ca57c7", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange};\n \n use std::hash::Hash;\n@@ -726,7 +725,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n-            if !op.layout.ty.is_freeze(self.ecx.tcx.at(DUMMY_SP), self.ecx.param_env) {\n+            if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }\n         }"}, {"sha": "443c01fdb90c6d474658ab38a417a2e5a6e2665b", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -22,7 +22,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(yeet_expr)]\n #![feature(is_some_and)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate tracing;"}, {"sha": "5a8b3e30b9fc0cdaab6bc89e90bfbb3624ee2668", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,11 +13,8 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, ObligationCtxt, SelectionContext};\n \n use std::mem;\n use std::ops::Deref;\n@@ -747,37 +744,28 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     // \"non-const\" check. This is required for correctness here.\n                     {\n                         let infcx = tcx.infer_ctxt().build();\n-                        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+                        let ocx = ObligationCtxt::new(&infcx);\n+\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n                             .hir()\n                             .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n-                        let cause = || {\n-                            ObligationCause::new(\n-                                terminator.source_info.span,\n-                                hir_id,\n-                                ObligationCauseCode::ItemObligation(callee),\n-                            )\n-                        };\n-                        let normalized = infcx.partially_normalize_associated_types_in(\n-                            cause(),\n-                            param_env,\n-                            predicates,\n+                        let cause = ObligationCause::new(\n+                            terminator.source_info.span,\n+                            hir_id,\n+                            ObligationCauseCode::ItemObligation(callee),\n                         );\n-\n-                        for p in normalized.obligations {\n-                            fulfill_cx.register_predicate_obligation(&infcx, p);\n-                        }\n-                        for obligation in traits::predicates_for_generics(\n-                            |_, _| cause(),\n+                        let normalized_predicates =\n+                            ocx.normalize(cause.clone(), param_env, predicates);\n+                        ocx.register_obligations(traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n                             self.param_env,\n-                            normalized.value,\n-                        ) {\n-                            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                        let errors = fulfill_cx.select_all_or_error(&infcx);\n+                            normalized_predicates,\n+                        ));\n+\n+                        let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n-                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                         }\n                     }\n \n@@ -843,7 +831,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                         obligation.clone(),\n                                         &obligation,\n                                         &e,\n-                                        false,\n                                     );\n                                 }\n "}, {"sha": "d995d533ca3e434ff9da5b25aba08375bfd50c61", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -8,7 +8,6 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n     self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n@@ -92,7 +91,7 @@ impl Qualif for HasMutInterior {\n     }\n \n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+        !ty.is_freeze(cx.tcx, cx.param_env)\n     }\n \n     fn in_adt_inherently<'tcx>(\n@@ -147,6 +146,7 @@ impl Qualif for NeedsNonConstDrop {\n         qualifs.needs_non_const_drop\n     }\n \n+    #[instrument(level = \"trace\", skip(cx), ret)]\n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         // Avoid selecting for simple cases, such as builtin types.\n         if ty::util::is_trivially_const_drop(ty) {\n@@ -175,6 +175,8 @@ impl Qualif for NeedsNonConstDrop {\n             return true;\n         };\n \n+        trace!(?impl_src);\n+\n         if !matches!(\n             impl_src,\n             ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)"}, {"sha": "805e6096b35c8577c2a033d3f999f26c462c5a55", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -8,7 +8,6 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location, Statement, StatementK\n use rustc_mir_dataflow::fmt::DebugWithContext;\n use rustc_mir_dataflow::JoinSemiLattice;\n use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces};\n-use rustc_span::DUMMY_SP;\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -120,10 +119,7 @@ where\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n-        !place\n-            .ty(self.ccx.body, self.ccx.tcx)\n-            .ty\n-            .is_freeze(self.ccx.tcx.at(DUMMY_SP), self.ccx.param_env)\n+        !place.ty(self.ccx.body, self.ccx.tcx).ty.is_freeze(self.ccx.tcx, self.ccx.param_env)\n     }\n }\n "}, {"sha": "f48bcd9080966dafe2d693b828bb04aee3aafc69", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -41,19 +41,14 @@ pub struct PromoteTemps<'tcx> {\n }\n \n impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n-    fn phase_change(&self) -> Option<MirPhase> {\n-        Some(MirPhase::Analysis(AnalysisPhase::Initial))\n-    }\n-\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         //\n         // This does not include MIR that failed const-checking, which we still try to promote.\n-        if body.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+        if let Err(_) = body.return_ty().error_reported() {\n+            debug!(\"PromoteTemps: MIR had errors\");\n             return;\n         }\n-\n         if body.source.promoted.is_some() {\n             return;\n         }"}, {"sha": "81b82a21fa1a7276796672a3980784bad79869ed", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -235,9 +235,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n                 let ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-                let span = self.body.source_info(location).span;\n \n-                if !ty.is_copy_modulo_regions(self.tcx.at(span), self.param_env) {\n+                if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n                     self.fail(location, format!(\"`Operand::Copy` with non-`Copy` type {}\", ty));\n                 }\n             }\n@@ -556,21 +555,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n             Rvalue::Cast(kind, operand, target_type) => {\n+                let op_ty = operand.ty(self.body, self.tcx);\n                 match kind {\n                     CastKind::DynStar => {\n                         // FIXME(dyn-star): make sure nothing needs to be done here.\n                     }\n-                    // Nothing to check here\n+                    // FIXME: Add Checks for these\n                     CastKind::PointerFromExposedAddress\n                     | CastKind::PointerExposeAddress\n                     | CastKind::Pointer(_) => {}\n-                    _ => {\n-                        let op_ty = operand.ty(self.body, self.tcx);\n-                        if op_ty.is_enum() {\n+                    CastKind::IntToInt | CastKind::IntToFloat => {\n+                        let input_valid = op_ty.is_integral() || op_ty.is_char() || op_ty.is_bool();\n+                        let target_valid = target_type.is_numeric() || target_type.is_char();\n+                        if !input_valid || !target_valid {\n+                            self.fail(\n+                                location,\n+                                format!(\"Wrong cast kind {kind:?} for the type {op_ty}\",),\n+                            );\n+                        }\n+                    }\n+                    CastKind::FnPtrToPtr | CastKind::PtrToPtr => {\n+                        if !(op_ty.is_any_ptr() && target_type.is_unsafe_ptr()) {\n+                            self.fail(location, \"Can't cast {op_ty} into 'Ptr'\");\n+                        }\n+                    }\n+                    CastKind::FloatToFloat | CastKind::FloatToInt => {\n+                        if !op_ty.is_floating_point() || !target_type.is_numeric() {\n                             self.fail(\n                                 location,\n                                 format!(\n-                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                    \"Trying to cast non 'Float' as {kind:?} into {target_type:?}\"\n                                 ),\n                             );\n                         }"}, {"sha": "5446ccb1a47307e7608a7f28b78a27c50b12237d", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -3,7 +3,7 @@\n //! context.\n \n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItemGroup;\n+use rustc_hir::lang_items;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_span::symbol::Ident;\n@@ -74,22 +74,24 @@ pub fn call_kind<'tcx>(\n         }\n     });\n \n-    let fn_call = parent\n-        .and_then(|p| tcx.lang_items().group(LangItemGroup::Fn).iter().find(|did| **did == p));\n+    let fn_call = parent.and_then(|p| {\n+        lang_items::FN_TRAITS.iter().filter_map(|&l| tcx.lang_items().get(l)).find(|&id| id == p)\n+    });\n \n-    let operator = (!from_hir_call)\n-        .then(|| parent)\n-        .flatten()\n-        .and_then(|p| tcx.lang_items().group(LangItemGroup::Op).iter().find(|did| **did == p));\n+    let operator = if !from_hir_call && let Some(p) = parent {\n+        lang_items::OPERATORS.iter().filter_map(|&l| tcx.lang_items().get(l)).find(|&id| id == p)\n+    } else {\n+        None\n+    };\n \n     let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n \n     // Check for a 'special' use of 'self' -\n     // an FnOnce call, an operator (e.g. `<<`), or a\n     // deref coercion.\n-    let kind = if let Some(&trait_id) = fn_call {\n+    let kind = if let Some(trait_id) = fn_call {\n         Some(CallKind::FnCall { fn_trait_id: trait_id, self_ty: method_substs.type_at(0) })\n-    } else if let Some(&trait_id) = operator {\n+    } else if let Some(trait_id) = operator {\n         Some(CallKind::Operator { self_arg, trait_id, self_ty: method_substs.type_at(0) })\n     } else if is_deref {\n         let deref_target = tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {"}, {"sha": "4d0f81a4060088b669d85902ca9013a50f7e3e4c", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -4,9 +4,11 @@ mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n mod might_permit_raw_init;\n+mod type_name;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;\n pub use self::might_permit_raw_init::might_permit_raw_init;\n+pub use self::type_name::type_name;"}, {"sha": "08a6d69b8e40c28422fc6a8710606cdca7b65d37", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "renamed", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,6 @@\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::CrateNum;\n use rustc_hir::definitions::DisambiguatedDefPathData;\n-use rustc_middle::mir::interpret::{Allocation, ConstAllocation};\n use rustc_middle::ty::{\n     self,\n     print::{PrettyPrinter, Print, Printer},\n@@ -74,18 +73,10 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n     }\n \n     fn print_dyn_existential(\n-        mut self,\n+        self,\n         predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n-        let mut first = true;\n-        for p in predicates {\n-            if !first {\n-                write!(self, \"+\")?;\n-            }\n-            first = false;\n-            self = p.print(self)?;\n-        }\n-        Ok(self)\n+        self.pretty_print_dyn_existential(predicates)\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n@@ -179,6 +170,11 @@ impl<'tcx> PrettyPrinter<'tcx> for AbsolutePathPrinter<'tcx> {\n \n         Ok(self)\n     }\n+\n+    fn should_print_verbose(&self) -> bool {\n+        // `std::any::type_name` should never print verbose type names\n+        false\n+    }\n }\n \n impl Write for AbsolutePathPrinter<'_> {\n@@ -188,9 +184,6 @@ impl Write for AbsolutePathPrinter<'_> {\n     }\n }\n \n-/// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n-    let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n-    let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n-    tcx.intern_const_alloc(alloc)\n+pub fn type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> String {\n+    AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path\n }", "previous_filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs"}, {"sha": "5afce15e26bfcc55e3fa8c7454c010dc0aca2296", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -23,9 +23,9 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dangle\"] }\n stable_deref_trait = \"1.0.0\"\n-stacker = \"0.1.14\"\n+stacker = \"0.1.15\"\n tempfile = \"3.2\"\n-thin-vec = \"0.2.8\"\n+thin-vec = \"0.2.9\"\n tracing = \"0.1\"\n \n [dependencies.parking_lot]"}, {"sha": "11cbff8ea6a84ef7d27adf4a266866a3409848ec", "filename": "compiler/rustc_data_structures/src/intern.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fintern.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -110,11 +110,6 @@ where\n     }\n }\n \n-/// A helper trait so that `Interned` things can cache stable hashes reproducibly.\n-pub trait InternedHashingContext {\n-    fn with_def_path_and_no_spans(&mut self, f: impl FnOnce(&mut Self));\n-}\n-\n /// A helper type that you can wrap round your own type in order to automatically\n /// cache the stable hash on creation and not recompute it whenever the stable hash\n /// of the type is computed.\n@@ -161,11 +156,15 @@ impl<T> Deref for WithStableHash<T> {\n impl<T: Hash> Hash for WithStableHash<T> {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.internee.hash(s)\n+        if self.stable_hash != Fingerprint::ZERO {\n+            self.stable_hash.hash(s)\n+        } else {\n+            self.internee.hash(s)\n+        }\n     }\n }\n \n-impl<T: HashStable<CTX>, CTX: InternedHashingContext> HashStable<CTX> for WithStableHash<T> {\n+impl<T: HashStable<CTX>, CTX> HashStable<CTX> for WithStableHash<T> {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n         if self.stable_hash == Fingerprint::ZERO || cfg!(debug_assertions) {\n             // No cached hash available. This can only mean that incremental is disabled.\n@@ -176,7 +175,7 @@ impl<T: HashStable<CTX>, CTX: InternedHashingContext> HashStable<CTX> for WithSt\n             // otherwise the hashes will differ between cached and non-cached mode.\n             let stable_hash: Fingerprint = {\n                 let mut hasher = StableHasher::new();\n-                hcx.with_def_path_and_no_spans(|hcx| self.internee.hash_stable(hcx, &mut hasher));\n+                self.internee.hash_stable(hcx, &mut hasher);\n                 hasher.finish()\n             };\n             if cfg!(debug_assertions) && self.stable_hash != Fingerprint::ZERO {"}, {"sha": "3a2000233c5d10fac7150e1956b2e33f7a9a7042", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -22,6 +22,7 @@\n #![feature(new_uninit)]\n #![feature(once_cell)]\n #![feature(rustc_attrs)]\n+#![feature(negative_impls)]\n #![feature(test)]\n #![feature(thread_id_value)]\n #![feature(vec_into_raw_parts)]\n@@ -86,6 +87,7 @@ pub mod steal;\n pub mod tagged_ptr;\n pub mod temp_dir;\n pub mod unhash;\n+pub mod unord;\n \n pub use ena::undo_log;\n pub use ena::unify;"}, {"sha": "c550f246e094aa77358d0010610e108226caf5af", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -410,6 +410,7 @@ impl<T> Lock<T> {\n \n     #[cfg(parallel_compiler)]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         if ERROR_CHECKING {\n             self.0.try_lock().expect(\"lock was already held\")\n@@ -420,21 +421,25 @@ impl<T> Lock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn lock(&self) -> LockGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.lock())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> LockGuard<'_, T> {\n         self.lock()\n     }\n@@ -476,6 +481,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn read(&self) -> ReadGuard<'_, T> {\n         self.0.borrow()\n     }\n@@ -491,6 +497,7 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n         f(&*self.read())\n     }\n@@ -509,6 +516,7 @@ impl<T> RwLock<T> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n+    #[track_caller]\n     pub fn write(&self) -> WriteGuard<'_, T> {\n         self.0.borrow_mut()\n     }\n@@ -524,16 +532,19 @@ impl<T> RwLock<T> {\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n         f(&mut *self.write())\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow(&self) -> ReadGuard<'_, T> {\n         self.read()\n     }\n \n     #[inline(always)]\n+    #[track_caller]\n     pub fn borrow_mut(&self) -> WriteGuard<'_, T> {\n         self.write()\n     }"}, {"sha": "c015f1232cd927c74ec8c968c1328985940a693a", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -0,0 +1,382 @@\n+//! This module contains collection types that don't expose their internal\n+//! ordering. This is a useful property for deterministic computations, such\n+//! as required by the query system.\n+\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::SmallVec;\n+use std::{\n+    borrow::Borrow,\n+    hash::Hash,\n+    iter::{Product, Sum},\n+};\n+\n+use crate::{\n+    fingerprint::Fingerprint,\n+    stable_hasher::{HashStable, StableHasher, ToStableHashKey},\n+};\n+\n+/// `UnordItems` is the order-less version of `Iterator`. It only contains methods\n+/// that don't (easily) expose an ordering of the underlying items.\n+///\n+/// Most methods take an `Fn` where the `Iterator`-version takes an `FnMut`. This\n+/// is to reduce the risk of accidentally leaking the internal order via the closure\n+/// environment. Otherwise one could easily do something like\n+///\n+/// ```rust,ignore (pseudo code)\n+/// let mut ordered = vec![];\n+/// unordered_items.all(|x| ordered.push(x));\n+/// ```\n+///\n+/// It's still possible to do the same thing with an `Fn` by using interior mutability,\n+/// but the chance of doing it accidentally is reduced.\n+pub struct UnordItems<T, I: Iterator<Item = T>>(I);\n+\n+impl<T, I: Iterator<Item = T>> UnordItems<T, I> {\n+    #[inline]\n+    pub fn map<U, F: Fn(T) -> U>(self, f: F) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.map(f))\n+    }\n+\n+    #[inline]\n+    pub fn all<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.all(f)\n+    }\n+\n+    #[inline]\n+    pub fn any<U, F: Fn(T) -> bool>(mut self, f: F) -> bool {\n+        self.0.any(f)\n+    }\n+\n+    #[inline]\n+    pub fn filter<U, F: Fn(&T) -> bool>(self, f: F) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.filter(f))\n+    }\n+\n+    #[inline]\n+    pub fn filter_map<U, F: Fn(T) -> Option<U>>(\n+        self,\n+        f: F,\n+    ) -> UnordItems<U, impl Iterator<Item = U>> {\n+        UnordItems(self.0.filter_map(f))\n+    }\n+\n+    #[inline]\n+    pub fn max(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.max()\n+    }\n+\n+    #[inline]\n+    pub fn min(self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n+        self.0.min()\n+    }\n+\n+    #[inline]\n+    pub fn sum<S>(self) -> S\n+    where\n+        S: Sum<T>,\n+    {\n+        self.0.sum()\n+    }\n+\n+    #[inline]\n+    pub fn product<S>(self) -> S\n+    where\n+        S: Product<T>,\n+    {\n+        self.0.product()\n+    }\n+\n+    #[inline]\n+    pub fn count(self) -> usize {\n+        self.0.count()\n+    }\n+}\n+\n+impl<'a, T: Clone + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn cloned(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.cloned())\n+    }\n+}\n+\n+impl<'a, T: Copy + 'a, I: Iterator<Item = &'a T>> UnordItems<&'a T, I> {\n+    #[inline]\n+    pub fn copied(self) -> UnordItems<T, impl Iterator<Item = T>> {\n+        UnordItems(self.0.copied())\n+    }\n+}\n+\n+impl<T: Ord, I: Iterator<Item = T>> UnordItems<T, I> {\n+    pub fn into_sorted<HCX>(self, hcx: &HCX) -> Vec<T>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: Vec<T> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+\n+    pub fn into_sorted_small_vec<HCX, const LEN: usize>(self, hcx: &HCX) -> SmallVec<[T; LEN]>\n+    where\n+        T: ToStableHashKey<HCX>,\n+    {\n+        let mut items: SmallVec<[T; LEN]> = self.0.collect();\n+        items.sort_by_cached_key(|x| x.to_stable_hash_key(hcx));\n+        items\n+    }\n+}\n+\n+/// This is a set collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for set-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordSet<V: Eq + Hash> {\n+    inner: FxHashSet<V>,\n+}\n+\n+impl<V: Eq + Hash> Default for UnordSet<V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashSet::default() }\n+    }\n+}\n+\n+impl<V: Eq + Hash> UnordSet<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, v: V) -> bool {\n+        self.inner.insert(v)\n+    }\n+\n+    #[inline]\n+    pub fn contains<Q: ?Sized>(&self, v: &Q) -> bool\n+    where\n+        V: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains(v)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<V: Hash + Eq> Extend<V> for UnordSet<V> {\n+    fn extend<T: IntoIterator<Item = V>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordSet<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a map collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for map-like collections the\n+/// keys of which don't have a semantic ordering.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordMap<K: Eq + Hash, V> {\n+    inner: FxHashMap<K, V>,\n+}\n+\n+impl<K: Eq + Hash, V> Default for UnordMap<K, V> {\n+    fn default() -> Self {\n+        Self { inner: FxHashMap::default() }\n+    }\n+}\n+\n+impl<K: Hash + Eq, V> Extend<(K, V)> for UnordMap<K, V> {\n+    fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> UnordMap<K, V> {\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        self.inner.insert(k, v)\n+    }\n+\n+    #[inline]\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        self.inner.contains_key(k)\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<(&'a K, &'a V), impl Iterator<Item = (&'a K, &'a V)>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<(K, V), impl Iterator<Item = (K, V)>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordMap from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = (K, V)>>(&mut self, items: UnordItems<(K, V), I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<HCX, K: Hash + Eq + HashStable<HCX>, V: HashStable<HCX>> HashStable<HCX> for UnordMap<K, V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+/// This is a collection type that tries very hard to not expose\n+/// any internal iteration. This is a useful property when trying to\n+/// uphold the determinism invariants imposed by the query system.\n+///\n+/// This collection type is a good choice for collections the\n+/// keys of which don't have a semantic ordering and don't implement\n+/// `Hash` or `Eq`.\n+///\n+/// See [MCP 533](https://github.com/rust-lang/compiler-team/issues/533)\n+/// for more information.\n+#[derive(Default, Debug, Eq, PartialEq, Clone, Encodable, Decodable)]\n+pub struct UnordBag<V> {\n+    inner: Vec<V>,\n+}\n+\n+impl<V> UnordBag<V> {\n+    #[inline]\n+    pub fn new() -> Self {\n+        Self { inner: Default::default() }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+\n+    #[inline]\n+    pub fn push(&mut self, v: V) {\n+        self.inner.push(v);\n+    }\n+\n+    #[inline]\n+    pub fn items<'a>(&'a self) -> UnordItems<&'a V, impl Iterator<Item = &'a V>> {\n+        UnordItems(self.inner.iter())\n+    }\n+\n+    #[inline]\n+    pub fn into_items(self) -> UnordItems<V, impl Iterator<Item = V>> {\n+        UnordItems(self.inner.into_iter())\n+    }\n+\n+    // We can safely extend this UnordSet from a set of unordered values because that\n+    // won't expose the internal ordering anywhere.\n+    #[inline]\n+    pub fn extend<I: Iterator<Item = V>>(&mut self, items: UnordItems<V, I>) {\n+        self.inner.extend(items.0)\n+    }\n+}\n+\n+impl<T> Extend<T> for UnordBag<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        self.inner.extend(iter)\n+    }\n+}\n+\n+impl<HCX, V: Hash + Eq + HashStable<HCX>> HashStable<HCX> for UnordBag<V> {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n+        hash_iter_order_independent(self.inner.iter(), hcx, hasher);\n+    }\n+}\n+\n+fn hash_iter_order_independent<\n+    HCX,\n+    T: HashStable<HCX>,\n+    I: Iterator<Item = T> + ExactSizeIterator,\n+>(\n+    mut it: I,\n+    hcx: &mut HCX,\n+    hasher: &mut StableHasher,\n+) {\n+    let len = it.len();\n+    len.hash_stable(hcx, hasher);\n+\n+    match len {\n+        0 => {\n+            // We're done\n+        }\n+        1 => {\n+            // No need to instantiate a hasher\n+            it.next().unwrap().hash_stable(hcx, hasher);\n+        }\n+        _ => {\n+            let mut accumulator = Fingerprint::ZERO;\n+            for item in it {\n+                let mut item_hasher = StableHasher::new();\n+                item.hash_stable(hcx, &mut item_hasher);\n+                let item_fingerprint: Fingerprint = item_hasher.finish();\n+                accumulator = accumulator.combine_commutative(item_fingerprint);\n+            }\n+            accumulator.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+// Do not implement IntoIterator for the collections in this module.\n+// They only exist to hide iteration order in the first place.\n+impl<T> !IntoIterator for UnordBag<T> {}\n+impl<V> !IntoIterator for UnordSet<V> {}\n+impl<K, V> !IntoIterator for UnordMap<K, V> {}\n+impl<T, I> !IntoIterator for UnordItems<T, I> {}"}, {"sha": "e043368fdfe0210ae475bd7b151310538ba099cc", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(once_cell)]\n+#![feature(decl_macro)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -427,18 +428,6 @@ fn run_compiler(\n     })\n }\n \n-#[cfg(unix)]\n-pub fn set_sigpipe_handler() {\n-    unsafe {\n-        // Set the SIGPIPE signal handler, so that an EPIPE\n-        // will cause rustc to terminate, as expected.\n-        assert_ne!(libc::signal(libc::SIGPIPE, libc::SIG_DFL), libc::SIG_ERR);\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn set_sigpipe_handler() {}\n-\n // Extract output directory and file from matches.\n fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));\n@@ -748,26 +737,58 @@ fn print_crate_info(\n             // Any output here interferes with Cargo's parsing of other printed output\n             NativeStaticLibs => {}\n             LinkArgs => {}\n+            SplitDebuginfo => {\n+                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n+\n+                for split in &[Off, Packed, Unpacked] {\n+                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n+                    let unstable_ok = sess.unstable_options();\n+                    if stable || unstable_ok {\n+                        println!(\"{}\", split);\n+                    }\n+                }\n+            }\n         }\n     }\n     Compilation::Stop\n }\n \n /// Prints version information\n-pub fn version(binary: &str, matches: &getopts::Matches) {\n+///\n+/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n+pub macro version($binary: literal, $matches: expr) {\n+    fn unw(x: Option<&str>) -> &str {\n+        x.unwrap_or(\"unknown\")\n+    }\n+    $crate::version_at_macro_invocation(\n+        $binary,\n+        $matches,\n+        unw(option_env!(\"CFG_VERSION\")),\n+        unw(option_env!(\"CFG_VER_HASH\")),\n+        unw(option_env!(\"CFG_VER_DATE\")),\n+        unw(option_env!(\"CFG_RELEASE\")),\n+    )\n+}\n+\n+#[doc(hidden)] // use the macro instead\n+pub fn version_at_macro_invocation(\n+    binary: &str,\n+    matches: &getopts::Matches,\n+    version: &str,\n+    commit_hash: &str,\n+    commit_date: &str,\n+    release: &str,\n+) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\", binary, util::version_str().unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\", binary, version);\n \n     if verbose {\n-        fn unw(x: Option<&str>) -> &str {\n-            x.unwrap_or(\"unknown\")\n-        }\n         println!(\"binary: {}\", binary);\n-        println!(\"commit-hash: {}\", unw(util::commit_hash_str()));\n-        println!(\"commit-date: {}\", unw(util::commit_date_str()));\n+        println!(\"commit-hash: {}\", commit_hash);\n+        println!(\"commit-date: {}\", commit_date);\n         println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {}\", unw(util::release_str()));\n+        println!(\"release: {}\", release);\n \n         let debug_flags = matches.opt_strs(\"Z\");\n         let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n@@ -1083,7 +1104,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if matches.opt_present(\"version\") {\n-        version(\"rustc\", &matches);\n+        version!(\"rustc\", &matches);\n         return None;\n     }\n \n@@ -1212,6 +1233,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         false,\n         None,\n         false,\n+        false,\n     ));\n     let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n \n@@ -1227,7 +1249,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         format!(\"we would appreciate a bug report: {}\", bug_report_url).into(),\n         format!(\n             \"rustc {} running on {}\",\n-            util::version_str().unwrap_or(\"unknown_version\"),\n+            util::version_str!().unwrap_or(\"unknown_version\"),\n             config::host_triple()\n         )\n         .into(),"}, {"sha": "95e7c9fc76ce2bf00c081a386e488c4dfcf05b6e", "filename": "compiler/rustc_error_codes/src/error_codes/E0207.md", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,4 +1,5 @@\n-A type parameter that is specified for `impl` is not constrained.\n+A type, const or lifetime parameter that is specified for `impl` is not\n+constrained.\n \n Erroneous code example:\n \n@@ -14,15 +15,18 @@ impl<T: Default> Foo {\n }\n ```\n \n-Any type parameter of an `impl` must meet at least one of\n-the following criteria:\n+Any type or const parameter of an `impl` must meet at least one of the\n+following criteria:\n \n  - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\n  - for a trait impl, it appears in the _implemented trait_, e.g.\n    `impl<T> SomeTrait<T> for Foo`\n  - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\n    where T: AnotherTrait<AssocType=U>`\n \n+Any unconstrained lifetime parameter of an `impl` is not supported if the\n+lifetime parameter is used by an associated type.\n+\n ### Error example 1\n \n Suppose we have a struct `Foo` and we would like to define some methods for it.\n@@ -32,7 +36,6 @@ The problem is that the parameter `T` does not appear in the implementing type\n (`Foo`) of the impl. In this case, we can fix the error by moving the type\n parameter from the `impl` to the method `get`:\n \n-\n ```\n struct Foo;\n \n@@ -128,6 +131,70 @@ impl<T: Default> Maker<Foo<T>> for FooMaker {\n }\n ```\n \n+### Error example 3\n+\n+Suppose we have a struct `Foo` and we would like to define some methods for it.\n+The following code example has a definition which leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+\n+impl<const T: i32> Foo {\n+    // error: the const parameter `T` is not constrained by the impl trait, self\n+    // type, or predicates [E0207]\n+    fn get(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+The problem is that the const parameter `T` does not appear in the implementing\n+type (`Foo`) of the impl. In this case, we can fix the error by moving the type\n+parameter from the `impl` to the method `get`:\n+\n+\n+```\n+struct Foo;\n+\n+// Move the const parameter from the impl to the method\n+impl Foo {\n+    fn get<const T: i32>(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+### Error example 4\n+\n+Suppose we have a struct `Foo` and a struct `Bar` that uses lifetime `'a`. We\n+would like to implement trait `Contains` for `Foo`. The trait `Contains` have\n+the associated type `B`. The following code example has a definition which\n+leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+struct Bar<'a>;\n+\n+trait Contains {\n+    type B;\n+\n+    fn get(&self) -> i32;\n+}\n+\n+impl<'a> Contains for Foo {\n+    type B = Bar<'a>;\n+\n+    // error: the lifetime parameter `'a` is not constrained by the impl trait,\n+    // self type, or predicates [E0207]\n+    fn get(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+Please note that unconstrained lifetime parameters are not supported if they are\n+being used by an associated type.\n+\n ### Additional information\n \n For more information, please see [RFC 447]."}, {"sha": "41263e5e3f5ac8381b9dba21e49d1efbfb2a857a", "filename": "compiler/rustc_error_codes/src/error_codes/E0210.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -76,7 +76,5 @@ Let `Ti` be the first such type.\n For information on the design of the orphan rules,\n see [RFC 2451] and [RFC 1023].\n \n-For information on the design of the orphan rules, see [RFC 1023].\n-\n [RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\n [RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "194bbd83b0f74c296dc97e009c697fc8ebad914e", "filename": "compiler/rustc_error_codes/src/error_codes/E0322.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0322.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0322.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0322.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,4 +1,5 @@\n-The `Sized` trait was implemented explicitly.\n+A built-in trait was implemented explicitly. All implementations of the trait\n+are provided automatically by the compiler.\n \n Erroneous code example:\n "}, {"sha": "cbc4980f8cab3bd7bcea297902ac6a2ab9db364d", "filename": "compiler/rustc_error_codes/src/error_codes/E0382.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0382.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -61,7 +61,7 @@ with `#[derive(Clone)]`.\n \n Some types have no ownership semantics at all and are trivial to duplicate. An\n example is `i32` and the other number types. We don't have to call `.clone()` to\n-clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+clone them, because they are marked `Copy` in addition to `Clone`. Implicit\n cloning is more convenient in this case. We can mark our own types `Copy` if\n all their members also are marked `Copy`.\n "}, {"sha": "fabd855a222f0f3e1aa97d96e580c9107737ec97", "filename": "compiler/rustc_error_codes/src/error_codes/E0706.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0706.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -56,4 +56,4 @@ You might be interested in visiting the [async book] for further information.\n [`async-trait` crate]: https://crates.io/crates/async-trait\n [async-is-hard]: https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/\n [Generic Associated Types]: https://github.com/rust-lang/rust/issues/44265\n-[async book]: https://rust-lang.github.io/async-book/07_workarounds/06_async_in_traits.html\n+[async book]: https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html"}, {"sha": "9536fdbf0df87362eac7e509c289361d8be95c73", "filename": "compiler/rustc_error_codes/src/error_codes/E0732.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0732.md?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -3,8 +3,6 @@ An `enum` with a discriminant must specify a `#[repr(inttype)]`.\n Erroneous code example:\n \n ```compile_fail,E0732\n-#![feature(arbitrary_enum_discriminant)]\n-\n enum Enum { // error!\n     Unit = 1,\n     Tuple() = 2,\n@@ -20,8 +18,6 @@ is a well-defined way to extract a variant's discriminant from a value;\n for instance:\n \n ```\n-#![feature(arbitrary_enum_discriminant)]\n-\n #[repr(u8)]\n enum Enum {\n     Unit = 3,"}, {"sha": "de47ada826444e00644e0edfc357973969a21f20", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -58,3 +58,68 @@ borrowck_returned_lifetime_short =\n \n borrowck_used_impl_require_static =\n     the used `impl` has a `'static` requirement\n+\n+borrowck_capture_kind_label =\n+    capture is {$kind_desc} because of use here\n+\n+borrowck_var_borrow_by_use_place_in_generator =\n+    borrow occurs due to use of {$place} in closure in generator\n+\n+borrowck_var_borrow_by_use_place_in_closure =\n+    borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_borrow_by_use_place =\n+    borrow occurs due to use of {$place}\n+\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_assign_due_to_use_generator =\n+    assign occurs due to use in generator\n+\n+borrowck_assign_part_due_to_use_generator =\n+    assign to part occurs due to use in generator\n+\n+borrowck_borrow_due_to_use_closure =\n+    borrow occurs due to use in closure\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_assign_due_to_use_closure =\n+    assign occurs due to use in closure\n+\n+borrowck_assign_part_due_to_use_closure =\n+    assign to part occurs due to use in closure\n+\n+borrowck_capture_immute =\n+    capture is immutable because of use here\n+\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n+\n+borrowck_capture_move =\n+    capture is moved because of use here\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here"}, {"sha": "68a205df6c7ad05207b41617b23b8defd7dab31c", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -0,0 +1,58 @@\n+codegen_llvm_unknown_ctarget_feature =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = it is still passed through to the codegen backend\n+    .possible_feature = you might have meant: `{$rust_feature}`\n+    .consider_filing_feature_request = consider filing a feature request\n+\n+codegen_llvm_unknown_ctarget_feature_prefix =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = features must begin with a `+` to enable or `-` to disable it\n+\n+codegen_llvm_error_creating_import_library =\n+    Error creating import library for {$lib_name}: {$error}\n+\n+codegen_llvm_instrument_coverage_requires_llvm_12 =\n+    rustc option `-C instrument-coverage` requires LLVM 12 or higher.\n+\n+codegen_llvm_symbol_already_defined =\n+    symbol `{$symbol_name}` is already defined\n+\n+codegen_llvm_branch_protection_requires_aarch64 =\n+    -Zbranch-protection is only supported on aarch64\n+\n+codegen_llvm_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n+\n+codegen_llvm_linkage_const_or_mut_type =\n+    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+\n+codegen_llvm_sanitizer_memtag_requires_mte =\n+    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n+\n+codegen_llvm_archive_build_failure =\n+    failed to build archive: {$error}\n+\n+codegen_llvm_error_writing_def_file =\n+    Error writing .DEF file: {$error}\n+\n+codegen_llvm_error_calling_dlltool =\n+    Error calling dlltool: {$error}\n+\n+codegen_llvm_dlltool_fail_import_library =\n+    Dlltool could not create import library: {$stdout}\\n{$stderr}\n+\n+codegen_llvm_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}\n+\n+codegen_llvm_target_feature_disable_or_enable =\n+    the target features {$features} must all be either enabled or disabled together\n+\n+codegen_llvm_missing_features =\n+    add the missing features in a `target_feature` attribute\n+\n+codegen_llvm_dynamic_linking_with_lto =\n+    cannot prefer dynamic linking when performing LTO\n+    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+\n+codegen_llvm_fail_parsing_target_machine_config_to_target_machine =\n+    failed to parse target machine config to target machine: {$error}"}, {"sha": "eb6b403d00e88943e8eddd6f32d66bce672b0bc4", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -119,3 +119,68 @@ codegen_ssa_thorin_object_read = {$error}\n codegen_ssa_thorin_object_write = {$error}\n codegen_ssa_thorin_gimli_read = {$error}\n codegen_ssa_thorin_gimli_write = {$error}\n+\n+codegen_ssa_link_exe_unexpected_error = `link.exe` returned an unexpected error\n+\n+codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n+\n+codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n+\n+codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n+\n+codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload\n+\n+codegen_ssa_linker_not_found = linker `{$linker_path}` not found\n+    .note = {$error}\n+\n+codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n+    .note = {$error}\n+    .command_note = {$command_formatted}\n+\n+codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n+\n+codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n+\n+codegen_ssa_unsufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+\n+codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n+\n+codegen_ssa_stripping_debu_info_failed = stripping debug info with `{$util}` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n+\n+codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n+\n+codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n+\n+codegen_ssa_native_static_libs = native-static-libs: {$arguments}\n+\n+codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n+\n+codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n+\n+codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+\n+codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n+\n+codegen_ssa_rlib_archive_build_failure = failed to build archive from rlib: {$error}\n+\n+codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n+\n+codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n+\n+codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n+\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {error}\n+\n+codegen_ssa_read_file = failed to read file: {message}"}, {"sha": "d27edd47470e83a60c74dd527f9317c1bbad4b7b", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -93,7 +93,7 @@ hir_analysis_expected_default_return_type = expected `()` because of default ret\n hir_analysis_expected_return_type = expected `{$expected}` because of return type\n \n hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n-    .note = `{$name}` must be used in combination with a concrete type within the same module\n+    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n@@ -137,3 +137,19 @@ hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(l\n hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n \n hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+\n+hir_analysis_const_impl_for_non_const_trait =\n+    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n+    .suggestion = mark `{$trait_name}` as const\n+    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+    .adding = adding a non-const method body in the future would be a breaking change\n+\n+hir_analysis_const_bound_for_non_const_trait =\n+    ~const can only be applied to `#[const_trait]` traits\n+\n+hir_analysis_self_in_impl_self =\n+    `Self` is not valid in the self type of an impl block\n+    .note = replace `Self` with a different type\n+\n+hir_analysis_op_trait_generic_params =\n+    `{$method_name}` must not have any generic parameters"}, {"sha": "c9d83746d5454debb5f9e21fb847cc1a3cd863bb", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -126,10 +126,10 @@ infer_data_lifetime_flow = ...but data with one lifetime flows into the other he\n infer_declared_multiple = this type is declared with multiple lifetimes...\n infer_types_declared_different = these two types are declared with different lifetimes...\n infer_data_flows = ...but data{$label_var1_exists ->\n-    [true] -> {\" \"}from `{$label_var1}`\n+    [true] {\" \"}from `{$label_var1}`\n     *[false] -> {\"\"}\n } flows{$label_var2_exists ->\n-    [true] -> {\" \"}into `{$label_var2}`\n+    [true] {\" \"}into `{$label_var2}`\n     *[false] -> {\"\"}\n } here\n \n@@ -171,3 +171,4 @@ infer_msl_introduces_static = introduces a `'static` lifetime requirement\n infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n+infer_suggest_add_let_for_letchains = consider adding `let`"}, {"sha": "c292ae9b32abba5af8a913994643c571303332c2", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -150,12 +150,28 @@ metadata_no_multiple_global_alloc =\n metadata_prev_global_alloc =\n     previous global allocator defined here\n \n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n+\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n+\n metadata_conflicting_global_alloc =\n     the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+\n metadata_global_alloc_required =\n     no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n \n+metadata_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+metadata_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n metadata_no_transitive_needs_dep =\n     the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n "}, {"sha": "81d8e8a473bb7184ca5b3892d727eb7523954682", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -27,3 +27,7 @@ middle_values_too_big =\n \n middle_cannot_be_normalized =\n     unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n+\n+middle_strict_coherence_needs_negative_coherence =\n+    to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n+    .label = due to this attribute"}, {"sha": "48ddb54b79e795eb3c67f96b69bb5dda24e32f01", "filename": "compiler/rustc_error_messages/locales/en-US/monomorphize.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmonomorphize.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -21,6 +21,3 @@ monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n-\n-monomorphize_requires_lang_item =\n-    requires `{$lang_item}` lang_item"}, {"sha": "4c7ce30097c95f324050b0d93ae2cc2770e1615c", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -112,6 +112,9 @@ parser_missing_semicolon_before_array = expected `;`, found `[`\n parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n     .label = the `block` fragment is within this context\n \n+parser_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n+\n parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n     .add_then_block = add a block here\n     .condition_possibly_unfinished = this binary operation is possibly unfinished\n@@ -122,6 +125,9 @@ parser_if_expression_missing_condition = missing condition for `if` expression\n \n parser_expected_expression_found_let = expected expression, found `let` statement\n \n+parser_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n+\n parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n     .label = expected an `if` or a block after this `else`\n     .suggestion = add an `if` if this is the condition of a chained `else if` statement\n@@ -369,3 +375,15 @@ parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n \n parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n     .suggestion = use single colon\n+\n+parser_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list\n+\n+parser_invalid_identifier_with_leading_number = expected identifier, found number literal\n+    .label = identifiers cannot start with a number"}, {"sha": "001e53d1d0e4ce52953539a295d5a3cf0ded2475", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -47,7 +47,10 @@ passes_no_coverage_not_coverable =\n \n passes_should_be_applied_to_fn =\n     attribute should be applied to a function definition\n-    .label = not a function definition\n+    .label = {$on_crate ->\n+        [true] cannot be applied to crates\n+        *[false] not a function definition\n+    }\n \n passes_naked_tracked_caller =\n     cannot use `#[track_caller]` with `#[naked]`\n@@ -367,12 +370,6 @@ passes_unknown_external_lang_item =\n passes_missing_panic_handler =\n     `#[panic_handler]` function required, but not found\n \n-passes_alloc_func_required =\n-    `#[alloc_error_handler]` function required, but not found\n-\n-passes_missing_alloc_error_handler =\n-    use `#![feature(default_alloc_error_handler)]` for a default error handler\n-\n passes_missing_lang_item =\n     language item required, but not found: `{$name}`\n     .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n@@ -457,8 +454,14 @@ passes_break_inside_async_block =\n     .async_block_label = enclosing `async` block\n \n passes_outside_loop =\n-    `{$name}` outside of a loop\n-    .label = cannot `{$name}` outside of a loop\n+    `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n+    .label = cannot `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n \n passes_unlabeled_in_labeled_block =\n     unlabeled `{$cf_type}` inside of a labeled block\n@@ -671,3 +674,36 @@ passes_missing_const_err =\n     attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n     .help = make the function or method const\n     .label = attribute specified here\n+\n+passes_dead_codes =\n+    { $multiple ->\n+      *[true] multiple {$descr}s are\n+       [false] { $num ->\n+         [one] {$descr} {$name_list} is\n+        *[other] {$descr}s {$name_list} are\n+       }\n+    } never {$participle}\n+\n+passes_change_fields_to_be_of_unit_type =\n+    consider changing the { $num ->\n+      [one] field\n+     *[other] fields\n+    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n+      [one] field\n+     *[other] fields\n+    }\n+\n+passes_parent_info =\n+    {$num ->\n+      [one] {$descr}\n+     *[other] {$descr}s\n+    } in this {$parent_descr}\n+\n+passes_ignored_derived_impls =\n+    `{$name}` has {$trait_list_len ->\n+      [one] a derived impl\n+     *[other] derived impls\n+    } for the {$trait_list_len ->\n+      [one] trait {$trait_list}, but this is\n+     *[other] traits {$trait_list}, but these are\n+    } intentionally ignored during dead code analysis"}, {"sha": "0b1b75471a661cefaa5d530e0534cb85ea868ea7", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -30,7 +30,8 @@ use intl_memoizer::concurrent::IntlLangMemoizer;\n #[cfg(not(parallel_compiler))]\n use intl_memoizer::IntlLangMemoizer;\n \n-pub use fluent_bundle::{FluentArgs, FluentError, FluentValue};\n+pub use fluent_bundle::{self, FluentArgs, FluentError, FluentValue};\n+\n pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n@@ -42,6 +43,7 @@ fluent_messages! {\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n+    codegen_llvm => \"../locales/en-US/codegen_llvm.ftl\",\n     codegen_ssa => \"../locales/en-US/codegen_ssa.ftl\",\n     compiletest => \"../locales/en-US/compiletest.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\","}, {"sha": "c450c276366e156220e09c14077eb72c23e4727b", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -52,7 +52,6 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.source_map,\n             &mut primary_span,\n             &mut children,\n             &diag.level,"}, {"sha": "66c986977eccb78c1ad58e2c9adc9c22a69f93e4", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 89, "deletions": 9, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,6 +12,7 @@ use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n+use std::panic::Location;\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n /// `.disable_suggestions()` was called on the `Diagnostic`.\n@@ -43,6 +44,15 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n+impl<'source> IntoDiagnosticArg for DiagnosticArgValue<'source> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            DiagnosticArgValue::Str(s) => DiagnosticArgValue::Str(Cow::Owned(s.into_owned())),\n+            DiagnosticArgValue::Number(n) => DiagnosticArgValue::Number(n),\n+        }\n+    }\n+}\n+\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {\n@@ -54,8 +64,7 @@ impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n-#[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n+#[rustc_diagnostic_item = \"AddToDiagnostic\"]\n pub trait AddToDiagnostic\n where\n     Self: Sized,\n@@ -107,6 +116,31 @@ pub struct Diagnostic {\n     /// If diagnostic is from Lint, custom hash function ignores notes\n     /// otherwise hash is based on the all the fields\n     pub is_lint: bool,\n+\n+    /// With `-Ztrack_diagnostics` enabled,\n+    /// we print where in rustc this error was emitted.\n+    pub emitted_at: DiagnosticLocation,\n+}\n+\n+#[derive(Clone, Debug, Encodable, Decodable)]\n+pub struct DiagnosticLocation {\n+    file: Cow<'static, str>,\n+    line: u32,\n+    col: u32,\n+}\n+\n+impl DiagnosticLocation {\n+    #[track_caller]\n+    fn caller() -> Self {\n+        let loc = Location::caller();\n+        DiagnosticLocation { file: loc.file().into(), line: loc.line(), col: loc.column() }\n+    }\n+}\n+\n+impl fmt::Display for DiagnosticLocation {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}:{}:{}\", self.file, self.line, self.col)\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n@@ -173,10 +207,28 @@ impl StringPart {\n }\n \n impl Diagnostic {\n+    #[track_caller]\n     pub fn new<M: Into<DiagnosticMessage>>(level: Level, message: M) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n     }\n \n+    #[track_caller]\n+    pub fn new_with_messages(level: Level, messages: Vec<(DiagnosticMessage, Style)>) -> Self {\n+        Diagnostic {\n+            level,\n+            message: messages,\n+            code: None,\n+            span: MultiSpan::new(),\n+            children: vec![],\n+            suggestions: Ok(vec![]),\n+            args: Default::default(),\n+            sort_span: DUMMY_SP,\n+            is_lint: false,\n+            emitted_at: DiagnosticLocation::caller(),\n+        }\n+    }\n+\n+    #[track_caller]\n     pub fn new_with_code<M: Into<DiagnosticMessage>>(\n         level: Level,\n         code: Option<DiagnosticId>,\n@@ -192,6 +244,7 @@ impl Diagnostic {\n             args: Default::default(),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n+            emitted_at: DiagnosticLocation::caller(),\n         }\n     }\n \n@@ -688,10 +741,28 @@ impl Diagnostic {\n         &mut self,\n         sp: Span,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = String>,\n+        suggestions: impl IntoIterator<Item = String>,\n+        applicability: Applicability,\n+    ) -> &mut Self {\n+        self.span_suggestions_with_style(\n+            sp,\n+            msg,\n+            suggestions,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        )\n+    }\n+\n+    /// [`Diagnostic::span_suggestions()`] but you can set the [`SuggestionStyle`].\n+    pub fn span_suggestions_with_style(\n+        &mut self,\n+        sp: Span,\n+        msg: impl Into<SubdiagnosticMessage>,\n+        suggestions: impl IntoIterator<Item = String>,\n         applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n-        let mut suggestions: Vec<_> = suggestions.collect();\n+        let mut suggestions: Vec<_> = suggestions.into_iter().collect();\n         suggestions.sort();\n \n         debug_assert!(\n@@ -706,21 +777,22 @@ impl Diagnostic {\n         self.push_suggestion(CodeSuggestion {\n             substitutions,\n             msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n         });\n         self\n     }\n \n-    /// Prints out a message with multiple suggested edits of the code.\n-    /// See also [`Diagnostic::span_suggestion()`].\n+    /// Prints out a message with multiple suggested edits of the code, where each edit consists of\n+    /// multiple parts.\n+    /// See also [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n+        suggestions: impl IntoIterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n-        let suggestions: Vec<_> = suggestions.collect();\n+        let suggestions: Vec<_> = suggestions.into_iter().collect();\n         debug_assert!(\n             !(suggestions\n                 .iter()\n@@ -745,6 +817,7 @@ impl Diagnostic {\n         });\n         self\n     }\n+\n     /// Prints out a message with a suggested edit of the code. If the suggestion is presented\n     /// inline, it will only show the message and not the suggestion.\n     ///\n@@ -882,6 +955,13 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn replace_args(\n+        &mut self,\n+        args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n+    ) {\n+        self.args = args;\n+    }\n+\n     pub fn styled_message(&self) -> &[(DiagnosticMessage, Style)] {\n         &self.message\n     }"}, {"sha": "a2ed988643ff2a4ef2589ba99046d045725e250f", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -16,8 +16,7 @@ use std::thread::panicking;\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Diagnostic)]` -- see [rustc_macros::Diagnostic].\n-#[cfg_attr(bootstrap, rustc_diagnostic_item = \"SessionDiagnostic\")]\n-#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"IntoDiagnostic\")]\n+#[rustc_diagnostic_item = \"IntoDiagnostic\"]\n pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     /// Write out as a diagnostic out of `Handler`.\n     #[must_use]\n@@ -133,6 +132,7 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n         handler: &'a Handler,\n         message: M,\n@@ -196,6 +196,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n         }\n     }\n \n+    #[track_caller]\n     fn make_diagnostic_builder(\n         handler: &Handler,\n         msg: impl Into<DiagnosticMessage>,\n@@ -209,6 +210,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new<M: Into<DiagnosticMessage>>(\n         handler: &'a Handler,\n         level: Level,\n@@ -220,6 +222,7 @@ impl<'a> DiagnosticBuilder<'a, ()> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n+    #[track_caller]\n     pub(crate) fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n@@ -308,6 +311,7 @@ impl EmissionGuarantee for Noted {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n+    #[track_caller]\n     pub(crate) fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)\n@@ -477,9 +481,9 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n     /// In the meantime, though, callsites are required to deal with the \"bug\"\n     /// locally in whichever way makes the most sense.\n     #[track_caller]\n-    pub fn delay_as_bug(&mut self) {\n+    pub fn delay_as_bug(&mut self) -> G {\n         self.downgrade_to_delayed_bug();\n-        self.emit();\n+        self.emit()\n     }\n \n     forward!(\n@@ -594,13 +598,13 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         &mut self,\n         sp: Span,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = String>,\n+        suggestions: impl IntoIterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n-        suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n+        suggestions: impl IntoIterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_short("}, {"sha": "c6035705e39fa70d2022800fee8d488c82fb115b", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -11,8 +11,10 @@ use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n+use std::fmt::Write;\n use std::num::ParseIntError;\n use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n \n pub struct DiagnosticArgFromDisplay<'a>(pub &'a dyn fmt::Display);\n \n@@ -58,6 +60,7 @@ into_diagnostic_arg_using_display!(\n     i128,\n     u128,\n     std::io::Error,\n+    std::boxed::Box<dyn std::error::Error>,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,\n@@ -66,7 +69,8 @@ into_diagnostic_arg_using_display!(\n     ParseIntError,\n     StackProtector,\n     &TargetTriple,\n-    SplitDebuginfo\n+    SplitDebuginfo,\n+    ExitStatus,\n );\n \n impl IntoDiagnosticArg for bool {\n@@ -103,6 +107,12 @@ impl IntoDiagnosticArg for String {\n     }\n }\n \n+impl<'a> IntoDiagnosticArg for Cow<'a, str> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.into_owned()))\n+    }\n+}\n+\n impl<'a> IntoDiagnosticArg for &'a Path {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n@@ -170,6 +180,37 @@ impl IntoDiagnosticArg for Level {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct DiagnosticSymbolList(Vec<Symbol>);\n+\n+impl From<Vec<Symbol>> for DiagnosticSymbolList {\n+    fn from(v: Vec<Symbol>) -> Self {\n+        DiagnosticSymbolList(v)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for DiagnosticSymbolList {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        // FIXME: replace the logic here with a real list formatter\n+        let symbols = match &self.0[..] {\n+            [symbol] => format!(\"`{symbol}`\"),\n+            [symbol, last] => {\n+                format!(\"`{symbol}` and `{last}`\",)\n+            }\n+            [symbols @ .., last] => {\n+                let mut result = String::new();\n+                for symbol in symbols {\n+                    write!(result, \"`{symbol}`, \").unwrap();\n+                }\n+                write!(result, \"and `{last}`\").unwrap();\n+                result\n+            }\n+            [] => unreachable!(),\n+        };\n+        DiagnosticArgValue::Str(Cow::Owned(symbols))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;"}, {"sha": "55c7997a513636bc38d48f8acfc74da9e3c61dd9", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 71, "deletions": 25, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -16,10 +16,10 @@ use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Styl\n use crate::styled_buffer::StyledBuffer;\n use crate::translation::{to_fluent_args, Translate};\n use crate::{\n-    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n-    LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n+    diagnostic::DiagnosticLocation, CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage,\n+    FluentBundle, Handler, LazyFallbackBundle, Level, MultiSpan, SubDiagnostic,\n+    SubstitutionHighlight, SuggestionStyle,\n };\n-\n use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n@@ -64,6 +64,7 @@ impl HumanReadableErrorType {\n         teach: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n@@ -77,6 +78,7 @@ impl HumanReadableErrorType {\n             color,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         )\n     }\n }\n@@ -312,7 +314,6 @@ pub trait Emitter: Translate {\n \n     fn fix_multispans_in_extern_macros_and_render_macro_backtrace(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n         level: &Level,\n@@ -338,7 +339,7 @@ pub trait Emitter: Translate {\n             .collect();\n \n         if !backtrace {\n-            self.fix_multispans_in_extern_macros(source_map, span, children);\n+            self.fix_multispans_in_extern_macros(span, children);\n         }\n \n         self.render_multispans_macro_backtrace(span, children, backtrace);\n@@ -478,23 +479,22 @@ pub trait Emitter: Translate {\n     // this will change the span to point at the use site.\n     fn fix_multispans_in_extern_macros(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n     ) {\n-        let Some(source_map) = source_map else { return };\n         debug!(\"fix_multispans_in_extern_macros: before: span={:?} children={:?}\", span, children);\n-        self.fix_multispan_in_extern_macros(source_map, span);\n+        self.fix_multispan_in_extern_macros(span);\n         for child in children.iter_mut() {\n-            self.fix_multispan_in_extern_macros(source_map, &mut child.span);\n+            self.fix_multispan_in_extern_macros(&mut child.span);\n         }\n         debug!(\"fix_multispans_in_extern_macros: after: span={:?} children={:?}\", span, children);\n     }\n \n     // This \"fixes\" MultiSpans that contain `Span`s pointing to locations inside of external macros.\n     // Since these locations are often difficult to read,\n     // we move these spans from the external macros to their corresponding use site.\n-    fn fix_multispan_in_extern_macros(&self, source_map: &Lrc<SourceMap>, span: &mut MultiSpan) {\n+    fn fix_multispan_in_extern_macros(&self, span: &mut MultiSpan) {\n+        let Some(source_map) = self.source_map() else { return };\n         // First, find all the spans in external macros and point instead at their use site.\n         let replacements: Vec<(Span, Span)> = span\n             .primary_spans()\n@@ -542,7 +542,6 @@ impl Emitter for EmitterWriter {\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.sm,\n             &mut primary_span,\n             &mut children,\n             &diag.level,\n@@ -557,6 +556,7 @@ impl Emitter for EmitterWriter {\n             &primary_span,\n             &children,\n             &suggestions,\n+            self.track_diagnostics.then_some(&diag.emitted_at),\n         );\n     }\n \n@@ -650,6 +650,7 @@ pub struct EmitterWriter {\n     diagnostic_width: Option<usize>,\n \n     macro_backtrace: bool,\n+    track_diagnostics: bool,\n }\n \n #[derive(Debug)]\n@@ -669,6 +670,7 @@ impl EmitterWriter {\n         teach: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n@@ -681,6 +683,7 @@ impl EmitterWriter {\n             ui_testing: false,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -694,6 +697,7 @@ impl EmitterWriter {\n         colored: bool,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n@@ -705,6 +709,7 @@ impl EmitterWriter {\n             ui_testing: false,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -1327,6 +1332,7 @@ impl EmitterWriter {\n         level: &Level,\n         max_line_num_len: usize,\n         is_secondary: bool,\n+        emitted_at: Option<&DiagnosticLocation>,\n     ) -> io::Result<()> {\n         let mut buffer = StyledBuffer::new();\n \n@@ -1377,7 +1383,6 @@ impl EmitterWriter {\n                 }\n             }\n         }\n-\n         let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n \n         // Make sure our primary file comes first\n@@ -1653,6 +1658,12 @@ impl EmitterWriter {\n             }\n         }\n \n+        if let Some(tracked) = emitted_at {\n+            let track = format!(\"-Ztrack-diagnostics: created at {tracked}\");\n+            let len = buffer.num_lines();\n+            buffer.append(len, &track, Style::NoStyle);\n+        }\n+\n         // final step: take our styled buffer, render it, then output it\n         emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n \n@@ -1977,6 +1988,7 @@ impl EmitterWriter {\n         span: &MultiSpan,\n         children: &[SubDiagnostic],\n         suggestions: &[CodeSuggestion],\n+        emitted_at: Option<&DiagnosticLocation>,\n     ) {\n         let max_line_num_len = if self.ui_testing {\n             ANONYMIZED_LINE_NUM.len()\n@@ -1985,7 +1997,16 @@ impl EmitterWriter {\n             num_decimal_digits(n)\n         };\n \n-        match self.emit_message_default(span, message, args, code, level, max_line_num_len, false) {\n+        match self.emit_message_default(\n+            span,\n+            message,\n+            args,\n+            code,\n+            level,\n+            max_line_num_len,\n+            false,\n+            emitted_at,\n+        ) {\n             Ok(()) => {\n                 if !children.is_empty()\n                     || suggestions.iter().any(|s| s.style != SuggestionStyle::CompletelyHidden)\n@@ -2014,6 +2035,7 @@ impl EmitterWriter {\n                             &child.level,\n                             max_line_num_len,\n                             true,\n+                            None,\n                         ) {\n                             panic!(\"failed to emit error: {}\", err);\n                         }\n@@ -2030,6 +2052,7 @@ impl EmitterWriter {\n                                 &Level::Help,\n                                 max_line_num_len,\n                                 true,\n+                                None,\n                             ) {\n                                 panic!(\"failed to emit error: {}\", e);\n                             }\n@@ -2187,22 +2210,45 @@ impl FileWithAnnotatedLines {\n \n         if let Some(ref sm) = emitter.source_map() {\n             for span_label in msp.span_labels() {\n+                let fixup_lo_hi = |span: Span| {\n+                    let lo = sm.lookup_char_pos(span.lo());\n+                    let mut hi = sm.lookup_char_pos(span.hi());\n+\n+                    // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                    // want to just display a `^` at 6, so convert that to\n+                    // 6..7. This is degenerate input, but it's best to degrade\n+                    // gracefully -- and the parser likes to supply a span like\n+                    // that for EOF, in particular.\n+\n+                    if lo.col_display == hi.col_display && lo.line == hi.line {\n+                        hi.col_display += 1;\n+                    }\n+                    (lo, hi)\n+                };\n+\n                 if span_label.span.is_dummy() {\n+                    if let Some(span) = msp.primary_span() {\n+                        // if we don't know where to render the annotation, emit it as a note\n+                        // on the primary span.\n+\n+                        let (lo, hi) = fixup_lo_hi(span);\n+\n+                        let ann = Annotation {\n+                            start_col: lo.col_display,\n+                            end_col: hi.col_display,\n+                            is_primary: span_label.is_primary,\n+                            label: span_label\n+                                .label\n+                                .as_ref()\n+                                .map(|m| emitter.translate_message(m, args).to_string()),\n+                            annotation_type: AnnotationType::Singleline,\n+                        };\n+                        add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                    }\n                     continue;\n                 }\n \n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n+                let (lo, hi) = fixup_lo_hi(span_label.span);\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {"}, {"sha": "c4498eafa4eab1f287cfe1a8699706571f865777", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -45,6 +45,7 @@ pub struct JsonEmitter {\n     json_rendered: HumanReadableErrorType,\n     diagnostic_width: Option<usize>,\n     macro_backtrace: bool,\n+    track_diagnostics: bool,\n }\n \n impl JsonEmitter {\n@@ -57,6 +58,7 @@ impl JsonEmitter {\n         json_rendered: HumanReadableErrorType,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::BufWriter::new(io::stderr())),\n@@ -69,6 +71,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -79,6 +82,7 @@ impl JsonEmitter {\n         fallback_bundle: LazyFallbackBundle,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(\n@@ -90,6 +94,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         )\n     }\n \n@@ -103,6 +108,7 @@ impl JsonEmitter {\n         json_rendered: HumanReadableErrorType,\n         diagnostic_width: Option<usize>,\n         macro_backtrace: bool,\n+        track_diagnostics: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n@@ -115,6 +121,7 @@ impl JsonEmitter {\n             json_rendered,\n             diagnostic_width,\n             macro_backtrace,\n+            track_diagnostics,\n         }\n     }\n \n@@ -350,6 +357,7 @@ impl Diagnostic {\n                 false,\n                 je.diagnostic_width,\n                 je.macro_backtrace,\n+                je.track_diagnostics,\n             )\n             .ui_testing(je.ui_testing)\n             .emit_diagnostic(diag);"}, {"sha": "f131468971b5adbcd66e090b05d21a1f5eb51c55", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -59,6 +59,7 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n             HumanReadableErrorType::Short(ColorConfig::Never),\n             None,\n             false,\n+            false,\n         );\n \n         let span = Span::with_root_ctxt(BytePos(span.0), BytePos(span.1));"}, {"sha": "170d4341ae71b4a3356a12a7c6d03b60d9021f4f", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -376,7 +376,7 @@ pub use diagnostic::{\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n-pub use diagnostic_impls::DiagnosticArgFromDisplay;\n+pub use diagnostic_impls::{DiagnosticArgFromDisplay, DiagnosticSymbolList};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output.\n@@ -492,6 +492,8 @@ pub struct HandlerFlags {\n     pub macro_backtrace: bool,\n     /// If true, identical diagnostics are reported only once.\n     pub deduplicate_diagnostics: bool,\n+    /// Track where errors are created. Enabled with `-Ztrack-diagnostics`.\n+    pub track_diagnostics: bool,\n }\n \n impl Drop for HandlerInner {\n@@ -559,6 +561,7 @@ impl Handler {\n             false,\n             None,\n             flags.macro_backtrace,\n+            flags.track_diagnostics,\n         ));\n         Self::with_emitter_and_flags(emitter, flags)\n     }\n@@ -664,6 +667,7 @@ impl Handler {\n \n     /// Construct a builder with the `msg` at the level appropriate for the specific `EmissionGuarantee`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_diagnostic<G: EmissionGuarantee>(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -677,6 +681,7 @@ impl Handler {\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -693,6 +698,7 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    #[track_caller]\n     pub fn struct_span_warn_with_expectation(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -706,6 +712,7 @@ impl Handler {\n \n     /// Construct a builder at the `Allow` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_allow(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -719,6 +726,7 @@ impl Handler {\n     /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n     /// Also include a code.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -736,6 +744,7 @@ impl Handler {\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Warning(None), msg)\n     }\n@@ -746,6 +755,7 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n+    #[track_caller]\n     pub fn struct_warn_with_expectation(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -756,12 +766,14 @@ impl Handler {\n \n     /// Construct a builder at the `Allow` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Allow, msg)\n     }\n \n     /// Construct a builder at the `Expect` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_expect(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -772,6 +784,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -784,6 +797,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level at the given `span`, with the `msg`, and `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -798,6 +812,7 @@ impl Handler {\n     /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -807,12 +822,14 @@ impl Handler {\n \n     /// This should only be used by `rustc_middle::lint::struct_lint_level`. Do not use it for hard errors.\n     #[doc(hidden)]\n+    #[track_caller]\n     pub fn struct_err_lint(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Error { lint: true }, msg)\n     }\n \n     /// Construct a builder at the `Error` level with the `msg` and the `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_err_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -825,6 +842,7 @@ impl Handler {\n \n     /// Construct a builder at the `Warn` level with the `msg` and the `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_warn_with_code(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -837,6 +855,7 @@ impl Handler {\n \n     /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_fatal(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -849,6 +868,7 @@ impl Handler {\n \n     /// Construct a builder at the `Fatal` level at the given `span`, with the `msg`, and `code`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -862,6 +882,7 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         DiagnosticBuilder::new_fatal(self, msg)\n     }\n@@ -874,6 +895,7 @@ impl Handler {\n \n     /// Construct a builder at the `Note` level with the `msg`.\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_note_without_error(\n         &self,\n         msg: impl Into<DiagnosticMessage>,\n@@ -882,12 +904,14 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError.raise()\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -899,6 +923,7 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -908,6 +933,7 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -921,11 +947,13 @@ impl Handler {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Warning(None), msg), span);\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -954,10 +982,12 @@ impl Handler {\n         self.inner.borrow_mut().delay_good_path_bug(msg)\n     }\n \n+    #[track_caller]\n     pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n \n+    #[track_caller]\n     pub fn span_note_without_error(\n         &self,\n         span: impl Into<MultiSpan>,\n@@ -966,6 +996,7 @@ impl Handler {\n         self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n \n+    #[track_caller]\n     pub fn span_note_diag(\n         &self,\n         span: Span,\n@@ -1223,6 +1254,10 @@ impl HandlerInner {\n         }\n \n         if diagnostic.has_future_breakage() {\n+            // Future breakages aren't emitted if they're Level::Allowed,\n+            // but they still need to be constructed and stashed below,\n+            // so they'll trigger the good-path bug check.\n+            self.suppressed_expected_diag = true;\n             self.future_breakage_diagnostics.push(diagnostic.clone());\n         }\n \n@@ -1452,6 +1487,7 @@ impl HandlerInner {\n         }\n     }\n \n+    #[track_caller]\n     fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic::panic_any(ExplicitBug);"}, {"sha": "a452fac074787348a0bf5666d5b7b55cfa00421f", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,10 @@\n use crate::snippet::Style;\n use crate::{DiagnosticArg, DiagnosticMessage, FluentBundle};\n use rustc_data_structures::sync::Lrc;\n-use rustc_error_messages::FluentArgs;\n+use rustc_error_messages::{\n+    fluent_bundle::resolver::errors::{ReferenceKind, ResolverError},\n+    FluentArgs, FluentError,\n+};\n use std::borrow::Cow;\n \n /// Convert diagnostic arguments (a rustc internal type that exists to implement\n@@ -102,14 +105,31 @@ pub trait Translate {\n             .or_else(|| translate_with_bundle(self.fallback_fluent_bundle()))\n             .map(|(translated, errs)| {\n                 // Always bail out for errors with the fallback bundle.\n-                assert!(\n-                    errs.is_empty(),\n-                    \"identifier: {:?}, attr: {:?}, args: {:?}, errors: {:?}\",\n-                    identifier,\n-                    attr,\n-                    args,\n-                    errs\n-                );\n+\n+                let mut help_messages = vec![];\n+\n+                if !errs.is_empty() {\n+                    for error in &errs {\n+                        match error {\n+                            FluentError::ResolverError(ResolverError::Reference(\n+                                ReferenceKind::Message { id, .. },\n+                            )) if args.iter().any(|(arg_id, _)| arg_id == id) => {\n+                                help_messages.push(format!(\"Argument `{id}` exists but was not referenced correctly. Try using `{{${id}}}` instead\"));\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+\n+                    panic!(\n+                        \"Encountered errors while formatting message for `{identifier}`\\n\\\n+                        help: {}\\n\\\n+                        attr: `{attr:?}`\\n\\\n+                        args: `{args:?}`\\n\\\n+                        errors: `{errs:?}`\",\n+                        help_messages.join(\"\\nhelp: \")\n+                    );\n+                }\n+\n                 translated\n             })\n             .expect(\"failed to find message in primary or fallback fluent bundles\")"}, {"sha": "1294f1e17d412a7469cf564760f1df89a2f68583", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -22,7 +22,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, FileName, Span, DUMMY_SP};\n+use rustc_span::{BytePos, FileName, RealFileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n use std::default::Default;\n@@ -250,6 +250,7 @@ pub trait MultiItemModifier {\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable>;\n }\n \n@@ -263,6 +264,7 @@ where\n         span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         ExpandResult::Ready(self(ecx, span, meta_item, item))\n     }\n@@ -873,7 +875,7 @@ impl SyntaxExtension {\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n-pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>)>;\n+pub type DeriveResolutions = Vec<(ast::Path, Annotatable, Option<Lrc<SyntaxExtension>>, bool)>;\n \n pub trait ResolverExpand {\n     fn next_node_id(&mut self) -> NodeId;\n@@ -1423,16 +1425,40 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n         if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n             if let [variant] = &*enum_def.variants {\n                 if variant.ident.name == sym::Input {\n-                    sess.buffer_lint_with_diagnostic(\n-                        &PROC_MACRO_BACK_COMPAT,\n-                        item.ident.span,\n-                        ast::CRATE_NODE_ID,\n-                        \"using `procedural-masquerade` crate\",\n-                        BuiltinLintDiagnostics::ProcMacroBackCompat(\n-                        \"The `procedural-masquerade` crate has been unnecessary since Rust 1.30.0. \\\n-                        Versions of this crate below 0.1.7 will eventually stop compiling.\".to_string())\n-                    );\n-                    return true;\n+                    let filename = sess.source_map().span_to_filename(item.ident.span);\n+                    if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n+                        if let Some(c) = path\n+                            .components()\n+                            .flat_map(|c| c.as_os_str().to_str())\n+                            .find(|c| c.starts_with(\"rental\") || c.starts_with(\"allsorts-rental\"))\n+                        {\n+                            let crate_matches = if c.starts_with(\"allsorts-rental\") {\n+                                true\n+                            } else {\n+                                let mut version = c.trim_start_matches(\"rental-\").split(\".\");\n+                                version.next() == Some(\"0\")\n+                                    && version.next() == Some(\"5\")\n+                                    && version\n+                                        .next()\n+                                        .and_then(|c| c.parse::<u32>().ok())\n+                                        .map_or(false, |v| v < 6)\n+                            };\n+\n+                            if crate_matches {\n+                                sess.buffer_lint_with_diagnostic(\n+                                        &PROC_MACRO_BACK_COMPAT,\n+                                        item.ident.span,\n+                                        ast::CRATE_NODE_ID,\n+                                        \"using an old version of `rental`\",\n+                                        BuiltinLintDiagnostics::ProcMacroBackCompat(\n+                                        \"older versions of the `rental` crate will stop compiling in future versions of Rust; \\\n+                                        please update to `rental` v0.5.6, or switch to one of the `rental` alternatives\".to_string()\n+                                        )\n+                                    );\n+                                return true;\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "1d2b1298a68f6372dca41d0bf71b0241636eda44", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -469,6 +469,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n+    #[instrument(level = \"trace\", skip(self))]\n     pub(crate) fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n@@ -486,9 +487,12 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_expr(&self, expr: &mut P<ast::Expr>) {\n-        for attr in expr.attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n+    #[instrument(level = \"trace\", skip(self))]\n+    pub fn configure_expr(&self, expr: &mut P<ast::Expr>, method_receiver: bool) {\n+        if !method_receiver {\n+            for attr in expr.attrs.iter() {\n+                self.maybe_emit_expr_attr_err(attr);\n+            }\n         }\n \n         // If an expr is valid to cfg away it will have been removed by the"}, {"sha": "3d37e2c6568518cf5a5615a350c4a22241e175ac", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -50,20 +50,23 @@ macro_rules! ast_fragments {\n         /// Can also serve as an input and intermediate result for macro expansion operations.\n         pub enum AstFragment {\n             OptExpr(Option<P<ast::Expr>>),\n+            MethodReceiverExpr(P<ast::Expr>),\n             $($Kind($AstTy),)*\n         }\n \n         /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum AstFragmentKind {\n             OptExpr,\n+            MethodReceiverExpr,\n             $($Kind,)*\n         }\n \n         impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n                     AstFragmentKind::OptExpr => \"expression\",\n+                    AstFragmentKind::MethodReceiverExpr => \"expression\",\n                     $(AstFragmentKind::$Kind => $kind_name,)*\n                 }\n             }\n@@ -72,6 +75,8 @@ macro_rules! ast_fragments {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),\n+                    AstFragmentKind::MethodReceiverExpr =>\n+                        result.make_expr().map(AstFragment::MethodReceiverExpr),\n                     $(AstFragmentKind::$Kind => result.$make_ast().map(AstFragment::$Kind),)*\n                 }\n             }\n@@ -98,6 +103,13 @@ macro_rules! ast_fragments {\n                 }\n             }\n \n+            pub fn make_method_receiver_expr(self) -> P<ast::Expr> {\n+                match self {\n+                    AstFragment::MethodReceiverExpr(expr) => expr,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n+                }\n+            }\n+\n             $(pub fn $make_ast(self) -> $AstTy {\n                 match self {\n                     AstFragment::$Kind(ast) => ast,\n@@ -120,6 +132,7 @@ macro_rules! ast_fragments {\n                             }\n                         });\n                     }\n+                    AstFragment::MethodReceiverExpr(expr) => vis.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ast) => vis.$mut_visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ast) =>\n                         ast.flat_map_in_place(|ast| vis.$flat_map_ast_elt(ast)),)?)*\n@@ -130,6 +143,7 @@ macro_rules! ast_fragments {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n+                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n@@ -222,6 +236,7 @@ impl AstFragmentKind {\n         match self {\n             AstFragmentKind::OptExpr\n             | AstFragmentKind::Expr\n+            | AstFragmentKind::MethodReceiverExpr\n             | AstFragmentKind::Stmts\n             | AstFragmentKind::Ty\n             | AstFragmentKind::Pat => SupportsMacroExpansion::Yes { supports_inner_attrs: false },\n@@ -285,6 +300,9 @@ impl AstFragmentKind {\n             AstFragmentKind::Expr => AstFragment::Expr(\n                 items.next().expect(\"expected exactly one expression\").expect_expr(),\n             ),\n+            AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr(),\n+            ),\n             AstFragmentKind::OptExpr => {\n                 AstFragment::OptExpr(items.next().map(Annotatable::expect_expr))\n             }\n@@ -319,6 +337,7 @@ pub enum InvocationKind {\n     },\n     Derive {\n         path: ast::Path,\n+        is_const: bool,\n         item: Annotatable,\n     },\n }\n@@ -460,13 +479,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             derive_invocations.reserve(derives.len());\n                             derives\n                                 .into_iter()\n-                                .map(|(path, item, _exts)| {\n+                                .map(|(path, item, _exts, is_const)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n                                     let expn_id = LocalExpnId::fresh_empty();\n                                     derive_invocations.push((\n                                         Invocation {\n-                                            kind: InvocationKind::Derive { path, item },\n+                                            kind: InvocationKind::Derive { path, item, is_const },\n                                             fragment_kind,\n                                             expansion_data: ExpansionData {\n                                                 id: expn_id,\n@@ -699,7 +718,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n                     match validate_attr::parse_meta(&self.cx.sess.parse_sess, &attr) {\n                         Ok(meta) => {\n-                            let items = match expander.expand(self.cx, span, &meta, item) {\n+                            let items = match expander.expand(self.cx, span, &meta, item, false) {\n                                 ExpandResult::Ready(items) => items,\n                                 ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n@@ -731,19 +750,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!(),\n             },\n-            InvocationKind::Derive { path, item } => match ext {\n+            InvocationKind::Derive { path, item, is_const } => match ext {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: MetaItemKind::Word, span, path };\n-                    let items = match expander.expand(self.cx, span, &meta, item) {\n+                    let items = match expander.expand(self.cx, span, &meta, item, is_const) {\n                         ExpandResult::Ready(items) => items,\n                         ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n                             return ExpandResult::Retry(Invocation {\n-                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                kind: InvocationKind::Derive { path: meta.path, item, is_const },\n                                 ..invoc\n                             });\n                         }\n@@ -893,6 +912,7 @@ pub fn parse_ast_fragment<'a>(\n             AstFragment::Stmts(stmts)\n         }\n         AstFragmentKind::Expr => AstFragment::Expr(this.parse_expr()?),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(this.parse_expr()?),\n         AstFragmentKind::OptExpr => {\n             if this.token != token::Eof {\n                 AstFragment::OptExpr(Some(this.parse_expr()?))\n@@ -1477,6 +1497,42 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, OptExprTag> {\n     }\n }\n \n+/// This struct is a hack to workaround unstable of `stmt_expr_attributes`.\n+/// It can be removed once that feature is stabilized.\n+struct MethodReceiverTag;\n+impl DummyAstNode for MethodReceiverTag {\n+    fn dummy() -> MethodReceiverTag {\n+        MethodReceiverTag\n+    }\n+}\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, MethodReceiverTag> {\n+    type OutputTy = Self;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::MethodReceiverExpr;\n+    fn descr() -> &'static str {\n+        \"an expression\"\n+    }\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        AstNodeWrapper::new(fragment.make_method_receiver_expr(), MethodReceiverTag)\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(&mut self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     invocations: Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>,\n@@ -1840,6 +1896,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.visit_node(node)\n     }\n \n+    fn visit_method_receiver_expr(&mut self, node: &mut P<ast::Expr>) {\n+        visit_clobber(node, |node| {\n+            let mut wrapper = AstNodeWrapper::new(node, MethodReceiverTag);\n+            self.visit_node(&mut wrapper);\n+            wrapper.wrapped\n+        })\n+    }\n+\n     fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         self.flat_map_node(AstNodeWrapper::new(node, OptExprTag))\n     }"}, {"sha": "63bafd7b046fb173275548d333b098ddfd4ab06a", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -52,7 +52,7 @@ impl KleeneToken {\n /// A Kleene-style [repetition operator](https://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n-enum KleeneOp {\n+pub(crate) enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n     /// Kleene plus (`+`) for one or more repetitions"}, {"sha": "d161868edce778677f02f7526acb6addf0069bb8", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 78, "deletions": 21, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -73,19 +73,21 @@\n pub(crate) use NamedMatch::*;\n pub(crate) use ParseResult::*;\n \n-use crate::mbe::{KleeneOp, TokenTree};\n+use crate::mbe::{macro_rules::Tracker, KleeneOp, TokenTree};\n \n use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n+use rustc_ast_pretty::pprust;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_lint_defs::pluralize;\n use rustc_parse::parser::{NtOrTt, Parser};\n+use rustc_span::symbol::Ident;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::fmt::Display;\n \n /// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)\n /// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.\n@@ -96,7 +98,8 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n ///\n /// This means a matcher can be represented by `&[MatcherLoc]`, and traversal mostly involves\n /// simply incrementing the current matcher position index by one.\n-pub(super) enum MatcherLoc {\n+#[derive(Debug, PartialEq, Clone)]\n+pub(crate) enum MatcherLoc {\n     Token {\n         token: Token,\n     },\n@@ -128,6 +131,46 @@ pub(super) enum MatcherLoc {\n     Eof,\n }\n \n+impl MatcherLoc {\n+    pub(super) fn span(&self) -> Option<Span> {\n+        match self {\n+            MatcherLoc::Token { token } => Some(token.span),\n+            MatcherLoc::Delimited => None,\n+            MatcherLoc::Sequence { .. } => None,\n+            MatcherLoc::SequenceKleeneOpNoSep { .. } => None,\n+            MatcherLoc::SequenceSep { .. } => None,\n+            MatcherLoc::SequenceKleeneOpAfterSep { .. } => None,\n+            MatcherLoc::MetaVarDecl { span, .. } => Some(*span),\n+            MatcherLoc::Eof => None,\n+        }\n+    }\n+}\n+\n+impl Display for MatcherLoc {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            MatcherLoc::Token { token } | MatcherLoc::SequenceSep { separator: token } => {\n+                write!(f, \"`{}`\", pprust::token_to_string(token))\n+            }\n+            MatcherLoc::MetaVarDecl { bind, kind, .. } => {\n+                write!(f, \"meta-variable `${bind}\")?;\n+                if let Some(kind) = kind {\n+                    write!(f, \":{}\", kind)?;\n+                }\n+                write!(f, \"`\")?;\n+                Ok(())\n+            }\n+            MatcherLoc::Eof => f.write_str(\"end of macro\"),\n+\n+            // These are not printed in the diagnostic\n+            MatcherLoc::Delimited => f.write_str(\"delimiter\"),\n+            MatcherLoc::Sequence { .. } => f.write_str(\"sequence start\"),\n+            MatcherLoc::SequenceKleeneOpNoSep { .. } => f.write_str(\"sequence end\"),\n+            MatcherLoc::SequenceKleeneOpAfterSep { .. } => f.write_str(\"sequence end\"),\n+        }\n+    }\n+}\n+\n pub(super) fn compute_locs(matcher: &[TokenTree]) -> Vec<MatcherLoc> {\n     fn inner(\n         tts: &[TokenTree],\n@@ -270,13 +313,17 @@ pub(crate) enum ParseResult<T> {\n     Failure(Token, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n-    ErrorReported,\n+    ErrorReported(ErrorGuaranteed),\n }\n \n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-pub(crate) type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n+pub(crate) type NamedParseResult = ParseResult<NamedMatches>;\n+\n+/// Contains a mapping of `MacroRulesNormalizedIdent`s to `NamedMatch`es.\n+/// This represents the mapping of metavars to the token trees they bind to.\n+pub(crate) type NamedMatches = FxHashMap<MacroRulesNormalizedIdent, NamedMatch>;\n \n /// Count how many metavars declarations are in `matcher`.\n pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n@@ -393,24 +440,32 @@ impl TtParser {\n         }\n     }\n \n+    pub(super) fn has_no_remaining_items_for_step(&self) -> bool {\n+        self.cur_mps.is_empty()\n+    }\n+\n     /// Process the matcher positions of `cur_mps` until it is empty. In the process, this will\n     /// produce more mps in `next_mps` and `bb_mps`.\n     ///\n     /// # Returns\n     ///\n     /// `Some(result)` if everything is finished, `None` otherwise. Note that matches are kept\n     /// track of through the mps generated.\n-    fn parse_tt_inner(\n+    fn parse_tt_inner<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n         // modified if `token == Eof`.\n         let mut eof_mps = EofMatcherPositions::None;\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n-            match &matcher[mp.idx] {\n+            let matcher_loc = &matcher[mp.idx];\n+            track.before_match_loc(self, matcher_loc);\n+\n+            match matcher_loc {\n                 MatcherLoc::Token { token: t } => {\n                     // If it's a doc comment, we just ignore it and move on to the next tt in the\n                     // matcher. This is a bug, but #95267 showed that existing programs rely on\n@@ -450,7 +505,7 @@ impl TtParser {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,\n-                            matches: mp.matches.clone(), // a cheap clone\n+                            matches: Lrc::clone(&mp.matches),\n                         });\n                     }\n \n@@ -463,8 +518,8 @@ impl TtParser {\n                     // sequence. If that's not possible, `ending_mp` will fail quietly when it is\n                     // processed next time around the loop.\n                     let ending_mp = MatcherPos {\n-                        idx: mp.idx + 1,             // +1 skips the Kleene op\n-                        matches: mp.matches.clone(), // a cheap clone\n+                        idx: mp.idx + 1, // +1 skips the Kleene op\n+                        matches: Lrc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -479,8 +534,8 @@ impl TtParser {\n                     // separator yet. Try ending the sequence. If that's not possible, `ending_mp`\n                     // will fail quietly when it is processed next time around the loop.\n                     let ending_mp = MatcherPos {\n-                        idx: mp.idx + 2,             // +2 skips the separator and the Kleene op\n-                        matches: mp.matches.clone(), // a cheap clone\n+                        idx: mp.idx + 2, // +2 skips the separator and the Kleene op\n+                        matches: Lrc::clone(&mp.matches),\n                     };\n                     self.cur_mps.push(ending_mp);\n \n@@ -552,10 +607,11 @@ impl TtParser {\n     }\n \n     /// Match the token stream from `parser` against `matcher`.\n-    pub(super) fn parse_tt(\n+    pub(super) fn parse_tt<'matcher, T: Tracker<'matcher>>(\n         &mut self,\n         parser: &mut Cow<'_, Parser<'_>>,\n-        matcher: &[MatcherLoc],\n+        matcher: &'matcher [MatcherLoc],\n+        track: &mut T,\n     ) -> NamedParseResult {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `matcher`.\n@@ -571,7 +627,8 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            if let Some(res) = self.parse_tt_inner(matcher, &parser.token) {\n+            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            if let Some(res) = res {\n                 return res;\n             }\n \n@@ -612,14 +669,14 @@ impl TtParser {\n                         // edition-specific matching behavior for non-terminals.\n                         let nt = match parser.to_mut().parse_nonterminal(kind) {\n                             Err(mut err) => {\n-                                err.span_label(\n+                                let guarantee = err.span_label(\n                                     span,\n                                     format!(\n                                         \"while parsing argument for this `{kind}` macro fragment\"\n                                     ),\n                                 )\n                                 .emit();\n-                                return ErrorReported;\n+                                return ErrorReported(guarantee);\n                             }\n                             Ok(nt) => nt,\n                         };"}, {"sha": "182fbe36919d479c3e7b4070590a6f1369012941", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 276, "deletions": 121, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -14,7 +14,9 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n+};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -33,6 +35,8 @@ use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n+use super::macro_parser::{NamedMatches, NamedParseResult};\n+\n pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -205,8 +209,32 @@ fn trace_macros_note(cx_expansions: &mut FxIndexMap<Span, Vec<String>>, sp: Span\n     cx_expansions.entry(sp).or_default().push(message);\n }\n \n+pub(super) trait Tracker<'matcher> {\n+    /// This is called before trying to match next MatcherLoc on the current token.\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc);\n+\n+    /// This is called after an arm has been parsed, either successfully or unsuccessfully. When this is called,\n+    /// `before_match_loc` was called at least once (with a `MatcherLoc::Eof`).\n+    fn after_arm(&mut self, result: &NamedParseResult);\n+\n+    /// For tracing.\n+    fn description() -> &'static str;\n+}\n+\n+/// A noop tracker that is used in the hot path of the expansion, has zero overhead thanks to monomorphization.\n+struct NoopTracker;\n+\n+impl<'matcher> Tracker<'matcher> for NoopTracker {\n+    fn before_match_loc(&mut self, _: &TtParser, _: &'matcher MatcherLoc) {}\n+    fn after_arm(&mut self, _: &NamedParseResult) {}\n+    fn description() -> &'static str {\n+        \"none\"\n+    }\n+}\n+\n /// Expands the rules based macro defined by `lhses` and `rhses` for a given\n /// input `arg`.\n+#[instrument(skip(cx, transparency, arg, lhses, rhses))]\n fn expand_macro<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n@@ -228,9 +256,207 @@ fn expand_macro<'cx>(\n         trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n-    // Which arm's failure should we report? (the one furthest along)\n-    let mut best_failure: Option<(Token, &str)> = None;\n+    // Track nothing for the best performance.\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut NoopTracker);\n+\n+    match try_success_result {\n+        Ok((i, named_matches)) => {\n+            let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n+                mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n+                _ => cx.span_bug(sp, \"malformed macro rhs\"),\n+            };\n+            let arm_span = rhses[i].span();\n+\n+            let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n+            // rhs has holes ( `$id` and `$(...)` that need filled)\n+            let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n+                Ok(tts) => tts,\n+                Err(mut err) => {\n+                    err.emit();\n+                    return DummyResult::any(arm_span);\n+                }\n+            };\n+\n+            // Replace all the tokens for the corresponding positions in the macro, to maintain\n+            // proper positions in error reporting, while maintaining the macro_backtrace.\n+            if rhs_spans.len() == tts.len() {\n+                tts = tts.map_enumerated(|i, tt| {\n+                    let mut tt = tt.clone();\n+                    let mut sp = rhs_spans[i];\n+                    sp = sp.with_ctxt(tt.span().ctxt());\n+                    tt.set_span(sp);\n+                    tt\n+                });\n+            }\n+\n+            if cx.trace_macros() {\n+                let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n+                trace_macros_note(&mut cx.expansions, sp, msg);\n+            }\n+\n+            let mut p = Parser::new(sess, tts, false, None);\n+            p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+\n+            if is_local {\n+                cx.resolver.record_macro_rule_usage(node_id, i);\n+            }\n+\n+            // Let the context choose how to interpret the result.\n+            // Weird, but useful for X-macros.\n+            return Box::new(ParserAnyMacro {\n+                parser: p,\n+\n+                // Pass along the original expansion site and the name of the macro\n+                // so we can print a useful error message if the parse of the expanded\n+                // macro leaves unparsed tokens.\n+                site_span: sp,\n+                macro_ident: name,\n+                lint_node_id: cx.current_expansion.lint_node_id,\n+                is_trailing_mac: cx.current_expansion.is_trailing_mac,\n+                arm_span,\n+                is_local,\n+            });\n+        }\n+        Err(CanRetry::No(_)) => {\n+            debug!(\"Will not retry matching as an error was emitted already\");\n+            return DummyResult::any(sp);\n+        }\n+        Err(CanRetry::Yes) => {\n+            // Retry and emit a better error below.\n+        }\n+    }\n+\n+    // An error occurred, try the expansion again, tracking the expansion closely for better diagnostics.\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+    assert!(try_success_result.is_err(), \"Macro matching returned a success on the second try\");\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occurred and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+        return tracker.result.expect(\"must have encountered Error or ErrorReported\");\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n+    }\n+\n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    if let Some(span) = remaining_matcher.span() {\n+        err.span_note(span, format!(\"while trying to match {remaining_matcher}\"));\n+    } else {\n+        err.note(format!(\"while trying to match {remaining_matcher}\"));\n+    }\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone());\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n+    DummyResult::any(sp)\n+}\n+\n+/// The tracker used for the slow error path that collects useful info for diagnostics.\n+struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    remaining_matcher: Option<&'matcher MatcherLoc>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n+    fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n+        if self.remaining_matcher.is_none()\n+            || (parser.has_no_remaining_items_for_step() && *matcher != MatcherLoc::Eof)\n+        {\n+            self.remaining_matcher = Some(matcher);\n+        }\n+    }\n \n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                unreachable!(\"should not collect detailed info for successful macro match\");\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => {\n+                    self.best_failure = Some((\n+                        token.clone(),\n+                        msg,\n+                        self.remaining_matcher\n+                            .expect(\"must have collected matcher already\")\n+                            .clone(),\n+                    ))\n+                }\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx, '_> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, remaining_matcher: None, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+enum CanRetry {\n+    Yes,\n+    /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n+    No(ErrorGuaranteed),\n+}\n+\n+/// Try expanding the macro. Returns the index of the successful arm and its named_matches if it was successful,\n+/// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n+/// correctly.\n+#[instrument(level = \"debug\", skip(sess, arg, lhses, track), fields(tracking = %T::description()))]\n+fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n+    sess: &ParseSess,\n+    name: Ident,\n+    arg: &TokenStream,\n+    lhses: &'matcher [Vec<MatcherLoc>],\n+    track: &mut T,\n+) -> Result<(usize, NamedMatches), CanRetry> {\n     // We create a base parser that can be used for the \"black box\" parts.\n     // Every iteration needs a fresh copy of that parser. However, the parser\n     // is not mutated on many of the iterations, particularly when dealing with\n@@ -250,126 +476,54 @@ fn expand_macro<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n+    // FIXME(Nilstrieb): Stop recovery from happening on this parser and retry later with recovery if the macro failed to match.\n     let parser = parser_from_cx(sess, arg.clone());\n-\n     // Try each arm's matchers.\n     let mut tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n+        let _tracing_span = trace_span!(\"Matching arm\", %i);\n+\n         // Take a snapshot of the state of pre-expansion gating at this point.\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n+        let result = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, track);\n+\n+        track.after_arm(&result);\n+\n+        match result {\n             Success(named_matches) => {\n+                debug!(\"Parsed arm successfully\");\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n-                let (rhs, rhs_span): (&mbe::Delimited, DelimSpan) = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(span, delimited) => (&delimited, *span),\n-                    _ => cx.span_bug(sp, \"malformed macro rhs\"),\n-                };\n-                let arm_span = rhses[i].span();\n-\n-                let rhs_spans = rhs.tts.iter().map(|t| t.span()).collect::<Vec<_>>();\n-                // rhs has holes ( `$id` and `$(...)` that need filled)\n-                let mut tts = match transcribe(cx, &named_matches, &rhs, rhs_span, transparency) {\n-                    Ok(tts) => tts,\n-                    Err(mut err) => {\n-                        err.emit();\n-                        return DummyResult::any(arm_span);\n-                    }\n-                };\n-\n-                // Replace all the tokens for the corresponding positions in the macro, to maintain\n-                // proper positions in error reporting, while maintaining the macro_backtrace.\n-                if rhs_spans.len() == tts.len() {\n-                    tts = tts.map_enumerated(|i, tt| {\n-                        let mut tt = tt.clone();\n-                        let mut sp = rhs_spans[i];\n-                        sp = sp.with_ctxt(tt.span().ctxt());\n-                        tt.set_span(sp);\n-                        tt\n-                    });\n-                }\n-\n-                if cx.trace_macros() {\n-                    let msg = format!(\"to `{}`\", pprust::tts_to_string(&tts));\n-                    trace_macros_note(&mut cx.expansions, sp, msg);\n-                }\n-\n-                let mut p = Parser::new(sess, tts, false, None);\n-                p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n-\n-                if is_local {\n-                    cx.resolver.record_macro_rule_usage(node_id, i);\n-                }\n-\n-                // Let the context choose how to interpret the result.\n-                // Weird, but useful for X-macros.\n-                return Box::new(ParserAnyMacro {\n-                    parser: p,\n-\n-                    // Pass along the original expansion site and the name of the macro\n-                    // so we can print a useful error message if the parse of the expanded\n-                    // macro leaves unparsed tokens.\n-                    site_span: sp,\n-                    macro_ident: name,\n-                    lint_node_id: cx.current_expansion.lint_node_id,\n-                    is_trailing_mac: cx.current_expansion.is_trailing_mac,\n-                    arm_span,\n-                    is_local,\n-                });\n+                return Ok((i, named_matches));\n             }\n-            Failure(token, msg) => match best_failure {\n-                Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => best_failure = Some((token, msg)),\n-            },\n-            Error(err_sp, ref msg) => {\n-                let span = err_sp.substitute_dummy(sp);\n-                cx.struct_span_err(span, &msg).emit();\n-                return DummyResult::any(span);\n+            Failure(_, _) => {\n+                trace!(\"Failed to match arm, trying the next one\");\n+                // Try the next arm.\n+            }\n+            Error(_, _) => {\n+                debug!(\"Fatal error occurred during matching\");\n+                // We haven't emitted an error yet, so we can retry.\n+                return Err(CanRetry::Yes);\n+            }\n+            ErrorReported(guarantee) => {\n+                debug!(\"Fatal error occurred and was reported during matching\");\n+                // An error has been reported already, we cannot retry as that would cause duplicate errors.\n+                return Err(CanRetry::No(guarantee));\n             }\n-            ErrorReported => return DummyResult::any(sp),\n         }\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n-    drop(parser);\n \n-    let (token, label) = best_failure.expect(\"ran no matchers\");\n-    let span = token.span.substitute_dummy(sp);\n-    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n-    err.span_label(span, label);\n-    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n-        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n-    }\n-    annotate_doc_comment(&mut err, sess.source_map(), span);\n-    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n-    if let Some((arg, comma_span)) = arg.add_comma() {\n-        for lhs in lhses {\n-            let parser = parser_from_cx(sess, arg.clone());\n-            if let Success(_) = tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs) {\n-                if comma_span.is_dummy() {\n-                    err.note(\"you might be missing a comma\");\n-                } else {\n-                    err.span_suggestion_short(\n-                        comma_span,\n-                        \"missing comma here\",\n-                        \", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-    err.emit();\n-    cx.trace_macros_diag();\n-    DummyResult::any(sp)\n+    Err(CanRetry::Yes)\n }\n \n // Note that macro-by-example's input is also matched against a token tree:\n@@ -451,28 +605,29 @@ pub fn compile_declarative_macro(\n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n-    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n-        Success(m) => m,\n-        Failure(token, msg) => {\n-            let s = parse_failure_msg(&token);\n-            let sp = token.span.substitute_dummy(def.span);\n-            let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n-            err.span_label(sp, msg);\n-            annotate_doc_comment(&mut err, sess.source_map(), sp);\n-            err.emit();\n-            return dummy_syn_ext();\n-        }\n-        Error(sp, msg) => {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n-                .emit();\n-            return dummy_syn_ext();\n-        }\n-        ErrorReported => {\n-            return dummy_syn_ext();\n-        }\n-    };\n+    let argument_map =\n+        match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n+            Success(m) => m,\n+            Failure(token, msg) => {\n+                let s = parse_failure_msg(&token);\n+                let sp = token.span.substitute_dummy(def.span);\n+                let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);\n+                err.span_label(sp, msg);\n+                annotate_doc_comment(&mut err, sess.source_map(), sp);\n+                err.emit();\n+                return dummy_syn_ext();\n+            }\n+            Error(sp, msg) => {\n+                sess.parse_sess\n+                    .span_diagnostic\n+                    .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                    .emit();\n+                return dummy_syn_ext();\n+            }\n+            ErrorReported(_) => {\n+                return dummy_syn_ext();\n+            }\n+        };\n \n     let mut valid = true;\n "}, {"sha": "faaf3b3fea58916ae2740546351fcfbc1cb0301a", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -55,6 +55,7 @@ pub fn placeholder(\n         }),\n         AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(expr_placeholder()),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n             id,\n             span,\n@@ -296,6 +297,13 @@ impl MutVisitor for PlaceholderExpander {\n         }\n     }\n \n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        match expr.kind {\n+            ast::ExprKind::MacCall(_) => *expr = self.remove(expr.id).make_method_receiver_expr(),\n+            _ => noop_visit_expr(expr, self),\n+        }\n+    }\n+\n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         match expr.kind {\n             ast::ExprKind::MacCall(_) => self.remove(expr.id).make_opt_expr(),"}, {"sha": "e9a69192068941167386c97429d4ec96bbd217b1", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -112,6 +112,7 @@ impl MultiItemModifier for DeriveProcMacro {\n         span: Span,\n         _meta_item: &ast::MetaItem,\n         item: Annotatable,\n+        _is_derive_const: bool,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // We need special handling for statement items\n         // (e.g. `fn foo() { #[derive(Debug)] struct Bar; }`)"}, {"sha": "a929f6cb0a5df6d6db89b433c8f133412711e260", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -525,6 +525,13 @@ impl server::TokenStream for Rustc<'_, '_> {\n             ast::ExprKind::Lit(l) => {\n                 Ok(tokenstream::TokenStream::token_alone(token::Literal(l.token_lit), l.span))\n             }\n+            ast::ExprKind::IncludedBytes(bytes) => {\n+                let lit = ast::Lit::from_included_bytes(bytes, expr.span);\n+                Ok(tokenstream::TokenStream::token_alone(\n+                    token::TokenKind::Literal(lit.token_lit),\n+                    expr.span,\n+                ))\n+            }\n             ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n                 ast::ExprKind::Lit(l) => match l.token_lit {\n                     token::Lit { kind: token::Integer | token::Float, .. } => {"}, {"sha": "d82a7a54030c668a3c55bfaaef739b56ce59f509", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -151,6 +151,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n             false,\n             None,\n             false,\n+            false,\n         );\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n         handler.span_err(msp, \"foo\");"}, {"sha": "1646727a1c85f9b72f14f01596b72d8a42929184", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -53,8 +53,10 @@ declare_features! (\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n     /// Allows using ADX intrinsics from `core::arch::{x86, x86_64}`.\n     (accepted, adx_target_feature, \"1.61.0\", Some(44839), None),\n+    /// Allows explicit discriminants on non-unit enum variants.\n+    (accepted, arbitrary_enum_discriminant, \"1.66.0\", Some(60553), None),\n     /// Allows using `sym` operands in inline assembly.\n-    (accepted, asm_sym, \"CURRENT_RUSTC_VERSION\", Some(93333), None),\n+    (accepted, asm_sym, \"1.66.0\", Some(93333), None),\n     /// Allows the definition of associated constants in `trait` or `impl` blocks.\n     (accepted, associated_consts, \"1.20.0\", Some(29646), None),\n     /// Allows using associated `type`s in `trait`s.\n@@ -172,7 +174,7 @@ declare_features! (\n     // FIXME: explain `globs`.\n     (accepted, globs, \"1.0.0\", None, None),\n     /// Allows using `..=X` as a pattern.\n-    (accepted, half_open_range_patterns, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n+    (accepted, half_open_range_patterns, \"1.66.0\", Some(67264), None),\n     /// Allows using the `u128` and `i128` types.\n     (accepted, i128_type, \"1.26.0\", Some(35118), None),\n     /// Allows the use of `if let` expressions.\n@@ -189,6 +191,8 @@ declare_features! (\n     (accepted, infer_outlives_requirements, \"1.30.0\", Some(44493), None),\n     /// Allows irrefutable patterns in `if let` and `while let` statements (RFC 2086).\n     (accepted, irrefutable_let_patterns, \"1.33.0\", Some(44495), None),\n+    /// Allows `#[instruction_set(_)]` attribute.\n+    (accepted, isa_attribute, \"CURRENT_RUSTC_VERSION\", Some(74727), None),\n     /// Allows some increased flexibility in the name resolution rules,\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),"}, {"sha": "5cf2fdde392547979af15534f35bf10917cd814f", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -152,6 +152,8 @@ declare_features! (\n     (active, anonymous_lifetime_in_impl_trait, \"1.63.0\", None, None),\n     /// Allows identifying the `compiler_builtins` crate.\n     (active, compiler_builtins, \"1.13.0\", None, None),\n+    /// Allows writing custom MIR\n+    (active, custom_mir, \"1.65.0\", None, None),\n     /// Outputs useful `assert!` messages\n     (active, generic_assert, \"1.63.0\", None, None),\n     /// Allows using the `rust-intrinsic`'s \"ABI\".\n@@ -292,8 +294,6 @@ declare_features! (\n     (incomplete, adt_const_params, \"1.56.0\", Some(95174), None),\n     /// Allows defining an `#[alloc_error_handler]`.\n     (active, alloc_error_handler, \"1.29.0\", Some(51540), None),\n-    /// Allows explicit discriminants on non-unit enum variants.\n-    (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n     /// Allows trait methods with arbitrary self types.\n     (active, arbitrary_self_types, \"1.23.0\", Some(44874), None),\n     /// Allows using `const` operands in inline assembly.\n@@ -311,7 +311,7 @@ declare_features! (\n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n     /// Alows async functions to be declared, implemented, and used in traits.\n-    (incomplete, async_fn_in_trait, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n+    (incomplete, async_fn_in_trait, \"1.66.0\", Some(91611), None),\n     /// Allows `extern \"C-unwind\" fn` to enable unwinding across ABI boundaries.\n     (active, c_unwind, \"1.52.0\", Some(74990), None),\n     /// Allows using C-variadics.\n@@ -390,6 +390,9 @@ declare_features! (\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n     (active, exhaustive_patterns, \"1.13.0\", Some(51085), None),\n+    /// Allows using `efiapi`, `sysv64` and `win64` as calling convention\n+    /// for functions with varargs.\n+    (active, extended_varargs_abi_support, \"1.65.0\", Some(100189), None),\n     /// Allows defining `extern type`s.\n     (active, extern_types, \"1.23.0\", Some(43467), None),\n     /// Allows the use of `#[ffi_const]` on foreign functions.\n@@ -411,9 +414,11 @@ declare_features! (\n     /// Allows non-trivial generic constants which have to have wfness manually propagated to callers\n     (incomplete, generic_const_exprs, \"1.56.0\", Some(76560), None),\n     /// Allows using `..=X` as a patterns in slices.\n-    (active, half_open_range_patterns_in_slices, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n+    (active, half_open_range_patterns_in_slices, \"1.66.0\", Some(67264), None),\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n+    /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n+    (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n     /// Allows using imported `main` function\n     (active, imported_main, \"1.53.0\", Some(28937), None),\n     /// Allows associated types in inherent impls.\n@@ -424,8 +429,6 @@ declare_features! (\n     (incomplete, inline_const_pat, \"1.58.0\", Some(76001), None),\n     /// Allows using `pointer` and `reference` in intra-doc links\n     (active, intra_doc_pointers, \"1.51.0\", Some(80896), None),\n-    /// Allows `#[instruction_set(_)]` attribute\n-    (active, isa_attribute, \"1.48.0\", Some(74727), None),\n     // Allows setting the threshold for the `large_assignments` lint.\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `if/while p && let q = r && ...` chains.\n@@ -509,9 +512,9 @@ declare_features! (\n     (active, thread_local, \"1.0.0\", Some(29594), None),\n     /// Allows defining `trait X = A + B;` alias items.\n     (active, trait_alias, \"1.24.0\", Some(41517), None),\n-    /// Allows upcasting trait objects via supertraits.\n-    /// Trait upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n-    (incomplete, trait_upcasting, \"1.56.0\", Some(65991), None),\n+    /// Allows dyn upcasting trait objects via supertraits.\n+    /// Dyn upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n+    (active, trait_upcasting, \"1.56.0\", Some(65991), None),\n     /// Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n     /// Allows inconsistent bounds in where clauses."}, {"sha": "4b6e068db4312505c647c66023a49332d133cd57", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -147,7 +147,7 @@ pub enum AttributeDuplicates {\n     FutureWarnPreceding,\n }\n \n-/// A conveniece macro to deal with `$($expr)?`.\n+/// A convenience macro to deal with `$($expr)?`.\n macro_rules! or_default {\n     ($default:expr,) => {\n         $default\n@@ -391,6 +391,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         DuplicatesOk, @only_local: true,\n     ),\n     ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n+    ungated!(instruction_set, Normal, template!(List: \"set\"), ErrorPreceding),\n     gated!(\n         no_sanitize, Normal,\n         template!(List: \"address, memory, thread\"), DuplicatesOk,\n@@ -452,11 +453,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         optimize, Normal, template!(List: \"size|speed\"), ErrorPreceding, optimize_attribute,\n         experimental!(optimize),\n     ),\n-    // RFC 2867\n-    gated!(\n-        instruction_set, Normal, template!(List: \"set\"), ErrorPreceding,\n-        isa_attribute, experimental!(instruction_set)\n-    ),\n \n     gated!(\n         ffi_returns_twice, Normal, template!(Word), WarnFollowing, experimental!(ffi_returns_twice)\n@@ -554,10 +550,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(rustc_reallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_deallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_allocator_zeroed, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    gated!(\n-        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n-        experimental!(alloc_error_handler)\n-    ),\n     gated!(\n         default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n         experimental!(default_lib_allocator),\n@@ -699,6 +691,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: true,\n         \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n     ),\n+    rustc_attr!(\n+        rustc_deny_explicit_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: false,\n+        \"#[rustc_deny_explicit_impl] enforces that a trait can have no user-provided impls\"\n+    ),\n     rustc_attr!(\n         rustc_has_incoherent_inherent_impls, AttributeType::Normal, template!(Word), ErrorFollowing,\n         \"#[rustc_has_incoherent_inherent_impls] allows the addition of incoherent inherent impls for \\\n@@ -818,6 +814,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_def_path, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\"), DuplicatesOk),\n+    gated!(\n+        custom_mir, Normal, template!(List: r#\"dialect = \"...\", phase = \"...\"\"#),\n+        ErrorFollowing, \"the `#[custom_mir]` attribute is just used for the Rust test suite\",\n+    ),\n     rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word), WarnFollowing),"}, {"sha": "401d3f6689c99e7ae4cb072a0c5d35032396e0f1", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -471,7 +471,11 @@ pub trait Labeller<'a> {\n /// Escape tags in such a way that it is suitable for inclusion in a\n /// Graphviz HTML label.\n pub fn escape_html(s: &str) -> String {\n-    s.replace('&', \"&amp;\").replace('\\\"', \"&quot;\").replace('<', \"&lt;\").replace('>', \"&gt;\")\n+    s.replace('&', \"&amp;\")\n+        .replace('\\\"', \"&quot;\")\n+        .replace('<', \"&lt;\")\n+        .replace('>', \"&gt;\")\n+        .replace('\\n', \"<br align=\\\"left\\\"/>\")\n }\n \n impl<'a> LabelText<'a> {"}, {"sha": "82e260d158bc468acb5ec56372e53e49e1a4fb82", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -388,6 +388,8 @@ impl<'hir> GenericArgs<'hir> {\n     }\n \n     #[inline]\n+    /// This function returns the number of type and const generic params.\n+    /// It should only be used for diagnostics.\n     pub fn num_generic_params(&self) -> usize {\n         self.args.iter().filter(|arg| !matches!(arg, GenericArg::Lifetime(_))).count()\n     }\n@@ -2207,14 +2209,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2225,7 +2227,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2236,11 +2238,11 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n-        TraitItemId { def_id: self.def_id }\n+        TraitItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2271,22 +2273,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2298,11 +2300,11 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n-        ImplItemId { def_id: self.def_id }\n+        ImplItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2418,6 +2420,30 @@ impl<'hir> Ty<'hir> {\n         }\n         final_ty\n     }\n+\n+    pub fn find_self_aliases(&self) -> Vec<Span> {\n+        use crate::intravisit::Visitor;\n+        struct MyVisitor(Vec<Span>);\n+        impl<'v> Visitor<'v> for MyVisitor {\n+            fn visit_ty(&mut self, t: &'v Ty<'v>) {\n+                if matches!(\n+                    &t.kind,\n+                    TyKind::Path(QPath::Resolved(\n+                        _,\n+                        Path { res: crate::def::Res::SelfTyAlias { .. }, .. },\n+                    ))\n+                ) {\n+                    self.0.push(t.span);\n+                    return;\n+                }\n+                crate::intravisit::walk_ty(self, t);\n+            }\n+        }\n+\n+        let mut my_visitor = MyVisitor(vec![]);\n+        my_visitor.visit_ty(self);\n+        my_visitor.0\n+    }\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n@@ -2890,14 +2916,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2907,7 +2933,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2917,11 +2943,11 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n-        ItemId { def_id: self.def_id }\n+        ItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3134,14 +3160,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -3162,7 +3188,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3171,11 +3197,11 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n-        ForeignItemId { def_id: self.def_id }\n+        ForeignItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3267,10 +3293,10 @@ impl<'hir> OwnerNode<'hir> {\n \n     pub fn def_id(self) -> OwnerId {\n         match self {\n-            OwnerNode::Item(Item { def_id, .. })\n-            | OwnerNode::TraitItem(TraitItem { def_id, .. })\n-            | OwnerNode::ImplItem(ImplItem { def_id, .. })\n-            | OwnerNode::ForeignItem(ForeignItem { def_id, .. }) => *def_id,\n+            OwnerNode::Item(Item { owner_id, .. })\n+            | OwnerNode::TraitItem(TraitItem { owner_id, .. })\n+            | OwnerNode::ImplItem(ImplItem { owner_id, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { owner_id, .. }) => *owner_id,\n             OwnerNode::Crate(..) => crate::CRATE_HIR_ID.owner,\n         }\n     }"}, {"sha": "3ef58d7d70570031b01e8ed3173ef237b242c07a", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 373, "deletions": 366, "changes": 739, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -358,6 +358,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate<'v>) {\n         walk_where_predicate(self, predicate)\n     }\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'v FnRetTy<'v>) {\n+        walk_fn_ret_ty(self, ret_ty)\n+    }\n     fn visit_fn_decl(&mut self, fd: &'v FnDecl<'v>) {\n         walk_fn_decl(self, fd)\n     }\n@@ -410,12 +413,7 @@ pub trait Visitor<'v>: Sized {\n         walk_inf(self, inf);\n     }\n     fn visit_generic_arg(&mut self, generic_arg: &'v GenericArg<'v>) {\n-        match generic_arg {\n-            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n-            GenericArg::Type(ty) => self.visit_ty(ty),\n-            GenericArg::Const(ct) => self.visit_anon_const(&ct.value),\n-            GenericArg::Infer(inf) => self.visit_infer(inf),\n-        }\n+        walk_generic_arg(self, generic_arg);\n     }\n     fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n         walk_lifetime(self, lifetime)\n@@ -448,63 +446,6 @@ pub trait Visitor<'v>: Sized {\n     }\n }\n \n-pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n-    visitor.visit_id(mod_hir_id);\n-    for &item_id in module.item_ids {\n-        visitor.visit_nested_item(item_id);\n-    }\n-}\n-\n-pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n-    walk_list!(visitor, visit_param, body.params);\n-    visitor.visit_expr(&body.value);\n-}\n-\n-pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n-    // Intentionally visiting the expr first - the initialization expr\n-    // dominates the local's definition.\n-    walk_list!(visitor, visit_expr, &local.init);\n-    visitor.visit_id(local.hir_id);\n-    visitor.visit_pat(&local.pat);\n-    if let Some(els) = local.els {\n-        visitor.visit_block(els);\n-    }\n-    walk_list!(visitor, visit_ty, &local.ty);\n-}\n-\n-pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n-    visitor.visit_name(ident.name);\n-}\n-\n-pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n-    visitor.visit_ident(label.ident);\n-}\n-\n-pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n-    visitor.visit_id(lifetime.hir_id);\n-    match lifetime.name {\n-        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n-            visitor.visit_ident(ident);\n-        }\n-        LifetimeName::Param(_, ParamName::Fresh)\n-        | LifetimeName::Param(_, ParamName::Error)\n-        | LifetimeName::Static\n-        | LifetimeName::Error\n-        | LifetimeName::ImplicitObjectLifetimeDefault\n-        | LifetimeName::Infer => {}\n-    }\n-}\n-\n-pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n-    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n-    visitor.visit_trait_ref(&trait_ref.trait_ref);\n-}\n-\n-pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n-    visitor.visit_id(trait_ref.hir_ref_id);\n-    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n-}\n-\n pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param<'v>) {\n     visitor.visit_id(param.hir_id);\n     visitor.visit_pat(&param.pat);\n@@ -601,142 +542,80 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n     }\n }\n \n-pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n-    for (op, op_sp) in asm.operands {\n-        match op {\n-            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                visitor.visit_expr(expr)\n-            }\n-            InlineAsmOperand::Out { expr, .. } => {\n-                if let Some(expr) = expr {\n-                    visitor.visit_expr(expr);\n-                }\n-            }\n-            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                visitor.visit_expr(in_expr);\n-                if let Some(out_expr) = out_expr {\n-                    visitor.visit_expr(out_expr);\n-                }\n-            }\n-            InlineAsmOperand::Const { anon_const, .. }\n-            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n-            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n-        }\n-    }\n-}\n-\n-pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n-    visitor.visit_id(hir_id);\n-    visitor.visit_path(path, hir_id);\n+pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body<'v>) {\n+    walk_list!(visitor, visit_param, body.params);\n+    visitor.visit_expr(&body.value);\n }\n \n-pub fn walk_enum_def<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    enum_definition: &'v EnumDef<'v>,\n-    item_id: HirId,\n-) {\n-    visitor.visit_id(item_id);\n-    walk_list!(visitor, visit_variant, enum_definition.variants);\n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.name);\n }\n \n-pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n-    visitor.visit_ident(variant.ident);\n-    visitor.visit_id(variant.id);\n-    visitor.visit_variant_data(&variant.data);\n-    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n+    visitor.visit_id(mod_hir_id);\n+    for &item_id in module.item_ids {\n+        visitor.visit_nested_item(item_id);\n+    }\n }\n \n-pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n-    visitor.visit_id(typ.hir_id);\n+pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n+    visitor.visit_id(foreign_item.hir_id());\n+    visitor.visit_ident(foreign_item.ident);\n \n-    match typ.kind {\n-        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n-        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n-        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n-            visitor.visit_lifetime(lifetime);\n-            visitor.visit_ty(&mutable_type.ty)\n-        }\n-        TyKind::Never => {}\n-        TyKind::Tup(tuple_element_types) => {\n-            walk_list!(visitor, visit_ty, tuple_element_types);\n-        }\n-        TyKind::BareFn(ref function_declaration) => {\n-            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n-            visitor.visit_fn_decl(&function_declaration.decl);\n-        }\n-        TyKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n-        }\n-        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n-            visitor.visit_nested_item(item_id);\n-            walk_list!(visitor, visit_generic_arg, lifetimes);\n-        }\n-        TyKind::Array(ref ty, ref length) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_array_length(length)\n-        }\n-        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n-            for bound in bounds {\n-                visitor.visit_poly_trait_ref(bound);\n+    match foreign_item.kind {\n+        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_fn_decl(function_declaration);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n-            visitor.visit_lifetime(lifetime);\n         }\n-        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n-        TyKind::Infer | TyKind::Err => {}\n+        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n+        ForeignItemKind::Type => (),\n     }\n }\n \n-pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n-    visitor.visit_id(inf.hir_id);\n-}\n-\n-pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n-    match *qpath {\n-        QPath::Resolved(ref maybe_qself, ref path) => {\n-            walk_list!(visitor, visit_ty, maybe_qself);\n-            visitor.visit_path(path, id)\n-        }\n-        QPath::TypeRelative(ref qself, ref segment) => {\n-            visitor.visit_ty(qself);\n-            visitor.visit_path_segment(segment);\n-        }\n-        QPath::LangItem(..) => {}\n+pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n+    // Intentionally visiting the expr first - the initialization expr\n+    // dominates the local's definition.\n+    walk_list!(visitor, visit_expr, &local.init);\n+    visitor.visit_id(local.hir_id);\n+    visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n     }\n+    walk_list!(visitor, visit_ty, &local.ty);\n }\n \n-pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n-    for segment in path.segments {\n-        visitor.visit_path_segment(segment);\n-    }\n+pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n+    visitor.visit_id(block.hir_id);\n+    walk_list!(visitor, visit_stmt, block.stmts);\n+    walk_list!(visitor, visit_expr, &block.expr);\n }\n \n-pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n-    visitor.visit_ident(segment.ident);\n-    visitor.visit_id(segment.hir_id);\n-    if let Some(ref args) = segment.args {\n-        visitor.visit_generic_args(args);\n+pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n+    visitor.visit_id(statement.hir_id);\n+    match statement.kind {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(item) => visitor.visit_nested_item(item),\n+        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n+            visitor.visit_expr(expression)\n+        }\n     }\n }\n \n-pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n-    walk_list!(visitor, visit_generic_arg, generic_args.args);\n-    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n-}\n-\n-pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n-    visitor: &mut V,\n-    type_binding: &'v TypeBinding<'v>,\n-) {\n-    visitor.visit_id(type_binding.hir_id);\n-    visitor.visit_ident(type_binding.ident);\n-    visitor.visit_generic_args(type_binding.gen_args);\n-    match type_binding.kind {\n-        TypeBindingKind::Equality { ref term } => match term {\n-            Term::Ty(ref ty) => visitor.visit_ty(ty),\n-            Term::Const(ref c) => visitor.visit_anon_const(c),\n-        },\n-        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n+pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n+    visitor.visit_id(arm.hir_id);\n+    visitor.visit_pat(&arm.pat);\n+    if let Some(ref g) = arm.guard {\n+        match g {\n+            Guard::If(ref e) => visitor.visit_expr(e),\n+            Guard::IfLet(ref l) => {\n+                visitor.visit_let_expr(l);\n+            }\n+        }\n     }\n+    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat<'v>) {\n@@ -784,34 +663,182 @@ pub fn walk_pat_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v PatField<'\n     visitor.visit_pat(&field.pat)\n }\n \n-pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v ForeignItem<'v>) {\n-    visitor.visit_id(foreign_item.hir_id());\n-    visitor.visit_ident(foreign_item.ident);\n-\n-    match foreign_item.kind {\n-        ForeignItemKind::Fn(ref function_declaration, param_names, ref generics) => {\n-            visitor.visit_generics(generics);\n-            visitor.visit_fn_decl(function_declaration);\n-            for &param_name in param_names {\n-                visitor.visit_ident(param_name);\n-            }\n-        }\n-        ForeignItemKind::Static(ref typ, _) => visitor.visit_ty(typ),\n-        ForeignItemKind::Type => (),\n+pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n+    match len {\n+        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n+        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n     }\n }\n \n-pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n-    match *bound {\n-        GenericBound::Trait(ref typ, _modifier) => {\n-            visitor.visit_poly_trait_ref(typ);\n-        }\n-        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n-            visitor.visit_id(hir_id);\n-            visitor.visit_generic_args(args);\n-        }\n-        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n-    }\n+pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n+    visitor.visit_id(constant.hir_id);\n+    visitor.visit_nested_body(constant.body);\n+}\n+\n+pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n+    visitor.visit_id(expression.hir_id);\n+    match expression.kind {\n+        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n+        ExprKind::Repeat(ref element, ref count) => {\n+            visitor.visit_expr(element);\n+            visitor.visit_array_length(count)\n+        }\n+        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+            walk_list!(visitor, visit_expr_field, fields);\n+            walk_list!(visitor, visit_expr, optional_base);\n+        }\n+        ExprKind::Tup(subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Call(ref callee_expression, arguments) => {\n+            visitor.visit_expr(callee_expression);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+            visitor.visit_path_segment(segment);\n+            visitor.visit_expr(receiver);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n+        }\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n+        }\n+        ExprKind::DropTemps(ref subexpression) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n+        ExprKind::If(ref cond, ref then, ref else_opt) => {\n+            visitor.visit_expr(cond);\n+            visitor.visit_expr(then);\n+            walk_list!(visitor, visit_expr, else_opt);\n+        }\n+        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Match(ref subexpression, arms, _) => {\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n+        }\n+        ExprKind::Closure(&Closure {\n+            binder: _,\n+            bound_generic_params,\n+            fn_decl,\n+            body,\n+            capture_clause: _,\n+            fn_decl_span: _,\n+            movability: _,\n+        }) => {\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n+        }\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(rhs);\n+            visitor.visit_expr(lhs)\n+        }\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(right_expression);\n+            visitor.visit_expr(left_expression);\n+        }\n+        ExprKind::Field(ref subexpression, ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident);\n+        }\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n+        }\n+        ExprKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n+        }\n+        ExprKind::Break(ref destination, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref destination) => {\n+            walk_list!(visitor, visit_label, &destination.label);\n+        }\n+        ExprKind::Ret(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::InlineAsm(ref asm) => {\n+            visitor.visit_inline_asm(asm, expression.hir_id);\n+        }\n+        ExprKind::Yield(ref subexpression, _) => {\n+            visitor.visit_expr(subexpression);\n+        }\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n+    }\n+}\n+\n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n+pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n+    visitor.visit_id(field.hir_id);\n+    visitor.visit_ident(field.ident);\n+    visitor.visit_expr(&field.expr)\n+}\n+\n+pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty<'v>) {\n+    visitor.visit_id(typ.hir_id);\n+\n+    match typ.kind {\n+        TyKind::Slice(ref ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(ref lifetime, ref mutable_type) => {\n+            visitor.visit_lifetime(lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n+        }\n+        TyKind::Never => {}\n+        TyKind::Tup(tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n+        }\n+        TyKind::BareFn(ref function_declaration) => {\n+            walk_list!(visitor, visit_generic_param, function_declaration.generic_params);\n+            visitor.visit_fn_decl(&function_declaration.decl);\n+        }\n+        TyKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.hir_id, typ.span);\n+        }\n+        TyKind::OpaqueDef(item_id, lifetimes, _in_trait) => {\n+            visitor.visit_nested_item(item_id);\n+            walk_list!(visitor, visit_generic_arg, lifetimes);\n+        }\n+        TyKind::Array(ref ty, ref length) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_array_length(length)\n+        }\n+        TyKind::TraitObject(bounds, ref lifetime, _syntax) => {\n+            for bound in bounds {\n+                visitor.visit_poly_trait_ref(bound);\n+            }\n+            visitor.visit_lifetime(lifetime);\n+        }\n+        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Infer | TyKind::Err => {}\n+    }\n }\n \n pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v GenericParam<'v>) {\n@@ -875,25 +902,16 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n     }\n }\n \n-pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n-    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n-        visitor.visit_ty(output_ty)\n-    }\n-}\n-\n pub fn walk_fn_decl<'v, V: Visitor<'v>>(visitor: &mut V, function_declaration: &'v FnDecl<'v>) {\n     for ty in function_declaration.inputs {\n         visitor.visit_ty(ty)\n     }\n-    walk_fn_ret_ty(visitor, &function_declaration.output)\n+    visitor.visit_fn_ret_ty(&function_declaration.output)\n }\n \n-pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n-    match function_kind {\n-        FnKind::ItemFn(_, generics, ..) => {\n-            visitor.visit_generics(generics);\n-        }\n-        FnKind::Closure | FnKind::Method(..) => {}\n+pub fn walk_fn_ret_ty<'v, V: Visitor<'v>>(visitor: &mut V, ret_ty: &'v FnRetTy<'v>) {\n+    if let FnRetTy::Return(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(output_ty)\n     }\n }\n \n@@ -910,9 +928,23 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n     visitor.visit_nested_body(body_id)\n }\n \n+pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'v>) {\n+    match function_kind {\n+        FnKind::ItemFn(_, generics, ..) => {\n+            visitor.visit_generics(generics);\n+        }\n+        FnKind::Closure | FnKind::Method(..) => {}\n+    }\n+}\n+\n+pub fn walk_use<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>, hir_id: HirId) {\n+    visitor.visit_id(hir_id);\n+    visitor.visit_path(path, hir_id);\n+}\n+\n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let TraitItem { ident, generics, ref defaultness, ref kind, span, def_id: _ } = *trait_item;\n+    let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n     visitor.visit_generics(&generics);\n@@ -952,7 +984,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        def_id: _,\n+        owner_id: _,\n         ident,\n         ref generics,\n         ref kind,\n@@ -1004,6 +1036,29 @@ pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'\n     visitor.visit_associated_item_kind(kind);\n }\n \n+pub fn walk_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v TraitRef<'v>) {\n+    visitor.visit_id(trait_ref.hir_ref_id);\n+    visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n+}\n+\n+pub fn walk_param_bound<'v, V: Visitor<'v>>(visitor: &mut V, bound: &'v GenericBound<'v>) {\n+    match *bound {\n+        GenericBound::Trait(ref typ, _modifier) => {\n+            visitor.visit_poly_trait_ref(typ);\n+        }\n+        GenericBound::LangItemTrait(_, _span, hir_id, args) => {\n+            visitor.visit_id(hir_id);\n+            visitor.visit_generic_args(args);\n+        }\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+    }\n+}\n+\n+pub fn walk_poly_trait_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_ref: &'v PolyTraitRef<'v>) {\n+    walk_list!(visitor, visit_generic_param, trait_ref.bound_generic_params);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n pub fn walk_struct_def<'v, V: Visitor<'v>>(\n     visitor: &mut V,\n     struct_definition: &'v VariantData<'v>,\n@@ -1018,173 +1073,101 @@ pub fn walk_field_def<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v FieldDef<'\n     visitor.visit_ty(&field.ty);\n }\n \n-pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block<'v>) {\n-    visitor.visit_id(block.hir_id);\n-    walk_list!(visitor, visit_stmt, block.stmts);\n-    walk_list!(visitor, visit_expr, &block.expr);\n+pub fn walk_enum_def<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    enum_definition: &'v EnumDef<'v>,\n+    item_id: HirId,\n+) {\n+    visitor.visit_id(item_id);\n+    walk_list!(visitor, visit_variant, enum_definition.variants);\n }\n \n-pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt<'v>) {\n-    visitor.visit_id(statement.hir_id);\n-    match statement.kind {\n-        StmtKind::Local(ref local) => visitor.visit_local(local),\n-        StmtKind::Item(item) => visitor.visit_nested_item(item),\n-        StmtKind::Expr(ref expression) | StmtKind::Semi(ref expression) => {\n-            visitor.visit_expr(expression)\n-        }\n-    }\n+pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V, variant: &'v Variant<'v>) {\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n }\n \n-pub fn walk_array_len<'v, V: Visitor<'v>>(visitor: &mut V, len: &'v ArrayLen) {\n-    match len {\n-        &ArrayLen::Infer(hir_id, _span) => visitor.visit_id(hir_id),\n-        ArrayLen::Body(c) => visitor.visit_anon_const(c),\n-    }\n+pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n+    visitor.visit_ident(label.ident);\n }\n \n-pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n-    visitor.visit_id(constant.hir_id);\n-    visitor.visit_nested_body(constant.body);\n+pub fn walk_inf<'v, V: Visitor<'v>>(visitor: &mut V, inf: &'v InferArg) {\n+    visitor.visit_id(inf.hir_id);\n }\n \n-pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n-    // match the visit order in walk_local\n-    visitor.visit_expr(let_expr.init);\n-    visitor.visit_id(let_expr.hir_id);\n-    visitor.visit_pat(let_expr.pat);\n-    walk_list!(visitor, visit_ty, let_expr.ty);\n+pub fn walk_generic_arg<'v, V: Visitor<'v>>(visitor: &mut V, generic_arg: &'v GenericArg<'v>) {\n+    match generic_arg {\n+        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n+        GenericArg::Type(ty) => visitor.visit_ty(ty),\n+        GenericArg::Const(ct) => visitor.visit_anon_const(&ct.value),\n+        GenericArg::Infer(inf) => visitor.visit_infer(inf),\n+    }\n }\n \n-pub fn walk_expr_field<'v, V: Visitor<'v>>(visitor: &mut V, field: &'v ExprField<'v>) {\n-    visitor.visit_id(field.hir_id);\n-    visitor.visit_ident(field.ident);\n-    visitor.visit_expr(&field.expr)\n+pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n+    visitor.visit_id(lifetime.hir_id);\n+    match lifetime.name {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n+            visitor.visit_ident(ident);\n+        }\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n+        | LifetimeName::Static\n+        | LifetimeName::Error\n+        | LifetimeName::ImplicitObjectLifetimeDefault\n+        | LifetimeName::Infer => {}\n+    }\n }\n \n-pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n-    visitor.visit_id(expression.hir_id);\n-    match expression.kind {\n-        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n-        ExprKind::Array(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n-        ExprKind::Repeat(ref element, ref count) => {\n-            visitor.visit_expr(element);\n-            visitor.visit_array_length(count)\n-        }\n-        ExprKind::Struct(ref qpath, fields, ref optional_base) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-            walk_list!(visitor, visit_expr_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n-        }\n-        ExprKind::Tup(subexpressions) => {\n-            walk_list!(visitor, visit_expr, subexpressions);\n-        }\n-        ExprKind::Call(ref callee_expression, arguments) => {\n-            visitor.visit_expr(callee_expression);\n-            walk_list!(visitor, visit_expr, arguments);\n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath<'v>, id: HirId) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            walk_list!(visitor, visit_ty, maybe_qself);\n+            visitor.visit_path(path, id)\n         }\n-        ExprKind::MethodCall(ref segment, receiver, arguments, _) => {\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n             visitor.visit_path_segment(segment);\n-            visitor.visit_expr(receiver);\n-            walk_list!(visitor, visit_expr, arguments);\n-        }\n-        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(left_expression);\n-            visitor.visit_expr(right_expression)\n         }\n-        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n-            visitor.visit_expr(subexpression)\n-        }\n-        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ty(typ)\n-        }\n-        ExprKind::DropTemps(ref subexpression) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n-        ExprKind::If(ref cond, ref then, ref else_opt) => {\n-            visitor.visit_expr(cond);\n-            visitor.visit_expr(then);\n-            walk_list!(visitor, visit_expr, else_opt);\n-        }\n-        ExprKind::Loop(ref block, ref opt_label, _, _) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Match(ref subexpression, arms, _) => {\n-            visitor.visit_expr(subexpression);\n-            walk_list!(visitor, visit_arm, arms);\n-        }\n-        ExprKind::Closure(&Closure {\n-            binder: _,\n-            bound_generic_params,\n-            fn_decl,\n-            body,\n-            capture_clause: _,\n-            fn_decl_span: _,\n-            movability: _,\n-        }) => {\n-            walk_list!(visitor, visit_generic_param, bound_generic_params);\n-            visitor.visit_fn(FnKind::Closure, fn_decl, body, expression.span, expression.hir_id)\n-        }\n-        ExprKind::Block(ref block, ref opt_label) => {\n-            walk_list!(visitor, visit_label, opt_label);\n-            visitor.visit_block(block);\n-        }\n-        ExprKind::Assign(ref lhs, ref rhs, _) => {\n-            visitor.visit_expr(rhs);\n-            visitor.visit_expr(lhs)\n-        }\n-        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n-            visitor.visit_expr(right_expression);\n-            visitor.visit_expr(left_expression);\n-        }\n-        ExprKind::Field(ref subexpression, ident) => {\n-            visitor.visit_expr(subexpression);\n-            visitor.visit_ident(ident);\n-        }\n-        ExprKind::Index(ref main_expression, ref index_expression) => {\n-            visitor.visit_expr(main_expression);\n-            visitor.visit_expr(index_expression)\n-        }\n-        ExprKind::Path(ref qpath) => {\n-            visitor.visit_qpath(qpath, expression.hir_id, expression.span);\n-        }\n-        ExprKind::Break(ref destination, ref opt_expr) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-            walk_list!(visitor, visit_expr, opt_expr);\n-        }\n-        ExprKind::Continue(ref destination) => {\n-            walk_list!(visitor, visit_label, &destination.label);\n-        }\n-        ExprKind::Ret(ref optional_expression) => {\n-            walk_list!(visitor, visit_expr, optional_expression);\n-        }\n-        ExprKind::InlineAsm(ref asm) => {\n-            visitor.visit_inline_asm(asm, expression.hir_id);\n-        }\n-        ExprKind::Yield(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n-        ExprKind::Lit(_) | ExprKind::Err => {}\n+        QPath::LangItem(..) => {}\n     }\n }\n \n-pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm<'v>) {\n-    visitor.visit_id(arm.hir_id);\n-    visitor.visit_pat(&arm.pat);\n-    if let Some(ref g) = arm.guard {\n-        match g {\n-            Guard::If(ref e) => visitor.visit_expr(e),\n-            Guard::IfLet(ref l) => {\n-                visitor.visit_let_expr(l);\n-            }\n-        }\n+pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path<'v>) {\n+    for segment in path.segments {\n+        visitor.visit_path_segment(segment);\n+    }\n+}\n+\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V, segment: &'v PathSegment<'v>) {\n+    visitor.visit_ident(segment.ident);\n+    visitor.visit_id(segment.hir_id);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(args);\n+    }\n+}\n+\n+pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V, generic_args: &'v GenericArgs<'v>) {\n+    walk_list!(visitor, visit_generic_arg, generic_args.args);\n+    walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n+}\n+\n+pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(\n+    visitor: &mut V,\n+    type_binding: &'v TypeBinding<'v>,\n+) {\n+    visitor.visit_id(type_binding.hir_id);\n+    visitor.visit_ident(type_binding.ident);\n+    visitor.visit_generic_args(type_binding.gen_args);\n+    match type_binding.kind {\n+        TypeBindingKind::Equality { ref term } => match term {\n+            Term::Ty(ref ty) => visitor.visit_ty(ty),\n+            Term::Const(ref c) => visitor.visit_anon_const(c),\n+        },\n+        TypeBindingKind::Constraint { bounds } => walk_list!(visitor, visit_param_bound, bounds),\n     }\n-    visitor.visit_expr(&arm.body);\n }\n \n pub fn walk_associated_item_kind<'v, V: Visitor<'v>>(_: &mut V, _: &'v AssocItemKind) {\n@@ -1198,3 +1181,27 @@ pub fn walk_defaultness<'v, V: Visitor<'v>>(_: &mut V, _: &'v Defaultness) {\n     // the right thing to do, should content be added in the future,\n     // would be to walk it.\n }\n+\n+pub fn walk_inline_asm<'v, V: Visitor<'v>>(visitor: &mut V, asm: &'v InlineAsm<'v>, id: HirId) {\n+    for (op, op_sp) in asm.operands {\n+        match op {\n+            InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                visitor.visit_expr(expr)\n+            }\n+            InlineAsmOperand::Out { expr, .. } => {\n+                if let Some(expr) = expr {\n+                    visitor.visit_expr(expr);\n+                }\n+            }\n+            InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                visitor.visit_expr(in_expr);\n+                if let Some(out_expr) = out_expr {\n+                    visitor.visit_expr(out_expr);\n+                }\n+            }\n+            InlineAsmOperand::Const { anon_const, .. }\n+            | InlineAsmOperand::SymFn { anon_const, .. } => visitor.visit_anon_const(anon_const),\n+            InlineAsmOperand::SymStatic { path, .. } => visitor.visit_qpath(path, id, *op_sp),\n+        }\n+    }\n+}"}, {"sha": "a55224d10972abf01a57e95933d174bab7481941", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 107, "deletions": 105, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,35 +12,56 @@ use crate::errors::LangItemError;\n use crate::{MethodKind, Target};\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::sync::LazyLock;\n-\n-pub enum LangItemGroup {\n-    Op,\n-    Fn,\n+/// All of the language items, defined or not.\n+/// Defined lang items can come from the current crate or its dependencies.\n+#[derive(HashStable_Generic, Debug)]\n+pub struct LanguageItems {\n+    /// Mappings from lang items to their possibly found [`DefId`]s.\n+    /// The index corresponds to the order in [`LangItem`].\n+    items: [Option<DefId>; std::mem::variant_count::<LangItem>()],\n+    /// Lang items that were not found during collection.\n+    pub missing: Vec<LangItem>,\n }\n \n-const NUM_GROUPS: usize = 2;\n+impl LanguageItems {\n+    /// Construct an empty collection of lang items and no missing ones.\n+    pub fn new() -> Self {\n+        Self { items: [None; std::mem::variant_count::<LangItem>()], missing: Vec::new() }\n+    }\n+\n+    pub fn get(&self, item: LangItem) -> Option<DefId> {\n+        self.items[item as usize]\n+    }\n \n-macro_rules! expand_group {\n-    () => {\n-        None\n-    };\n-    ($group:expr) => {\n-        Some($group)\n-    };\n+    pub fn set(&mut self, item: LangItem, def_id: DefId) {\n+        self.items[item as usize] = Some(def_id);\n+    }\n+\n+    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+    /// returns an error encapsulating the `LangItem`.\n+    pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n+        self.get(it).ok_or_else(|| LangItemError(it))\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (LangItem, DefId)> + 'a {\n+        self.items\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, id)| id.map(|id| (LangItem::from_u32(i as u32).unwrap(), id)))\n+    }\n }\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {\n     (\n-        $( $(#[$attr:meta])* $variant:ident $($group:expr)?, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+        $( $(#[$attr:meta])* $variant:ident, $module:ident :: $name:ident, $method:ident, $target:expr, $generics:expr; )*\n     ) => {\n \n         enum_from_u32! {\n@@ -66,12 +87,17 @@ macro_rules! language_item_table {\n                 }\n             }\n \n-            /// The [group](LangItemGroup) that this lang item belongs to,\n-            /// or `None` if it doesn't belong to a group.\n-            pub fn group(self) -> Option<LangItemGroup> {\n-                use LangItemGroup::*;\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_name(name: Symbol) -> Option<Self> {\n+                match name {\n+                    $( $module::$name => Some(LangItem::$variant), )*\n+                    _ => None,\n+                }\n+            }\n+\n+            pub fn target(self) -> Target {\n                 match self {\n-                    $( LangItem::$variant => expand_group!($($group)*), )*\n+                    $( LangItem::$variant => $target, )*\n                 }\n             }\n \n@@ -82,66 +108,14 @@ macro_rules! language_item_table {\n             }\n         }\n \n-        /// All of the language items, defined or not.\n-        /// Defined lang items can come from the current crate or its dependencies.\n-        #[derive(HashStable_Generic, Debug)]\n-        pub struct LanguageItems {\n-            /// Mappings from lang items to their possibly found [`DefId`]s.\n-            /// The index corresponds to the order in [`LangItem`].\n-            pub items: Vec<Option<DefId>>,\n-            /// Lang items that were not found during collection.\n-            pub missing: Vec<LangItem>,\n-            /// Mapping from [`LangItemGroup`] discriminants to all\n-            /// [`DefId`]s of lang items in that group.\n-            pub groups: [Vec<DefId>; NUM_GROUPS],\n-        }\n-\n         impl LanguageItems {\n-            /// Construct an empty collection of lang items and no missing ones.\n-            pub fn new() -> Self {\n-                fn init_none(_: LangItem) -> Option<DefId> { None }\n-                const EMPTY: Vec<DefId> = Vec::new();\n-\n-                Self {\n-                    items: vec![$(init_none(LangItem::$variant)),*],\n-                    missing: Vec::new(),\n-                    groups: [EMPTY; NUM_GROUPS],\n-                }\n-            }\n-\n-            /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-            pub fn items(&self) -> &[Option<DefId>] {\n-                &*self.items\n-            }\n-\n-            /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-            /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-            /// returns an error encapsulating the `LangItem`.\n-            pub fn require(&self, it: LangItem) -> Result<DefId, LangItemError> {\n-                self.items[it as usize].ok_or_else(|| LangItemError(it))\n-            }\n-\n-            /// Returns the [`DefId`]s of all lang items in a group.\n-            pub fn group(&self, group: LangItemGroup) -> &[DefId] {\n-                self.groups[group as usize].as_ref()\n-            }\n-\n             $(\n                 #[doc = concat!(\"Returns the [`DefId`] of the `\", stringify!($name), \"` lang item if it is defined.\")]\n                 pub fn $method(&self) -> Option<DefId> {\n                     self.items[LangItem::$variant as usize]\n                 }\n             )*\n         }\n-\n-        /// A mapping from the name of the lang item to its order and the form it must be of.\n-        pub static ITEM_REFS: LazyLock<FxIndexMap<Symbol, (usize, Target)>> = LazyLock::new(|| {\n-            let mut item_refs = FxIndexMap::default();\n-            $( item_refs.insert($module::$name, (LangItem::$variant as usize, $target)); )*\n-            item_refs\n-        });\n-\n-// End of the macro\n     }\n }\n \n@@ -152,14 +126,12 @@ impl<CTX> HashStable<CTX> for LangItem {\n }\n \n /// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n+/// The `#[panic_handler]` attribute is also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     attrs.iter().find_map(|attr| {\n         Some(match attr {\n             _ if attr.has_name(sym::lang) => (attr.value_str()?, attr.span),\n             _ if attr.has_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.has_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n             _ => return None,\n         })\n     })\n@@ -196,30 +168,30 @@ language_item_table! {\n     TransmuteOpts,           sym::transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n     TransmuteTrait,          sym::transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n \n-    Add(Op),                 sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Sub(Op),                 sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Mul(Op),                 sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Div(Op),                 sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Rem(Op),                 sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Neg(Op),                 sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    Not(Op),                 sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n-    BitXor(Op),              sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitAnd(Op),              sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    BitOr(Op),               sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    Shl(Op),                 sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    Shr(Op),                 sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n-    AddAssign(Op),           sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    SubAssign(Op),           sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    MulAssign(Op),           sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    DivAssign(Op),           sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    RemAssign(Op),           sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    BitXorAssign(Op),        sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitAndAssign(Op),        sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n-    BitOrAssign(Op),         sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n-    ShlAssign(Op),           sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    ShrAssign(Op),           sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n-    Index(Op),               sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n-    IndexMut(Op),            sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+    Add,                     sym::add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sym::sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     sym::mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     sym::div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     sym::rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     sym::neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     sym::not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  sym::bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  sym::bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   sym::bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     sym::shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     sym::shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               sym::add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sym::sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               sym::mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               sym::div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               sym::rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            sym::bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            sym::bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             sym::bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               sym::shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               sym::shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   sym::index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                sym::index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n \n     UnsafeCell,              sym::unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n     VaList,                  sym::va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n@@ -229,9 +201,9 @@ language_item_table! {\n     DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n \n-    Fn(Fn),                  kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut(Fn),               sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce(Fn),              sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n \n     FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n \n@@ -241,8 +213,8 @@ language_item_table! {\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n-    PartialEq(Op),           sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd(Op),          sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n@@ -266,7 +238,6 @@ language_item_table! {\n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n     BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n-    Oom,                     sym::oom,                 oom,                        Target::Fn,             GenericRequirement::None;\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n \n     Start,                   sym::start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n@@ -338,3 +309,34 @@ pub enum GenericRequirement {\n     Minimum(usize),\n     Exact(usize),\n }\n+\n+pub static FN_TRAITS: &'static [LangItem] = &[LangItem::Fn, LangItem::FnMut, LangItem::FnOnce];\n+\n+pub static OPERATORS: &'static [LangItem] = &[\n+    LangItem::Add,\n+    LangItem::Sub,\n+    LangItem::Mul,\n+    LangItem::Div,\n+    LangItem::Rem,\n+    LangItem::Neg,\n+    LangItem::Not,\n+    LangItem::BitXor,\n+    LangItem::BitAnd,\n+    LangItem::BitOr,\n+    LangItem::Shl,\n+    LangItem::Shr,\n+    LangItem::AddAssign,\n+    LangItem::SubAssign,\n+    LangItem::MulAssign,\n+    LangItem::DivAssign,\n+    LangItem::RemAssign,\n+    LangItem::BitXorAssign,\n+    LangItem::BitAndAssign,\n+    LangItem::BitOrAssign,\n+    LangItem::ShlAssign,\n+    LangItem::ShrAssign,\n+    LangItem::Index,\n+    LangItem::IndexMut,\n+    LangItem::PartialEq,\n+    LangItem::PartialOrd,\n+];"}, {"sha": "1c55cd8fee8f922f94a92bc398f291ee68748b0e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,10 +5,10 @@\n #![feature(associated_type_defaults)]\n #![feature(closure_track_caller)]\n #![feature(const_btree_len)]\n-#![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n+#![feature(variant_count)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]"}, {"sha": "23423e8f3b3bff5f7121730e857a190e665d8667", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "0cc50c6dd85054642fdb576e5137c7bded4bb934", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 18, "deletions": 41, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,53 +1,30 @@\n //! Validity checking for weak lang items\n \n-use crate::def_id::DefId;\n-use crate::{lang_items, LangItem, LanguageItems};\n+use crate::LangItem;\n \n-use rustc_ast as ast;\n-use rustc_data_structures::fx::FxIndexMap;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::sync::LazyLock;\n-\n macro_rules! weak_lang_items {\n-    ($($name:ident, $item:ident, $sym:ident;)*) => (\n-\n-pub static WEAK_ITEMS_REFS: LazyLock<FxIndexMap<Symbol, LangItem>> = LazyLock::new(|| {\n-    let mut map = FxIndexMap::default();\n-    $(map.insert(sym::$name, LangItem::$item);)*\n-    map\n-});\n-\n-pub static WEAK_ITEMS_SYMBOLS: LazyLock<FxIndexMap<LangItem, Symbol>> = LazyLock::new(|| {\n-    let mut map = FxIndexMap::default();\n-    $(map.insert(LangItem::$item, sym::$sym);)*\n-    map\n-});\n-\n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol>\n-{\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n-        $(if name == sym::$name {\n-            Some(sym::$sym)\n-        } else)* {\n-            None\n+    ($($item:ident, $sym:ident;)*) => {\n+        pub static WEAK_LANG_ITEMS: &[LangItem] = &[$(LangItem::$item,)*];\n+\n+        impl LangItem {\n+            pub fn is_weak(self) -> bool {\n+                matches!(self, $(LangItem::$item)|*)\n+            }\n+\n+            pub fn link_name(self) -> Option<Symbol> {\n+                match self {\n+                    $( LangItem::$item => Some(sym::$sym),)*\n+                    _ => None,\n+                }\n+            }\n         }\n-    })\n-}\n-\n-impl LanguageItems {\n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n-        let did = Some(item_def_id);\n-\n-        $(self.$name() == did)||*\n     }\n }\n \n-) }\n-\n weak_lang_items! {\n-    panic_impl,         PanicImpl,          rust_begin_unwind;\n-    eh_personality,     EhPersonality,      rust_eh_personality;\n-    eh_catch_typeinfo,  EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n-    oom,                Oom,                rust_oom;\n+    PanicImpl,          rust_begin_unwind;\n+    EhPersonality,      rust_eh_personality;\n+    EhCatchTypeinfo,    rust_eh_catch_typeinfo;\n }"}, {"sha": "e6465d641f1e64552af60f0775a5bbf4564b0666", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -177,11 +177,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .all_traits()\n             .filter(|trait_def_id| {\n                 let viz = self.tcx().visibility(*trait_def_id);\n-                if let Some(def_id) = self.item_def_id() {\n-                    viz.is_accessible_from(def_id, self.tcx())\n-                } else {\n-                    viz.is_visible_locally()\n-                }\n+                let def_id = self.item_def_id();\n+                viz.is_accessible_from(def_id, self.tcx())\n             })\n             .collect();\n "}, {"sha": "4518cf30acdd5fda428c2fa7d3ef6e9f26bacb84", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 92, "deletions": 43, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -23,7 +23,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n@@ -36,7 +35,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -55,7 +54,7 @@ pub struct PathSeg(pub DefId, pub usize);\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn item_def_id(&self) -> Option<DefId>;\n+    fn item_def_id(&self) -> DefId;\n \n     /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n     /// is a type parameter `X` with the given id `def_id` and T\n@@ -275,6 +274,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -324,6 +324,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n+        constness: ty::BoundConstness,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -499,6 +500,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                     GenericParamDefKind::Const { has_default } => {\n                         let ty = tcx.at(self.span).type_of(param.def_id);\n+                        if ty.references_error() {\n+                            return tcx.const_error(ty).into();\n+                        }\n                         if !infer_args && has_default {\n                             tcx.bound_const_param_default(param.def_id)\n                                 .subst(tcx, substs.unwrap())\n@@ -534,6 +538,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &mut substs_ctx,\n         );\n \n+        if let ty::BoundConstness::ConstIfConst = constness\n+            && generics.has_self && !tcx.has_attr(def_id, sym::const_trait)\n+        {\n+            tcx.sess.emit_err(crate::errors::ConstBoundForNonConstTrait { span } );\n+        }\n+\n         (substs, arg_count)\n     }\n \n@@ -601,6 +611,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n+            ty::BoundConstness::NotConst,\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n@@ -620,6 +631,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n+        constness: ty::BoundConstness,\n     ) -> ty::TraitRef<'tcx> {\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n@@ -629,6 +641,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n             true,\n+            constness,\n         )\n     }\n \n@@ -655,6 +668,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             args,\n             infer_args,\n             Some(self_ty),\n+            constness,\n         );\n \n         let tcx = self.tcx();\n@@ -680,6 +694,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 speculative,\n                 &mut dup_bindings,\n                 binding_span.unwrap_or(binding.span),\n+                constness,\n             );\n             // Okay to ignore `Err` because of `ErrorGuaranteed` (see above).\n         }\n@@ -783,13 +798,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n         is_impl: bool,\n+        constness: ty::BoundConstness,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, _) = self.create_substs_for_ast_trait_ref(\n             span,\n             trait_def_id,\n             self_ty,\n             trait_segment,\n             is_impl,\n+            constness,\n         );\n         if let Some(b) = trait_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -805,6 +822,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n         is_impl: bool,\n+        constness: ty::BoundConstness,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, is_impl);\n \n@@ -816,6 +834,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_segment.args(),\n             trait_segment.infer_args,\n             Some(self_ty),\n+            constness,\n         )\n     }\n \n@@ -867,9 +886,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         }\n \n-        let sized_def_id = tcx.lang_items().require(LangItem::Sized);\n+        let sized_def_id = tcx.lang_items().sized_trait();\n         match (&sized_def_id, unbound) {\n-            (Ok(sized_def_id), Some(tpb))\n+            (Some(sized_def_id), Some(tpb))\n                 if tpb.path.res == Res::Def(DefKind::Trait, *sized_def_id) =>\n             {\n                 // There was in fact a `?Sized` bound, return without doing anything\n@@ -889,7 +908,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // There was no `?Sized` bound; add implicitly sized if `Sized` is available.\n             }\n         }\n-        if sized_def_id.is_err() {\n+        if sized_def_id.is_none() {\n             // No lang item for `Sized`, so we can't add it as a bound.\n             return;\n         }\n@@ -1027,6 +1046,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         speculative: bool,\n         dup_bindings: &mut FxHashMap<DefId, Span>,\n         path_span: Span,\n+        constness: ty::BoundConstness,\n     ) -> Result<(), ErrorGuaranteed> {\n         // Given something like `U: SomeTrait<T = X>`, we want to produce a\n         // predicate like `<U as SomeTrait>::T = X`. This is somewhat\n@@ -1122,10 +1142,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 trait_ref.substs,\n             );\n \n-            debug!(\n-                \"add_predicates_for_ast_type_binding: substs for trait-ref and assoc_item: {:?}\",\n-                substs_trait_ref_and_assoc_item\n-            );\n+            debug!(?substs_trait_ref_and_assoc_item);\n \n             ty::ProjectionTy {\n                 item_def_id: assoc_item.def_id,\n@@ -1146,8 +1163,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     tcx.collect_constrained_late_bound_regions(&projection_ty);\n                 let late_bound_in_ty =\n                     tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n-                debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n-                debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n+                debug!(?late_bound_in_trait_ref);\n+                debug!(?late_bound_in_ty);\n \n                 // FIXME: point at the type params that don't have appropriate lifetimes:\n                 // struct S1<F: for<'a> Fn(&i32, &i32) -> &'a i32>(F);\n@@ -1184,7 +1201,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (_, _) => {\n                         let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n                         let expected = def_kind.descr(assoc_item_def_id);\n-                        tcx.sess\n+                        let reported = tcx\n+                            .sess\n                             .struct_span_err(\n                                 binding.span,\n                                 &format!(\"expected {expected} bound, found {got}\"),\n@@ -1195,11 +1213,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             )\n                             .emit();\n                         term = match def_kind {\n-                            hir::def::DefKind::AssocTy => tcx.ty_error().into(),\n+                            hir::def::DefKind::AssocTy => {\n+                                tcx.ty_error_with_guaranteed(reported).into()\n+                            }\n                             hir::def::DefKind::AssocConst => tcx\n-                                .const_error(\n+                                .const_error_with_guaranteed(\n                                     tcx.bound_type_of(assoc_item_def_id)\n                                         .subst(tcx, projection_ty.skip_binder().substs),\n+                                    reported,\n                                 )\n                                 .into(),\n                             _ => unreachable!(),\n@@ -1317,8 +1338,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .map(|&(trait_ref, _, _)| trait_ref.def_id())\n                 .find(|&trait_ref| tcx.is_trait_alias(trait_ref))\n                 .map(|trait_ref| tcx.def_span(trait_ref));\n-            tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n-            return tcx.ty_error();\n+            let reported =\n+                tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n+            return tcx.ty_error_with_guaranteed(reported);\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1328,14 +1350,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let object_safety_violations =\n                 astconv_object_safety_violations(tcx, item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n-                report_object_safety_error(\n+                let reported = report_object_safety_error(\n                     tcx,\n                     span,\n                     item.trait_ref().def_id(),\n                     &object_safety_violations,\n                 )\n                 .emit();\n-                return tcx.ty_error();\n+                return tcx.ty_error_with_guaranteed(reported);\n             }\n         }\n \n@@ -1648,6 +1670,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     // Checks that `bounds` contains exactly one element and reports appropriate\n     // errors otherwise.\n+    #[instrument(level = \"debug\", skip(self, all_candidates, ty_param_name, is_equality), ret)]\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n@@ -1677,10 +1700,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 return Err(reported);\n             }\n         };\n-        debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n+        debug!(?bound);\n \n         if let Some(bound2) = next_cand {\n-            debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n+            debug!(?bound2);\n \n             let is_equality = is_equality();\n             let bounds = IntoIterator::into_iter([bound, bound2]).chain(matching_candidates);\n@@ -1776,6 +1799,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     // parameter or `Self`.\n     // NOTE: When this function starts resolving `Trait::AssocTy` successfully\n     // it should also start reporting the `BARE_TRAIT_OBJECTS` lint.\n+    #[instrument(level = \"debug\", skip(self, hir_ref_id, span, qself, assoc_segment), fields(assoc_ident=?assoc_segment.ident), ret)]\n     pub fn associated_path_to_ty(\n         &self,\n         hir_ref_id: hir::HirId,\n@@ -1793,8 +1817,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Err\n         };\n \n-        debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n-\n         // Check if we have an enum variant.\n         let mut variant_resolution = None;\n         if let ty::Adt(adt_def, _) = qself_ty.kind() {\n@@ -1893,6 +1915,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n             }\n+\n+            // see if we can satisfy using an inherent associated type\n+            for impl_ in tcx.inherent_impls(adt_def.did()) {\n+                let assoc_ty = tcx.associated_items(impl_).find_by_name_and_kind(\n+                    tcx,\n+                    assoc_ident,\n+                    ty::AssocKind::Type,\n+                    *impl_,\n+                );\n+                if let Some(assoc_ty) = assoc_ty {\n+                    let ty = tcx.type_of(assoc_ty.def_id);\n+                    return Ok((ty, DefKind::AssocTy, assoc_ty.def_id));\n+                }\n+            }\n         }\n \n         // Find the type of the associated item, and the trait where the associated\n@@ -1962,7 +1998,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n \n                     err.emit()\n-                } else if let Some(reported) = qself_ty.error_reported() {\n+                } else if let Err(reported) = qself_ty.error_reported() {\n                     reported\n                 } else {\n                     // Don't print `TyErr` to the user.\n@@ -2050,6 +2086,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         item_def_id: DefId,\n         trait_segment: &hir::PathSegment<'_>,\n         item_segment: &hir::PathSegment<'_>,\n+        constness: ty::BoundConstness,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2064,17 +2101,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             debug!(\"qpath_to_ty: self.item_def_id()={:?}\", def_id);\n \n-            let parent_def_id = def_id\n-                .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-                })\n+            let parent_def_id = def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                 .map(|hir_id| tcx.hir().get_parent_item(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n \n             // If the trait in segment is the same as the trait defining the item,\n             // use the `<Self as ..>` syntax in the error.\n-            let is_part_of_self_trait_constraints = def_id == Some(trait_def_id);\n+            let is_part_of_self_trait_constraints = def_id == trait_def_id;\n             let is_part_of_fn_in_self_trait = parent_def_id == Some(trait_def_id);\n \n             let type_name = if is_part_of_self_trait_constraints || is_part_of_fn_in_self_trait {\n@@ -2083,19 +2117,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"Type\"\n             };\n \n-            self.report_ambiguous_associated_type(\n+            let reported = self.report_ambiguous_associated_type(\n                 span,\n                 type_name,\n                 &path_str,\n                 item_segment.ident.name,\n             );\n-            return tcx.ty_error();\n+            return tcx.ty_error_with_guaranteed(reported)\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n \n-        let trait_ref =\n-            self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment, false);\n+        let trait_ref = self.ast_path_to_mono_trait_ref(\n+            span,\n+            trait_def_id,\n+            self_ty,\n+            trait_segment,\n+            false,\n+            constness,\n+        );\n \n         let item_substs = self.create_substs_for_associated_item(\n             span,\n@@ -2525,21 +2565,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     {\n                         err.span_note(impl_.self_ty.span, \"not a concrete type\");\n                     }\n-                    err.emit();\n-                    tcx.ty_error()\n+                    tcx.ty_error_with_guaranteed(err.emit())\n                 } else {\n                     self.normalize_ty(span, ty)\n                 }\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n+                // HACK: until we support `<Type as ~const Trait>`, assume all of them are.\n+                let constness = if tcx.has_attr(tcx.parent(def_id), sym::const_trait) {\n+                    ty::BoundConstness::ConstIfConst\n+                } else {\n+                    ty::BoundConstness::NotConst\n+                };\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n                     def_id,\n                     &path.segments[path.segments.len() - 2],\n                     path.segments.last().unwrap(),\n+                    constness,\n                 )\n             }\n             Res::PrimTy(prim_ty) => {\n@@ -2632,7 +2678,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n-                let def_id = item_id.def_id.to_def_id();\n+                let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n@@ -2658,6 +2704,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &GenericArgs::none(),\n                     true,\n                     None,\n+                    ty::BoundConstness::NotConst,\n                 );\n                 EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n                     .subst(tcx, substs)\n@@ -2766,6 +2813,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, hir_id, unsafety, abi, decl, generics, hir_ty), ret)]\n     pub fn ty_of_fn(\n         &self,\n         hir_id: hir::HirId,\n@@ -2775,8 +2823,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generics: Option<&hir::Generics<'_>>,\n         hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n-        debug!(\"ty_of_fn\");\n-\n         let tcx = self.tcx();\n         let bound_vars = tcx.late_bound_vars(hir_id);\n         debug!(?bound_vars);\n@@ -2826,7 +2872,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::FnRetTy::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n-        debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n+        debug!(?output_ty);\n \n         let fn_ty = tcx.mk_fn_sig(input_tys.into_iter(), output_ty, decl.c_variadic, unsafety, abi);\n         let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n@@ -2903,8 +2949,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n                 hir.get(hir.get_parent_node(fn_hir_id)) else { bug!(\"ImplItem should have Impl parent\") };\n \n-        let trait_ref =\n-            self.instantiate_mono_trait_ref(i.of_trait.as_ref()?, self.ast_ty_to_ty(i.self_ty));\n+        let trait_ref = self.instantiate_mono_trait_ref(\n+            i.of_trait.as_ref()?,\n+            self.ast_ty_to_ty(i.self_ty),\n+            ty::BoundConstness::NotConst,\n+        );\n \n         let assoc = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n             tcx,\n@@ -2931,15 +2980,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         for br in referenced_regions.difference(&constrained_regions) {\n             let br_name = match *br {\n-                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) | ty::BrEnv => {\n+                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(..) | ty::BrEnv => {\n                     \"an anonymous lifetime\".to_string()\n                 }\n                 ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n             };\n \n             let mut err = generate_err(&br_name);\n \n-            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) = *br {\n+            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(..) = *br {\n                 // The only way for an anonymous lifetime to wind up\n                 // in the return type but **also** be unconstrained is\n                 // if it only appears in \"associated types\" in the"}, {"sha": "0ba5e61510125d10e187a6269996729c21b46280", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 93, "deletions": 89, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,7 +6,7 @@ use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n@@ -26,6 +26,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n@@ -75,15 +76,15 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         check_simd(tcx, span, def_id);\n     }\n \n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_packed(tcx, span, def);\n }\n \n fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_transparent(tcx, span, def);\n+    check_transparent(tcx, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n }\n@@ -114,7 +115,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                 _ => {\n                     // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n                     ty.ty_adt_def().is_some_and(|adt_def| adt_def.is_manually_drop())\n-                        || ty.is_copy_modulo_regions(tcx.at(span), param_env)\n+                        || ty.is_copy_modulo_regions(tcx, param_env)\n                 }\n             }\n         }\n@@ -227,17 +228,17 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         return;\n     }\n \n-    let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n-    let span = tcx.def_span(item.def_id.def_id);\n+    let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n+    let span = tcx.def_span(item.owner_id.def_id);\n \n-    check_opaque_for_inheriting_lifetimes(tcx, item.def_id.def_id, span);\n-    if tcx.type_of(item.def_id.def_id).references_error() {\n+    check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    if tcx.type_of(item.owner_id.def_id).references_error() {\n         return;\n     }\n-    if check_opaque_for_cycles(tcx, item.def_id.def_id, substs, span, &origin).is_err() {\n+    if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, item.def_id.def_id, substs, span, &origin);\n+    check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n@@ -471,7 +472,7 @@ fn check_opaque_meets_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n     match origin {\n         // Checked when type checking the function containing them.\n@@ -492,38 +493,34 @@ fn check_opaque_meets_bounds<'tcx>(\n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n-        id.def_id,\n-        tcx.def_path_str(id.def_id.to_def_id())\n+        id.owner_id,\n+        tcx.def_path_str(id.owner_id.to_def_id())\n     );\n     let _indenter = indenter();\n-    match tcx.def_kind(id.def_id) {\n+    match tcx.def_kind(id.owner_id) {\n         DefKind::Static(..) => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n-            maybe_check_static_with_link_section(tcx, id.def_id.def_id);\n-            check_static_inhabited(tcx, id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.owner_id.def_id);\n+            check_static_inhabited(tcx, id.owner_id.def_id);\n         }\n         DefKind::Const => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n-                return;\n-            };\n-            check_enum(tcx, &enum_definition.variants, item.def_id.def_id);\n+            check_enum(tcx, id.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::Impl(ref impl_) = it.kind else {\n                 return;\n             };\n-            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n+            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    it.def_id.def_id,\n+                    it.owner_id.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -545,32 +542,32 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n                     hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.def_id);\n+                        let assoc_item = tcx.associated_item(item.owner_id);\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n                             default.span,\n-                            ty::TraitRef { def_id: it.def_id.to_def_id(), substs: trait_substs },\n+                            ty::TraitRef { def_id: it.owner_id.to_def_id(), substs: trait_substs },\n                         );\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         DefKind::Struct => {\n-            check_struct(tcx, id.def_id.def_id);\n+            check_struct(tcx, id.owner_id.def_id);\n         }\n         DefKind::Union => {\n-            check_union(tcx, id.def_id.def_id);\n+            check_union(tcx, id.owner_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n             check_opaque(tcx, id);\n         }\n         DefKind::ImplTraitPlaceholder => {\n-            let parent = tcx.impl_trait_in_trait_parent(id.def_id.to_def_id());\n+            let parent = tcx.impl_trait_in_trait_parent(id.owner_id.to_def_id());\n             // Only check the validity of this opaque type if the function has a default body\n             if let hir::Node::TraitItem(hir::TraitItem {\n                 kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)),\n@@ -581,8 +578,8 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             }\n         }\n         DefKind::TyAlias => {\n-            let pty_ty = tcx.type_of(id.def_id);\n-            let generics = tcx.generics_of(id.def_id);\n+            let pty_ty = tcx.type_of(id.owner_id);\n+            let generics = tcx.generics_of(id.owner_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         DefKind::ForeignMod => {\n@@ -604,7 +601,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = item.id.def_id.def_id;\n+                    let def_id = item.id.owner_id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -659,7 +656,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.def_id.to_def_id());\n+    let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>(\n@@ -746,7 +743,7 @@ fn check_impl_items_against_trait<'tcx>(\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n     for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.def_id);\n+        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n@@ -758,7 +755,7 @@ fn check_impl_items_against_trait<'tcx>(\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n                 let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n-                    impl_item.id.def_id.def_id,\n+                    impl_item.id.owner_id.def_id,\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }\n@@ -1026,7 +1023,7 @@ pub(super) fn check_packed_inner(\n     None\n }\n \n-pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtDef<'tcx>) {\n+pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     if !adt.repr().transparent() {\n         return;\n     }\n@@ -1035,14 +1032,14 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         feature_err(\n             &tcx.sess.parse_sess,\n             sym::transparent_unions,\n-            sp,\n+            tcx.def_span(adt.did()),\n             \"transparent unions are unstable\",\n         )\n         .emit();\n     }\n \n     if adt.variants().len() != 1 {\n-        bad_variant_count(tcx, adt, sp, adt.did());\n+        bad_variant_count(tcx, adt, tcx.def_span(adt.did()), adt.did());\n         if adt.variants().is_empty() {\n             // Don't bother checking the fields. No variants (and thus no fields) exist.\n             return;\n@@ -1103,7 +1100,7 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n         .filter_map(|(span, zst, _align1, _non_exhaustive)| if !zst { Some(span) } else { None });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count >= 2 {\n-        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, tcx.def_span(adt.did()));\n     }\n     let incompatible_zst_fields =\n         field_infos.clone().filter(|(_, _, _, opt)| opt.is_some()).count();\n@@ -1143,20 +1140,19 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n }\n \n #[allow(trivial_numeric_casts)]\n-fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: LocalDefId) {\n+fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n-    let sp = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n \n-    if vs.is_empty() {\n+    if def.variants().is_empty() {\n         if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,\n                 E0084,\n                 \"unsupported representation for zero-variant enum\"\n             )\n-            .span_label(sp, \"zero-variant enum\")\n+            .span_label(tcx.def_span(def_id), \"zero-variant enum\")\n             .emit();\n         }\n     }\n@@ -1167,88 +1163,96 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n             feature_err(\n                 &tcx.sess.parse_sess,\n                 sym::repr128,\n-                sp,\n+                tcx.def_span(def_id),\n                 \"repr with 128-bit type is unstable\",\n             )\n             .emit();\n         }\n     }\n \n-    for v in vs {\n-        if let Some(ref e) = v.disr_expr {\n-            tcx.ensure().typeck(tcx.hir().local_def_id(e.hir_id));\n+    for v in def.variants() {\n+        if let ty::VariantDiscr::Explicit(discr_def_id) = v.discr {\n+            tcx.ensure().typeck(discr_def_id.expect_local());\n         }\n     }\n \n-    if tcx.adt_def(def_id).repr().int.is_none() && tcx.features().arbitrary_enum_discriminant {\n-        let is_unit = |var: &hir::Variant<'_>| matches!(var.data, hir::VariantData::Unit(..));\n+    if def.repr().int.is_none() {\n+        let is_unit = |var: &ty::VariantDef| matches!(var.ctor_kind, CtorKind::Const);\n+        let has_disr = |var: &ty::VariantDef| matches!(var.discr, ty::VariantDiscr::Explicit(_));\n \n-        let has_disr = |var: &hir::Variant<'_>| var.disr_expr.is_some();\n-        let has_non_units = vs.iter().any(|var| !is_unit(var));\n-        let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n-        let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n+        let has_non_units = def.variants().iter().any(|var| !is_unit(var));\n+        let disr_units = def.variants().iter().any(|var| is_unit(&var) && has_disr(&var));\n+        let disr_non_unit = def.variants().iter().any(|var| !is_unit(&var) && has_disr(&var));\n \n         if disr_non_unit || (disr_units && has_non_units) {\n-            let mut err =\n-                struct_span_err!(tcx.sess, sp, E0732, \"`#[repr(inttype)]` must be specified\");\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                tcx.def_span(def_id),\n+                E0732,\n+                \"`#[repr(inttype)]` must be specified\"\n+            );\n             err.emit();\n         }\n     }\n \n-    detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n-\n-    check_transparent(tcx, sp, def);\n+    detect_discriminant_duplicate(tcx, def);\n+    check_transparent(tcx, def);\n }\n \n /// Part of enum check. Given the discriminants of an enum, errors if two or more discriminants are equal\n-fn detect_discriminant_duplicate<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    mut discrs: Vec<(VariantIdx, Discr<'tcx>)>,\n-    vs: &'tcx [hir::Variant<'tcx>],\n-    self_span: Span,\n-) {\n+fn detect_discriminant_duplicate<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>) {\n     // Helper closure to reduce duplicate code. This gets called everytime we detect a duplicate.\n     // Here `idx` refers to the order of which the discriminant appears, and its index in `vs`\n-    let report = |dis: Discr<'tcx>, idx: usize, err: &mut Diagnostic| {\n-        let var = &vs[idx]; // HIR for the duplicate discriminant\n-        let (span, display_discr) = match var.disr_expr {\n-            Some(ref expr) => {\n+    let report = |dis: Discr<'tcx>, idx, err: &mut Diagnostic| {\n+        let var = adt.variant(idx); // HIR for the duplicate discriminant\n+        let (span, display_discr) = match var.discr {\n+            ty::VariantDiscr::Explicit(discr_def_id) => {\n                 // In the case the discriminant is both a duplicate and overflowed, let the user know\n-                if let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n+                if let hir::Node::AnonConst(expr) = tcx.hir().get_by_def_id(discr_def_id.expect_local())\n+                    && let hir::ExprKind::Lit(lit) = &tcx.hir().body(expr.body).value.kind\n                     && let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node\n                     && *lit_value != dis.val\n                 {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n-                // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}` (overflowed from `{lit_value}`)\"))\n                 } else {\n-                    (tcx.hir().span(expr.hir_id), format!(\"`{dis}`\"))\n+                    // Otherwise, format the value as-is\n+                    (tcx.def_span(discr_def_id), format!(\"`{dis}`\"))\n                 }\n             }\n-            None => {\n+            // This should not happen.\n+            ty::VariantDiscr::Relative(0) => (tcx.def_span(var.def_id), format!(\"`{dis}`\")),\n+            ty::VariantDiscr::Relative(distance_to_explicit) => {\n                 // At this point we know this discriminant is a duplicate, and was not explicitly\n                 // assigned by the user. Here we iterate backwards to fetch the HIR for the last\n                 // explicitly assigned discriminant, and letting the user know that this was the\n                 // increment startpoint, and how many steps from there leading to the duplicate\n-                if let Some((n, hir::Variant { span, ident, .. })) =\n-                    vs[..idx].iter().rev().enumerate().find(|v| v.1.disr_expr.is_some())\n+                if let Some(explicit_idx) =\n+                    idx.as_u32().checked_sub(distance_to_explicit).map(VariantIdx::from_u32)\n                 {\n-                    let ve_ident = var.ident;\n-                    let n = n + 1;\n-                    let sp = if n > 1 { \"variants\" } else { \"variant\" };\n+                    let explicit_variant = adt.variant(explicit_idx);\n+                    let ve_ident = var.name;\n+                    let ex_ident = explicit_variant.name;\n+                    let sp = if distance_to_explicit > 1 { \"variants\" } else { \"variant\" };\n \n                     err.span_label(\n-                        *span,\n-                        format!(\"discriminant for `{ve_ident}` incremented from this startpoint (`{ident}` + {n} {sp} later => `{ve_ident}` = {dis})\"),\n+                        tcx.def_span(explicit_variant.def_id),\n+                        format!(\n+                            \"discriminant for `{ve_ident}` incremented from this startpoint \\\n+                            (`{ex_ident}` + {distance_to_explicit} {sp} later \\\n+                             => `{ve_ident}` = {dis})\"\n+                        ),\n                     );\n                 }\n \n-                (vs[idx].span, format!(\"`{dis}`\"))\n+                (tcx.def_span(var.def_id), format!(\"`{dis}`\"))\n             }\n         };\n \n         err.span_label(span, format!(\"{display_discr} assigned here\"));\n     };\n \n+    let mut discrs = adt.discriminants(tcx).collect::<Vec<_>>();\n+\n     // Here we loop through the discriminants, comparing each discriminant to another.\n     // When a duplicate is detected, we instantiate an error and point to both\n     // initial and duplicate value. The duplicate discriminant is then discarded by swapping\n@@ -1257,29 +1261,29 @@ fn detect_discriminant_duplicate<'tcx>(\n     // style as we are mutating `discrs` on the fly).\n     let mut i = 0;\n     while i < discrs.len() {\n-        let hir_var_i_idx = discrs[i].0.index();\n+        let var_i_idx = discrs[i].0;\n         let mut error: Option<DiagnosticBuilder<'_, _>> = None;\n \n         let mut o = i + 1;\n         while o < discrs.len() {\n-            let hir_var_o_idx = discrs[o].0.index();\n+            let var_o_idx = discrs[o].0;\n \n             if discrs[i].1.val == discrs[o].1.val {\n                 let err = error.get_or_insert_with(|| {\n                     let mut ret = struct_span_err!(\n                         tcx.sess,\n-                        self_span,\n+                        tcx.def_span(adt.did()),\n                         E0081,\n                         \"discriminant value `{}` assigned more than once\",\n                         discrs[i].1,\n                     );\n \n-                    report(discrs[i].1, hir_var_i_idx, &mut ret);\n+                    report(discrs[i].1, var_i_idx, &mut ret);\n \n                     ret\n                 });\n \n-                report(discrs[o].1, hir_var_o_idx, err);\n+                report(discrs[o].1, var_o_idx, err);\n \n                 // Safe to unwrap here, as we wouldn't reach this point if `discrs` was empty\n                 discrs[o] = *discrs.last().unwrap();"}, {"sha": "7c99896b4571427d08543e8031e4ab20b99e30b8", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 171, "deletions": 139, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,22 +1,23 @@\n use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{self, TyCtxtInferExt};\n+use rustc_infer::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::util::ExplicitSelf;\n-use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n-    self, AssocItem, DefIdTree, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n+    self, AssocItem, DefIdTree, TraitRef, Ty, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n };\n+use rustc_middle::ty::{FnSig, InternalSubsts};\n use rustc_middle::ty::{GenericParamDefKind, ToPredicate, TyCtxt};\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -256,7 +257,7 @@ fn compare_predicate_entailment<'tcx>(\n     // Compute placeholder form of impl and trait method tys.\n     let tcx = infcx.tcx;\n \n-    let mut wf_tys = FxHashSet::default();\n+    let mut wf_tys = FxIndexSet::default();\n \n     let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n         impl_m_span,\n@@ -290,129 +291,39 @@ fn compare_predicate_entailment<'tcx>(\n     // type would be more appropriate. In other places we have a `Vec<Span>`\n     // corresponding to their `Vec<Predicate>`, but we don't have that here.\n     // Fixing this would improve the output of test `issue-83765.rs`.\n-    let mut result = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_fty, impl_fty)\n-        .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok));\n+    let mut result = ocx.sup(&cause, param_env, trait_fty, impl_fty);\n \n     // HACK(RPITIT): #101614. When we are trying to infer the hidden types for\n     // RPITITs, we need to equate the output tys instead of just subtyping. If\n     // we just use `sup` above, we'll end up `&'static str <: _#1t`, which causes\n     // us to infer `_#1t = #'_#2r str`, where `'_#2r` is unconstrained, which gets\n     // fixed up to `ReEmpty`, and which is certainly not what we want.\n     if trait_fty.has_infer_types() {\n-        result = result.and_then(|()| {\n-            infcx\n-                .at(&cause, param_env)\n-                .eq(trait_sig.output(), impl_sig.output())\n-                .map(|infer_ok| ocx.register_infer_ok_obligations(infer_ok))\n-        });\n+        result =\n+            result.and_then(|()| ocx.eq(&cause, param_env, trait_sig.output(), impl_sig.output()));\n     }\n \n     if let Err(terr) = result {\n-        debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n-\n-        let (impl_err_span, trait_err_span) =\n-            extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n-\n-        cause.span = impl_err_span;\n-\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            cause.span(),\n-            E0053,\n-            \"method `{}` has an incompatible type for trait\",\n-            trait_m.name\n-        );\n-        match &terr {\n-            TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n-                if trait_m.fn_has_self_parameter =>\n-            {\n-                let ty = trait_sig.inputs()[0];\n-                let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n-                    ExplicitSelf::ByValue => \"self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n-                    ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n-                    _ => format!(\"self: {ty}\"),\n-                };\n+        debug!(?terr, \"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-                // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n-                // span points only at the type `Box<Self`>, but we want to cover the whole\n-                // argument pattern and type.\n-                let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                    ImplItemKind::Fn(ref sig, body) => tcx\n-                        .hir()\n-                        .body_param_names(body)\n-                        .zip(sig.decl.inputs.iter())\n-                        .map(|(param, ty)| param.span.to(ty.span))\n-                        .next()\n-                        .unwrap_or(impl_err_span),\n-                    _ => bug!(\"{:?} is not a method\", impl_m),\n-                };\n-\n-                diag.span_suggestion(\n-                    span,\n-                    \"change the self-receiver type to match the trait\",\n-                    sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n-                if trait_sig.inputs().len() == *i {\n-                    // Suggestion to change output type. We do not suggest in `async` functions\n-                    // to avoid complex logic or incorrect output.\n-                    match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n-                        ImplItemKind::Fn(ref sig, _)\n-                            if sig.header.asyncness == hir::IsAsync::NotAsync =>\n-                        {\n-                            let msg = \"change the output type to match the trait\";\n-                            let ap = Applicability::MachineApplicable;\n-                            match sig.decl.output {\n-                                hir::FnRetTy::DefaultReturn(sp) => {\n-                                    let sugg = format!(\"-> {} \", trait_sig.output());\n-                                    diag.span_suggestion_verbose(sp, msg, sugg, ap);\n-                                }\n-                                hir::FnRetTy::Return(hir_ty) => {\n-                                    let sugg = trait_sig.output();\n-                                    diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n-                                }\n-                            };\n-                        }\n-                        _ => {}\n-                    };\n-                } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n-                    diag.span_suggestion(\n-                        impl_err_span,\n-                        \"change the parameter type to match the trait\",\n-                        trait_ty,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        infcx.err_ctxt().note_type_err(\n-            &mut diag,\n-            &cause,\n-            trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n-            Some(infer::ValuePairs::Terms(ExpectedFound {\n-                expected: trait_fty.into(),\n-                found: impl_fty.into(),\n-            })),\n+        let emitted = report_trait_method_mismatch(\n+            tcx,\n+            &mut cause,\n+            &infcx,\n             terr,\n-            false,\n-            false,\n+            (trait_m, trait_fty),\n+            (impl_m, impl_fty),\n+            &trait_sig,\n+            &impl_trait_ref,\n         );\n-\n-        return Err(diag.emit());\n+        return Err(emitted);\n     }\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -431,6 +342,7 @@ fn compare_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn collect_trait_impl_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n@@ -444,7 +356,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n \n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let return_span = tcx.hir().fn_decl_by_hir_id(impl_m_hir_id).unwrap().output.span();\n-    let cause = ObligationCause::new(\n+    let mut cause = ObligationCause::new(\n         return_span,\n         impl_m_hir_id,\n         ObligationCauseCode::CompareImplItemObligation {\n@@ -486,7 +398,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let trait_sig = ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_sig);\n     let trait_return_ty = trait_sig.output();\n \n-    let wf_tys = FxHashSet::from_iter(\n+    let wf_tys = FxIndexSet::from_iter(\n         unnormalized_trait_sig.inputs_and_output.iter().chain(trait_sig.inputs_and_output.iter()),\n     );\n \n@@ -521,31 +433,43 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n         }\n     }\n \n+    debug!(?trait_sig, ?impl_sig, \"equating function signatures\");\n+\n+    let trait_fty = tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig));\n+    let impl_fty = tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig));\n+\n     // Unify the whole function signature. We need to do this to fully infer\n     // the lifetimes of the return type, but do this after unifying just the\n     // return types, since we want to avoid duplicating errors from\n     // `compare_predicate_entailment`.\n-    match infcx\n-        .at(&cause, param_env)\n-        .eq(tcx.mk_fn_ptr(ty::Binder::dummy(trait_sig)), tcx.mk_fn_ptr(ty::Binder::dummy(impl_sig)))\n-    {\n+    match infcx.at(&cause, param_env).eq(trait_fty, impl_fty) {\n         Ok(infer::InferOk { value: (), obligations }) => {\n             ocx.register_obligations(obligations);\n         }\n         Err(terr) => {\n-            let guar = tcx.sess.delay_span_bug(\n-                return_span,\n-                format!(\"could not unify `{trait_sig}` and `{impl_sig}`: {terr:?}\"),\n+            // This function gets called during `compare_predicate_entailment` when normalizing a\n+            // signature that contains RPITIT. When the method signatures don't match, we have to\n+            // emit an error now because `compare_predicate_entailment` will not report the error\n+            // when normalization fails.\n+            let emitted = report_trait_method_mismatch(\n+                tcx,\n+                &mut cause,\n+                infcx,\n+                terr,\n+                (trait_m, trait_fty),\n+                (impl_m, impl_fty),\n+                &trait_sig,\n+                &impl_trait_ref,\n             );\n-            return Err(guar);\n+            return Err(emitted);\n         }\n     }\n \n     // Check that all obligations are satisfied by the implementation's\n     // RPITs.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -597,9 +521,17 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                 let num_trait_substs = trait_to_impl_substs.len();\n                 let num_impl_substs = tcx.generics_of(impl_m.container_id(tcx)).params.len();\n                 let ty = tcx.fold_regions(ty, |region, _| {\n-                    let ty::ReFree(_) = region.kind() else { return region; };\n-                    let ty::ReEarlyBound(e) = map[&region.into()].expect_region().kind()\n-                        else { bug!(\"expected ReFree to map to ReEarlyBound\"); };\n+                    let (ty::ReFree(_) | ty::ReEarlyBound(_)) = region.kind() else { return region; };\n+                    let Some(ty::ReEarlyBound(e)) = map.get(&region.into()).map(|r| r.expect_region().kind())\n+                    else {\n+                        tcx\n+                            .sess\n+                            .delay_span_bug(\n+                                return_span,\n+                                \"expected ReFree to map to ReEarlyBound\"\n+                            );\n+                        return tcx.lifetimes.re_static;\n+                    };\n                     tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                         def_id: e.def_id,\n                         name: e.name,\n@@ -610,11 +542,11 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                 collected_tys.insert(def_id, ty);\n             }\n             Err(err) => {\n-                tcx.sess.delay_span_bug(\n+                let reported = tcx.sess.delay_span_bug(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, tcx.ty_error());\n+                collected_tys.insert(def_id, tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }\n@@ -689,6 +621,112 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n     }\n }\n \n+fn report_trait_method_mismatch<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    cause: &mut ObligationCause<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    terr: TypeError<'tcx>,\n+    (trait_m, trait_fty): (&AssocItem, Ty<'tcx>),\n+    (impl_m, impl_fty): (&AssocItem, Ty<'tcx>),\n+    trait_sig: &FnSig<'tcx>,\n+    impl_trait_ref: &TraitRef<'tcx>,\n+) -> ErrorGuaranteed {\n+    let (impl_err_span, trait_err_span) =\n+        extract_spans_for_error_reporting(&infcx, terr, &cause, impl_m, trait_m);\n+\n+    cause.span = impl_err_span;\n+\n+    let mut diag = struct_span_err!(\n+        tcx.sess,\n+        cause.span(),\n+        E0053,\n+        \"method `{}` has an incompatible type for trait\",\n+        trait_m.name\n+    );\n+    match &terr {\n+        TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+            if trait_m.fn_has_self_parameter =>\n+        {\n+            let ty = trait_sig.inputs()[0];\n+            let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty()) {\n+                ExplicitSelf::ByValue => \"self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mut) => \"&mut self\".to_owned(),\n+                _ => format!(\"self: {ty}\"),\n+            };\n+\n+            // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+            // span points only at the type `Box<Self`>, but we want to cover the whole\n+            // argument pattern and type.\n+            let span = match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                ImplItemKind::Fn(ref sig, body) => tcx\n+                    .hir()\n+                    .body_param_names(body)\n+                    .zip(sig.decl.inputs.iter())\n+                    .map(|(param, ty)| param.span.to(ty.span))\n+                    .next()\n+                    .unwrap_or(impl_err_span),\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n+            };\n+\n+            diag.span_suggestion(\n+                span,\n+                \"change the self-receiver type to match the trait\",\n+                sugg,\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+            if trait_sig.inputs().len() == *i {\n+                // Suggestion to change output type. We do not suggest in `async` functions\n+                // to avoid complex logic or incorrect output.\n+                match tcx.hir().expect_impl_item(impl_m.def_id.expect_local()).kind {\n+                    ImplItemKind::Fn(ref sig, _)\n+                        if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                    {\n+                        let msg = \"change the output type to match the trait\";\n+                        let ap = Applicability::MachineApplicable;\n+                        match sig.decl.output {\n+                            hir::FnRetTy::DefaultReturn(sp) => {\n+                                let sugg = format!(\"-> {} \", trait_sig.output());\n+                                diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                            }\n+                            hir::FnRetTy::Return(hir_ty) => {\n+                                let sugg = trait_sig.output();\n+                                diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                            }\n+                        };\n+                    }\n+                    _ => {}\n+                };\n+            } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n+                diag.span_suggestion(\n+                    impl_err_span,\n+                    \"change the parameter type to match the trait\",\n+                    trait_ty,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    infcx.err_ctxt().note_type_err(\n+        &mut diag,\n+        &cause,\n+        trait_err_span.map(|sp| (sp, \"type in trait\".to_owned())),\n+        Some(infer::ValuePairs::Terms(ExpectedFound {\n+            expected: trait_fty.into(),\n+            found: impl_fty.into(),\n+        })),\n+        terr,\n+        false,\n+        false,\n+    );\n+\n+    return diag.emit();\n+}\n+\n fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n@@ -1381,10 +1419,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n \n     debug!(\"compare_const_impl: trait_ty={:?}\", trait_ty);\n \n-    let err = infcx\n-        .at(&cause, param_env)\n-        .sup(trait_ty, impl_ty)\n-        .map(|ok| ocx.register_infer_ok_obligations(ok));\n+    let err = ocx.sup(&cause, param_env, trait_ty, impl_ty);\n \n     if let Err(terr) = err {\n         debug!(\n@@ -1433,7 +1468,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None));\n     }\n \n     // FIXME return `ErrorReported` if region obligations error?\n@@ -1551,7 +1586,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -1657,13 +1692,10 @@ pub fn check_type_bounds<'tcx>(\n         GenericParamDefKind::Const { .. } => {\n             let bound_var = ty::BoundVariableKind::Const;\n             bound_vars.push(bound_var);\n-            tcx.mk_const(ty::ConstS {\n-                ty: tcx.type_of(param.def_id),\n-                kind: ty::ConstKind::Bound(\n-                    ty::INNERMOST,\n-                    ty::BoundVar::from_usize(bound_vars.len() - 1),\n-                ),\n-            })\n+            tcx.mk_const(\n+                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n+                tcx.type_of(param.def_id),\n+            )\n             .into()\n         }\n     });\n@@ -1774,7 +1806,7 @@ pub fn check_type_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n "}, {"sha": "69e54b41d4c04331081c51aaa179e1bf75f00441", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -26,7 +26,7 @@ fn equate_intrinsic_type<'tcx>(\n ) {\n     let (own_counts, span) = match &it.kind {\n         hir::ForeignItemKind::Fn(.., generics) => {\n-            let own_counts = tcx.generics_of(it.def_id.to_def_id()).own_counts();\n+            let own_counts = tcx.generics_of(it.owner_id.to_def_id()).own_counts();\n             (own_counts, generics.span)\n         }\n         _ => {\n@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'tcx>(\n     {\n         let fty = tcx.mk_fn_ptr(sig);\n         let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n-        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.def_id)), fty);\n+        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id)), fty);\n     }\n }\n \n@@ -129,20 +129,23 @@ pub fn intrinsic_operation_unsafety(tcx: TyCtxt<'_>, intrinsic_id: DefId) -> hir\n /// and in `library/core/src/intrinsics.rs`.\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let intrinsic_id = it.def_id.to_def_id();\n+    let intrinsic_id = it.owner_id.to_def_id();\n     let intrinsic_name = tcx.item_name(intrinsic_id);\n     let name_str = intrinsic_name.as_str();\n \n     let bound_vars = tcx.mk_bound_variable_kinds(\n-        [ty::BoundVariableKind::Region(ty::BrAnon(0)), ty::BoundVariableKind::Region(ty::BrEnv)]\n-            .iter()\n-            .copied(),\n+        [\n+            ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n+            ty::BoundVariableKind::Region(ty::BrEnv),\n+        ]\n+        .iter()\n+        .copied(),\n     );\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n             let region = tcx.mk_region(ty::ReLateBound(\n                 ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) },\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) },\n             ));\n             let env_region = tcx.mk_region(ty::ReLateBound(\n                 ty::INNERMOST,\n@@ -364,7 +367,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 );\n                 let discriminant_def_id = assoc_items[0];\n \n-                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let br =\n+                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n                 (\n                     1,\n                     vec![\n@@ -418,7 +422,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             sym::raw_eq => {\n-                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let br =\n+                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n                 let param_ty =\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0));\n                 (1, vec![param_ty; 2], tcx.types.bool)"}, {"sha": "17c4d0d482f2ab0b2a72e58c27aad8717f3decff", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx, self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));"}, {"sha": "837ff0bdf3e35401f38db801d96d286d0b67874a", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 101, "deletions": 123, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,7 @@\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n use hir::def::DefKind;\n use rustc_ast as ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -21,6 +21,7 @@ use rustc_middle::ty::{GenericArgKind, InternalSubsts};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n@@ -104,7 +105,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     f(&mut wfcx);\n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return;\n     }\n \n@@ -116,7 +117,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n }\n \n fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n-    let node = tcx.hir().expect_owner(def_id);\n+    let node = tcx.hir().owner(def_id);\n     match node {\n         hir::OwnerNode::Crate(_) => {}\n         hir::OwnerNode::Item(item) => check_item(tcx, item),\n@@ -147,10 +148,10 @@ fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n /// the types first.\n #[instrument(skip(tcx), level = \"debug\")]\n fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -218,19 +219,16 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, def_id, ty.span, false);\n         }\n-        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, false, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Struct(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, false);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| vec![wfcx.non_enum_variant(struct_def)]);\n-\n+        hir::ItemKind::Union(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n-            check_type_defn(tcx, item, true, |wfcx| wfcx.enum_variants(enum_def));\n-\n+        hir::ItemKind::Enum(_, ref ast_generics) => {\n+            check_type_defn(tcx, item, true);\n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n         hir::ItemKind::Trait(..) => {\n@@ -246,10 +244,10 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n }\n \n fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -263,7 +261,7 @@ fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n }\n \n fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n-    let def_id = trait_item.def_id.def_id;\n+    let def_id = trait_item.owner_id.def_id;\n \n     let (method_sig, span) = match trait_item.kind {\n         hir::TraitItemKind::Fn(ref sig, _) => (Some(sig), trait_item.span),\n@@ -275,7 +273,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n \n     let encl_trait_def_id = tcx.local_parent(def_id);\n     let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n-    let encl_trait_def_id = encl_trait.def_id.to_def_id();\n+    let encl_trait_def_id = encl_trait.owner_id.to_def_id();\n     let fn_lang_item_name = if Some(encl_trait_def_id) == tcx.lang_items().fn_trait() {\n         Some(\"fn\")\n     } else if Some(encl_trait_def_id) == tcx.lang_items().fn_mut_trait() {\n@@ -348,7 +346,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n     loop {\n         let mut should_continue = false;\n         for gat_item in associated_items {\n-            let gat_def_id = gat_item.id.def_id;\n+            let gat_def_id = gat_item.id.owner_id;\n             let gat_item = tcx.associated_item(gat_def_id);\n             // If this item is not an assoc ty, or has no substs, then it's not a GAT\n             if gat_item.kind != ty::AssocKind::Type {\n@@ -365,7 +363,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             // constrains the GAT with individually.\n             let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n             for item in associated_items {\n-                let item_def_id = item.id.def_id;\n+                let item_def_id = item.id.owner_id;\n                 // Skip our own GAT, since it does not constrain itself at all.\n                 if item_def_id == gat_def_id {\n                     continue;\n@@ -414,7 +412,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                                 .iter()\n                                 .copied()\n                                 .collect::<Vec<_>>(),\n-                            &FxHashSet::default(),\n+                            &FxIndexSet::default(),\n                             gat_def_id.def_id,\n                             gat_generics,\n                         )\n@@ -464,10 +462,10 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n+                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n+                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n@@ -549,7 +547,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     param_env: ty::ParamEnv<'tcx>,\n     item_hir: hir::HirId,\n     to_check: T,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     gat_def_id: LocalDefId,\n     gat_generics: &'tcx ty::Generics,\n ) -> Option<FxHashSet<ty::Predicate<'tcx>>> {\n@@ -656,7 +654,7 @@ fn ty_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     ty: Ty<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> bool {\n@@ -673,7 +671,7 @@ fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n     region_b: ty::Region<'tcx>,\n ) -> bool {\n@@ -697,7 +695,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'tcx>, &'a RegionBoundPairs<'tcx>),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n@@ -713,6 +711,10 @@ fn resolve_regions_with_wf_tys<'tcx>(\n \n     add_constraints(&infcx, region_bound_pairs);\n \n+    infcx.process_registered_region_obligations(\n+        outlives_environment.region_bound_pairs(),\n+        param_env,\n+    );\n     let errors = infcx.resolve_regions(&outlives_environment);\n \n     debug!(?errors, \"errors\");\n@@ -786,7 +788,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     let (trait_name, trait_def_id) =\n         match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id()).def_id) {\n             hir::Node::Item(item) => match item.kind {\n-                hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n+                hir::ItemKind::Trait(..) => (item.ident, item.owner_id),\n                 _ => return,\n             },\n             _ => return,\n@@ -841,7 +843,7 @@ fn check_impl_item(tcx: TyCtxt<'_>, impl_item: &hir::ImplItem<'_>) {\n         _ => (None, impl_item.span),\n     };\n \n-    check_associated_item(tcx, impl_item.def_id.def_id, span, method_sig);\n+    check_associated_item(tcx, impl_item.owner_id.def_id, span, method_sig);\n }\n \n fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n@@ -1033,43 +1035,41 @@ fn item_adt_kind(kind: &ItemKind<'_>) -> Option<AdtKind> {\n }\n \n /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-fn check_type_defn<'tcx, F>(\n-    tcx: TyCtxt<'tcx>,\n-    item: &hir::Item<'tcx>,\n-    all_sized: bool,\n-    mut lookup_fields: F,\n-) where\n-    F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n-{\n-    let _ = tcx.representability(item.def_id.def_id);\n+fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: bool) {\n+    let _ = tcx.representability(item.owner_id.def_id);\n+    let adt_def = tcx.adt_def(item.owner_id);\n \n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n-        let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.def_id).repr().packed();\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n+        let variants = adt_def.variants();\n+        let packed = adt_def.repr().packed();\n \n-        for variant in &variants {\n+        for variant in variants.iter() {\n             // All field types must be well-formed.\n             for field in &variant.fields {\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_wf_obligation(\n-                    field.span,\n-                    Some(WellFormedLoc::Ty(field.def_id)),\n-                    field.ty.into(),\n+                    hir_ty.span,\n+                    Some(WellFormedLoc::Ty(field_id)),\n+                    ty.into(),\n                 )\n             }\n \n             // For DST, or when drop needs to copy things around, all\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = tcx.type_of(variant.fields.last().unwrap().did);\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(tcx, tcx.param_env(item.def_id))\n+                        ty.needs_drop(tcx, tcx.param_env(item.owner_id))\n                     }\n                 }\n             };\n@@ -1080,27 +1080,31 @@ fn check_type_defn<'tcx, F>(\n                 variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n+                let field_id = field.did.expect_local();\n+                let hir::Node::Field(hir::FieldDef { ty: hir_ty, .. }) = tcx.hir().get_by_def_id(field_id)\n+                else { bug!() };\n+                let ty = wfcx.normalize(hir_ty.span, None, tcx.type_of(field.did));\n                 wfcx.register_bound(\n                     traits::ObligationCause::new(\n-                        field.span,\n+                        hir_ty.span,\n                         wfcx.body_id,\n                         traits::FieldSized {\n                             adt_kind: match item_adt_kind(&item.kind) {\n                                 Some(i) => i,\n                                 None => bug!(),\n                             },\n-                            span: field.span,\n+                            span: hir_ty.span,\n                             last,\n                         },\n                     ),\n                     wfcx.param_env,\n-                    field.ty,\n+                    ty,\n                     tcx.require_lang_item(LangItem::Sized, None),\n                 );\n             }\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n-            if let Some(discr_def_id) = variant.explicit_discr {\n+            if let ty::VariantDiscr::Explicit(discr_def_id) = variant.discr {\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1110,22 +1114,22 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::Const::from_anon_const(tcx, discr_def_id),\n+                        ty::Const::from_anon_const(tcx, discr_def_id.expect_local()),\n                     ))\n                     .to_predicate(tcx),\n                 ));\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n #[instrument(skip(tcx, item))]\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(?item.def_id);\n+    debug!(?item.owner_id);\n \n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n     let trait_def = tcx.trait_def(def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n@@ -1236,13 +1240,13 @@ fn check_impl<'tcx>(\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n     constness: hir::Constness,\n ) {\n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap();\n                 let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n                 let trait_pred = ty::TraitPredicate {\n                     trait_ref,\n@@ -1264,7 +1268,7 @@ fn check_impl<'tcx>(\n                 wfcx.register_obligations(obligations);\n             }\n             None => {\n-                let self_ty = tcx.type_of(item.def_id);\n+                let self_ty = tcx.type_of(item.owner_id);\n                 let self_ty = wfcx.normalize(\n                     item.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n@@ -1278,7 +1282,7 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n@@ -1539,6 +1543,33 @@ fn check_fn_or_method<'tcx>(\n         sig.output(),\n         hir_decl.output.span(),\n     );\n+\n+    if sig.abi == Abi::RustCall {\n+        let span = tcx.def_span(def_id);\n+        let has_implicit_self = hir_decl.implicit_self != hir::ImplicitSelfKind::None;\n+        let mut inputs = sig.inputs().iter().skip(if has_implicit_self { 1 } else { 0 });\n+        // Check that the argument is a tuple\n+        if let Some(ty) = inputs.next() {\n+            wfcx.register_bound(\n+                ObligationCause::new(span, wfcx.body_id, ObligationCauseCode::RustCall),\n+                wfcx.param_env,\n+                *ty,\n+                tcx.require_lang_item(hir::LangItem::Tuple, Some(span)),\n+            );\n+        } else {\n+            tcx.sess.span_err(\n+                hir_decl.inputs.last().map_or(span, |input| input.span),\n+                \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+            );\n+        }\n+        // No more inputs other than the `self` type and the tuple type\n+        if inputs.next().is_some() {\n+            tcx.sess.span_err(\n+                hir_decl.inputs.last().map_or(span, |input| input.span),\n+                \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+            );\n+        }\n+    }\n }\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be\n@@ -1671,14 +1702,13 @@ fn receiver_is_valid<'tcx>(\n \n     // `self: Self` is always valid.\n     if can_eq_self(receiver_ty) {\n-        if let Err(err) = wfcx.equate_types(&cause, wfcx.param_env, self_ty, receiver_ty) {\n+        if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, receiver_ty) {\n             infcx.err_ctxt().report_mismatched_types(&cause, self_ty, receiver_ty, err).emit();\n         }\n         return true;\n     }\n \n-    let mut autoderef =\n-        Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty, span);\n+    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {\n@@ -1701,9 +1731,7 @@ fn receiver_is_valid<'tcx>(\n             if can_eq_self(potential_self_ty) {\n                 wfcx.register_obligations(autoderef.into_obligations());\n \n-                if let Err(err) =\n-                    wfcx.equate_types(&cause, wfcx.param_env, self_ty, potential_self_ty)\n-                {\n+                if let Err(err) = wfcx.eq(&cause, wfcx.param_env, self_ty, potential_self_ty) {\n                     infcx\n                         .err_ctxt()\n                         .report_mismatched_types(&cause, self_ty, potential_self_ty, err)\n@@ -1774,14 +1802,14 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let ty = tcx.type_of(item.def_id);\n+    let ty = tcx.type_of(item.owner_id);\n     if tcx.has_error_field(ty) {\n         return;\n     }\n \n-    let ty_predicates = tcx.predicates_of(item.def_id);\n+    let ty_predicates = tcx.predicates_of(item.owner_id);\n     assert_eq!(ty_predicates.parent, None);\n-    let variances = tcx.variances_of(item.def_id);\n+    let variances = tcx.variances_of(item.owner_id);\n \n     let mut constrained_parameters: FxHashSet<_> = variances\n         .iter()\n@@ -1794,7 +1822,7 @@ fn check_variances_for_type_defn<'tcx>(\n \n     // Lazily calculated because it is only needed in case of an error.\n     let explicitly_bounded_params = LazyCell::new(|| {\n-        let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n+        let icx = crate::collect::ItemCtxt::new(tcx, item.owner_id.to_def_id());\n         hir_generics\n             .predicates\n             .iter()\n@@ -1915,60 +1943,10 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let items = tcx.hir_module_items(module);\n-    items.par_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// ADT\n-\n-// FIXME(eddyb) replace this with getting fields/discriminants through `ty::AdtDef`.\n-struct AdtVariant<'tcx> {\n-    /// Types of fields in the variant, that must be well-formed.\n-    fields: Vec<AdtField<'tcx>>,\n-\n-    /// Explicit discriminant of this variant (e.g. `A = 123`),\n-    /// that must evaluate to a constant value.\n-    explicit_discr: Option<LocalDefId>,\n-}\n-\n-struct AdtField<'tcx> {\n-    ty: Ty<'tcx>,\n-    def_id: LocalDefId,\n-    span: Span,\n-}\n-\n-impl<'a, 'tcx> WfCheckingCtxt<'a, 'tcx> {\n-    // FIXME(eddyb) replace this with getting fields through `ty::AdtDef`.\n-    fn non_enum_variant(&self, struct_def: &hir::VariantData<'_>) -> AdtVariant<'tcx> {\n-        let fields = struct_def\n-            .fields()\n-            .iter()\n-            .map(|field| {\n-                let def_id = self.tcx().hir().local_def_id(field.hir_id);\n-                let field_ty = self.tcx().type_of(def_id);\n-                let field_ty = self.normalize(field.ty.span, None, field_ty);\n-                debug!(\"non_enum_variant: type of field {:?} is {:?}\", field, field_ty);\n-                AdtField { ty: field_ty, span: field.ty.span, def_id }\n-            })\n-            .collect();\n-        AdtVariant { fields, explicit_discr: None }\n-    }\n-\n-    fn enum_variants(&self, enum_def: &hir::EnumDef<'_>) -> Vec<AdtVariant<'tcx>> {\n-        enum_def\n-            .variants\n-            .iter()\n-            .map(|variant| AdtVariant {\n-                fields: self.non_enum_variant(&variant.data).fields,\n-                explicit_discr: variant\n-                    .disr_expr\n-                    .map(|explicit_discr| self.tcx().hir().local_def_id(explicit_discr.hir_id)),\n-            })\n-            .collect()\n-    }\n+    items.par_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n fn error_392("}, {"sha": "d0c31733481b63ef24e1f5a2e9cc54d37a6a03c9", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,5 +1,6 @@\n use crate::errors::{ExternCrateNotIdiomatic, UnusedExternCrate};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::unord::UnordSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -8,12 +9,12 @@ use rustc_session::lint;\n use rustc_span::{Span, Symbol};\n \n pub fn check_crate(tcx: TyCtxt<'_>) {\n-    let mut used_trait_imports: FxHashSet<LocalDefId> = FxHashSet::default();\n+    let mut used_trait_imports: UnordSet<LocalDefId> = Default::default();\n \n     for item_def_id in tcx.hir().body_owners() {\n         let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n-        used_trait_imports.extend(imports.iter());\n+        used_trait_imports.extend(imports.items().copied());\n     }\n \n     for &id in tcx.maybe_unused_trait_imports(()) {\n@@ -89,11 +90,11 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let mut crates_to_lint = vec![];\n \n     for id in tcx.hir().items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::ExternCrate) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::ExternCrate) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n                 crates_to_lint.push(ExternCrateToLint {\n-                    def_id: item.def_id.to_def_id(),\n+                    def_id: item.owner_id.to_def_id(),\n                     span: item.span,\n                     orig_name,\n                     warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "6f74ef3ccad6d75684c5576e5861fb83ac38425f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -321,7 +321,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     }),\n                 );\n                 if !errors.is_empty() {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                 }\n \n                 // Finally, resolve all regions.\n@@ -561,7 +561,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n \n     // Finally, resolve all regions."}, {"sha": "2890c149b3afe3f2ac1eba2ecc37a438e9824e75", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -58,7 +58,7 @@ const ADD_ATTR: &str =\n \n impl<'tcx> InherentCollect<'tcx> {\n     fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId) {\n-        let impl_def_id = item.def_id;\n+        let impl_def_id = item.owner_id;\n         if let Some(def_id) = def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n@@ -89,7 +89,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             for impl_item in items {\n                 if !self\n                     .tcx\n-                    .has_attr(impl_item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                 {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -135,7 +135,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 for item in items {\n                     if !self\n                         .tcx\n-                        .has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                     {\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -177,7 +177,7 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.def_id), DefKind::Impl) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl) {\n             return;\n         }\n \n@@ -186,7 +186,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             return;\n         };\n \n-        let self_ty = self.tcx.type_of(item.def_id);\n+        let self_ty = self.tcx.type_of(item.owner_id);\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, self_ty, def.did());\n@@ -221,7 +221,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Never\n             | ty::FnPtr(_)\n             | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.def_id.def_id, self_ty, items, ty.span)\n+                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n             ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n@@ -243,7 +243,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}, {"sha": "972769eb1970735f7736ddf7168f94ac51072fa8", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -156,14 +156,14 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        let def_kind = self.tcx.def_kind(id.def_id);\n+        let def_kind = self.tcx.def_kind(id.owner_id);\n         if !matches!(def_kind, DefKind::Enum | DefKind::Struct | DefKind::Trait | DefKind::Union) {\n             return;\n         }\n \n-        let impls = self.tcx.inherent_impls(id.def_id);\n+        let impls = self.tcx.inherent_impls(id.owner_id);\n \n-        let overlap_mode = OverlapMode::get(self.tcx, id.def_id.to_def_id());\n+        let overlap_mode = OverlapMode::get(self.tcx, id.owner_id.to_def_id());\n \n         let impls_items = impls\n             .iter()"}, {"sha": "1bf3768fead3619f9fb5781cb8f9314c21f6e256", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 50, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -5,10 +5,11 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::{error_code, struct_span_err};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_span::sym;\n use rustc_trait_selection::traits;\n \n mod builtin;\n@@ -39,61 +40,26 @@ fn enforce_trait_manually_implementable(\n     impl_def_id: LocalDefId,\n     trait_def_id: DefId,\n ) {\n-    let did = Some(trait_def_id);\n-    let li = tcx.lang_items();\n     let impl_header_span = tcx.def_span(impl_def_id);\n \n-    // Disallow *all* explicit impls of `Pointee`, `DiscriminantKind`, `Sized` and `Unsize` for now.\n-    if did == li.pointee_trait() {\n-        struct_span_err!(\n+    // Disallow *all* explicit impls of traits marked `#[rustc_deny_explicit_impl]`\n+    if tcx.has_attr(trait_def_id, sym::rustc_deny_explicit_impl) {\n+        let trait_name = tcx.item_name(trait_def_id);\n+        let mut err = struct_span_err!(\n             tcx.sess,\n             impl_header_span,\n             E0322,\n-            \"explicit impls for the `Pointee` trait are not permitted\"\n-        )\n-        .span_label(impl_header_span, \"impl of `Pointee` not allowed\")\n-        .emit();\n-        return;\n-    }\n-\n-    if did == li.discriminant_kind_trait() {\n-        struct_span_err!(\n-            tcx.sess,\n-            impl_header_span,\n-            E0322,\n-            \"explicit impls for the `DiscriminantKind` trait are not permitted\"\n-        )\n-        .span_label(impl_header_span, \"impl of `DiscriminantKind` not allowed\")\n-        .emit();\n-        return;\n-    }\n-\n-    if did == li.sized_trait() {\n-        struct_span_err!(\n-            tcx.sess,\n-            impl_header_span,\n-            E0322,\n-            \"explicit impls for the `Sized` trait are not permitted\"\n-        )\n-        .span_label(impl_header_span, \"impl of `Sized` not allowed\")\n-        .emit();\n-        return;\n-    }\n-\n-    if did == li.unsize_trait() {\n-        struct_span_err!(\n-            tcx.sess,\n-            impl_header_span,\n-            E0328,\n-            \"explicit impls for the `Unsize` trait are not permitted\"\n-        )\n-        .span_label(impl_header_span, \"impl of `Unsize` not allowed\")\n-        .emit();\n-        return;\n-    }\n+            \"explicit impls for the `{trait_name}` trait are not permitted\"\n+        );\n+        err.span_label(impl_header_span, format!(\"impl of `{trait_name}` not allowed\"));\n+\n+        // Maintain explicit error code for `Unsize`, since it has a useful\n+        // explanation about using `CoerceUnsized` instead.\n+        if Some(trait_def_id) == tcx.lang_items().unsize_trait() {\n+            err.code(error_code!(E0328));\n+        }\n \n-    if tcx.features().unboxed_closures {\n-        // the feature gate allows all Fn traits\n+        err.emit();\n         return;\n     }\n "}, {"sha": "71c932d747bca7de4f888e463f175e353c761f1d", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -23,9 +23,7 @@ pub(crate) fn orphan_check_impl(\n     impl_def_id: LocalDefId,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-    if let Some(err) = trait_ref.error_reported() {\n-        return Err(err);\n-    }\n+    trait_ref.error_reported()?;\n \n     let ret = do_orphan_check_impl(tcx, trait_ref, impl_def_id);\n     if tcx.trait_is_auto(trait_ref.def_id) {\n@@ -101,7 +99,7 @@ fn do_orphan_check_impl<'tcx>(\n         span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n     }\n \n-    match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n+    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n             tcx,"}, {"sha": "a34815b45b3adeb7834cc163c66bbd5cbc7257fc", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(def_id);\n     let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n \n-    if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+    if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_def = tcx.trait_def(trait_ref.def_id);\n         let unsafe_attr =\n             impl_.generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\");\n@@ -26,6 +26,12 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"implementing the trait `{}` is not unsafe\",\n                     trait_ref.print_only_trait_path()\n                 )\n+                .span_suggestion_verbose(\n+                    item.span.with_hi(item.span.lo() + rustc_span::BytePos(7)),\n+                    \"remove `unsafe` from this trait implementation\",\n+                    \"\",\n+                    rustc_errors::Applicability::MachineApplicable,\n+                )\n                 .emit();\n             }\n \n@@ -37,6 +43,18 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"the trait `{}` requires an `unsafe impl` declaration\",\n                     trait_ref.print_only_trait_path()\n                 )\n+                .note(format!(\n+                    \"the trait `{}` enforces invariants that the compiler can't check. \\\n+                    Review the trait documentation and make sure this implementation \\\n+                    upholds those invariants before adding the `unsafe` keyword\",\n+                    trait_ref.print_only_trait_path()\n+                ))\n+                .span_suggestion_verbose(\n+                    item.span.shrink_to_lo(),\n+                    \"add `unsafe` to this trait implementation\",\n+                    \"unsafe \",\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                )\n                 .emit();\n             }\n \n@@ -48,6 +66,18 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n                     \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n                     attr_name\n                 )\n+                .note(format!(\n+                    \"the trait `{}` enforces invariants that the compiler can't check. \\\n+                    Review the trait documentation and make sure this implementation \\\n+                    upholds those invariants before adding the `unsafe` keyword\",\n+                    trait_ref.print_only_trait_path()\n+                ))\n+                .span_suggestion_verbose(\n+                    item.span.shrink_to_lo(),\n+                    \"add `unsafe` to this trait implementation\",\n+                    \"unsafe \",\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                )\n                 .emit();\n             }\n "}, {"sha": "0e7a5ebf5ab6245e205951a36c1d8765212f3ec3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 94, "deletions": 65, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -27,8 +27,8 @@ use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::weak_lang_items;\n-use rustc_hir::{GenericParamKind, Node};\n+use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n+use rustc_hir::{lang_items, GenericParamKind, LangItem, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n@@ -379,8 +379,8 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        Some(self.item_def_id)\n+    fn item_def_id(&self) -> DefId {\n+        self.item_def_id\n     }\n \n     fn get_type_parameter_bounds(\n@@ -512,8 +512,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 }\n                 _ => {}\n             }\n-            err.emit();\n-            self.tcx().ty_error()\n+            self.tcx().ty_error_with_guaranteed(err.emit())\n         }\n     }\n \n@@ -571,7 +570,7 @@ fn get_new_lifetime_name<'tcx>(\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     let it = tcx.hir().item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n-    let def_id = item_id.def_id.def_id;\n+    let def_id = item_id.owner_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -583,11 +582,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for item in items {\n                 let item = tcx.hir().foreign_item(item.id);\n-                tcx.ensure().generics_of(item.def_id);\n-                tcx.ensure().type_of(item.def_id);\n-                tcx.ensure().predicates_of(item.def_id);\n+                tcx.ensure().generics_of(item.owner_id);\n+                tcx.ensure().type_of(item.owner_id);\n+                tcx.ensure().predicates_of(item.owner_id);\n                 match item.kind {\n-                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.def_id),\n+                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.owner_id),\n                     hir::ForeignItemKind::Static(..) => {\n                         let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_foreign_item(item);\n@@ -604,11 +603,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                 }\n             }\n         }\n-        hir::ItemKind::Enum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id());\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -640,50 +639,50 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             }\n \n             if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                convert_variant_ctor(tcx, ctor_hir_id);\n+                let ctor_def_id = tcx.hir().local_def_id(ctor_hir_id);\n+                convert_variant_ctor(tcx, ctor_def_id);\n             }\n         }\n \n-        // Desugared from `impl Trait`, so visited by the function's return type.\n-        hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-            origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-            ..\n-        }) => {}\n-\n         // Don't call `type_of` on opaque types, since that depends on type\n         // checking function bodies. `check_item_type` ensures that it's called\n         // instead.\n         hir::ItemKind::OpaqueTy(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n             tcx.ensure().explicit_item_bounds(def_id);\n+            tcx.ensure().item_bounds(def_id);\n         }\n-        hir::ItemKind::TyAlias(..)\n-        | hir::ItemKind::Static(..)\n-        | hir::ItemKind::Const(..)\n-        | hir::ItemKind::Fn(..) => {\n+\n+        hir::ItemKind::TyAlias(..) => {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            match it.kind {\n-                hir::ItemKind::Fn(..) => tcx.ensure().fn_sig(def_id),\n-                hir::ItemKind::OpaqueTy(..) => tcx.ensure().item_bounds(def_id),\n-                hir::ItemKind::Const(ty, ..) | hir::ItemKind::Static(ty, ..) => {\n-                    if !is_suggestable_infer_ty(ty) {\n-                        let mut visitor = HirPlaceholderCollector::default();\n-                        visitor.visit_item(it);\n-                        placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n-                    }\n-                }\n-                _ => (),\n+        }\n+\n+        hir::ItemKind::Static(ty, ..) | hir::ItemKind::Const(ty, ..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            if !is_suggestable_infer_ty(ty) {\n+                let mut visitor = HirPlaceholderCollector::default();\n+                visitor.visit_item(it);\n+                placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n             }\n         }\n+\n+        hir::ItemKind::Fn(..) => {\n+            tcx.ensure().generics_of(def_id);\n+            tcx.ensure().type_of(def_id);\n+            tcx.ensure().predicates_of(def_id);\n+            tcx.ensure().fn_sig(def_id);\n+        }\n     }\n }\n \n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n     let trait_item = tcx.hir().trait_item(trait_item_id);\n-    let def_id = trait_item_id.def_id;\n+    let def_id = trait_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n \n     match trait_item.kind {\n@@ -730,7 +729,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n-    let def_id = impl_item_id.def_id;\n+    let def_id = impl_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n@@ -750,55 +749,51 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n     }\n }\n \n-fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n-    let def_id = tcx.hir().local_def_id(ctor_id);\n+fn convert_variant_ctor(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId, variants: &[hir::Variant<'_>]) {\n+fn convert_enum_variant_types(tcx: TyCtxt<'_>, def_id: DefId) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr().discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n     let mut prev_discr = None::<Discr<'_>>;\n \n     // fill the discriminant values and field types\n-    for variant in variants {\n+    for variant in def.variants() {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.disr_expr {\n-                let expr_did = tcx.hir().local_def_id(e.hir_id);\n-                def.eval_explicit_discr(tcx, expr_did.to_def_id())\n+            if let ty::VariantDiscr::Explicit(const_def_id) = variant.discr {\n+                def.eval_explicit_discr(tcx, const_def_id)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n                 Some(discr)\n             } else {\n-                struct_span_err!(tcx.sess, variant.span, E0370, \"enum discriminant overflowed\")\n-                    .span_label(\n-                        variant.span,\n-                        format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n-                    )\n+                let span = tcx.def_span(variant.def_id);\n+                struct_span_err!(tcx.sess, span, E0370, \"enum discriminant overflowed\")\n+                    .span_label(span, format!(\"overflowed on value after {}\", prev_discr.unwrap()))\n                     .note(&format!(\n                         \"explicitly set `{} = {}` if that is desired outcome\",\n-                        variant.ident, wrapped_discr\n+                        tcx.item_name(variant.def_id),\n+                        wrapped_discr\n                     ))\n                     .emit();\n                 None\n             }\n             .unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.data.fields() {\n-            let def_id = tcx.hir().local_def_id(f.hir_id);\n-            tcx.ensure().generics_of(def_id);\n-            tcx.ensure().type_of(def_id);\n-            tcx.ensure().predicates_of(def_id);\n+        for f in &variant.fields {\n+            tcx.ensure().generics_of(f.did);\n+            tcx.ensure().type_of(f.did);\n+            tcx.ensure().predicates_of(f.did);\n         }\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n-            convert_variant_ctor(tcx, ctor_hir_id);\n+        if let Some(ctor_def_id) = variant.ctor_def_id {\n+            convert_variant_ctor(tcx, ctor_def_id.expect_local());\n         }\n     }\n }\n@@ -1010,7 +1005,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n \n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n-                        if !tcx.impl_defaultness(item.id.def_id).has_value() {\n+                        if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n                             tcx.sess\n                                 .struct_span_err(\n                                     item.span,\n@@ -1143,7 +1138,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n-            // Do not try to inference the return type for a impl method coming from a trait\n+            // Do not try to infer the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n                 tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n                 && i.of_trait.is_some()\n@@ -1286,15 +1281,46 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n-    match tcx.hir().expect_item(def_id.expect_local()).kind {\n+    let item = tcx.hir().expect_item(def_id.expect_local());\n+    match item.kind {\n         hir::ItemKind::Impl(ref impl_) => impl_.of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n-            <dyn AstConv<'_>>::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+            <dyn AstConv<'_>>::instantiate_mono_trait_ref(\n+                &icx,\n+                ast_trait_ref,\n+                selfty,\n+                check_impl_constness(tcx, impl_.constness, ast_trait_ref),\n+            )\n         }),\n         _ => bug!(),\n     }\n }\n \n+fn check_impl_constness(\n+    tcx: TyCtxt<'_>,\n+    constness: hir::Constness,\n+    ast_trait_ref: &hir::TraitRef<'_>,\n+) -> ty::BoundConstness {\n+    match constness {\n+        hir::Constness::Const => {\n+            if let Some(trait_def_id) = ast_trait_ref.trait_def_id() && !tcx.has_attr(trait_def_id, sym::const_trait) {\n+                let trait_name = tcx.item_name(trait_def_id).to_string();\n+                tcx.sess.emit_err(errors::ConstImplForNonConstTrait {\n+                    trait_ref_span: ast_trait_ref.path.span,\n+                    trait_name,\n+                    local_trait_span: trait_def_id.as_local().map(|_| tcx.def_span(trait_def_id).shrink_to_lo()),\n+                    marking: (),\n+                    adding: (),\n+                });\n+                ty::BoundConstness::NotConst\n+            } else {\n+                ty::BoundConstness::ConstIfConst\n+            }\n+        },\n+        hir::Constness::NotConst => ty::BoundConstness::NotConst,\n+    }\n+}\n+\n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(def_id.expect_local());\n@@ -2073,12 +2099,15 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n     // strippable by the linker.\n     //\n     // Additionally weak lang items have predetermined symbol names.\n-    if tcx.is_weak_lang_item(did.to_def_id()) {\n+    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(attrs) {\n-        codegen_fn_attrs.export_name = Some(name);\n-        codegen_fn_attrs.link_name = Some(name);\n+    if let Some((name, _)) = lang_items::extract(attrs)\n+        && let Some(lang_item) = LangItem::from_name(name)\n+        && let Some(link_name) = lang_item.link_name()\n+    {\n+        codegen_fn_attrs.export_name = Some(link_name);\n+        codegen_fn_attrs.link_name = Some(link_name);\n     }\n     check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n "}, {"sha": "c7777a946893a689e3eb56b45109a7138320f38a", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -249,6 +249,11 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;\n     let mut i = 0;\n+    let mut next_index = || {\n+        let prev = i;\n+        i += 1;\n+        prev as u32 + type_start\n+    };\n \n     const TYPE_DEFAULT_NOT_ALLOWED: &'static str = \"defaults for type parameters are only allowed in \\\n     `struct`, `enum`, `type`, or `trait` definitions\";\n@@ -278,15 +283,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n \n             let kind = ty::GenericParamDefKind::Type { has_default: default.is_some(), synthetic };\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind,\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n         GenericParamKind::Const { default, .. } => {\n             if !matches!(allow_defaults, Defaults::Allowed) && default.is_some() {\n@@ -297,15 +300,13 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 );\n             }\n \n-            let param_def = ty::GenericParamDef {\n-                index: type_start + i as u32,\n+            Some(ty::GenericParamDef {\n+                index: next_index(),\n                 name: param.name.ident().name,\n                 def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Const { has_default: default.is_some() },\n-            };\n-            i += 1;\n-            Some(param_def)\n+            })\n         }\n     }));\n \n@@ -323,8 +324,8 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             &[\"<closure_kind>\", \"<closure_signature>\", \"<upvars>\"][..]\n         };\n \n-        params.extend(dummy_args.iter().enumerate().map(|(i, &arg)| ty::GenericParamDef {\n-            index: type_start + i as u32,\n+        params.extend(dummy_args.iter().map(|&arg| ty::GenericParamDef {\n+            index: next_index(),\n             name: Symbol::intern(arg),\n             def_id,\n             pure_wrt_drop: false,\n@@ -337,7 +338,7 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n         if let Node::Expr(&Expr { kind: ExprKind::ConstBlock(_), .. }) = parent_node {\n             params.push(ty::GenericParamDef {\n-                index: type_start,\n+                index: next_index(),\n                 name: Symbol::intern(\"<const_ty>\"),\n                 def_id,\n                 pure_wrt_drop: false,"}, {"sha": "6ee7aa9cdac6b8ebc65b56a45732131aedc85768", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 206, "deletions": 224, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -94,11 +94,6 @@ struct LifetimeContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n-\n-    /// Indicates that we only care about the definition of a trait. This should\n-    /// be false if the `Item` we are resolving lifetimes for is not a trait or\n-    /// we eventually need lifetimes resolve for trait items.\n-    trait_definition_only: bool,\n }\n \n #[derive(Debug)]\n@@ -166,7 +161,9 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    Root,\n+    Root {\n+        opt_parent_item: Option<LocalDefId>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -214,95 +211,58 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n-            Scope::Root => f.debug_struct(\"Root\").finish(),\n+            Scope::Root { opt_parent_item } => {\n+                f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n+            }\n         }\n     }\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n-const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n-\n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes_trait_definition,\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n+        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Like `resolve_lifetimes`, but does not resolve lifetimes for trait items.\n-/// Also does not generate any diagnostics.\n-///\n-/// This is ultimately a subset of the `resolve_lifetimes` work. It effectively\n-/// resolves lifetimes only within the trait \"header\" -- that is, the trait\n-/// and supertrait list. In contrast, `resolve_lifetimes` resolves all the\n-/// lifetimes within the trait and its items. There is room to refactor this,\n-/// for example to resolve lifetimes for each trait item in separate queries,\n-/// but it's convenient to do the entire trait at once because the lifetimes\n-/// from the trait definition are in scope within the trait items as well.\n-///\n-/// The reason for this separate call is to resolve what would otherwise\n-/// be a cycle. Consider this example:\n-///\n-/// ```ignore UNSOLVED (maybe @jackh726 knows what lifetime parameter to give Sub)\n-/// trait Base<'a> {\n-///     type BaseItem;\n-/// }\n-/// trait Sub<'b>: for<'a> Base<'a> {\n-///    type SubItem: Sub<BaseItem = &'b u32>;\n-/// }\n-/// ```\n-///\n-/// When we resolve `Sub` and all its items, we also have to resolve `Sub<BaseItem = &'b u32>`.\n-/// To figure out the index of `'b`, we have to know about the supertraits\n-/// of `Sub` so that we can determine that the `for<'a>` will be in scope.\n-/// (This is because we -- currently at least -- flatten all the late-bound\n-/// lifetimes into a single binder.) This requires us to resolve the\n-/// *trait definition* of `Sub`; basically just enough lifetime information\n-/// to look at the supertraits.\n-#[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes_trait_definition(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, true))\n-}\n-\n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(do_resolve(tcx, local_def_id, false))\n-}\n-\n-fn do_resolve(\n-    tcx: TyCtxt<'_>,\n-    local_def_id: LocalDefId,\n-    trait_definition_only: bool,\n-) -> NamedRegionMap {\n-    let item = tcx.hir().expect_item(local_def_id);\n+fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n     let mut named_region_map =\n         NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n-        scope: ROOT_SCOPE,\n-        trait_definition_only,\n+        scope: &Scope::Root { opt_parent_item: None },\n     };\n-    visitor.visit_item(item);\n-\n-    named_region_map\n-}\n+    match tcx.hir().owner(local_def_id) {\n+        hir::OwnerNode::Item(item) => visitor.visit_item(item),\n+        hir::OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n+        hir::OwnerNode::TraitItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_trait_item(item)\n+        }\n+        hir::OwnerNode::ImplItem(item) => {\n+            let scope =\n+                Scope::Root { opt_parent_item: Some(tcx.local_parent(item.owner_id.def_id)) };\n+            visitor.scope = &scope;\n+            visitor.visit_impl_item(item)\n+        }\n+        hir::OwnerNode::Crate(_) => {}\n+    }\n \n-fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n@@ -319,53 +279,6 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n     rl\n }\n \n-/// Given `any` owner (structs, traits, trait methods, etc.), does lifetime resolution.\n-/// There are two important things this does.\n-/// First, we have to resolve lifetimes for\n-/// the entire *`Item`* that contains this owner, because that's the largest \"scope\"\n-/// where we can have relevant lifetimes.\n-/// Second, if we are asking for lifetimes in a trait *definition*, we use `resolve_lifetimes_trait_definition`\n-/// instead of `resolve_lifetimes`, which does not descend into the trait items and does not emit diagnostics.\n-/// This allows us to avoid cycles. Importantly, if we ask for lifetimes for lifetimes that have an owner\n-/// other than the trait itself (like the trait methods or associated types), then we just use the regular\n-/// `resolve_lifetimes`.\n-fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n-    let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.def_id.def_id;\n-    if item_id.def_id == def_id {\n-        let item = tcx.hir().item(item_id);\n-        match item.kind {\n-            hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n-            _ => tcx.resolve_lifetimes(local_def_id),\n-        }\n-    } else {\n-        tcx.resolve_lifetimes(local_def_id)\n-    }\n-}\n-\n-/// Finds the `Item` that contains the given `LocalDefId`\n-fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> hir::ItemId {\n-    match tcx.hir().find_by_def_id(local_def_id) {\n-        Some(Node::Item(item)) => {\n-            return item.item_id();\n-        }\n-        _ => {}\n-    }\n-    let item = {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-        let mut parent_iter = tcx.hir().parent_iter(hir_id);\n-        loop {\n-            let node = parent_iter.next().map(|n| n.1);\n-            match node {\n-                Some(hir::Node::Item(item)) => break item.item_id(),\n-                Some(hir::Node::Crate(_)) | None => bug!(\"Called `item_for` on an Item.\"),\n-                _ => {}\n-            }\n-        }\n-    };\n-    item\n-}\n-\n fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n     match region {\n         Region::LateBound(_, _, def_id) => {\n@@ -383,7 +296,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut supertrait_lifetimes = vec![];\n         loop {\n             match scope {\n-                Scope::Body { .. } | Scope::Root => {\n+                Scope::Body { .. } | Scope::Root { .. } => {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n@@ -414,21 +327,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n+    type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n         self.tcx.hir()\n     }\n \n-    // We want to nest trait/impl items in their parent, but nothing else.\n-    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n-\n-    fn visit_trait_item_ref(&mut self, ii: &'tcx hir::TraitItemRef) {\n-        if !self.trait_definition_only {\n-            intravisit::walk_trait_item_ref(self, ii)\n-        }\n-    }\n-\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         let body = self.tcx.hir().body(body);\n         self.with(Scope::Body { id: body.id(), s: self.scope }, |this| {\n@@ -548,7 +452,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item)\n                 });\n             }\n-            hir::ItemKind::OpaqueTy(hir::OpaqueTy { .. }) => {\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::TyAlias, ..\n+            }) => {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n                 // their parent opaque_ty in scope.\n@@ -557,34 +463,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.def_id.into()) {\n-                    match node {\n-                        hir::Node::Item(parent_item) => {\n-                            let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.def_id.def_id).def_id.def_id,\n-                            );\n-                            // We need to add *all* deps, since opaque tys may want them from *us*\n-                            for (&owner, defs) in resolved_lifetimes.defs.iter() {\n-                                defs.iter().for_each(|(&local_id, region)| {\n-                                    self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n-                                });\n-                            }\n-                            for (&owner, late_bound_vars) in\n-                                resolved_lifetimes.late_bound_vars.iter()\n-                            {\n-                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n-                                    self.record_late_bound_vars(\n-                                        hir::HirId { owner, local_id },\n-                                        late_bound_vars.clone(),\n-                                    );\n-                                });\n-                            }\n-                            break;\n+                let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n+                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                // We need to add *all* deps, since opaque tys may want them from *us*\n+                for (&owner, defs) in resolved_lifetimes.defs.iter() {\n+                    defs.iter().for_each(|(&local_id, region)| {\n+                        self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n+                    });\n+                }\n+                for (&owner, late_bound_vars) in resolved_lifetimes.late_bound_vars.iter() {\n+                    late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                        self.record_late_bound_vars(\n+                            hir::HirId { owner, local_id },\n+                            late_bound_vars.clone(),\n+                        );\n+                    });\n+                }\n+            }\n+            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_),\n+                generics,\n+                ..\n+            }) => {\n+                // We want to start our early-bound indices at the end of the parent scope,\n+                // not including any parent `impl Trait`s.\n+                let mut lifetimes = FxIndexMap::default();\n+                debug!(?generics.params);\n+                for param in generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n+                            lifetimes.insert(def_id, reg);\n                         }\n-                        hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n-                        _ => {}\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n+\n+                let scope = Scope::Binder {\n+                    hir_id: item.hir_id(),\n+                    lifetimes,\n+                    s: self.scope,\n+                    scope_type: BinderScopeType::Normal,\n+                    where_bound_origin: None,\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |this| intravisit::walk_item(this, item))\n+                });\n             }\n             hir::ItemKind::TyAlias(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n@@ -609,7 +534,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     hir_id: item.hir_id(),\n                     lifetimes,\n                     scope_type: BinderScopeType::Normal,\n-                    s: ROOT_SCOPE,\n+                    s: self.scope,\n                     where_bound_origin: None,\n                 };\n                 self.with(scope, |this| {\n@@ -712,7 +637,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 //                 ^                  ^ this gets resolved in the scope of\n                 //                                      the opaque_ty generics\n                 let opaque_ty = self.tcx.hir().item(item_id);\n-                let (generics, bounds) = match opaque_ty.kind {\n+                match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::TyAlias,\n                         ..\n@@ -733,10 +658,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n                         origin: hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..),\n-                        ref generics,\n-                        bounds,\n                         ..\n-                    }) => (generics, bounds),\n+                    }) => {}\n                     ref i => bug!(\"`impl Trait` pointed to non-opaque type?? {:#?}\", i),\n                 };\n \n@@ -766,65 +689,28 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // Ensure that the parent of the def is an item, not HRTB\n                     let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                     if !parent_id.is_owner() {\n-                        if !self.trait_definition_only {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                lifetime.span,\n-                                E0657,\n-                                \"`impl Trait` can only capture lifetimes \\\n-                                    bound at the fn or impl level\"\n-                            )\n-                            .emit();\n-                        }\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime.span,\n+                            E0657,\n+                            \"`impl Trait` can only capture lifetimes bound at the fn or impl level\"\n+                        )\n+                        .emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                     if let hir::Node::Item(hir::Item {\n                         kind: hir::ItemKind::OpaqueTy { .. }, ..\n                     }) = self.tcx.hir().get(parent_id)\n                     {\n-                        if !self.trait_definition_only {\n-                            let mut err = self.tcx.sess.struct_span_err(\n-                                lifetime.span,\n-                                \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n-                            );\n-                            err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n-                            err.emit();\n-                        }\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            lifetime.span,\n+                            \"higher kinded lifetime bounds on nested opaque types are not supported yet\",\n+                        );\n+                        err.span_note(self.tcx.def_span(def_id), \"lifetime declared here\");\n+                        err.emit();\n                         self.uninsert_lifetime_on_error(lifetime, def.unwrap());\n                     }\n                 }\n-\n-                // We want to start our early-bound indices at the end of the parent scope,\n-                // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n-                debug!(?generics.params);\n-                for param in generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(self.tcx.hir(), &param);\n-                            lifetimes.insert(def_id, reg);\n-                        }\n-                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n-                    }\n-                }\n-                self.record_late_bound_vars(ty.hir_id, vec![]);\n-\n-                let scope = Scope::Binder {\n-                    hir_id: ty.hir_id,\n-                    lifetimes,\n-                    s: self.scope,\n-                    scope_type: BinderScopeType::Normal,\n-                    where_bound_origin: None,\n-                };\n-                self.with(scope, |this| {\n-                    let scope = Scope::TraitRefBoundary { s: this.scope };\n-                    this.with(scope, |this| {\n-                        this.visit_generics(generics);\n-                        for bound in bounds {\n-                            this.visit_param_bound(bound);\n-                        }\n-                    })\n-                });\n             }\n             _ => intravisit::walk_ty(self, ty),\n         }\n@@ -1193,12 +1079,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext {\n-            tcx: *tcx,\n-            map,\n-            scope: &wrap_scope,\n-            trait_definition_only: self.trait_definition_only,\n-        };\n+        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1303,7 +1184,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root => {\n+                Scope::Root { opt_parent_item } => {\n+                    if let Some(parent_item) = opt_parent_item\n+                        && let parent_generics = self.tcx.generics_of(parent_item)\n+                        && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n+                    {\n+                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                    }\n                     break None;\n                 }\n \n@@ -1377,11 +1264,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n                 match self.tcx.hir().get(fn_id) {\n-                    Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | Node::TraitItem(&hir::TraitItem {\n+                    Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | Node::TraitItem(hir::TraitItem {\n                         kind: hir::TraitItemKind::Fn(..), ..\n                     })\n-                    | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n+                    | Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. })\n+                    | Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope.to_def_id(), def.id().unwrap());\n                     }\n@@ -1416,7 +1304,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     err.emit();\n                     return;\n                 }\n-                Scope::Root => break,\n+                Scope::Root { .. } => break,\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n@@ -1494,7 +1382,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let mut scope = self.scope;\n                 loop {\n                     match *scope {\n-                        Scope::Root => break false,\n+                        Scope::Root { .. } => break false,\n \n                         Scope::Body { .. } => break true,\n \n@@ -1731,7 +1619,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n@@ -1780,7 +1668,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n \n     let mut late_bound = FxIndexSet::default();\n \n-    let mut constrained_by_input = ConstrainedCollector::default();\n+    let mut constrained_by_input = ConstrainedCollector { regions: Default::default(), tcx };\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n@@ -1833,12 +1721,65 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n     debug!(?late_bound);\n     return Some(tcx.arena.alloc(late_bound));\n \n-    #[derive(Default)]\n-    struct ConstrainedCollector {\n+    /// Visits a `ty::Ty` collecting information about what generic parameters are constrained.\n+    ///\n+    /// The visitor does not operate on `hir::Ty` so that it can be called on the rhs of a `type Alias<...> = ...;`\n+    /// which may live in a separate crate so there would not be any hir available. Instead we use the `type_of`\n+    /// query to obtain a `ty::Ty` which will be present even in cross crate scenarios. It also naturally\n+    /// handles cycle detection as we go through the query system.\n+    ///\n+    /// This is necessary in the first place for the following case:\n+    /// ```\n+    /// type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n+    /// fn foo<'a>(_: Alias<'a, ()>) -> Alias<'a, ()> { ... }\n+    /// ```\n+    ///\n+    /// If we conservatively considered `'a` unconstrained then we could break users who had written code before\n+    /// we started correctly handling aliases. If we considered `'a` constrained then it would become late bound\n+    /// causing an error during astconv as the `'a` is not constrained by the input type `<() as Trait<'a>>::Assoc`\n+    /// but appears in the output type `<() as Trait<'a>>::Assoc`.\n+    ///\n+    /// We must therefore \"look into\" the `Alias` to see whether we should consider `'a` constrained or not.\n+    ///\n+    /// See #100508 #85533 #47511 for additional context\n+    struct ConstrainedCollectorPostAstConv {\n+        arg_is_constrained: Box<[bool]>,\n+    }\n+\n+    use std::ops::ControlFlow;\n+    use ty::Ty;\n+    impl<'tcx> TypeVisitor<'tcx> for ConstrainedCollectorPostAstConv {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<!> {\n+            match t.kind() {\n+                ty::Param(param_ty) => {\n+                    self.arg_is_constrained[param_ty.index as usize] = true;\n+                }\n+                ty::Projection(_) => return ControlFlow::Continue(()),\n+                _ => (),\n+            }\n+            t.super_visit_with(self)\n+        }\n+\n+        fn visit_const(&mut self, _: ty::Const<'tcx>) -> ControlFlow<!> {\n+            ControlFlow::Continue(())\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<!> {\n+            debug!(\"r={:?}\", r.kind());\n+            if let ty::RegionKind::ReEarlyBound(region) = r.kind() {\n+                self.arg_is_constrained[region.index as usize] = true;\n+            }\n+\n+            ControlFlow::Continue(())\n+        }\n+    }\n+\n+    struct ConstrainedCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         regions: FxHashSet<LocalDefId>,\n     }\n \n-    impl<'v> Visitor<'v> for ConstrainedCollector {\n+    impl<'v> Visitor<'v> for ConstrainedCollector<'_> {\n         fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n             match ty.kind {\n                 hir::TyKind::Path(\n@@ -1849,6 +1790,47 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     // (defined above)\n                 }\n \n+                hir::TyKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { res: Res::Def(DefKind::TyAlias, alias_def), segments, span },\n+                )) => {\n+                    // See comments on `ConstrainedCollectorPostAstConv` for why this arm does not just consider\n+                    // substs to be unconstrained.\n+                    let generics = self.tcx.generics_of(alias_def);\n+                    let mut walker = ConstrainedCollectorPostAstConv {\n+                        arg_is_constrained: vec![false; generics.params.len()].into_boxed_slice(),\n+                    };\n+                    walker.visit_ty(self.tcx.type_of(alias_def));\n+\n+                    match segments.last() {\n+                        Some(hir::PathSegment { args: Some(args), .. }) => {\n+                            let tcx = self.tcx;\n+                            for constrained_arg in\n+                                args.args.iter().enumerate().flat_map(|(n, arg)| {\n+                                    match walker.arg_is_constrained.get(n) {\n+                                        Some(true) => Some(arg),\n+                                        Some(false) => None,\n+                                        None => {\n+                                            tcx.sess.delay_span_bug(\n+                                                *span,\n+                                                format!(\n+                                                    \"Incorrect generic arg count for alias {:?}\",\n+                                                    alias_def\n+                                                ),\n+                                            );\n+                                            None\n+                                        }\n+                                    }\n+                                })\n+                            {\n+                                self.visit_generic_arg(constrained_arg);\n+                            }\n+                        }\n+                        Some(_) => (),\n+                        None => bug!(\"Path with no segments or self type\"),\n+                    }\n+                }\n+\n                 hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently"}, {"sha": "5d1ca1cbd2389046881a349839011366507c796d", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -427,6 +427,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n+\n             if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n@@ -439,8 +441,33 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //        parent of generics returned by `generics_of`\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_def_id = tcx.hir().get_parent_item(hir_id);\n-                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n+                // and we would be calling `explicit_predicates_of(Foo)` here\n+                return tcx.explicit_predicates_of(parent_def_id);\n+            }\n+\n+            let parent_def_kind = tcx.def_kind(parent_def_id);\n+            if matches!(parent_def_kind, DefKind::OpaqueTy) {\n+                // In `instantiate_identity` we inherit the predicates of our parent.\n+                // However, opaque types do not have a parent (see `gather_explicit_predicates_of`), which means\n+                // that we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                //\n+                //\n+                // fn foo<T: Trait>() -> impl Iterator<Output = Another<{ <T as Trait>::ASSOC }> > { todo!() }\n+                //                                                        ^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //                                                                            explicit_predicates_of on\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`.\n+                // However, the anon const cannot inherit predicates from its parent since it's opaque.\n+                //\n+                // To fix this, we call `explicit_predicates_of` directly on `foo`, the parent's parent.\n+\n+                // In the above example this is `foo::{opaque#0}` or `impl Iterator`\n+                let parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent_def_id.def_id);\n+\n+                // In the above example this is the function `foo`\n+                let item_def_id = tcx.hir().get_parent_item(parent_hir_id);\n+\n+                // In the above code example we would be calling `explicit_predicates_of(foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n         }"}, {"sha": "2402495c2e4a6ffde84ea918a633705408a27c27", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -319,7 +319,15 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     }\n                 }\n                 ItemKind::TyAlias(self_ty, _) => icx.to_ty(self_ty),\n-                ItemKind::Impl(hir::Impl { self_ty, .. }) => icx.to_ty(*self_ty),\n+                ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n+                    match self_ty.find_self_aliases() {\n+                        spans if spans.len() > 0 => {\n+                            tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: (), });\n+                            tcx.ty_error()\n+                        },\n+                        _ => icx.to_ty(*self_ty),\n+                    }\n+                },\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_fn_def(def_id.to_def_id(), substs)\n@@ -635,24 +643,24 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n@@ -690,11 +698,17 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n     }\n \n     let Some(hidden) = locator.found else {\n-        tcx.sess.emit_err(UnconstrainedOpaqueType {\n+        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            what: match tcx.hir().get(scope) {\n+                _ if scope == hir::CRATE_HIR_ID => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n+                _ => \"item\",\n+            },\n         });\n-        return tcx.ty_error();\n+        return tcx.ty_error_with_guaranteed(reported);\n     };\n \n     // Only check against typeck if we didn't already error\n@@ -764,24 +778,24 @@ fn find_opaque_ty_constraints_for_rpit(\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "afbb27155a2f59f7deb2c49acf44acc590e7c376", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,7 +1,7 @@\n //! Errors emitted by `rustc_hir_analysis`.\n \n-use rustc_errors::IntoDiagnostic;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n+use rustc_errors::{IntoDiagnostic, MultiSpan};\n use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n@@ -120,7 +120,7 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[suggestion_verbose(code = \"{ty}\")]\n+    #[suggestion(style = \"verbose\", code = \"{ty}\")]\n     pub opt_sugg: Option<(Span, Applicability)>,\n }\n \n@@ -143,6 +143,7 @@ pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n+    pub what: &'static str,\n }\n \n pub struct MissingTypeParams {\n@@ -155,6 +156,7 @@ pub struct MissingTypeParams {\n \n // Manual implementation of `IntoDiagnostic` to be able to call `span_to_snippet`.\n impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n+    #[track_caller]\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n@@ -237,7 +239,11 @@ pub struct UnusedExternCrate {\n #[derive(LintDiagnostic)]\n #[diag(hir_analysis_extern_crate_not_idiomatic)]\n pub struct ExternCrateNotIdiomatic {\n-    #[suggestion_short(applicability = \"machine-applicable\", code = \"{suggestion_code}\")]\n+    #[suggestion(\n+        style = \"short\",\n+        applicability = \"machine-applicable\",\n+        code = \"{suggestion_code}\"\n+    )]\n     pub span: Span,\n     pub msg_code: String,\n     pub suggestion_code: String,\n@@ -249,3 +255,33 @@ pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_impl_for_non_const_trait)]\n+pub struct ConstImplForNonConstTrait {\n+    #[primary_span]\n+    pub trait_ref_span: Span,\n+    pub trait_name: String,\n+    #[suggestion(applicability = \"machine-applicable\", code = \"#[const_trait]\")]\n+    pub local_trait_span: Option<Span>,\n+    #[note]\n+    pub marking: (),\n+    #[note(adding)]\n+    pub adding: (),\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_bound_for_non_const_trait)]\n+pub struct ConstBoundForNonConstTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_self_in_impl_self)]\n+pub struct SelfInImplSelf {\n+    #[primary_span]\n+    pub span: MultiSpan,\n+    #[note]\n+    pub note: (),\n+}"}, {"sha": "136f6199911a0eeb9ba7ac07032bf630df2eef6a", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -55,10 +55,10 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-            enforce_impl_params_are_constrained(tcx, id.def_id.def_id);\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+            enforce_impl_params_are_constrained(tcx, id.owner_id.def_id);\n             if min_specialization {\n-                check_min_specialization(tcx, id.def_id.def_id);\n+                check_min_specialization(tcx, id.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "55cca0cd2d7b540b2a3edad210ada95d39fc6d67", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 99, "deletions": 23, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -69,6 +69,7 @@ use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -80,6 +81,7 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, translate_substs, wf, ObligationCtxt};\n+use tracing::instrument;\n \n pub(super) fn check_min_specialization(tcx: TyCtxt<'_>, impl_def_id: LocalDefId) {\n     if let Some(node) = parent_specialization_node(tcx, impl_def_id) {\n@@ -103,13 +105,11 @@ fn parent_specialization_node(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId) -> Opti\n }\n \n /// Check that `impl1` is a sound specialization\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node) {\n     if let Some((impl1_substs, impl2_substs)) = get_impl_substs(tcx, impl1_def_id, impl2_node) {\n         let impl2_def_id = impl2_node.def_id();\n-        debug!(\n-            \"check_always_applicable(\\nimpl1_def_id={:?},\\nimpl2_def_id={:?},\\nimpl2_substs={:?}\\n)\",\n-            impl1_def_id, impl2_def_id, impl2_substs\n-        );\n+        debug!(?impl2_def_id, ?impl2_substs);\n \n         let parent_substs = if impl2_node.is_from_trait() {\n             impl2_substs.to_vec()\n@@ -118,12 +118,33 @@ fn check_always_applicable(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node\n         };\n \n         let span = tcx.def_span(impl1_def_id);\n+        check_constness(tcx, impl1_def_id, impl2_node, span);\n         check_static_lifetimes(tcx, &parent_substs, span);\n         check_duplicate_params(tcx, impl1_substs, &parent_substs, span);\n         check_predicates(tcx, impl1_def_id, impl1_substs, impl2_node, impl2_substs, span);\n     }\n }\n \n+/// Check that the specializing impl `impl1` is at least as const as the base\n+/// impl `impl2`\n+fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node, span: Span) {\n+    if impl2_node.is_from_trait() {\n+        // This isn't a specialization\n+        return;\n+    }\n+\n+    let impl1_constness = tcx.constness(impl1_def_id.to_def_id());\n+    let impl2_constness = tcx.constness(impl2_node.def_id());\n+\n+    if let hir::Constness::Const = impl2_constness {\n+        if let hir::Constness::NotConst = impl1_constness {\n+            tcx.sess\n+                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n+                .emit();\n+        }\n+    }\n+}\n+\n /// Given a specializing impl `impl1`, and the base impl `impl2`, returns two\n /// substitutions `(S1, S2)` that equate their trait references. The returned\n /// types are expressed in terms of the generics of `impl1`.\n@@ -155,7 +176,7 @@ fn get_impl_substs<'tcx>(\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return None;\n     }\n \n@@ -278,15 +299,15 @@ fn check_static_lifetimes<'tcx>(\n \n /// Check whether predicates on the specializing impl (`impl1`) are allowed.\n ///\n-/// Each predicate `P` must be:\n+/// Each predicate `P` must be one of:\n ///\n-/// * global (not reference any parameters)\n-/// * `T: Tr` predicate where `Tr` is an always-applicable trait\n-/// * on the base `impl impl2`\n-///     * Currently this check is done using syntactic equality, which is\n-///       conservative but generally sufficient.\n-/// * a well-formed predicate of a type argument of the trait being implemented,\n+/// * Global (not reference any parameters).\n+/// * A `T: Tr` predicate where `Tr` is an always-applicable trait.\n+/// * Present on the base impl `impl2`.\n+///     * This check is done using the `trait_predicates_eq` function below.\n+/// * A well-formed predicate of a type argument of the trait being implemented,\n ///   including the `Self`-type.\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl1_def_id: LocalDefId,\n@@ -322,10 +343,7 @@ fn check_predicates<'tcx>(\n         .map(|obligation| obligation.predicate)\n         .collect()\n     };\n-    debug!(\n-        \"check_always_applicable(\\nimpl1_predicates={:?},\\nimpl2_predicates={:?}\\n)\",\n-        impl1_predicates, impl2_predicates,\n-    );\n+    debug!(?impl1_predicates, ?impl2_predicates);\n \n     // Since impls of always applicable traits don't get to assume anything, we\n     // can also assume their supertraits apply.\n@@ -373,25 +391,83 @@ fn check_predicates<'tcx>(\n     );\n \n     for (predicate, span) in impl1_predicates {\n-        if !impl2_predicates.contains(&predicate) {\n+        if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {\n             check_specialization_on(tcx, predicate, span)\n         }\n     }\n }\n \n+/// Checks if some predicate on the specializing impl (`predicate1`) is the same\n+/// as some predicate on the base impl (`predicate2`).\n+///\n+/// This basically just checks syntactic equivalence, but is a little more\n+/// forgiving since we want to equate `T: Tr` with `T: ~const Tr` so this can work:\n+///\n+/// ```ignore (illustrative)\n+/// #[rustc_specialization_trait]\n+/// trait Specialize { }\n+///\n+/// impl<T: Bound> Tr for T { }\n+/// impl<T: ~const Bound + Specialize> const Tr for T { }\n+/// ```\n+///\n+/// However, we *don't* want to allow the reverse, i.e., when the bound on the\n+/// specializing impl is not as const as the bound on the base impl:\n+///\n+/// ```ignore (illustrative)\n+/// impl<T: ~const Bound> const Tr for T { }\n+/// impl<T: Bound + Specialize> const Tr for T { } // should be T: ~const Bound\n+/// ```\n+///\n+/// So we make that check in this function and try to raise a helpful error message.\n+fn trait_predicates_eq<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicate1: ty::Predicate<'tcx>,\n+    predicate2: ty::Predicate<'tcx>,\n+    span: Span,\n+) -> bool {\n+    let pred1_kind = predicate1.kind().skip_binder();\n+    let pred2_kind = predicate2.kind().skip_binder();\n+    let (trait_pred1, trait_pred2) = match (pred1_kind, pred2_kind) {\n+        (ty::PredicateKind::Trait(pred1), ty::PredicateKind::Trait(pred2)) => (pred1, pred2),\n+        // Just use plain syntactic equivalence if either of the predicates aren't\n+        // trait predicates or have bound vars.\n+        _ => return predicate1 == predicate2,\n+    };\n+\n+    let predicates_equal_modulo_constness = {\n+        let pred1_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred1 };\n+        let pred2_unconsted =\n+            ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..trait_pred2 };\n+        pred1_unconsted == pred2_unconsted\n+    };\n+\n+    if !predicates_equal_modulo_constness {\n+        return false;\n+    }\n+\n+    // Check that the predicate on the specializing impl is at least as const as\n+    // the one on the base.\n+    match (trait_pred2.constness, trait_pred1.constness) {\n+        (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n+            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+        }\n+        _ => {}\n+    }\n+\n+    true\n+}\n+\n+#[instrument(level = \"debug\", skip(tcx))]\n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n-    debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n     match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(ty::TraitPredicate {\n-            trait_ref,\n-            constness: ty::BoundConstness::NotConst,\n-            polarity: _,\n-        }) => {\n+        ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref, constness: _, polarity: _ }) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)"}, {"sha": "664d3a3a1db84c3d5e8cefd394ee650daaff1613", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -106,7 +106,7 @@ use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util;\n-use rustc_session::config::EntryFnType;\n+use rustc_session::{config::EntryFnType, parse::feature_err};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -118,20 +118,40 @@ use astconv::AstConv;\n use bounds::Bounds;\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n-    match (decl.c_variadic, abi) {\n-        // The function has the correct calling convention, or isn't a \"C-variadic\" function.\n-        (false, _) | (true, Abi::C { .. }) | (true, Abi::Cdecl { .. }) => {}\n-        // The function is a \"C-variadic\" function with an incorrect calling convention.\n-        (true, _) => {\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n+    const ERROR_HEAD: &str = \"C-variadic function must have a compatible calling convention\";\n+    const CONVENTIONS_UNSTABLE: &str = \"`C`, `cdecl`, `win64`, `sysv64` or `efiapi`\";\n+    const CONVENTIONS_STABLE: &str = \"`C` or `cdecl`\";\n+    const UNSTABLE_EXPLAIN: &str =\n+        \"using calling conventions other than `C` or `cdecl` for varargs functions is unstable\";\n+\n+    if !decl.c_variadic || matches!(abi, Abi::C { .. } | Abi::Cdecl { .. }) {\n+        return;\n+    }\n+\n+    let extended_abi_support = tcx.features().extended_varargs_abi_support;\n+    let conventions = match (extended_abi_support, abi.supports_varargs()) {\n+        // User enabled additional ABI support for varargs and function ABI matches those ones.\n+        (true, true) => return,\n+\n+        // Using this ABI would be ok, if the feature for additional ABI support was enabled.\n+        // Return CONVENTIONS_STABLE, because we want the other error to look the same.\n+        (false, true) => {\n+            feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::extended_varargs_abi_support,\n                 span,\n-                E0045,\n-                \"C-variadic function must have C or cdecl calling convention\"\n-            );\n-            err.span_label(span, \"C-variadics require C or cdecl calling convention\").emit();\n+                UNSTABLE_EXPLAIN,\n+            )\n+            .emit();\n+            CONVENTIONS_STABLE\n         }\n-    }\n+\n+        (false, false) => CONVENTIONS_STABLE,\n+        (true, false) => CONVENTIONS_UNSTABLE,\n+    };\n+\n+    let mut err = struct_span_err!(tcx.sess, span, E0045, \"{}, like {}\", ERROR_HEAD, conventions);\n+    err.span_label(span, ERROR_HEAD).emit();\n }\n \n fn require_same_types<'tcx>(\n@@ -153,7 +173,7 @@ fn require_same_types<'tcx>(\n     match &errors[..] {\n         [] => true,\n         errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(errors, None);\n             false\n         }\n     }\n@@ -316,7 +336,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             error = true;\n         }\n         // now we can take the return type of the given main function\n@@ -381,7 +401,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n-                        let span = tcx.def_span(it.def_id);\n+                        let span = tcx.def_span(it.owner_id);\n                         struct_span_err!(\n                             tcx.sess,\n                             span,"}, {"sha": "90c6edb65e46faa6aac8214fb3587c9abd5a5723", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -29,7 +29,7 @@ pub(super) fn infer_predicates<'tcx>(\n \n         // Visit all the crates and infer predicates\n         for id in tcx.hir().items() {\n-            let item_did = id.def_id;\n+            let item_did = id.owner_id;\n \n             debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n "}, {"sha": "fa2ac56593bcf5c38d685bdf9023b60be02f626e", "filename": "compiler/rustc_hir_analysis/src/outlives/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,11 +6,11 @@ pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n     for id in tcx.hir().items() {\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = tcx.inferred_outlives_of(id.def_id);\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = tcx.inferred_outlives_of(id.owner_id);\n             struct_span_err!(\n                 tcx.sess,\n-                tcx.def_span(id.def_id),\n+                tcx.def_span(id.owner_id),\n                 E0640,\n                 \"{:?}\",\n                 inferred_outlives_of"}, {"sha": "83ed3e44b3d733ca28477c985a4674c1eb201041", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,9 +6,10 @@ pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = tcx.variances_of(id.def_id);\n-            struct_span_err!(tcx.sess, tcx.def_span(id.def_id), E0208, \"{:?}\", variances_of).emit();\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = tcx.variances_of(id.owner_id);\n+            struct_span_err!(tcx.sess, tcx.def_span(id.owner_id), E0208, \"{:?}\", variances_of)\n+                .emit();\n         }\n     }\n }"}, {"sha": "6a4a6a5b0a546716721f3bf2d9ec77cbd0a6ed5a", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 74, "deletions": 55, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::{AsCoercionSite, CoerceMany};\n use crate::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -137,55 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self\n-                        .tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner.def_id)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                    else { return; };\n-                    let Expectation::IsLast(stmt) = orig_expected else {\n-                        return\n-                    };\n-                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                        Some(ret_coercion) if self.in_tail_expr => {\n-                            let ret_ty = ret_coercion.borrow().expected_ty();\n-                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                            self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n-                                // The match arms need to unify for the case of `impl Trait`.\n-                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                        }\n-                        _ => false,\n-                    };\n-                    if !can_coerce_to_return_ty {\n-                        return;\n-                    }\n-\n-                    let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                    let mut ret_span: MultiSpan = semi_span.into();\n-                    ret_span.push_span_label(\n-                        expr.span,\n-                        \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n-                    );\n-                    ret_span\n-                        .push_span_label(ret, \"the `match` arms can conform to this return type\");\n-                    ret_span.push_span_label(\n-                        semi_span,\n-                        \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n-                    );\n-                    err.span_note(\n-                        ret_span,\n-                        \"you might have meant to return the `match` expression\",\n-                    );\n-                    err.tool_only_span_suggestion(\n-                        semi_span,\n-                        \"remove this semicolon\",\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    self.suggest_removing_semicolon_for_coerce(\n+                        err,\n+                        expr,\n+                        orig_expected,\n+                        arm_ty,\n+                        prior_arm,\n+                    )\n                 }),\n                 false,\n             );\n@@ -219,6 +177,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn suggest_removing_semicolon_for_coerce(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expectation: Expectation<'tcx>,\n+        arm_ty: Ty<'tcx>,\n+        prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n+    ) {\n+        let hir = self.tcx.hir();\n+\n+        // First, check that we're actually in the tail of a function.\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n+            hir.get(self.body_id) else { return; };\n+        let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n+            = block.innermost_block().stmts.last() else {  return; };\n+        if last_expr.hir_id != expr.hir_id {\n+            return;\n+        }\n+\n+        // Next, make sure that we have no type expectation.\n+        let Some(ret) = hir\n+            .find_by_def_id(self.body_id.owner.def_id)\n+            .and_then(|owner| owner.fn_decl())\n+            .map(|decl| decl.output.span()) else { return; };\n+        let Expectation::IsLast(stmt) = expectation else {\n+            return;\n+        };\n+\n+        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+            Some(ret_coercion) => {\n+                let ret_ty = ret_coercion.borrow().expected_ty();\n+                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                self.can_coerce(arm_ty, ret_ty)\n+                    && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n+                    // The match arms need to unify for the case of `impl Trait`.\n+                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+            }\n+            _ => false,\n+        };\n+        if !can_coerce_to_return_ty {\n+            return;\n+        }\n+\n+        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+        let mut ret_span: MultiSpan = semi_span.into();\n+        ret_span.push_span_label(\n+            expr.span,\n+            \"this could be implicitly returned but it is a statement, not a \\\n+                            tail expression\",\n+        );\n+        ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n+        ret_span.push_span_label(\n+            semi_span,\n+            \"the `match` is a statement because of this semicolon, consider \\\n+                            removing it\",\n+        );\n+        diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n+        diag.tool_only_span_suggestion(\n+            semi_span,\n+            \"remove this semicolon\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {\n@@ -491,11 +514,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ..\n                 } = self.type_var_origin(expected)? else { return None; };\n \n-                let sig = *self\n-                    .typeck_results\n-                    .borrow()\n-                    .liberated_fn_sigs()\n-                    .get(hir::HirId::make_owner(self.body_id.owner.def_id))?;\n+                let sig = self.body_fn_sig()?;\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()"}, {"sha": "41b52a4c4a9fcb2901c2f26a1562e65faae1a7b3", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -12,18 +12,7 @@ use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, span)\n-    }\n-\n-    /// Like `autoderef`, but provides a custom `Span` to use for calls to\n-    /// an overloaded `Deref` operator\n-    pub fn autoderef_overloaded_span(\n-        &'a self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        overloaded_span: Span,\n-    ) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, overloaded_span)\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n \n     pub fn try_overloaded_deref(\n@@ -55,11 +44,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                Some(OverloadedDeref {\n-                                    region,\n-                                    mutbl,\n-                                    span: autoderef.overloaded_span(),\n-                                })\n+                                Some(OverloadedDeref { region, mutbl, span: autoderef.span() })\n                             } else {\n                                 None\n                             }"}, {"sha": "2b019c8c9b7a581f09facce0ee0c90845c9ebe0c", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -129,6 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         output\n     }\n \n+    #[instrument(level = \"debug\", skip(self, call_expr, callee_expr, arg_exprs, autoderef), ret)]\n     fn try_overloaded_call_step(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,\n@@ -138,10 +139,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty =\n             self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n-        debug!(\n-            \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n-            call_expr, adjusted_ty\n-        );\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match *adjusted_ty.kind() {\n@@ -471,6 +468,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             def_id,\n         );\n \n+        if fn_sig.abi == abi::Abi::RustCall {\n+            let sp = arg_exprs.last().map_or(call_expr.span, |expr| expr.span);\n+            if let Some(ty) = fn_sig.inputs().last().copied() {\n+                self.register_bound(\n+                    ty,\n+                    self.tcx.require_lang_item(hir::LangItem::Tuple, Some(sp)),\n+                    traits::ObligationCause::new(sp, self.body_id, traits::RustCall),\n+                );\n+            } else {\n+                self.tcx.sess.span_err(\n+                        sp,\n+                        \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+                    );\n+            }\n+        }\n+\n         fn_sig.output()\n     }\n "}, {"sha": "7d3129f7ea730567e0bbaefbdc263ca0c27c5f5f", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -60,6 +60,8 @@ pub struct CastCheck<'tcx> {\n     cast_ty: Ty<'tcx>,\n     cast_span: Span,\n     span: Span,\n+    /// whether the cast is made in a const context or not.\n+    pub constness: hir::Constness,\n }\n \n /// The kind of pointer and associated metadata (thin, length or vtable) - we\n@@ -92,10 +94,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n         let t = self.resolve_vars_if_possible(t);\n-\n-        if let Some(reported) = t.error_reported() {\n-            return Err(reported);\n-        }\n+        t.error_reported()?;\n \n         if self.type_is_sized_modulo_regions(self.param_env, t, span) {\n             return Ok(Some(PointerKind::Thin));\n@@ -210,17 +209,17 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         cast_ty: Ty<'tcx>,\n         cast_span: Span,\n         span: Span,\n+        constness: hir::Constness,\n     ) -> Result<CastCheck<'tcx>, ErrorGuaranteed> {\n         let expr_span = expr.span.find_ancestor_inside(span).unwrap_or(expr.span);\n-        let check = CastCheck { expr, expr_ty, expr_span, cast_ty, cast_span, span };\n+        let check = CastCheck { expr, expr_ty, expr_span, cast_ty, cast_span, span, constness };\n \n         // For better error messages, check for some obviously unsized\n         // cases now. We do a more thorough check at the end, once\n         // inference is more completely known.\n         match cast_ty.kind() {\n             ty::Dynamic(_, _, ty::Dyn) | ty::Slice(..) => {\n-                let reported = check.report_cast_to_unsized_type(fcx);\n-                Err(reported)\n+                Err(check.report_cast_to_unsized_type(fcx))\n             }\n             _ => Ok(check),\n         }\n@@ -611,10 +610,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx>) -> ErrorGuaranteed {\n-        if let Some(reported) =\n-            self.cast_ty.error_reported().or_else(|| self.expr_ty.error_reported())\n-        {\n-            return reported;\n+        if let Err(err) = self.cast_ty.error_reported() {\n+            return err;\n+        }\n+        if let Err(err) = self.expr_ty.error_reported() {\n+            return err;\n         }\n \n         let tstr = fcx.ty_to_string(self.cast_ty);\n@@ -866,7 +866,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            (_, DynStar) | (DynStar, _) => bug!(\"should be handled by `try_coerce`\"),\n+            (_, DynStar) | (DynStar, _) => {\n+                if fcx.tcx.features().dyn_star {\n+                    bug!(\"should be handled by `try_coerce`\")\n+                } else {\n+                    Err(CastError::IllegalCast)\n+                }\n+            }\n         }\n     }\n "}, {"sha": "3c57e33f6f7fb164e10213569cf5a32cd538343c", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -6,13 +6,11 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ImplicitSelfKind, ItemKind, Node};\n use rustc_hir_analysis::check::fn_maybe_err;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefId;\n-use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use std::cell::RefCell;\n \n@@ -31,13 +29,11 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fn_id: hir::HirId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n-    return_type_pre_known: bool,\n ) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n     // Create the function context. This is either derived from scratch or,\n     // in the case of closures, based on the outer context.\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n-    fcx.return_type_pre_known = return_type_pre_known;\n \n     let tcx = fcx.tcx;\n     let hir = tcx.hir();\n@@ -51,51 +47,13 @@ pub(super) fn check_fn<'a, 'tcx>(\n             decl.output.span(),\n             param_env,\n         ));\n-    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n-    // an opaque type, so set a flag so we can improve diagnostics.\n-    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n \n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n \n     let span = body.value.span;\n \n     fn_maybe_err(tcx, span, fn_sig.abi);\n \n-    if fn_sig.abi == Abi::RustCall {\n-        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n-\n-        let err = || {\n-            let item = match tcx.hir().get(fn_id) {\n-                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n-                Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(header, ..), ..\n-                }) => Some(header),\n-                Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(header, ..),\n-                    ..\n-                }) => Some(header),\n-                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n-                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-            };\n-\n-            if let Some(header) = item {\n-                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n-            }\n-        };\n-\n-        if fn_sig.inputs().len() != expected_args {\n-            err()\n-        } else {\n-            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n-            //   This will probably require wide-scale changes to support a TupleKind obligation\n-            //   We can't resolve this without knowing the type of the param\n-            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n-                err()\n-            }\n-        }\n-    }\n-\n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n@@ -142,7 +100,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -161,7 +118,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value, false);\n     }\n-    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n@@ -211,13 +167,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n     }\n \n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n-        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n     (fcx, gen_ty)\n }\n \n@@ -273,52 +222,3 @@ fn check_panic_info_fn(\n         tcx.sess.span_err(span, \"should have no const parameters\");\n     }\n }\n-\n-fn check_alloc_error_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n-        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_alloc_layout = match inputs[0].kind() {\n-        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-        _ => false,\n-    };\n-\n-    if !arg_is_alloc_layout {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess\n-            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n-    }\n-}"}, {"sha": "63062761b500d9ac8ebe62944cf859b0a9b87003", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 57, "deletions": 61, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -10,18 +10,20 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::ArgKind;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use std::cmp;\n use std::iter;\n \n /// What signature do we *expect* the closure to have from context?\n-#[derive(Debug)]\n+#[derive(Debug, Clone, TypeFoldable, TypeVisitable)]\n struct ExpectedSig<'tcx> {\n     /// Span that gave us this expectation, if we know that.\n     cause_span: Option<Span>,\n@@ -33,7 +35,7 @@ struct ClosureSignatures<'tcx> {\n     bound_sig: ty::PolyFnSig<'tcx>,\n     /// The signature within the function body.\n     /// This mostly differs in the sense that lifetimes are now early bound and any\n-    /// opaque types from the signature expectation are overriden in case there are\n+    /// opaque types from the signature expectation are overridden in case there are\n     /// explicit hidden types written by the user in the closure signature.\n     liberated_sig: ty::FnSig<'tcx>,\n }\n@@ -82,8 +84,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         debug!(?bound_sig, ?liberated_sig);\n \n-        let return_type_pre_known = !liberated_sig.output().is_ty_infer();\n-\n         let generator_types = check_fn(\n             self,\n             self.param_env.without_const(),\n@@ -92,7 +92,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr.hir_id,\n             body,\n             gen,\n-            return_type_pre_known,\n         )\n         .1;\n \n@@ -174,34 +173,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty: Ty<'tcx>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n         match *expected_ty.kind() {\n-            ty::Opaque(def_id, substs) => {\n-                let bounds = self.tcx.bound_explicit_item_bounds(def_id);\n-                let sig =\n-                    bounds.subst_iter_copied(self.tcx, substs).find_map(|(pred, span)| match pred\n-                        .kind()\n-                        .skip_binder()\n-                    {\n-                        ty::PredicateKind::Projection(proj_predicate) => self\n-                            .deduce_sig_from_projection(\n-                                Some(span),\n-                                pred.kind().rebind(proj_predicate),\n-                            ),\n-                        _ => None,\n-                    });\n-\n-                let kind = bounds\n-                    .0\n-                    .iter()\n-                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(tp) => {\n-                            self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n-                        }\n-                        _ => None,\n-                    })\n-                    .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n-                trace!(?sig, ?kind);\n-                (sig, kind)\n-            }\n+            ty::Opaque(def_id, substs) => self.deduce_signature_from_predicates(\n+                self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+            ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n                     let pb = pb.with_self_ty(self.tcx, self.tcx.types.trait_object_dummy_self);\n@@ -212,7 +186,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n                 (sig, kind)\n             }\n-            ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.deduce_signature_from_predicates(\n+                self.obligations_for_self_ty(vid).map(|obl| (obl.predicate, obl.cause.span)),\n+            ),\n             ty::FnPtr(sig) => {\n                 let expected_sig = ExpectedSig { cause_span: None, sig };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n@@ -221,37 +197,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn deduce_expectations_from_obligations(\n+    fn deduce_signature_from_predicates(\n         &self,\n-        expected_vid: ty::TyVid,\n+        predicates: impl DoubleEndedIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     ) -> (Option<ExpectedSig<'tcx>>, Option<ty::ClosureKind>) {\n-        let expected_sig =\n-            self.obligations_for_self_ty(expected_vid).find_map(|(_, obligation)| {\n-                debug!(?obligation.predicate);\n-\n-                let bound_predicate = obligation.predicate.kind();\n-                if let ty::PredicateKind::Projection(proj_predicate) =\n-                    obligation.predicate.kind().skip_binder()\n-                {\n-                    // Given a Projection predicate, we can potentially infer\n-                    // the complete signature.\n+        let mut expected_sig = None;\n+        let mut expected_kind = None;\n+\n+        for obligation in traits::elaborate_predicates_with_span(\n+            self.tcx,\n+            // Reverse the obligations here, since `elaborate_*` uses a stack,\n+            // and we want to keep inference generally in the same order of\n+            // the registered obligations.\n+            predicates.rev(),\n+        ) {\n+            debug!(?obligation.predicate);\n+            let bound_predicate = obligation.predicate.kind();\n+\n+            // Given a Projection predicate, we can potentially infer\n+            // the complete signature.\n+            if expected_sig.is_none()\n+                && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n+            {\n+                expected_sig = self.normalize_associated_types_in(\n+                    obligation.cause.span,\n                     self.deduce_sig_from_projection(\n-                        Some(obligation.cause.span),\n+                    Some(obligation.cause.span),\n                         bound_predicate.rebind(proj_predicate),\n-                    )\n-                } else {\n-                    None\n-                }\n-            });\n+                    ),\n+                );\n+            }\n \n-        // Even if we can't infer the full signature, we may be able to\n-        // infer the kind. This can occur when we elaborate a predicate\n-        // like `F : Fn<A>`. Note that due to subtyping we could encounter\n-        // many viable options, so pick the most restrictive.\n-        let expected_kind = self\n-            .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n-            .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+            // Even if we can't infer the full signature, we may be able to\n+            // infer the kind. This can occur when we elaborate a predicate\n+            // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+            // many viable options, so pick the most restrictive.\n+            let trait_def_id = match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Projection(data) => {\n+                    Some(data.projection_ty.trait_def_id(self.tcx))\n+                }\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()),\n+                _ => None,\n+            };\n+            if let Some(closure_kind) =\n+                trait_def_id.and_then(|def_id| self.tcx.fn_trait_kind_from_lang_item(def_id))\n+            {\n+                expected_kind = Some(\n+                    expected_kind\n+                        .map_or_else(|| closure_kind, |current| cmp::min(current, closure_kind)),\n+                );\n+            }\n+        }\n \n         (expected_sig, expected_kind)\n     }\n@@ -689,7 +685,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let output_ty = match *ret_ty.kind() {\n             ty::Infer(ty::TyVar(ret_vid)) => {\n-                self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n+                self.obligations_for_self_ty(ret_vid).find_map(|obligation| {\n                     get_future_output(obligation.predicate, obligation.cause.span)\n                 })?\n             }"}, {"sha": "71949b4211819b79d08c09b5b32872504294a3a7", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -62,6 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::TraitEngineExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -705,12 +706,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.err_ctxt().report_selection_error(\n-                        obligation.clone(),\n-                        &obligation,\n-                        &err,\n-                        false,\n-                    );\n+                    self.err_ctxt().report_selection_error(obligation.clone(), &obligation, &err);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -1043,7 +1039,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = traits::FulfillmentContext::new_in_snapshot();\n+            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n             fcx.register_predicate_obligations(self, ok.obligations);\n             fcx.select_where_possible(&self).is_empty()\n         })\n@@ -1644,9 +1640,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 if visitor.ret_exprs.len() > 0 && let Some(expr) = expression {\n                     self.note_unreachable_loop_return(&mut err, &expr, &visitor.ret_exprs);\n                 }\n-                err.emit_unless(unsized_return);\n+                let reported = err.emit_unless(unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.ty_error());\n+                self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }\n@@ -1782,7 +1778,8 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             // may occur at the first return expression we see in the closure\n             // (if it conflicts with the declared return type). Skip adding a\n             // note in this case, since it would be incorrect.\n-            && !fcx.return_type_pre_known\n+            && let Some(fn_sig) = fcx.body_fn_sig()\n+            && fn_sig.output().is_ty_var()\n         {\n             err.span_note(\n                 sp,"}, {"sha": "9ca7730daa68d3ee71d2b7db1b03a951841c4be1", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -30,6 +30,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n         error: Option<TypeError<'tcx>>,\n     ) {\n+        if expr_ty == expected {\n+            return;\n+        }\n+\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n@@ -42,7 +46,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty)\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n-            || self.suggest_into(err, expr, expr_ty, expected);\n+            || self.suggest_into(err, expr, expr_ty, expected)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n+            || self.suggest_floating_point_literal(err, expr, expected);\n \n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n@@ -530,24 +536,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         hir_id: hir::HirId,\n     ) -> Vec<AssocItem> {\n-        let mut methods =\n-            self.probe_for_return_type(span, probe::Mode::MethodCall, expected, checked_ty, hir_id);\n-        methods.retain(|m| {\n-            self.has_only_self_parameter(m)\n-                && self\n-                    .tcx\n-                    // This special internal attribute is used to permit\n-                    // \"identity-like\" conversion methods to be suggested here.\n-                    //\n-                    // FIXME (#46459 and #46460): ideally\n-                    // `std::convert::Into::into` and `std::borrow:ToOwned` would\n-                    // also be `#[rustc_conversion_suggestion]`, if not for\n-                    // method-probing false-positives and -negatives (respectively).\n-                    //\n-                    // FIXME? Other potential candidate methods: `as_ref` and\n-                    // `as_mut`?\n-                    .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n-        });\n+        let methods = self.probe_for_return_type(\n+            span,\n+            probe::Mode::MethodCall,\n+            expected,\n+            checked_ty,\n+            hir_id,\n+            |m| {\n+                self.has_only_self_parameter(m)\n+                    && self\n+                        .tcx\n+                        // This special internal attribute is used to permit\n+                        // \"identity-like\" conversion methods to be suggested here.\n+                        //\n+                        // FIXME (#46459 and #46460): ideally\n+                        // `std::convert::Into::into` and `std::borrow:ToOwned` would\n+                        // also be `#[rustc_conversion_suggestion]`, if not for\n+                        // method-probing false-positives and -negatives (respectively).\n+                        //\n+                        // FIXME? Other potential candidate methods: `as_ref` and\n+                        // `as_mut`?\n+                        .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n+            },\n+        );\n \n         methods\n     }\n@@ -714,7 +725,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, String, String, Applicability, bool /* verbose */)> {\n+    ) -> Option<(\n+        Span,\n+        String,\n+        String,\n+        Applicability,\n+        bool, /* verbose */\n+        bool, /* suggest `&` or `&mut` type annotation */\n+    )> {\n         let sess = self.sess();\n         let sp = expr.span;\n \n@@ -746,6 +764,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     String::new(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                             }\n                         }\n@@ -760,6 +779,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                     }\n                 }\n@@ -817,6 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 sugg.2,\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ));\n                         }\n \n@@ -844,13 +865,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 format!(\"{prefix}&mut {sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\".to_string(),\n                                 format!(\"{prefix}&{sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                         });\n                     }\n@@ -880,6 +903,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n+                            true\n                         ));\n                     }\n                     return None;\n@@ -893,6 +917,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         String::new(),\n                         Applicability::MachineApplicable,\n                         true,\n+                        true,\n                     ));\n                 }\n             }\n@@ -959,6 +984,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             src,\n                             applicability,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }\n@@ -999,6 +1025,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Applicability::MachineApplicable\n                             },\n                             true,\n+                            false,\n                         ));\n                     }\n \n@@ -1050,6 +1077,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             suggestion,\n                             Applicability::MachineApplicable,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }"}, {"sha": "afac6e7d94a8116ca0ef9916c61c569d1f24dbfb", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -113,8 +113,9 @@ pub struct MissingParentheseInRange {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion_verbose(\n+#[multipart_suggestion(\n     hir_analysis_add_missing_parentheses_in_range,\n+    style = \"verbose\",\n     applicability = \"maybe-incorrect\"\n )]\n pub struct AddMissingParenthesesInRange {\n@@ -124,3 +125,11 @@ pub struct AddMissingParenthesesInRange {\n     #[suggestion_part(code = \")\")]\n     pub right: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_op_trait_generic_params)]\n+pub struct OpMethodGenericParams {\n+    #[primary_span]\n+    pub span: Span,\n+    pub method_name: String,\n+}"}, {"sha": "e948d832e3280997fd134daf86d38b42712ce606", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -80,14 +80,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n             if let Some(adjustments) = self.typeck_results.borrow().adjustments().get(expr.hir_id) {\n-                self.tcx().sess.delay_span_bug(\n+                let reported = self.tcx().sess.delay_span_bug(\n                     expr.span,\n                     \"expression with never type wound up being adjusted\",\n                 );\n                 return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &adjustments[..] {\n                     target.to_owned()\n                 } else {\n-                    self.tcx().ty_error()\n+                    self.tcx().ty_error_with_guaranteed(reported)\n                 };\n             }\n \n@@ -103,8 +103,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = expr.peel_drop_temps();\n-            self.suggest_deref_ref_or_into(&mut err, expr, expected_ty, ty, None);\n+            // FIXME(compiler-errors): We probably should fold some of the\n+            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n+            // since some of those aren't necessarily just coerce suggestions.\n+            let _ = self.suggest_deref_ref_or_into(\n+                &mut err,\n+                expr.peel_drop_temps(),\n+                expected_ty,\n+                ty,\n+                None,\n+            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n             extend_err(&mut err);\n             err.emit();\n         }\n@@ -220,7 +228,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n-        let old_has_errors = self.has_errors.replace(false);\n \n         let ty = ensure_sufficient_stack(|| match &expr.kind {\n             hir::ExprKind::Path(\n@@ -259,7 +266,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Combine the diverging and has_error flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n         debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n@@ -398,8 +404,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n                         }\n-                        err.emit();\n-                        oprnd_t = tcx.ty_error();\n+                        oprnd_t = tcx.ty_error_with_guaranteed(err.emit());\n                     }\n                 }\n                 hir::UnOp::Not => {\n@@ -840,10 +845,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return_expr_ty,\n         );\n \n-        if self.return_type_has_opaque {\n+        if let Some(fn_sig) = self.body_fn_sig()\n+            && fn_sig.output().has_opaque_types()\n+        {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n-            self.select_obligations_where_possible(false, |errors| {\n+            self.select_obligations_where_possible(|errors| {\n                 self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty);\n             });\n         }\n@@ -1097,12 +1104,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // If the assignment expression itself is ill-formed, don't\n             // bother emitting another error\n-            if lhs_ty.references_error() || rhs_ty.references_error() {\n-                err.delay_as_bug()\n-            } else {\n-                err.emit();\n-            }\n-            return self.tcx.ty_error();\n+            let reported = err.emit_unless(lhs_ty.references_error() || rhs_ty.references_error());\n+            return self.tcx.ty_error_with_guaranteed(reported);\n         }\n \n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -1272,7 +1275,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-            match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+            match cast::CastCheck::new(\n+                self,\n+                e,\n+                t_expr,\n+                t_cast,\n+                t.span,\n+                expr.span,\n+                self.param_env.constness(),\n+            ) {\n                 Ok(cast_check) => {\n                     debug!(\n                         \"check_expr_cast: deferring cast from {:?} to {:?}: {:?}\",\n@@ -2730,7 +2741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n-                    self.select_obligations_where_possible(false, |errors| {\n+                    self.select_obligations_where_possible(|errors| {\n                         self.point_at_index_if_possible(errors, idx.span)\n                     });\n                     element_ty\n@@ -2769,8 +2780,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    err.emit();\n-                    self.tcx.ty_error()\n+                    let reported = err.emit();\n+                    self.tcx.ty_error_with_guaranteed(reported)\n                 }\n             }\n         }"}, {"sha": "5d44092a5f68e33c440e652e24608bf9745ba161", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -7,16 +7,16 @@ use rustc_data_structures::{\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n-    /// Performs type inference fallback, returning true if any fallback\n-    /// occurs.\n-    pub(super) fn type_inference_fallback(&self) -> bool {\n+    /// Performs type inference fallback, setting `FnCtxt::fallback_has_occurred`\n+    /// if fallback has occurred.\n+    pub(super) fn type_inference_fallback(&self) {\n         debug!(\n             \"type-inference-fallback start obligations: {:#?}\",\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n         // All type checking constraints were added, try to fallback unsolved variables.\n-        self.select_obligations_where_possible(false, |_| {});\n+        self.select_obligations_where_possible(|_| {});\n \n         debug!(\n             \"type-inference-fallback post selection obligations: {:#?}\",\n@@ -26,18 +26,17 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n-            return false;\n+            return;\n         }\n \n         let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n \n-        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n         for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n+            self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n         // We now see if we can make progress. This might cause us to\n@@ -63,9 +62,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // If we had tried to fallback the opaque inference variable to `MyType`,\n         // we will generate a confusing type-check error that does not explicitly\n         // refer to opaque types.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        fallback_has_occurred\n+        self.select_obligations_where_possible(|_| {});\n     }\n \n     // Tries to apply a fallback to `ty` if it is an unsolved variable.\n@@ -81,12 +78,13 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     // Fallback becomes very dubious if we have encountered\n     // type-checking errors.  In that case, fallback to Error.\n     //\n-    // The return value indicates whether fallback has occurred.\n+    // Sets `FnCtxt::fallback_has_occurred` if fallback is performed\n+    // during this call.\n     fn fallback_if_possible(\n         &self,\n         ty: Ty<'tcx>,\n         diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n-    ) -> bool {\n+    ) {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n         // is an unsolved variable, and we determine its fallback\n         // based solely on how it was created, not what other type\n@@ -111,7 +109,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {\n                 Some(&fallback_ty) => fallback_ty,\n-                None => return false,\n+                None => return,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -122,7 +120,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n         self.demand_eqtype(span, ty, fallback);\n-        true\n+        self.fallback_has_occurred.set(true);\n     }\n \n     /// The \"diverging fallback\" system is rather complicated. This is"}, {"sha": "c6bd771fad2568e4b8578316c80013836f845e38", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 63, "deletions": 86, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -18,11 +18,12 @@ use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryRespons\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n-    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPolyTraitRef,\n-    ToPredicate, Ty, UserType,\n+    self, AdtKind, CanonicalUserType, DefIdTree, EarlyBinder, GenericParamDefKind, ToPredicate, Ty,\n+    UserType,\n };\n use rustc_middle::ty::{GenericArgKind, InternalSubsts, SubstsRef, UserSelfTy, UserSubsts};\n use rustc_session::lint;\n@@ -32,9 +33,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -106,7 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        self.select_obligations_where_possible(false, mutate_fulfillment_errors);\n+        self.select_obligations_where_possible(mutate_fulfillment_errors);\n         self.resolve_vars_if_possible(ty)\n     }\n \n@@ -143,7 +142,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n-            self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n     }\n@@ -601,7 +599,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n-            self.select_obligations_where_possible(false, |_| {});\n+            self.select_obligations_where_possible(|_| {});\n             crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n@@ -612,25 +610,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id, false);\n+            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n     pub(in super::super) fn select_obligations_where_possible(\n         &self,\n-        fallback_has_occurred: bool,\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) {\n         let mut result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.err_ctxt().report_fulfillment_errors(\n-                &result,\n-                self.inh.body_id,\n-                fallback_has_occurred,\n-            );\n+            self.err_ctxt().report_fulfillment_errors(&result, self.inh.body_id);\n         }\n     }\n \n@@ -650,12 +643,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> bool {\n-        let self_ty = self.shallow_resolve(trait_ref.skip_binder().self_ty());\n+    fn self_type_matches_expected_vid(&self, self_ty: Ty<'tcx>, expected_vid: ty::TyVid) -> bool {\n+        let self_ty = self.shallow_resolve(self_ty);\n         debug!(?self_ty);\n \n         match *self_ty.kind() {\n@@ -674,54 +663,61 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn obligations_for_self_ty<'b>(\n         &'b self,\n         self_ty: ty::TyVid,\n-    ) -> impl Iterator<Item = (ty::PolyTraitRef<'tcx>, traits::PredicateObligation<'tcx>)>\n-    + Captures<'tcx>\n-    + 'b {\n+    ) -> impl DoubleEndedIterator<Item = traits::PredicateObligation<'tcx>> + Captures<'tcx> + 'b\n+    {\n         // FIXME: consider using `sub_root_var` here so we\n         // can see through subtyping.\n         let ty_var_root = self.root_var(self_ty);\n         trace!(\"pending_obligations = {:#?}\", self.fulfillment_cx.borrow().pending_obligations());\n \n-        self.fulfillment_cx\n-            .borrow()\n-            .pending_obligations()\n-            .into_iter()\n-            .filter_map(move |obligation| {\n-                let bound_predicate = obligation.predicate.kind();\n-                match bound_predicate.skip_binder() {\n-                    ty::PredicateKind::Projection(data) => Some((\n-                        bound_predicate.rebind(data).required_poly_trait_ref(self.tcx),\n-                        obligation,\n-                    )),\n-                    ty::PredicateKind::Trait(data) => {\n-                        Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n-                    }\n-                    ty::PredicateKind::Subtype(..) => None,\n-                    ty::PredicateKind::Coerce(..) => None,\n-                    ty::PredicateKind::RegionOutlives(..) => None,\n-                    ty::PredicateKind::TypeOutlives(..) => None,\n-                    ty::PredicateKind::WellFormed(..) => None,\n-                    ty::PredicateKind::ObjectSafe(..) => None,\n-                    ty::PredicateKind::ConstEvaluatable(..) => None,\n-                    ty::PredicateKind::ConstEquate(..) => None,\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of an unresolved\n-                    // inference variable.\n-                    ty::PredicateKind::ClosureKind(..) => None,\n-                    ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+        self.fulfillment_cx.borrow().pending_obligations().into_iter().filter_map(\n+            move |obligation| match &obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(data)\n+                    if self.self_type_matches_expected_vid(\n+                        data.projection_ty.self_ty(),\n+                        ty_var_root,\n+                    ) =>\n+                {\n+                    Some(obligation)\n                 }\n-            })\n-            .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n+                ty::PredicateKind::Trait(data)\n+                    if self.self_type_matches_expected_vid(data.self_ty(), ty_var_root) =>\n+                {\n+                    Some(obligation)\n+                }\n+\n+                ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Coerce(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of an unresolved\n+                // inference variable.\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+            },\n+        )\n     }\n \n     pub(in super::super) fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n-        self.obligations_for_self_ty(self_ty)\n-            .any(|(tr, _)| Some(tr.def_id()) == self.tcx.lang_items().sized_trait())\n+        let sized_did = self.tcx.lang_items().sized_trait();\n+        self.obligations_for_self_ty(self_ty).any(|obligation| {\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(data) => Some(data.def_id()) == sized_did,\n+                _ => false,\n+            }\n+        })\n     }\n \n     pub(in super::super) fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n@@ -769,34 +765,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let expect_args = self\n             .fudge_inference_if_ok(|| {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = self.misc(call_span);\n-                let ures = self.at(&origin, self.param_env).sup(ret_ty, formal_ret);\n-\n-                // FIXME(#27336) can't use ? here, Try::from_error doesn't default\n-                // to identity so the resulting type is not constrained.\n-                match ures {\n-                    Ok(ok) => {\n-                        // Process any obligations locally as much as\n-                        // we can.  We don't care if some things turn\n-                        // out unconstrained or ambiguous, as we're\n-                        // just trying to get hints here.\n-                        let errors = self.save_and_restore_in_snapshot_flag(|_| {\n-                            let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                            for obligation in ok.obligations {\n-                                fulfill.register_predicate_obligation(self, obligation);\n-                            }\n-                            fulfill.select_where_possible(self)\n-                        });\n-\n-                        if !errors.is_empty() {\n-                            return Err(());\n-                        }\n-                    }\n-                    Err(_) => return Err(()),\n+                ocx.sup(&origin, self.param_env, ret_ty, formal_ret)?;\n+                if !ocx.select_where_possible().is_empty() {\n+                    return Err(TypeError::Mismatch);\n                 }\n \n                 // Record all the argument types, with the substitutions\n@@ -1215,9 +1193,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    err.emit();\n-\n-                    return (tcx.ty_error(), res);\n+                    let reported = err.emit();\n+                    return (tcx.ty_error_with_guaranteed(reported), res);\n                 }\n             }\n         } else {"}, {"sha": "8cf70eb5431a8c4ec2d6fd1a11455ffb4d771158", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -33,16 +33,27 @@ use rustc_span::{self, sym, Span};\n use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n+use std::mem;\n use std::ops::ControlFlow;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub(in super::super) fn check_casts(&self) {\n-        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+    pub(in super::super) fn check_casts(&mut self) {\n+        // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n+        // when writing to `self.param_env`.\n+        let mut deferred_cast_checks = mem::take(&mut *self.deferred_cast_checks.borrow_mut());\n+\n         debug!(\"FnCtxt::check_casts: {} deferred checks\", deferred_cast_checks.len());\n         for cast in deferred_cast_checks.drain(..) {\n+            let prev_env = self.param_env;\n+            self.param_env = self.param_env.with_constness(cast.constness);\n+\n             cast.check(self);\n+\n+            self.param_env = prev_env;\n         }\n+\n+        *self.deferred_cast_checks.borrow_mut() = deferred_cast_checks;\n     }\n \n     pub(in super::super) fn check_transmutes(&self) {\n@@ -125,6 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tuple_arguments,\n             Some(method.def_id),\n         );\n+\n         method.sig.output()\n     }\n \n@@ -203,7 +215,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n-                    .emit();\n+                    .delay_as_bug();\n                     (self.err_args(provided_args.len()), None)\n                 }\n             }\n@@ -333,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n-                self.select_obligations_where_possible(false, |_| {})\n+                self.select_obligations_where_possible(|_| {})\n             }\n \n             // Check each argument, to satisfy the input it was provided for\n@@ -585,6 +597,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let mk_trace = |span, (formal_ty, expected_ty), provided_ty| {\n+            let mismatched_ty = if expected_ty == provided_ty {\n+                // If expected == provided, then we must have failed to sup\n+                // the formal type. Avoid printing out \"expected Ty, found Ty\"\n+                // in that case.\n+                formal_ty\n+            } else {\n+                expected_ty\n+            };\n+            TypeTrace::types(&self.misc(span), true, mismatched_ty, provided_ty)\n+        };\n+\n         // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n         // We'll try to detect 4 different types of mistakes:\n         // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n@@ -649,10 +673,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // A tuple wrap suggestion actually occurs within,\n                         // so don't do anything special here.\n                         err = self.err_ctxt().report_and_explain_type_error(\n-                            TypeTrace::types(\n-                                &self.misc(*lo),\n-                                true,\n-                                formal_and_expected_inputs[mismatch_idx.into()].1,\n+                            mk_trace(\n+                                *lo,\n+                                formal_and_expected_inputs[mismatch_idx.into()],\n                                 provided_arg_tys[mismatch_idx.into()].0,\n                             ),\n                             terr,\n@@ -736,9 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         errors.drain_filter(|error| {\n                 let Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(Some(e))) = error else { return false };\n                 let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n-                let (expected_ty, _) = formal_and_expected_inputs[*expected_idx];\n-                let cause = &self.misc(provided_span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                let trace = mk_trace(provided_span, formal_and_expected_inputs[*expected_idx], provided_ty);\n                 if !matches!(trace.cause.as_failure_code(*e), FailureCode::Error0308(_)) {\n                     self.err_ctxt().report_and_explain_type_error(trace, *e).emit();\n                     return true;\n@@ -762,8 +783,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             let (formal_ty, expected_ty) = formal_and_expected_inputs[*expected_idx];\n             let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n-            let cause = &self.misc(provided_arg_span);\n-            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+            let trace = mk_trace(provided_arg_span, (formal_ty, expected_ty), provided_ty);\n             let mut err = self.err_ctxt().report_and_explain_type_error(trace, *err);\n             self.emit_coerce_suggestions(\n                 &mut err,\n@@ -835,8 +855,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (formal_ty, expected_ty) = formal_and_expected_inputs[expected_idx];\n                     let (provided_ty, provided_span) = provided_arg_tys[provided_idx];\n                     if let Compatibility::Incompatible(error) = compatibility {\n-                        let cause = &self.misc(provided_span);\n-                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        let trace = mk_trace(provided_span, (formal_ty, expected_ty), provided_ty);\n                         if let Some(e) = error {\n                             self.err_ctxt().note_type_err(\n                                 &mut err,\n@@ -1323,7 +1342,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.replace(Diverges::Maybe);\n-        let old_has_errors = self.has_errors.replace(false);\n \n         match stmt.kind {\n             hir::StmtKind::Local(l) => {\n@@ -1353,7 +1371,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Combine the diverging and `has_error` flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n     }\n \n     pub fn check_block_no_value(&self, blk: &'tcx hir::Block<'tcx>) {\n@@ -1533,11 +1550,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.diverges.set(prev_diverges);\n         }\n \n-        let mut ty = ctxt.coerce.unwrap().complete(self);\n-\n-        if self.has_errors.get() || ty.references_error() {\n-            ty = self.tcx.ty_error()\n-        }\n+        let ty = ctxt.coerce.unwrap().complete(self);\n \n         self.write_ty(blk.hir_id, ty);\n "}, {"sha": "d5e4b6de581c3551a2af1020a282790f0807f431", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -68,10 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    /// Used exclusively to reduce cost of advanced evaluation used for\n-    /// more helpful diagnostics.\n-    pub(super) in_tail_expr: bool,\n-\n     /// First span of a return site that we find. Used in error messages.\n     pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n@@ -112,21 +108,11 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// the diverges flag is set to something other than `Maybe`.\n     pub(super) diverges: Cell<Diverges>,\n \n-    /// Whether any child nodes have any type errors.\n-    pub(super) has_errors: Cell<bool>,\n-\n     pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n \n     pub(super) inh: &'a Inherited<'tcx>,\n \n-    /// True if the function or closure's return type is known before\n-    /// entering the function/closure, i.e. if the return type is\n-    /// either given explicitly or inferred from, say, an `Fn*` trait\n-    /// bound. Used for diagnostic purposes only.\n-    pub(super) return_type_pre_known: bool,\n-\n-    /// True if the return type has an Opaque type\n-    pub(super) return_type_has_opaque: bool,\n+    pub(super) fallback_has_occurred: Cell<bool>,\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -140,19 +126,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n-            has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n                 stack: Vec::new(),\n                 by_id: Default::default(),\n             }),\n             inh,\n-            return_type_pre_known: true,\n-            return_type_has_opaque: false,\n+            fallback_has_occurred: Cell::new(false),\n         }\n     }\n \n@@ -174,7 +157,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// [`InferCtxt::err_ctxt`]: infer::InferCtxt::err_ctxt\n     pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n-        TypeErrCtxt { infcx: &self.infcx, typeck_results: Some(self.typeck_results.borrow()) }\n+        TypeErrCtxt {\n+            infcx: &self.infcx,\n+            typeck_results: Some(self.typeck_results.borrow()),\n+            fallback_has_occurred: self.fallback_has_occurred.get(),\n+        }\n     }\n \n     pub fn errors_reported_since_creation(&self) -> bool {\n@@ -194,8 +181,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn item_def_id(&self) -> Option<DefId> {\n-        None\n+    fn item_def_id(&self) -> DefId {\n+        self.body_id.owner.to_def_id()\n     }\n \n     fn get_type_parameter_bounds("}, {"sha": "06e6e4350fcbcb9271aac6bb5b8a850692a211b6", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 142, "deletions": 4, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad", "patch": "@@ -13,7 +13,7 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -22,6 +22,14 @@ use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n+        self.typeck_results\n+            .borrow()\n+            .liberated_fn_sigs()\n+            .get(self.tcx.hir().get_parent_node(self.body_id))\n+            .copied()\n+    }\n+\n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n         err.span_suggestion_short(\n             span.shrink_to_hi(),\n@@ -327,17 +335,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n-        if let Some((sp, msg, suggestion, applicability, verbose)) =\n+        if let Some((sp, msg, suggestion, applicability, verbose, annotation)) =\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n                 err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n+            if annotation {\n+                let suggest_annotation = match expr.peel_drop_temps().kind {\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    _ => return true,\n+                };\n+                let mut tuple_indexes = Vec::new();\n+                let mut expr_id = expr.hir_id;\n+                for (parent_id, node) in self.tcx.hir().parent_iter(expr.hir_id) {\n+                    match node {\n+                        Node::Expr(&Expr { kind: ExprKind::Tup(subs), .. }) => {\n+                            tuple_indexes.push(\n+                                subs.iter()\n+                                    .enumerate()\n+                                    .find(|(_, sub_expr)| sub_expr.hir_id == expr_id)\n+                                    .unwrap()\n+                                    .0,\n+                            );\n+                            expr_id = parent_id;\n+                        }\n+                        Node::Local(local) => {\n+                            if let Some(mut ty) = local.ty {\n+                                while let Some(index) = tuple_indexes.pop() {\n+                                    match ty.kind {\n+                                        TyKind::Tup(tys) => ty = &tys[index],\n+                                        _ => return true,\n+                                    }\n+                                }\n+                                let annotation_span = ty.span;\n+                                err.span_suggestion(\n+                                    annotation_span.with_hi(annotation_span.lo()),\n+                                    \"alternatively, consider changing the type annotation\",\n+                                    suggest_annotation,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            break;\n+                        }\n+                        _ => break,\n+                    }\n+                }\n+            }\n             return true;\n-        } else if self.suggest_else_fn_with_closure(err, expr, found, expected)\n-        {\n+        } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = &found.kind()\n@@ -1067,6 +1116,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    /// When expecting a `bool` and finding an `Option`, suggests using `let Some(..)` or `.is_some()`\n+    pub(crate) fn suggest_option_to_bool(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expr_ty: Ty<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if !expected_ty.is_bool() {\n+            return false;\n+        }\n+\n+        let ty::Adt(def, _) = expr_ty.peel_refs().kind() else { return false; };\n+        if !self.tcx.is_diagnostic_item(sym::Option, def.did()) {\n+            return false;\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let cond_parent = hir.parent_iter(expr.hir_id).skip_while(|(_, node)| {\n+            matches!(node, hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, _, _), .. }) if op.node == hir::BinOpKind::And)\n+        }).next();\n+        // Don't suggest:\n+        //     `let Some(_) = a.is_some() && b`\n+        //                     ++++++++++\n+        // since the user probably just misunderstood how `let else`\n+        // and `&&` work together.\n+        if let Some((_, hir::Node::Local(local))) = cond_parent\n+            && let hir::PatKind::Path(qpath) | hir::PatKind::TupleStruct(qpath, _, _) = &local.pat.kind\n+            && let hir::QPath::Resolved(None, path) = qpath\n+            && let Some(did) = path.res.opt_def_id()\n+                .and_then(|did| self.tcx.opt_parent(did))\n+                .and_then(|did| self.tcx.opt_parent(did))\n+            && self.tcx.is_diagnostic_item(sym::Option, did)\n+        {\n+            return false;\n+        }\n+\n+        diag.span_suggestion(\n+            expr.span.shrink_to_hi(),\n+            \"use `Option::is_some` to test if the `Option` has a value\",\n+            \".is_some()\",\n+            Applicability::MachineApplicable,\n+        );\n+\n+        true\n+    }\n+\n     /// Suggest wrapping the block in square brackets instead of curly braces\n     /// in case the block was mistaken array syntax, e.g. `{ 1 }` -> `[ 1 ]`.\n     pub(crate) fn suggest_block_to_brackets(\n@@ -1108,6 +1204,48 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, err))]\n+    pub(crate) fn suggest_floating_point_literal(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        if !expected_ty.is_floating_point() {\n+            return false;\n+        }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::LangItem(LangItem::Range, ..), [start, end], _) => {\n+                err.span_suggestion_verbose(\n+                    start.span.shrink_to_hi().with_hi(end.span.lo()),\n+                    \"remove the unnecessary `.` operator for a floating point literal\",\n+                    '.',\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::Struct(QPath::LangItem(LangItem::RangeFrom, ..), [start], _) => {\n+                err.span_suggestion_verbose(\n+                    expr.span.with_lo(start.span.hi()),\n+                    \"remove the unnecessary `.` operator for a floating point literal\",\n+                    '.',\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::Struct(QPath::LangItem(LangItem::RangeTo, ..), [end], _) => {\n+                err.span_suggestion_verbose(\n+                    expr.span.until(end.span),\n+                    \"remove the unnecessary `.` operator and add an integer part for a floating point literal\",\n+                    \"0.\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "7bbfb70f2c3a320021cf1c3b4f104fb75f01c527", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "183e80f2e0840b610f47765a0972b3ab2d6f0e5f", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "d996d6ec610bae81c64789c6f9d8d676f1c309ed", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "4a8b774936543698c07c7f9bba395e96792b2a0b", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "3fcd073f5979300fd1d50713b2f196c4c5c797ad", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "edfe12963dc635adaa85b413d0fe441c8b4e73e9", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 236, "deletions": 154, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "38b3dd218a9719b4b28fcc41ff354c66bb50c42b", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "eb10f3e2c107f8f943b9d17c30cd8238b5fc9d8f", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "952ea14887f7bc7f279de7c1863e523c61c0195a", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "79e2d371ed37394c8a3e549a3d9be616452fe541", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "ec4eeb8caa27c9687b2684a29fc7a5c9736c46a0", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "7aaa5ce2f4242bd83ded5184a09162e5a0f6b855", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "3dc0d60b1eb0fab07d2358d1cf9c2c959f5c0cbd", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "0794792d8cb3786311cc2758fb8f647cfcebb7ad", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "a299a3e578d2237bf8a32dea8157939fdcedf200", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "a973bf54b055eb7b98ca89147abc3d3f1f8007d5", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "22f32251f6df0bff273c0e52999c9157209dac26", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 82, "deletions": 8, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "1067ccda20ca0ea4a80c64960c7330ce895cf8e7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "8a0e332f9c704b4f5f958e6f59bd546c65fa629a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "3fe7c1598fc3fbbf2e6ad540f2b2e9a557387e40", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "c42240f21724f77bf9a798b948b06e6368744809", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "b4efe8da1259266507da5ddd265f1021d00d03c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "fd26d7d29c5ee6ba1f13554126a8255e54323fd5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "d739323de77c817d7bbe41e3ea2fee0e70b15297", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "ba990acfe6fc4a5991bfcba2d65c7355f25a971b", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "fd3b3e4d59fa699d7570a708814025e0519e7e3e", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "600f94f095eace0056fc0af4292245a197946f0f", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "a982f11f7187fa7703f46bf1eb5f81694479f272", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "6ca884799aa6fb3b77b5891c6ff20175f9aab922", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "22b4bbb17d47fd3e38948d6dd51e545588d39ade", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "985c5d360db8e814b4a7b9b7e69924e2ae9fabcc", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "97354ba5d1bd1c2cf044988eaedf7cf536750423", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 8, "deletions": 31, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "4c119a443555e35fcd444cd6668fb74d028c7d44", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "4d53519581b3795bdc9b7bf27e9b9820011078a4", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "2e526733df974b6e33a7c287505c46f200669f33", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "542b638bbd7a40dcb5596aca193092332b93a811", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "7f1d21bf1d8b0cdebacd4fb2dc8b1ab73776d69d", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "9bf7778bfb29c7abd75a2a6144d12fcee9b86453", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "a03e7b0dae527344a17f8edfd6d958cceed0853a", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}, {"sha": "2fe3fb2fa5668013978287aa75086ea0d42480ce", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 8, "deletions": 111, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a528b16fcee67f0ce47c88bf7b57f1bd5439bad/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=0a528b16fcee67f0ce47c88bf7b57f1bd5439bad"}]}