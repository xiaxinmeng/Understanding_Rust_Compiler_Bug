{"sha": "5be4e71262587c0b04ead0f629d2a74858fe25a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZTRlNzEyNjI1ODdjMGIwNGVhZDBmNjI5ZDJhNzQ4NThmZTI1YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T08:26:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-06T08:26:48Z"}, "message": "Auto merge of #4136 - euclio:println-writeln-suggestions, r=flip1995\n\nadd suggestions for print/write with newline lint\n\nchangelog: Add machine-applicable suggestions for `print!`/`write!` with newline lints.", "tree": {"sha": "f94d3c3809b54e84920e3ea9a37d731fe99a7bdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f94d3c3809b54e84920e3ea9a37d731fe99a7bdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5be4e71262587c0b04ead0f629d2a74858fe25a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5be4e71262587c0b04ead0f629d2a74858fe25a6", "html_url": "https://github.com/rust-lang/rust/commit/5be4e71262587c0b04ead0f629d2a74858fe25a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5be4e71262587c0b04ead0f629d2a74858fe25a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46d7a0d2b89314e0cf1ba87755673f6c57ebae40", "url": "https://api.github.com/repos/rust-lang/rust/commits/46d7a0d2b89314e0cf1ba87755673f6c57ebae40", "html_url": "https://github.com/rust-lang/rust/commit/46d7a0d2b89314e0cf1ba87755673f6c57ebae40"}, {"sha": "2d0c797da6c2d3395e95c086c3cee66fa95a0b53", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d0c797da6c2d3395e95c086c3cee66fa95a0b53", "html_url": "https://github.com/rust-lang/rust/commit/2d0c797da6c2d3395e95c086c3cee66fa95a0b53"}], "stats": {"total": 288, "additions": 206, "deletions": 82}, "files": [{"sha": "b55d0d94019855313a146e81494962f0b5e348d7", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 110, "deletions": 54, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/5be4e71262587c0b04ead0f629d2a74858fe25a6/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be4e71262587c0b04ead0f629d2a74858fe25a6/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=5be4e71262587c0b04ead0f629d2a74858fe25a6", "patch": "@@ -1,12 +1,12 @@\n-use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg};\n+use crate::utils::{snippet_with_applicability, span_lint, span_lint_and_sugg, span_lint_and_then};\n use rustc::lint::{EarlyContext, EarlyLintPass, LintArray, LintPass};\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use std::borrow::Cow;\n use syntax::ast::*;\n use syntax::parse::{parser, token};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n-use syntax_pos::symbol::Symbol;\n+use syntax::tokenstream::TokenStream;\n+use syntax_pos::{symbol::Symbol, BytePos, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -184,8 +184,8 @@ impl EarlyLintPass for Write {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n         if mac.node.path == sym!(println) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n-                if fmtstr == \"\" {\n+            if let (Some(fmt_str), _) = check_tts(cx, &mac.node.tts, false) {\n+                if fmt_str.contents.is_empty() {\n                     span_lint_and_sugg(\n                         cx,\n                         PRINTLN_EMPTY_STRING,\n@@ -199,35 +199,52 @@ impl EarlyLintPass for Write {\n             }\n         } else if mac.node.path == sym!(print) {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n-            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, false) {\n-                if check_newlines(&fmtstr, is_raw) {\n-                    span_lint(\n+            if let (Some(fmt_str), _) = check_tts(cx, &mac.node.tts, false) {\n+                if check_newlines(&fmt_str) {\n+                    span_lint_and_then(\n                         cx,\n                         PRINT_WITH_NEWLINE,\n                         mac.span,\n-                        \"using `print!()` with a format string that ends in a \\\n-                         single newline, consider using `println!()` instead\",\n+                        \"using `print!()` with a format string that ends in a single newline\",\n+                        |err| {\n+                            err.multipart_suggestion(\n+                                \"use `println!` instead\",\n+                                vec![\n+                                    (mac.node.path.span, String::from(\"println\")),\n+                                    (fmt_str.newline_span(), String::new()),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n                     );\n                 }\n             }\n         } else if mac.node.path == sym!(write) {\n-            if let (Some(fmtstr), _, is_raw) = check_tts(cx, &mac.node.tts, true) {\n-                if check_newlines(&fmtstr, is_raw) {\n-                    span_lint(\n+            if let (Some(fmt_str), _) = check_tts(cx, &mac.node.tts, true) {\n+                if check_newlines(&fmt_str) {\n+                    span_lint_and_then(\n                         cx,\n                         WRITE_WITH_NEWLINE,\n                         mac.span,\n-                        \"using `write!()` with a format string that ends in a \\\n-                         single newline, consider using `writeln!()` instead\",\n-                    );\n+                        \"using `write!()` with a format string that ends in a single newline\",\n+                        |err| {\n+                            err.multipart_suggestion(\n+                                \"use `writeln!()` instead\",\n+                                vec![\n+                                    (mac.node.path.span, String::from(\"writeln\")),\n+                                    (fmt_str.newline_span(), String::new()),\n+                                ],\n+                                Applicability::MachineApplicable,\n+                            );\n+                        },\n+                    )\n                 }\n             }\n         } else if mac.node.path == sym!(writeln) {\n-            let check_tts = check_tts(cx, &mac.node.tts, true);\n-            if let Some(fmtstr) = check_tts.0 {\n-                if fmtstr == \"\" {\n+            if let (Some(fmt_str), expr) = check_tts(cx, &mac.node.tts, true) {\n+                if fmt_str.contents.is_empty() {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = check_tts.1.map_or_else(\n+                    let suggestion = expr.map_or_else(\n                         move || {\n                             applicability = Applicability::HasPlaceholders;\n                             Cow::Borrowed(\"v\")\n@@ -250,10 +267,44 @@ impl EarlyLintPass for Write {\n     }\n }\n \n+/// The arguments of a `print[ln]!` or `write[ln]!` invocation.\n+struct FmtStr {\n+    /// The contents of the format string (inside the quotes).\n+    contents: String,\n+    style: StrStyle,\n+    /// The span of the format string, including quotes, the raw marker, and any raw hashes.\n+    span: Span,\n+}\n+\n+impl FmtStr {\n+    /// Given a format string that ends in a newline and its span, calculates the span of the\n+    /// newline.\n+    fn newline_span(&self) -> Span {\n+        let sp = self.span;\n+\n+        let newline_sp_hi = sp.hi()\n+            - match self.style {\n+                StrStyle::Cooked => BytePos(1),\n+                StrStyle::Raw(hashes) => BytePos((1 + hashes).into()),\n+            };\n+\n+        let newline_sp_len = if self.contents.ends_with('\\n') {\n+            BytePos(1)\n+        } else if self.contents.ends_with(r\"\\n\") {\n+            BytePos(2)\n+        } else {\n+            panic!(\"expected format string to contain a newline\");\n+        };\n+\n+        sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n+    }\n+}\n+\n /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n-/// options and a bool. The first part of the tuple is `format_str` of the macros. The second part\n-/// of the tuple is in the `write[ln]!` case the expression the `format_str` should be written to.\n-/// The final part is a boolean flag indicating if the string is a raw string.\n+/// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n+/// the contents of the string, whether it's a raw string, and the span of the literal in the\n+/// source. The second `Option` in the tuple is, in the `write[ln]!` case, the expression the\n+/// `format_str` should be written to.\n ///\n /// Example:\n ///\n@@ -266,49 +317,36 @@ impl EarlyLintPass for Write {\n /// ```\n /// will return\n /// ```rust,ignore\n-/// (Some(\"string to write: {}\"), Some(buf), false)\n+/// (Some(\"string to write: {}\"), Some(buf))\n /// ```\n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<String>, Option<Expr>, bool) {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (Option<FmtStr>, Option<Expr>) {\n     use fmt_macros::*;\n     let tts = tts.clone();\n-    let mut is_raw = false;\n-    if let TokenStream(Some(tokens)) = &tts {\n-        for token in tokens.iter() {\n-            if let (TokenTree::Token(_, token::Token::Literal(lit)), _) = token {\n-                match lit.kind {\n-                    token::Str => break,\n-                    token::StrRaw(_) => {\n-                        is_raw = true;\n-                        break;\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n+\n     let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, None, false, false, None);\n     let mut expr: Option<Expr> = None;\n     if is_write {\n         expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n             Ok(p) => Some(p.into_inner()),\n-            Err(_) => return (None, None, is_raw),\n+            Err(_) => return (None, None),\n         };\n         // might be `writeln!(foo)`\n         if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-            return (None, expr, is_raw);\n+            return (None, expr);\n         }\n     }\n \n-    let fmtstr = match parser.parse_str().map_err(|mut err| err.cancel()) {\n-        Ok(token) => token.0.to_string(),\n-        Err(_) => return (None, expr, is_raw),\n+    let (fmtstr, fmtstyle) = match parser.parse_str().map_err(|mut err| err.cancel()) {\n+        Ok((fmtstr, fmtstyle)) => (fmtstr.to_string(), fmtstyle),\n+        Err(_) => return (None, expr),\n     };\n+    let fmtspan = parser.prev_span;\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None, Vec::new(), false);\n     while let Some(piece) = fmt_parser.next() {\n         if !fmt_parser.errors.is_empty() {\n-            return (None, expr, is_raw);\n+            return (None, expr);\n         }\n         if let Piece::NextArgument(arg) = piece {\n             if arg.format.ty == \"?\" {\n@@ -330,11 +368,26 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n             ty: \"\",\n         };\n         if !parser.eat(&token::Comma) {\n-            return (Some(fmtstr), expr, is_raw);\n+            return (\n+                Some(FmtStr {\n+                    contents: fmtstr,\n+                    style: fmtstyle,\n+                    span: fmtspan,\n+                }),\n+                expr,\n+            );\n         }\n-        let token_expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n-            Ok(expr) => expr,\n-            Err(_) => return (Some(fmtstr), None, is_raw),\n+        let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n+            expr\n+        } else {\n+            return (\n+                Some(FmtStr {\n+                    contents: fmtstr,\n+                    style: fmtstyle,\n+                    span: fmtspan,\n+                }),\n+                None,\n+            );\n         };\n         match &token_expr.node {\n             ExprKind::Lit(_) => {\n@@ -383,12 +436,15 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &TokenStream, is_write: bool) -> (O\n     }\n }\n \n-// Checks if `s` constains a single newline that terminates it\n-// Literal and escaped newlines are both checked (only literal for raw strings)\n-fn check_newlines(s: &str, is_raw: bool) -> bool {\n+/// Checks if the format string constains a single newline that terminates it.\n+///\n+/// Literal and escaped newlines are both checked (only literal for raw strings).\n+fn check_newlines(fmt_str: &FmtStr) -> bool {\n+    let s = &fmt_str.contents;\n+\n     if s.ends_with('\\n') {\n         return true;\n-    } else if is_raw {\n+    } else if let StrStyle::Raw(_) = fmt_str.style {\n         return false;\n     }\n "}, {"sha": "111a29faa41ec055e3c017178500a884460c2995", "filename": "tests/ui/print_with_newline.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fprint_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fprint_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.rs?ref=5be4e71262587c0b04ead0f629d2a74858fe25a6", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Ideally these suggestions would be fixed via rustfix. Blocked by rust-lang/rust#53934\n+// // run-rustfix\n+\n #![allow(clippy::print_literal)]\n #![warn(clippy::print_with_newline)]\n "}, {"sha": "81e8b45b56609a15c31840c57f7dcc61724f7886", "filename": "tests/ui/print_with_newline.stderr", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fprint_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fprint_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fprint_with_newline.stderr?ref=5be4e71262587c0b04ead0f629d2a74858fe25a6", "patch": "@@ -1,52 +1,82 @@\n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:5:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:8:5\n    |\n LL |     print!(\"Hello/n\");\n    |     ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::print-with-newline` implied by `-D warnings`\n+help: use `println!` instead\n+   |\n+LL |     println!(\"Hello\");\n+   |     ^^^^^^^       --\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:6:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:9:5\n    |\n LL |     print!(\"Hello {}/n\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `println!` instead\n+   |\n+LL |     println!(\"Hello {}\", \"world\");\n+   |     ^^^^^^^          --\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:7:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:10:5\n    |\n LL |     print!(\"Hello {} {}/n\", \"world\", \"#2\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `println!` instead\n+   |\n+LL |     println!(\"Hello {} {}\", \"world\", \"#2\");\n+   |     ^^^^^^^             --\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:8:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:11:5\n    |\n LL |     print!(\"{}/n\", 1265);\n    |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `println!` instead\n+   |\n+LL |     println!(\"{}\", 1265);\n+   |     ^^^^^^^    --\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:27:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:30:5\n    |\n LL |     print!(\"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^\n+help: use `println!` instead\n+   |\n+LL |     println!(\"/\"); // should fail\n+   |     ^^^^^^^    --\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:34:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:37:5\n    |\n LL | /     print!(\n LL | |         \"\n LL | | \"\n LL | |     );\n    | |_____^\n+help: use `println!` instead\n+   |\n+LL |     println!(\n+LL |         \"\"\n+   |\n \n-error: using `print!()` with a format string that ends in a single newline, consider using `println!()` instead\n-  --> $DIR/print_with_newline.rs:38:5\n+error: using `print!()` with a format string that ends in a single newline\n+  --> $DIR/print_with_newline.rs:41:5\n    |\n LL | /     print!(\n LL | |         r\"\n LL | | \"\n LL | |     );\n    | |_____^\n+help: use `println!` instead\n+   |\n+LL |     println!(\n+LL |         r\"\"\n+   |\n \n error: aborting due to 7 previous errors\n "}, {"sha": "f0b13a698871170f2618fba8f91f55e4a4ca30ec", "filename": "tests/ui/write_with_newline.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fwrite_with_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fwrite_with_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.rs?ref=5be4e71262587c0b04ead0f629d2a74858fe25a6", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Ideally these suggestions would be fixed via rustfix. Blocked by rust-lang/rust#53934\n+// // run-rustfix\n+\n #![allow(clippy::write_literal)]\n #![warn(clippy::write_with_newline)]\n "}, {"sha": "c1f1d64c2e3296369fac32c5f726b46fff741734", "filename": "tests/ui/write_with_newline.stderr", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fwrite_with_newline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5be4e71262587c0b04ead0f629d2a74858fe25a6/tests%2Fui%2Fwrite_with_newline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrite_with_newline.stderr?ref=5be4e71262587c0b04ead0f629d2a74858fe25a6", "patch": "@@ -1,54 +1,86 @@\n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:10:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:13:5\n    |\n LL |     write!(&mut v, \"Hello/n\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::write-with-newline` implied by `-D warnings`\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, \"Hello\");\n+   |     ^^^^^^^               --\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:11:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:14:5\n    |\n LL |     write!(&mut v, \"Hello {}/n\", \"world\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, \"Hello {}\", \"world\");\n+   |     ^^^^^^^                  --\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:12:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:15:5\n    |\n LL |     write!(&mut v, \"Hello {} {}/n\", \"world\", \"#2\");\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, \"Hello {} {}\", \"world\", \"#2\");\n+   |     ^^^^^^^                     --\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:13:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:16:5\n    |\n LL |     write!(&mut v, \"{}/n\", 1265);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, \"{}\", 1265);\n+   |     ^^^^^^^            --\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:32:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:35:5\n    |\n LL |     write!(&mut v, \"//n\"); // should fail\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(&mut v, \"/\"); // should fail\n+   |     ^^^^^^^            --\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:39:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:42:5\n    |\n LL | /     write!(\n LL | |         &mut v,\n LL | |         \"\n LL | | \"\n LL | |     );\n    | |_____^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(\n+LL |         &mut v,\n+LL |         \"\"\n+   |\n \n-error: using `write!()` with a format string that ends in a single newline, consider using `writeln!()` instead\n-  --> $DIR/write_with_newline.rs:44:5\n+error: using `write!()` with a format string that ends in a single newline\n+  --> $DIR/write_with_newline.rs:47:5\n    |\n LL | /     write!(\n LL | |         &mut v,\n LL | |         r\"\n LL | | \"\n LL | |     );\n    | |_____^\n+help: use `writeln!()` instead\n+   |\n+LL |     writeln!(\n+LL |         &mut v,\n+LL |         r\"\"\n+   |\n \n error: aborting due to 7 previous errors\n "}]}