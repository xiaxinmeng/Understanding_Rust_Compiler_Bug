{"sha": "1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZDJkNzc4NjAxM2Y5OGM1OWYwOTlhMmEwNDEzYjYxYTZlODJkOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-07T22:21:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-07T22:21:30Z"}, "message": "auto merge of #12029 : zkamsler/rust/merge-sort-allocations, r=huonw\n\nThis pull request:\r\n1) Changes the initial insertion sort to be in-place, and defers allocation of working set until merge is needed.\r\n2) Increases the increases the maximum run length to use insertion sort for from 8 to 32 elements. This increases the size of vectors that will not allocate, and reduces the number of merge passes by two. It seemed to be the sweet spot in the benchmarks that I ran.\r\n\r\nHere are the results of some benchmarks. Note that they are sorting u64s, so types that are more expensive to compare or copy may have different behaviors.\r\nBefore changes:\r\n```\r\ntest vec::bench::sort_random_large      bench:    719753 ns/iter (+/- 130173) = 111 MB/s\r\ntest vec::bench::sort_random_medium     bench:      4726 ns/iter (+/- 742) = 169 MB/s\r\ntest vec::bench::sort_random_small      bench:       344 ns/iter (+/- 76) = 116 MB/s\r\ntest vec::bench::sort_sorted            bench:    437244 ns/iter (+/- 70043) = 182 MB/s\r\n```\r\n\r\nDeferred allocation (8 element insertion sort):\r\n```\r\ntest vec::bench::sort_random_large      bench:    702630 ns/iter (+/- 88158) = 113 MB/s\r\ntest vec::bench::sort_random_medium     bench:      4529 ns/iter (+/- 497) = 176 MB/s\r\ntest vec::bench::sort_random_small      bench:       185 ns/iter (+/- 49) = 216 MB/s\r\ntest vec::bench::sort_sorted            bench:    425853 ns/iter (+/- 60907) = 187 MB/s\r\n```\r\n\r\nDeferred allocation (16 element insertion sort):\r\n```\r\ntest vec::bench::sort_random_large      bench:    692783 ns/iter (+/- 165837) = 115 MB/s\r\ntest vec::bench::sort_random_medium     bench:      4434 ns/iter (+/- 722) = 180 MB/s\r\ntest vec::bench::sort_random_small      bench:       187 ns/iter (+/- 38) = 213 MB/s\r\ntest vec::bench::sort_sorted            bench:    393783 ns/iter (+/- 85548) = 203 MB/s\r\n```\r\n\r\nDeferred allocation (32 element insertion sort):\r\n```\r\ntest vec::bench::sort_random_large      bench:    682556 ns/iter (+/- 131008) = 117 MB/s\r\ntest vec::bench::sort_random_medium     bench:      4370 ns/iter (+/- 1369) = 183 MB/s\r\ntest vec::bench::sort_random_small      bench:       179 ns/iter (+/- 32) = 223 MB/s\r\ntest vec::bench::sort_sorted            bench:    358353 ns/iter (+/- 65423) = 223 MB/s\r\n```\r\n\r\nDeferred allocation (64 element insertion sort):\r\n```\r\ntest vec::bench::sort_random_large      bench:    712040 ns/iter (+/- 132454) = 112 MB/s\r\ntest vec::bench::sort_random_medium     bench:      4425 ns/iter (+/- 784) = 180 MB/s\r\ntest vec::bench::sort_random_small      bench:       179 ns/iter (+/- 81) = 223 MB/s\r\ntest vec::bench::sort_sorted            bench:    317812 ns/iter (+/- 62675) = 251 MB/s\r\n```\r\n\r\nThis is the best I could manage with the basic merge sort while keeping the invariant that the original vector must contain each element exactly once when the comparison function is called. If one is not married to a stable sort, an in-place n*log(n) sorting algorithm may have better performance in some cases.\r\n\r\nfor #12011\r\ncc @huonw", "tree": {"sha": "467b44d8810035eec87b9d5c65817dad6d3be6b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467b44d8810035eec87b9d5c65817dad6d3be6b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "html_url": "https://github.com/rust-lang/rust/commit/1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fd2d7786013f98c59f099a2a0413b61a6e82d9d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d7a060f8d95ee43406560e69a12631e52c617a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d7a060f8d95ee43406560e69a12631e52c617a7", "html_url": "https://github.com/rust-lang/rust/commit/7d7a060f8d95ee43406560e69a12631e52c617a7"}, {"sha": "cebe5e8e6baecd448f810f5960daab10fa2d089c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cebe5e8e6baecd448f810f5960daab10fa2d089c", "html_url": "https://github.com/rust-lang/rust/commit/cebe5e8e6baecd448f810f5960daab10fa2d089c"}], "stats": {"total": 109, "additions": 104, "deletions": 5}, "files": [{"sha": "fa5566ecab4259590a1c274cd310cf93cd2b6038", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1fd2d7786013f98c59f099a2a0413b61a6e82d9d/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fd2d7786013f98c59f099a2a0413b61a6e82d9d/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1fd2d7786013f98c59f099a2a0413b61a6e82d9d", "patch": "@@ -1812,12 +1812,70 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n     }\n }\n \n+fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n+    let len = v.len() as int;\n+    let buf_v = v.as_mut_ptr();\n+\n+    // 1 <= i < len;\n+    for i in range(1, len) {\n+        // j satisfies: 0 <= j <= i;\n+        let mut j = i;\n+        unsafe {\n+            // `i` is in bounds.\n+            let read_ptr = buf_v.offset(i) as *T;\n+\n+            // find where to insert, we need to do strict <,\n+            // rather than <=, to maintain stability.\n+\n+            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n+            while j > 0 &&\n+                    compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n+                j -= 1;\n+            }\n+\n+            // shift everything to the right, to make space to\n+            // insert this value.\n+\n+            // j + 1 could be `len` (for the last `i`), but in\n+            // that case, `i == j` so we don't copy. The\n+            // `.offset(j)` is always in bounds.\n+\n+            if i != j {\n+                let tmp = ptr::read_ptr(read_ptr);\n+                ptr::copy_memory(buf_v.offset(j + 1),\n+                                 buf_v.offset(j),\n+                                 (i - j) as uint);\n+                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n+                                                &tmp as *T,\n+                                                1);\n+                cast::forget(tmp);\n+            }\n+        }\n+    }\n+}\n+\n fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // warning: this wildly uses unsafe.\n-    static INSERTION: uint = 8;\n+    static BASE_INSERTION: uint = 32;\n+    static LARGE_INSERTION: uint = 16;\n+\n+    // FIXME #12092: smaller insertion runs seems to make sorting\n+    // vectors of large elements a little faster on some platforms,\n+    // but hasn't been tested/tuned extensively\n+    let insertion = if size_of::<T>() <= 16 {\n+        BASE_INSERTION\n+    } else {\n+        LARGE_INSERTION\n+    };\n \n     let len = v.len();\n \n+    // short vectors get sorted in-place via insertion sort to avoid allocations\n+    if len <= insertion {\n+        insertion_sort(v, compare);\n+        return;\n+    }\n+\n     // allocate some memory to use as scratch memory, we keep the\n     // length 0 so we can keep shallow copies of the contents of `v`\n     // without risking the dtors running on an object twice if\n@@ -1837,9 +1895,9 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // We could hardcode the sorting comparisons here, and we could\n     // manipulate/step the pointers themselves, rather than repeatedly\n     // .offset-ing.\n-    for start in range_step(0, len, INSERTION) {\n-        // start <= i <= len;\n-        for i in range(start, cmp::min(start + INSERTION, len)) {\n+    for start in range_step(0, len, insertion) {\n+        // start <= i < len;\n+        for i in range(start, cmp::min(start + insertion, len)) {\n             // j satisfies: start <= j <= i;\n             let mut j = i as int;\n             unsafe {\n@@ -1871,7 +1929,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     }\n \n     // step 2. merge the sorted runs.\n-    let mut width = INSERTION;\n+    let mut width = insertion;\n     while width < len {\n         // merge the sorted runs of length `width` in `buf_dat` two at\n         // a time, placing the result in `buf_tmp`.\n@@ -4505,4 +4563,45 @@ mod bench {\n         });\n         bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n     }\n+\n+    type BigSortable = (u64,u64,u64,u64);\n+\n+    #[bench]\n+    fn sort_big_random_small(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(5);\n+            v.sort();\n+        });\n+        bh.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_medium(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(100);\n+            v.sort();\n+        });\n+        bh.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_random_large(bh: &mut BenchHarness) {\n+        let mut rng = weak_rng();\n+        bh.iter(|| {\n+            let mut v: ~[BigSortable] = rng.gen_vec(10000);\n+            v.sort();\n+        });\n+        bh.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n+    }\n+\n+    #[bench]\n+    fn sort_big_sorted(bh: &mut BenchHarness) {\n+        let mut v = vec::from_fn(10000u, |i| (i, i, i, i));\n+        bh.iter(|| {\n+            v.sort();\n+        });\n+        bh.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    }\n }"}]}