{"sha": "149032aff393de695c068c4cd907d99ec75a3f7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0OTAzMmFmZjM5M2RlNjk1YzA2OGM0Y2Q5MDdkOTllYzc1YTNmN2E=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-08-11T10:59:35Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-08-29T08:05:26Z"}, "message": "rustc: move pretty printing into its own module.\n\nThere's a lot of it, and it's a fairly well-defined/separate chunk of\ncode, so it might as well be separate.", "tree": {"sha": "598005a18528b46d11aa6755609c2f58a9621baf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/598005a18528b46d11aa6755609c2f58a9621baf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/149032aff393de695c068c4cd907d99ec75a3f7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/149032aff393de695c068c4cd907d99ec75a3f7a", "html_url": "https://github.com/rust-lang/rust/commit/149032aff393de695c068c4cd907d99ec75a3f7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/149032aff393de695c068c4cd907d99ec75a3f7a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3549ee202355731003002e813cf071cd89f04cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3549ee202355731003002e813cf071cd89f04cb", "html_url": "https://github.com/rust-lang/rust/commit/e3549ee202355731003002e813cf071cd89f04cb"}], "stats": {"total": 1134, "additions": 579, "deletions": 555}, "files": [{"sha": "3b873d6dfc310a95165ade162661a44b9313d099", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 516, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=149032aff393de695c068c4cd907d99ec75a3f7a", "patch": "@@ -11,19 +11,12 @@\n \n use back::link;\n use driver::session::Session;\n-use driver::{config, PpMode, PpSourceMode};\n-use driver::{PpmFlowGraph, PpmExpanded, PpmExpandedIdentified, PpmTyped};\n-use driver::{PpmIdentified, PpmNormal, PpmSource};\n+use driver::config;\n use front;\n use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use middle::borrowck::{FnPartsWithCFG};\n-use middle::borrowck;\n-use middle::borrowck::graphviz as borrowck_dot;\n-use middle::cfg;\n-use middle::cfg::graphviz::LabelledCFG;\n use middle::{trans, freevars, stability, kind, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n@@ -32,28 +25,18 @@ use plugin::registry::Registry;\n use plugin;\n \n use util::common::time;\n-use util::ppaux;\n use util::nodemap::{NodeSet};\n \n-use graphviz as dot;\n-\n use serialize::{json, Encodable};\n \n-use std::from_str::FromStr;\n use std::io;\n use std::io::fs;\n-use std::io::MemReader;\n-use std::option;\n use syntax::ast;\n-use syntax::ast_map;\n-use syntax::ast_map::blocks;\n-use syntax::ast_map::NodePrinter;\n use syntax::attr;\n use syntax::attr::{AttrMetaMethods};\n use syntax::diagnostics;\n use syntax::parse;\n use syntax::parse::token;\n-use syntax::print::{pp, pprust};\n use syntax;\n \n pub fn host_triple() -> &'static str {\n@@ -614,504 +597,6 @@ fn write_out_deps(sess: &Session,\n     }\n }\n \n-// This slightly awkward construction is to allow for each PpMode to\n-// choose whether it needs to do analyses (which can consume the\n-// Session) and then pass through the session (now attached to the\n-// analysis results) on to the chosen pretty-printer, along with the\n-// `&PpAnn` object.\n-//\n-// Note that since the `&PrinterSupport` is freshly constructed on each\n-// call, it would not make sense to try to attach the lifetime of `self`\n-// to the lifetime of the `&PrinterObject`.\n-//\n-// (The `use_once_payload` is working around the current lack of once\n-// functions in the compiler.)\n-trait CratePrinter {\n-    /// Constructs a `PrinterSupport` object and passes it to `f`.\n-    fn call_with_pp_support<A,B>(&self,\n-                                 sess: Session,\n-                                 krate: &ast::Crate,\n-                                 ast_map: Option<syntax::ast_map::Map>,\n-                                 id: String,\n-                                 use_once_payload: B,\n-                                 f: |&PrinterSupport, B| -> A) -> A;\n-}\n-\n-trait SessionCarrier {\n-    /// Provides a uniform interface for re-extracting a reference to a\n-    /// `Session` from a value that now owns it.\n-    fn sess<'a>(&'a self) -> &'a Session;\n-}\n-\n-trait AstMapCarrier {\n-    /// Provides a uniform interface for re-extracting a reference to an\n-    /// `ast_map::Map` from a value that now owns it.\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n-}\n-\n-trait PrinterSupport : SessionCarrier + AstMapCarrier {\n-    /// Produces the pretty-print annotation object.\n-    ///\n-    /// Usually implemented via `self as &pprust::PpAnn`.\n-    ///\n-    /// (Rust does not yet support upcasting from a trait object to\n-    /// an object for one of its super-traits.)\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n-}\n-\n-struct NoAnn {\n-    sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for NoAnn {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n-}\n-\n-impl SessionCarrier for NoAnn {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n-\n-impl AstMapCarrier for NoAnn {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n-        self.ast_map.as_ref()\n-    }\n-}\n-\n-impl pprust::PpAnn for NoAnn {}\n-\n-struct IdentifiedAnnotation {\n-    sess: Session,\n-    ast_map: Option<ast_map::Map>,\n-}\n-\n-impl PrinterSupport for IdentifiedAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n-}\n-\n-impl SessionCarrier for IdentifiedAnnotation {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n-}\n-\n-impl AstMapCarrier for IdentifiedAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n-        self.ast_map.as_ref()\n-    }\n-}\n-\n-impl pprust::PpAnn for IdentifiedAnnotation {\n-    fn pre(&self,\n-           s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::IoResult<()> {\n-        match node {\n-            pprust::NodeExpr(_) => s.popen(),\n-            _ => Ok(())\n-        }\n-    }\n-    fn post(&self,\n-            s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::IoResult<()> {\n-        match node {\n-            pprust::NodeItem(item) => {\n-                try!(pp::space(&mut s.s));\n-                s.synth_comment(item.id.to_string())\n-            }\n-            pprust::NodeBlock(blk) => {\n-                try!(pp::space(&mut s.s));\n-                s.synth_comment(format!(\"block {}\", blk.id))\n-            }\n-            pprust::NodeExpr(expr) => {\n-                try!(pp::space(&mut s.s));\n-                try!(s.synth_comment(expr.id.to_string()));\n-                s.pclose()\n-            }\n-            pprust::NodePat(pat) => {\n-                try!(pp::space(&mut s.s));\n-                s.synth_comment(format!(\"pat {}\", pat.id))\n-            }\n-        }\n-    }\n-}\n-\n-struct TypedAnnotation {\n-    analysis: CrateAnalysis,\n-}\n-\n-impl PrinterSupport for TypedAnnotation {\n-    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n-}\n-\n-impl SessionCarrier for TypedAnnotation {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n-}\n-\n-impl AstMapCarrier for TypedAnnotation {\n-    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n-        Some(&self.analysis.ty_cx.map)\n-    }\n-}\n-\n-impl pprust::PpAnn for TypedAnnotation {\n-    fn pre(&self,\n-           s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::IoResult<()> {\n-        match node {\n-            pprust::NodeExpr(_) => s.popen(),\n-            _ => Ok(())\n-        }\n-    }\n-    fn post(&self,\n-            s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::IoResult<()> {\n-        let tcx = &self.analysis.ty_cx;\n-        match node {\n-            pprust::NodeExpr(expr) => {\n-                try!(pp::space(&mut s.s));\n-                try!(pp::word(&mut s.s, \"as\"));\n-                try!(pp::space(&mut s.s));\n-                try!(pp::word(&mut s.s,\n-                              ppaux::ty_to_string(\n-                                  tcx,\n-                                  ty::expr_ty(tcx, expr)).as_slice()));\n-                s.pclose()\n-            }\n-            _ => Ok(())\n-        }\n-    }\n-}\n-\n-fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n-    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;\n-    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;\n-    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;\n-    let print_all     = config::FLOWGRAPH_PRINT_ALL;\n-    let opt = |print_which| sess.debugging_opt(print_which);\n-    let mut variants = Vec::new();\n-    if opt(print_all) || opt(print_loans) {\n-        variants.push(borrowck_dot::Loans);\n-    }\n-    if opt(print_all) || opt(print_moves) {\n-        variants.push(borrowck_dot::Moves);\n-    }\n-    if opt(print_all) || opt(print_assigns) {\n-        variants.push(borrowck_dot::Assigns);\n-    }\n-    variants\n-}\n-\n-#[deriving(Clone, Show)]\n-pub enum UserIdentifiedItem {\n-    ItemViaNode(ast::NodeId),\n-    ItemViaPath(Vec<String>),\n-}\n-\n-impl FromStr for UserIdentifiedItem {\n-    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n-        let extract_path_parts = || {\n-            let v : Vec<_> = s.split_str(\"::\")\n-                .map(|x|x.to_string())\n-                .collect();\n-            Some(ItemViaPath(v))\n-        };\n-\n-        from_str(s).map(ItemViaNode).or_else(extract_path_parts)\n-    }\n-}\n-\n-enum NodesMatchingUII<'a> {\n-    NodesMatchingDirect(option::Item<ast::NodeId>),\n-    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n-}\n-\n-impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n-    fn next(&mut self) -> Option<ast::NodeId> {\n-        match self {\n-            &NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n-        }\n-    }\n-}\n-\n-impl UserIdentifiedItem {\n-    fn reconstructed_input(&self) -> String {\n-        match *self {\n-            ItemViaNode(node_id) => node_id.to_string(),\n-            ItemViaPath(ref parts) => parts.connect(\"::\"),\n-        }\n-    }\n-\n-    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n-        match *self {\n-            ItemViaNode(node_id) =>\n-                NodesMatchingDirect(Some(node_id).move_iter()),\n-            ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n-        }\n-    }\n-\n-    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message =\n-                format!(\"{:s} needs NodeId (int) or unique \\\n-                         path suffix (b::c::d); got {:s}, which {:s}\",\n-                        user_option,\n-                        self.reconstructed_input(),\n-                        is_wrong_because);\n-            sess.fatal(message.as_slice())\n-        };\n-\n-        let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0u;\n-        for node in self.all_matching_node_ids(map) {\n-            saw_node = node;\n-            seen += 1;\n-            if seen > 1 {\n-                fail_because(\"does not resolve uniquely\");\n-            }\n-        }\n-        if seen == 0 {\n-            fail_because(\"does not resolve to any item\");\n-        }\n-\n-        assert!(seen == 1);\n-        return saw_node;\n-    }\n-}\n-\n-impl CratePrinter for PpSourceMode {\n-    fn call_with_pp_support<A,B>(&self,\n-                                 sess: Session,\n-                                 krate: &ast::Crate,\n-                                 ast_map: Option<syntax::ast_map::Map>,\n-                                 id: String,\n-                                 payload: B,\n-                                 f: |&PrinterSupport, B| -> A) -> A {\n-        match *self {\n-            PpmNormal | PpmExpanded => {\n-                let annotation = NoAnn { sess: sess, ast_map: ast_map };\n-                f(&annotation, payload)\n-            }\n-\n-            PpmIdentified | PpmExpandedIdentified => {\n-                let annotation = IdentifiedAnnotation { sess: sess, ast_map: ast_map };\n-                f(&annotation, payload)\n-            }\n-            PpmTyped => {\n-                let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n-                let analysis = phase_3_run_analysis_passes(sess, krate, ast_map, id);\n-                let annotation = TypedAnnotation { analysis: analysis };\n-                f(&annotation, payload)\n-            }\n-        }\n-    }\n-}\n-\n-fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmTyped) |\n-        PpmFlowGraph => true\n-    }\n-}\n-\n-fn needs_expansion(ppm: &PpMode) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmIdentified) => false,\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmTyped) |\n-        PpmFlowGraph => true\n-    }\n-}\n-pub fn pretty_print_input(sess: Session,\n-                          cfg: ast::CrateConfig,\n-                          input: &Input,\n-                          ppm: PpMode,\n-                          opt_uii: Option<UserIdentifiedItem>,\n-                          ofile: Option<Path>) {\n-    let krate = phase_1_parse_input(&sess, cfg, input);\n-    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n-\n-    let is_expanded = needs_expansion(&ppm);\n-    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n-        let k = phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n-        let (krate, ast_map) = match k {\n-            None => return,\n-            Some(p) => p,\n-        };\n-        (krate, Some(ast_map))\n-    } else {\n-        (krate, None)\n-    };\n-\n-    let src_name = source_name(input);\n-    let src = Vec::from_slice(sess.codemap()\n-                                  .get_filemap(src_name.as_slice())\n-                                  .src\n-                                  .as_bytes());\n-    let mut rdr = MemReader::new(src);\n-\n-    let out = match ofile {\n-        None => box io::stdout() as Box<Writer+'static>,\n-        Some(p) => {\n-            let r = io::File::create(&p);\n-            match r {\n-                Ok(w) => box w as Box<Writer+'static>,\n-                Err(e) => fail!(\"print-print failed to open {} due to {}\",\n-                                p.display(), e),\n-            }\n-        }\n-    };\n-\n-    match (ppm, opt_uii) {\n-        (PpmSource(s), None) =>\n-            s.call_with_pp_support(\n-                sess, &krate, ast_map, id, out, |annotation, out| {\n-                    debug!(\"pretty printing source code {}\", s);\n-                    let sess = annotation.sess();\n-                    pprust::print_crate(sess.codemap(),\n-                                        sess.diagnostic(),\n-                                        &krate,\n-                                        src_name.to_string(),\n-                                        &mut rdr,\n-                                        out,\n-                                        annotation.pp_ann(),\n-                                        is_expanded)\n-                }),\n-\n-        (PpmSource(s), Some(uii)) =>\n-            s.call_with_pp_support(\n-                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n-                    debug!(\"pretty printing source code {}\", s);\n-                    let sess = annotation.sess();\n-                    let ast_map = annotation.ast_map()\n-                        .expect(\"--pretty missing ast_map\");\n-                    let mut pp_state =\n-                        pprust::State::new_from_input(sess.codemap(),\n-                                                      sess.diagnostic(),\n-                                                      src_name.to_string(),\n-                                                      &mut rdr,\n-                                                      out,\n-                                                      annotation.pp_ann(),\n-                                                      is_expanded);\n-                    for node_id in uii.all_matching_node_ids(ast_map) {\n-                        let node = ast_map.get(node_id);\n-                        try!(pp_state.print_node(&node));\n-                        try!(pp::space(&mut pp_state.s));\n-                        try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n-                        try!(pp::hardbreak(&mut pp_state.s));\n-                    }\n-                    pp::eof(&mut pp_state.s)\n-                }),\n-\n-        (PpmFlowGraph, opt_uii) => {\n-            debug!(\"pretty printing flow graph for {}\", opt_uii);\n-            let uii = opt_uii.unwrap_or_else(|| {\n-                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\").as_slice())\n-\n-            });\n-            let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n-            let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n-\n-            let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid).as_slice())\n-            });\n-\n-            let code = blocks::Code::from_node(node);\n-            match code {\n-                Some(code) => {\n-                    let variants = gather_flowgraph_variants(&sess);\n-                    let analysis = phase_3_run_analysis_passes(sess, &krate,\n-                                                               ast_map, id);\n-                    print_flowgraph(variants, analysis, code, out)\n-                }\n-                None => {\n-                    let message = format!(\"--pretty=flowgraph needs \\\n-                                           block, fn, or method; got {:?}\",\n-                                          node);\n-\n-                    // point to what was found, if there's an\n-                    // accessible span.\n-                    match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message.as_slice()),\n-                        None => sess.fatal(message.as_slice())\n-                    }\n-                }\n-            }\n-        }\n-    }.unwrap()\n-}\n-\n-fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n-                                 analysis: CrateAnalysis,\n-                                 code: blocks::Code,\n-                                 mut out: W) -> io::IoResult<()> {\n-    let ty_cx = &analysis.ty_cx;\n-    let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n-    };\n-    debug!(\"cfg: {:?}\", cfg);\n-\n-    match code {\n-        _ if variants.len() == 0 => {\n-            let lcfg = LabelledCFG {\n-                ast_map: &ty_cx.map,\n-                cfg: &cfg,\n-                name: format!(\"node_{}\", code.id()),\n-            };\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-        blocks::BlockCode(_) => {\n-            ty_cx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n-                            annotations requires fn-like node id.\");\n-            return Ok(())\n-        }\n-        blocks::FnLikeCode(fn_like) => {\n-            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n-            let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n-\n-            let lcfg = LabelledCFG {\n-                ast_map: &ty_cx.map,\n-                cfg: &cfg,\n-                name: format!(\"node_{}\", code.id()),\n-            };\n-            let lcfg = borrowck_dot::DataflowLabeller {\n-                inner: lcfg,\n-                variants: variants,\n-                borrowck_ctxt: &bccx,\n-                analysis_data: &analysis_data,\n-            };\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-    }\n-\n-    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {\n-        r.map_err(|ioerr| {\n-            let orig_detail = ioerr.detail.clone();\n-            let m = \"graphviz::render failed\";\n-            io::IoError {\n-                detail: Some(match orig_detail {\n-                    None => m.into_string(),\n-                    Some(d) => format!(\"{}: {}\", m, d)\n-                }),\n-                ..ioerr\n-            }\n-        })\n-    }\n-}\n-\n pub fn collect_crate_types(session: &Session,\n                            attrs: &[ast::Attribute]) -> Vec<config::CrateType> {\n     // Unconditionally collect crate types from attributes to make them used"}, {"sha": "b393689ef2f8ded106440d7e3047467d5b687ef6", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=149032aff393de695c068c4cd907d99ec75a3f7a", "patch": "@@ -33,6 +33,7 @@ use getopts;\n pub mod driver;\n pub mod session;\n pub mod config;\n+pub mod pretty;\n \n \n pub fn main_args(args: &[String]) -> int {\n@@ -96,11 +97,11 @@ fn run_compiler(args: &[String]) {\n     let ofile = matches.opt_str(\"o\").map(|o| Path::new(o));\n \n     let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        parse_pretty(&sess, a.as_slice())\n+        pretty::parse_pretty(&sess, a.as_slice())\n     });\n     match pretty {\n         Some((ppm, opt_uii)) => {\n-            driver::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n+            pretty::pretty_print_input(sess, cfg, &input, ppm, opt_uii, ofile);\n             return;\n         }\n         None => {/* continue */ }\n@@ -340,43 +341,6 @@ fn print_crate_info(sess: &Session,\n     }\n }\n \n-#[deriving(PartialEq, Show)]\n-pub enum PpSourceMode {\n-    PpmNormal,\n-    PpmExpanded,\n-    PpmTyped,\n-    PpmIdentified,\n-    PpmExpandedIdentified,\n-}\n-\n-#[deriving(PartialEq, Show)]\n-pub enum PpMode {\n-    PpmSource(PpSourceMode),\n-    PpmFlowGraph,\n-}\n-\n-fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<driver::UserIdentifiedItem>) {\n-    let mut split = name.splitn(1, '=');\n-    let first = split.next().unwrap();\n-    let opt_second = split.next();\n-    let first = match first {\n-        \"normal\"       => PpmSource(PpmNormal),\n-        \"expanded\"     => PpmSource(PpmExpanded),\n-        \"typed\"        => PpmSource(PpmTyped),\n-        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n-        \"identified\"   => PpmSource(PpmIdentified),\n-        \"flowgraph\"    => PpmFlowGraph,\n-        _ => {\n-            sess.fatal(format!(\n-                \"argument to `pretty` must be one of `normal`, \\\n-                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n-                 or `expanded,identified`; got {}\", name).as_slice());\n-        }\n-    };\n-    let opt_second = opt_second.and_then::<driver::UserIdentifiedItem>(from_str);\n-    (first, opt_second)\n-}\n-\n fn parse_crate_attrs(sess: &Session, input: &Input) ->\n                      Vec<ast::Attribute> {\n     let result = match *input {"}, {"sha": "8f2b56f9ce3667ba058540a87aea1062fc859b92", "filename": "src/librustc/driver/pretty.rs", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/149032aff393de695c068c4cd907d99ec75a3f7a/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=149032aff393de695c068c4cd907d99ec75a3f7a", "patch": "@@ -0,0 +1,575 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The various pretty print routines.\n+\n+use back::link;\n+\n+use driver::config;\n+use driver::driver::{mod, CrateAnalysis};\n+use driver::session::Session;\n+\n+use middle::ty;\n+use middle::borrowck::{mod, FnPartsWithCFG};\n+use middle::borrowck::graphviz as borrowck_dot;\n+use middle::cfg;\n+use middle::cfg::graphviz::LabelledCFG;\n+\n+use util::ppaux;\n+\n+use syntax::ast;\n+use syntax::ast_map::{mod, blocks, NodePrinter};\n+use syntax::print::{pp, pprust};\n+\n+use graphviz as dot;\n+\n+use std::io::{mod, MemReader};\n+use std::from_str::FromStr;\n+use std::option;\n+\n+\n+#[deriving(PartialEq, Show)]\n+pub enum PpSourceMode {\n+    PpmNormal,\n+    PpmExpanded,\n+    PpmTyped,\n+    PpmIdentified,\n+    PpmExpandedIdentified,\n+}\n+\n+#[deriving(PartialEq, Show)]\n+pub enum PpMode {\n+    PpmSource(PpSourceMode),\n+    PpmFlowGraph,\n+}\n+\n+pub fn parse_pretty(sess: &Session, name: &str) -> (PpMode, Option<UserIdentifiedItem>) {\n+    let mut split = name.splitn(1, '=');\n+    let first = split.next().unwrap();\n+    let opt_second = split.next();\n+    let first = match first {\n+        \"normal\"       => PpmSource(PpmNormal),\n+        \"expanded\"     => PpmSource(PpmExpanded),\n+        \"typed\"        => PpmSource(PpmTyped),\n+        \"expanded,identified\" => PpmSource(PpmExpandedIdentified),\n+        \"identified\"   => PpmSource(PpmIdentified),\n+        \"flowgraph\"    => PpmFlowGraph,\n+        _ => {\n+            sess.fatal(format!(\n+                \"argument to `pretty` must be one of `normal`, \\\n+                 `expanded`, `flowgraph=<nodeid>`, `typed`, `identified`, \\\n+                 or `expanded,identified`; got {}\", name).as_slice());\n+        }\n+    };\n+    let opt_second = opt_second.and_then::<UserIdentifiedItem>(from_str);\n+    (first, opt_second)\n+}\n+\n+\n+\n+// This slightly awkward construction is to allow for each PpMode to\n+// choose whether it needs to do analyses (which can consume the\n+// Session) and then pass through the session (now attached to the\n+// analysis results) on to the chosen pretty-printer, along with the\n+// `&PpAnn` object.\n+//\n+// Note that since the `&PrinterSupport` is freshly constructed on each\n+// call, it would not make sense to try to attach the lifetime of `self`\n+// to the lifetime of the `&PrinterObject`.\n+//\n+// (The `use_once_payload` is working around the current lack of once\n+// functions in the compiler.)\n+\n+trait CratePrinter {\n+    /// Constructs a `PrinterSupport` object and passes it to `f`.\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<ast_map::Map>,\n+                                 id: String,\n+                                 use_once_payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A;\n+}\n+\n+trait SessionCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to a\n+    /// `Session` from a value that now owns it.\n+    fn sess<'a>(&'a self) -> &'a Session;\n+}\n+\n+trait AstMapCarrier {\n+    /// Provides a uniform interface for re-extracting a reference to an\n+    /// `ast_map::Map` from a value that now owns it.\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map>;\n+}\n+\n+trait PrinterSupport : SessionCarrier + AstMapCarrier {\n+    /// Produces the pretty-print annotation object.\n+    ///\n+    /// Usually implemented via `self as &pprust::PpAnn`.\n+    ///\n+    /// (Rust does not yet support upcasting from a trait object to\n+    /// an object for one of its super-traits.)\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn;\n+}\n+\n+struct NoAnn {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for NoAnn {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for NoAnn {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for NoAnn {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n+\n+impl pprust::PpAnn for NoAnn {}\n+\n+struct IdentifiedAnnotation {\n+    sess: Session,\n+    ast_map: Option<ast_map::Map>,\n+}\n+\n+impl PrinterSupport for IdentifiedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for IdentifiedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+}\n+\n+impl AstMapCarrier for IdentifiedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        self.ast_map.as_ref()\n+    }\n+}\n+\n+impl pprust::PpAnn for IdentifiedAnnotation {\n+    fn pre(&self,\n+           s: &mut pprust::State,\n+           node: pprust::AnnNode) -> io::IoResult<()> {\n+        match node {\n+            pprust::NodeExpr(_) => s.popen(),\n+            _ => Ok(())\n+        }\n+    }\n+    fn post(&self,\n+            s: &mut pprust::State,\n+            node: pprust::AnnNode) -> io::IoResult<()> {\n+        match node {\n+            pprust::NodeItem(item) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(item.id.to_string())\n+            }\n+            pprust::NodeBlock(blk) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(format!(\"block {}\", blk.id))\n+            }\n+            pprust::NodeExpr(expr) => {\n+                try!(pp::space(&mut s.s));\n+                try!(s.synth_comment(expr.id.to_string()));\n+                s.pclose()\n+            }\n+            pprust::NodePat(pat) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(format!(\"pat {}\", pat.id))\n+            }\n+        }\n+    }\n+}\n+\n+struct TypedAnnotation {\n+    analysis: CrateAnalysis,\n+}\n+\n+impl PrinterSupport for TypedAnnotation {\n+    fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self as &pprust::PpAnn }\n+}\n+\n+impl SessionCarrier for TypedAnnotation {\n+    fn sess<'a>(&'a self) -> &'a Session { &self.analysis.ty_cx.sess }\n+}\n+\n+impl AstMapCarrier for TypedAnnotation {\n+    fn ast_map<'a>(&'a self) -> Option<&'a ast_map::Map> {\n+        Some(&self.analysis.ty_cx.map)\n+    }\n+}\n+\n+impl pprust::PpAnn for TypedAnnotation {\n+    fn pre(&self,\n+           s: &mut pprust::State,\n+           node: pprust::AnnNode) -> io::IoResult<()> {\n+        match node {\n+            pprust::NodeExpr(_) => s.popen(),\n+            _ => Ok(())\n+        }\n+    }\n+    fn post(&self,\n+            s: &mut pprust::State,\n+            node: pprust::AnnNode) -> io::IoResult<()> {\n+        let tcx = &self.analysis.ty_cx;\n+        match node {\n+            pprust::NodeExpr(expr) => {\n+                try!(pp::space(&mut s.s));\n+                try!(pp::word(&mut s.s, \"as\"));\n+                try!(pp::space(&mut s.s));\n+                try!(pp::word(&mut s.s,\n+                              ppaux::ty_to_string(\n+                                  tcx,\n+                                  ty::expr_ty(tcx, expr)).as_slice()));\n+                s.pclose()\n+            }\n+            _ => Ok(())\n+        }\n+    }\n+}\n+\n+fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n+    let print_loans   = config::FLOWGRAPH_PRINT_LOANS;\n+    let print_moves   = config::FLOWGRAPH_PRINT_MOVES;\n+    let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;\n+    let print_all     = config::FLOWGRAPH_PRINT_ALL;\n+    let opt = |print_which| sess.debugging_opt(print_which);\n+    let mut variants = Vec::new();\n+    if opt(print_all) || opt(print_loans) {\n+        variants.push(borrowck_dot::Loans);\n+    }\n+    if opt(print_all) || opt(print_moves) {\n+        variants.push(borrowck_dot::Moves);\n+    }\n+    if opt(print_all) || opt(print_assigns) {\n+        variants.push(borrowck_dot::Assigns);\n+    }\n+    variants\n+}\n+\n+#[deriving(Clone, Show)]\n+pub enum UserIdentifiedItem {\n+    ItemViaNode(ast::NodeId),\n+    ItemViaPath(Vec<String>),\n+}\n+\n+impl FromStr for UserIdentifiedItem {\n+    fn from_str(s: &str) -> Option<UserIdentifiedItem> {\n+        let extract_path_parts = || {\n+            let v : Vec<_> = s.split_str(\"::\")\n+                .map(|x|x.to_string())\n+                .collect();\n+            Some(ItemViaPath(v))\n+        };\n+\n+        from_str(s).map(ItemViaNode).or_else(extract_path_parts)\n+    }\n+}\n+\n+enum NodesMatchingUII<'a> {\n+    NodesMatchingDirect(option::Item<ast::NodeId>),\n+    NodesMatchingSuffix(ast_map::NodesMatchingSuffix<'a, String>),\n+}\n+\n+impl<'a> Iterator<ast::NodeId> for NodesMatchingUII<'a> {\n+    fn next(&mut self) -> Option<ast::NodeId> {\n+        match self {\n+            &NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n+        }\n+    }\n+}\n+\n+impl UserIdentifiedItem {\n+    fn reconstructed_input(&self) -> String {\n+        match *self {\n+            ItemViaNode(node_id) => node_id.to_string(),\n+            ItemViaPath(ref parts) => parts.connect(\"::\"),\n+        }\n+    }\n+\n+    fn all_matching_node_ids<'a>(&'a self, map: &'a ast_map::Map) -> NodesMatchingUII<'a> {\n+        match *self {\n+            ItemViaNode(node_id) =>\n+                NodesMatchingDirect(Some(node_id).move_iter()),\n+            ItemViaPath(ref parts) =>\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts.as_slice())),\n+        }\n+    }\n+\n+    fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n+        let fail_because = |is_wrong_because| -> ast::NodeId {\n+            let message =\n+                format!(\"{:s} needs NodeId (int) or unique \\\n+                         path suffix (b::c::d); got {:s}, which {:s}\",\n+                        user_option,\n+                        self.reconstructed_input(),\n+                        is_wrong_because);\n+            sess.fatal(message.as_slice())\n+        };\n+\n+        let mut saw_node = ast::DUMMY_NODE_ID;\n+        let mut seen = 0u;\n+        for node in self.all_matching_node_ids(map) {\n+            saw_node = node;\n+            seen += 1;\n+            if seen > 1 {\n+                fail_because(\"does not resolve uniquely\");\n+            }\n+        }\n+        if seen == 0 {\n+            fail_because(\"does not resolve to any item\");\n+        }\n+\n+        assert!(seen == 1);\n+        return saw_node;\n+    }\n+}\n+\n+impl CratePrinter for PpSourceMode {\n+    fn call_with_pp_support<A,B>(&self,\n+                                 sess: Session,\n+                                 krate: &ast::Crate,\n+                                 ast_map: Option<ast_map::Map>,\n+                                 id: String,\n+                                 payload: B,\n+                                 f: |&PrinterSupport, B| -> A) -> A {\n+        match *self {\n+            PpmNormal | PpmExpanded => {\n+                let annotation = NoAnn { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+\n+            PpmIdentified | PpmExpandedIdentified => {\n+                let annotation = IdentifiedAnnotation { sess: sess, ast_map: ast_map };\n+                f(&annotation, payload)\n+            }\n+            PpmTyped => {\n+                let ast_map = ast_map.expect(\"--pretty=typed missing ast_map\");\n+                let analysis = driver::phase_3_run_analysis_passes(sess, krate, ast_map, id);\n+                let annotation = TypedAnnotation { analysis: analysis };\n+                f(&annotation, payload)\n+            }\n+        }\n+    }\n+}\n+\n+fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n+\n+fn needs_expansion(ppm: &PpMode) -> bool {\n+    match *ppm {\n+        PpmSource(PpmNormal) |\n+        PpmSource(PpmIdentified) => false,\n+\n+        PpmSource(PpmExpanded) |\n+        PpmSource(PpmExpandedIdentified) |\n+        PpmSource(PpmTyped) |\n+        PpmFlowGraph => true\n+    }\n+}\n+\n+pub fn pretty_print_input(sess: Session,\n+                          cfg: ast::CrateConfig,\n+                          input: &driver::Input,\n+                          ppm: PpMode,\n+                          opt_uii: Option<UserIdentifiedItem>,\n+                          ofile: Option<Path>) {\n+    let krate = driver::phase_1_parse_input(&sess, cfg, input);\n+    let id = link::find_crate_name(Some(&sess), krate.attrs.as_slice(), input);\n+\n+    let is_expanded = needs_expansion(&ppm);\n+    let (krate, ast_map) = if needs_ast_map(&ppm, &opt_uii) {\n+        let k = driver::phase_2_configure_and_expand(&sess, krate, id.as_slice(), None);\n+        let (krate, ast_map) = match k {\n+            None => return,\n+            Some(p) => p,\n+        };\n+        (krate, Some(ast_map))\n+    } else {\n+        (krate, None)\n+    };\n+\n+    let src_name = driver::source_name(input);\n+    let src = Vec::from_slice(sess.codemap()\n+                                  .get_filemap(src_name.as_slice())\n+                                  .src\n+                                  .as_bytes());\n+    let mut rdr = MemReader::new(src);\n+\n+    let out = match ofile {\n+        None => box io::stdout() as Box<Writer+'static>,\n+        Some(p) => {\n+            let r = io::File::create(&p);\n+            match r {\n+                Ok(w) => box w as Box<Writer+'static>,\n+                Err(e) => fail!(\"print-print failed to open {} due to {}\",\n+                                p.display(), e),\n+            }\n+        }\n+    };\n+\n+    match (ppm, opt_uii) {\n+        (PpmSource(s), None) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, out, |annotation, out| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    pprust::print_crate(sess.codemap(),\n+                                        sess.diagnostic(),\n+                                        &krate,\n+                                        src_name.to_string(),\n+                                        &mut rdr,\n+                                        out,\n+                                        annotation.pp_ann(),\n+                                        is_expanded)\n+                }),\n+\n+        (PpmSource(s), Some(uii)) =>\n+            s.call_with_pp_support(\n+                sess, &krate, ast_map, id, (out,uii), |annotation, (out,uii)| {\n+                    debug!(\"pretty printing source code {}\", s);\n+                    let sess = annotation.sess();\n+                    let ast_map = annotation.ast_map()\n+                        .expect(\"--pretty missing ast_map\");\n+                    let mut pp_state =\n+                        pprust::State::new_from_input(sess.codemap(),\n+                                                      sess.diagnostic(),\n+                                                      src_name.to_string(),\n+                                                      &mut rdr,\n+                                                      out,\n+                                                      annotation.pp_ann(),\n+                                                      is_expanded);\n+                    for node_id in uii.all_matching_node_ids(ast_map) {\n+                        let node = ast_map.get(node_id);\n+                        try!(pp_state.print_node(&node));\n+                        try!(pp::space(&mut pp_state.s));\n+                        try!(pp_state.synth_comment(ast_map.path_to_string(node_id)));\n+                        try!(pp::hardbreak(&mut pp_state.s));\n+                    }\n+                    pp::eof(&mut pp_state.s)\n+                }),\n+\n+        (PpmFlowGraph, opt_uii) => {\n+            debug!(\"pretty printing flow graph for {}\", opt_uii);\n+            let uii = opt_uii.unwrap_or_else(|| {\n+                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     unique path suffix (b::c::d)\").as_slice())\n+\n+            });\n+            let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n+            let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n+\n+            let node = ast_map.find(nodeid).unwrap_or_else(|| {\n+                sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n+                                   nodeid).as_slice())\n+            });\n+\n+            let code = blocks::Code::from_node(node);\n+            match code {\n+                Some(code) => {\n+                    let variants = gather_flowgraph_variants(&sess);\n+                    let analysis = driver::phase_3_run_analysis_passes(sess, &krate,\n+                                                                       ast_map, id);\n+                    print_flowgraph(variants, analysis, code, out)\n+                }\n+                None => {\n+                    let message = format!(\"--pretty=flowgraph needs \\\n+                                           block, fn, or method; got {:?}\",\n+                                          node);\n+\n+                    // point to what was found, if there's an\n+                    // accessible span.\n+                    match ast_map.opt_span(nodeid) {\n+                        Some(sp) => sess.span_fatal(sp, message.as_slice()),\n+                        None => sess.fatal(message.as_slice())\n+                    }\n+                }\n+            }\n+        }\n+    }.unwrap()\n+}\n+\n+fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n+                                 analysis: CrateAnalysis,\n+                                 code: blocks::Code,\n+                                 mut out: W) -> io::IoResult<()> {\n+    let ty_cx = &analysis.ty_cx;\n+    let cfg = match code {\n+        blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(ty_cx, &*fn_like.body()),\n+    };\n+    debug!(\"cfg: {:?}\", cfg);\n+\n+    match code {\n+        _ if variants.len() == 0 => {\n+            let lcfg = LabelledCFG {\n+                ast_map: &ty_cx.map,\n+                cfg: &cfg,\n+                name: format!(\"node_{}\", code.id()),\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+        blocks::BlockCode(_) => {\n+            ty_cx.sess.err(\"--pretty flowgraph with -Z flowgraph-print \\\n+                            annotations requires fn-like node id.\");\n+            return Ok(())\n+        }\n+        blocks::FnLikeCode(fn_like) => {\n+            let fn_parts = FnPartsWithCFG::from_fn_like(&fn_like, &cfg);\n+            let (bccx, analysis_data) =\n+                borrowck::build_borrowck_dataflow_data_for_fn(ty_cx, fn_parts);\n+\n+            let lcfg = LabelledCFG {\n+                ast_map: &ty_cx.map,\n+                cfg: &cfg,\n+                name: format!(\"node_{}\", code.id()),\n+            };\n+            let lcfg = borrowck_dot::DataflowLabeller {\n+                inner: lcfg,\n+                variants: variants,\n+                borrowck_ctxt: &bccx,\n+                analysis_data: &analysis_data,\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+    }\n+\n+    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {\n+        r.map_err(|ioerr| {\n+            let orig_detail = ioerr.detail.clone();\n+            let m = \"graphviz::render failed\";\n+            io::IoError {\n+                detail: Some(match orig_detail {\n+                    None => m.into_string(),\n+                    Some(d) => format!(\"{}: {}\", m, d)\n+                }),\n+                ..ioerr\n+            }\n+        })\n+    }\n+}"}]}