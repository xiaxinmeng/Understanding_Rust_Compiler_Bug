{"sha": "1064d41c96047650897be96190e018be9bbd818a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNjRkNDFjOTYwNDc2NTA4OTdiZTk2MTkwZTAxOGJlOWJiZDgxOGE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-17T17:49:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-17T18:04:48Z"}, "message": "resolve/expand: Rename some things for clarity", "tree": {"sha": "ae34516d3c4151802e5a2ef75ca292ff7d194175", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae34516d3c4151802e5a2ef75ca292ff7d194175"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1064d41c96047650897be96190e018be9bbd818a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1064d41c96047650897be96190e018be9bbd818a", "html_url": "https://github.com/rust-lang/rust/commit/1064d41c96047650897be96190e018be9bbd818a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1064d41c96047650897be96190e018be9bbd818a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d479ff2ffe75e966fc802505852b1c74f1da95df", "url": "https://api.github.com/repos/rust-lang/rust/commits/d479ff2ffe75e966fc802505852b1c74f1da95df", "html_url": "https://github.com/rust-lang/rust/commit/d479ff2ffe75e966fc802505852b1c74f1da95df"}], "stats": {"total": 84, "additions": 43, "deletions": 41}, "files": [{"sha": "42428456b6eec39de4c2640a129c0428714a18c4", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -160,23 +160,23 @@ impl<'a> Resolver<'a> {\n         Some(ext)\n     }\n \n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     crate fn build_reduced_graph(\n         &mut self,\n         fragment: &AstFragment,\n-        extra_placeholders: &[ExpnId],\n+        extra_placeholders: &[NodeId],\n         parent_scope: ParentScope<'a>,\n     ) -> LegacyScope<'a> {\n         let mut def_collector = DefCollector::new(&mut self.definitions, parent_scope.expansion);\n         fragment.visit_with(&mut def_collector);\n         for placeholder in extra_placeholders {\n-            def_collector.visit_macro_invoc(NodeId::placeholder_from_expn_id(*placeholder));\n+            def_collector.visit_macro_invoc(*placeholder);\n         }\n \n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n         for placeholder in extra_placeholders {\n-            visitor.parent_scope.legacy =\n-                visitor.visit_invoc(NodeId::placeholder_from_expn_id(*placeholder));\n+            visitor.parent_scope.legacy = visitor.visit_invoc(*placeholder);\n         }\n \n         visitor.parent_scope.legacy\n@@ -884,7 +884,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<ast::NodeId>) {\n+    fn build_reduced_graph_for_external_crate_res(&mut self, child: Export<NodeId>) {\n         let parent = self.parent_scope.module;\n         let Export { ident, res, vis, span } = child;\n         // FIXME: We shouldn't create the gensym here, it should come from metadata,\n@@ -1073,10 +1073,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: ast::NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n-        self.parent_scope.module.unresolved_invocations.borrow_mut().insert(invoc_id);\n+        self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");"}, {"sha": "2dd0ad13c526d80b4d653db5df3e474b69a94d01", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -448,7 +448,7 @@ pub struct ModuleData<'a> {\n     populate_on_access: Cell<bool>,\n \n     // Macro invocations that can expand into items in this module.\n-    unresolved_invocations: RefCell<FxHashSet<ExpnId>>,\n+    unexpanded_invocations: RefCell<FxHashSet<ExpnId>>,\n \n     no_implicit_prelude: bool,\n \n@@ -478,7 +478,7 @@ impl<'a> ModuleData<'a> {\n             normal_ancestor_id,\n             lazy_resolutions: Default::default(),\n             populate_on_access: Cell::new(!normal_ancestor_id.is_local()),\n-            unresolved_invocations: Default::default(),\n+            unexpanded_invocations: Default::default(),\n             no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new(Vec::new()),"}, {"sha": "01ad67252a387886f630a7e01ed12f14ad33bd15", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -10,7 +10,7 @@ use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n-use syntax::ast::{self, Ident};\n+use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n@@ -26,7 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n \n-type Res = def::Res<ast::NodeId>;\n+type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n@@ -91,11 +91,11 @@ fn fast_print_path(path: &ast::Path) -> Symbol {\n }\n \n impl<'a> base::Resolver for Resolver<'a> {\n-    fn next_node_id(&mut self) -> ast::NodeId {\n+    fn next_node_id(&mut self) -> NodeId {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n         let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n@@ -115,18 +115,18 @@ impl<'a> base::Resolver for Resolver<'a> {\n         });\n     }\n \n-\n-\n+    // FIXME: `extra_placeholders` should be included into the `fragment` as regular placeholders.\n     fn visit_ast_fragment_with_placeholders(\n-        &mut self, expansion: ExpnId, fragment: &AstFragment, derives: &[ExpnId]\n+        &mut self, expansion: ExpnId, fragment: &AstFragment, extra_placeholders: &[NodeId]\n     ) {\n         // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let output_legacy_scope = self.build_reduced_graph(fragment, derives, parent_scope);\n+        let output_legacy_scope =\n+            self.build_reduced_graph(fragment, extra_placeholders, parent_scope);\n         self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n \n-        parent_scope.module.unresolved_invocations.borrow_mut().remove(&expansion);\n+        parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n \n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension) {\n@@ -480,7 +480,7 @@ impl<'a> Resolver<'a> {\n                 Scope::MacroUsePrelude => match this.macro_use_prelude.get(&ident.name).cloned() {\n                     Some(binding) => Ok((binding, Flags::PRELUDE | Flags::MISC_FROM_PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     ))\n                 }\n                 Scope::BuiltinAttrs => if is_builtin_attr_name(ident.name) {\n@@ -503,7 +503,7 @@ impl<'a> Resolver<'a> {\n                 Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n                     Some(binding) => Ok((binding, Flags::PRELUDE)),\n                     None => Err(Determinacy::determined(\n-                        this.graph_root.unresolved_invocations.borrow().is_empty()\n+                        this.graph_root.unexpanded_invocations.borrow().is_empty()\n                     )),\n                 }\n                 Scope::ToolPrelude => if KNOWN_TOOLS.contains(&ident.name) {"}, {"sha": "fd222a132a3f8589c53df38bff1849c8edb759e5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n                     Err((Determined, Weak::No))\n                 } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n                     Ok(binding)\n-                } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n                     Err((Undetermined, Weak::No))\n                 } else {\n@@ -348,7 +348,7 @@ impl<'a> Resolver<'a> {\n         // progress, we have to ignore those potential unresolved invocations from other modules\n         // and prohibit access to macro-expanded `macro_export` macros instead (unless restricted\n         // shadowing is enabled, see `macro_expanded_macro_export_errors`).\n-        let unexpanded_macros = !module.unresolved_invocations.borrow().is_empty();\n+        let unexpanded_macros = !module.unexpanded_invocations.borrow().is_empty();\n         if let Some(binding) = resolution.binding {\n             if !unexpanded_macros || ns == MacroNS || restricted_shadowing {\n                 return check_usable(self, binding);"}, {"sha": "b0a4a6af9839c4fd91e6f33541b241c3f313593c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Attribute, Name, PatKind};\n+use crate::ast::{self, NodeId, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n@@ -671,13 +671,13 @@ bitflags::bitflags! {\n }\n \n pub trait Resolver {\n-    fn next_node_id(&mut self) -> ast::NodeId;\n+    fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId;\n+    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n \n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n-                                            derives: &[ExpnId]);\n+                                            extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n     fn resolve_imports(&mut self);"}, {"sha": "c1d52c9745529125ddcfed00d900d8bd5d65731c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Unresolved macros produce dummy outputs as a recovery measure.\n         invocations.reverse();\n         let mut expanded_fragments = Vec::new();\n-        let mut derives: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n+        let mut all_derive_placeholders: FxHashMap<ExpnId, Vec<_>> = FxHashMap::default();\n         let mut undetermined_invocations = Vec::new();\n         let (mut progress, mut force) = (false, !self.monotonic);\n         loop {\n@@ -347,13 +347,14 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derives = derives.entry(invoc.expansion_data.id).or_default();\n+                let derive_placeholders =\n+                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n \n-                derives.reserve(traits.len());\n+                derive_placeholders.reserve(traits.len());\n                 invocations.reserve(traits.len());\n                 for path in traits {\n                     let expn_id = ExpnId::fresh(None);\n-                    derives.push(expn_id);\n+                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n                     invocations.push(Invocation {\n                         kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n@@ -365,7 +366,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 let fragment = invoc.fragment_kind\n                     .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derives)\n+                self.collect_invocations(fragment, derive_placeholders)\n             } else {\n                 unreachable!()\n             };\n@@ -384,10 +385,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expanded_fragments) = expanded_fragments.pop() {\n-            for (mark, expanded_fragment) in expanded_fragments.into_iter().rev() {\n-                let derives = derives.remove(&mark).unwrap_or_else(Vec::new);\n-                placeholder_expander.add(NodeId::placeholder_from_expn_id(mark),\n-                                         expanded_fragment, derives);\n+            for (expn_id, expanded_fragment) in expanded_fragments.into_iter().rev() {\n+                let derive_placeholders =\n+                    all_derive_placeholders.remove(&expn_id).unwrap_or_else(Vec::new);\n+                placeholder_expander.add(NodeId::placeholder_from_expn_id(expn_id),\n+                                         expanded_fragment, derive_placeholders);\n             }\n         }\n         fragment_with_placeholders.mut_visit_with(&mut placeholder_expander);\n@@ -404,7 +406,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// them with \"placeholders\" - dummy macro invocations with specially crafted `NodeId`s.\n     /// Then call into resolver that builds a skeleton (\"reduced graph\") of the fragment and\n     /// prepares data for resolving paths of macro invocations.\n-    fn collect_invocations(&mut self, mut fragment: AstFragment, derives: &[ExpnId])\n+    fn collect_invocations(&mut self, mut fragment: AstFragment, extra_placeholders: &[NodeId])\n                            -> (AstFragment, Vec<Invocation>) {\n         // Resolve `$crate`s in the fragment for pretty-printing.\n         self.cx.resolver.resolve_dollar_crates();\n@@ -423,9 +425,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             collector.invocations\n         };\n \n+        // FIXME: Merge `extra_placeholders` into the `fragment` as regular placeholders.\n         if self.monotonic {\n             self.cx.resolver.visit_ast_fragment_with_placeholders(\n-                self.cx.current_expansion.id, &fragment, derives);\n+                self.cx.current_expansion.id, &fragment, extra_placeholders);\n         }\n \n         (fragment, invocations)"}, {"sha": "d800cfedcfb4b27796b7a01f34ba3081479f0a2e", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1064d41c96047650897be96190e018be9bbd818a/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=1064d41c96047650897be96190e018be9bbd818a", "patch": "@@ -2,7 +2,6 @@ use crate::ast::{self, NodeId};\n use crate::source_map::{DUMMY_SP, dummy_spanned};\n use crate::ext::base::ExtCtxt;\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::ExpnId;\n use crate::tokenstream::TokenStream;\n use crate::mut_visit::*;\n use crate::ptr::P;\n@@ -86,11 +85,11 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n         }\n     }\n \n-    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, derives: Vec<ExpnId>) {\n+    pub fn add(&mut self, id: ast::NodeId, mut fragment: AstFragment, placeholders: Vec<NodeId>) {\n         fragment.mut_visit_with(self);\n         if let AstFragment::Items(mut items) = fragment {\n-            for derive in derives {\n-                match self.remove(NodeId::placeholder_from_expn_id(derive)) {\n+            for placeholder in placeholders {\n+                match self.remove(placeholder) {\n                     AstFragment::Items(derived_items) => items.extend(derived_items),\n                     _ => unreachable!(),\n                 }"}]}