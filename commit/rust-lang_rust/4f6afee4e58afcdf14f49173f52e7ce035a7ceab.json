{"sha": "4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "node_id": "C_kwDOAAsO6NoAKDRmNmFmZWU0ZTU4YWZjZGYxNGY0OTE3M2Y1MmU3Y2UwMzVhN2NlYWI", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-10-05T04:12:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-05T04:12:33Z"}, "message": "Rollup merge of #88090 - nbdd0121:inference, r=nikomatsakis\n\nPerform type inference in range pattern\n\nFix #88074", "tree": {"sha": "4551cfa7a1d99ad11ae12eeb42b9b96332337a05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4551cfa7a1d99ad11ae12eeb42b9b96332337a05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhW9CyCRBK7hj4Ov3rIwAA23kIAHksQacvcMDbLvmmqoeW+NLh\nGfPliWGb/f2kQK7b8mAfuagCrLVOLeuwOS8PAGOJAFR5E/89iukpxz2FFjAo+Ufl\nrExngbRmXI8i/F2He0FoBbUyQ30J8yooZSvKJDFvTs87nMZ0D475HWBqeiby6AoI\nXXOvx/cszCxu0E1QkI0qahFAsIs/9xthVPnbiW+P828Zpy8twUGIqG2pU8CrZfh1\nkw4hcdJeIqoF3OK45+69ASmcJjfjWKHmIW14cpNvMlRHCGLb5XJbs4jnw9VT/f+P\nnuxzRjUumGP7R58r0L7Z8p0mafrpe8obZ7c3YS0R3U5586nBswssQEZOS0fwyXk=\n=et94\n-----END PGP SIGNATURE-----\n", "payload": "tree 4551cfa7a1d99ad11ae12eeb42b9b96332337a05\nparent 99e6e3ff078162ffec3bb5fd810d54246add2196\nparent 52a040379010f78a75ffc4806c968b3489372311\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1633407153 -0700\ncommitter GitHub <noreply@github.com> 1633407153 -0700\n\nRollup merge of #88090 - nbdd0121:inference, r=nikomatsakis\n\nPerform type inference in range pattern\n\nFix #88074\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "html_url": "https://github.com/rust-lang/rust/commit/4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99e6e3ff078162ffec3bb5fd810d54246add2196", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e6e3ff078162ffec3bb5fd810d54246add2196", "html_url": "https://github.com/rust-lang/rust/commit/99e6e3ff078162ffec3bb5fd810d54246add2196"}, {"sha": "52a040379010f78a75ffc4806c968b3489372311", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a040379010f78a75ffc4806c968b3489372311", "html_url": "https://github.com/rust-lang/rust/commit/52a040379010f78a75ffc4806c968b3489372311"}], "stats": {"total": 137, "additions": 109, "deletions": 28}, "files": [{"sha": "98bec3f6eac5108a4882834a9a3832f30b59f9f9", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -449,16 +449,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let calc_side = |opt_expr: Option<&'tcx hir::Expr<'tcx>>| match opt_expr {\n-            None => (None, None),\n+            None => None,\n             Some(expr) => {\n                 let ty = self.check_expr(expr);\n-                // Check that the end-point is of numeric or char type.\n-                let fail = !(ty.is_numeric() || ty.is_char() || ty.references_error());\n-                (Some(ty), Some((fail, ty, expr.span)))\n+                // Check that the end-point is possibly of numeric or char type.\n+                // The early check here is not for correctness, but rather better\n+                // diagnostics (e.g. when `&str` is being matched, `expected` will\n+                // be peeled to `str` while ty here is still `&str`, if we don't\n+                // err ealy here, a rather confusing unification error will be\n+                // emitted instead).\n+                let fail =\n+                    !(ty.is_numeric() || ty.is_char() || ty.is_ty_var() || ty.references_error());\n+                Some((fail, ty, expr.span))\n             }\n         };\n-        let (lhs_ty, lhs) = calc_side(lhs);\n-        let (rhs_ty, rhs) = calc_side(rhs);\n+        let mut lhs = calc_side(lhs);\n+        let mut rhs = calc_side(rhs);\n \n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n             // There exists a side that didn't meet our criteria that the end-point\n@@ -467,25 +473,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        // Now that we know the types can be unified we find the unified type\n-        // and use it to type the entire expression.\n-        let common_type = self.resolve_vars_if_possible(lhs_ty.or(rhs_ty).unwrap_or(expected));\n-\n+        // Unify each side with `expected`.\n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n-        let demand_eqtype = |x, y| {\n-            if let Some((_, x_ty, x_span)) = x {\n+        let demand_eqtype = |x: &mut _, y| {\n+            if let Some((ref mut fail, x_ty, x_span)) = *x {\n                 if let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti) {\n                     if let Some((_, y_ty, y_span)) = y {\n                         self.endpoint_has_type(&mut err, y_span, y_ty);\n                     }\n                     err.emit();\n+                    *fail = true;\n                 };\n             }\n         };\n-        demand_eqtype(lhs, rhs);\n-        demand_eqtype(rhs, lhs);\n+        demand_eqtype(&mut lhs, rhs);\n+        demand_eqtype(&mut rhs, lhs);\n+\n+        if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n+            return self.tcx.ty_error();\n+        }\n \n-        common_type\n+        // Find the unified type and check if it's of numeric or char type again.\n+        // This check is needed if both sides are inference variables.\n+        // We require types to be resolved here so that we emit inference failure\n+        // rather than \"_ is not a char or numeric\".\n+        let ty = self.structurally_resolved_type(span, expected);\n+        if !(ty.is_numeric() || ty.is_char() || ty.references_error()) {\n+            if let Some((ref mut fail, _, _)) = lhs {\n+                *fail = true;\n+            }\n+            if let Some((ref mut fail, _, _)) = rhs {\n+                *fail = true;\n+            }\n+            self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error();\n+        }\n+        ty\n     }\n \n     fn endpoint_has_type(&self, err: &mut DiagnosticBuilder<'_>, span: Span, ty: Ty<'_>) {\n@@ -512,10 +535,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             E0029,\n             \"only `char` and numeric types are allowed in range patterns\"\n         );\n-        let msg = |ty| format!(\"this is of type `{}` but it should be `char` or numeric\", ty);\n+        let msg = |ty| {\n+            let ty = self.resolve_vars_if_possible(ty);\n+            format!(\"this is of type `{}` but it should be `char` or numeric\", ty)\n+        };\n         let mut one_side_err = |first_span, first_ty, second: Option<(bool, Ty<'tcx>, Span)>| {\n             err.span_label(first_span, &msg(first_ty));\n             if let Some((_, ty, sp)) = second {\n+                let ty = self.resolve_vars_if_possible(ty);\n                 self.endpoint_has_type(&mut err, sp, ty);\n             }\n         };"}, {"sha": "16df272df6bd9a909bda177582ad3b73835bbefb", "filename": "src/test/ui/pattern/issue-88074-pat-range-type-inference-err.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.rs?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -0,0 +1,28 @@\n+trait Zero {\n+    const ZERO: Self;\n+}\n+\n+impl Zero for String {\n+    const ZERO: Self = String::new();\n+}\n+\n+fn foo() {\n+     match String::new() {\n+        Zero::ZERO ..= Zero::ZERO => {},\n+        //~^ ERROR only `char` and numeric types are allowed in range patterns\n+        _ => {},\n+    }\n+}\n+\n+fn bar() {\n+    match Zero::ZERO {\n+        Zero::ZERO ..= Zero::ZERO => {},\n+        //~^ ERROR type annotations needed [E0282]\n+        _ => {},\n+    }\n+}\n+\n+fn main() {\n+    foo();\n+    bar();\n+}"}, {"sha": "06a279925edbc75d3831d9e67f96214f46e368b9", "filename": "src/test/ui/pattern/issue-88074-pat-range-type-inference-err.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference-err.stderr?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -0,0 +1,21 @@\n+error[E0029]: only `char` and numeric types are allowed in range patterns\n+  --> $DIR/issue-88074-pat-range-type-inference-err.rs:11:9\n+   |\n+LL |         Zero::ZERO ..= Zero::ZERO => {},\n+   |         ----------^^^^^----------\n+   |         |              |\n+   |         |              this is of type `String` but it should be `char` or numeric\n+   |         this is of type `String` but it should be `char` or numeric\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-88074-pat-range-type-inference-err.rs:19:9\n+   |\n+LL |         Zero::ZERO ..= Zero::ZERO => {},\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type\n+   |\n+   = note: type must be known at this point\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0029, E0282.\n+For more information about an error, try `rustc --explain E0029`."}, {"sha": "27db7d8c7ab9dbfa0d66d50fd871ebe7969e39af", "filename": "src/test/ui/pattern/issue-88074-pat-range-type-inference.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-88074-pat-range-type-inference.rs?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+trait Zero {\n+    const ZERO: Self;\n+}\n+\n+impl Zero for i32 {\n+    const ZERO: Self = 0;\n+}\n+\n+fn main() {\n+    match 1 {\n+        Zero::ZERO ..= 1 => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "7ef541cb58528d39a5eae25eb1199632f1a9d5a4", "filename": "src/test/ui/pattern/patkind-litrange-no-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -19,7 +19,6 @@ enum_number!(Change {\n     Neg = -1,\n     Arith = 1 + 1, //~ ERROR arbitrary expressions aren't allowed in patterns\n                    //~| ERROR arbitrary expressions aren't allowed in patterns\n-                   //~| ERROR only `char` and numeric types are allowed in range patterns\n });\n \n fn main() {}"}, {"sha": "eb1ee7e45673d6856d2ea08af2f40e82638fa7e7", "filename": "src/test/ui/pattern/patkind-litrange-no-expr.stderr", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f6afee4e58afcdf14f49173f52e7ce035a7ceab/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr?ref=4f6afee4e58afcdf14f49173f52e7ce035a7ceab", "patch": "@@ -10,15 +10,5 @@ error: arbitrary expressions aren't allowed in patterns\n LL |     Arith = 1 + 1,\n    |             ^^^^^\n \n-error[E0029]: only `char` and numeric types are allowed in range patterns\n-  --> $DIR/patkind-litrange-no-expr.rs:20:13\n-   |\n-LL |                 $( $value ..= 42 => Some($name::$variant), )* // PatKind::Range\n-   |                               -- this is of type `{integer}`\n-...\n-LL |     Arith = 1 + 1,\n-   |             ^^^^^ this is of type `_` but it should be `char` or numeric\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0029`."}]}