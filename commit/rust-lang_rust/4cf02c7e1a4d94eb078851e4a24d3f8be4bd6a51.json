{"sha": "4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjAyYzdlMWE0ZDk0ZWIwNzg4NTFlNGEyNGQzZjhiZTRiZDZhNTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-03-07T07:09:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-07T07:09:48Z"}, "message": "Merge pull request #2483 from kimsnj/infinite_loop\n\nimmutable while condition", "tree": {"sha": "6fb76f05d02460b1dacf9e0528095ad88a591e6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fb76f05d02460b1dacf9e0528095ad88a591e6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJan5A8CRBK7hj4Ov3rIwAAdHIIAEzzMJWxqp9C4ptL5gqvxnk+\ntK6tMEMtf2Wpc5eGO8kJea0k6kqtgJY40FZ7NzQx6tcBX7L9eQSji7kfDgsrdRoh\nO1Du9yXTDvARoQfEQWhvnJKXIe0+B47Z245/04zN3c4Dd0kMQwjDw7M+ETkMOGtu\niEHjBwYkbsT/hsTeXVhj1LfXlPzb997vw1CaSeIDASu/ZLQEzjXF76+GUf6UDEY0\nI7/Ptx6jgZJ3rVFFdq9GaiMP3i9rk0B8yWdXCWaBi4XBhuu03b8tsM6zE+GBNL7E\nTqlDnSyACkrIre2tm1v6s+5FmRC27CqGfyEhE5hhiepyx8dQgthEohAbhkSQCUw=\n=6AuA\n-----END PGP SIGNATURE-----\n", "payload": "tree 6fb76f05d02460b1dacf9e0528095ad88a591e6e\nparent 7d5ecd5ad59ea2b8df02366c2bd5040c98fa6730\nparent 814827113e8cdffadb215de52fde349bace81610\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1520406588 +0100\ncommitter GitHub <noreply@github.com> 1520406588 +0100\n\nMerge pull request #2483 from kimsnj/infinite_loop\n\nimmutable while condition"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "html_url": "https://github.com/rust-lang/rust/commit/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d5ecd5ad59ea2b8df02366c2bd5040c98fa6730", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d5ecd5ad59ea2b8df02366c2bd5040c98fa6730", "html_url": "https://github.com/rust-lang/rust/commit/7d5ecd5ad59ea2b8df02366c2bd5040c98fa6730"}, {"sha": "814827113e8cdffadb215de52fde349bace81610", "url": "https://api.github.com/repos/rust-lang/rust/commits/814827113e8cdffadb215de52fde349bace81610", "html_url": "https://github.com/rust-lang/rust/commit/814827113e8cdffadb215de52fde349bace81610"}], "stats": {"total": 325, "additions": 319, "deletions": 6}, "files": [{"sha": "e1b8ff2dc05fc1241340aa3cdd5f68f3ce67ecf7", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "patch": "@@ -521,6 +521,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         loops::UNUSED_COLLECT,\n         loops::WHILE_LET_LOOP,\n         loops::WHILE_LET_ON_ITERATOR,\n+        loops::WHILE_IMMUTABLE_CONDITION,\n         map_clone::MAP_CLONE,\n         matches::MATCH_AS_REF,\n         matches::MATCH_BOOL,"}, {"sha": "7873240a95c17c593e429e90fb71e3151428cadc", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 135, "deletions": 5, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "patch": "@@ -343,6 +343,27 @@ declare_lint! {\n     \"for loop over a range where one of the bounds is a mutable variable\"\n }\n \n+/// **What it does:** Checks whether variables used within while loop condition\n+/// can be (and are) mutated in the body.\n+///\n+/// **Why is this bad?** If the condition is unchanged, entering the body of the loop\n+/// will lead to an infinite loop.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// let i = 0;\n+/// while i > 10 {\n+///    println!(\"let me loop forever!\");\n+/// }\n+/// ```\n+declare_lint! {\n+    pub WHILE_IMMUTABLE_CONDITION,\n+    Warn,\n+    \"variables used within while expression are not mutated in the body\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Pass;\n \n@@ -364,7 +385,8 @@ impl LintPass for Pass {\n             WHILE_LET_ON_ITERATOR,\n             FOR_KV_MAP,\n             NEVER_LOOP,\n-            MUT_RANGE_BOUND\n+            MUT_RANGE_BOUND,\n+            WHILE_IMMUTABLE_CONDITION,\n         )\n     }\n }\n@@ -469,6 +491,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             }\n         }\n+\n+        // check for while loops which conditions never change\n+        if let ExprWhile(ref cond, ref block, _) = expr.node {\n+            check_infinite_loop(cx, cond, block, expr);\n+        }\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n@@ -1372,14 +1399,14 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-struct MutateDelegate {\n+struct MutatePairDelegate {\n     node_id_low: Option<NodeId>,\n     node_id_high: Option<NodeId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n-impl<'tcx> Delegate<'tcx> for MutateDelegate {\n+impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {}\n \n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n@@ -1413,7 +1440,7 @@ impl<'tcx> Delegate<'tcx> for MutateDelegate {\n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n }\n \n-impl<'tcx> MutateDelegate {\n+impl<'tcx> MutatePairDelegate {\n     fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n         (self.span_low, self.span_high)\n     }\n@@ -1472,7 +1499,7 @@ fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n }\n \n fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>]) -> (Option<Span>, Option<Span>) {\n-    let mut delegate = MutateDelegate {\n+    let mut delegate = MutatePairDelegate {\n         node_id_low: bound_ids[0],\n         node_id_high: bound_ids[1],\n         span_low: None,\n@@ -2113,3 +2140,106 @@ fn path_name(e: &Expr) -> Option<Name> {\n     };\n     None\n }\n+\n+fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, block: &'tcx Block, expr: &'tcx Expr) {\n+    let mut mut_var_visitor = MutableVarsVisitor {\n+        cx,\n+        ids: HashMap::new(),\n+        skip: false,\n+    };\n+    walk_expr(&mut mut_var_visitor, expr);\n+    if mut_var_visitor.skip {\n+        return;\n+    }\n+\n+    if mut_var_visitor.ids.len() == 0 {\n+        span_lint(\n+            cx,\n+            WHILE_IMMUTABLE_CONDITION,\n+            cond.span,\n+            \"all variables in condition are immutable. This might lead to infinite loops.\",\n+        );\n+        return;\n+    }\n+\n+\n+    let mut delegate = MutVarsDelegate {\n+        mut_spans: mut_var_visitor.ids,\n+    };\n+    let def_id = def_id::DefId::local(block.hir_id.owner);\n+    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n+    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n+\n+    if !delegate.mut_spans.iter().any(|(_, v)| v.is_some()) {\n+        span_lint(\n+            cx,\n+            WHILE_IMMUTABLE_CONDITION,\n+            expr.span,\n+            \"Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\",\n+        );\n+    }\n+}\n+\n+/// Collects the set of mutable variable in an expression\n+/// Stops analysis if a function call is found\n+struct MutableVarsVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    ids: HashMap<NodeId, Option<Span>>,\n+    skip: bool,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for MutableVarsVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+        match ex.node {\n+            ExprPath(_) => if let Some(node_id) = check_for_mutability(self.cx, &ex) {\n+                self.ids.insert(node_id, None);\n+            },\n+\n+            // If there is any fuction/method call\u2026 we just stop analysis\n+            ExprCall(..) | ExprMethodCall(..) => self.skip = true,\n+\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn visit_block(&mut self, _b: &'tcx Block) {}\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+struct MutVarsDelegate {\n+    mut_spans: HashMap<NodeId, Option<Span>>,\n+}\n+\n+impl<'tcx> MutVarsDelegate {\n+    fn update(&mut self, cat: &'tcx Categorization, sp: Span) {\n+        if let &Categorization::Local(id) = cat {\n+            if let Some(span) = self.mut_spans.get_mut(&id) {    \n+                *span = Some(sp)\n+            }\n+        }\n+    }\n+}\n+\n+\n+impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n+    fn consume(&mut self, _: NodeId, _: Span, _: cmt<'tcx>, _: ConsumeMode) {}\n+\n+    fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n+\n+    fn consume_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            self.update(&cmt.cat, sp)\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: NodeId, sp: Span, cmt: cmt<'tcx>, _: MutateMode) {\n+            self.update(&cmt.cat, sp)\n+    }\n+\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+}\n\\ No newline at end of file"}, {"sha": "cc694583eecbcee59e768306e8883ffa25d58062", "filename": "tests/ui/infinite_loop.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "patch": "@@ -0,0 +1,115 @@\n+fn fn_val(i: i32) -> i32 { unimplemented!() }\n+fn fn_constref(i: &i32) -> i32 { unimplemented!() }\n+fn fn_mutref(i: &mut i32) { unimplemented!() }\n+fn fooi() -> i32 { unimplemented!() }\n+fn foob() -> bool { unimplemented!() }\n+\n+fn immutable_condition() {\n+    // Should warn when all vars mentionned are immutable\n+    let y = 0;\n+    while y < 10 {\n+        println!(\"KO - y is immutable\");\n+    }\n+\n+    let x = 0;\n+    while y < 10 && x < 3 {\n+        let mut k = 1;\n+        k += 2;\n+        println!(\"KO - x and y immutable\");\n+    }\n+\n+    let cond = false;\n+    while !cond {\n+        println!(\"KO - cond immutable\");\n+    }\n+\n+    let mut i = 0;\n+    while y < 10 && i < 3 {\n+        i += 1;\n+        println!(\"OK - i is mutable\");\n+    }\n+\n+    let mut mut_cond = false;\n+    while !mut_cond || cond {\n+        mut_cond = true;\n+        println!(\"OK - mut_cond is mutable\");\n+    }\n+\n+    while fooi() < x {\n+        println!(\"OK - Fn call results may vary\");\n+    }\n+\n+    while foob() {\n+        println!(\"OK - Fn call results may vary\");\n+    }\n+\n+}\n+\n+fn unused_var() {\n+    // Should warn when a (mutable) var is not used in while body\n+    let (mut i, mut j) = (0, 0);\n+\n+    while i < 3 {\n+        j = 3;\n+        println!(\"KO - i not mentionned\");\n+    }\n+\n+    while i < 3 && j > 0 {\n+        println!(\"KO - i and j not mentionned\");\n+    }\n+\n+    while i < 3 {\n+        let mut i = 5;\n+        fn_mutref(&mut i);\n+        println!(\"KO - shadowed\");\n+    }\n+\n+    while i < 3 && j > 0 {\n+        i = 5;\n+        println!(\"OK - i in cond and mentionned\");\n+    }\n+}\n+\n+fn used_immutable() {\n+    let mut i = 0;\n+\n+    while i < 3 {\n+        fn_constref(&i);\n+        println!(\"KO - const reference\");\n+    }\n+\n+    while i < 3 {\n+        fn_val(i);\n+        println!(\"KO - passed by value\");\n+    }\n+\n+    while i < 3 {\n+        println!(\"OK - passed by mutable reference\");\n+        fn_mutref(&mut i)\n+    }\n+\n+    while i < 3 {\n+        fn_mutref(&mut i);\n+        println!(\"OK - passed by mutable reference\");\n+    }\n+}\n+\n+use std::cell::Cell;\n+\n+fn maybe_i_mutate(i: &Cell<bool>) { unimplemented!() }\n+\n+fn internally_mutable() {\n+    let b = Cell::new(true);\n+\n+    while b.get() {       // b cannot be silently coerced to `bool`\n+        maybe_i_mutate(&b);\n+        println!(\"OK - Method call within condition\");\n+    }\n+}\n+\n+fn main() {\n+    immutable_condition();\n+    unused_var();\n+    used_immutable();\n+    internally_mutable();\n+}"}, {"sha": "fba90823173df901520a205adedc7c2a87841466", "filename": "tests/ui/infinite_loop.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.stderr?ref=4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "patch": "@@ -0,0 +1,67 @@\n+error: all variables in condition are immutable. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:10:11\n+   |\n+10 |     while y < 10 {\n+   |           ^^^^^^\n+   |\n+   = note: `-D while-immutable-condition` implied by `-D warnings`\n+\n+error: all variables in condition are immutable. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:15:11\n+   |\n+15 |     while y < 10 && x < 3 {\n+   |           ^^^^^^^^^^^^^^^\n+\n+error: all variables in condition are immutable. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:22:11\n+   |\n+22 |     while !cond {\n+   |           ^^^^^\n+\n+error: Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:52:5\n+   |\n+52 | /     while i < 3 {\n+53 | |         j = 3;\n+54 | |         println!(\"KO - i not mentionned\");\n+55 | |     }\n+   | |_____^\n+\n+error: Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:57:5\n+   |\n+57 | /     while i < 3 && j > 0 {\n+58 | |         println!(\"KO - i and j not mentionned\");\n+59 | |     }\n+   | |_____^\n+\n+error: Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:61:5\n+   |\n+61 | /     while i < 3 {\n+62 | |         let mut i = 5;\n+63 | |         fn_mutref(&mut i);\n+64 | |         println!(\"KO - shadowed\");\n+65 | |     }\n+   | |_____^\n+\n+error: Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:76:5\n+   |\n+76 | /     while i < 3 {\n+77 | |         fn_constref(&i);\n+78 | |         println!(\"KO - const reference\");\n+79 | |     }\n+   | |_____^\n+\n+error: Variable in the condition are not mutated in the loop body. This might lead to infinite loops.\n+  --> $DIR/infinite_loop.rs:81:5\n+   |\n+81 | /     while i < 3 {\n+82 | |         fn_val(i);\n+83 | |         println!(\"KO - passed by value\");\n+84 | |     }\n+   | |_____^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "2050012666207d7f3f7d641c03b65c4f06f1b86e", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=4cf02c7e1a4d94eb078851e4a24d3f8be4bd6a51", "patch": "@@ -1,6 +1,6 @@\n \n \n-#![allow(single_match, unused_assignments, unused_variables)]\n+#![allow(single_match, unused_assignments, unused_variables, while_immutable_condition)]\n \n fn test1() {\n     let mut x = 0;"}]}