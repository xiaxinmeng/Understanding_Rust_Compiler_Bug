{"sha": "896a1c7fcdda7398d242ac6faace1c547349d3d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NmExYzdmY2RkYTczOThkMjQyYWM2ZmFhY2UxYzU0NzM0OWQzZDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-01T20:52:02Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T06:33:09Z"}, "message": "resolve: account for general or-patterns in consistency checking.", "tree": {"sha": "296c1ee353213980eb120273f3315c349f7ec5fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/296c1ee353213980eb120273f3315c349f7ec5fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/896a1c7fcdda7398d242ac6faace1c547349d3d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/896a1c7fcdda7398d242ac6faace1c547349d3d6", "html_url": "https://github.com/rust-lang/rust/commit/896a1c7fcdda7398d242ac6faace1c547349d3d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/896a1c7fcdda7398d242ac6faace1c547349d3d6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "498ec5952062bac854eae7cb4e5152bb648dfe35", "url": "https://api.github.com/repos/rust-lang/rust/commits/498ec5952062bac854eae7cb4e5152bb648dfe35", "html_url": "https://github.com/rust-lang/rust/commit/498ec5952062bac854eae7cb4e5152bb648dfe35"}], "stats": {"total": 142, "additions": 93, "deletions": 49}, "files": [{"sha": "ac5ae327e5ba1a14390563ff7f801c733c33941b", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 82, "deletions": 45, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=896a1c7fcdda7398d242ac6faace1c547349d3d6", "patch": "@@ -1112,6 +1112,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut bindings = smallvec![(false, <_>::default())];\n         for Param { pat, ty, .. } in params {\n             self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+            self.check_consistent_bindings_top(pat);\n             self.visit_ty(ty);\n             debug!(\"(resolving function / closure) recorded parameter\");\n         }\n@@ -1128,69 +1129,90 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         self.resolve_pattern_top(&local.pat, PatternSource::Let);\n     }\n \n-    // build a map from pattern identifiers to binding-info's.\n-    // this is done hygienically. This could arise for a macro\n-    // that expands into an or-pattern where one 'x' was from the\n-    // user and one 'x' came from the macro.\n+    /// build a map from pattern identifiers to binding-info's.\n+    /// this is done hygienically. This could arise for a macro\n+    /// that expands into an or-pattern where one 'x' was from the\n+    /// user and one 'x' came from the macro.\n     fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n-            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.r.partial_res_map.get(&pat.id)\n-                                                                  .map(|res| res.base_res()) {\n-                    Some(Res::Local(..)) => true,\n-                    _ => false,\n-                } {\n-                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident, binding_info);\n+            match pat.node {\n+                PatKind::Ident(binding_mode, ident, ref sub_pat)\n+                    if sub_pat.is_some() || self.is_base_res_local(pat.id) =>\n+                {\n+                    binding_map.insert(ident, BindingInfo { span: ident.span, binding_mode });\n+                }\n+                PatKind::Or(ref ps) => {\n+                    // Check the consistency of this or-pattern and\n+                    // then add all bindings to the larger map.\n+                    for bm in self.check_consistent_bindings(ps) {\n+                        binding_map.extend(bm);\n+                    }\n+                    return false;\n                 }\n+                _ => {}\n             }\n+\n             true\n         });\n \n         binding_map\n     }\n \n-    // Checks that all of the arms in an or-pattern have exactly the\n-    // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+    fn is_base_res_local(&self, nid: NodeId) -> bool {\n+        match self.r.partial_res_map.get(&nid).map(|res| res.base_res()) {\n+            Some(Res::Local(..)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Checks that all of the arms in an or-pattern have exactly the\n+    /// same set of bindings, with the same binding modes for each.\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<BindingMap> {\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n \n-        for pat_outer in pats.iter() {\n-            let map_outer = self.binding_mode_map(&pat_outer);\n-\n-            for pat_inner in pats.iter().filter(|pat| pat.id != pat_outer.id) {\n-                let map_inner = self.binding_mode_map(&pat_inner);\n-\n-                for (&key_inner, &binding_inner) in map_inner.iter() {\n-                    match map_outer.get(&key_inner) {\n-                        None => {  // missing binding\n-                            let binding_error = missing_vars\n-                                .entry(key_inner.name)\n-                                .or_insert(BindingError {\n-                                    name: key_inner.name,\n-                                    origin: BTreeSet::new(),\n-                                    target: BTreeSet::new(),\n-                                    could_be_path:\n-                                        key_inner.name.as_str().starts_with(char::is_uppercase)\n-                                });\n-                            binding_error.origin.insert(binding_inner.span);\n-                            binding_error.target.insert(pat_outer.span);\n-                        }\n-                        Some(binding_outer) => {  // check consistent binding\n-                            if binding_outer.binding_mode != binding_inner.binding_mode {\n-                                inconsistent_vars\n-                                    .entry(key_inner.name)\n-                                    .or_insert((binding_inner.span, binding_outer.span));\n-                            }\n+        // 1) Compute the binding maps of all arms.\n+        let maps = pats.iter()\n+            .map(|pat| self.binding_mode_map(pat))\n+            .collect::<Vec<_>>();\n+\n+        // 2) Record any missing bindings or binding mode inconsistencies.\n+        for (map_outer, pat_outer) in pats.iter().enumerate().map(|(idx, pat)| (&maps[idx], pat)) {\n+            // Check against all arms except for the same pattern which is always self-consistent.\n+            let inners = pats.iter().enumerate()\n+                .filter(|(_, pat)| pat.id != pat_outer.id)\n+                .flat_map(|(idx, _)| maps[idx].iter())\n+                .map(|(key, binding)| (key.name, map_outer.get(&key), binding));\n+\n+            for (name, info, &binding_inner) in inners {\n+                match info {\n+                    None => { // The inner binding is missing in the outer.\n+                        let binding_error = missing_vars\n+                            .entry(name)\n+                            .or_insert_with(|| BindingError {\n+                                name,\n+                                origin: BTreeSet::new(),\n+                                target: BTreeSet::new(),\n+                                could_be_path: name.as_str().starts_with(char::is_uppercase),\n+                            });\n+                        binding_error.origin.insert(binding_inner.span);\n+                        binding_error.target.insert(pat_outer.span);\n+                    }\n+                    Some(binding_outer) => {\n+                        if binding_outer.binding_mode != binding_inner.binding_mode {\n+                            // The binding modes in the outer and inner bindings differ.\n+                            inconsistent_vars\n+                                .entry(name)\n+                                .or_insert((binding_inner.span, binding_outer.span));\n                         }\n                     }\n                 }\n             }\n         }\n \n+        // 3) Report all missing variables we found.\n         let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n         missing_vars.sort();\n         for (name, mut v) in missing_vars {\n@@ -1202,11 +1224,26 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 ResolutionError::VariableNotBoundInPattern(v));\n         }\n \n+        // 4) Report all inconsistencies in binding modes we found.\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n             self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n+\n+        // 5) Finally bubble up all the binding maps.\n+        maps\n+    }\n+\n+    /// Check the consistency of the outermost or-patterns.\n+    fn check_consistent_bindings_top(&mut self, pat: &Pat) {\n+        pat.walk(&mut |pat| match pat.node {\n+            PatKind::Or(ref ps) => {\n+                self.check_consistent_bindings(ps);\n+                false\n+            },\n+            _ => true,\n+        })\n     }\n \n     fn resolve_arm(&mut self, arm: &Arm) {\n@@ -1227,13 +1264,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             bindings.last_mut().unwrap().1.extend(collected);\n         }\n         // This has to happen *after* we determine which pat_idents are variants\n-        if pats.len() > 1 {\n-            self.check_consistent_bindings(pats);\n-        }\n+        self.check_consistent_bindings(pats);\n     }\n \n     fn resolve_pattern_top(&mut self, pat: &Pat, pat_src: PatternSource) {\n         self.resolve_pattern(pat, pat_src, &mut smallvec![(false, <_>::default())]);\n+        // This has to happen *after* we determine which pat_idents are variants:\n+        self.check_consistent_bindings_top(pat);\n     }\n \n     fn resolve_pattern("}, {"sha": "44bd22effd322e824edd018e9a3b16623bb4f33f", "filename": "src/test/ui/or-patterns/already-bound-name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.rs?ref=896a1c7fcdda7398d242ac6faace1c547349d3d6", "patch": "@@ -38,6 +38,7 @@ fn main() {\n     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n     //~^ ERROR identifier `a` is bound more than once in the same pattern\n     //~| ERROR identifier `a` is bound more than once in the same pattern\n+    //~| ERROR variable `a` is not bound in all patterns\n \n     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n     //~^ ERROR identifier `a` is bound more than once in the same pattern"}, {"sha": "f140b36f2b66f72814c0fc26c07800fcf375d93d", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/896a1c7fcdda7398d242ac6faace1c547349d3d6/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=896a1c7fcdda7398d242ac6faace1c547349d3d6", "patch": "@@ -64,14 +64,20 @@ error[E0416]: identifier `a` is bound more than once in the same pattern\n LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                              ^ used in a pattern more than once\n \n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/already-bound-name.rs:38:9\n+   |\n+LL |     let B(_) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n+   |         ^^^^ pattern doesn't bind `a`        - variable not in all patterns\n+\n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:42:49\n+  --> $DIR/already-bound-name.rs:43:49\n    |\n LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                                 ^ used in a pattern more than once\n \n error[E0416]: identifier `a` is bound more than once in the same pattern\n-  --> $DIR/already-bound-name.rs:42:59\n+  --> $DIR/already-bound-name.rs:43:59\n    |\n LL |     let B(A(a, _) | B(a)) | A(A(a, _) | B(a), A(a, _) | B(a)) = B(B(1));\n    |                                                           ^ used in a pattern more than once\n@@ -85,7 +91,7 @@ LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n    = note: expected type `{integer}`\n               found type `E<{integer}>`\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 15 previous errors\n \n-Some errors have detailed explanations: E0308, E0416.\n+Some errors have detailed explanations: E0308, E0408, E0416.\n For more information about an error, try `rustc --explain E0308`."}]}