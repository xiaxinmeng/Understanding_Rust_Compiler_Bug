{"sha": "ba23d37b70253be905349aaeb0781eb6eba05333", "node_id": "C_kwDOAAsO6NoAKGJhMjNkMzdiNzAyNTNiZTkwNTM0OWFhZWIwNzgxZWI2ZWJhMDUzMzM", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-06-22T05:57:06Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-06-22T05:58:00Z"}, "message": "Format tests with rustfmt (288-299 of 299)", "tree": {"sha": "cb45adb81bc4b36a08ecf130e840ac6f7ff9fdb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb45adb81bc4b36a08ecf130e840ac6f7ff9fdb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba23d37b70253be905349aaeb0781eb6eba05333", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmKyr2gACgkQ+boUO5X/\nbYIOVA/8DWqKt6jF4LaDk7I5OhTcHbo/1I8g+WPsWVE1y2ooNH7ni/Ov5aLXU2Lu\nSOQZgjUOHEEh1Btf3UKD7HSvZtm9UYSPqICdJyQQiDp61W9t4NuYu79YfIZRlIQu\nckzxvym1SDONwnTCI2G2S/3c1dUtUYGpYprJIvpdqilNBCgcR34ZwU79kKIf32j+\nZ5x31qQ2efhTVvtAID1TS8H+3fvYjZ6nzqt5YHwAnpFcs/RHcscvC7F30Y9hlKQZ\n0EnJ/YdZXO/skZdnpuHyZN63D0d5wHlORUXDzvxkXugqagU49GD2j81qQMqv7raz\nmIaJ2M3snWAq/iBl/JeKxhDUwybvcPdoBrNPKomCfCYle0yl0hP26pA0Xh2I3iE8\n2xp/4O7S+KWmXU9bre2C0g/JKRWc27MtCnJAJugZ63Li1w+hMpLJwo/7Azd42qtV\nxdBjxYZNty0xd4BJqt3q8rH7mlNS3kdSzx+4DA/pYkJQhKMua4xMAQv0uV+dxzLz\nUw9XtW82z0iiCPbMmjIWy+vl2zKQlksBwqD8TGOUKjUmd3u85df5jxTaHWsy6QDT\nBI8KQkPJAeoE9CtOUMjHxpAKBnbv5JSOUHVrGiz3QJjgNf0LcSxkmFx131q9H86C\nYiLbTNBG9MKdJ5iFLQ9KbCdIe+MOUbVC6qou+fNjDE+ok0mh7mk=\n=ZxAm\n-----END PGP SIGNATURE-----", "payload": "tree cb45adb81bc4b36a08ecf130e840ac6f7ff9fdb0\nparent 7a1b08e46eb106480cbb0bc0a70521f273f045aa\nauthor David Tolnay <dtolnay@gmail.com> 1655877426 -0700\ncommitter David Tolnay <dtolnay@gmail.com> 1655877480 -0700\n\nFormat tests with rustfmt (288-299 of 299)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba23d37b70253be905349aaeb0781eb6eba05333", "html_url": "https://github.com/rust-lang/rust/commit/ba23d37b70253be905349aaeb0781eb6eba05333", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba23d37b70253be905349aaeb0781eb6eba05333/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1b08e46eb106480cbb0bc0a70521f273f045aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1b08e46eb106480cbb0bc0a70521f273f045aa", "html_url": "https://github.com/rust-lang/rust/commit/7a1b08e46eb106480cbb0bc0a70521f273f045aa"}], "stats": {"total": 432, "additions": 273, "deletions": 159}, "files": [{"sha": "39dd6f9e4c079b047db79c5beb4e8e31b91c6cc0", "filename": "tests/fail/unaligned_pointers/dyn_alignment.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Fdyn_alignment.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -6,15 +6,18 @@\n struct MuchAlign;\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n         let buf = [0u32; 256];\n         // `buf` is sufficiently aligned for `layout.align` on a `dyn Debug`, but not\n         // for the actual alignment required by `MuchAlign`.\n         // We craft a wide reference `&dyn Debug` with the vtable for `MuchAlign`. That should be UB,\n         // as the reference is not aligned to its dynamic alignment requirements.\n         let mut ptr = &MuchAlign as &dyn std::fmt::Debug;\n         // Overwrite the data part of `ptr` so it points to `buf`.\n-        unsafe { (&mut ptr as *mut _ as *mut *const u8).write(&buf as *const _ as *const u8); }\n+        unsafe {\n+            (&mut ptr as *mut _ as *mut *const u8).write(&buf as *const _ as *const u8);\n+        }\n         // Re-borrow that. This should be UB.\n         let _ptr = &*ptr; //~ERROR alignment 256 is required\n     }"}, {"sha": "74b2f308e2301b4631dc24d95b7f8b44927b626b", "filename": "tests/fail/unaligned_pointers/reference_to_packed.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Freference_to_packed.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -10,11 +10,9 @@ struct Foo {\n }\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n-        let foo = Foo {\n-            x: 42,\n-            y: 99,\n-        };\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n+        let foo = Foo { x: 42, y: 99 };\n         let p = &foo.x;\n         let i = *p; //~ERROR alignment 4 is required\n     }"}, {"sha": "445eb051ae2d14342621e99a8ecf3f9a06b1c13d", "filename": "tests/fail/unaligned_pointers/unaligned_ptr1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr1.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -2,7 +2,8 @@\n // compile-flags: -Zmiri-disable-validation -Zmiri-disable-stacked-borrows\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n         let x = [2u16, 3, 4]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const u32;\n         // This must fail because alignment is violated: the allocation's base is not sufficiently aligned."}, {"sha": "f13ae488867538a693f426c9e00525669c6a55f5", "filename": "tests/fail/unaligned_pointers/unaligned_ptr3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr3.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -2,7 +2,8 @@\n // compile-flags: -Zmiri-disable-validation -Zmiri-disable-stacked-borrows\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n         let x = [2u16, 3, 4, 5]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const *const u8; // cast to ptr-to-ptr, so that we load a ptr\n         // This must fail because alignment is violated. Test specifically for loading pointers,"}, {"sha": "18ae48b0a1e502d7dd63a6a736549e33cc8da732", "filename": "tests/fail/unaligned_pointers/unaligned_ptr4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr4.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -4,7 +4,8 @@\n fn main() {\n     // Make sure we notice when a u16 is loaded at offset 1 into a u8 allocation.\n     // (This would be missed if u8 allocations are *always* at odd addresses.)\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n         let x = [0u8; 4];\n         let ptr = x.as_ptr().wrapping_offset(1).cast::<u16>();\n         let _val = unsafe { *ptr }; //~ERROR but alignment"}, {"sha": "0604a7eb2d2b1cd650e82d705ea682690e8dfdd3", "filename": "tests/fail/unaligned_pointers/unaligned_ptr_addr_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_addr_of.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -3,7 +3,8 @@\n use std::ptr;\n \n fn main() {\n-    for _ in 0..10 { // Try many times as this might work by chance.\n+    for _ in 0..10 {\n+        // Try many times as this might work by chance.\n         let x = [2u16, 3, 4]; // Make it big enough so we don't get an out-of-bounds error.\n         let x = &x[0] as *const _ as *const u32;\n         // This must fail because alignment is violated: the allocation's base is not sufficiently aligned."}, {"sha": "983939688f1baf2bf89db646e16948369e908547", "filename": "tests/fail/unaligned_pointers/unaligned_ptr_zst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Funaligned_pointers%2Funaligned_ptr_zst.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -3,7 +3,8 @@\n // compile-flags: -Zmir-opt-level=0 -Zmiri-disable-validation\n \n fn main() {\n-    for i in 0..10 { // Try many times as this might work by chance.\n+    for i in 0..10 {\n+        // Try many times as this might work by chance.\n         let x = i as u8;\n         let x = &x as *const _ as *const [u32; 0];\n         // This must fail because alignment is violated. Test specifically for loading ZST."}, {"sha": "e8a3056f2c342ef58b59ea3bc2faa90e71946304", "filename": "tests/pass/intrinsics-integer.rs", "status": "modified", "additions": 200, "deletions": 116, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics-integer.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -13,110 +13,194 @@ use std::intrinsics::*;\n \n pub fn main() {\n     unsafe {\n-        assert_eq!(ctpop(0u8), 0); assert_eq!(ctpop(0i8), 0);\n-        assert_eq!(ctpop(0u16), 0); assert_eq!(ctpop(0i16), 0);\n-        assert_eq!(ctpop(0u32), 0); assert_eq!(ctpop(0i32), 0);\n-        assert_eq!(ctpop(0u64), 0); assert_eq!(ctpop(0i64), 0);\n-\n-        assert_eq!(ctpop(1u8), 1); assert_eq!(ctpop(1i8), 1);\n-        assert_eq!(ctpop(1u16), 1); assert_eq!(ctpop(1i16), 1);\n-        assert_eq!(ctpop(1u32), 1); assert_eq!(ctpop(1i32), 1);\n-        assert_eq!(ctpop(1u64), 1); assert_eq!(ctpop(1i64), 1);\n-\n-        assert_eq!(ctpop(10u8), 2); assert_eq!(ctpop(10i8), 2);\n-        assert_eq!(ctpop(10u16), 2); assert_eq!(ctpop(10i16), 2);\n-        assert_eq!(ctpop(10u32), 2); assert_eq!(ctpop(10i32), 2);\n-        assert_eq!(ctpop(10u64), 2); assert_eq!(ctpop(10i64), 2);\n-\n-        assert_eq!(ctpop(100u8), 3); assert_eq!(ctpop(100i8), 3);\n-        assert_eq!(ctpop(100u16), 3); assert_eq!(ctpop(100i16), 3);\n-        assert_eq!(ctpop(100u32), 3); assert_eq!(ctpop(100i32), 3);\n-        assert_eq!(ctpop(100u64), 3); assert_eq!(ctpop(100i64), 3);\n-\n-        assert_eq!(ctpop(-1i8 as u8), 8); assert_eq!(ctpop(-1i8), 8);\n-        assert_eq!(ctpop(-1i16 as u16), 16); assert_eq!(ctpop(-1i16), 16);\n-        assert_eq!(ctpop(-1i32 as u32), 32); assert_eq!(ctpop(-1i32), 32);\n-        assert_eq!(ctpop(-1i64 as u64), 64); assert_eq!(ctpop(-1i64), 64);\n-\n-        assert_eq!(ctlz(0u8), 8); assert_eq!(ctlz(0i8), 8);\n-        assert_eq!(ctlz(0u16), 16); assert_eq!(ctlz(0i16), 16);\n-        assert_eq!(ctlz(0u32), 32); assert_eq!(ctlz(0i32), 32);\n-        assert_eq!(ctlz(0u64), 64); assert_eq!(ctlz(0i64), 64);\n-\n-        assert_eq!(ctlz(1u8), 7); assert_eq!(ctlz(1i8), 7);\n-        assert_eq!(ctlz(1u16), 15); assert_eq!(ctlz(1i16), 15);\n-        assert_eq!(ctlz(1u32), 31); assert_eq!(ctlz(1i32), 31);\n-        assert_eq!(ctlz(1u64), 63); assert_eq!(ctlz(1i64), 63);\n-\n-        assert_eq!(ctlz(10u8), 4); assert_eq!(ctlz(10i8), 4);\n-        assert_eq!(ctlz(10u16), 12); assert_eq!(ctlz(10i16), 12);\n-        assert_eq!(ctlz(10u32), 28); assert_eq!(ctlz(10i32), 28);\n-        assert_eq!(ctlz(10u64), 60); assert_eq!(ctlz(10i64), 60);\n-\n-        assert_eq!(ctlz(100u8), 1); assert_eq!(ctlz(100i8), 1);\n-        assert_eq!(ctlz(100u16), 9); assert_eq!(ctlz(100i16), 9);\n-        assert_eq!(ctlz(100u32), 25); assert_eq!(ctlz(100i32), 25);\n-        assert_eq!(ctlz(100u64), 57); assert_eq!(ctlz(100i64), 57);\n-\n-        assert_eq!(ctlz_nonzero(1u8), 7); assert_eq!(ctlz_nonzero(1i8), 7);\n-        assert_eq!(ctlz_nonzero(1u16), 15); assert_eq!(ctlz_nonzero(1i16), 15);\n-        assert_eq!(ctlz_nonzero(1u32), 31); assert_eq!(ctlz_nonzero(1i32), 31);\n-        assert_eq!(ctlz_nonzero(1u64), 63); assert_eq!(ctlz_nonzero(1i64), 63);\n-\n-        assert_eq!(ctlz_nonzero(10u8), 4); assert_eq!(ctlz_nonzero(10i8), 4);\n-        assert_eq!(ctlz_nonzero(10u16), 12); assert_eq!(ctlz_nonzero(10i16), 12);\n-        assert_eq!(ctlz_nonzero(10u32), 28); assert_eq!(ctlz_nonzero(10i32), 28);\n-        assert_eq!(ctlz_nonzero(10u64), 60); assert_eq!(ctlz_nonzero(10i64), 60);\n-\n-        assert_eq!(ctlz_nonzero(100u8), 1); assert_eq!(ctlz_nonzero(100i8), 1);\n-        assert_eq!(ctlz_nonzero(100u16), 9); assert_eq!(ctlz_nonzero(100i16), 9);\n-        assert_eq!(ctlz_nonzero(100u32), 25); assert_eq!(ctlz_nonzero(100i32), 25);\n-        assert_eq!(ctlz_nonzero(100u64), 57); assert_eq!(ctlz_nonzero(100i64), 57);\n-\n-        assert_eq!(cttz(-1i8 as u8), 0); assert_eq!(cttz(-1i8), 0);\n-        assert_eq!(cttz(-1i16 as u16), 0); assert_eq!(cttz(-1i16), 0);\n-        assert_eq!(cttz(-1i32 as u32), 0); assert_eq!(cttz(-1i32), 0);\n-        assert_eq!(cttz(-1i64 as u64), 0); assert_eq!(cttz(-1i64), 0);\n-\n-        assert_eq!(cttz(0u8), 8); assert_eq!(cttz(0i8), 8);\n-        assert_eq!(cttz(0u16), 16); assert_eq!(cttz(0i16), 16);\n-        assert_eq!(cttz(0u32), 32); assert_eq!(cttz(0i32), 32);\n-        assert_eq!(cttz(0u64), 64); assert_eq!(cttz(0i64), 64);\n-\n-        assert_eq!(cttz(1u8), 0); assert_eq!(cttz(1i8), 0);\n-        assert_eq!(cttz(1u16), 0); assert_eq!(cttz(1i16), 0);\n-        assert_eq!(cttz(1u32), 0); assert_eq!(cttz(1i32), 0);\n-        assert_eq!(cttz(1u64), 0); assert_eq!(cttz(1i64), 0);\n-\n-        assert_eq!(cttz(10u8), 1); assert_eq!(cttz(10i8), 1);\n-        assert_eq!(cttz(10u16), 1); assert_eq!(cttz(10i16), 1);\n-        assert_eq!(cttz(10u32), 1); assert_eq!(cttz(10i32), 1);\n-        assert_eq!(cttz(10u64), 1); assert_eq!(cttz(10i64), 1);\n-\n-        assert_eq!(cttz(100u8), 2); assert_eq!(cttz(100i8), 2);\n-        assert_eq!(cttz(100u16), 2); assert_eq!(cttz(100i16), 2);\n-        assert_eq!(cttz(100u32), 2); assert_eq!(cttz(100i32), 2);\n-        assert_eq!(cttz(100u64), 2); assert_eq!(cttz(100i64), 2);\n-\n-        assert_eq!(cttz_nonzero(-1i8 as u8), 0); assert_eq!(cttz_nonzero(-1i8), 0);\n-        assert_eq!(cttz_nonzero(-1i16 as u16), 0); assert_eq!(cttz_nonzero(-1i16), 0);\n-        assert_eq!(cttz_nonzero(-1i32 as u32), 0); assert_eq!(cttz_nonzero(-1i32), 0);\n-        assert_eq!(cttz_nonzero(-1i64 as u64), 0); assert_eq!(cttz_nonzero(-1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(1u8), 0); assert_eq!(cttz_nonzero(1i8), 0);\n-        assert_eq!(cttz_nonzero(1u16), 0); assert_eq!(cttz_nonzero(1i16), 0);\n-        assert_eq!(cttz_nonzero(1u32), 0); assert_eq!(cttz_nonzero(1i32), 0);\n-        assert_eq!(cttz_nonzero(1u64), 0); assert_eq!(cttz_nonzero(1i64), 0);\n-\n-        assert_eq!(cttz_nonzero(10u8), 1); assert_eq!(cttz_nonzero(10i8), 1);\n-        assert_eq!(cttz_nonzero(10u16), 1); assert_eq!(cttz_nonzero(10i16), 1);\n-        assert_eq!(cttz_nonzero(10u32), 1); assert_eq!(cttz_nonzero(10i32), 1);\n-        assert_eq!(cttz_nonzero(10u64), 1); assert_eq!(cttz_nonzero(10i64), 1);\n-\n-        assert_eq!(cttz_nonzero(100u8), 2); assert_eq!(cttz_nonzero(100i8), 2);\n-        assert_eq!(cttz_nonzero(100u16), 2); assert_eq!(cttz_nonzero(100i16), 2);\n-        assert_eq!(cttz_nonzero(100u32), 2); assert_eq!(cttz_nonzero(100i32), 2);\n-        assert_eq!(cttz_nonzero(100u64), 2); assert_eq!(cttz_nonzero(100i64), 2);\n+        assert_eq!(ctpop(0u8), 0);\n+        assert_eq!(ctpop(0i8), 0);\n+        assert_eq!(ctpop(0u16), 0);\n+        assert_eq!(ctpop(0i16), 0);\n+        assert_eq!(ctpop(0u32), 0);\n+        assert_eq!(ctpop(0i32), 0);\n+        assert_eq!(ctpop(0u64), 0);\n+        assert_eq!(ctpop(0i64), 0);\n+\n+        assert_eq!(ctpop(1u8), 1);\n+        assert_eq!(ctpop(1i8), 1);\n+        assert_eq!(ctpop(1u16), 1);\n+        assert_eq!(ctpop(1i16), 1);\n+        assert_eq!(ctpop(1u32), 1);\n+        assert_eq!(ctpop(1i32), 1);\n+        assert_eq!(ctpop(1u64), 1);\n+        assert_eq!(ctpop(1i64), 1);\n+\n+        assert_eq!(ctpop(10u8), 2);\n+        assert_eq!(ctpop(10i8), 2);\n+        assert_eq!(ctpop(10u16), 2);\n+        assert_eq!(ctpop(10i16), 2);\n+        assert_eq!(ctpop(10u32), 2);\n+        assert_eq!(ctpop(10i32), 2);\n+        assert_eq!(ctpop(10u64), 2);\n+        assert_eq!(ctpop(10i64), 2);\n+\n+        assert_eq!(ctpop(100u8), 3);\n+        assert_eq!(ctpop(100i8), 3);\n+        assert_eq!(ctpop(100u16), 3);\n+        assert_eq!(ctpop(100i16), 3);\n+        assert_eq!(ctpop(100u32), 3);\n+        assert_eq!(ctpop(100i32), 3);\n+        assert_eq!(ctpop(100u64), 3);\n+        assert_eq!(ctpop(100i64), 3);\n+\n+        assert_eq!(ctpop(-1i8 as u8), 8);\n+        assert_eq!(ctpop(-1i8), 8);\n+        assert_eq!(ctpop(-1i16 as u16), 16);\n+        assert_eq!(ctpop(-1i16), 16);\n+        assert_eq!(ctpop(-1i32 as u32), 32);\n+        assert_eq!(ctpop(-1i32), 32);\n+        assert_eq!(ctpop(-1i64 as u64), 64);\n+        assert_eq!(ctpop(-1i64), 64);\n+\n+        assert_eq!(ctlz(0u8), 8);\n+        assert_eq!(ctlz(0i8), 8);\n+        assert_eq!(ctlz(0u16), 16);\n+        assert_eq!(ctlz(0i16), 16);\n+        assert_eq!(ctlz(0u32), 32);\n+        assert_eq!(ctlz(0i32), 32);\n+        assert_eq!(ctlz(0u64), 64);\n+        assert_eq!(ctlz(0i64), 64);\n+\n+        assert_eq!(ctlz(1u8), 7);\n+        assert_eq!(ctlz(1i8), 7);\n+        assert_eq!(ctlz(1u16), 15);\n+        assert_eq!(ctlz(1i16), 15);\n+        assert_eq!(ctlz(1u32), 31);\n+        assert_eq!(ctlz(1i32), 31);\n+        assert_eq!(ctlz(1u64), 63);\n+        assert_eq!(ctlz(1i64), 63);\n+\n+        assert_eq!(ctlz(10u8), 4);\n+        assert_eq!(ctlz(10i8), 4);\n+        assert_eq!(ctlz(10u16), 12);\n+        assert_eq!(ctlz(10i16), 12);\n+        assert_eq!(ctlz(10u32), 28);\n+        assert_eq!(ctlz(10i32), 28);\n+        assert_eq!(ctlz(10u64), 60);\n+        assert_eq!(ctlz(10i64), 60);\n+\n+        assert_eq!(ctlz(100u8), 1);\n+        assert_eq!(ctlz(100i8), 1);\n+        assert_eq!(ctlz(100u16), 9);\n+        assert_eq!(ctlz(100i16), 9);\n+        assert_eq!(ctlz(100u32), 25);\n+        assert_eq!(ctlz(100i32), 25);\n+        assert_eq!(ctlz(100u64), 57);\n+        assert_eq!(ctlz(100i64), 57);\n+\n+        assert_eq!(ctlz_nonzero(1u8), 7);\n+        assert_eq!(ctlz_nonzero(1i8), 7);\n+        assert_eq!(ctlz_nonzero(1u16), 15);\n+        assert_eq!(ctlz_nonzero(1i16), 15);\n+        assert_eq!(ctlz_nonzero(1u32), 31);\n+        assert_eq!(ctlz_nonzero(1i32), 31);\n+        assert_eq!(ctlz_nonzero(1u64), 63);\n+        assert_eq!(ctlz_nonzero(1i64), 63);\n+\n+        assert_eq!(ctlz_nonzero(10u8), 4);\n+        assert_eq!(ctlz_nonzero(10i8), 4);\n+        assert_eq!(ctlz_nonzero(10u16), 12);\n+        assert_eq!(ctlz_nonzero(10i16), 12);\n+        assert_eq!(ctlz_nonzero(10u32), 28);\n+        assert_eq!(ctlz_nonzero(10i32), 28);\n+        assert_eq!(ctlz_nonzero(10u64), 60);\n+        assert_eq!(ctlz_nonzero(10i64), 60);\n+\n+        assert_eq!(ctlz_nonzero(100u8), 1);\n+        assert_eq!(ctlz_nonzero(100i8), 1);\n+        assert_eq!(ctlz_nonzero(100u16), 9);\n+        assert_eq!(ctlz_nonzero(100i16), 9);\n+        assert_eq!(ctlz_nonzero(100u32), 25);\n+        assert_eq!(ctlz_nonzero(100i32), 25);\n+        assert_eq!(ctlz_nonzero(100u64), 57);\n+        assert_eq!(ctlz_nonzero(100i64), 57);\n+\n+        assert_eq!(cttz(-1i8 as u8), 0);\n+        assert_eq!(cttz(-1i8), 0);\n+        assert_eq!(cttz(-1i16 as u16), 0);\n+        assert_eq!(cttz(-1i16), 0);\n+        assert_eq!(cttz(-1i32 as u32), 0);\n+        assert_eq!(cttz(-1i32), 0);\n+        assert_eq!(cttz(-1i64 as u64), 0);\n+        assert_eq!(cttz(-1i64), 0);\n+\n+        assert_eq!(cttz(0u8), 8);\n+        assert_eq!(cttz(0i8), 8);\n+        assert_eq!(cttz(0u16), 16);\n+        assert_eq!(cttz(0i16), 16);\n+        assert_eq!(cttz(0u32), 32);\n+        assert_eq!(cttz(0i32), 32);\n+        assert_eq!(cttz(0u64), 64);\n+        assert_eq!(cttz(0i64), 64);\n+\n+        assert_eq!(cttz(1u8), 0);\n+        assert_eq!(cttz(1i8), 0);\n+        assert_eq!(cttz(1u16), 0);\n+        assert_eq!(cttz(1i16), 0);\n+        assert_eq!(cttz(1u32), 0);\n+        assert_eq!(cttz(1i32), 0);\n+        assert_eq!(cttz(1u64), 0);\n+        assert_eq!(cttz(1i64), 0);\n+\n+        assert_eq!(cttz(10u8), 1);\n+        assert_eq!(cttz(10i8), 1);\n+        assert_eq!(cttz(10u16), 1);\n+        assert_eq!(cttz(10i16), 1);\n+        assert_eq!(cttz(10u32), 1);\n+        assert_eq!(cttz(10i32), 1);\n+        assert_eq!(cttz(10u64), 1);\n+        assert_eq!(cttz(10i64), 1);\n+\n+        assert_eq!(cttz(100u8), 2);\n+        assert_eq!(cttz(100i8), 2);\n+        assert_eq!(cttz(100u16), 2);\n+        assert_eq!(cttz(100i16), 2);\n+        assert_eq!(cttz(100u32), 2);\n+        assert_eq!(cttz(100i32), 2);\n+        assert_eq!(cttz(100u64), 2);\n+        assert_eq!(cttz(100i64), 2);\n+\n+        assert_eq!(cttz_nonzero(-1i8 as u8), 0);\n+        assert_eq!(cttz_nonzero(-1i8), 0);\n+        assert_eq!(cttz_nonzero(-1i16 as u16), 0);\n+        assert_eq!(cttz_nonzero(-1i16), 0);\n+        assert_eq!(cttz_nonzero(-1i32 as u32), 0);\n+        assert_eq!(cttz_nonzero(-1i32), 0);\n+        assert_eq!(cttz_nonzero(-1i64 as u64), 0);\n+        assert_eq!(cttz_nonzero(-1i64), 0);\n+\n+        assert_eq!(cttz_nonzero(1u8), 0);\n+        assert_eq!(cttz_nonzero(1i8), 0);\n+        assert_eq!(cttz_nonzero(1u16), 0);\n+        assert_eq!(cttz_nonzero(1i16), 0);\n+        assert_eq!(cttz_nonzero(1u32), 0);\n+        assert_eq!(cttz_nonzero(1i32), 0);\n+        assert_eq!(cttz_nonzero(1u64), 0);\n+        assert_eq!(cttz_nonzero(1i64), 0);\n+\n+        assert_eq!(cttz_nonzero(10u8), 1);\n+        assert_eq!(cttz_nonzero(10i8), 1);\n+        assert_eq!(cttz_nonzero(10u16), 1);\n+        assert_eq!(cttz_nonzero(10i16), 1);\n+        assert_eq!(cttz_nonzero(10u32), 1);\n+        assert_eq!(cttz_nonzero(10i32), 1);\n+        assert_eq!(cttz_nonzero(10u64), 1);\n+        assert_eq!(cttz_nonzero(10i64), 1);\n+\n+        assert_eq!(cttz_nonzero(100u8), 2);\n+        assert_eq!(cttz_nonzero(100i8), 2);\n+        assert_eq!(cttz_nonzero(100u16), 2);\n+        assert_eq!(cttz_nonzero(100i16), 2);\n+        assert_eq!(cttz_nonzero(100u32), 2);\n+        assert_eq!(cttz_nonzero(100i32), 2);\n+        assert_eq!(cttz_nonzero(100u64), 2);\n+        assert_eq!(cttz_nonzero(100i64), 2);\n \n         assert_eq!(bswap(0x0Au8), 0x0A); // no-op\n         assert_eq!(bswap(0x0Ai8), 0x0A); // no-op\n@@ -127,20 +211,20 @@ pub fn main() {\n         assert_eq!(bswap(0x0122334455667708u64), 0x0877665544332201);\n         assert_eq!(bswap(0x0122334455667708i64), 0x0877665544332201);\n \n-        assert_eq!(exact_div(9*9u32, 3), 27);\n-        assert_eq!(exact_div(-9*9i32, 3), -27);\n-        assert_eq!(exact_div(9*9i8, -3), -27);\n-        assert_eq!(exact_div(-9*9i64, -3), 27);\n+        assert_eq!(exact_div(9 * 9u32, 3), 27);\n+        assert_eq!(exact_div(-9 * 9i32, 3), -27);\n+        assert_eq!(exact_div(9 * 9i8, -3), -27);\n+        assert_eq!(exact_div(-9 * 9i64, -3), 27);\n \n-        assert_eq!(unchecked_div(9*9u32, 2), 40);\n-        assert_eq!(unchecked_div(-9*9i32, 2), -40);\n-        assert_eq!(unchecked_div(9*9i8, -2), -40);\n-        assert_eq!(unchecked_div(-9*9i64, -2), 40);\n+        assert_eq!(unchecked_div(9 * 9u32, 2), 40);\n+        assert_eq!(unchecked_div(-9 * 9i32, 2), -40);\n+        assert_eq!(unchecked_div(9 * 9i8, -2), -40);\n+        assert_eq!(unchecked_div(-9 * 9i64, -2), 40);\n \n-        assert_eq!(unchecked_rem(9*9u32, 2), 1);\n-        assert_eq!(unchecked_rem(-9*9i32, 2), -1);\n-        assert_eq!(unchecked_rem(9*9i8, -2), 1);\n-        assert_eq!(unchecked_rem(-9*9i64, -2), -1);\n+        assert_eq!(unchecked_rem(9 * 9u32, 2), 1);\n+        assert_eq!(unchecked_rem(-9 * 9i32, 2), -1);\n+        assert_eq!(unchecked_rem(9 * 9i8, -2), 1);\n+        assert_eq!(unchecked_rem(-9 * 9i64, -2), -1);\n \n         assert_eq!(unchecked_add(23u8, 19), 42);\n         assert_eq!(unchecked_add(5, -10), -5);"}, {"sha": "2fb00391cd79527bd69f0b169eedbac2775b578a", "filename": "tests/pass/panic/catch_panic.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fpanic%2Fcatch_panic.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -3,8 +3,8 @@\n #![feature(never_type)]\n #![allow(unconditional_panic, non_fmt_panics)]\n \n-use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::cell::Cell;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n \n thread_local! {\n     static MY_COUNTER: Cell<usize> = Cell::new(0);\n@@ -59,23 +59,29 @@ fn main() {\n     test(None, |old_val| core::panic!(\"Hello from panic: {:?}\", old_val));\n \n     // Built-in panics; also make sure the message is right.\n-    test(\n-        Some(\"index out of bounds: the len is 3 but the index is 4\"),\n-        |_old_val| { let _val = [0, 1, 2][4]; loop {} },\n-    );\n-    test(\n-        Some(\"attempt to divide by zero\"),\n-        |_old_val| { let _val = 1/0; loop {} },\n-    );\n-\n-    test(\n-        Some(\"align_offset: align is not a power-of-two\"),\n-        |_old_val| { (0usize as *const u8).align_offset(3); loop {} },\n-    );\n+    test(Some(\"index out of bounds: the len is 3 but the index is 4\"), |_old_val| {\n+        let _val = [0, 1, 2][4];\n+        loop {}\n+    });\n+    test(Some(\"attempt to divide by zero\"), |_old_val| {\n+        let _val = 1 / 0;\n+        loop {}\n+    });\n+\n+    test(Some(\"align_offset: align is not a power-of-two\"), |_old_val| {\n+        (0usize as *const u8).align_offset(3);\n+        loop {}\n+    });\n \n     // Assertion and debug assertion\n-    test(None, |_old_val| { assert!(false); loop {} });\n-    test(None, |_old_val| { debug_assert!(false); loop {} });\n+    test(None, |_old_val| {\n+        assert!(false);\n+        loop {}\n+    });\n+    test(None, |_old_val| {\n+        debug_assert!(false);\n+        loop {}\n+    });\n \n     eprintln!(\"Success!\"); // Make sure we get this in stderr\n }\n@@ -89,7 +95,8 @@ fn test(expect_msg: Option<&str>, do_panic: impl FnOnce(usize) -> !) {\n     let res = catch_unwind(AssertUnwindSafe(|| {\n         let _string = \"LEAKED FROM CLOSURE\".to_string();\n         do_panic_counter(do_panic)\n-    })).expect_err(\"do_panic() did not panic!\");\n+    }))\n+    .expect_err(\"do_panic() did not panic!\");\n \n     // See if we can extract the panic message.\n     let msg = if let Some(s) = res.downcast_ref::<String>() {"}, {"sha": "aa60fd0c81efda7d337b570b1713fd98ef72f042", "filename": "tests/pass/ptr_int_casts.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fptr_int_casts.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -5,20 +5,23 @@ fn eq_ref<T>(x: &T, y: &T) -> bool {\n     x as *const _ == y as *const _\n }\n \n-fn f() -> i32 { 42 }\n+fn f() -> i32 {\n+    42\n+}\n \n fn ptr_int_casts() {\n     // int-ptr-int\n     assert_eq!(1 as *const i32 as usize, 1);\n-    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4*4);\n+    assert_eq!((1 as *const i32).wrapping_offset(4) as usize, 1 + 4 * 4);\n \n     // negative overflowing wrapping_offset (going through memory because\n     // this used to trigger an ICE on 32bit)\n     let val = &mut ptr::null();\n     *val = (1 as *const u8).wrapping_offset(-4);\n     assert_eq!(*val as usize, usize::MAX - 2);\n \n-    {   // ptr-int-ptr\n+    {\n+        // ptr-int-ptr\n         let x = 13;\n         let mut y = &x as &_ as *const _ as usize;\n         y += 13;\n@@ -27,13 +30,14 @@ fn ptr_int_casts() {\n         assert!(eq_ref(&x, unsafe { &*y }));\n     }\n \n-    {   // fnptr-int-fnptr\n-        let x : fn() -> i32 = f;\n-        let y : *mut u8 = unsafe { mem::transmute(x as fn() -> i32) };\n+    {\n+        // fnptr-int-fnptr\n+        let x: fn() -> i32 = f;\n+        let y: *mut u8 = unsafe { mem::transmute(x as fn() -> i32) };\n         let mut y = y as usize;\n         y += 13;\n         y -= 13;\n-        let x : fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n+        let x: fn() -> i32 = unsafe { mem::transmute(y as *mut u8) };\n         assert_eq!(x(), 42);\n     }\n \n@@ -51,13 +55,13 @@ fn ptr_int_ops() {\n     // bit-operations, covered by alignment\n     assert_eq!(x & 1, 0);\n     assert_eq!(x & 0, 0);\n-    assert_eq!(1 & (x+1), 1);\n+    assert_eq!(1 & (x + 1), 1);\n     let _y = !1 & x;\n     let _y = !0 & x;\n     let _y = x & !1;\n     // remainder, covered by alignment\n     assert_eq!(x % 2, 0);\n-    assert_eq!((x+1) % 2, 1);\n+    assert_eq!((x + 1) % 2, 1);\n     // remainder with 1 is always 0\n     assert_eq!(x % 1, 0);\n }"}, {"sha": "c91ac36ed6b41eab29e58d4db264338cf0284a43", "filename": "tests/pass/regions-lifetime-nonfree-late-bound.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fregions-lifetime-nonfree-late-bound.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -16,15 +16,23 @@\n \n pub fn main() {\n     fn explicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn for<'a> FnMut(&'a isize)>) {}\n+        fn test<F>(_x: Option<Box<F>>)\n+        where\n+            F: FnMut(Box<dyn for<'a> FnMut(&'a isize)>),\n+        {\n+        }\n         test(Some(box |_f: Box<dyn for<'a> FnMut(&'a isize)>| {}));\n     }\n \n     // The code below is shorthand for the code above (and more likely\n     // to represent what one encounters in practice).\n     fn implicit() {\n-        fn test<F>(_x: Option<Box<F>>) where F: FnMut(Box<dyn         FnMut(&   isize)>) {}\n-        test(Some(box |_f: Box<dyn         FnMut(&   isize)>| {}));\n+        fn test<F>(_x: Option<Box<F>>)\n+        where\n+            F: FnMut(Box<dyn FnMut(&isize)>),\n+        {\n+        }\n+        test(Some(box |_f: Box<dyn FnMut(&isize)>| {}));\n     }\n \n     explicit();"}, {"sha": "84ff96942002b0ab49f9f81ce3e71eb110e9e1d7", "filename": "tests/pass/sums.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23d37b70253be905349aaeb0781eb6eba05333/tests%2Fpass%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fsums.rs?ref=ba23d37b70253be905349aaeb0781eb6eba05333", "patch": "@@ -1,12 +1,17 @@\n #[derive(Debug, PartialEq)]\n-enum Unit { Unit(()) } // Force non-C-enum representation.\n+enum Unit {\n+    Unit(()),\n+} // Force non-C-enum representation.\n \n fn return_unit() -> Unit {\n     Unit::Unit(())\n }\n \n #[derive(Debug, PartialEq)]\n-enum MyBool { False(()), True(()) } // Force non-C-enum representation.\n+enum MyBool {\n+    False(()),\n+    True(()),\n+} // Force non-C-enum representation.\n \n fn return_true() -> MyBool {\n     MyBool::True(())"}]}