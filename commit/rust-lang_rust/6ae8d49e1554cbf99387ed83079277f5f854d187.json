{"sha": "6ae8d49e1554cbf99387ed83079277f5f854d187", "node_id": "C_kwDOAAsO6NoAKDZhZThkNDllMTU1NGNiZjk5Mzg3ZWQ4MzA3OTI3N2Y1Zjg1NGQxODc", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-16T13:46:12Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-16T13:46:12Z"}, "message": "Simplify eager macro error handling", "tree": {"sha": "bb1a21e85ddc2b32493da5aa3e795a57cd8dfcae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb1a21e85ddc2b32493da5aa3e795a57cd8dfcae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ae8d49e1554cbf99387ed83079277f5f854d187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ae8d49e1554cbf99387ed83079277f5f854d187", "html_url": "https://github.com/rust-lang/rust/commit/6ae8d49e1554cbf99387ed83079277f5f854d187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ae8d49e1554cbf99387ed83079277f5f854d187/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5558cdfe50dc105d31c93edb6848a07005e7d85", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5558cdfe50dc105d31c93edb6848a07005e7d85", "html_url": "https://github.com/rust-lang/rust/commit/a5558cdfe50dc105d31c93edb6848a07005e7d85"}], "stats": {"total": 331, "additions": 120, "deletions": 211}, "files": [{"sha": "f4304ae7e8a9f98ab010f52580ce0898a616b53b", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -138,6 +138,7 @@ impl Expander {\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n+        // FIXME: within_limit should support this, instead of us having to extract the error\n         let mut unresolved_macro_err = None;\n \n         let result = self.within_limit(db, |this| {\n@@ -146,22 +147,13 @@ impl Expander {\n             let resolver =\n                 |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n \n-            let mut err = None;\n-            let call_id = match macro_call.as_call_id_with_errors(\n-                db,\n-                this.def_map.krate(),\n-                resolver,\n-                &mut |e| {\n-                    err.get_or_insert(e);\n-                },\n-            ) {\n+            match macro_call.as_call_id_with_errors(db, this.def_map.krate(), resolver) {\n                 Ok(call_id) => call_id,\n                 Err(resolve_err) => {\n                     unresolved_macro_err = Some(resolve_err);\n-                    return ExpandResult { value: None, err: None };\n+                    ExpandResult { value: None, err: None }\n                 }\n-            };\n-            ExpandResult { value: call_id.ok(), err }\n+            }\n         });\n \n         if let Some(err) = unresolved_macro_err {"}, {"sha": "55e1e91220fbdb78cf4eca9017116d20a58f74fa", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -65,11 +65,11 @@ use hir_expand::{\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n-    eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n+    eager::expand_eager_macro,\n     hygiene::Hygiene,\n     proc_macro::ProcMacroExpander,\n-    AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n-    MacroDefKind, UnresolvedMacro,\n+    AstId, ExpandError, ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind,\n+    MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n use item_tree::ExternBlock;\n use la_arena::Idx;\n@@ -795,16 +795,15 @@ pub trait AsMacroCall {\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n-        self.as_call_id_with_errors(db, krate, resolver, &mut |_| ()).ok()?.ok()\n+        self.as_call_id_with_errors(db, krate, resolver).ok()?.value\n     }\n \n     fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro>;\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n@@ -813,21 +812,15 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        mut error_sink: &mut dyn FnMut(ExpandError),\n-    ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+    ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n         let path =\n             self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n \n-        let path = match error_sink\n-            .option(path, || ExpandError::Other(\"malformed macro invocation\".into()))\n-        {\n-            Ok(path) => path,\n-            Err(error) => {\n-                return Ok(Err(error));\n-            }\n+        let Some(path) = path else {\n+            return Ok(ExpandResult::only_err(ExpandError::Other(\"malformed macro invocation\".into())));\n         };\n \n         macro_call_as_call_id(\n@@ -836,7 +829,6 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n             expands_to,\n             krate,\n             resolver,\n-            error_sink,\n         )\n     }\n }\n@@ -860,21 +852,23 @@ fn macro_call_as_call_id(\n     expand_to: ExpandTo,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-    error_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n     let def =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n         let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n \n-        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver, error_sink)?\n+        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver)?\n     } else {\n-        Ok(def.as_lazy_macro(\n-            db.upcast(),\n-            krate,\n-            MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n-        ))\n+        ExpandResult {\n+            value: Some(def.as_lazy_macro(\n+                db.upcast(),\n+                krate,\n+                MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n+            )),\n+            err: None,\n+        }\n     };\n     Ok(res)\n }"}, {"sha": "73a495d89bfde59c6d069d69448c25d667028aaf", "filename": "crates/hir-def/src/macro_expansion_tests/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmod.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -125,21 +125,15 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n \n     for macro_call in source_file.syntax().descendants().filter_map(ast::MacroCall::cast) {\n         let macro_call = InFile::new(source.file_id, &macro_call);\n-        let mut error = None;\n-        let macro_call_id = macro_call\n-            .as_call_id_with_errors(\n-                &db,\n-                krate,\n-                |path| {\n-                    resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n-                },\n-                &mut |err| error = Some(err),\n-            )\n-            .unwrap()\n+        let res = macro_call\n+            .as_call_id_with_errors(&db, krate, |path| {\n+                resolver.resolve_path_as_macro(&db, &path).map(|it| macro_id_to_def_id(&db, it))\n+            })\n             .unwrap();\n+        let macro_call_id = res.value.unwrap();\n         let macro_file = MacroFile { macro_call_id };\n         let mut expansion_result = db.parse_macro_expansion(macro_file);\n-        expansion_result.err = expansion_result.err.or(error);\n+        expansion_result.err = expansion_result.err.or(res.err);\n         expansions.push((macro_call.value.clone(), expansion_result, db.macro_arg(macro_call_id)));\n     }\n "}, {"sha": "8ab0b3dbd14575f17ec93c7157a824907744c5ab", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -16,8 +16,8 @@ use hir_expand::{\n     builtin_fn_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n-    MacroDefKind,\n+    ExpandResult, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroCallLoc,\n+    MacroDefId, MacroDefKind,\n };\n use itertools::{izip, Itertools};\n use la_arena::Idx;\n@@ -1116,9 +1116,8 @@ impl DefCollector<'_> {\n                         *expand_to,\n                         self.def_map.krate,\n                         resolver_def_id,\n-                        &mut |_err| (),\n                     );\n-                    if let Ok(Ok(call_id)) = call_id {\n+                    if let Ok(ExpandResult { value: Some(call_id), .. }) = call_id {\n                         push_resolved(directive, call_id);\n                         res = ReachedFixedPoint::No;\n                         return false;\n@@ -1414,7 +1413,6 @@ impl DefCollector<'_> {\n                                 .take_macros()\n                                 .map(|it| macro_id_to_def_id(self.db, it))\n                         },\n-                        &mut |_| (),\n                     );\n                     if let Err(UnresolvedMacro { path }) = macro_call_as_call_id {\n                         self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n@@ -2112,7 +2110,6 @@ impl ModCollector<'_, '_> {\n         let ast_id = AstIdWithPath::new(self.file_id(), mac.ast_id, ModPath::clone(&mac.path));\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n-        let mut error = None;\n         match macro_call_as_call_id(\n             self.def_collector.db,\n             &ast_id,\n@@ -2133,21 +2130,20 @@ impl ModCollector<'_, '_> {\n                     )\n                 })\n             },\n-            &mut |err| {\n-                error.get_or_insert(err);\n-            },\n         ) {\n-            Ok(Ok(macro_call_id)) => {\n+            Ok(res) => {\n                 // Legacy macros need to be expanded immediately, so that any macros they produce\n                 // are in scope.\n-                self.def_collector.collect_macro_expansion(\n-                    self.module_id,\n-                    macro_call_id,\n-                    self.macro_depth + 1,\n-                    container,\n-                );\n+                if let Some(val) = res.value {\n+                    self.def_collector.collect_macro_expansion(\n+                        self.module_id,\n+                        val,\n+                        self.macro_depth + 1,\n+                        container,\n+                    );\n+                }\n \n-                if let Some(err) = error {\n+                if let Some(err) = res.err {\n                     self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n                         self.module_id,\n                         MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n@@ -2157,16 +2153,6 @@ impl ModCollector<'_, '_> {\n \n                 return;\n             }\n-            Ok(Err(_)) => {\n-                // Built-in macro failed eager expansion.\n-\n-                self.def_collector.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                    self.module_id,\n-                    MacroCallKind::FnLike { ast_id: ast_id.ast_id, expand_to: mac.expand_to },\n-                    error.unwrap().to_string(),\n-                ));\n-                return;\n-            }\n             Err(UnresolvedMacro { .. }) => (),\n         }\n "}, {"sha": "d7aff6b02f40fe322389fe342ea60621f76da9db", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -279,25 +279,28 @@ fn parse_macro_expansion(\n     let mbe::ValueResult { value, err } = db.macro_expand(macro_file.macro_call_id);\n \n     if let Some(err) = &err {\n-        // Note:\n-        // The final goal we would like to make all parse_macro success,\n-        // such that the following log will not call anyway.\n-        let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-        let node = loc.kind.to_node(db);\n-\n-        // collect parent information for warning log\n-        let parents =\n-            std::iter::successors(loc.kind.file_id().call_node(db), |it| it.file_id.call_node(db))\n-                .map(|n| format!(\"{:#}\", n.value))\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\");\n-\n-        tracing::debug!(\n-            \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n-            err,\n-            node.value,\n-            parents\n-        );\n+        if tracing::enabled!(tracing::Level::DEBUG) {\n+            // Note:\n+            // The final goal we would like to make all parse_macro success,\n+            // such that the following log will not call anyway.\n+            let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+            let node = loc.kind.to_node(db);\n+\n+            // collect parent information for warning log\n+            let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n+                it.file_id.call_node(db)\n+            })\n+            .map(|n| format!(\"{:#}\", n.value))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+\n+            tracing::debug!(\n+                \"fail on macro_parse: (reason: {:?} macro_call: {:#}) parents: {}\",\n+                err,\n+                node.value,\n+                parents\n+            );\n+        }\n     }\n     let tt = match value {\n         Some(tt) => tt,\n@@ -466,7 +469,8 @@ fn macro_expand(\n         Ok(it) => it,\n         // FIXME: This is weird -- we effectively report macro *definition*\n         // errors lazily, when we try to expand the macro. Instead, they should\n-        // be reported at the definition site (when we construct a def map).\n+        // be reported at the definition site when we construct a def map.\n+        // (Note we do report them also at the definition site in the late diagnostic pass)\n         Err(err) => {\n             return ExpandResult::only_err(ExpandError::Other(\n                 format!(\"invalid macro definition: {err}\").into(),"}, {"sha": "74adced8c6818a52d709e108d01ce8d8be53f0a6", "filename": "crates/hir-expand/src/eager.rs", "status": "modified", "additions": 55, "deletions": 116, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ae8d49e1554cbf99387ed83079277f5f854d187/crates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Feager.rs?ref=6ae8d49e1554cbf99387ed83079277f5f854d187", "patch": "@@ -32,77 +32,16 @@ use crate::{\n     MacroCallLoc, MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n \n-#[derive(Debug)]\n-pub struct ErrorEmitted {\n-    _private: (),\n-}\n-\n-pub trait ErrorSink {\n-    fn emit(&mut self, err: ExpandError);\n-\n-    fn option<T>(\n-        &mut self,\n-        opt: Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        match opt {\n-            Some(it) => Ok(it),\n-            None => {\n-                self.emit(error());\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn option_with<T>(\n-        &mut self,\n-        opt: impl FnOnce() -> Option<T>,\n-        error: impl FnOnce() -> ExpandError,\n-    ) -> Result<T, ErrorEmitted> {\n-        self.option(opt(), error)\n-    }\n-\n-    fn result<T>(&mut self, res: Result<T, ExpandError>) -> Result<T, ErrorEmitted> {\n-        match res {\n-            Ok(it) => Ok(it),\n-            Err(e) => {\n-                self.emit(e);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-        }\n-    }\n-\n-    fn expand_result_option<T>(&mut self, res: ExpandResult<Option<T>>) -> Result<T, ErrorEmitted> {\n-        match (res.value, res.err) {\n-            (None, Some(err)) => {\n-                self.emit(err);\n-                Err(ErrorEmitted { _private: () })\n-            }\n-            (Some(value), opt_err) => {\n-                if let Some(err) = opt_err {\n-                    self.emit(err);\n-                }\n-                Ok(value)\n-            }\n-            (None, None) => unreachable!(\"`ExpandResult` without value or error\"),\n-        }\n-    }\n-}\n-\n-impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n-    fn emit(&mut self, err: ExpandError) {\n-        self(err);\n-    }\n-}\n-\n pub fn expand_eager_macro(\n     db: &dyn ExpandDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n+    let MacroDefKind::BuiltInEager(eager, _) = def.kind else {\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\")\n+    };\n     let hygiene = Hygiene::new(db, macro_call.file_id);\n     let parsed_args = macro_call\n         .value\n@@ -129,40 +68,34 @@ pub fn expand_eager_macro(\n     });\n \n     let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, mbe::TopEntryPoint::Expr).0;\n-    let result = match eager_macro_recur(\n+    let ExpandResult { value, mut err } = eager_macro_recur(\n         db,\n         &hygiene,\n         InFile::new(arg_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n-        diagnostic_sink,\n-    ) {\n-        Ok(Ok(it)) => it,\n-        Ok(Err(err)) => return Ok(Err(err)),\n-        Err(err) => return Err(err),\n+    )?;\n+    let Some(value ) = value else {\n+        return Ok(ExpandResult { value: None, err })\n     };\n-    let subtree = to_subtree(&result);\n+    let subtree = to_subtree(&value);\n \n-    if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n-        let res = eager.expand(db, arg_id, &subtree);\n-        if let Some(err) = res.err {\n-            diagnostic_sink(err);\n-        }\n+    let res = eager.expand(db, arg_id, &subtree);\n+    if err.is_none() {\n+        err = res.err;\n+    }\n \n-        let loc = MacroCallLoc {\n-            def,\n-            krate,\n-            eager: Some(EagerCallInfo {\n-                arg_or_expansion: Arc::new(res.value.subtree),\n-                included_file: res.value.included_file,\n-            }),\n-            kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n-        };\n+    let loc = MacroCallLoc {\n+        def,\n+        krate,\n+        eager: Some(EagerCallInfo {\n+            arg_or_expansion: Arc::new(res.value.subtree),\n+            included_file: res.value.included_file,\n+        }),\n+        kind: MacroCallKind::FnLike { ast_id: call_id, expand_to },\n+    };\n \n-        Ok(Ok(db.intern_macro_call(loc)))\n-    } else {\n-        panic!(\"called `expand_eager_macro` on non-eager macro def {def:?}\");\n-    }\n+    Ok(ExpandResult { value: Some(db.intern_macro_call(loc)), err })\n }\n \n fn to_subtree(node: &SyntaxNode) -> crate::tt::Subtree {\n@@ -201,69 +134,75 @@ fn eager_macro_recur(\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    mut diagnostic_sink: &mut dyn FnMut(ExpandError),\n-) -> Result<Result<SyntaxNode, ErrorEmitted>, UnresolvedMacro> {\n+) -> Result<ExpandResult<Option<SyntaxNode>>, UnresolvedMacro> {\n     let original = curr.value.clone_for_update();\n \n     let children = original.descendants().filter_map(ast::MacroCall::cast);\n     let mut replacements = Vec::new();\n \n+    // Note: We only report a single error inside of eager expansions\n+    let mut error = None;\n+\n     // Collect replacement\n     for child in children {\n         let def = match child.path().and_then(|path| ModPath::from_src(db, path, hygiene)) {\n             Some(path) => macro_resolver(path.clone()).ok_or(UnresolvedMacro { path })?,\n             None => {\n-                diagnostic_sink(ExpandError::Other(\"malformed macro invocation\".into()));\n+                error = Some(ExpandError::Other(\"malformed macro invocation\".into()));\n                 continue;\n             }\n         };\n-        let insert = match def.kind {\n+        let ExpandResult { value, err } = match def.kind {\n             MacroDefKind::BuiltInEager(..) => {\n                 let id = match expand_eager_macro(\n                     db,\n                     krate,\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n-                    diagnostic_sink,\n                 ) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n+                    Ok(it) => it,\n                     Err(err) => return Err(err),\n                 };\n-                db.parse_or_expand(id.as_file())\n-                    .expect(\"successful macro expansion should be parseable\")\n-                    .clone_for_update()\n+                id.map(|call| {\n+                    call.and_then(|call| db.parse_or_expand(call.as_file()))\n+                        .map(|it| it.clone_for_update())\n+                })\n             }\n             MacroDefKind::Declarative(_)\n             | MacroDefKind::BuiltIn(..)\n             | MacroDefKind::BuiltInAttr(..)\n             | MacroDefKind::BuiltInDerive(..)\n             | MacroDefKind::ProcMacro(..) => {\n-                let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n-                let val = match diagnostic_sink.expand_result_option(res) {\n-                    Ok(it) => it,\n-                    Err(err) => return Ok(Err(err)),\n-                };\n-\n-                // replace macro inside\n-                let hygiene = Hygiene::new(db, val.file_id);\n-                match eager_macro_recur(db, &hygiene, val, krate, macro_resolver, diagnostic_sink) {\n-                    Ok(Ok(it)) => it,\n-                    Ok(Err(err)) => return Ok(Err(err)),\n-                    Err(err) => return Err(err),\n+                let ExpandResult { value, err } =\n+                    lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n+\n+                match value {\n+                    Some(val) => {\n+                        // replace macro inside\n+                        let hygiene = Hygiene::new(db, val.file_id);\n+                        let ExpandResult { value, err: error } =\n+                            eager_macro_recur(db, &hygiene, val, krate, macro_resolver)?;\n+                        let err = if err.is_none() { error } else { err };\n+                        ExpandResult { value, err }\n+                    }\n+                    None => ExpandResult { value: None, err },\n                 }\n             }\n         };\n-\n+        if err.is_some() {\n+            error = err;\n+        }\n         // check if the whole original syntax is replaced\n         if child.syntax() == &original {\n-            return Ok(Ok(insert));\n+            return Ok(ExpandResult { value, err: error });\n         }\n \n-        replacements.push((child, insert));\n+        if let Some(insert) = value {\n+            replacements.push((child, insert));\n+        }\n     }\n \n     replacements.into_iter().rev().for_each(|(old, new)| ted::replace(old.syntax(), new));\n-    Ok(Ok(original))\n+    Ok(ExpandResult { value: Some(original), err: error })\n }"}]}