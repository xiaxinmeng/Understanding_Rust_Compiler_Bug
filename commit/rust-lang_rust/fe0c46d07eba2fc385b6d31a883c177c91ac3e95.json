{"sha": "fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMGM0NmQwN2ViYTJmYzM4NWI2ZDMxYTg4M2MxNzdjOTFhYzNlOTU=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-15T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-16T22:52:05Z"}, "message": "Pass PlaceTy by reference not value", "tree": {"sha": "c5c484360647a9a362e4f56b6f940f3e6fa85f1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c484360647a9a362e4f56b6f940f3e6fa85f1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "html_url": "https://github.com/rust-lang/rust/commit/fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e915cf45dc48e90653081f9d760a7f4f803ce428", "url": "https://api.github.com/repos/rust-lang/rust/commits/e915cf45dc48e90653081f9d760a7f4f803ce428", "html_url": "https://github.com/rust-lang/rust/commit/e915cf45dc48e90653081f9d760a7f4f803ce428"}], "stats": {"total": 178, "additions": 91, "deletions": 87}, "files": [{"sha": "9a2e659678d53bbc3e7b4248d538f4c13de88563", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -56,7 +56,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.push_stack_frame(\n         cid.instance,\n         body,\n-        Some(ret.into()),\n+        Some(&ret.into()),\n         StackPopCleanup::None { cleanup: false },\n     )?;\n "}, {"sha": "70548c583d695a06b2c287c3ffc2aecedb18da78", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -222,7 +222,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         _abi: Abi,\n         args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -262,7 +262,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n-        ret: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         // Shared intrinsics.\n@@ -366,7 +366,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n+        _dest: &PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         Err(ConstEvalErrKind::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into())\n     }"}, {"sha": "04c3fad3a13d7b0d6a2161196cf7ae80de24f346", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -20,7 +20,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         src: &OpTy<'tcx, M::PointerTag>,\n         cast_kind: CastKind,\n         cast_ty: Ty<'tcx>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::CastKind::*;\n         // FIXME: In which cases should we trigger UB when the source is uninit?\n@@ -260,7 +260,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn unsize_into_ptr(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n         // The pointee types\n         source_ty: Ty<'tcx>,\n         cast_ty: Ty<'tcx>,\n@@ -302,7 +302,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n         cast_ty: TyAndLayout<'tcx>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"Unsizing {:?} of type {} into {:?}\", *src, src.layout.ty, cast_ty.ty);\n         match (&src.layout.ty.kind(), &cast_ty.ty.kind()) {\n@@ -340,9 +340,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     let src_field = self.operand_field(src, i)?;\n                     let dst_field = self.place_field(dest, i)?;\n                     if src_field.layout.ty == cast_ty_field.ty {\n-                        self.copy_op(&src_field, dst_field)?;\n+                        self.copy_op(&src_field, &dst_field)?;\n                     } else {\n-                        self.unsize_into(&src_field, cast_ty_field, dst_field)?;\n+                        self.unsize_into(&src_field, cast_ty_field, &dst_field)?;\n                     }\n                 }\n                 Ok(())"}, {"sha": "3d3a4afb5aca344c85ed7a308fa746bd7c950a6b", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -654,15 +654,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         body: &'mir mir::Body<'tcx>,\n-        return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n+        return_place: Option<&PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n             loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n-            return_place,\n+            return_place: return_place.copied(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n@@ -777,10 +777,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         if !unwinding {\n             // Copy the return value to the caller's stack frame.\n-            if let Some(return_place) = frame.return_place {\n+            if let Some(ref return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n                 self.copy_op_transmute(&op, return_place)?;\n-                trace!(\"{:?}\", self.dump_place(*return_place));\n+                trace!(\"{:?}\", self.dump_place(**return_place));\n             } else {\n                 throw_ub!(Unreachable);\n             }"}, {"sha": "7c53fcbb9552ef3660a900fa449a0080c54819d6", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -115,7 +115,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx, bool> {\n         let substs = instance.substs;\n         let intrinsic_name = self.tcx.item_name(instance.def_id());\n@@ -459,7 +459,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 for i in 0..len {\n                     let place = self.place_index(dest, i)?;\n                     let value = if i == index { *elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(&value, place)?;\n+                    self.copy_op(&value, &place)?;\n                 }\n             }\n             sym::simd_extract => {\n@@ -492,7 +492,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n-        trace!(\"{:?}\", self.dump_place(*dest));\n+        trace!(\"{:?}\", self.dump_place(**dest));\n         self.go_to_block(ret);\n         Ok(true)\n     }\n@@ -501,7 +501,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         a: &ImmTy<'tcx, M::PointerTag>,\n         b: &ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Performs an exact division, resulting in undefined behavior where\n         // `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`."}, {"sha": "72b07d76372432f3cdae55291e1d819c8e81aa2d", "filename": "compiler/rustc_mir/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -92,11 +92,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n \n         // Initialize fields.\n-        self.write_immediate(file.to_ref(), self.mplace_field(location, 0).unwrap().into())\n+        self.write_immediate(file.to_ref(), &self.mplace_field(location, 0).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(line, self.mplace_field(location, 1).unwrap().into())\n+        self.write_scalar(line, &self.mplace_field(location, 1).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n-        self.write_scalar(col, self.mplace_field(location, 2).unwrap().into())\n+        self.write_scalar(col, &self.mplace_field(location, 2).unwrap().into())\n             .expect(\"writing to memory we just allocated cannot fail\");\n \n         location"}, {"sha": "65869f956397f16ab79a89e5e5d5867bd4dc68f6", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -157,7 +157,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n@@ -168,7 +168,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         fn_val: Self::ExtraFnVal,\n         abi: Abi,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n@@ -178,7 +178,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, Self::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n@@ -207,7 +207,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Self::PointerTag>,\n+        dest: &PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n@@ -327,7 +327,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn retag(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n-        _place: PlaceTy<'tcx, Self::PointerTag>,\n+        _place: &PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n@@ -420,7 +420,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         fn_val: !,\n         _abi: Abi,\n         _args: &[OpTy<$tcx>],\n-        _ret: Option<(PlaceTy<$tcx>, mir::BasicBlock)>,\n+        _ret: Option<(&PlaceTy<$tcx>, mir::BasicBlock)>,\n         _unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<$tcx> {\n         match fn_val {}"}, {"sha": "1a0d9ba1d3c56418c150197ccfc678f4a90ce45e", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -462,9 +462,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     #[inline(always)]\n     pub fn place_to_op(\n         &self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        let op = match *place {\n+        let op = match **place {\n             Place::Ptr(mplace) => Operand::Indirect(mplace),\n             Place::Local { frame, local } => {\n                 *self.access_local(&self.stack()[frame], local, None)?"}, {"sha": "3737f8781c7ae2a333dc02cfd9405717f4eeabaa", "filename": "compiler/rustc_mir/src/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperator.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -16,7 +16,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: mir::BinOp,\n         left: &ImmTy<'tcx, M::PointerTag>,\n         right: &ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let (val, overflowed, ty) = self.overflowing_binary_op(op, &left, &right)?;\n         debug_assert_eq!(\n@@ -36,7 +36,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         op: mir::BinOp,\n         left: &ImmTy<'tcx, M::PointerTag>,\n         right: &ImmTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         let (val, _overflowed, ty) = self.overflowing_binary_op(op, left, right)?;\n         assert_eq!(ty, dest.layout.ty, \"type mismatch for result of {:?}\", op);"}, {"sha": "5dbb49018a6c102ff63bb82edd28be92f7ee9e36", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -592,7 +592,7 @@ where\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n     pub fn place_field(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         field: usize,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // FIXME: We could try to be smarter and avoid allocation for fields that span the\n@@ -603,7 +603,7 @@ where\n \n     pub fn place_index(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         index: u64,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         let mplace = self.force_allocation(base)?;\n@@ -612,7 +612,7 @@ where\n \n     pub fn place_downcast(\n         &self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n@@ -622,15 +622,15 @@ where\n             }\n             Place::Local { .. } => {\n                 let layout = base.layout.for_variant(self, variant);\n-                PlaceTy { layout, ..base }\n+                PlaceTy { layout, ..*base }\n             }\n         })\n     }\n \n     /// Projects into a place.\n     pub fn place_projection(\n         &mut self,\n-        base: PlaceTy<'tcx, M::PointerTag>,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n         &proj_elem: &mir::ProjectionElem<mir::Local, Ty<'tcx>>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n@@ -660,7 +660,7 @@ where\n         };\n \n         for elem in place.projection.iter() {\n-            place_ty = self.place_projection(place_ty, &elem)?\n+            place_ty = self.place_projection(&place_ty, &elem)?\n         }\n \n         trace!(\"{:?}\", self.dump_place(place_ty.place));\n@@ -681,7 +681,7 @@ where\n     pub fn write_scalar(\n         &mut self,\n         val: impl Into<ScalarMaybeUninit<M::PointerTag>>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n     }\n@@ -691,7 +691,7 @@ where\n     pub fn write_immediate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate_no_validate(src, dest)?;\n \n@@ -726,7 +726,7 @@ where\n     fn write_immediate_no_validate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if cfg!(debug_assertions) {\n             // This is a very common path, avoid some checks in release mode\n@@ -844,7 +844,7 @@ where\n     pub fn copy_op(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         self.copy_op_no_validate(src, dest)?;\n \n@@ -863,7 +863,7 @@ where\n     fn copy_op_no_validate(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n@@ -922,7 +922,7 @@ where\n     pub fn copy_op_transmute(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n@@ -959,7 +959,7 @@ where\n         let dest = self.force_allocation(dest)?;\n         self.copy_op_no_validate(\n             src,\n-            PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n+            &PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n         )?;\n \n         if M::enforce_validity(self) {\n@@ -980,7 +980,7 @@ where\n     /// version.\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n         meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n@@ -1025,7 +1025,7 @@ where\n     #[inline(always)]\n     pub fn force_allocation(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         Ok(self.force_allocation_maybe_sized(place, MemPlaceMeta::None)?.0)\n     }\n@@ -1061,7 +1061,7 @@ where\n     pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,\n-        dest: PlaceTy<'tcx, M::PointerTag>,\n+        dest: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         // Layout computation excludes uninhabited variants from consideration\n         // therefore there's no way to represent those variants in the given layout.\n@@ -1092,7 +1092,7 @@ where\n                 let tag_val = size.truncate(discr_val);\n \n                 let tag_dest = self.place_field(dest, tag_field)?;\n-                self.write_scalar(Scalar::from_uint(tag_val, size), tag_dest)?;\n+                self.write_scalar(Scalar::from_uint(tag_val, size), &tag_dest)?;\n             }\n             Variants::Multiple {\n                 tag_encoding:\n@@ -1123,7 +1123,7 @@ where\n                     )?;\n                     // Write result.\n                     let niche_dest = self.place_field(dest, tag_field)?;\n-                    self.write_immediate(*tag_val, niche_dest)?;\n+                    self.write_immediate(*tag_val, &niche_dest)?;\n                 }\n             }\n         }"}, {"sha": "bb58b9d2f2a9cbb21c0395a7f51dc3f604595c03", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -90,7 +90,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             SetDiscriminant { place, variant_index } => {\n                 let dest = self.eval_place(**place)?;\n-                self.write_discriminant(*variant_index, dest)?;\n+                self.write_discriminant(*variant_index, &dest)?;\n             }\n \n             // Mark locals as alive\n@@ -110,7 +110,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Stacked Borrows.\n             Retag(kind, place) => {\n                 let dest = self.eval_place(**place)?;\n-                M::retag(self, *kind, dest)?;\n+                M::retag(self, *kind, &dest)?;\n             }\n \n             // Statements we do not track.\n@@ -156,45 +156,45 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ThreadLocalRef(did) => {\n                 let id = M::thread_local_static_alloc_id(self, did)?;\n                 let val = self.global_base_pointer(id.into())?;\n-                self.write_scalar(val, dest)?;\n+                self.write_scalar(val, &dest)?;\n             }\n \n             Use(ref operand) => {\n                 // Avoid recomputing the layout\n                 let op = self.eval_operand(operand, Some(dest.layout))?;\n-                self.copy_op(&op, dest)?;\n+                self.copy_op(&op, &dest)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = binop_left_homogeneous(bin_op).then_some(dest.layout);\n                 let left = self.read_immediate(&self.eval_operand(left, layout)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_ignore_overflow(bin_op, &left, &right, dest)?;\n+                self.binop_ignore_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n                 let left = self.read_immediate(&self.eval_operand(left, None)?)?;\n                 let layout = binop_right_homogeneous(bin_op).then_some(left.layout);\n                 let right = self.read_immediate(&self.eval_operand(right, layout)?)?;\n-                self.binop_with_overflow(bin_op, &left, &right, dest)?;\n+                self.binop_with_overflow(bin_op, &left, &right, &dest)?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n                 let val = self.read_immediate(&self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, &val)?;\n                 assert_eq!(val.layout, dest.layout, \"layout mismatch for result of {:?}\", un_op);\n-                self.write_immediate(*val, dest)?;\n+                self.write_immediate(*val, &dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant(variant_index, dest)?;\n+                        self.write_discriminant(variant_index, &dest)?;\n                         if adt_def.is_enum() {\n-                            (self.place_downcast(dest, variant_index)?, active_field_index)\n+                            (self.place_downcast(&dest, variant_index)?, active_field_index)\n                         } else {\n                             (dest, active_field_index)\n                         }\n@@ -207,21 +207,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Ignore zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let field_dest = self.place_field(dest, field_index)?;\n-                        self.copy_op(&op, field_dest)?;\n+                        let field_dest = self.place_field(&dest, field_index)?;\n+                        self.copy_op(&op, &field_dest)?;\n                     }\n                 }\n             }\n \n             Repeat(ref operand, _) => {\n                 let op = self.eval_operand(operand, None)?;\n-                let dest = self.force_allocation(dest)?;\n+                let dest = self.force_allocation(&dest)?;\n                 let length = dest.len(self)?;\n \n                 if let Some(first_ptr) = self.check_mplace_access(dest, None)? {\n                     // Write the first.\n                     let first = self.mplace_field(dest, 0)?;\n-                    self.copy_op(&op, first.into())?;\n+                    self.copy_op(&op, &first.into())?;\n \n                     if length > 1 {\n                         let elem_size = first.layout.size;\n@@ -242,23 +242,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Len(place) => {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n-                let mplace = self.force_allocation(src)?;\n+                let mplace = self.force_allocation(&src)?;\n                 let len = mplace.len(self)?;\n-                self.write_scalar(Scalar::from_machine_usize(len, self), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(len, self), &dest)?;\n             }\n \n             AddressOf(_, place) | Ref(_, _, place) => {\n                 let src = self.eval_place(place)?;\n-                let place = self.force_allocation(src)?;\n+                let place = self.force_allocation(&src)?;\n                 if place.layout.size.bytes() > 0 {\n                     // definitely not a ZST\n                     assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n                 }\n-                self.write_immediate(place.to_ref(), dest)?;\n+                self.write_immediate(place.to_ref(), &dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {\n-                M::box_alloc(self, dest)?;\n+                M::box_alloc(self, &dest)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n@@ -272,19 +272,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     );\n                     throw_inval!(SizeOfUnsizedType(ty));\n                 }\n-                self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), dest)?;\n+                self.write_scalar(Scalar::from_machine_usize(layout.size.bytes(), self), &dest)?;\n             }\n \n             Cast(cast_kind, ref operand, cast_ty) => {\n                 let src = self.eval_operand(operand, None)?;\n                 let cast_ty = self.subst_from_current_frame_and_normalize_erasing_regions(cast_ty);\n-                self.cast(&src, cast_kind, cast_ty, dest)?;\n+                self.cast(&src, cast_kind, cast_ty, &dest)?;\n             }\n \n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(&op)?.0;\n-                self.write_scalar(discr_val, dest)?;\n+                self.write_scalar(discr_val, &dest)?;\n             }\n         }\n "}, {"sha": "db2766bb7e26038a34e92446fcfeb7258c8cb969", "filename": "compiler/rustc_mir/src/interpret/terminator.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fterminator.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -78,8 +78,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ),\n                 };\n                 let args = self.eval_operands(args)?;\n+                let dest_place;\n                 let ret = match destination {\n-                    Some((dest, ret)) => Some((self.eval_place(dest)?, ret)),\n+                    Some((dest, ret)) => {\n+                        dest_place = self.eval_place(dest)?;\n+                        Some((&dest_place, ret))\n+                    },\n                     None => None,\n                 };\n                 self.eval_fn_call(fn_val, abi, &args[..], ret, *cleanup)?;\n@@ -96,7 +100,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n \n                 let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n-                self.drop_in_place(place, instance, target, unwind)?;\n+                self.drop_in_place(&place, instance, target, unwind)?;\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n@@ -180,7 +184,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self,\n         rust_abi: bool,\n         caller_arg: &mut impl Iterator<Item = OpTy<'tcx, M::PointerTag>>,\n-        callee_arg: PlaceTy<'tcx, M::PointerTag>,\n+        callee_arg: &PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         if rust_abi && callee_arg.layout.is_zst() {\n             // Nothing to do.\n@@ -211,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n-        ret: Option<(PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n+        ret: Option<(&PlaceTy<'tcx, M::PointerTag>, mir::BasicBlock)>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", fn_val);\n@@ -344,12 +348,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n-                                let dest = self.place_field(dest, i)?;\n-                                self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n+                                let dest = self.place_field(&dest, i)?;\n+                                self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n                             }\n                         } else {\n                             // Normal argument\n-                            self.pass_argument(rust_abi, &mut caller_iter, dest)?;\n+                            self.pass_argument(rust_abi, &mut caller_iter, &dest)?;\n                         }\n                     }\n                     // Now we should have no more caller args\n@@ -426,7 +430,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     fn drop_in_place(\n         &mut self,\n-        place: PlaceTy<'tcx, M::PointerTag>,\n+        place: &PlaceTy<'tcx, M::PointerTag>,\n         instance: ty::Instance<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n@@ -457,7 +461,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             FnVal::Instance(instance),\n             Abi::Rust,\n             &[arg.into()],\n-            Some((dest.into(), target)),\n+            Some((&dest.into(), target)),\n             unwind,\n         )\n     }"}, {"sha": "8c4ffd3e1b4abfd25a2069166ee8245bae3a70d8", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe0c46d07eba2fc385b6d31a883c177c91ac3e95/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=fe0c46d07eba2fc385b6d31a883c177c91ac3e95", "patch": "@@ -197,7 +197,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _instance: ty::Instance<'tcx>,\n         _abi: Abi,\n         _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n         Ok(None)\n@@ -207,7 +207,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::Instance<'tcx>,\n         _args: &[OpTy<'tcx>],\n-        _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n+        _ret: Option<(&PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n@@ -237,7 +237,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n \n     fn box_alloc(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        _dest: PlaceTy<'tcx>,\n+        _dest: &PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n         throw_machine_stop_str!(\"can't const prop heap allocations\")\n     }\n@@ -392,12 +392,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             .filter(|ret_layout| {\n                 !ret_layout.is_zst() && ret_layout.size < Size::from_bytes(MAX_ALLOC_LIMIT)\n             })\n-            .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack));\n+            .map(|ret_layout| ecx.allocate(ret_layout, MemoryKind::Stack).into());\n \n         ecx.push_stack_frame(\n             Instance::new(def_id, substs),\n             dummy_body,\n-            ret.map(Into::into),\n+            ret.as_ref(),\n             StackPopCleanup::None { cleanup: false },\n         )\n         .expect(\"failed to push initial stack frame\");\n@@ -760,14 +760,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     match op {\n                         BinOp::BitAnd => {\n                             if arg_value == 0 {\n-                                this.ecx.write_immediate(*const_arg, dest)?;\n+                                this.ecx.write_immediate(*const_arg, &dest)?;\n                             }\n                         }\n                         BinOp::BitOr => {\n                             if arg_value == const_arg.layout.size.truncate(u128::MAX)\n                                 || (const_arg.layout.ty.is_bool() && arg_value == 1)\n                             {\n-                                this.ecx.write_immediate(*const_arg, dest)?;\n+                                this.ecx.write_immediate(*const_arg, &dest)?;\n                             }\n                         }\n                         BinOp::Mul => {\n@@ -777,9 +777,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                         const_arg.to_scalar()?.into(),\n                                         Scalar::from_bool(false).into(),\n                                     );\n-                                    this.ecx.write_immediate(val, dest)?;\n+                                    this.ecx.write_immediate(val, &dest)?;\n                                 } else {\n-                                    this.ecx.write_immediate(*const_arg, dest)?;\n+                                    this.ecx.write_immediate(*const_arg, &dest)?;\n                                 }\n                             }\n                         }"}]}