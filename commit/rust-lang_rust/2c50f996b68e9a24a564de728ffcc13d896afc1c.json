{"sha": "2c50f996b68e9a24a564de728ffcc13d896afc1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNTBmOTk2YjY4ZTlhMjRhNTY0ZGU3MjhmZmNjMTNkODk2YWZjMWM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-30T16:31:15Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-01-11T22:33:04Z"}, "message": "more WIP", "tree": {"sha": "03dc2a0abd8706f00089b7865ad0d95731a408e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03dc2a0abd8706f00089b7865ad0d95731a408e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c50f996b68e9a24a564de728ffcc13d896afc1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c50f996b68e9a24a564de728ffcc13d896afc1c", "html_url": "https://github.com/rust-lang/rust/commit/2c50f996b68e9a24a564de728ffcc13d896afc1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c50f996b68e9a24a564de728ffcc13d896afc1c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22b412f1a9d245cc3d3774dab9408e3a39a52025", "url": "https://api.github.com/repos/rust-lang/rust/commits/22b412f1a9d245cc3d3774dab9408e3a39a52025", "html_url": "https://github.com/rust-lang/rust/commit/22b412f1a9d245cc3d3774dab9408e3a39a52025"}], "stats": {"total": 134, "additions": 122, "deletions": 12}, "files": [{"sha": "cc686ea6a5db08982c52978e7adcfadcff93614d", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 90, "deletions": 12, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2c50f996b68e9a24a564de728ffcc13d896afc1c/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c50f996b68e9a24a564de728ffcc13d896afc1c/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=2c50f996b68e9a24a564de728ffcc13d896afc1c", "patch": "@@ -1,18 +1,35 @@\n //! An algorithm to find a path to refer to a certain item.\n \n-use crate::{ModuleDefId, path::ModPath, ModuleId};\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    path::{ModPath, PathKind},\n+    ModuleId,\n+};\n \n-pub fn find_path(item: ModuleDefId, from: ModuleId) -> ModPath {\n+pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> ModPath {\n+    // 1. Find all locations that the item could be imported from (i.e. that are visible)\n+    //    - this needs to consider other crates, for reexports from transitive dependencies\n+    //    - filter by visibility\n+    // 2. For each of these, go up the module tree until we find an\n+    //    item/module/crate that is already in scope (including because it is in\n+    //    the prelude, and including aliases!)\n+    // 3. Then select the one that gives the shortest path\n+    let def_map = db.crate_def_map(from.krate);\n+    let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n+    if let Some((name, _)) = from_scope.reverse_get(item) {\n+        return ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]);\n+    }\n     todo!()\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use crate::{db::DefDatabase, test_db::TestDB};\n-    use ra_syntax::ast::AstNode;\n+    use crate::test_db::TestDB;\n     use hir_expand::hygiene::Hygiene;\n+    use ra_db::fixture::WithFixture;\n+    use ra_syntax::ast::AstNode;\n \n     /// `code` needs to contain a cursor marker; checks that `find_path` for the\n     /// item the `path` refers to returns that same path when called from the\n@@ -21,24 +38,85 @@ mod tests {\n         let (db, pos) = TestDB::with_position(code);\n         let module = db.module_for_file(pos.file_id);\n         let parsed_path_file = ra_syntax::SourceFile::parse(&format!(\"use {};\", path));\n-        let ast_path = parsed_path_file.syntax_node().descendants().find_map(ra_syntax::ast::Path::cast).unwrap();\n+        let ast_path = parsed_path_file\n+            .syntax_node()\n+            .descendants()\n+            .find_map(ra_syntax::ast::Path::cast)\n+            .unwrap();\n         let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n \n         let crate_def_map = db.crate_def_map(module.krate);\n-        let resolved = crate_def_map.resolve_path(&db, module.local_id, &mod_path, crate::item_scope::BuiltinShadowMode::Module).0.take_types().unwrap();\n+        let resolved = crate_def_map\n+            .resolve_path(\n+                &db,\n+                module.local_id,\n+                &mod_path,\n+                crate::item_scope::BuiltinShadowMode::Module,\n+            )\n+            .0\n+            .take_types()\n+            .unwrap();\n \n-        let found_path = find_path(resolved, module);\n+        let found_path = find_path(&db, ItemInNs::Types(resolved), module);\n \n         assert_eq!(mod_path, found_path);\n     }\n \n     #[test]\n     fn same_module() {\n         let code = r#\"\n-//- /main.rs\n-struct S;\n-<|>\n-\"#;\n+            //- /main.rs\n+            struct S;\n+            <|>\n+        \"#;\n         check_found_path(code, \"S\");\n     }\n+\n+    #[test]\n+    fn sub_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo {\n+                pub struct S;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"foo::S\");\n+    }\n+\n+    #[test]\n+    fn same_crate() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            struct S;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"crate::S\");\n+    }\n+\n+    #[test]\n+    fn different_crate() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std\n+            pub struct S;\n+        \"#;\n+        check_found_path(code, \"std::S\");\n+    }\n+\n+    #[test]\n+    fn same_crate_reexport() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod bar {\n+                mod foo { pub(super) struct S; }\n+                pub(crate) use foo::*;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"bar::S\");\n+    }\n }"}, {"sha": "f88502d78865b22ca19fcad48397dfd3223a4349", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2c50f996b68e9a24a564de728ffcc13d896afc1c/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c50f996b68e9a24a564de728ffcc13d896afc1c/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=2c50f996b68e9a24a564de728ffcc13d896afc1c", "patch": "@@ -104,6 +104,15 @@ impl ItemScope {\n         }\n     }\n \n+    pub(crate) fn reverse_get(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n+        for (name, per_ns) in &self.visible {\n+            if let Some(vis) = item.match_with(*per_ns) {\n+                return Some((name, vis));\n+            }\n+        }\n+        None\n+    }\n+\n     pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n         self.visible.values().filter_map(|def| match def.take_types() {\n             Some(ModuleDefId::TraitId(t)) => Some(t),\n@@ -173,3 +182,26 @@ impl PerNs {\n         }\n     }\n }\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum ItemInNs {\n+    Types(ModuleDefId),\n+    Values(ModuleDefId),\n+    Macros(MacroDefId),\n+}\n+\n+impl ItemInNs {\n+    fn match_with(self, per_ns: PerNs) -> Option<Visibility> {\n+        match self {\n+            ItemInNs::Types(def) => {\n+                per_ns.types.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            },\n+            ItemInNs::Values(def) => {\n+                per_ns.values.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            },\n+            ItemInNs::Macros(def) => {\n+                per_ns.macros.filter(|(other_def, _)| *other_def == def).map(|(_, vis)| vis)\n+            },\n+        }\n+    }\n+}"}]}