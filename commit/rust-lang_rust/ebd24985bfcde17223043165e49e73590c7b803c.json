{"sha": "ebd24985bfcde17223043165e49e73590c7b803c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZDI0OTg1YmZjZGUxNzIyMzA0MzE2NWU0OWU3MzU5MGM3YjgwM2M=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-10T03:58:52Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-08-10T03:58:52Z"}, "message": "Rename implitem to impl_item\n\n`impl_item` is proper snake case and used everywhere else.", "tree": {"sha": "44353b8098d6355ea3013640ab161cfdac78baad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44353b8098d6355ea3013640ab161cfdac78baad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebd24985bfcde17223043165e49e73590c7b803c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd24985bfcde17223043165e49e73590c7b803c", "html_url": "https://github.com/rust-lang/rust/commit/ebd24985bfcde17223043165e49e73590c7b803c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebd24985bfcde17223043165e49e73590c7b803c/comments", "author": null, "committer": null, "parents": [{"sha": "c55d38ed7ace06e4a3a5939b3c7c01045017bca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55d38ed7ace06e4a3a5939b3c7c01045017bca4", "html_url": "https://github.com/rust-lang/rust/commit/c55d38ed7ace06e4a3a5939b3c7c01045017bca4"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "f0e2af266f37fdc0e918d1124f25aa2e96212696", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebd24985bfcde17223043165e49e73590c7b803c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebd24985bfcde17223043165e49e73590c7b803c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ebd24985bfcde17223043165e49e73590c7b803c", "patch": "@@ -991,29 +991,29 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n-        if in_external_macro(cx.sess(), implitem.span) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n+        if in_external_macro(cx.sess(), impl_item.span) {\n             return;\n         }\n-        let name = implitem.ident.name.as_str();\n-        let parent = cx.tcx.hir().get_parent_item(implitem.hir_id);\n+        let name = impl_item.ident.name.as_str();\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id);\n         let item = cx.tcx.hir().expect_item(parent);\n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n-            if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n+            if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n-                if cx.access_levels.is_exported(implitem.hir_id) {\n+                if cx.access_levels.is_exported(impl_item.hir_id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n                         sig.decl.inputs.len() == n_args &&\n                         out_type.matches(cx, &sig.decl.output) &&\n-                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n-                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &impl_item.generics) {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n                                 \"defining a method called `{}` on this type; consider implementing \\\n                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n                         }\n@@ -1026,7 +1026,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                     if conv.check(&name) {\n                         if !self_kinds\n                                 .iter()\n-                                .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics)) {\n+                                .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &impl_item.generics)) {\n                             let lint = if item.vis.node.is_pub() {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n@@ -1052,8 +1052,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             }\n         }\n \n-        if let hir::ImplItemKind::Method(_, _) = implitem.node {\n-            let ret_ty = return_ty(cx, implitem.hir_id);\n+        if let hir::ImplItemKind::Method(_, _) = impl_item.node {\n+            let ret_ty = return_ty(cx, impl_item.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n             for inner_type in ret_ty.walk() {\n@@ -1086,7 +1086,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n                 span_lint(\n                     cx,\n                     NEW_RET_NO_SELF,\n-                    implitem.span,\n+                    impl_item.span,\n                     \"methods called `new` usually return `Self`\",\n                 );\n             }"}]}