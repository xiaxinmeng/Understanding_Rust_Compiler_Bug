{"sha": "c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjE5ZjljZTA0Zjk4YjRlYzc4ZmQ4NTZmZDA5OGQ4OGZhN2VjOWY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T14:19:15Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-14T14:19:15Z"}, "message": "Accept returning refs rooted in an arg from a by-ref funtion\n\nIssue #918", "tree": {"sha": "0781bc9a4d9d467e87ee25854ea0153b401567e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0781bc9a4d9d467e87ee25854ea0153b401567e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "html_url": "https://github.com/rust-lang/rust/commit/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3c449df7426ea2f34be15fb5312a2620f871668", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c449df7426ea2f34be15fb5312a2620f871668", "html_url": "https://github.com/rust-lang/rust/commit/a3c449df7426ea2f34be15fb5312a2620f871668"}], "stats": {"total": 70, "additions": 49, "deletions": 21}, "files": [{"sha": "ae71acdaa1162d0c4ebf55cfcb1ab48d0054b6f7", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "patch": "@@ -119,7 +119,7 @@ fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n       }\n       ast::expr_ret(oexpr) {\n         if sc.ret_style == ast::return_ref && !is_none(oexpr) {\n-            check_ret_ref(*cx, option::get(oexpr));\n+            check_ret_ref(*cx, sc, option::get(oexpr));\n         }\n         handled = false;\n       }\n@@ -266,18 +266,53 @@ fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr]) -> [binding] {\n     ret bindings;\n }\n \n-fn check_ret_ref(cx: ctx, expr: @ast::expr) {\n+fn check_ret_ref(cx: ctx, sc: scope, expr: @ast::expr) {\n     let root = expr_root(cx.tcx, expr, false);\n     let bad = none;\n+    let mut_field = mut_field(root.ds);\n     alt path_def(cx, root.ex) {\n       none. { bad = some(\"temporary\"); }\n-      some(ast::def_arg(_, mode)) {\n-        if mode == ast::by_move { bad = some(\"move-mode parameter\"); }\n-        if mut_field(root.ds) { bad = some(\"mutable field\"); }\n+      some(ast::def_local(did)) | some(ast::def_binding(did)) |\n+      some(ast::def_arg(did, _)) {\n+        let cur_node = did.node;\n+        while true {\n+            alt cx.tcx.items.find(cur_node) {\n+              some(ast_map::node_arg(arg)) {\n+                if arg.mode == ast::by_move {\n+                    bad = some(\"move-mode parameter\");\n+                }\n+                break;\n+              }\n+              _ {}\n+            }\n+            alt vec::find({|b| b.node_id == cur_node}, sc.bs) {\n+              some(b) {\n+                if vec::len(b.unsafe_tys) > 0u {\n+                    mut_field = true;\n+                    break;\n+                }\n+                if is_none(b.root_var) {\n+                    bad = some(\"function-local value\");\n+                    break;\n+                }\n+                if b.copied == copied {\n+                    bad = some(\"implicitly copied reference\");\n+                    break;\n+                }\n+                b.copied = not_allowed;\n+                cur_node = option::get(b.root_var);\n+              }\n+              none. {\n+                bad = some(\"function-local value\");\n+                break;\n+              }\n+            }\n+        }\n       }\n       // FIXME allow references to constants and static items?\n-      _ { bad = some(\"non-argument value\"); }\n+      _ { bad = some(\"non-local value\"); }\n     }\n+      if mut_field { bad = some(\"mutable field\"); }\n     alt bad {\n       some(name) {\n         cx.tcx.sess.span_err(expr.span, \"can not return a reference \" +"}, {"sha": "4068c2e7c8edbe879f43859f8274b2ceee3275d0", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "patch": "@@ -347,7 +347,6 @@ fn visit_fn_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param], sp: span,\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n-\n     for c: @ast::constr in f.decl.constraints { resolve_constr(e, c, sc, v); }\n     visit::visit_fn(f, tp, sp, name, id,\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);"}, {"sha": "e1f3ae190a4d4b9cabf5de3839abc29a3e489b97", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c6619f9ce04f98b4ec78fd856fd098d88fa7ec9f", "patch": "@@ -3530,7 +3530,8 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n     let to_zero = [];\n     let to_revoke = [];\n \n-    let tcx = bcx_tcx(cx);\n+    let ccx = bcx_ccx(cx);\n+    let tcx = ccx.tcx;\n     let bcx: @block_ctxt = cx;\n     let by_ref = ty::ty_fn_ret_style(tcx, fn_ty) == ast::return_ref;\n     // Arg 0: Output pointer.\n@@ -3549,7 +3550,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n     }\n     let retty = ty::ty_fn_ret(tcx, fn_ty);\n     let llretslot_res = if by_ref {\n-        rslt(cx, alloca(cx, T_ptr(type_of_or_i8(cx, retty))))\n+        rslt(cx, alloca(cx, T_ptr(type_of_or_i8(bcx, retty))))\n     } else { alloc_ty(bcx, retty) };\n     bcx = llretslot_res.bcx;\n     let llretslot = llretslot_res.val;\n@@ -3568,7 +3569,8 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-        let llretty = T_ptr(type_of_inner(bcx_ccx(bcx), bcx.sp, retty));\n+        let llretty = T_ptr(type_of_inner(ccx, bcx.sp, retty));\n+        if by_ref { llretty = T_ptr(llretty); }\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n@@ -3588,7 +3590,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n         let lli =\n             if ty::type_contains_params(tcx, retty) {\n                 let body_ty = ty::mk_iter_body_fn(tcx, retty);\n-                let body_llty = type_of_inner(bcx_ccx(cx), cx.sp, body_ty);\n+                let body_llty = type_of_inner(ccx, cx.sp, body_ty);\n                 PointerCast(bcx, lli, T_ptr(body_llty))\n             } else { lli };\n         llargs += [Load(cx, lli)];\n@@ -3600,7 +3602,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef, gen: option::t<generic_info>,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    let arg_tys = type_of_explicit_args(bcx_ccx(cx), cx.sp, args);\n+    let arg_tys = type_of_explicit_args(ccx, cx.sp, args);\n     let i = 0u;\n     for e: @ast::expr in es {\n         if is_terminated(bcx) {\n@@ -3631,15 +3633,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let cx = new_scope_block_ctxt(in_cx, \"call\");\n     Br(in_cx, cx.llbb);\n     let f_res = trans_lval_gen(cx, f);\n-    let fn_ty: ty::t;\n-    alt f_res.method_ty {\n-      some(meth) {\n-        // self-call\n-        fn_ty = meth;\n-      }\n-      _ { fn_ty = ty::expr_ty(bcx_tcx(cx), f); }\n-    }\n-\n+    let fn_ty = ty::expr_ty(bcx_tcx(cx), f);\n     let bcx = f_res.res.bcx;\n \n     let faddr = f_res.res.val;"}]}