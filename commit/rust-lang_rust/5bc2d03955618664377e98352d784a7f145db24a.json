{"sha": "5bc2d03955618664377e98352d784a7f145db24a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzJkMDM5NTU2MTg2NjQzNzdlOTgzNTJkNzg0YTdmMTQ1ZGIyNGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-10T04:57:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-10T04:57:09Z"}, "message": "auto merge of #14783 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #14611 (std: Remove the as_utf16_p functions)\r\nCloses #14694 (Num cleanup)\r\nCloses #14760 (Add --color to test binary options)\r\nCloses #14763 (std: Move dynamic_lib from std::unstable to std)\r\nCloses #14766 (Add test for issue #13446)\r\nCloses #14769 (collections: Add missing Default impls)\r\nCloses #14773 (General nits)\r\nCloses #14776 (rustdoc: Correctly classify enums/typedefs)", "tree": {"sha": "ab76e5ea82592a803694bf232e983734482ba088", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab76e5ea82592a803694bf232e983734482ba088"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc2d03955618664377e98352d784a7f145db24a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc2d03955618664377e98352d784a7f145db24a", "html_url": "https://github.com/rust-lang/rust/commit/5bc2d03955618664377e98352d784a7f145db24a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc2d03955618664377e98352d784a7f145db24a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf5cc605fd2732fa35b284a4401bfaa899dcae2", "html_url": "https://github.com/rust-lang/rust/commit/5bf5cc605fd2732fa35b284a4401bfaa899dcae2"}, {"sha": "5ede96c2fd62a63e75cb5faf073933d914f3eeaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ede96c2fd62a63e75cb5faf073933d914f3eeaf", "html_url": "https://github.com/rust-lang/rust/commit/5ede96c2fd62a63e75cb5faf073933d914f3eeaf"}], "stats": {"total": 519, "additions": 309, "deletions": 210}, "files": [{"sha": "977b7dc32c5658b7d01e9bd4c4b79137bd647bff", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -292,6 +292,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         save_metrics: config.save_metrics.clone(),\n         test_shard: config.test_shard.clone(),\n         nocapture: false,\n+        color: test::AutoColor,\n     }\n }\n "}, {"sha": "8fa34dd6d27c91ff254c139ac6df1c006766842b", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -11,7 +11,7 @@\n use std::os;\n use std::str;\n use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n \n fn target_env(lib_path: &str, prog: &str) -> Vec<(String, String)> {\n     let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};"}, {"sha": "e100baa1e3ac493bd329842ff40c592cb9d121e2", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -13,6 +13,7 @@\n use core::prelude::*;\n \n use core::cmp;\n+use core::default::Default;\n use core::fmt;\n use core::iter::{Enumerate, Repeat, Map, Zip};\n use core::ops;\n@@ -698,6 +699,11 @@ pub struct BitvSet {\n     bitv: BigBitv\n }\n \n+impl Default for BitvSet {\n+    #[inline]\n+    fn default() -> BitvSet { BitvSet::new() }\n+}\n+\n impl BitvSet {\n     /// Creates a new bit vector set with initially no contents\n     pub fn new() -> BitvSet {"}, {"sha": "ac8c5c5557ed9cff4921f08afa9e252fddd51fc6", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -24,6 +24,7 @@\n use core::prelude::*;\n \n use alloc::owned::Box;\n+use core::default::Default;\n use core::fmt;\n use core::iter;\n use core::mem;\n@@ -262,6 +263,11 @@ impl<T> Deque<T> for DList<T> {\n     }\n }\n \n+impl<T> Default for DList<T> {\n+    #[inline]\n+    fn default() -> DList<T> { DList::new() }\n+}\n+\n impl<T> DList<T> {\n     /// Create an empty DList\n     #[inline]"}, {"sha": "f25864933f2eba691de2dddcb257aeeb11430c48", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::*;\n \n+use core::default::Default;\n use core::mem::{zeroed, replace, swap};\n use core::ptr;\n \n@@ -37,6 +38,11 @@ impl<T: Ord> Mutable for PriorityQueue<T> {\n     fn clear(&mut self) { self.data.truncate(0) }\n }\n \n+impl<T: Ord> Default for PriorityQueue<T> {\n+    #[inline]\n+    fn default() -> PriorityQueue<T> { PriorityQueue::new() }\n+}\n+\n impl<T: Ord> PriorityQueue<T> {\n     /// An iterator visiting all values in underlying vector, in\n     /// arbitrary order."}, {"sha": "ae1925126cae7055f8ef8b2cc0bb8fd395705ed8", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -16,6 +16,7 @@\n use core::prelude::*;\n \n use core::cmp;\n+use core::default::Default;\n use core::fmt;\n use core::iter::RandomAccessIterator;\n \n@@ -112,6 +113,11 @@ impl<T> Deque<T> for RingBuf<T> {\n     }\n }\n \n+impl<T> Default for RingBuf<T> {\n+    #[inline]\n+    fn default() -> RingBuf<T> { RingBuf::new() }\n+}\n+\n impl<T> RingBuf<T> {\n     /// Create an empty RingBuf\n     pub fn new() -> RingBuf<T> {"}, {"sha": "6b4982de0821699816e94a85214d2e87681d54cf", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -17,6 +17,7 @@\n \n use core::prelude::*;\n \n+use core::default::Default;\n use core::fmt;\n use core::iter::{Enumerate, FilterMap};\n use core::mem::replace;\n@@ -114,6 +115,11 @@ impl<V> MutableMap<uint, V> for SmallIntMap<V> {\n     }\n }\n \n+impl<V> Default for SmallIntMap<V> {\n+    #[inline]\n+    fn default() -> SmallIntMap<V> { SmallIntMap::new() }\n+}\n+\n impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n     pub fn new() -> SmallIntMap<V> { SmallIntMap{v: vec!()} }"}, {"sha": "1f4ee52008cdc56833056a95fe6288dadb0f8e3c", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -15,6 +15,7 @@\n use core::prelude::*;\n \n use alloc::owned::Box;\n+use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n use core::iter::Peekable;\n@@ -135,6 +136,11 @@ impl<K: Ord, V> MutableMap<K, V> for TreeMap<K, V> {\n     }\n }\n \n+impl<K: Ord, V> Default for TreeMap<K,V> {\n+    #[inline]\n+    fn default() -> TreeMap<K, V> { TreeMap::new() }\n+}\n+\n impl<K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -633,6 +639,11 @@ impl<T: Ord> MutableSet<T> for TreeSet<T> {\n     fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n }\n \n+impl<T: Ord> Default for TreeSet<T> {\n+    #[inline]\n+    fn default() -> TreeSet<T> { TreeSet::new() }\n+}\n+\n impl<T: Ord> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline]"}, {"sha": "3f4fdd66b802accf5b46a9ed5036783a66d5a100", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -13,6 +13,7 @@\n use core::prelude::*;\n \n use alloc::owned::Box;\n+use core::default::Default;\n use core::mem::zeroed;\n use core::mem;\n use core::uint;\n@@ -105,6 +106,11 @@ impl<T> MutableMap<uint, T> for TrieMap<T> {\n     }\n }\n \n+impl<T> Default for TrieMap<T> {\n+    #[inline]\n+    fn default() -> TrieMap<T> { TrieMap::new() }\n+}\n+\n impl<T> TrieMap<T> {\n     /// Create an empty TrieMap\n     #[inline]\n@@ -332,6 +338,11 @@ impl MutableSet<uint> for TrieSet {\n     }\n }\n \n+impl Default for TrieSet {\n+    #[inline]\n+    fn default() -> TrieSet { TrieSet::new() }\n+}\n+\n impl TrieSet {\n     /// Create an empty TrieSet\n     #[inline]"}, {"sha": "1ec25933eec3c2ea1bfafc0cb2fe6156f7a51ca7", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -69,7 +69,6 @@ extern \"system\" {\n pub mod compat {\n     use std::intrinsics::{atomic_store_relaxed, transmute};\n     use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-    use std::os::win32::as_utf16_p;\n \n     extern \"system\" {\n         fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n@@ -80,12 +79,11 @@ pub mod compat {\n     // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n     // be any slower than a regular DLL call.\n     unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n-        as_utf16_p(module, |module| {\n-            symbol.with_c_str(|symbol| {\n-                let handle = GetModuleHandleW(module);\n-                let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n-                atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n-            })\n+        let module = module.to_utf16().append_one(0);\n+        symbol.with_c_str(|symbol| {\n+            let handle = GetModuleHandleW(module.as_ptr());\n+            let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n+            atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n         })\n     }\n "}, {"sha": "5ace8e347c67ef7d5c4e521f91ec125d5314d908", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 63, "deletions": 53, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -15,10 +15,10 @@ use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n use std::mem;\n-use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n+use std::os::win32::fill_utf16_buf_and_decode;\n use std::ptr;\n use std::rt::rtio;\n-use std::rt::rtio::IoResult;\n+use std::rt::rtio::{IoResult, IoError};\n use std::str;\n use std::vec;\n \n@@ -253,6 +253,17 @@ impl Drop for Inner {\n     }\n }\n \n+pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n+    match s.as_str() {\n+        Some(s) => Ok(s.to_utf16().append_one(0)),\n+        None => Err(IoError {\n+            code: libc::ERROR_INVALID_NAME as uint,\n+            extra: 0,\n+            detail: Some(\"valid unicode input required\".to_str()),\n+        })\n+    }\n+}\n+\n pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n         -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n@@ -299,15 +310,16 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n     // Compat with unix, this allows opening directories (see libuv)\n     dwFlagsAndAttributes |= libc::FILE_FLAG_BACKUP_SEMANTICS;\n \n-    let handle = as_utf16_p(path.as_str().unwrap(), |buf| unsafe {\n-        libc::CreateFileW(buf,\n+    let path = try!(to_utf16(path));\n+    let handle = unsafe {\n+        libc::CreateFileW(path.as_ptr(),\n                           dwDesiredAccess,\n                           dwShareMode,\n                           ptr::mut_null(),\n                           dwCreationDisposition,\n                           dwFlagsAndAttributes,\n                           ptr::mut_null())\n-    });\n+    };\n     if handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n         Err(super::last_error())\n     } else {\n@@ -324,11 +336,10 @@ pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n }\n \n pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n+    let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n-        as_utf16_p(p.as_str().unwrap(), |buf| {\n-            libc::CreateDirectoryW(buf, ptr::mut_null())\n-        })\n+        libc::CreateDirectoryW(p.as_ptr(), ptr::mut_null())\n     })\n }\n \n@@ -351,9 +362,11 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n     let star = Path::new(unsafe {\n         CString::new(p.with_ref(|p| p), false)\n     }).join(\"*\");\n-    as_utf16_p(star.as_str().unwrap(), |path_ptr| unsafe {\n+    let path = try!(to_utf16(&star.to_c_str()));\n+\n+    unsafe {\n         let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n-        let find_handle = libc::FindFirstFileW(path_ptr, wfd_ptr as libc::HANDLE);\n+        let find_handle = libc::FindFirstFileW(path.as_ptr(), wfd_ptr as libc::HANDLE);\n         if find_handle as libc::c_int != libc::INVALID_HANDLE_VALUE {\n             let mut paths = vec!();\n             let mut more_files = 1 as libc::c_int;\n@@ -377,37 +390,35 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         } else {\n             Err(super::last_error())\n         }\n-    })\n+    }\n }\n \n pub fn unlink(p: &CString) -> IoResult<()> {\n+    let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n-        as_utf16_p(p.as_str().unwrap(), |buf| {\n-            libc::DeleteFileW(buf)\n-        })\n+        libc::DeleteFileW(p.as_ptr())\n     })\n }\n \n pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n+    let old = try!(to_utf16(old));\n+    let new = try!(to_utf16(new));\n     super::mkerr_winbool(unsafe {\n-        as_utf16_p(old.as_str().unwrap(), |old| {\n-            as_utf16_p(new.as_str().unwrap(), |new| {\n-                libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-            })\n-        })\n+        libc::MoveFileExW(old.as_ptr(), new.as_ptr(),\n+                          libc::MOVEFILE_REPLACE_EXISTING)\n     })\n }\n \n pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wchmod(p, mode as libc::c_int)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe {\n+        libc::wchmod(p.as_ptr(), mode as libc::c_int)\n+    })\n }\n \n pub fn rmdir(p: &CString) -> IoResult<()> {\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wrmdir(p)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe { libc::wrmdir(p.as_ptr()) })\n }\n \n pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n@@ -418,16 +429,15 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n pub fn readlink(p: &CString) -> IoResult<CString> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n     use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n+    let p = try!(to_utf16(p));\n     let handle = unsafe {\n-        as_utf16_p(p.as_str().unwrap(), |p| {\n-            libc::CreateFileW(p,\n-                              libc::GENERIC_READ,\n-                              libc::FILE_SHARE_READ,\n-                              ptr::mut_null(),\n-                              libc::OPEN_EXISTING,\n-                              libc::FILE_ATTRIBUTE_NORMAL,\n-                              ptr::mut_null())\n-        })\n+        libc::CreateFileW(p.as_ptr(),\n+                          libc::GENERIC_READ,\n+                          libc::FILE_SHARE_READ,\n+                          ptr::mut_null(),\n+                          libc::OPEN_EXISTING,\n+                          libc::FILE_ATTRIBUTE_NORMAL,\n+                          ptr::mut_null())\n     };\n     if handle as int == libc::INVALID_HANDLE_VALUE as int {\n         return Err(super::last_error())\n@@ -453,19 +463,19 @@ pub fn readlink(p: &CString) -> IoResult<CString> {\n \n pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n     use io::c::compat::kernel32::CreateSymbolicLinkW;\n-    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-        as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { CreateSymbolicLinkW(dst, src, 0) }\n-        }) as libc::BOOL\n-    }))\n+    let src = try!(to_utf16(src));\n+    let dst = try!(to_utf16(dst));\n+    super::mkerr_winbool(unsafe {\n+        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), 0) as libc::BOOL\n+    })\n }\n \n pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n-    super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n-        as_utf16_p(dst.as_str().unwrap(), |dst| {\n-            unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-        })\n-    }))\n+    let src = try!(to_utf16(src));\n+    let dst = try!(to_utf16(dst));\n+    super::mkerr_winbool(unsafe {\n+        libc::CreateHardLinkW(dst.as_ptr(), src.as_ptr(), ptr::mut_null())\n+    })\n }\n \n fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n@@ -491,12 +501,11 @@ fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n \n pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n-    as_utf16_p(p.as_str().unwrap(), |up| {\n-        match unsafe { libc::wstat(up, &mut stat) } {\n-            0 => Ok(mkstat(&stat)),\n-            _ => Err(super::last_error()),\n-        }\n-    })\n+    let p = try!(to_utf16(p));\n+    match unsafe { libc::wstat(p.as_ptr(), &mut stat) } {\n+        0 => Ok(mkstat(&stat)),\n+        _ => Err(super::last_error()),\n+    }\n }\n \n pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n@@ -509,7 +518,8 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n         actime: (atime / 1000) as libc::time64_t,\n         modtime: (mtime / 1000) as libc::time64_t,\n     };\n-    super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wutime(p, &buf)\n-    }))\n+    let p = try!(to_utf16(p));\n+    super::mkerr_libc(unsafe {\n+        libc::wutime(p.as_ptr(), &buf)\n+    })\n }"}, {"sha": "4c5929ef2233f0e3315a80c37f2a922170f85371", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -77,7 +77,7 @@ fn unimpl() -> IoError {\n     IoError {\n         code: ERROR as uint,\n         extra: 0,\n-        detail: None,\n+        detail: Some(\"not yet supported by the `native` runtime, maybe try `green`.\".to_string()),\n     }\n }\n "}, {"sha": "45b12aa7007ff307320d33bd8be67816c0c13ce4", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -88,7 +88,6 @@ use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n use std::mem;\n-use std::os::win32::as_utf16_p;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n@@ -98,6 +97,7 @@ use std::rt::mutex;\n \n use super::c;\n use super::util;\n+use super::file::to_utf16;\n \n struct Event(libc::HANDLE);\n \n@@ -261,67 +261,66 @@ impl UnixStream {\n     }\n \n     pub fn connect(addr: &CString, timeout: Option<u64>) -> IoResult<UnixStream> {\n-        as_utf16_p(addr.as_str().unwrap(), |p| {\n-            let start = ::io::timer::now();\n-            loop {\n-                match UnixStream::try_connect(p) {\n-                    Some(handle) => {\n-                        let inner = Inner::new(handle);\n-                        let mut mode = libc::PIPE_TYPE_BYTE |\n-                                       libc::PIPE_READMODE_BYTE |\n-                                       libc::PIPE_WAIT;\n-                        let ret = unsafe {\n-                            libc::SetNamedPipeHandleState(inner.handle,\n-                                                          &mut mode,\n-                                                          ptr::mut_null(),\n-                                                          ptr::mut_null())\n-                        };\n-                        return if ret == 0 {\n-                            Err(super::last_error())\n-                        } else {\n-                            Ok(UnixStream {\n-                                inner: Arc::new(inner),\n-                                read: None,\n-                                write: None,\n-                                read_deadline: 0,\n-                                write_deadline: 0,\n-                            })\n-                        }\n+        let addr = try!(to_utf16(addr));\n+        let start = ::io::timer::now();\n+        loop {\n+            match UnixStream::try_connect(addr.as_ptr()) {\n+                Some(handle) => {\n+                    let inner = Inner::new(handle);\n+                    let mut mode = libc::PIPE_TYPE_BYTE |\n+                                   libc::PIPE_READMODE_BYTE |\n+                                   libc::PIPE_WAIT;\n+                    let ret = unsafe {\n+                        libc::SetNamedPipeHandleState(inner.handle,\n+                                                      &mut mode,\n+                                                      ptr::mut_null(),\n+                                                      ptr::mut_null())\n+                    };\n+                    return if ret == 0 {\n+                        Err(super::last_error())\n+                    } else {\n+                        Ok(UnixStream {\n+                            inner: Arc::new(inner),\n+                            read: None,\n+                            write: None,\n+                            read_deadline: 0,\n+                            write_deadline: 0,\n+                        })\n                     }\n-                    None => {}\n                 }\n+                None => {}\n+            }\n \n-                // On windows, if you fail to connect, you may need to call the\n-                // `WaitNamedPipe` function, and this is indicated with an error\n-                // code of ERROR_PIPE_BUSY.\n-                let code = unsafe { libc::GetLastError() };\n-                if code as int != libc::ERROR_PIPE_BUSY as int {\n-                    return Err(super::last_error())\n-                }\n+            // On windows, if you fail to connect, you may need to call the\n+            // `WaitNamedPipe` function, and this is indicated with an error\n+            // code of ERROR_PIPE_BUSY.\n+            let code = unsafe { libc::GetLastError() };\n+            if code as int != libc::ERROR_PIPE_BUSY as int {\n+                return Err(super::last_error())\n+            }\n \n-                match timeout {\n-                    Some(timeout) => {\n-                        let now = ::io::timer::now();\n-                        let timed_out = (now - start) >= timeout || unsafe {\n-                            let ms = (timeout - (now - start)) as libc::DWORD;\n-                            libc::WaitNamedPipeW(p, ms) == 0\n-                        };\n-                        if timed_out {\n-                            return Err(util::timeout(\"connect timed out\"))\n-                        }\n+            match timeout {\n+                Some(timeout) => {\n+                    let now = ::io::timer::now();\n+                    let timed_out = (now - start) >= timeout || unsafe {\n+                        let ms = (timeout - (now - start)) as libc::DWORD;\n+                        libc::WaitNamedPipeW(addr.as_ptr(), ms) == 0\n+                    };\n+                    if timed_out {\n+                        return Err(util::timeout(\"connect timed out\"))\n                     }\n+                }\n \n-                    // An example I found on microsoft's website used 20\n-                    // seconds, libuv uses 30 seconds, hence we make the\n-                    // obvious choice of waiting for 25 seconds.\n-                    None => {\n-                        if unsafe { libc::WaitNamedPipeW(p, 25000) } == 0 {\n-                            return Err(super::last_error())\n-                        }\n+                // An example I found on microsoft's website used 20\n+                // seconds, libuv uses 30 seconds, hence we make the\n+                // obvious choice of waiting for 25 seconds.\n+                None => {\n+                    if unsafe { libc::WaitNamedPipeW(addr.as_ptr(), 25000) } == 0 {\n+                        return Err(super::last_error())\n                     }\n                 }\n             }\n-        })\n+        }\n     }\n \n     fn handle(&self) -> libc::HANDLE { self.inner.handle }\n@@ -564,14 +563,13 @@ impl UnixListener {\n         // Although we technically don't need the pipe until much later, we\n         // create the initial handle up front to test the validity of the name\n         // and such.\n-        as_utf16_p(addr.as_str().unwrap(), |p| {\n-            let ret = unsafe { pipe(p, true) };\n-            if ret == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n-                Err(super::last_error())\n-            } else {\n-                Ok(UnixListener { handle: ret, name: addr.clone() })\n-            }\n-        })\n+        let addr_v = try!(to_utf16(addr));\n+        let ret = unsafe { pipe(addr_v.as_ptr(), true) };\n+        if ret == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n+            Err(super::last_error())\n+        } else {\n+            Ok(UnixListener { handle: ret, name: addr.clone() })\n+        }\n     }\n \n     pub fn native_listen(self) -> IoResult<UnixAcceptor> {\n@@ -639,6 +637,8 @@ impl UnixAcceptor {\n         // using the original server pipe.\n         let handle = self.listener.handle;\n \n+        let name = try!(to_utf16(&self.listener.name));\n+\n         // Once we've got a \"server handle\", we need to wait for a client to\n         // connect. The ConnectNamedPipe function will block this thread until\n         // someone on the other end connects. This function can \"fail\" if a\n@@ -678,9 +678,7 @@ impl UnixAcceptor {\n         // Now that we've got a connected client to our handle, we need to\n         // create a second server pipe. If this fails, we disconnect the\n         // connected client and return an error (see comments above).\n-        let new_handle = as_utf16_p(self.listener.name.as_str().unwrap(), |p| {\n-            unsafe { pipe(p, false) }\n-        });\n+        let new_handle = unsafe { pipe(name.as_ptr(), false) };\n         if new_handle == libc::INVALID_HANDLE_VALUE as libc::HANDLE {\n             let ret = Err(super::last_error());\n             // If our disconnection fails, then there's not really a whole lot"}, {"sha": "97b227ae1d8d3b6ee14f1b4b3b56fab34b0bd7ce", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -296,16 +296,15 @@ fn spawn_process_os(cfg: ProcessConfig,\n                     lpSecurityDescriptor: ptr::mut_null(),\n                     bInheritHandle: 1,\n                 };\n-                *slot = os::win32::as_utf16_p(\"NUL\", |filename| {\n-                    libc::CreateFileW(filename,\n-                                      access,\n-                                      libc::FILE_SHARE_READ |\n-                                          libc::FILE_SHARE_WRITE,\n-                                      &mut sa,\n-                                      libc::OPEN_EXISTING,\n-                                      0,\n-                                      ptr::mut_null())\n-                });\n+                let filename = \"NUL\".to_utf16().append_one(0);\n+                *slot = libc::CreateFileW(filename.as_ptr(),\n+                                          access,\n+                                          libc::FILE_SHARE_READ |\n+                                              libc::FILE_SHARE_WRITE,\n+                                          &mut sa,\n+                                          libc::OPEN_EXISTING,\n+                                          0,\n+                                          ptr::mut_null());\n                 if *slot == INVALID_HANDLE_VALUE as libc::HANDLE {\n                     return Err(super::last_error())\n                 }\n@@ -338,18 +337,17 @@ fn spawn_process_os(cfg: ProcessConfig,\n \n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n-                os::win32::as_mut_utf16_p(cmd_str.as_slice(), |cmdp| {\n-                    let created = CreateProcessW(ptr::null(),\n-                                                 cmdp,\n-                                                 ptr::mut_null(),\n-                                                 ptr::mut_null(),\n-                                                 TRUE,\n-                                                 flags, envp, dirp,\n-                                                 &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(super::last_error());\n-                    }\n-                })\n+                let mut cmd_str = cmd_str.to_utf16().append_one(0);\n+                let created = CreateProcessW(ptr::null(),\n+                                             cmd_str.as_mut_ptr(),\n+                                             ptr::mut_null(),\n+                                             ptr::mut_null(),\n+                                             TRUE,\n+                                             flags, envp, dirp,\n+                                             &mut si, &mut pi);\n+                if created == FALSE {\n+                    create_err = Some(super::last_error());\n+                }\n             })\n         });\n \n@@ -740,7 +738,8 @@ fn with_dirp<T>(d: Option<&CString>, cb: |*u16| -> T) -> T {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          os::win32::as_utf16_p(dir_str, cb)\n+          let dir_str = dir_str.to_utf16().append_one(0);\n+          cb(dir_str.as_ptr())\n       },\n       None => cb(ptr::null())\n     }"}, {"sha": "0a88abd67d9dfffab5e5c96512b81598c23f745c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -321,3 +321,8 @@ pub fn get_reachable_extern_fns(cstore: &cstore::CStore, cnum: ast::CrateNum)\n     let cdata = cstore.get_crate_data(cnum);\n     decoder::get_reachable_extern_fns(&*cdata)\n }\n+\n+pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_typedef(&*cdata, did.node)\n+}"}, {"sha": "56d6766e1b719f6be681c7f2d0bdb7d820194c2f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -1339,3 +1339,11 @@ pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n     });\n     return ret;\n }\n+\n+pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let item_doc = lookup_item(id, cdata.data());\n+    match item_family(item_doc) {\n+        Type => true,\n+        _ => false,\n+    }\n+}"}, {"sha": "ec46e7f8592d3391ffbc4e69e101bf47df625e61", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -13,7 +13,7 @@\n use std::cell::RefCell;\n use std::os;\n use std::io::fs;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n use std::collections::HashSet;\n \n use myfs = util::fs;"}, {"sha": "97ffcf279ae737770234cc0f6aaf42f49e9a364e", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -16,7 +16,7 @@ use plugin::registry::Registry;\n \n use std::mem;\n use std::os;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n use syntax::ast;\n use syntax::attr;\n use syntax::visit;"}, {"sha": "d243c61ddaff8ba3d91bdab8fb135e9888352d12", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -203,7 +203,7 @@ fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> clean::Struct {\n fn build_type(tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n     match ty::get(t.ty).sty {\n-        ty::ty_enum(edid, _) => {\n+        ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n                 generics: t.generics.clean(),\n                 variants_stripped: false,"}, {"sha": "8ad10a686e677677778e4ce92efb73b5f6424094", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -135,7 +135,6 @@ mod imp {\n mod imp {\n     use libc;\n     use std::mem;\n-    use std::os::win32::as_utf16_p;\n     use std::os;\n     use std::ptr;\n \n@@ -162,8 +161,9 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let handle = as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-                libc::CreateFileW(p,\n+            let p_16 = p.as_str().unwrap().to_utf16().append_one(0);\n+            let handle = unsafe {\n+                libc::CreateFileW(p_16.as_ptr(),\n                                   libc::FILE_GENERIC_READ |\n                                     libc::FILE_GENERIC_WRITE,\n                                   libc::FILE_SHARE_READ |\n@@ -173,7 +173,7 @@ mod imp {\n                                   libc::CREATE_ALWAYS,\n                                   libc::FILE_ATTRIBUTE_NORMAL,\n                                   ptr::mut_null())\n-            });\n+            };\n             if handle as uint == libc::INVALID_HANDLE_VALUE as uint {\n                 fail!(\"create file error: {}\", os::last_os_error());\n             }"}, {"sha": "fee1d63a274d51ab7530e157bb98d8c0de1e2db1", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -10,7 +10,7 @@\n \n use clean;\n \n-use dl = std::unstable::dynamic_lib;\n+use dl = std::dynamic_lib;\n use serialize::json;\n use std::string::String;\n "}, {"sha": "0d77764127465bcee61ad89cb2aefe8c9579efb5", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -15,7 +15,7 @@ use std::io::{Command, TempDir};\n use std::os;\n use std::str;\n use std::string::String;\n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n \n use std::collections::{HashSet, HashMap};\n use testing;"}, {"sha": "fa6efc8a4b18ab34e0b75ce8913ee8c28844e057", "filename": "src/libstd/dynamic_lib.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -16,6 +16,9 @@ A simple wrapper over the platform's dynamic library facilities\n \n */\n \n+#![experimental]\n+#![allow(missing_doc)]\n+\n use clone::Clone;\n use c_str::ToCStr;\n use iter::Iterator;\n@@ -272,21 +275,21 @@ pub mod dl {\n \n #[cfg(target_os = \"win32\")]\n pub mod dl {\n+    use c_str::ToCStr;\n     use libc;\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n-    use string::String;\n+    use str::StrAllocating;\n     use str;\n-    use c_str::ToCStr;\n+    use string::String;\n \n     pub unsafe fn open_external<T: ToCStr>(filename: T) -> *u8 {\n         // Windows expects Unicode data\n         let filename_cstr = filename.to_c_str();\n         let filename_str = str::from_utf8(filename_cstr.as_bytes_no_nul()).unwrap();\n-        os::win32::as_utf16_p(filename_str, |raw_name| {\n-            LoadLibraryW(raw_name as *libc::c_void) as *u8\n-        })\n+        let filename_str = filename_str.to_utf16().append_one(0);\n+        LoadLibraryW(filename_str.as_ptr() as *libc::c_void) as *u8\n     }\n \n     pub unsafe fn open_internal() -> *u8 {", "previous_filename": "src/libstd/unstable/dynamic_lib.rs"}, {"sha": "a1e0fa889789f39b3b59a1f3a50c6cdd781d1641", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -81,13 +81,18 @@ Some examples of obvious things you might want to do\n \n * Make a simple TCP client connection and request\n \n-    ```rust,should_fail\n+    ```rust\n     # #![allow(unused_must_use)]\n     use std::io::net::tcp::TcpStream;\n \n+    # // connection doesn't fail if a server is running on 8080\n+    # // locally, we still want to be type checking this code, so lets\n+    # // just stop it running (#11576)\n+    # if false {\n     let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n     let response = socket.read_to_end();\n+    # }\n     ```\n \n * Make a simple TCP server"}, {"sha": "e147997334ccc4259296366d347a96c18824c427", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -241,15 +241,12 @@ pub mod sync;\n /* Runtime and platform support */\n \n pub mod c_vec;\n+pub mod dynamic_lib;\n pub mod os;\n pub mod io;\n pub mod path;\n pub mod fmt;\n \n-// Private APIs\n-#[unstable]\n-pub mod unstable;\n-\n // FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub.\n #[unstable]\n@@ -279,3 +276,11 @@ mod std {\n     // The test runner requires std::slice::Vector, so re-export std::slice just for it.\n     #[cfg(test)] pub use slice;\n }\n+\n+#[deprecated]\n+#[allow(missing_doc)]\n+#[doc(hiden)]\n+pub mod unstable {\n+    #[deprecated = \"use std::dynamic_lib\"]\n+    pub use dynamic_lib;\n+}"}, {"sha": "fa882e7d016fe21783efe91b2ed1cebd09c62af4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -133,7 +133,7 @@ pub mod win32 {\n     use os::TMPBUF_SZ;\n     use slice::{MutableVector, ImmutableVector};\n     use string::String;\n-    use str::{StrSlice, StrAllocating};\n+    use str::StrSlice;\n     use str;\n     use vec::Vec;\n \n@@ -171,17 +171,6 @@ pub mod win32 {\n             return res;\n         }\n     }\n-\n-    pub fn as_utf16_p<T>(s: &str, f: |*u16| -> T) -> T {\n-        as_mut_utf16_p(s, |t| { f(t as *u16) })\n-    }\n-\n-    pub fn as_mut_utf16_p<T>(s: &str, f: |*mut u16| -> T) -> T {\n-        let mut t = s.to_utf16();\n-        // Null terminate before passing on.\n-        t.push(0u16);\n-        f(t.as_mut_ptr())\n-    }\n }\n \n /*\n@@ -356,11 +345,10 @@ pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n pub fn getenv(n: &str) -> Option<String> {\n     unsafe {\n         with_env_lock(|| {\n-            use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-            as_utf16_p(n, |u| {\n-                fill_utf16_buf_and_decode(|buf, sz| {\n-                    libc::GetEnvironmentVariableW(u, buf, sz)\n-                })\n+            use os::win32::{fill_utf16_buf_and_decode};\n+            let n = n.to_utf16().append_one(0);\n+            fill_utf16_buf_and_decode(|buf, sz| {\n+                libc::GetEnvironmentVariableW(n.as_ptr(), buf, sz)\n             })\n         })\n     }\n@@ -398,14 +386,11 @@ pub fn setenv(n: &str, v: &str) {\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n pub fn setenv(n: &str, v: &str) {\n+    let n = n.to_utf16().append_one(0);\n+    let v = v.to_utf16().append_one(0);\n     unsafe {\n         with_env_lock(|| {\n-            use os::win32::as_utf16_p;\n-            as_utf16_p(n, |nbuf| {\n-                as_utf16_p(v, |vbuf| {\n-                    libc::SetEnvironmentVariableW(nbuf, vbuf);\n-                })\n-            })\n+            libc::SetEnvironmentVariableW(n.as_ptr(), v.as_ptr());\n         })\n     }\n }\n@@ -428,12 +413,10 @@ pub fn unsetenv(n: &str) {\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n+        let n = n.to_utf16().append_one(0);\n         unsafe {\n             with_env_lock(|| {\n-                use os::win32::as_utf16_p;\n-                as_utf16_p(n, |nbuf| {\n-                    libc::SetEnvironmentVariableW(nbuf, ptr::null());\n-                })\n+                libc::SetEnvironmentVariableW(n.as_ptr(), ptr::null());\n             })\n         }\n     }\n@@ -732,11 +715,12 @@ pub fn change_dir(p: &Path) -> bool {\n \n     #[cfg(windows)]\n     fn chdir(p: &Path) -> bool {\n+        let p = match p.as_str() {\n+            Some(s) => s.to_utf16().append_one(0),\n+            None => return false,\n+        };\n         unsafe {\n-            use os::win32::as_utf16_p;\n-            return as_utf16_p(p.as_str().unwrap(), |buf| {\n-                libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n-            });\n+            libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL)\n         }\n     }\n "}, {"sha": "423f372f018fdbe799be5fa83abc43d442097350", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -614,7 +614,7 @@ mod imp {\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n     use slice::ImmutableVector;\n     use str::StrSlice;\n-    use unstable::dynamic_lib::DynamicLibrary;\n+    use dynamic_lib::DynamicLibrary;\n \n     #[allow(non_snake_case_functions)]\n     extern \"system\" {"}, {"sha": "7d94e46a88a6e74b5769e57e1f5fc4e979422482", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -271,6 +271,12 @@ pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n                      tests)\n }\n \n+pub enum ColorConfig {\n+    AutoColor,\n+    AlwaysColor,\n+    NeverColor,\n+}\n+\n pub struct TestOpts {\n     pub filter: Option<Regex>,\n     pub run_ignored: bool,\n@@ -282,6 +288,7 @@ pub struct TestOpts {\n     pub test_shard: Option<(uint,uint)>,\n     pub logfile: Option<Path>,\n     pub nocapture: bool,\n+    pub color: ColorConfig,\n }\n \n impl TestOpts {\n@@ -298,6 +305,7 @@ impl TestOpts {\n             test_shard: None,\n             logfile: None,\n             nocapture: false,\n+            color: AutoColor,\n         }\n     }\n }\n@@ -324,7 +332,11 @@ fn optgroups() -> Vec<getopts::OptGroup> {\n       getopts::optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\",\n                      \"A.B\"),\n       getopts::optflag(\"\", \"nocapture\", \"don't capture stdout/stderr of each \\\n-                                         task, allow printing directly\"))\n+                                         task, allow printing directly\"),\n+      getopts::optopt(\"\", \"color\", \"Configure coloring of output:\n+            auto   = colorize if stdout is a tty and tests are run on serially (default);\n+            always = always colorize output;\n+            never  = never colorize output;\", \"auto|always|never\"))\n }\n \n fn usage(binary: &str) {\n@@ -406,6 +418,16 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         nocapture = os::getenv(\"RUST_TEST_NOCAPTURE\").is_some();\n     }\n \n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.as_slice()) {\n+        Some(\"auto\") | None => AutoColor,\n+        Some(\"always\") => AlwaysColor,\n+        Some(\"never\") => NeverColor,\n+\n+        Some(v) => return Some(Err(format!(\"argument for --color must be \\\n+                                            auto, always, or never (was {})\",\n+                                            v))),\n+    };\n+\n     let test_opts = TestOpts {\n         filter: filter,\n         run_ignored: run_ignored,\n@@ -417,6 +439,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         test_shard: test_shard,\n         logfile: logfile,\n         nocapture: nocapture,\n+        color: color,\n     };\n \n     Some(Ok(test_opts))\n@@ -492,7 +515,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         Ok(ConsoleTestState {\n             out: out,\n             log_out: log_out,\n-            use_color: use_color(),\n+            use_color: use_color(opts),\n             total: 0u,\n             passed: 0u,\n             failed: 0u,\n@@ -867,8 +890,12 @@ fn should_sort_failures_before_printing_them() {\n     assert!(apos < bpos);\n }\n \n-fn use_color() -> bool {\n-    get_concurrency() == 1 && io::stdout().get_ref().isatty()\n+fn use_color(opts: &TestOpts) -> bool {\n+    match opts.color {\n+        AutoColor => get_concurrency() == 1 && io::stdout().get_ref().isatty(),\n+        AlwaysColor => true,\n+        NeverColor => false,\n+    }\n }\n \n #[deriving(Clone)]"}, {"sha": "0b4bea49fa2499d0481dbdcbe5178c20c8401fe9", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n \n #[no_mangle]\n pub fn foo() { bar(); }"}, {"sha": "0bb6ded00121d3046e36cee2919557caa6944b94", "filename": "src/test/compile-fail/issue-13446.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13446.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![doc(hidden)]\n \n-pub mod dynamic_lib;\n+// Used to cause ICE\n+\n+static VEC: [u32, ..256] = vec!(); //~ ERROR mismatched types\n+\n+fn main() {}\n+", "previous_filename": "src/libstd/unstable/mod.rs"}, {"sha": "0f759efb02539bc874d624f4511cd767b819f89e", "filename": "src/test/run-make/extern-fn-reachable/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-reachable%2Fmain.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::unstable::dynamic_lib::DynamicLibrary;\n+use std::dynamic_lib::DynamicLibrary;\n use std::os;\n \n pub fn main() {"}, {"sha": "58f66314e4430dd7fca25b6b6046b192787d9eb1", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc2d03955618664377e98352d784a7f145db24a/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=5bc2d03955618664377e98352d784a7f145db24a", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:linkage-visibility.rs\n // ignore-android: FIXME(#10379)\n-// ignore-win32: std::unstable::dynamic_lib does not work on win32 well\n+// ignore-win32: std::dynamic_lib does not work on win32 well\n \n extern crate foo = \"linkage-visibility\";\n "}]}