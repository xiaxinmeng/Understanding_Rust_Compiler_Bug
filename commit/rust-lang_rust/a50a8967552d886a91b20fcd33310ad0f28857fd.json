{"sha": "a50a8967552d886a91b20fcd33310ad0f28857fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MGE4OTY3NTUyZDg4NmE5MWIyMGZjZDMzMzEwYWQwZjI4ODU3ZmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-02-13T01:52:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-13T01:52:54Z"}, "message": "Rollup merge of #69050 - nnethercote:micro-optimize-leb128, r=michaelwoerister\n\nMicro-optimize the heck out of LEB128 reading and writing.\n\nThis commit makes the following writing improvements:\n- Removes the unnecessary `write_to_vec` function.\n- Reduces the number of conditions per loop from 2 to 1.\n- Avoids a mask and a shift on the final byte.\n\nAnd the following reading improvements:\n- Removes an unnecessary type annotation.\n- Fixes a dangerous unchecked slice access. Imagine a slice `[0x80]` --\n  the current code will read past the end of the slice some number of\n  bytes. The bounds check at the end will subsequently trigger, unless\n  something bad (like a crash) happens first. The cost of doing bounds\n  check in the loop body is negligible.\n- Avoids a mask on the final byte.\n\nAnd the following improvements for both reading and writing:\n- Changes `for` to `loop` for the loops, avoiding an unnecessary\n  condition on each iteration. This also removes the need for\n  `leb128_size`.\n\nAll of these changes give significant perf wins, up to 5%.\n\nr? @michaelwoerister", "tree": {"sha": "757999dfe462003e4675a39d3344c6fdbff32793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757999dfe462003e4675a39d3344c6fdbff32793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a50a8967552d886a91b20fcd33310ad0f28857fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRKv2CRBK7hj4Ov3rIwAAdHIIAHdV7fpsJ+p8LZj0lIi2kyii\noDH9QqdvxfI0GwIPZ0yaxfT6t16VRPK3N8IuRpsdoC0RaQW0uqw4Gie9DNdb2kHS\nmNvp/r4Ge78hpjrqbCbQPkVGvGRqA63PcVCLiUk2gyH6vFGC/I9WQRPXV13a+Tjp\nt0KYoyfj7OufHPJFzVXkgXNd/h8wh7Dv5iSkkWCToqwxfyrPdEZvmP4WuDZYaH6J\ny7oa2PhuMuDD2huDPUV69FeCrq/D2WSjJxqI2abTVHH8F42zVTYH5kLrT8k6V6ZF\nMno5we1kRAnI8W35gCMLLLqyDrAvVygbG8FNLG+bfKqkWp9Ik+yCwN/uebgqgF8=\n=+vgp\n-----END PGP SIGNATURE-----\n", "payload": "tree 757999dfe462003e4675a39d3344c6fdbff32793\nparent 53a790c58a9fb055b58ae471a6e57ece81c55b50\nparent ad7802f9d45b884dad58931c7a8bec91d196ad0e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1581558774 +0100\ncommitter GitHub <noreply@github.com> 1581558774 +0100\n\nRollup merge of #69050 - nnethercote:micro-optimize-leb128, r=michaelwoerister\n\nMicro-optimize the heck out of LEB128 reading and writing.\n\nThis commit makes the following writing improvements:\n- Removes the unnecessary `write_to_vec` function.\n- Reduces the number of conditions per loop from 2 to 1.\n- Avoids a mask and a shift on the final byte.\n\nAnd the following reading improvements:\n- Removes an unnecessary type annotation.\n- Fixes a dangerous unchecked slice access. Imagine a slice `[0x80]` --\n  the current code will read past the end of the slice some number of\n  bytes. The bounds check at the end will subsequently trigger, unless\n  something bad (like a crash) happens first. The cost of doing bounds\n  check in the loop body is negligible.\n- Avoids a mask on the final byte.\n\nAnd the following improvements for both reading and writing:\n- Changes `for` to `loop` for the loops, avoiding an unnecessary\n  condition on each iteration. This also removes the need for\n  `leb128_size`.\n\nAll of these changes give significant perf wins, up to 5%.\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a50a8967552d886a91b20fcd33310ad0f28857fd", "html_url": "https://github.com/rust-lang/rust/commit/a50a8967552d886a91b20fcd33310ad0f28857fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a50a8967552d886a91b20fcd33310ad0f28857fd/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a790c58a9fb055b58ae471a6e57ece81c55b50", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a790c58a9fb055b58ae471a6e57ece81c55b50", "html_url": "https://github.com/rust-lang/rust/commit/53a790c58a9fb055b58ae471a6e57ece81c55b50"}, {"sha": "ad7802f9d45b884dad58931c7a8bec91d196ad0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7802f9d45b884dad58931c7a8bec91d196ad0e", "html_url": "https://github.com/rust-lang/rust/commit/ad7802f9d45b884dad58931c7a8bec91d196ad0e"}], "stats": {"total": 64, "additions": 14, "deletions": 50}, "files": [{"sha": "1fe6a309e9650a90f39f8cf639aff03538268e28", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a50a8967552d886a91b20fcd33310ad0f28857fd/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a50a8967552d886a91b20fcd33310ad0f28857fd/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=a50a8967552d886a91b20fcd33310ad0f28857fd", "patch": "@@ -1,46 +1,14 @@\n-#[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, byte: u8) {\n-    vec.push(byte);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-const USIZE_LEB128_SIZE: usize = 5;\n-#[cfg(target_pointer_width = \"64\")]\n-const USIZE_LEB128_SIZE: usize = 10;\n-\n-macro_rules! leb128_size {\n-    (u16) => {\n-        3\n-    };\n-    (u32) => {\n-        5\n-    };\n-    (u64) => {\n-        10\n-    };\n-    (u128) => {\n-        19\n-    };\n-    (usize) => {\n-        USIZE_LEB128_SIZE\n-    };\n-}\n-\n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(out: &mut Vec<u8>, mut value: $int_ty) {\n-            for _ in 0..leb128_size!($int_ty) {\n-                let mut byte = (value & 0x7F) as u8;\n-                value >>= 7;\n-                if value != 0 {\n-                    byte |= 0x80;\n-                }\n-\n-                write_to_vec(out, byte);\n-\n-                if value == 0 {\n+            loop {\n+                if value < 0x80 {\n+                    out.push(value as u8);\n                     break;\n+                } else {\n+                    out.push(((value & 0x7f) | 0x80) as u8);\n+                    value >>= 7;\n                 }\n             }\n         }\n@@ -57,24 +25,20 @@ macro_rules! impl_read_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n-            let mut result: $int_ty = 0;\n+            let mut result = 0;\n             let mut shift = 0;\n             let mut position = 0;\n-\n-            for _ in 0..leb128_size!($int_ty) {\n-                let byte = unsafe { *slice.get_unchecked(position) };\n+            loop {\n+                let byte = slice[position];\n                 position += 1;\n-                result |= ((byte & 0x7F) as $int_ty) << shift;\n                 if (byte & 0x80) == 0 {\n-                    break;\n+                    result |= (byte as $int_ty) << shift;\n+                    return (result, position);\n+                } else {\n+                    result |= ((byte & 0x7F) as $int_ty) << shift;\n                 }\n                 shift += 7;\n             }\n-\n-            // Do a single bounds check at the end instead of for every byte.\n-            assert!(position <= slice.len());\n-\n-            (result, position)\n         }\n     };\n }\n@@ -116,7 +80,7 @@ where\n \n #[inline]\n pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n-    write_signed_leb128_to(value, |v| write_to_vec(out, v))\n+    write_signed_leb128_to(value, |v| out.push(v))\n }\n \n #[inline]"}]}