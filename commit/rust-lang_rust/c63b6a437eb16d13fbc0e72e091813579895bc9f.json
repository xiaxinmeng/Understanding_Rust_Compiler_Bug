{"sha": "c63b6a437eb16d13fbc0e72e091813579895bc9f", "node_id": "C_kwDOAAsO6NoAKGM2M2I2YTQzN2ViMTZkMTNmYmMwZTcyZTA5MTgxMzU3OTg5NWJjOWY", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-16T20:46:06Z"}, "committer": {"name": "yukang", "email": "moorekang@gmail.com", "date": "2023-05-01T08:15:13Z"}, "message": "Rip it out\n\nMy type ascription\nOh rip it out\nAh\nIf you think we live too much then\nYou can sacrifice diagnostics\nDon't mix your garbage\nInto my syntax\nSo many weird hacks keep diagnostics alive\nYet I don't even step outside\nSo many bad diagnostics keep tyasc alive\nYet tyasc doesn't even bother to survive!", "tree": {"sha": "e8f76dda7c8e719159690efab7899d68ed0acb09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f76dda7c8e719159690efab7899d68ed0acb09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c63b6a437eb16d13fbc0e72e091813579895bc9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c63b6a437eb16d13fbc0e72e091813579895bc9f", "html_url": "https://github.com/rust-lang/rust/commit/c63b6a437eb16d13fbc0e72e091813579895bc9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c63b6a437eb16d13fbc0e72e091813579895bc9f/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "chenyukang", "id": 230646, "node_id": "MDQ6VXNlcjIzMDY0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/230646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/chenyukang", "html_url": "https://github.com/chenyukang", "followers_url": "https://api.github.com/users/chenyukang/followers", "following_url": "https://api.github.com/users/chenyukang/following{/other_user}", "gists_url": "https://api.github.com/users/chenyukang/gists{/gist_id}", "starred_url": "https://api.github.com/users/chenyukang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/chenyukang/subscriptions", "organizations_url": "https://api.github.com/users/chenyukang/orgs", "repos_url": "https://api.github.com/users/chenyukang/repos", "events_url": "https://api.github.com/users/chenyukang/events{/privacy}", "received_events_url": "https://api.github.com/users/chenyukang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2034b6d23ca18311a23273f2f08c381a04fa05d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2034b6d23ca18311a23273f2f08c381a04fa05d9", "html_url": "https://github.com/rust-lang/rust/commit/2034b6d23ca18311a23273f2f08c381a04fa05d9"}], "stats": {"total": 1895, "additions": 946, "deletions": 949}, "files": [{"sha": "dce7106d1280462460ac30686e01eeae4f8f0735", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1589,7 +1589,6 @@ pub enum ClosureBinder {\n pub struct MacCall {\n     pub path: Path,\n     pub args: P<DelimArgs>,\n-    pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n impl MacCall {"}, {"sha": "66b94d12a32c6c11933eaf9e209a298694f187a2", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -631,7 +631,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n-    let MacCall { path, args, prior_type_ascription: _ } = mac;\n+    let MacCall { path, args } = mac;\n     vis.visit_path(path);\n     visit_delim_args(args, vis);\n }"}, {"sha": "35afd5423721d980a2c57f438cefcd745f512040", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -53,8 +53,6 @@ pub enum AssocOp {\n     DotDot,\n     /// `..=` range\n     DotDotEq,\n-    /// `:`\n-    Colon,\n }\n \n #[derive(PartialEq, Debug)]\n@@ -96,7 +94,6 @@ impl AssocOp {\n             token::DotDotEq => Some(DotDotEq),\n             // DotDotDot is no longer supported, but we need some way to display the error\n             token::DotDotDot => Some(DotDotEq),\n-            token::Colon => Some(Colon),\n             // `<-` should probably be `< -`\n             token::LArrow => Some(Less),\n             _ if t.is_keyword(kw::As) => Some(As),\n@@ -133,7 +130,7 @@ impl AssocOp {\n     pub fn precedence(&self) -> usize {\n         use AssocOp::*;\n         match *self {\n-            As | Colon => 14,\n+            As => 14,\n             Multiply | Divide | Modulus => 13,\n             Add | Subtract => 12,\n             ShiftLeft | ShiftRight => 11,\n@@ -156,7 +153,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => Fixity::Right,\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd\n             | BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual\n-            | LAnd | LOr | Colon => Fixity::Left,\n+            | LAnd | LOr => Fixity::Left,\n             DotDot | DotDotEq => Fixity::None,\n         }\n     }\n@@ -166,8 +163,9 @@ impl AssocOp {\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n             Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract\n-            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq\n-            | Colon => false,\n+            | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr | DotDot | DotDotEq => {\n+                false\n+            }\n         }\n     }\n \n@@ -177,7 +175,7 @@ impl AssocOp {\n             Assign | AssignOp(_) => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply\n             | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor\n-            | BitOr | LAnd | LOr | DotDot | DotDotEq | Colon => false,\n+            | BitOr | LAnd | LOr | DotDot | DotDotEq => false,\n         }\n     }\n \n@@ -202,7 +200,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None,\n+            Assign | AssignOp(_) | As | DotDot | DotDotEq => None,\n         }\n     }\n \n@@ -223,10 +221,9 @@ impl AssocOp {\n             Greater | // `{ 42 } > 3`\n             GreaterEqual | // `{ 42 } >= 3`\n             AssignOp(_) | // `{ 42 } +=`\n-            As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n-            Colon, // `{ 42 }: usize`\n+            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            As // `{ 42 } as usize`\n         )\n     }\n }\n@@ -254,7 +251,6 @@ pub enum ExprPrecedence {\n     Binary(BinOpKind),\n \n     Cast,\n-    Type,\n \n     Assign,\n     AssignOp,\n@@ -313,7 +309,6 @@ impl ExprPrecedence {\n             // Binop-like expr kinds, handled by `AssocOp`.\n             ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n             ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n-            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n \n             ExprPrecedence::Assign |\n             ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,"}, {"sha": "b74c59bca30c5022c90d8ca148c0d75f66b4a259", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -341,10 +341,16 @@ impl<'a> State<'a> {\n                 self.print_type(ty);\n             }\n             ast::ExprKind::Type(expr, ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n+                self.word(\"type_ascribe!(\");\n+                self.ibox(0);\n+                self.print_expr(expr);\n+\n+                self.word(\",\");\n+                self.space_if_not_bol();\n                 self.print_type(ty);\n+\n+                self.end();\n+                self.word(\")\");\n             }\n             ast::ExprKind::Let(pat, scrutinee, _) => {\n                 self.print_let(pat, scrutinee);"}, {"sha": "3ccdc8179a5c887708cbae8f571112f45219d90a", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -69,7 +69,6 @@ pub fn parse_asm_args<'a>(\n             if allow_templates {\n                 // After a template string, we always expect *only* a comma...\n                 let mut err = diag.create_err(errors::AsmExpectedComma { span: p.token.span });\n-                p.maybe_annotate_with_ascription(&mut err, false);\n                 return Err(err);\n             } else {\n                 // ...after that delegate to `expect` to also include the other expected tokens."}, {"sha": "ab4ea9c8c20525ff7c3a989a63bcc4520c7c689f", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -61,7 +61,6 @@ pub fn expand_assert<'cx>(\n                     delim: MacDelimiter::Parenthesis,\n                     tokens,\n                 }),\n-                prior_type_ascription: None,\n             })),\n         );\n         expr_if_not(cx, call_site_span, cond_expr, then, None)"}, {"sha": "ea830a0ce60dfba2edce4bdf7737188d4e214ec3", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -182,7 +182,6 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     delim: MacDelimiter::Parenthesis,\n                     tokens: initial.into_iter().chain(captures).collect::<TokenStream>(),\n                 }),\n-                prior_type_ascription: None,\n             })),\n         )\n     }"}, {"sha": "ef0db23ff2f2d8cb15e4e3954bed4d27c27bd0e5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -63,7 +63,6 @@ fn expand<'cx>(\n                     delim: MacDelimiter::Parenthesis,\n                     tokens: tts,\n                 }),\n-                prior_type_ascription: None,\n             })),\n         ),\n     )"}, {"sha": "2345cc5223b538e44d85f1d6e6d017abfa92d262", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -992,7 +992,6 @@ pub struct ExpansionData {\n     pub depth: usize,\n     pub module: Rc<ModuleData>,\n     pub dir_ownership: DirOwnership,\n-    pub prior_type_ascription: Option<(Span, bool)>,\n     /// Some parent node that is close to this macro call\n     pub lint_node_id: NodeId,\n     pub is_trailing_mac: bool,\n@@ -1043,7 +1042,6 @@ impl<'a> ExtCtxt<'a> {\n                 depth: 0,\n                 module: Default::default(),\n                 dir_ownership: DirOwnership::Owned { relative: None },\n-                prior_type_ascription: None,\n                 lint_node_id: ast::CRATE_NODE_ID,\n                 is_trailing_mac: false,\n             },"}, {"sha": "28539d46ba1034c4571472719759e4f11f56e64f", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -657,16 +657,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n-                    let prev = self.cx.current_expansion.prior_type_ascription;\n-                    self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n                     let tok_result = expander.expand(self.cx, span, mac.args.tokens.clone());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n                         self.error_wrong_fragment_kind(fragment_kind, &mac, span);\n                         fragment_kind.dummy(span)\n                     };\n-                    self.cx.current_expansion.prior_type_ascription = prev;\n                     result\n                 }\n                 _ => unreachable!(),"}, {"sha": "ccfee935901cd0d3d376e6c30e00a56affac0303", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -250,8 +250,7 @@ fn expand_macro<'cx>(\n                 trace_macros_note(&mut cx.expansions, sp, msg);\n             }\n \n-            let mut p = Parser::new(sess, tts, false, None);\n-            p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n+            let p = Parser::new(sess, tts, false, None);\n \n             if is_local {\n                 cx.resolver.record_macro_rule_usage(node_id, i);"}, {"sha": "e9af688ee2b61004e24d89ebaf26cf0cc6a85053", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -21,7 +21,6 @@ pub fn placeholder(\n                 delim: ast::MacDelimiter::Parenthesis,\n                 tokens: ast::tokenstream::TokenStream::new(Vec::new()),\n             }),\n-            prior_type_ascription: None,\n         })\n     }\n "}, {"sha": "d93e8efc1b59ad2d0f344fc064babfde819a91b6", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1407,10 +1407,16 @@ impl<'a> State<'a> {\n                 self.print_type(ty);\n             }\n             hir::ExprKind::Type(expr, ty) => {\n-                let prec = AssocOp::Colon.precedence() as i8;\n-                self.print_expr_maybe_paren(expr, prec);\n-                self.word_space(\":\");\n+                self.word(\"type_ascribe!(\");\n+                self.ibox(0);\n+                self.print_expr(expr);\n+\n+                self.word(\",\");\n+                self.space_if_not_bol();\n                 self.print_type(ty);\n+\n+                self.end();\n+                self.word(\")\");\n             }\n             hir::ExprKind::DropTemps(init) => {\n                 // Print `{`:"}, {"sha": "9c6d00b44ce74355e22cdf8ea2fa25fa647e16d5", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -420,6 +420,14 @@ parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of\n parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n     .suggestion = use `Fn` to refer to the trait\n \n+parse_path_single_colon = path separator must be a double colon\n+    .suggestion = use a double colon instead\n+\n+parse_colon_as_semi = statements are terminated with a semicolon\n+    .suggestion = use a semicolon instead\n+\n+parse_type_ascription_removed = type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n     .label = unexpected where clause\n     .name_label = while parsing this tuple struct"}, {"sha": "b445ccc7ad0aabc34727cd4da4d8effc5648b2d0", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1340,6 +1340,28 @@ pub(crate) struct ExpectedFnPathFoundFnKeyword {\n     pub fn_token_span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parse_path_single_colon)]\n+pub(crate) struct PathSingleColon {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \"::\")]\n+    pub span: Span,\n+\n+    #[note(parse_type_ascription_removed)]\n+    pub type_ascription: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_colon_as_semi)]\n+pub(crate) struct ColonAsSemi {\n+    #[primary_span]\n+    #[suggestion(applicability = \"machine-applicable\", code = \";\")]\n+    pub span: Span,\n+\n+    #[note(parse_type_ascription_removed)]\n+    pub type_ascription: Option<()>,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_where_clause_before_tuple_struct_body)]\n pub(crate) struct WhereClauseBeforeTupleStructBody {"}, {"sha": "bcc76c2081530b83757e3863fcb7d24a3ced9944", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 44, "deletions": 75, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -4,7 +4,7 @@ use super::{\n     TokenExpectType, TokenType,\n };\n use crate::errors::{\n-    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub,\n+    AmbiguousPlus, AttributeOnParamType, BadQPathStage2, BadTypePlus, BadTypePlusSub, ColonAsSemi,\n     ComparisonOperatorsCannotBeChained, ComparisonOperatorsCannotBeChainedSugg,\n     ConstGenericWithoutBraces, ConstGenericWithoutBracesSugg, DocCommentDoesNotDocumentAnything,\n     DocCommentOnParamType, DoubleColonInBound, ExpectedIdentifier, ExpectedSemi, ExpectedSemiSugg,\n@@ -84,6 +84,7 @@ impl RecoverQPath for Ty {\n }\n \n impl RecoverQPath for Pat {\n+    const PATH_STYLE: PathStyle = PathStyle::Pat;\n     fn to_ty(&self) -> Option<P<Ty>> {\n         self.to_ty()\n     }\n@@ -237,6 +238,7 @@ impl<'a> DerefMut for SnapshotParser<'a> {\n \n impl<'a> Parser<'a> {\n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n@@ -663,7 +665,6 @@ impl<'a> Parser<'a> {\n             err.span_label(sp, label_exp);\n             err.span_label(self.token.span, \"unexpected token\");\n         }\n-        self.maybe_annotate_with_ascription(&mut err, false);\n         Err(err)\n     }\n \n@@ -788,59 +789,6 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    pub fn maybe_annotate_with_ascription(\n-        &mut self,\n-        err: &mut Diagnostic,\n-        maybe_expected_semicolon: bool,\n-    ) {\n-        if let Some((sp, likely_path)) = self.last_type_ascription.take() {\n-            let sm = self.sess.source_map();\n-            let next_pos = sm.lookup_char_pos(self.token.span.lo());\n-            let op_pos = sm.lookup_char_pos(sp.hi());\n-\n-            let allow_unstable = self.sess.unstable_features.is_nightly_build();\n-\n-            if likely_path {\n-                err.span_suggestion(\n-                    sp,\n-                    \"maybe write a path separator here\",\n-                    \"::\",\n-                    if allow_unstable {\n-                        Applicability::MaybeIncorrect\n-                    } else {\n-                        Applicability::MachineApplicable\n-                    },\n-                );\n-                self.sess.type_ascription_path_suggestions.borrow_mut().insert(sp);\n-            } else if op_pos.line != next_pos.line && maybe_expected_semicolon {\n-                err.span_suggestion(\n-                    sp,\n-                    \"try using a semicolon\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else if allow_unstable {\n-                err.span_label(sp, \"tried to parse a type due to this type ascription\");\n-            } else {\n-                err.span_label(sp, \"tried to parse a type due to this\");\n-            }\n-            if allow_unstable {\n-                // Give extra information about type ascription only if it's a nightly compiler.\n-                err.note(\n-                    \"`#![feature(type_ascription)]` lets you annotate an expression with a type: \\\n-                     `<expr>: <type>`\",\n-                );\n-                if !likely_path {\n-                    // Avoid giving too much info when it was likely an unrelated typo.\n-                    err.note(\n-                        \"see issue #23416 <https://github.com/rust-lang/rust/issues/23416> \\\n-                        for more information\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     pub(super) fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n@@ -1625,9 +1573,40 @@ impl<'a> Parser<'a> {\n         if self.eat(&token::Semi) {\n             return Ok(());\n         }\n+\n+        if self.recover_colon_as_semi() {\n+            return Ok(());\n+        }\n+\n         self.expect(&token::Semi).map(drop) // Error unconditionally\n     }\n \n+    pub(super) fn recover_colon_as_semi(&mut self) -> bool {\n+        let line_idx = |span: Span| {\n+            self.sess\n+                .source_map()\n+                .span_to_lines(span)\n+                .ok()\n+                .and_then(|lines| Some(lines.lines.get(0)?.line_index))\n+        };\n+\n+        if self.may_recover()\n+            && self.token == token::Colon\n+            && self.look_ahead(1, |next| line_idx(self.token.span) < line_idx(next.span))\n+        {\n+            self.sess.emit_err(ColonAsSemi {\n+                span: self.token.span,\n+                type_ascription: self.sess.unstable_features.is_nightly_build().then_some(()),\n+            });\n+\n+            self.bump();\n+\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n     /// Consumes alternative await syntaxes like `await!(<expr>)`, `await <expr>`,\n     /// `await? <expr>`, `await(<expr>)`, and `await { <expr> }`.\n     pub(super) fn recover_incorrect_await_syntax(\n@@ -1790,37 +1769,27 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        (self.token == token::Lt && // `foo:<bar`, likely a typoed turbofish.\n-            self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident()))\n-            || self.token.is_ident() &&\n-            matches!(node, ast::ExprKind::Path(..) | ast::ExprKind::Field(..)) &&\n-            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Parenthesis))\n-            || self.look_ahead(1, |t| t == &token::OpenDelim(Delimiter::Brace)) // `foo:bar {`\n-            || self.look_ahead(1, |t| t == &token::Colon) &&     // `foo:bar::<baz`\n-            self.look_ahead(2, |t| t == &token::Lt) &&\n-            self.look_ahead(3, |t| t.is_ident())\n-            || self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n-            self.look_ahead(2, |t| t.is_ident())\n-            || self.look_ahead(1, |t| t == &token::ModSep)\n-                && (self.look_ahead(2, |t| t.is_ident()) ||   // `foo:bar::baz`\n-            self.look_ahead(2, |t| t == &token::Lt)) // `foo:bar::<baz>`\n-    }\n-\n     pub(super) fn recover_seq_parse_error(\n         &mut self,\n         delim: Delimiter,\n         lo: Span,\n         result: PResult<'a, P<Expr>>,\n     ) -> P<Expr> {\n+        use crate::parser::DUMMY_NODE_ID;\n         match result {\n             Ok(x) => x,\n             Err(mut err) => {\n                 err.emit();\n                 // Recover from parse error, callers expect the closing delim to be consumed.\n                 self.consume_block(delim, ConsumeClosingDelim::Yes);\n-                self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err)\n+                debug!(\"recover_seq_parse_error: consumed tokens until {:?} {:?}\", lo, self.token);\n+                let res = self.mk_expr(lo.to(self.prev_token.span), ExprKind::Err);\n+                if res.id == DUMMY_NODE_ID {\n+                    //panic!(\"debug now ....: {:?}\", res);\n+                    res\n+                } else {\n+                    res\n+                }\n             }\n         }\n     }\n@@ -1902,7 +1871,7 @@ impl<'a> Parser<'a> {\n                         && brace_depth == 0\n                         && bracket_depth == 0 =>\n                 {\n-                    debug!(\"recover_stmt_ return - Semi\");\n+                    debug!(\"recover_stmt_ return - Comma\");\n                     break;\n                 }\n                 _ => self.bump(),"}, {"sha": "7c55ac9cce2a2786f20a83390a83e03a91673c6a", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 36, "deletions": 69, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -174,10 +174,8 @@ impl<'a> Parser<'a> {\n                 self.parse_expr_prefix(attrs)?\n             }\n         };\n-        let last_type_ascription_set = self.last_type_ascription.is_some();\n \n         if !self.should_continue_as_assoc_expr(&lhs) {\n-            self.last_type_ascription = None;\n             return Ok(lhs);\n         }\n \n@@ -296,14 +294,22 @@ impl<'a> Parser<'a> {\n                 continue;\n             }\n \n+            // Special cases:\n+            if op.node == AssocOp::As {\n+                lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n+                continue;\n+            } else if op.node == AssocOp::DotDot || op.node == AssocOp::DotDotEq {\n+                // If we didn't have to handle `x..`/`x..=`, it would be pretty easy to\n+                // generalise it to the Fixity::None code.\n+                lhs = self.parse_expr_range(prec, lhs, op.node, cur_op_span)?;\n+                break;\n+            }\n+\n             let op = op.node;\n             // Special cases:\n             if op == AssocOp::As {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue;\n-            } else if op == AssocOp::Colon {\n-                lhs = self.parse_assoc_op_ascribe(lhs, lhs_span)?;\n-                continue;\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn't have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n@@ -364,7 +370,7 @@ impl<'a> Parser<'a> {\n                     let aopexpr = self.mk_assign_op(source_map::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(span, aopexpr)\n                 }\n-                AssocOp::As | AssocOp::Colon | AssocOp::DotDot | AssocOp::DotDotEq => {\n+                AssocOp::As | AssocOp::DotDot | AssocOp::DotDotEq => {\n                     self.span_bug(span, \"AssocOp should have been handled by special case\")\n                 }\n             };\n@@ -373,9 +379,7 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n         }\n-        if last_type_ascription_set {\n-            self.last_type_ascription = None;\n-        }\n+\n         Ok(lhs)\n     }\n \n@@ -615,7 +619,9 @@ impl<'a> Parser<'a> {\n             token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n-            _ => return this.parse_expr_dot_or_call(Some(attrs)),\n+            _ => {\n+                return this.parse_expr_dot_or_call(Some(attrs));\n+            }\n         }\n     }\n \n@@ -743,7 +749,7 @@ impl<'a> Parser<'a> {\n                     (\n                         // `foo: `\n                         ExprKind::Path(None, ast::Path { segments, .. }),\n-                        TokenKind::Ident(kw::For | kw::Loop | kw::While, false),\n+                        token::Ident(kw::For | kw::Loop | kw::While, false),\n                     ) if segments.len() == 1 => {\n                         let snapshot = self.create_snapshot_for_diagnostic();\n                         let label = Label {\n@@ -838,21 +844,19 @@ impl<'a> Parser<'a> {\n         &mut self,\n         cast_expr: P<Expr>,\n     ) -> PResult<'a, P<Expr>> {\n+        if let ExprKind::Type(_, _) = cast_expr.kind {\n+            panic!(\"ExprKind::Type must not be parsed\");\n+        }\n+\n         let span = cast_expr.span;\n-        let (cast_kind, maybe_ascription_span) =\n-            if let ExprKind::Type(ascripted_expr, _) = &cast_expr.kind {\n-                (\"type ascription\", Some(ascripted_expr.span.shrink_to_hi().with_hi(span.hi())))\n-            } else {\n-                (\"cast\", None)\n-            };\n \n         let with_postfix = self.parse_expr_dot_or_call_with_(cast_expr, span)?;\n \n         // Check if an illegal postfix operator has been added after the cast.\n         // If the resulting expression is not a cast, it is an illegal postfix operator.\n-        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) {\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _)) {\n             let msg = format!(\n-                \"{cast_kind} cannot be followed by {}\",\n+                \"cast cannot be followed by {}\",\n                 match with_postfix.kind {\n                     ExprKind::Index(_, _) => \"indexing\",\n                     ExprKind::Try(_) => \"`?`\",\n@@ -878,44 +882,13 @@ impl<'a> Parser<'a> {\n                 );\n             };\n \n-            // If type ascription is \"likely an error\", the user will already be getting a useful\n-            // help message, and doesn't need a second.\n-            if self.last_type_ascription.map_or(false, |last_ascription| last_ascription.1) {\n-                self.maybe_annotate_with_ascription(&mut err, false);\n-            } else if let Some(ascription_span) = maybe_ascription_span {\n-                let is_nightly = self.sess.unstable_features.is_nightly_build();\n-                if is_nightly {\n-                    suggest_parens(&mut err);\n-                }\n-                err.span_suggestion(\n-                    ascription_span,\n-                    &format!(\n-                        \"{}remove the type ascription\",\n-                        if is_nightly { \"alternatively, \" } else { \"\" }\n-                    ),\n-                    \"\",\n-                    if is_nightly {\n-                        Applicability::MaybeIncorrect\n-                    } else {\n-                        Applicability::MachineApplicable\n-                    },\n-                );\n-            } else {\n-                suggest_parens(&mut err);\n-            }\n+            suggest_parens(&mut err);\n+\n             err.emit();\n         };\n         Ok(with_postfix)\n     }\n \n-    fn parse_assoc_op_ascribe(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n-        let maybe_path = self.could_ascription_be_path(&lhs.kind);\n-        self.last_type_ascription = Some((self.prev_token.span, maybe_path));\n-        let lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-        self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n-        Ok(lhs)\n-    }\n-\n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n     fn parse_expr_borrow(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n@@ -1010,7 +983,7 @@ impl<'a> Parser<'a> {\n             };\n             if has_dot {\n                 // expr.f\n-                e = self.parse_expr_dot_suffix(lo, e)?;\n+                e = self.parse_dot_suffix_expr(lo, e)?;\n                 continue;\n             }\n             if self.expr_is_complete(&e) {\n@@ -1024,13 +997,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn look_ahead_type_ascription_as_field(&mut self) -> bool {\n-        self.look_ahead(1, |t| t.is_ident())\n-            && self.look_ahead(2, |t| t == &token::Colon)\n-            && self.look_ahead(3, |t| t.can_begin_expr())\n-    }\n-\n-    fn parse_expr_dot_suffix(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         match self.token.uninterpolate().kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n@@ -1183,9 +1150,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a function call expression, `expr(...)`.\n     fn parse_expr_fn_call(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n-        let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n-            && self.look_ahead_type_ascription_as_field()\n-        {\n+        let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis) {\n             Some((self.create_snapshot_for_diagnostic(), fun.kind.clone()))\n         } else {\n             None\n@@ -1216,7 +1181,6 @@ impl<'a> Parser<'a> {\n         if !self.may_recover() {\n             return None;\n         }\n-\n         match (seq.as_mut(), snapshot) {\n             (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 snapshot.bump(); // `(`\n@@ -1260,9 +1224,7 @@ impl<'a> Parser<'a> {\n                         return Some(self.mk_expr_err(span));\n                     }\n                     Ok(_) => {}\n-                    Err(mut err) => {\n-                        err.emit();\n-                    }\n+                    Err(err) => err.cancel(),\n                 }\n             }\n             _ => {}\n@@ -1516,7 +1478,6 @@ impl<'a> Parser<'a> {\n             let mac = P(MacCall {\n                 path,\n                 args: self.parse_delim_args()?,\n-                prior_type_ascription: self.last_type_ascription,\n             });\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))\n         } else if self.check(&token::OpenDelim(Delimiter::Brace))\n@@ -1535,7 +1496,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_expr_labeled(\n+    pub(super) fn parse_expr_labeled(\n         &mut self,\n         label_: Label,\n         mut consume_colon: bool,\n@@ -3013,6 +2974,11 @@ impl<'a> Parser<'a> {\n                     } else {\n                         e.span_label(pth.span, \"while parsing this struct\");\n                     }\n+\n+                    if !recover {\n+                        return Err(e);\n+                    }\n+\n                     e.emit();\n \n                     // If the next token is a comma, then try to parse\n@@ -3024,6 +2990,7 @@ impl<'a> Parser<'a> {\n                             break;\n                         }\n                     }\n+\n                     None\n                 }\n             };"}, {"sha": "64ff7f1fb2c10c96909baf9cb819d12f313d7050", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -443,7 +443,7 @@ impl<'a> Parser<'a> {\n             Ok(args) => {\n                 self.eat_semi_for_macro_if_needed(&args);\n                 self.complain_if_pub_macro(vis, false);\n-                Ok(MacCall { path, args, prior_type_ascription: self.last_type_ascription })\n+                Ok(MacCall { path, args })\n             }\n \n             Err(mut err) => {"}, {"sha": "93a01fafa103e47d001f5dcf37617d39f5f3eea4", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -148,9 +148,6 @@ pub struct Parser<'a> {\n     max_angle_bracket_count: u32,\n \n     last_unexpected_token_span: Option<Span>,\n-    /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n-    /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n-    pub last_type_ascription: Option<(Span, bool /* likely path typo */)>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     subparser_name: Option<&'static str>,\n     capture_state: CaptureState,\n@@ -165,7 +162,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 288);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 320);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -470,7 +467,6 @@ impl<'a> Parser<'a> {\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n             last_unexpected_token_span: None,\n-            last_type_ascription: None,\n             subparser_name,\n             capture_state: CaptureState {\n                 capturing: Capturing::No,\n@@ -832,10 +828,11 @@ impl<'a> Parser<'a> {\n     }\n \n     fn expect_any_with_type(&mut self, kets: &[&TokenKind], expect: TokenExpectType) -> bool {\n-        kets.iter().any(|k| match expect {\n+        let res = kets.iter().any(|k| match expect {\n             TokenExpectType::Expect => self.check(k),\n             TokenExpectType::NoExpect => self.token == **k,\n-        })\n+        });\n+        res\n     }\n \n     fn parse_seq_to_before_tokens<T>(\n@@ -941,10 +938,14 @@ impl<'a> Parser<'a> {\n                                         // propagate the help message from sub error 'e' to main error 'expect_err;\n                                         expect_err.children.push(xx.clone());\n                                     }\n-                                    expect_err.emit();\n-\n                                     e.cancel();\n-                                    break;\n+                                    if self.token == token::Colon {\n+                                        // we will try to recover in `maybe_recover_struct_lit_bad_delims`\n+                                        return Err(expect_err);\n+                                    } else {\n+                                        expect_err.emit();\n+                                        break;\n+                                    }\n                                 }\n                             }\n                         }\n@@ -959,7 +960,6 @@ impl<'a> Parser<'a> {\n             let t = f(self)?;\n             v.push(t);\n         }\n-\n         Ok((v, trailing, recovered))\n     }\n \n@@ -1045,6 +1045,7 @@ impl<'a> Parser<'a> {\n         f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     ) -> PResult<'a, (ThinVec<T>, bool /* trailing */)> {\n         let (val, trailing, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+\n         if !recovered {\n             self.eat(ket);\n         }"}, {"sha": "3c4b2977af93ab72785fca258e1532833ce1b6fa", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -406,11 +406,11 @@ impl<'a> Parser<'a> {\n             // Parse pattern starting with a path\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Pat)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(PathStyle::Expr)?)\n+                (None, self.parse_path(PathStyle::Pat)?)\n             };\n             let span = lo.to(self.prev_token.span);\n \n@@ -666,7 +666,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n         let args = self.parse_delim_args()?;\n-        let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n+        let mac = P(MacCall { path, args });\n         Ok(PatKind::MacCall(mac))\n     }\n \n@@ -789,11 +789,11 @@ impl<'a> Parser<'a> {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Pat)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n-                (None, self.parse_path(PathStyle::Expr)?)\n+                (None, self.parse_path(PathStyle::Pat)?)\n             };\n             let hi = self.prev_token.span;\n             Ok(self.mk_expr(lo.to(hi), ExprKind::Path(qself, path)))"}, {"sha": "323588c4ff5924f241b24b7656e9daa58766b7c2", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,6 @@\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{Parser, Restrictions, TokenType};\n+use crate::errors::PathSingleColon;\n use crate::{errors, maybe_whole};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n@@ -8,23 +9,35 @@ use rustc_ast::{\n     AssocConstraintKind, BlockCheckMode, GenericArg, GenericArgs, Generics, ParenthesizedArgs,\n     Path, PathSegment, QSelf,\n };\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::{pluralize, Applicability, IntoDiagnostic, PResult};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::symbol::{kw, sym, Ident};\n use std::mem;\n use thin_vec::ThinVec;\n use tracing::debug;\n \n /// Specifies how to parse a path.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PathStyle {\n     /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n     /// with something else. For example, in expressions `segment < ....` can be interpreted\n     /// as a comparison and `segment ( ....` can be interpreted as a function call.\n     /// In all such contexts the non-path interpretation is preferred by default for practical\n     /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n     /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n+    ///\n+    /// Also, a path may never be followed by a `:`. This means that we can eagerly recover if\n+    /// we encounter it.\n     Expr,\n+    /// The same as `Expr`, but may be followed by a `:`.\n+    /// For example, this code:\n+    /// ```rust\n+    /// struct S;\n+    ///\n+    /// let S: S;\n+    /// //  ^ Followed by a `:`\n+    /// ```\n+    Pat,\n     /// In other contexts, notably in types, no ambiguity exists and paths can be written\n     /// without the disambiguator, e.g., `x<y>` - unambiguously a path.\n     /// Paths with disambiguators are still accepted, `x::<Y>` - unambiguously a path too.\n@@ -38,6 +51,12 @@ pub enum PathStyle {\n     Mod,\n }\n \n+impl PathStyle {\n+    fn has_generic_ambiguity(&self) -> bool {\n+        matches!(self, Self::Expr | Self::Pat)\n+    }\n+}\n+\n impl<'a> Parser<'a> {\n     /// Parses a qualified path.\n     /// Assumes that the leading `<` has been parsed already.\n@@ -183,7 +202,9 @@ impl<'a> Parser<'a> {\n             segments.push(PathSegment::path_root(lo.shrink_to_lo().with_ctxt(mod_sep_ctxt)));\n         }\n         self.parse_path_segments(&mut segments, style, ty_generics)?;\n-\n+        if segments.len() > 1 {\n+            //panic!(\"debug now ...\");\n+        }\n         Ok(Path { segments, span: lo.to(self.prev_token.span), tokens: None })\n     }\n \n@@ -195,7 +216,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, ()> {\n         loop {\n             let segment = self.parse_path_segment(style, ty_generics)?;\n-            if style == PathStyle::Expr {\n+            if style.has_generic_ambiguity() {\n                 // In order to check for trailing angle brackets, we must have finished\n                 // recursing (`parse_path_segment` can indirectly call this function),\n                 // that is, the next token must be the highlighted part of the below example:\n@@ -217,6 +238,29 @@ impl<'a> Parser<'a> {\n             segments.push(segment);\n \n             if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                if style == PathStyle::Expr\n+                    && self.may_recover()\n+                    && self.token == token::Colon\n+                    && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+                {\n+                    // Emit a special error message for `a::b:c` to help users\n+                    // otherwise, `a: c` might have meant to introduce a new binding\n+                    if self.token.span.lo() == self.prev_token.span.hi()\n+                        && self.look_ahead(1, |token| self.token.span.hi() == token.span.lo())\n+                    {\n+                        self.bump(); // bump past the colon\n+                        self.sess.emit_err(PathSingleColon {\n+                            span: self.prev_token.span,\n+                            type_ascription: self\n+                                .sess\n+                                .unstable_features\n+                                .is_nightly_build()\n+                                .then_some(()),\n+                        });\n+                    }\n+                    continue;\n+                }\n+\n                 return Ok(());\n             }\n         }\n@@ -270,8 +314,25 @@ impl<'a> Parser<'a> {\n                         ty_generics,\n                     )?;\n                     self.expect_gt().map_err(|mut err| {\n+                        // Try to recover a `:` into a `::`\n+                        if self.token == token::Colon\n+                            && self.look_ahead(1, |token| {\n+                                token.is_ident() && !token.is_reserved_ident()\n+                            })\n+                        {\n+                            err.cancel();\n+                            err = PathSingleColon {\n+                                span: self.token.span,\n+                                type_ascription: self\n+                                    .sess\n+                                    .unstable_features\n+                                    .is_nightly_build()\n+                                    .then_some(()),\n+                            }\n+                            .into_diagnostic(self.diagnostic());\n+                        }\n                         // Attempt to find places where a missing `>` might belong.\n-                        if let Some(arg) = args\n+                        else if let Some(arg) = args\n                             .iter()\n                             .rev()\n                             .find(|arg| !matches!(arg, AngleBracketedArg::Constraint(_)))\n@@ -679,6 +740,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         ty_generics: Option<&Generics>,\n     ) -> PResult<'a, Option<GenericArg>> {\n+        debug!(\"pain\");\n         let start = self.token.span;\n         let arg = if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n             // Parse lifetime argument.\n@@ -687,6 +749,7 @@ impl<'a> Parser<'a> {\n             // Parse const argument.\n             GenericArg::Const(self.parse_const_arg()?)\n         } else if self.check_type() {\n+            debug!(\"type\");\n             // Parse type argument.\n \n             // Proactively create a parser snapshot enabling us to rewind and try to reparse the"}, {"sha": "8e8788beeba486040848cfe3fbffe551b62708d7", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 107, "deletions": 20, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -10,6 +10,8 @@ use super::{\n use crate::errors;\n use crate::maybe_whole;\n \n+use crate::errors::MalformedLoopLabel;\n+use ast::Label;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n@@ -19,7 +21,8 @@ use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, HasAttrs, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_span::source_map::{BytePos, Span};\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n+\n use std::mem;\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -186,7 +189,7 @@ impl<'a> Parser<'a> {\n             _ => MacStmtStyle::NoBraces,\n         };\n \n-        let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n+        let mac = P(MacCall { path, args });\n \n         let kind = if (style == MacStmtStyle::Braces\n             && self.token != token::Dot\n@@ -546,10 +549,36 @@ impl<'a> Parser<'a> {\n             }\n             let stmt = match self.parse_full_stmt(recover) {\n                 Err(mut err) if recover.yes() => {\n-                    self.maybe_annotate_with_ascription(&mut err, false);\n                     if let Some(ref mut snapshot) = snapshot {\n                         snapshot.recover_diff_marker();\n                     }\n+                    if self.token == token::Colon {\n+                        // if next token is following a colon, it's likely a path\n+                        // and we can suggest a path separator\n+                        let ident_span = self.prev_token.span;\n+                        self.bump();\n+                        if self.token.span.lo() == self.prev_token.span.hi() {\n+                            err.span_suggestion_verbose(\n+                                self.prev_token.span,\n+                                \"maybe write a path separator here\",\n+                                \"::\",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        if self.look_ahead(1, |token| token == &token::Eq) {\n+                            err.span_suggestion_verbose(\n+                                ident_span.shrink_to_lo(),\n+                                \"you might have meant to introduce a new binding\",\n+                                \"let \",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        if self.sess.unstable_features.is_nightly_build() {\n+                            // FIXME(Nilstrieb): Remove this again after a few months.\n+                            err.note(\"type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\");\n+                        }\n+                    }\n+\n                     err.emit();\n                     self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n                     Some(self.mk_stmt_err(self.token.span))\n@@ -580,19 +609,25 @@ impl<'a> Parser<'a> {\n         };\n \n         let mut eat_semi = true;\n+        let mut add_semi_to_stmt = false;\n+\n         match &mut stmt.kind {\n             // Expression without semicolon.\n             StmtKind::Expr(expr)\n                 if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n                 // `expect_one_of` returns PResult<'a, bool /* recovered */>\n-                let replace_with_err =\n-                    match self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]) {\n+\n+                let expect_result = self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]);\n+\n+                let replace_with_err = 'break_recover: {\n+                    match expect_result {\n                     // Recover from parser, skip type error to avoid extra errors.\n-                    Ok(true) => true,\n-                    Err(mut e) => {\n-                        if let TokenKind::DocComment(..) = self.token.kind &&\n-                            let Ok(snippet) = self.span_to_snippet(self.token.span) {\n+                        Ok(true) => true,\n+                        Err(mut e) => {\n+                            if let TokenKind::DocComment(..) = self.token.kind\n+                                && let Ok(snippet) = self.span_to_snippet(self.token.span)\n+                            {\n                                 let sp = self.token.span;\n                                 let marker = &snippet[..3];\n                                 let (comment_marker, doc_comment_marker) = marker.split_at(2);\n@@ -606,21 +641,72 @@ impl<'a> Parser<'a> {\n                                     format!(\"{} {}\", comment_marker, doc_comment_marker),\n                                     Applicability::MaybeIncorrect,\n                                 );\n-                        }\n+                            }\n+\n+                            if self.recover_colon_as_semi() {\n+                                // recover_colon_as_semi has already emitted a nicer error.\n+                                e.cancel();\n+                                add_semi_to_stmt = true;\n+                                eat_semi = false;\n+\n+                                break 'break_recover false;\n+                            }\n+\n+                            match &expr.kind {\n+                                ExprKind::Path(None, ast::Path { segments, .. }) if segments.len() == 1 => {\n+                                    if self.token == token::Colon\n+                                        && self.look_ahead(1, |token| {\n+                                            token.is_whole_block() || matches!(\n+                                                token.kind,\n+                                                token::Ident(kw::For | kw::Loop | kw::While, false)\n+                                                    | token::OpenDelim(Delimiter::Brace)\n+                                            )\n+                                        })\n+                                    {\n+                                        let snapshot = self.create_snapshot_for_diagnostic();\n+                                        let label = Label {\n+                                            ident: Ident::from_str_and_span(\n+                                                &format!(\"'{}\", segments[0].ident),\n+                                                segments[0].ident.span,\n+                                            ),\n+                                        };\n+                                        match self.parse_expr_labeled(label, false) {\n+                                            Ok(labeled_expr) => {\n+                                                e.cancel();\n+                                                self.sess.emit_err(MalformedLoopLabel {\n+                                                    span: label.ident.span,\n+                                                    correct_label: label.ident,\n+                                                });\n+                                                *expr = labeled_expr;\n+                                                break 'break_recover false;\n+                                            }\n+                                            Err(err) => {\n+                                                err.cancel();\n+                                                self.restore_snapshot(snapshot);\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                _ => {}\n+                            }\n \n-                        if let Err(mut e) =\n-                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n-                        {\n-                            if recover.no() {\n-                                return Err(e);\n+                            if let Err(mut e) =\n+                                self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n+                            {\n+                                if recover.no() {\n+                                    return Err(e);\n+                                }\n+                                e.emit();\n+                                self.recover_stmt();\n                             }\n-                            e.emit();\n-                            self.recover_stmt();\n+\n+                            true\n+\n                         }\n-                        true\n+                        Ok(false) => false\n                     }\n-                    _ => false\n                 };\n+\n                 if replace_with_err {\n                     // We already emitted an error, so don't emit another type error\n                     let sp = expr.span.to(self.prev_token.span);\n@@ -643,9 +729,10 @@ impl<'a> Parser<'a> {\n             StmtKind::Empty | StmtKind::Item(_) | StmtKind::Local(_) | StmtKind::Semi(_) => eat_semi = false,\n         }\n \n-        if eat_semi && self.eat(&token::Semi) {\n+        if add_semi_to_stmt || (eat_semi && self.eat(&token::Semi)) {\n             stmt = stmt.add_trailing_semicolon();\n         }\n+\n         stmt.span = stmt.span.to(self.prev_token.span);\n         Ok(Some(stmt))\n     }"}, {"sha": "37c441fbecb96a54c2630a00dd0d93e5ea0eb9bc", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -317,7 +317,6 @@ impl<'a> Parser<'a> {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n             let mut err = self.struct_span_err(self.token.span, &msg);\n             err.span_label(self.token.span, \"expected type\");\n-            self.maybe_annotate_with_ascription(&mut err, true);\n             return Err(err);\n         };\n \n@@ -651,11 +650,7 @@ impl<'a> Parser<'a> {\n         let path = self.parse_path_inner(PathStyle::Type, ty_generics)?;\n         if self.eat(&token::Not) {\n             // Macro invocation in type position\n-            Ok(TyKind::MacCall(P(MacCall {\n-                path,\n-                args: self.parse_delim_args()?,\n-                prior_type_ascription: self.last_type_ascription,\n-            })))\n+            Ok(TyKind::MacCall(P(MacCall { path, args: self.parse_delim_args()? })))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {\n             // `Trait1 + Trait2 + 'a`\n             self.parse_remaining_bounds_path(ThinVec::new(), path, lo, true)"}, {"sha": "aebd8125e2ca4f4176910aef722abeae9ea6637b", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -777,6 +777,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 .sess\n                 .create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span }),\n             ResolutionError::FailedToResolve { label, suggestion } => {\n+                if label.len() > 0 {\n+                    //panic!(\"debug now\");\n+                }\n+\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0433, \"failed to resolve: {}\", &label);\n                 err.span_label(span, label);"}, {"sha": "3a84a2db86cd5fd6350233bf64c2d61575cb2030", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1345,7 +1345,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n         ignore_binding: Option<&'a NameBinding<'a>>,\n     ) -> PathResult<'a> {\n-        debug!(\"resolve_path(path={:?}, opt_ns={:?}, finalize={:?})\", path, opt_ns, finalize);\n+        debug!(\n+            \"resolve_path(path={:?}, opt_ns={:?}, finalize={:?}) path_len: {}\",\n+            path,\n+            opt_ns,\n+            finalize,\n+            path.len()\n+        );\n \n         let mut module = None;\n         let mut allow_super = true;"}, {"sha": "c1d76920b66daaf709cd32c6d357c15253bd7406", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1264,14 +1264,15 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         finalize: Option<Finalize>,\n     ) -> PathResult<'a> {\n-        self.r.resolve_path_with_ribs(\n+        let res = self.r.resolve_path_with_ribs(\n             path,\n             opt_ns,\n             &self.parent_scope,\n             finalize,\n             Some(&self.ribs),\n             None,\n-        )\n+        );\n+        res\n     }\n \n     // AST resolution\n@@ -3488,10 +3489,6 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         //\n         // Similar thing, for types, happens in `report_errors` above.\n         let report_errors_for_call = |this: &mut Self, parent_err: Spanned<ResolutionError<'a>>| {\n-            if !source.is_call() {\n-                return Some(parent_err);\n-            }\n-\n             // Before we start looking for candidates, we have to get our hands\n             // on the type user is trying to perform invocation on; basically:\n             // we're transforming `HashMap::new` into just `HashMap`.\n@@ -3721,18 +3718,14 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     }\n \n     /// Handles paths that may refer to associated items.\n+    #[instrument(level = \"debug\", skip(self))]\n     fn resolve_qpath(\n         &mut self,\n         qself: &Option<P<QSelf>>,\n         path: &[Segment],\n         ns: Namespace,\n         finalize: Finalize,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n-        debug!(\n-            \"resolve_qpath(qself={:?}, path={:?}, ns={:?}, finalize={:?})\",\n-            qself, path, ns, finalize,\n-        );\n-\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // This is a case like `<T>::B`, where there is no"}, {"sha": "683e9fab8ac051646fa2ee876cac3377420d5996", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -305,6 +305,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n     /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn smart_resolve_report_errors(\n         &mut self,\n         path: &[Segment],\n@@ -350,7 +351,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             return (err, candidates);\n         }\n \n-        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n+        if !self.suggest_missing_let(&mut err, base_error.span) {\n             let mut fallback =\n                 self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n \n@@ -1823,7 +1824,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         start.to(sm.next_point(start))\n     }\n \n-    fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n+    #[instrument(level = \"debug\", skip(self, err))]\n+    fn suggest_missing_let(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n         let sm = self.r.tcx.sess.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n@@ -1878,12 +1880,6 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             }\n                         }\n                     }\n-                    if show_label {\n-                        err.span_label(\n-                            base_span,\n-                            \"expecting a type here because of type ascription\",\n-                        );\n-                    }\n                     return show_label;\n                 }\n             }"}, {"sha": "fea24703ddadf678e30bec05d4ce40aac453bc09", "filename": "tests/ui/consts/auxiliary/external_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fauxiliary%2Fexternal_macro.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -9,6 +9,6 @@\n macro_rules! static_assert {\n     ($test:expr) => {\n         #[allow(dead_code)]\n-        const _: () = [()][!($test: bool) as usize];\n+        const _: () = [()][!($test) as usize];\n     }\n }"}, {"sha": "6d92fa5e14e989034adfb766a090cfaa351e05c7", "filename": "tests/ui/did_you_mean/issue-48492-tuple-destructure-missing-parens.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fissue-48492-tuple-destructure-missing-parens.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -65,6 +65,7 @@ error: unexpected `,` in pattern\n LL |     let women, men: (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()\n    |              ^\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n help: try adding parentheses to match on a tuple\n    |\n LL |     let (women, men): (Vec<Genome>, Vec<Genome>) = genomes.iter().cloned()"}, {"sha": "5c3f0e37df63dfd57f5169ade9ba23247f62581a", "filename": "tests/ui/feature-gates/feature-gate-type_ascription.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // Type ascription is unstable\n \n fn main() {\n-    let a = 10: u8; //~ ERROR type ascription is experimental\n+    let a = type_ascribe!(10, u8); //~ ERROR use of unstable library feature 'type_ascription': placeholder syntax for type ascription\n }"}, {"sha": "d747aea6d177f8abe8f61efc68c5257de5c09b8a", "filename": "tests/ui/feature-gates/feature-gate-type_ascription.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-type_ascription.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: type ascription is experimental\n+error[E0658]: use of unstable library feature 'type_ascription': placeholder syntax for type ascription\n   --> $DIR/feature-gate-type_ascription.rs:4:13\n    |\n-LL |     let a = 10: u8;\n-   |             ^^^^^^\n+LL |     let a = type_ascribe!(10, u8);\n+   |             ^^^^^^^^^^^^\n    |\n    = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n    = help: add `#![feature(type_ascription)]` to the crate attributes to enable"}, {"sha": "b21ff30a27da9212546845e2a038b004140b6dff", "filename": "tests/ui/generic-associated-types/equality-bound.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fequality-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fequality-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fequality-bound.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -36,7 +36,10 @@ error[E0433]: failed to resolve: use of undeclared type `I`\n   --> $DIR/equality-bound.rs:9:41\n    |\n LL | fn sum3<J: Iterator>(i: J) -> i32 where I::Item = i32 {\n-   |                                         ^ use of undeclared type `I`\n+   |                                         ^\n+   |                                         |\n+   |                                         use of undeclared type `I`\n+   |                                         help: a type parameter with a similar name exists: `J`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "b7b93ef1c443b810e0d18cbfc1817d642a3a94f9", "filename": "tests/ui/generic-associated-types/parse/trait-path-missing-gen_arg.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -5,9 +5,6 @@ trait X {\n const _: () = {\n   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n       //~^ ERROR: expected one of `>`, a const expression, lifetime, or type, found `:`\n-      //~| ERROR: expected parameter name, found `>`\n-      //~| ERROR: expected one of `!`, `)`, `+`, `,`, or `::`, found `>`\n-      //~| ERROR: constant provided when a type was expected\n };\n \n const _: () = {"}, {"sha": "bfddb6dc693caac82c3acb63ca9e44e606fac0e1", "filename": "tests/ui/generic-associated-types/parse/trait-path-missing-gen_arg.stderr", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fparse%2Ftrait-path-missing-gen_arg.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,41 +3,14 @@ error: expected one of `>`, a const expression, lifetime, or type, found `:`\n    |\n LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n    |                              ^ expected one of `>`, a const expression, lifetime, or type\n-   |\n-help: expressions must be enclosed in braces to be used as const generic arguments\n-   |\n-LL |   fn f1<'a>(arg : Box<{ dyn X< : 32 } >>) {}\n-   |                       +             +\n-\n-error: expected parameter name, found `>`\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:36\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                                    ^ expected parameter name\n-\n-error: expected one of `!`, `)`, `+`, `,`, or `::`, found `>`\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:36\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                                    ^\n-   |                                    |\n-   |                                    expected one of `!`, `)`, `+`, `,`, or `::`\n-   |                                    help: missing `,`\n \n error: expected one of `>`, a const expression, lifetime, or type, found `=`\n-  --> $DIR/trait-path-missing-gen_arg.rs:14:30\n+  --> $DIR/trait-path-missing-gen_arg.rs:11:30\n    |\n LL |   fn f1<'a>(arg : Box<dyn X< = 32 >>) {}\n    |                            - ^ expected one of `>`, a const expression, lifetime, or type\n    |                            |\n    |                            maybe try to close unmatched angle bracket\n \n-error[E0747]: constant provided when a type was expected\n-  --> $DIR/trait-path-missing-gen_arg.rs:6:23\n-   |\n-LL |   fn f1<'a>(arg : Box<dyn X< : 32 >>) {}\n-   |                       ^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0747`."}, {"sha": "dff00b0b7200752cf4aa6de58e701f45b92d30a5", "filename": "tests/ui/generics/single-colon-path-not-const-generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -6,8 +6,8 @@ pub mod foo {\n \n pub struct Foo {\n   a: Vec<foo::bar:A>,\n-  //~^ ERROR expected\n-  //~| HELP path separator\n+  //~^ ERROR path separator must be a double colon\n+  //~| HELP use a double colon instead\n }\n \n fn main() {}"}, {"sha": "bb34c0ba546b65e781a5a77d8fd8944e124a9cce", "filename": "tests/ui/generics/single-colon-path-not-const-generics.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerics%2Fsingle-colon-path-not-const-generics.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,11 +1,12 @@\n-error: expected one of `,` or `>`, found `:`\n+error: path separator must be a double colon\n   --> $DIR/single-colon-path-not-const-generics.rs:8:18\n    |\n+LL | pub struct Foo {\n+   |            --- while parsing this struct\n LL |   a: Vec<foo::bar:A>,\n-   |                  ^\n-   |                  |\n-   |                  expected one of `,` or `>`\n-   |                  help: write a path separator here: `::`\n+   |                  ^ help: use a double colon instead: `::`\n+   |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "e3ada65049d56cd9667efbbffb591a982f6cd61a", "filename": "tests/ui/issues/issue-22644.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fissues%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fissues%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-22644.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,18 +1,12 @@\n-#![feature(type_ascription)]\n-\n fn main() {\n-    let a : usize = 0;\n-    let long_name : usize = 0;\n+    let a: usize = 0;\n+    let long_name: usize = 0;\n \n     println!(\"{}\", a as usize > long_name);\n     println!(\"{}\", a as usize < long_name); //~ ERROR `<` is interpreted as a start of generic\n     println!(\"{}{}\", a as usize < long_name, long_name);\n     //~^ ERROR `<` is interpreted as a start of generic\n     println!(\"{}\", a as usize < 4); //~ ERROR `<` is interpreted as a start of generic\n-    println!(\"{}\", a: usize > long_name);\n-    println!(\"{}{}\", a: usize < long_name, long_name);\n-    //~^ ERROR `<` is interpreted as a start of generic\n-    println!(\"{}\", a: usize < 4); //~ ERROR `<` is interpreted as a start of generic\n \n     println!(\"{}\", a\n                    as\n@@ -30,6 +24,4 @@ fn main() {\n                    5);\n \n     println!(\"{}\", a as usize << long_name); //~ ERROR `<<` is interpreted as a start of generic\n-\n-    println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n }"}, {"sha": "0799e9ef11b14f767ee96c51574e0ae524551ff9", "filename": "tests/ui/issues/issue-22644.stderr", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fissues%2Fissue-22644.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:8:31\n+  --> $DIR/issue-22644.rs:6:31\n    |\n LL |     println!(\"{}\", a as usize < long_name);\n    |                               ^ --------- interpreted as generic arguments\n@@ -12,7 +12,7 @@ LL |     println!(\"{}\", (a as usize) < long_name);\n    |                    +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:9:33\n+  --> $DIR/issue-22644.rs:7:33\n    |\n LL |     println!(\"{}{}\", a as usize < long_name, long_name);\n    |                                 ^ -------------------- interpreted as generic arguments\n@@ -25,7 +25,7 @@ LL |     println!(\"{}{}\", (a as usize) < long_name, long_name);\n    |                      +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:11:31\n+  --> $DIR/issue-22644.rs:9:31\n    |\n LL |     println!(\"{}\", a as usize < 4);\n    |                               ^ - interpreted as generic arguments\n@@ -38,33 +38,7 @@ LL |     println!(\"{}\", (a as usize) < 4);\n    |                    +          +\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:13:31\n-   |\n-LL |     println!(\"{}{}\", a: usize < long_name, long_name);\n-   |                               ^ -------------------- interpreted as generic arguments\n-   |                               |\n-   |                               not interpreted as comparison\n-   |\n-help: try comparing the cast value\n-   |\n-LL |     println!(\"{}{}\", (a: usize) < long_name, long_name);\n-   |                      +        +\n-\n-error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:15:29\n-   |\n-LL |     println!(\"{}\", a: usize < 4);\n-   |                             ^ - interpreted as generic arguments\n-   |                             |\n-   |                             not interpreted as comparison\n-   |\n-help: try comparing the cast value\n-   |\n-LL |     println!(\"{}\", (a: usize) < 4);\n-   |                    +        +\n-\n-error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:20:20\n+  --> $DIR/issue-22644.rs:14:20\n    |\n LL |                    <\n    |                    ^ not interpreted as comparison\n@@ -79,7 +53,7 @@ LL ~                    usize)\n    |\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:29:20\n+  --> $DIR/issue-22644.rs:23:20\n    |\n LL |                    <\n    |                    ^ not interpreted as comparison\n@@ -96,7 +70,7 @@ LL ~                    usize)\n    |\n \n error: `<<` is interpreted as a start of generic arguments for `usize`, not a shift\n-  --> $DIR/issue-22644.rs:32:31\n+  --> $DIR/issue-22644.rs:26:31\n    |\n LL |     println!(\"{}\", a as usize << long_name);\n    |                               ^^ --------- interpreted as generic arguments\n@@ -108,16 +82,5 @@ help: try shifting the cast value\n LL |     println!(\"{}\", (a as usize) << long_name);\n    |                    +          +\n \n-error: expected type, found `4`\n-  --> $DIR/issue-22644.rs:34:28\n-   |\n-LL |     println!(\"{}\", a: &mut 4);\n-   |                     -      ^ expected type\n-   |                     |\n-   |                     tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "8cd9a63b808934566d5320b8d08180053c6cb9ac", "filename": "tests/ui/macros/builtin-prelude-no-accidents.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fbuiltin-prelude-no-accidents.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -4,18 +4,21 @@ error[E0433]: failed to resolve: use of undeclared crate or module `env`\n LL |     env::current_dir;\n    |     ^^^ use of undeclared crate or module `env`\n \n+error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n+  --> $DIR/builtin-prelude-no-accidents.rs:7:14\n+   |\n+LL |     type B = vec::Vec<u8>;\n+   |              ^^^\n+   |              |\n+   |              use of undeclared crate or module `vec`\n+   |              help: a struct with a similar name exists (notice the capitalization): `Vec`\n+\n error[E0433]: failed to resolve: use of undeclared crate or module `panic`\n   --> $DIR/builtin-prelude-no-accidents.rs:6:14\n    |\n LL |     type A = panic::PanicInfo;\n    |              ^^^^^ use of undeclared crate or module `panic`\n \n-error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n-  --> $DIR/builtin-prelude-no-accidents.rs:7:14\n-   |\n-LL |     type B = vec::Vec<u8>;\n-   |              ^^^ use of undeclared crate or module `vec`\n-\n error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "816f99baa849532f5864696658a094cdd1e20aa9", "filename": "tests/ui/macros/stringify.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fstringify.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -134,8 +134,7 @@ fn test_expr() {\n     assert_eq!(stringify_expr!(expr as T<u8>), \"expr as T<u8>\");\n \n     // ExprKind::Type\n-    assert_eq!(stringify_expr!(expr: T), \"expr: T\");\n-    assert_eq!(stringify_expr!(expr: T<u8>), \"expr: T<u8>\");\n+    // There is no syntax for type ascription.\n \n     // ExprKind::If\n     assert_eq!(stringify_expr!(if true {}), \"if true {}\");"}, {"sha": "23dbb57cbcf0f0320049857b5ca6dc488a5d719d", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -8,9 +8,12 @@ use E::*;\n \n fn no_top_level_or_patterns() {\n     // We do *not* allow or-patterns at the top level of lambdas...\n-    let _ = |A | B: E| (); //~ ERROR no implementation for `E | ()`\n+    let _ = |A | B: E| ();\n+                           //~^ ERROR expected identifier, found\n     //           -------- This looks like an or-pattern but is in fact `|A| (B: E | ())`.\n+}\n \n+fn no_top_level_or_patterns_2() {\n     // ...and for now neither do we allow or-patterns at the top level of functions.\n     fn fun1(A | B: E) {}\n     //~^ ERROR top-level or-patterns are not allowed"}, {"sha": "c16a90368e1940ca4e2c5083402b13cfa16f650c", "filename": "tests/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,43 +1,34 @@\n+error: expected identifier, found `:`\n+  --> $DIR/or-patterns-syntactic-fail.rs:11:19\n+   |\n+LL |     let _ = |A | B: E| ();\n+   |                   ^ expected identifier\n+   |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n error: top-level or-patterns are not allowed in function parameters\n-  --> $DIR/or-patterns-syntactic-fail.rs:15:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:18:13\n    |\n LL |     fn fun1(A | B: E) {}\n    |             ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in function parameters\n-  --> $DIR/or-patterns-syntactic-fail.rs:18:13\n+  --> $DIR/or-patterns-syntactic-fail.rs:21:13\n    |\n LL |     fn fun2(| A | B: E) {}\n    |             ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in `let` bindings\n-  --> $DIR/or-patterns-syntactic-fail.rs:23:9\n+  --> $DIR/or-patterns-syntactic-fail.rs:26:9\n    |\n LL |     let A | B: E = A;\n    |         ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: top-level or-patterns are not allowed in `let` bindings\n-  --> $DIR/or-patterns-syntactic-fail.rs:26:9\n+  --> $DIR/or-patterns-syntactic-fail.rs:29:9\n    |\n LL |     let | A | B: E = A;\n    |         ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n-error[E0369]: no implementation for `E | ()`\n-  --> $DIR/or-patterns-syntactic-fail.rs:11:22\n-   |\n-LL |     let _ = |A | B: E| ();\n-   |                  ----^ -- ()\n-   |                  |\n-   |                  E\n-   |\n-note: an implementation of `BitOr<()>` might be missing for `E`\n-  --> $DIR/or-patterns-syntactic-fail.rs:6:1\n-   |\n-LL | enum E { A, B }\n-   | ^^^^^^ must implement `BitOr<()>`\n-note: the trait `BitOr` must be implemented\n-  --> $SRC_DIR/core/src/ops/bit.rs:LL:COL\n-\n error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0369`."}, {"sha": "d1950087c4c2d8acbf11d7794dc289d5ac22dde1", "filename": "tests/ui/parser/attr-stmt-expr-attr-bad.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -6,6 +6,7 @@ fn main() {}\n //~^ ERROR expected one of\n #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n //~^ ERROR an inner attribute is not permitted in this context\n+//~| ERROR an inner attribute is not permitted in this context\n //~| ERROR expected expression, found `)`\n #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n //~^ ERROR an inner attribute is not permitted in this context"}, {"sha": "9698ad1369a20950bc0bbb9a17690de49f456868", "filename": "tests/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 190, "deletions": 5, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -19,14 +19,27 @@ LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n+error: an inner attribute is not permitted in this context\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:9:36\n+   |\n+LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n+   |                                    ^^^^^^^^\n+   |\n+   = note: inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+   = note: outer attributes, like `#[test]`, annotate the item following them\n+\n error: expected expression, found `)`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:7:44\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = foo(#![attr]); }\n    |                                            ^ expected expression\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:10:38\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:13:38\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                      ^^^^^^^^\n@@ -35,13 +48,13 @@ LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected expression, found `)`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:10:46\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:13:46\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.foo(#![attr]); }\n    |                                              ^ expected expression\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:13:36\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:16:36\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n    |                                    ^^^^^^^^\n@@ -50,7 +63,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = 0 + #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:15:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:18:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n    |                                 ^^^^^^^^\n@@ -59,7 +72,7 @@ LL | #[cfg(FALSE)] fn e() { let _ = !#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:17:33\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:20:33\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    |                                 ^^^^^^^^\n@@ -68,13 +81,17 @@ LL | #[cfg(FALSE)] fn e() { let _ = -#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `!`, `.`, `::`, `;`, `?`, `else`, `{`, or an operator, found `#`\n-  --> $DIR/attr-stmt-expr-attr-bad.rs:19:34\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:22:34\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x #![attr] as Y; }\n    |                                  ^ expected one of 8 possible tokens\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:21:35\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:24:35\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n    |                                   ^^^^^^^^\n@@ -83,7 +100,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] foo; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:23:40\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:26:40\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n    |                                        ^^^^^^^^\n@@ -92,7 +113,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] foo; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:25:35\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:28:35\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n    |                                   ^^^^^^^^\n@@ -101,7 +126,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = || #![attr] {foo}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:27:40\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:30:40\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n    |                                        ^^^^^^^^\n@@ -110,19 +139,31 @@ LL | #[cfg(FALSE)] fn e() { let _ = move || #![attr] {foo}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected expression, found `..`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:29:40\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:32:40\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..#[attr] 0; }\n    |                                        ^^ expected expression\n \n error: expected expression, found `..`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:31:40\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:34:40\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] ..; }\n    |                                        ^^ expected expression\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:33:41\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:36:41\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n    |                                         ^^^^^^^^\n@@ -131,7 +172,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &#![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:35:45\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:38:45\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    |                                             ^^^^^^^^\n@@ -140,7 +185,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = #[attr] &mut #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:37:37\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:40:37\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                --   ^^^^^^^ -- the attributes are attached to this branch\n@@ -149,7 +198,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 #[attr] {}; }\n    |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:39:38\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:42:38\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    |                                      ^^^^^^^^\n@@ -158,13 +211,21 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:41:40\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:44:40\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} #[attr] else {}; }\n    |                                        ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:43:45\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:46:45\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                        ---- ^^^^^^^ -- the attributes are attached to this branch\n@@ -173,7 +234,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] {}; }\n    |                                        the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:45:46\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:48:46\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    |                                              ^^^^^^^^\n@@ -182,7 +247,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:47:45\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:50:45\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                        ---- ^^^^^^^ ------- the attributes are attached to this branch\n@@ -191,7 +260,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else #[attr] if 0 {}; }\n    |                                        the branch belongs to this `else`\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:49:50\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:52:50\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             --   ^^^^^^^ -- the attributes are attached to this branch\n@@ -200,7 +273,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 #[attr] {}; }\n    |                                             the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:51:51\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:54:51\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    |                                                   ^^^^^^^^\n@@ -209,7 +286,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if 0 {} else if 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:53:45\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:56:45\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                --           ^^^^^^^ -- the attributes are attached to this branch\n@@ -218,7 +299,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 #[attr] {}; }\n    |                                the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:55:46\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:58:46\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    |                                              ^^^^^^^^\n@@ -227,13 +312,21 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:57:48\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:60:48\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} #[attr] else {}; }\n    |                                                ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:59:53\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:62:53\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                ---- ^^^^^^^ -- the attributes are attached to this branch\n@@ -242,7 +335,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] {}; }\n    |                                                the branch belongs to this `else`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:61:54\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:64:54\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    |                                                      ^^^^^^^^\n@@ -251,7 +348,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else {#![attr]}; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:63:53\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:66:53\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}; }\n    |                                                ---- ^^^^^^^ --------------- the attributes are attached to this branch\n@@ -260,7 +361,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else #[attr] if let _ = 0 {}\n    |                                                the branch belongs to this `else`\n \n error: outer attributes are not allowed on `if` and `else` branches\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:65:66\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:68:66\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}; }\n    |                                                     --           ^^^^^^^ -- the attributes are attached to this branch\n@@ -269,7 +374,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 #[attr] {}\n    |                                                     the branch belongs to this `if`\n \n error: an inner attribute is not permitted in this context\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:67:67\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:70:67\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}; }\n    |                                                                   ^^^^^^^^\n@@ -278,7 +387,11 @@ LL | #[cfg(FALSE)] fn e() { let _ = if let _ = 0 {} else if let _ = 0 {#![attr]}\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:70:32\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:73:32\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -289,7 +402,11 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] let _ = 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:72:32\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:75:32\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    |                        ------- ^^^^^^^^ not permitted following an outer attribute\n@@ -300,7 +417,11 @@ LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] 0; }\n    = note: outer attributes, like `#[test]`, annotate the item following them\n \n error: an inner attribute is not permitted following an outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:74:32\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:77:32\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!(); }\n    |                        ------- ^^^^^^^^ ------- the inner attribute doesn't annotate this item macro invocation\n@@ -316,7 +437,11 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo!(); }\n    |\n \n error: an inner attribute is not permitted following an outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:76:32\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:79:32\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo![]; }\n    |                        ------- ^^^^^^^^ ------- the inner attribute doesn't annotate this item macro invocation\n@@ -332,7 +457,11 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo![]; }\n    |\n \n error: an inner attribute is not permitted following an outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:78:32\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:81:32\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn s() { #[attr] #![attr] foo!{}; }\n    |                        ------- ^^^^^^^^ ------ the inner attribute doesn't annotate this item macro invocation\n@@ -348,89 +477,145 @@ LL + #[cfg(FALSE)] fn s() { #[attr] #[attr] foo!{}; }\n    |\n \n error[E0586]: inclusive range with no end\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:84:35\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:87:35\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:84:38\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:87:38\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error[E0586]: inclusive range with no end\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:87:35\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:90:35\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:87:38\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:90:38\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:90:39\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:93:39\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=-#[attr] 10 => () } }\n    |                                       ^\n \n error[E0586]: inclusive range with no end\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:92:35\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:95:35\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                   ^^^ help: use `..` instead\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:92:38\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:95:38\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n    |                                      ^ expected one of `=>`, `if`, or `|`\n \n error: unexpected token: `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:96:34\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:96:34\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#![attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: unexpected token: `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:102:34\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^\n \n error: expected one of `.`, `;`, `?`, `else`, or an operator, found `#`\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:99:34\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:102:34\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { let _ = x.#[attr]foo(); }\n    |                                  ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n error: expected statement after outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:104:37\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:107:37\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr]; } } }\n    |                                     ^^^^^^^\n \n error: expected statement after outer attribute\n+<<<<<<< HEAD\n   --> $DIR/attr-stmt-expr-attr-bad.rs:106:37\n+=======\n+  --> $DIR/attr-stmt-expr-attr-bad.rs:109:37\n+>>>>>>> 30182b1d322 (Rip it out)\n    |\n LL | #[cfg(FALSE)] fn e() { { fn foo() { #[attr] } } }\n    |                                     ^^^^^^^\n \n+<<<<<<< HEAD\n error: aborting due to 52 previous errors\n+=======\n+error: aborting due to 54 previous errors\n+>>>>>>> 30182b1d322 (Rip it out)\n \n For more information about this error, try `rustc --explain E0586`."}, {"sha": "39f6727bb61149dffc66af09fe3ca6b93ae50d49", "filename": "tests/ui/parser/dyn-trait-compatibility.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fdyn-trait-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fdyn-trait-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fdyn-trait-compatibility.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,9 +1,3 @@\n-error[E0433]: failed to resolve: use of undeclared crate or module `dyn`\n-  --> $DIR/dyn-trait-compatibility.rs:3:11\n-   |\n-LL | type A1 = dyn::dyn;\n-   |           ^^^ use of undeclared crate or module `dyn`\n-\n error[E0412]: cannot find type `dyn` in this scope\n   --> $DIR/dyn-trait-compatibility.rs:1:11\n    |\n@@ -46,6 +40,18 @@ error[E0412]: cannot find type `dyn` in this scope\n LL | type A3 = dyn<<dyn as dyn>::dyn>;\n    |                ^^^ not found in this scope\n \n+error[E0433]: failed to resolve: use of undeclared crate or module `dyn`\n+  --> $DIR/dyn-trait-compatibility.rs:3:11\n+   |\n+LL | type A1 = dyn::dyn;\n+   |           ^^^ use of undeclared crate or module `dyn`\n+\n+error[E0433]: failed to resolve: use of undeclared crate or module `dyn`\n+  --> $DIR/dyn-trait-compatibility.rs:9:23\n+   |\n+LL | type A3 = dyn<<dyn as dyn>::dyn>;\n+   |                       ^^^ use of undeclared crate or module `dyn`\n+\n error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0405, E0412, E0433."}, {"sha": "9213437458a5917edb29be88787ed8265c5c6eab", "filename": "tests/ui/parser/issue-103869.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissue-103869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissue-103869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissue-103869.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -2,7 +2,6 @@ enum VecOrMap{\n     vec: Vec<usize>,\n     //~^ ERROR expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n     //~| HELP: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n-    //~| ERROR expected item, found `:`\n     map: HashMap<String,usize>\n }\n "}, {"sha": "9eb20e2005a4a7f91a0476f104190eca010fae54", "filename": "tests/ui/parser/issue-103869.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissue-103869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissue-103869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissue-103869.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,16 +1,12 @@\n error: expected one of `(`, `,`, `=`, `{`, or `}`, found `:`\n   --> $DIR/issue-103869.rs:2:8\n    |\n+LL | enum VecOrMap{\n+   |      -------- while parsing this enum\n LL |     vec: Vec<usize>,\n    |        ^ expected one of `(`, `,`, `=`, `{`, or `}`\n    |\n    = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`\n \n-error: expected item, found `:`\n-  --> $DIR/issue-103869.rs:2:8\n-   |\n-LL |     vec: Vec<usize>,\n-   |        ^ expected item\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "3d110adef3e3460c6fb03d643e591d2656583018", "filename": "tests/ui/parser/issues/issue-35813-postfix-after-cast.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -10,22 +10,22 @@ pub fn index_after_as_cast() {\n     vec![1, 2, 3] as Vec<i32>[0];\n     //~^ ERROR: cast cannot be followed by indexing\n     vec![1, 2, 3]: Vec<i32>[0];\n-    //~^ ERROR: type ascription cannot be followed by indexing\n+    //~^ ERROR: expected one of\n }\n \n pub fn index_after_cast_to_index() {\n     (&[0]) as &[i32][0];\n     //~^ ERROR: cast cannot be followed by indexing\n     (&[0i32]): &[i32; 1][0];\n-    //~^ ERROR: type ascription cannot be followed by indexing\n+    //~^ ERROR: expected one of\n }\n \n pub fn cast_after_cast() {\n     if 5u64 as i32 as u16 == 0u16 {\n \n     }\n     if 5u64: u64: u64 == 0u64 {\n-\n+        //~^ ERROR expected `{`, found `:`\n     }\n     let _ = 5u64: u64: u64 as u8 as i8 == 9i8;\n     let _ = 0i32: i32: i32;\n@@ -36,26 +36,46 @@ pub fn cast_after_cast() {\n }\n \n pub fn cast_cast_method_call() {\n-    let _ = 0i32: i32: i32.count_ones();\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0 as i32: i32.count_ones();\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0i32: i32 as i32.count_ones();\n-    //~^ ERROR: cast cannot be followed by a method call\n+    let _ = 0i32: i32: i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_2() {\n+    let _ = 0 as i32: i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_3() {\n+    let _ = 0i32: i32 as i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_4() {\n     let _ = 0 as i32 as i32.count_ones();\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n-    //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32.count_ones(): u32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n-    let _ = 0 as i32.count_ones(): u32;\n+}\n+\n+pub fn cast_cast_method_call_5() {\n+    let _ = 0i32: i32: i32 as u32 as i32.count_ones(); //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_6() {\n+    let _ = 0i32: i32.count_ones(): u32; //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_7() {\n+    let _ = 0 as i32.count_ones(): u32; //~ ERROR expected one of\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32.count_ones() as u32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+}\n+\n+pub fn cast_cast_method_call_8() {\n+    let _ = 0i32: i32.count_ones() as u32; //~ ERROR expected one of\n+}\n+\n+pub fn cast_cast_method_call_9() {\n     let _ = 0 as i32.count_ones() as u32;\n     //~^ ERROR: cast cannot be followed by a method call\n-    let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+}\n+\n+pub fn cast_cast_method_call_10() {\n+    let _ = 0i32: i32: i32.count_ones() as u32 as i32; //~ ERROR expected one of\n }\n \n pub fn multiline_error() {\n@@ -74,8 +94,7 @@ pub fn precedence() {\n pub fn method_calls() {\n     0 as i32.max(0);\n     //~^ ERROR: cast cannot be followed by a method call\n-    0: i32.max(0);\n-    //~^ ERROR: type ascription cannot be followed by a method call\n+    0: i32.max(0); //~ ERROR expected one of\n }\n \n pub fn complex() {\n@@ -84,7 +103,7 @@ pub fn complex() {\n         if true { 33 } else { 44 } as i32.max(0),\n         //~^ ERROR: cast cannot be followed by a method call\n         if true { 33 } else { 44 }: i32.max(0)\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected one of\n     );\n }\n \n@@ -93,7 +112,7 @@ pub fn in_condition() {\n         //~^ ERROR: cast cannot be followed by a method call\n     }\n     if 5u64: u64.max(0) == 0 {\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected `{`, found `:`\n     }\n }\n \n@@ -104,22 +123,22 @@ pub fn inside_block() {\n     } else { false };\n     let _ = if true {\n         5u64: u64.max(0) == 0\n-        //~^ ERROR: type ascription cannot be followed by a method call\n+        //~^ ERROR: expected one of\n     } else { false };\n }\n \n static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n //~^ ERROR: cast cannot be followed by indexing\n \n static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-//~^ ERROR: type ascription cannot be followed by indexing\n+//~^ ERROR: expected one of\n \n \n pub fn cast_then_try() -> Result<u64,u64> {\n     Err(0u64) as Result<u64,u64>?;\n     //~^ ERROR: cast cannot be followed by `?`\n     Err(0u64): Result<u64,u64>?;\n-    //~^ ERROR: type ascription cannot be followed by `?`\n+    //~^ ERROR: expected one of\n     Ok(1)\n }\n \n@@ -131,29 +150,30 @@ pub fn cast_then_call() {\n     drop as F();\n     //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n     drop_ptr: F();\n-    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+    //~^ ERROR: expected identifier, found `:`\n }\n \n pub fn cast_to_fn_should_work() {\n     let drop_ptr = drop as fn(u8);\n     drop as fn(u8);\n     drop_ptr: fn(u8);\n+    //~^ ERROR expected one of\n }\n \n pub fn parens_after_cast_error() {\n     let drop_ptr = drop as fn(u8);\n     drop as fn(u8)(0);\n     //~^ ERROR: cast cannot be followed by a function call\n     drop_ptr: fn(u8)(0);\n-    //~^ ERROR: type ascription cannot be followed by a function call\n+    //~^ ERROR: expected one of\n }\n \n pub async fn cast_then_await() {\n     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n     //~^ ERROR: cast cannot be followed by `.await`\n \n     Box::pin(noop()): Pin<Box<_>>.await;\n-    //~^ ERROR: type ascription cannot be followed by `.await`\n+    //~^ ERROR: expected one of\n }\n \n pub async fn noop() {}\n@@ -167,5 +187,5 @@ pub fn struct_field() {\n     Foo::default() as Foo.bar;\n     //~^ ERROR: cannot be followed by a field access\n     Foo::default(): Foo.bar;\n-    //~^ ERROR: type ascription cannot be followed by a field access\n+    //~^ ERROR expected one of\n }"}, {"sha": "d313c888e51c65f574d5c7df0edc420d68c47124", "filename": "tests/ui/parser/issues/issue-35813-postfix-after-cast.stderr", "status": "modified", "additions": 108, "deletions": 230, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-35813-postfix-after-cast.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -9,21 +9,11 @@ help: try surrounding the expression in parentheses\n LL |     (vec![1, 2, 3] as Vec<i32>)[0];\n    |     +                         +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:12:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:12:18\n    |\n LL |     vec![1, 2, 3]: Vec<i32>[0];\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (vec![1, 2, 3]: Vec<i32>)[0];\n-   |     +                       +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     vec![1, 2, 3]: Vec<i32>[0];\n-LL +     vec![1, 2, 3][0];\n-   |\n+   |                  ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by indexing\n   --> $DIR/issue-35813-postfix-after-cast.rs:17:5\n@@ -36,67 +26,50 @@ help: try surrounding the expression in parentheses\n LL |     ((&[0]) as &[i32])[0];\n    |     +                +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:19:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:19:14\n    |\n LL |     (&[0i32]): &[i32; 1][0];\n-   |     ^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator\n+\n+error: expected `{`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:27:12\n    |\n-LL |     ((&[0i32]): &[i32; 1])[0];\n-   |     +                    +\n-help: alternatively, remove the type ascription\n+LL |     if 5u64: u64: u64 == 0u64 {\n+   |            ^ expected `{`\n    |\n-LL -     (&[0i32]): &[i32; 1][0];\n-LL +     (&[0i32])[0];\n+note: the `if` expression is missing a block after this condition\n+  --> $DIR/issue-35813-postfix-after-cast.rs:27:8\n    |\n+LL |     if 5u64: u64: u64 == 0u64 {\n+   |        ^^^^\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:39:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:39:17\n    |\n LL |     let _ = 0i32: i32: i32.count_ones();\n-   |             ^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32: i32).count_ones();\n-   |             +              +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32: i32.count_ones();\n-LL +     let _ = 0i32: i32.count_ones();\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:41:13\n+error: expected one of `!`, `(`, `.`, `::`, `;`, `<`, `?`, or `else`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:43:21\n    |\n LL |     let _ = 0 as i32: i32.count_ones();\n-   |             ^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0 as i32: i32).count_ones();\n-   |             +             +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0 as i32: i32.count_ones();\n-LL +     let _ = 0 as i32.count_ones();\n+   |                     ^ expected one of 8 possible tokens\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:43:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:47:17\n    |\n LL |     let _ = 0i32: i32 as i32.count_ones();\n-   |             ^^^^^^^^^^^^^^^^\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32 as i32).count_ones();\n-   |             +                +\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:45:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n    |\n LL |     let _ = 0 as i32 as i32.count_ones();\n    |             ^^^^^^^^^^^^^^^\n@@ -106,35 +79,24 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32 as i32).count_ones();\n    |             +               +\n \n-error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:47:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:56:17\n    |\n LL |     let _ = 0i32: i32: i32 as u32 as i32.count_ones();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-LL |     let _ = (0i32: i32: i32 as u32 as i32).count_ones();\n-   |             +                            +\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:49:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:60:17\n    |\n LL |     let _ = 0i32: i32.count_ones(): u32;\n-   |             ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32).count_ones(): u32;\n-   |             +         +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32.count_ones(): u32;\n-LL +     let _ = 0i32.count_ones(): u32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:51:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:64:13\n    |\n LL |     let _ = 0 as i32.count_ones(): u32;\n    |             ^^^^^^^^\n@@ -144,24 +106,24 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32).count_ones(): u32;\n    |             +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:53:13\n+error: expected one of `.`, `;`, `?`, or `else`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:64:34\n    |\n-LL |     let _ = 0i32: i32.count_ones() as u32;\n-   |             ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+LL |     let _ = 0 as i32.count_ones(): u32;\n+   |                                  ^ expected one of `.`, `;`, `?`, or `else`\n    |\n-LL |     let _ = (0i32: i32).count_ones() as u32;\n-   |             +         +\n-help: alternatively, remove the type ascription\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:69:17\n    |\n-LL -     let _ = 0i32: i32.count_ones() as u32;\n-LL +     let _ = 0i32.count_ones() as u32;\n+LL |     let _ = 0i32: i32.count_ones() as u32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:55:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:73:13\n    |\n LL |     let _ = 0 as i32.count_ones() as u32;\n    |             ^^^^^^^^\n@@ -171,24 +133,16 @@ help: try surrounding the expression in parentheses\n LL |     let _ = (0 as i32).count_ones() as u32;\n    |             +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:57:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:78:17\n    |\n LL |     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-   |             ^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     let _ = (0i32: i32: i32).count_ones() as u32 as i32;\n-   |             +              +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     let _ = 0i32: i32: i32.count_ones() as u32 as i32;\n-LL +     let _ = 0i32: i32.count_ones() as u32 as i32;\n+   |                 ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:62:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:82:13\n    |\n LL |       let _ = 0\n    |  _____________^\n@@ -202,7 +156,7 @@ LL ~         as i32)\n    |\n \n error: cast cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:70:18\n+  --> $DIR/issue-35813-postfix-after-cast.rs:90:18\n    |\n LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -213,7 +167,7 @@ LL |     let x: i32 = (&vec![1, 2, 3] as &Vec<i32>)[0];\n    |                  +                           +\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:75:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:95:5\n    |\n LL |     0 as i32.max(0);\n    |     ^^^^^^^^\n@@ -223,24 +177,14 @@ help: try surrounding the expression in parentheses\n LL |     (0 as i32).max(0);\n    |     +        +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:77:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:97:6\n    |\n LL |     0: i32.max(0);\n-   |     ^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (0: i32).max(0);\n-   |     +      +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     0: i32.max(0);\n-LL +     0.max(0);\n-   |\n+   |      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:92:8\n+  --> $DIR/issue-35813-postfix-after-cast.rs:111:8\n    |\n LL |     if 5u64 as i32.max(0) == 0 {\n    |        ^^^^^^^^^^^\n@@ -250,24 +194,20 @@ help: try surrounding the expression in parentheses\n LL |     if (5u64 as i32).max(0) == 0 {\n    |        +           +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:95:8\n+error: expected `{`, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:12\n    |\n LL |     if 5u64: u64.max(0) == 0 {\n-   |        ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     if (5u64: u64).max(0) == 0 {\n-   |        +         +\n-help: alternatively, remove the type ascription\n+   |            ^ expected `{`\n    |\n-LL -     if 5u64: u64.max(0) == 0 {\n-LL +     if 5u64.max(0) == 0 {\n+note: the `if` expression is missing a block after this condition\n+  --> $DIR/issue-35813-postfix-after-cast.rs:114:8\n    |\n+LL |     if 5u64: u64.max(0) == 0 {\n+   |        ^^^^\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:102:9\n+  --> $DIR/issue-35813-postfix-after-cast.rs:121:9\n    |\n LL |         5u64 as u32.max(0) == 0\n    |         ^^^^^^^^^^^\n@@ -277,24 +217,14 @@ help: try surrounding the expression in parentheses\n LL |         (5u64 as u32).max(0) == 0\n    |         +           +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:106:9\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:125:13\n    |\n LL |         5u64: u64.max(0) == 0\n-   |         ^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |         (5u64: u64).max(0) == 0\n-   |         +         +\n-help: alternatively, remove the type ascription\n-   |\n-LL -         5u64: u64.max(0) == 0\n-LL +         5u64.max(0) == 0\n-   |\n+   |             ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:111:24\n+  --> $DIR/issue-35813-postfix-after-cast.rs:130:24\n    |\n LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n    |                        ^^^^^^^^^^^^^^^^^^\n@@ -304,24 +234,14 @@ help: try surrounding the expression in parentheses\n LL | static bar: &[i32] = &((&[1,2,3] as &[i32])[0..1]);\n    |                        +                  +\n \n-error: type ascription cannot be followed by indexing\n-  --> $DIR/issue-35813-postfix-after-cast.rs:114:25\n+error: expected one of `)`, `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:133:36\n    |\n LL | static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL | static bar2: &[i32] = &((&[1i32,2,3]: &[i32; 3])[0..1]);\n-   |                         +                      +\n-help: alternatively, remove the type ascription\n-   |\n-LL - static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n-LL + static bar2: &[i32] = &(&[1i32,2,3][0..1]);\n-   |\n+   |                                    ^ expected one of `)`, `,`, `.`, `?`, or an operator\n \n error: cast cannot be followed by `?`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:119:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:138:5\n    |\n LL |     Err(0u64) as Result<u64,u64>?;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -331,24 +251,28 @@ help: try surrounding the expression in parentheses\n LL |     (Err(0u64) as Result<u64,u64>)?;\n    |     +                            +\n \n-error: type ascription cannot be followed by `?`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:121:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:140:14\n    |\n LL |     Err(0u64): Result<u64,u64>?;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n+   |              ^ expected one of `.`, `;`, `?`, `}`, or an operator\n+\n+error: expected identifier, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:152:13\n    |\n-LL |     (Err(0u64): Result<u64,u64>)?;\n-   |     +                          +\n-help: alternatively, remove the type ascription\n+LL |     drop_ptr: F();\n+   |             ^ expected identifier\n    |\n-LL -     Err(0u64): Result<u64,u64>?;\n-LL +     Err(0u64)?;\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:159:13\n    |\n+LL |     drop_ptr: fn(u8);\n+   |             ^ expected one of 8 possible tokens\n \n error: cast cannot be followed by a function call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:145:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:165:5\n    |\n LL |     drop as fn(u8)(0);\n    |     ^^^^^^^^^^^^^^\n@@ -358,24 +282,14 @@ help: try surrounding the expression in parentheses\n LL |     (drop as fn(u8))(0);\n    |     +              +\n \n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:147:5\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:167:13\n    |\n LL |     drop_ptr: fn(u8)(0);\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (drop_ptr: fn(u8))(0);\n-   |     +                +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     drop_ptr: fn(u8)(0);\n-LL +     drop_ptr(0);\n-   |\n+   |             ^ expected one of 8 possible tokens\n \n error: cast cannot be followed by `.await`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:152:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:172:5\n    |\n LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -385,24 +299,14 @@ help: try surrounding the expression in parentheses\n LL |     (Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>).await;\n    |     +                                                     +\n \n-error: type ascription cannot be followed by `.await`\n-  --> $DIR/issue-35813-postfix-after-cast.rs:155:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:175:21\n    |\n LL |     Box::pin(noop()): Pin<Box<_>>.await;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (Box::pin(noop()): Pin<Box<_>>).await;\n-   |     +                             +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     Box::pin(noop()): Pin<Box<_>>.await;\n-LL +     Box::pin(noop()).await;\n-   |\n+   |                     ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a field access\n-  --> $DIR/issue-35813-postfix-after-cast.rs:167:5\n+  --> $DIR/issue-35813-postfix-after-cast.rs:187:5\n    |\n LL |     Foo::default() as Foo.bar;\n    |     ^^^^^^^^^^^^^^^^^^^^^\n@@ -412,24 +316,14 @@ help: try surrounding the expression in parentheses\n LL |     (Foo::default() as Foo).bar;\n    |     +                     +\n \n-error: type ascription cannot be followed by a field access\n-  --> $DIR/issue-35813-postfix-after-cast.rs:169:5\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:189:19\n    |\n LL |     Foo::default(): Foo.bar;\n-   |     ^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |     (Foo::default(): Foo).bar;\n-   |     +                   +\n-help: alternatively, remove the type ascription\n-   |\n-LL -     Foo::default(): Foo.bar;\n-LL +     Foo::default().bar;\n-   |\n+   |                   ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: cast cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:84:9\n+  --> $DIR/issue-35813-postfix-after-cast.rs:103:9\n    |\n LL |         if true { 33 } else { 44 } as i32.max(0),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -439,34 +333,18 @@ help: try surrounding the expression in parentheses\n LL |         (if true { 33 } else { 44 } as i32).max(0),\n    |         +                                 +\n \n-error: type ascription cannot be followed by a method call\n-  --> $DIR/issue-35813-postfix-after-cast.rs:86:9\n+error: expected one of `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:105:35\n    |\n LL |         if true { 33 } else { 44 }: i32.max(0)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-help: try surrounding the expression in parentheses\n-   |\n-LL |         (if true { 33 } else { 44 }: i32).max(0)\n-   |         +                               +\n-help: alternatively, remove the type ascription\n-   |\n-LL -         if true { 33 } else { 44 }: i32.max(0)\n-LL +         if true { 33 } else { 44 }.max(0)\n-   |\n+   |                                   ^ expected one of `,`, `.`, `?`, or an operator\n \n error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-35813-postfix-after-cast.rs:131:13\n+  --> $DIR/issue-35813-postfix-after-cast.rs:150:13\n    |\n LL |     drop as F();\n    |             ^^^ only `Fn` traits may use parentheses\n \n-error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-35813-postfix-after-cast.rs:133:15\n-   |\n-LL |     drop_ptr: F();\n-   |               ^^^ only `Fn` traits may use parentheses\n-\n-error: aborting due to 36 previous errors\n+error: aborting due to 39 previous errors\n \n For more information about this error, try `rustc --explain E0214`."}, {"sha": "6719e5828483614d642f967bd3b5cb8722a20cb1", "filename": "tests/ui/parser/issues/issue-44406.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -6,5 +6,4 @@ macro_rules! foo {\n \n fn main() {\n     foo!(true);\n-    //~^ ERROR expected identifier, found keyword\n }"}, {"sha": "69ff64c2772de92f24daff8a8f5e119d4a3286c1", "filename": "tests/ui/parser/issues/issue-44406.stderr", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-44406.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,14 +1,3 @@\n-error: expected identifier, found keyword `true`\n-  --> $DIR/issue-44406.rs:8:10\n-   |\n-LL |     foo!(true);\n-   |          ^^^^ expected identifier, found keyword\n-   |\n-help: escape `true` to use it as an identifier\n-   |\n-LL |     foo!(r#true);\n-   |          ++\n-\n error: invalid `struct` delimiters or `fn` call arguments\n   --> $DIR/issue-44406.rs:3:9\n    |\n@@ -29,5 +18,5 @@ LL -         bar(baz: $rest)\n LL +         bar(: $rest)\n    |\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "80e0940ad8f85c660ea5b3d56beba4a5385bc8a1", "filename": "tests/ui/parser/issues/issue-91461.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,6 +1,5 @@\n fn main() {\n     a(_:b:,)\n-    //~^ ERROR: expected identifier, found reserved identifier `_`\n-    //~| ERROR: expected type, found `,`\n-    //~| ERROR: expected type, found `,`\n+    //~^ ERROR expected identifier, found reserved identifier\n+    //~| ERROR: expected one of\n }"}, {"sha": "27e1b5cdc177ffc612ed7dd7043d884455ffdfed", "filename": "tests/ui/parser/issues/issue-91461.stderr", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Fissues%2Fissue-91461.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -4,28 +4,11 @@ error: expected identifier, found reserved identifier `_`\n LL |     a(_:b:,)\n    |       ^ expected identifier, found reserved identifier\n \n-error: expected type, found `,`\n-  --> $DIR/issue-91461.rs:2:11\n+error: expected one of `)`, `,`, `.`, `?`, or an operator, found `:`\n+  --> $DIR/issue-91461.rs:2:8\n    |\n LL |     a(_:b:,)\n-   |     -    -^ expected type\n-   |     |    |\n-   |     |    tried to parse a type due to this type ascription\n-   |     while parsing this struct\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-\n-error: expected type, found `,`\n-  --> $DIR/issue-91461.rs:2:11\n-   |\n-LL |     a(_:b:,)\n-   |          -^ expected type\n-   |          |\n-   |          tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   |        ^ expected one of `)`, `,`, `.`, `?`, or an operator\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "01a978d55574bb6096f2e8e49608dd651a7f71ea", "filename": "tests/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -22,8 +22,7 @@ fn case_1() {\n #[cfg(FALSE)]\n fn case_2() {\n     let a @ (b: u8);\n-    //~^ ERROR expected one of `!`\n-    //~| ERROR expected one of `)`\n+    //~^ ERROR expected one of `)`\n }\n \n #[cfg(FALSE)]"}, {"sha": "0c109ff6bbad12dbfde2aaeb9787005071dfb044", "filename": "tests/ui/pattern/bindings-after-at/nested-type-ascription-syntactically-invalid.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-type-ascription-syntactically-invalid.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -9,18 +9,14 @@ error: expected one of `)`, `,`, `@`, or `|`, found `:`\n    |\n LL |     let a @ (b: u8);\n    |               ^ expected one of `)`, `,`, `@`, or `|`\n-\n-error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `)`\n-  --> $DIR/nested-type-ascription-syntactically-invalid.rs:24:19\n    |\n-LL |     let a @ (b: u8);\n-   |                   ^ expected one of 7 possible tokens\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: expected one of `!`, `(`, `+`, `::`, `;`, `<`, or `=`, found `@`\n-  --> $DIR/nested-type-ascription-syntactically-invalid.rs:31:15\n+  --> $DIR/nested-type-ascription-syntactically-invalid.rs:30:15\n    |\n LL |     let a: T1 @ Outer(b: T2);\n    |               ^ expected one of 7 possible tokens\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "10fcccb030162357e4489769e7e601c8ff27226e", "filename": "tests/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,9 +1,3 @@\n-error[E0433]: failed to resolve: use of undeclared type `E`\n-  --> $DIR/pattern-error-continue.rs:33:9\n-   |\n-LL |         E::V => {}\n-   |         ^ use of undeclared type `E`\n-\n error[E0532]: expected tuple struct or tuple variant, found unit variant `A::D`\n   --> $DIR/pattern-error-continue.rs:18:9\n    |\n@@ -56,6 +50,15 @@ note: function defined here\n LL | fn f(_c: char) {}\n    |    ^ --------\n \n+error[E0433]: failed to resolve: use of undeclared type `E`\n+  --> $DIR/pattern-error-continue.rs:33:9\n+   |\n+LL |         E::V => {}\n+   |         ^\n+   |         |\n+   |         use of undeclared type `E`\n+   |         help: an enum with a similar name exists: `A`\n+\n error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0023, E0308, E0433, E0532."}, {"sha": "2b557d9f36931d01bdf01bd4fea8464939f6d3e0", "filename": "tests/ui/resolve/resolve-variant-assoc-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,5 +3,5 @@ use E::V;\n \n fn main() {\n     E::V::associated_item; //~ ERROR failed to resolve: `V` is a variant, not a module\n-    V::associated_item; //~ ERROR failed to resolve: `V` is a variant, not a module\n+    V::associated_item(); //~ ERROR failed to resolve: `V` is a variant, not a module\n }"}, {"sha": "2a46ae9ccc6a263e715e972842483638c70302f1", "filename": "tests/ui/resolve/resolve-variant-assoc-item.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fresolve-variant-assoc-item.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,12 +3,26 @@ error[E0433]: failed to resolve: `V` is a variant, not a module\n    |\n LL |     E::V::associated_item;\n    |        ^ `V` is a variant, not a module\n+   |\n+help: there is an enum variant `E::V`; try using the variant's enum\n+   |\n+LL |     E;\n+   |     ~\n \n error[E0433]: failed to resolve: `V` is a variant, not a module\n   --> $DIR/resolve-variant-assoc-item.rs:6:5\n    |\n-LL |     V::associated_item;\n+LL |     V::associated_item();\n    |     ^ `V` is a variant, not a module\n+   |\n+help: there is an enum variant `E::V`; try using the variant's enum\n+   |\n+LL |     E();\n+   |     ~\n+help: an enum with a similar name exists\n+   |\n+LL |     E::associated_item();\n+   |     ~\n \n error: aborting due to 2 previous errors\n "}, {"sha": "cc2406d6690e3b193d1ee19b7df9649851fafde2", "filename": "tests/ui/suggestions/many-type-ascription.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let _ = 0: i32; //~ ERROR: type ascription is experimental\n+    let _ = 0: i32; //~ ERROR: expected one of\n     let _ = 0: i32; // (error only emitted once)\n }"}, {"sha": "e36919c82f83255d06e83e3b22e2d694a1274668", "filename": "tests/ui/suggestions/many-type-ascription.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,10 @@\n-error[E0658]: type ascription is experimental\n-  --> $DIR/many-type-ascription.rs:2:13\n+error: expected one of `.`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/many-type-ascription.rs:2:14\n    |\n LL |     let _ = 0: i32;\n-   |             ^^^^^^\n+   |              ^ expected one of `.`, `;`, `?`, `else`, or an operator\n    |\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "5ad6024329861c4284c2b39e971e68a2970ed9cb", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,8 +3,7 @@ fn fun(x: i32) -> i32 { x }\n fn main() {\n     let closure_annotated = |value: i32| -> i32 {\n         temp: i32 = fun(5i32);\n-        //~^ ERROR cannot find value `temp` in this scope\n+        //~^ ERROR expected identifier, found `:`\n         temp + value + 1\n-        //~^ ERROR cannot find value `temp` in this scope\n     };\n }"}, {"sha": "fb697b0ccfd5e25ea6510f44a0f1b0b43c055997", "filename": "tests/ui/suggestions/type-ascription-instead-of-let.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,18 +1,8 @@\n-error[E0425]: cannot find value `temp` in this scope\n-  --> $DIR/type-ascription-instead-of-let.rs:5:9\n+error: expected identifier, found `:`\n+  --> $DIR/type-ascription-instead-of-let.rs:5:13\n    |\n LL |         temp: i32 = fun(5i32);\n-   |         ^^^^\n-   |         |\n-   |         not found in this scope\n-   |         help: maybe you meant to write an assignment here: `let temp`\n+   |             ^ expected identifier\n \n-error[E0425]: cannot find value `temp` in this scope\n-  --> $DIR/type-ascription-instead-of-let.rs:7:9\n-   |\n-LL |         temp + value + 1\n-   |         ^^^^ not found in this scope\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "682d89b3443a7c61f55293f8c096dbf3ac718130", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Box::new(\"foo\".to_string());\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colo\n }"}, {"sha": "d2d260efdbc1ff55e20db8f0237a374cee878754", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Box:new(\"foo\".to_string());\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colo\n }"}, {"sha": "9be8c5ce3c188ff41fce4f7aaeca5367d645b344", "filename": "tests/ui/suggestions/type-ascription-instead-of-method.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,10 @@\n-error: expected type, found `\"foo\"`\n-  --> $DIR/type-ascription-instead-of-method.rs:3:21\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-method.rs:3:16\n    |\n LL |     let _ = Box:new(\"foo\".to_string());\n-   |                -    ^^^^^ expected type\n-   |                |\n-   |                help: maybe write a path separator here: `::`\n+   |                ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "4cec58be856f033e3906ee4c596af4d437cdf3b5", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n fn main() -> Result<(), ()> {\n     let _ = vec![Ok(2)].into_iter().collect::<Result<Vec<_>,_>>()?;\n-    //~^ ERROR expected `::`, found `(`\n+    //~^ ERROR expected one of\n     Ok(())\n }"}, {"sha": "5695d5a7f72510d21ee5b88f03dcdf2dbec46fc5", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n fn main() -> Result<(), ()> {\n     let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n-    //~^ ERROR expected `::`, found `(`\n+    //~^ ERROR expected one of\n     Ok(())\n }"}, {"sha": "43d00591e74c0be6aa1538ccc4825658151c1b91", "filename": "tests/ui/suggestions/type-ascription-instead-of-path-2.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path-2.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,14 @@\n-error: expected `::`, found `(`\n-  --> $DIR/type-ascription-instead-of-path-2.rs:3:63\n+error: expected one of `(`, `.`, `::`, `;`, `?`, `else`, or an operator, found `:`\n+  --> $DIR/type-ascription-instead-of-path-2.rs:3:44\n    |\n LL |     let _ = vec![Ok(2)].into_iter().collect:<Result<Vec<_>,_>>()?;\n-   |                                            -                  ^ expected `::`\n-   |                                            |\n-   |                                            help: maybe write a path separator here: `::`\n+   |                                            ^ expected one of 7 possible tokens\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+help: maybe write a path separator here\n+   |\n+LL |     let _ = vec![Ok(2)].into_iter().collect::<Result<Vec<_>,_>>()?;\n+   |                                            ~~\n \n error: aborting due to previous error\n "}, {"sha": "69647887afcee176f04f3a3c3ff08c01b4f42475", "filename": "tests/ui/suggestions/type-ascription-instead-of-path.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,4 @@\n fn main() {\n     std:io::stdin();\n-    //~^ ERROR failed to resolve: use of undeclared crate or module `io`\n-    //~| ERROR expected value, found crate\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "d178621b8c6131f8cefdec3c5c1cf45557df2cae", "filename": "tests/ui/suggestions/type-ascription-instead-of-path.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,18 +1,10 @@\n-error[E0433]: failed to resolve: use of undeclared crate or module `io`\n-  --> $DIR/type-ascription-instead-of-path.rs:2:9\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-path.rs:2:8\n    |\n LL |     std:io::stdin();\n-   |         ^^ use of undeclared crate or module `io`\n-\n-error[E0423]: expected value, found crate `std`\n-  --> $DIR/type-ascription-instead-of-path.rs:2:5\n+   |        ^ help: use a double colon instead: `::`\n    |\n-LL |     std:io::stdin();\n-   |     ^^^- help: maybe you meant to write a path separator here: `::`\n-   |     |\n-   |     not a value\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0423, E0433.\n-For more information about an error, try `rustc --explain E0423`."}, {"sha": "04cb206862462cf39342bfab3722f2216ecaac0b", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Option::Some(\"\");\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "2cce69bfec8f344c8d1a3cd3e2a76115cd6c28f1", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _ = Option:Some(\"\");\n-    //~^ ERROR expected type, found\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "dfb7d8003faf979fef2fca2149bd5ead7128bcf9", "filename": "tests/ui/suggestions/type-ascription-instead-of-variant.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,10 @@\n-error: expected type, found `\"\"`\n-  --> $DIR/type-ascription-instead-of-variant.rs:3:25\n+error: path separator must be a double colon\n+  --> $DIR/type-ascription-instead-of-variant.rs:3:19\n    |\n LL |     let _ = Option:Some(\"\");\n-   |                   -     ^^ expected type\n-   |                   |\n-   |                   help: maybe write a path separator here: `::`\n+   |                   ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "f3cd02be7f01770fe31f82fb86b35582268437c4", "filename": "tests/ui/traits/associated_type_bound/assoc_type_bound_with_struct.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftraits%2Fassociated_type_bound%2Fassoc_type_bound_with_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftraits%2Fassociated_type_bound%2Fassoc_type_bound_with_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fassociated_type_bound%2Fassoc_type_bound_with_struct.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -85,6 +85,12 @@ LL | fn issue_95327() where <u8 as Unresolved>::Assoc: String {}\n    |\n    = note: similarly named trait `ToString` defined here\n \n+error[E0433]: failed to resolve: use of undeclared type `Unresolved`\n+  --> $DIR/assoc_type_bound_with_struct.rs:19:31\n+   |\n+LL | fn issue_95327() where <u8 as Unresolved>::Assoc: String {}\n+   |                               ^^^^^^^^^^ use of undeclared type `Unresolved`\n+\n error: aborting due to 6 previous errors\n \n Some errors have detailed explanations: E0404, E0405."}, {"sha": "7436f83593d34bd79bcb6ec88948057bcd8adfcc", "filename": "tests/ui/type/ascription/issue-34255-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,13 +1,12 @@\n+// rustfix\n+\n struct Reactor {\n     input_cells: Vec<usize>,\n }\n \n impl Reactor {\n-    pub fn new() -> Self {\n+    pub fn new() -> Self { //~ ERROR struct literal body without path\n         input_cells: Vec::new()\n-        //~^ ERROR cannot find value `input_cells` in this scope\n-        //~| ERROR parenthesized type parameters may only be used with a `Fn` trait\n-        //~| ERROR missing generics for struct `Vec`\n     }\n }\n "}, {"sha": "254d36cb9479c5c14ec2528d012591690cfddd62", "filename": "tests/ui/type/ascription/issue-34255-1.stderr", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-34255-1.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,36 +1,18 @@\n-error[E0425]: cannot find value `input_cells` in this scope\n-  --> $DIR/issue-34255-1.rs:7:9\n+error: struct literal body without path\n+  --> $DIR/issue-34255-1.rs:8:26\n    |\n-LL |         input_cells: Vec::new()\n-   |         ^^^^^^^^^^^ a field by this name exists in `Self`\n+LL |       pub fn new() -> Self {\n+   |  __________________________^\n+LL | |         input_cells: Vec::new()\n+LL | |     }\n+   | |_____^\n    |\n-help: you might have meant to write a `struct` literal\n+help: you might have forgotten to add the struct literal inside the block\n    |\n LL ~     pub fn new() -> Self { SomeStruct {\n LL |         input_cells: Vec::new()\n- ...\n-LL |\n-LL ~     }}\n-   |\n-\n-error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n-  --> $DIR/issue-34255-1.rs:7:27\n-   |\n-LL |         input_cells: Vec::new()\n-   |                           ^^^^^ only `Fn` traits may use parentheses\n-\n-error[E0107]: missing generics for struct `Vec`\n-  --> $DIR/issue-34255-1.rs:7:22\n-   |\n-LL |         input_cells: Vec::new()\n-   |                      ^^^ expected at least 1 generic argument\n-   |\n-help: add missing generic argument\n+LL ~     } }\n    |\n-LL |         input_cells: Vec<T>::new()\n-   |                         +++\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0107, E0214, E0425.\n-For more information about an error, try `rustc --explain E0107`."}, {"sha": "027c692f9003bc8c109f50e607b1e67c2ce52e98", "filename": "tests/ui/type/ascription/issue-47666.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,4 +1,4 @@\n // run-rustfix\n fn main() {\n-    let _ = Option::Some(vec![0, 1]); //~ ERROR expected type, found\n+    let _ = Option::Some(vec![0, 1]); //~ ERROR path separator must be a double colon\n }"}, {"sha": "e2f5d03ef74250bf9873e5083c3b54e906de710d", "filename": "tests/ui/type/ascription/issue-47666.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,4 +1,4 @@\n // run-rustfix\n fn main() {\n-    let _ = Option:Some(vec![0, 1]); //~ ERROR expected type, found\n+    let _ = Option:Some(vec![0, 1]); //~ ERROR path separator must be a double colon\n }"}, {"sha": "2f815041ce13d12b4ede04deefab25ab44cda794", "filename": "tests/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,16 +1,10 @@\n-error: expected type, found `<[_]>::into_vec(#[rustc_box] ::alloc::boxed::Box::new([0, 1]))`\n-  --> $DIR/issue-47666.rs:3:25\n+error: path separator must be a double colon\n+  --> $DIR/issue-47666.rs:3:19\n    |\n LL |     let _ = Option:Some(vec![0, 1]);\n-   |                   -     ^^^^^^^^^^\n-   |                   |     |\n-   |                   |     expected type\n-   |                   |     in this macro invocation\n-   |                   |     this macro call doesn't expand to a type\n-   |                   help: maybe write a path separator here: `::`\n+   |                   ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: this error originates in the macro `$crate::__rust_force_expr` which comes from the expansion of the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "48622663b4d5e2119c7b4ebcdd2d5779a57d0c07", "filename": "tests/ui/type/ascription/issue-54516.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,5 +3,5 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem::size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "9e71d2af1d32bed827da753bc8c139e29a959558", "filename": "tests/ui/type/ascription/issue-54516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -3,5 +3,5 @@ use std::collections::BTreeMap;\n \n fn main() {\n     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "7666864a9bcbb955ba77c89b1f87b2cf6b0e4a8b", "filename": "tests/ui/type/ascription/issue-54516.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-54516.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,10 @@\n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-54516.rs:5:20\n+error: path separator must be a double colon\n+  --> $DIR/issue-54516.rs:5:28\n    |\n LL |     println!(\"{}\", std::mem:size_of::<BTreeMap<u32, u32>>());\n-   |                    ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                            |\n-   |                            help: maybe write a path separator here: `::`\n+   |                            ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "016ad4a7e6a636e8a8b60aa544b4d987eb5dd50c", "filename": "tests/ui/type/ascription/issue-60933.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _: usize = std::mem::size_of::<u32>();\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "972bf2827f97f2b78fdcdbbcfa0a391a5021d013", "filename": "tests/ui/type/ascription/issue-60933.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let _: usize = std::mem:size_of::<u32>();\n-    //~^ ERROR type ascription cannot be followed by a function call\n+    //~^ ERROR path separator must be a double colon\n }"}, {"sha": "776cc412c326aba7e55d3e946105636d59632701", "filename": "tests/ui/type/ascription/issue-60933.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fascription%2Fissue-60933.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,12 +1,10 @@\n-error: type ascription cannot be followed by a function call\n-  --> $DIR/issue-60933.rs:3:20\n+error: path separator must be a double colon\n+  --> $DIR/issue-60933.rs:3:28\n    |\n LL |     let _: usize = std::mem:size_of::<u32>();\n-   |                    ^^^^^^^^-^^^^^^^^^^^^^^\n-   |                            |\n-   |                            help: maybe write a path separator here: `::`\n+   |                            ^ help: use a double colon instead: `::`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n "}, {"sha": "4301fed2312e60bd53ebf4e9ed7e684814fa0f59", "filename": "tests/ui/type/missing-let-in-binding.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let mut _foo: i32 = 1;\n-    let _foo: i32 = 4; //~ ERROR type ascription is experimental\n+    let _foo: i32 = 4; //~ ERROR expected identifier, found `:`\n }"}, {"sha": "c0f91d98ff31f6ddaa560080414fc8a4495b8a49", "filename": "tests/ui/type/missing-let-in-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,5 +1,5 @@\n // run-rustfix\n fn main() {\n     let mut _foo: i32 = 1;\n-    _foo: i32 = 4; //~ ERROR type ascription is experimental\n+    _foo: i32 = 4; //~ ERROR expected identifier, found `:`\n }"}, {"sha": "fc094e8cbad717a273a6b9e9ebf34c643dcd28e8", "filename": "tests/ui/type/missing-let-in-binding.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Fmissing-let-in-binding.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,16 +1,14 @@\n-error[E0658]: type ascription is experimental\n-  --> $DIR/missing-let-in-binding.rs:4:5\n+error: expected identifier, found `:`\n+  --> $DIR/missing-let-in-binding.rs:4:9\n    |\n LL |     _foo: i32 = 4;\n-   |     ^^^^^^^^^\n+   |         ^ expected identifier\n    |\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n-   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n help: you might have meant to introduce a new binding\n    |\n LL |     let _foo: i32 = 4;\n    |     +++\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "e30e571386bd254ba86c0f48785468c5eaaf39cd", "filename": "tests/ui/type/type-ascription-instead-of-statement-end.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,10 +1,8 @@\n-#![feature(type_ascription)]\n-\n fn main() {\n-    println!(\"test\"):\n-    0; //~ ERROR expected type, found `0`\n+    println!(\"test\"): //~ ERROR statements are terminated with a semicolon\n+    0;\n }\n \n fn foo() {\n-    println!(\"test\"): 0; //~ ERROR expected type, found `0`\n+    println!(\"test\"): 0; //~ ERROR expected one of\n }"}, {"sha": "678aed7b14417dcddff0e68a08e7ce92d1e6a9c9", "filename": "tests/ui/type/type-ascription-instead-of-statement-end.stderr", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,24 +1,16 @@\n-error: expected type, found `0`\n-  --> $DIR/type-ascription-instead-of-statement-end.rs:5:5\n+error: statements are terminated with a semicolon\n+  --> $DIR/type-ascription-instead-of-statement-end.rs:2:21\n    |\n LL |     println!(\"test\"):\n-   |                     - help: try using a semicolon: `;`\n-LL |     0;\n-   |     ^ expected type\n+   |                     ^ help: use a semicolon instead: `;`\n    |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-error: expected type, found `0`\n-  --> $DIR/type-ascription-instead-of-statement-end.rs:9:23\n+error: expected one of `.`, `;`, `?`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-instead-of-statement-end.rs:7:21\n    |\n LL |     println!(\"test\"): 0;\n-   |                     - ^ expected type\n-   |                     |\n-   |                     tried to parse a type due to this type ascription\n-   |\n-   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n-   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   |                     ^ expected one of `.`, `;`, `?`, `}`, or an operator\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d02e302b975f289f1f6c7c3dc0fd4b1367763010", "filename": "tests/ui/type/type-ascription-precedence.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-precedence.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,8 +1,5 @@\n // Operator precedence of type ascription\n // Type ascription has very high precedence, the same as operator `as`\n-\n-#![feature(type_ascription)]\n-\n use std::ops::*;\n \n struct S;\n@@ -26,29 +23,27 @@ impl Deref for S {\n }\n \n fn main() {\n-    &S: &S; // OK\n+    &S: &S; //~ ERROR expected one of\n     (&S): &S; // OK\n-    &(S: &S); //~ ERROR mismatched types\n+    &(S: &S);\n \n     *S: Z; // OK\n     (*S): Z; // OK\n-    *(S: Z); //~ ERROR mismatched types\n-    //~^ ERROR type `Z` cannot be dereferenced\n+    *(S: Z);\n \n     -S: Z; // OK\n     (-S): Z; // OK\n-    -(S: Z); //~ ERROR mismatched types\n-    //~^ ERROR cannot apply unary operator `-` to type `Z`\n+    -(S: Z);\n \n     S + Z: Z; // OK\n     S + (Z: Z); // OK\n-    (S + Z): Z; //~ ERROR mismatched types\n+    (S + Z): Z;\n \n     S * Z: Z; // OK\n     S * (Z: Z); // OK\n-    (S * Z): Z; //~ ERROR mismatched types\n+    (S * Z): Z;\n \n     S .. S: S; // OK\n     S .. (S: S); // OK\n-    (S .. S): S; //~ ERROR mismatched types\n+    (S .. S): S;\n }"}, {"sha": "2efdbcbe08ef18a7fe3dd49ec8b79521bc0b2061", "filename": "tests/ui/type/type-ascription-precedence.stderr", "status": "modified", "additions": 5, "deletions": 60, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-precedence.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,63 +1,8 @@\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:31:7\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `:`\n+  --> $DIR/type-ascription-precedence.rs:26:7\n    |\n-LL |     &(S: &S);\n-   |       ^ expected `&S`, found `S`\n+LL |     &S: &S;\n+   |       ^ expected one of 8 possible tokens\n \n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:35:7\n-   |\n-LL |     *(S: Z);\n-   |       ^ expected `Z`, found `S`\n-\n-error[E0614]: type `Z` cannot be dereferenced\n-  --> $DIR/type-ascription-precedence.rs:35:5\n-   |\n-LL |     *(S: Z);\n-   |     ^^^^^^^\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:40:7\n-   |\n-LL |     -(S: Z);\n-   |       ^ expected `Z`, found `S`\n-\n-error[E0600]: cannot apply unary operator `-` to type `Z`\n-  --> $DIR/type-ascription-precedence.rs:40:5\n-   |\n-LL |     -(S: Z);\n-   |     ^^^^^^^ cannot apply unary operator `-`\n-   |\n-note: an implementation of `std::ops::Neg` might be missing for `Z`\n-  --> $DIR/type-ascription-precedence.rs:9:1\n-   |\n-LL | struct Z;\n-   | ^^^^^^^^ must implement `std::ops::Neg`\n-note: the trait `std::ops::Neg` must be implemented\n-  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:45:5\n-   |\n-LL |     (S + Z): Z;\n-   |     ^^^^^^^ expected `Z`, found `S`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:49:5\n-   |\n-LL |     (S * Z): Z;\n-   |     ^^^^^^^ expected `Z`, found `S`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/type-ascription-precedence.rs:53:5\n-   |\n-LL |     (S .. S): S;\n-   |     ^^^^^^^^ expected `S`, found `Range<S>`\n-   |\n-   = note: expected struct `S`\n-              found struct `std::ops::Range<S>`\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0600, E0614.\n-For more information about an error, try `rustc --explain E0308`."}, {"sha": "847f33099732e61f7c0aa0679b60e544799fdd2e", "filename": "tests/ui/type/type-ascription-with-fn-call.fixed", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.fixed?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,9 +1,7 @@\n // run-rustfix\n-#![feature(type_ascription)]\n-\n fn main() {\n-    f()  ;\n-    f(); //~ ERROR expected type, found function\n+    f()  ; //~ ERROR statements are terminated with a semicolon\n+    f();\n }\n \n fn f() {}"}, {"sha": "1db48b0adc435faba4e57c0382f19a2a5278e533", "filename": "tests/ui/type/type-ascription-with-fn-call.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.rs?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,9 +1,7 @@\n // run-rustfix\n-#![feature(type_ascription)]\n-\n fn main() {\n-    f()  :\n-    f(); //~ ERROR expected type, found function\n+    f()  : //~ ERROR statements are terminated with a semicolon\n+    f();\n }\n \n fn f() {}"}, {"sha": "80fc075383eecf1548910d553e96ce71ecab3db9", "filename": "tests/ui/type/type-ascription-with-fn-call.stderr", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-ascription-with-fn-call.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,11 +1,10 @@\n-error[E0573]: expected type, found function `f`\n-  --> $DIR/type-ascription-with-fn-call.rs:6:5\n+error: statements are terminated with a semicolon\n+  --> $DIR/type-ascription-with-fn-call.rs:3:10\n    |\n LL |     f()  :\n-   |          - help: maybe you meant to write `;` here\n-LL |     f();\n-   |     ^^^ expecting a type here because of type ascription\n+   |          ^ help: use a semicolon instead: `;`\n+   |\n+   = note: type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0573`."}, {"sha": "8b12aa1a393b2d229b83631946ffe767c99a8a2e", "filename": "tests/ui/type/type-path-err-node-types.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Ftype%2Ftype-path-err-node-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-path-err-node-types.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,9 +1,3 @@\n-error[E0433]: failed to resolve: use of undeclared type `NonExistent`\n-  --> $DIR/type-path-err-node-types.rs:15:5\n-   |\n-LL |     NonExistent::Assoc::<u8>;\n-   |     ^^^^^^^^^^^ use of undeclared type `NonExistent`\n-\n error[E0412]: cannot find type `Nonexistent` in this scope\n   --> $DIR/type-path-err-node-types.rs:7:12\n    |\n@@ -22,6 +16,12 @@ error[E0425]: cannot find value `nonexistent` in this scope\n LL |     nonexistent.nonexistent::<u8>();\n    |     ^^^^^^^^^^^ not found in this scope\n \n+error[E0433]: failed to resolve: use of undeclared type `NonExistent`\n+  --> $DIR/type-path-err-node-types.rs:15:5\n+   |\n+LL |     NonExistent::Assoc::<u8>;\n+   |     ^^^^^^^^^^^ use of undeclared type `NonExistent`\n+\n error[E0282]: type annotations needed\n   --> $DIR/type-path-err-node-types.rs:23:14\n    |"}, {"sha": "737e739fceb47a17e959d9e488a8e674f7f2a9f7", "filename": "tests/ui/ufcs/ufcs-partially-resolved.stderr", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c63b6a437eb16d13fbc0e72e091813579895bc9f/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fufcs%2Fufcs-partially-resolved.stderr?ref=c63b6a437eb16d13fbc0e72e091813579895bc9f", "patch": "@@ -1,3 +1,25 @@\n+error[E0433]: failed to resolve: `Y` is a variant, not a module\n+  --> $DIR/ufcs-partially-resolved.rs:48:22\n+   |\n+LL |     let _: <u8 as E::Y>::NN;\n+   |                      ^ `Y` is a variant, not a module\n+   |\n+help: there is an enum variant `E::Y`; try using the variant's enum\n+   |\n+LL |     let _: E;\n+   |            ~\n+\n+error[E0433]: failed to resolve: `Y` is a variant, not a module\n+  --> $DIR/ufcs-partially-resolved.rs:50:15\n+   |\n+LL |     <u8 as E::Y>::NN;\n+   |               ^ `Y` is a variant, not a module\n+   |\n+help: there is an enum variant `E::Y`; try using the variant's enum\n+   |\n+LL |     E;\n+   |     ~\n+\n error[E0576]: cannot find associated type `N` in trait `Tr`\n   --> $DIR/ufcs-partially-resolved.rs:19:24\n    |"}]}