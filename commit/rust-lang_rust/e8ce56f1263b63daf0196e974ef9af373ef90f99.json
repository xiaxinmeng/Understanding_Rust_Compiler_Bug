{"sha": "e8ce56f1263b63daf0196e974ef9af373ef90f99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Y2U1NmYxMjYzYjYzZGFmMDE5NmU5NzRlZjlhZjM3M2VmOTBmOTk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-25T08:09:02Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-25T08:13:22Z"}, "message": "librustc_typeck: deny(elided_lifetimes_in_paths)", "tree": {"sha": "11514afea73182410eedc644f4bf868990d0c52d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11514afea73182410eedc644f4bf868990d0c52d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8ce56f1263b63daf0196e974ef9af373ef90f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8ce56f1263b63daf0196e974ef9af373ef90f99", "html_url": "https://github.com/rust-lang/rust/commit/e8ce56f1263b63daf0196e974ef9af373ef90f99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8ce56f1263b63daf0196e974ef9af373ef90f99/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1911babed0364ede7dedc646dbca63fac03d5c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1911babed0364ede7dedc646dbca63fac03d5c5", "html_url": "https://github.com/rust-lang/rust/commit/c1911babed0364ede7dedc646dbca63fac03d5c5"}], "stats": {"total": 112, "additions": 59, "deletions": 53}, "files": [{"sha": "71368927a801dc575e5760bc458adfa04a7f4a01", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -196,7 +196,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n@@ -227,7 +227,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// Used specifically for function calls.\n     pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         seg: &hir::PathSegment,\n@@ -259,7 +259,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// This is used both for datatypes and function calls.\n     fn check_generic_arg_count(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         args: &hir::GenericArgs,\n@@ -1502,7 +1502,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt, span: Span) {\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_, '_, '_>, span: Span) {\n         let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();"}, {"sha": "13469f1696631908712f63e0052a978ca0561c81", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let rhs_ty = self.check_expr(end);\n \n                 // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n+                let numeric_or_char = |ty: Ty<'_>| ty.is_numeric() || ty.is_char();\n                 let lhs_compat = numeric_or_char(lhs_ty);\n                 let rhs_compat = numeric_or_char(rhs_ty);\n "}, {"sha": "84d3c203afbe429f704acb1de40896ac01bc1356", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called).\n-pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_id: DefId) {\n     if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")"}, {"sha": "5f765245183901aedfea60ecb6caaa0b365ef8b1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n     ) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv = self;\n+        let astconv: &dyn AstConv<'_, '_> = self;\n \n         // First, convert the types that the user supplied (if any).\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n@@ -606,7 +606,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n     fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv = self;\n+        let astconv: &dyn AstConv<'_, '_> = self;\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them."}, {"sha": "8841f6b268419651af8ebf8869b1e423c1cbd31c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -101,7 +101,7 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-fn identity(_: Ty) -> Vec<Adjustment> { vec![] }\n+fn identity(_: Ty<'_>) -> Vec<Adjustment<'_>> { vec![] }\n \n fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>> {\n     move |target| vec![Adjustment { kind, target }]\n@@ -1084,7 +1084,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     pub fn coerce_forced_unit<'a>(&mut self,\n                                   fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                                   cause: &ObligationCause<'tcx>,\n-                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder),\n+                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n                                   label_unit_as_expected: bool)\n     {\n         self.coerce_inner(fcx,\n@@ -1103,7 +1103,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n                         mut expression_ty: Ty<'tcx>,\n-                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder)>,\n+                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n                         label_expression_as_expected: bool)\n     {\n         // Incorporate whatever type inference information we have"}, {"sha": "c6b34672e6b4c485102fc60786211633ddc84626", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -408,7 +408,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      param_env: ty::ParamEnv<'tcx>,\n-                                                     terr: &TypeError,\n+                                                     terr: &TypeError<'_>,\n                                                      cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,"}, {"sha": "adff5f2f9b9c8f7a677447333dc0f040a1d6e243", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -544,7 +544,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             let into_sugg = into_suggestion.clone();\n-            let suggest_to_change_suffix_or_into = |err: &mut DiagnosticBuilder,\n+            let suggest_to_change_suffix_or_into = |err: &mut DiagnosticBuilder<'_>,\n                                                     note: Option<&str>| {\n                 let suggest_msg = if literal_is_ty_suffixed(expr) {\n                     format!("}, {"sha": "1eaa8b17d09f7e64ed48e2db09a90b33a64bce6a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n+    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick<'_>) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {"}, {"sha": "04352626190f316bc6b5ea4c7447c0d46c3679de", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n@@ -1180,7 +1180,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn emit_unstable_name_collision_hint(\n         &self,\n-        stable_pick: &Pick,\n+        stable_pick: &Pick<'_>,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n         let mut diag = self.tcx.struct_span_lint_hir("}, {"sha": "c15cb1e5bb15140cd804318bd6ac44388ad7229a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -72,7 +72,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let report_candidates = |err: &mut DiagnosticBuilder, mut sources: Vec<CandidateSource>| {\n+        let report_candidates = |err: &mut DiagnosticBuilder<'_>,\n+                                 mut sources: Vec<CandidateSource>| {\n             sources.sort();\n             sources.dedup();\n             // Dynamic limit to avoid hiding just one candidate, which is silly.\n@@ -497,7 +498,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_use_candidates(&self,\n-                              err: &mut DiagnosticBuilder,\n+                              err: &mut DiagnosticBuilder<'_>,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n         let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n@@ -549,7 +550,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_valid_traits(&self,\n-                            err: &mut DiagnosticBuilder,\n+                            err: &mut DiagnosticBuilder<'_>,\n                             valid_out_of_scope_traits: Vec<DefId>) -> bool {\n         if !valid_out_of_scope_traits.is_empty() {\n             let mut candidates = valid_out_of_scope_traits;\n@@ -577,7 +578,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_traits_to_import<'b>(&self,\n-                                    err: &mut DiagnosticBuilder,\n+                                    err: &mut DiagnosticBuilder<'_>,\n                                     span: Span,\n                                     rcvr_ty: Ty<'tcx>,\n                                     item_name: ast::Ident,\n@@ -648,8 +649,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            source: SelfSource) -> bool {\n-        fn is_local(ty: Ty) -> bool {\n+                            source: SelfSource<'_>) -> bool {\n+        fn is_local(ty: Ty<'_>) -> bool {\n             match ty.sty {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n@@ -749,7 +750,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     // Cross-crate:\n \n     let mut external_mods = FxHashSet::default();\n-    fn handle_external_def(tcx: TyCtxt,\n+    fn handle_external_def(tcx: TyCtxt<'_, '_, '_>,\n                            traits: &mut Vec<DefId>,\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n@@ -779,7 +780,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     traits\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.all_traits = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(compute_all_traits(tcx))"}, {"sha": "2128466515123aa8b946cb6648da9e1716b2e004", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -738,7 +738,7 @@ fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: De\n     wfcheck::check_impl_item(tcx, def_id);\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     method::provide(providers);\n     *providers = Providers {\n         typeck_item_bodies,\n@@ -1437,7 +1437,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     }\n }\n \n-fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n+fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n         return\n@@ -2122,7 +2122,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn tag(&self) -> String {\n-        let self_ptr: *const FnCtxt = self;\n+        let self_ptr: *const FnCtxt<'_, '_, '_> = self;\n         format!(\"{:?}\", self_ptr)\n     }\n \n@@ -3369,7 +3369,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // (`only_has_type`); otherwise, we just go with a\n         // fresh type variable.\n         let coerce_to_ty = expected.coercion_target_type(self, sp);\n-        let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n+        let mut coerce: DynamicCoerceMany<'_, '_> = CoerceMany::new(coerce_to_ty);\n \n         coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n@@ -5043,7 +5043,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(&self, node: Node<'_>) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n                 ident, node: hir::ItemKind::Fn(ref decl, ..), .."}, {"sha": "e6b4523f9e7cc5e467b201ce6b4c9e79fd77a8db", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         rhs_expr: &'gcx hir::Expr,\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n-        err: &mut errors::DiagnosticBuilder,\n+        err: &mut errors::DiagnosticBuilder<'_>,\n         is_assign: bool,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n@@ -688,7 +688,7 @@ enum Op {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop(lhs: Ty, rhs: Ty, op: hir::BinOp) -> bool {\n+fn is_builtin_binop(lhs: Ty<'_>, rhs: Ty<'_>, op: hir::BinOp) -> bool {\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             true"}, {"sha": "1a165e6ff1eb88c32f363453b42380131ba35479", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -649,6 +649,6 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn var_name(tcx: TyCtxt, var_hir_id: hir::HirId) -> ast::Name {\n+fn var_name(tcx: TyCtxt<'_, '_, '_>, var_hir_id: hir::HirId) -> ast::Name {\n     tcx.hir().name_by_hir_id(var_hir_id)\n }"}, {"sha": "9217484f3a7af84714eb1d8db04f7f0140ba4cb2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -938,7 +938,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n+fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n@@ -1093,7 +1093,7 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n     err\n }\n \n-fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: &str) {\n+fn error_194(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_decl_span: Span, name: &str) {\n     struct_span_err!(tcx.sess, span, E0194,\n                      \"type parameter `{}` shadows another type parameter of the same name\",\n                      name)"}, {"sha": "c4575e6b01ee51d5864c4ceb2ec52e04c5190205", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -729,30 +729,30 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n }\n \n trait Locatable {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span;\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span;\n }\n \n impl Locatable for Span {\n-    fn to_span(&self, _: &TyCtxt) -> Span {\n+    fn to_span(&self, _: &TyCtxt<'_, '_, '_>) -> Span {\n         *self\n     }\n }\n \n impl Locatable for ast::NodeId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         tcx.hir().span(*self)\n     }\n }\n \n impl Locatable for DefIndex {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         let hir_id = tcx.hir().def_index_to_hir_id(*self);\n         tcx.hir().span_by_hir_id(hir_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         tcx.hir().span_by_hir_id(*self)\n     }\n }"}, {"sha": "282f1bad172dca5ed204d8e02b34e7b4a6fb9036", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -20,7 +20,7 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult,\n+                                       overlap: traits::OverlapResult<'_>,\n                                        used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {"}, {"sha": "01aba658850bfb345830327518ee6a1751d9ca60", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -41,7 +41,11 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     }\n }\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_trait_manually_implementable(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    impl_def_id: DefId,\n+    trait_def_id: DefId\n+) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n     let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n@@ -93,7 +97,11 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n \n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n-fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_empty_impls_for_marker_traits(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    impl_def_id: DefId,\n+    trait_def_id: DefId\n+) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n     }\n@@ -110,7 +118,7 @@ fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt, impl_def_id: DefId, trait_\n         .emit();\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     use self::builtin::coerce_unsized_info;\n     use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n     use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;"}, {"sha": "5af66969477cadccbc1fe9ef06c95121b5c71d36", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -1406,7 +1406,7 @@ fn find_existential_constraints<'a, 'tcx>(\n                         ty::Param(p) => Some(*index_map.get(p).unwrap()),\n                         _ => None,\n                     }).collect();\n-                let is_param = |ty: ty::Ty| match ty.sty {\n+                let is_param = |ty: ty::Ty<'_>| match ty.sty {\n                     ty::Param(_) => true,\n                     _ => false,\n                 };\n@@ -2216,7 +2216,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n     {\n-        let check = |ast_ty: &hir::Ty, ty: Ty| {\n+        let check = |ast_ty: &hir::Ty, ty: Ty<'_>| {\n             if ty.is_simd() {\n                 tcx.sess\n                    .struct_span_err(\n@@ -2251,7 +2251,7 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool\n }\n \n fn from_target_feature(\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n     whitelist: &FxHashMap<String, Option<String>>,"}, {"sha": "3682acd3c62c127e8f2b28e3716cfcda808454d9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -74,8 +74,6 @@ This API is completely unstable and subject to change.\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n \n-#![allow(elided_lifetimes_in_paths)] // WIP\n-\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n "}, {"sha": "c2f79207a562469ef6e1b86e6ce22408037f0eb2", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -27,7 +27,7 @@ pub mod test;\n /// Code for transforming variances.\n mod xform;\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         variances_of,\n         crate_variances,\n@@ -91,4 +91,3 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                        .unwrap_or(&crate_map.empty_variance)\n                        .clone()\n }\n-"}, {"sha": "f962c1313a923ee60b2d0615d781ab9d53b25481", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -23,7 +23,7 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::CrateVariancesMap {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];"}, {"sha": "4e562992e8cf931ee267600ae1fe85d305bb02b5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8ce56f1263b63daf0196e974ef9af373ef90f99/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=e8ce56f1263b63daf0196e974ef9af373ef90f99", "patch": "@@ -32,7 +32,7 @@ pub enum VarianceTerm<'a> {\n }\n \n impl<'a> fmt::Debug for VarianceTerm<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n             TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n@@ -86,7 +86,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     terms_cx\n }\n \n-fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n     let lang_items = tcx.lang_items();\n     let all = vec![\n         (lang_items.phantom_data(), vec![ty::Covariant]),"}]}