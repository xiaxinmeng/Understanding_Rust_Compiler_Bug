{"sha": "0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjM2VmM2NjNmJkZGFhNGJjZGIyNWY1NTYyMjg2YTcxYjU5Y2MxNWQ=", "commit": {"author": {"name": "Michael Neumann", "email": "mneumann@ntecs.de", "date": "2013-01-24T17:57:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-28T22:40:11Z"}, "message": "Convert log(debug, ...) to debug!(...)", "tree": {"sha": "bf2fac85f636edcf02c87315e094cce8c55c5a67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf2fac85f636edcf02c87315e094cce8c55c5a67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "html_url": "https://github.com/rust-lang/rust/commit/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d/comments", "author": {"login": "mneumann", "id": 34112, "node_id": "MDQ6VXNlcjM0MTEy", "avatar_url": "https://avatars.githubusercontent.com/u/34112?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mneumann", "html_url": "https://github.com/mneumann", "followers_url": "https://api.github.com/users/mneumann/followers", "following_url": "https://api.github.com/users/mneumann/following{/other_user}", "gists_url": "https://api.github.com/users/mneumann/gists{/gist_id}", "starred_url": "https://api.github.com/users/mneumann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mneumann/subscriptions", "organizations_url": "https://api.github.com/users/mneumann/orgs", "repos_url": "https://api.github.com/users/mneumann/repos", "events_url": "https://api.github.com/users/mneumann/events{/privacy}", "received_events_url": "https://api.github.com/users/mneumann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02de11c1e74de0f942aa463dcfbdcfeef3ef60ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/02de11c1e74de0f942aa463dcfbdcfeef3ef60ee", "html_url": "https://github.com/rust-lang/rust/commit/02de11c1e74de0f942aa463dcfbdcfeef3ef60ee"}], "stats": {"total": 131, "additions": 62, "deletions": 69}, "files": [{"sha": "dc310a32a527c1c62cd6b3805a97b8bb5daafb36", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 62, "deletions": 69, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=0c3ef3cc6bddaa4bcdb25f5562286a71b59cc15d", "patch": "@@ -169,20 +169,20 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n             iotask: iotask.clone()\n         };\n         let socket_data_ptr = ptr::addr_of(&(*socket_data));\n-        log(debug, fmt!(\"tcp_connect result_ch %?\", conn_data.result_ch));\n+        debug!(\"tcp_connect result_ch %?\", conn_data.result_ch);\n         // get an unsafe representation of our stream_handle_ptr that\n         // we can send into the interact cb to be handled in libuv..\n-        log(debug, fmt!(\"stream_handle_ptr outside interact %?\",\n-                        stream_handle_ptr));\n+        debug!(\"stream_handle_ptr outside interact %?\",\n+                        stream_handle_ptr);\n         do iotask::interact(iotask) |move input_ip, loop_ptr| {\n             unsafe {\n-                log(debug, ~\"in interact cb for tcp client connect..\");\n-                log(debug, fmt!(\"stream_handle_ptr in interact %?\",\n-                                stream_handle_ptr));\n+                debug!(\"in interact cb for tcp client connect..\");\n+                debug!(\"stream_handle_ptr in interact %?\",\n+                                stream_handle_ptr);\n                 match uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n                     0i32 => {\n-                        log(debug, ~\"tcp_init successful\");\n-                        log(debug, ~\"dealing w/ ipv4 connection..\");\n+                        debug!(\"tcp_init successful\");\n+                        debug!(\"dealing w/ ipv4 connection..\");\n                         let connect_req_ptr =\n                             ptr::addr_of(&((*socket_data_ptr).connect_req));\n                         let addr_str = ip::format_addr(&input_ip);\n@@ -195,7 +195,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 // type that actually is closer to\n                                 // what the libuv API expects (ip str\n                                 // + port num)\n-                                log(debug, fmt!(\"addr: %?\", addr));\n+                                debug!(\"addr: %?\", addr);\n                                 let in_addr = uv::ll::ip4_addr(addr_str,\n                                                                port as int);\n                                 uv::ll::tcp_connect(\n@@ -205,7 +205,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                     tcp_connect_on_connect_cb)\n                             }\n                             ip::Ipv6(ref addr) => {\n-                                log(debug, fmt!(\"addr: %?\", addr));\n+                                debug!(\"addr: %?\", addr);\n                                 let in_addr = uv::ll::ip6_addr(addr_str,\n                                                                port as int);\n                                 uv::ll::tcp_connect6(\n@@ -217,7 +217,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                         };\n                         match connect_result {\n                             0i32 => {\n-                                log(debug, ~\"tcp_connect successful\");\n+                                debug!(\"tcp_connect successful\");\n                                 // reusable data that we'll have for the\n                                 // duration..\n                                 uv::ll::set_data_for_uv_handle(\n@@ -228,8 +228,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                                 // outcome..\n                                 uv::ll::set_data_for_req(connect_req_ptr,\n                                                          conn_data_ptr);\n-                                log(debug,\n-                                    ~\"leaving tcp_connect interact cb...\");\n+                                debug!(\"leaving tcp_connect interact cb...\");\n                                 // let tcp_connect_on_connect_cb send on\n                                 // the result_ch, now..\n                             }\n@@ -260,12 +259,12 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         }\n         match oldcomm::recv(result_po) {\n             ConnSuccess => {\n-                log(debug, ~\"tcp::connect - received success on result_po\");\n+                debug!(\"tcp::connect - received success on result_po\");\n                 result::Ok(TcpSocket(socket_data))\n             }\n             ConnFailure(ref err_data) => {\n                 oldcomm::recv(closed_signal_po);\n-                log(debug, ~\"tcp::connect - received failure on result_po\");\n+                debug!(\"tcp::connect - received failure on result_po\");\n                 // still have to free the malloc'd stream handle..\n                 rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                                     as *libc::c_void);\n@@ -379,8 +378,8 @@ pub fn read_stop(sock: &TcpSocket,\n              read_port: oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> {\n     unsafe {\n-        log(debug,\n-            fmt!(\"taking the read_port out of commission %?\", read_port));\n+        debug!(\n+            \"taking the read_port out of commission %?\", read_port);\n         let socket_data = ptr::addr_of(&(*sock.socket_data));\n         read_stop_common_impl(socket_data)\n     }\n@@ -548,7 +547,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                 // the rules here because this always has to be\n                 // called within the context of a listen() new_connect_cb\n                 // callback (or it will likely fail and drown your cat)\n-                log(debug, ~\"in interact cb for tcp::accept\");\n+                debug!(\"in interact cb for tcp::accept\");\n                 let loop_ptr = uv::ll::get_loop_for_uv_handle(\n                     server_handle_ptr);\n                 match uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n@@ -908,7 +907,7 @@ impl TcpSocketBuf: io::Reader {\n         self.end_of_stream\n     }\n     fn seek(&self, dist: int, seek: io::SeekStyle) {\n-        log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n         // noop\n     }\n     fn tell(&self) -> uint {\n@@ -935,7 +934,7 @@ impl TcpSocketBuf: io::Writer {\n         }\n     }\n     fn seek(&self, dist: int, seek: io::SeekStyle) {\n-      log(debug, fmt!(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+      debug!(\"tcp_socket_buf seek stub %? %?\", dist, seek);\n         // noop\n     }\n     fn tell(&self) -> uint {\n@@ -1524,7 +1523,7 @@ pub mod test {\n         };\n         oldcomm::recv(cont_po);\n         // client\n-        log(debug, ~\"server started, firing up client..\");\n+        debug!(\"server started, firing up client..\");\n         let actual_resp_result = do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1536,10 +1535,10 @@ pub mod test {\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n         let actual_req = oldcomm::recv(server_result_po);\n-        log(debug, fmt!(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req));\n-        log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp));\n+        debug!(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req);\n+        debug!(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp);\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n@@ -1570,7 +1569,7 @@ pub mod test {\n         };\n         oldcomm::recv(cont_po);\n         // client\n-        log(debug, ~\"server started, firing up client..\");\n+        debug!(\"server started, firing up client..\");\n         do oldcomm::listen |client_ch| {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let iotask = uv::global_loop::get();\n@@ -1600,7 +1599,7 @@ pub mod test {\n         let server_port = 8889u;\n         let expected_req = ~\"ping\";\n         // client\n-        log(debug, ~\"firing up client..\");\n+        debug!(\"firing up client..\");\n         let actual_resp_result = do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1647,7 +1646,7 @@ pub mod test {\n                             server_port,\n                             hl_loop);\n         // client.. just doing this so that the first server tears down\n-        log(debug, ~\"server started, firing up client..\");\n+        debug!(\"server started, firing up client..\");\n         do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n@@ -1766,7 +1765,7 @@ pub mod test {\n         };\n         oldcomm::recv(cont_po);\n         // client\n-        log(debug, ~\"server started, firing up client..\");\n+        debug!(\"server started, firing up client..\");\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(move server_addr, server_port, hl_loop);\n         if result::is_err(&conn_result) {\n@@ -1777,23 +1776,23 @@ pub mod test {\n \n         let buf_reader = sock_buf as Reader;\n         let actual_response = str::from_bytes(buf_reader.read_whole_stream());\n-        log(debug, fmt!(\"Actual response: %s\", actual_response));\n+        debug!(\"Actual response: %s\", actual_response);\n         assert expected_resp == actual_response;\n     }\n \n     fn buf_write<W:io::Writer>(w: &W, val: &str) {\n-        log(debug, fmt!(\"BUF_WRITE: val len %?\", str::len(val)));\n+        debug!(\"BUF_WRITE: val len %?\", str::len(val));\n         do str::byte_slice(val) |b_slice| {\n-            log(debug, fmt!(\"BUF_WRITE: b_slice len %?\",\n-                            vec::len(b_slice)));\n+            debug!(\"BUF_WRITE: b_slice len %?\",\n+                            vec::len(b_slice));\n             w.write(b_slice)\n         }\n     }\n \n     fn buf_read<R:io::Reader>(r: &R, len: uint) -> ~str {\n         let new_bytes = (*r).read_bytes(len);\n-        log(debug, fmt!(\"in buf_read.. new_bytes len: %?\",\n-                        vec::len(new_bytes)));\n+        debug!(\"in buf_read.. new_bytes len: %?\",\n+                        vec::len(new_bytes));\n         str::from_bytes(new_bytes)\n     }\n \n@@ -1806,65 +1805,61 @@ pub mod test {\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, fmt!(\"establish_cb %?\",\n-                    kill_ch));\n+                debug!(\"establish_cb %?\", kill_ch);\n                 oldcomm::send(cont_ch, ());\n             },\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n-            log(debug, ~\"SERVER: new connection!\");\n+            debug!(\"SERVER: new connection!\");\n             do oldcomm::listen |cont_ch| {\n                 do task::spawn_sched(task::ManualThreads(1u)) {\n-                    log(debug, ~\"SERVER: starting worker for new req\");\n+                    debug!(\"SERVER: starting worker for new req\");\n \n                     let accept_result = accept(new_conn);\n-                    log(debug, ~\"SERVER: after accept()\");\n+                    debug!(\"SERVER: after accept()\");\n                     if result::is_err(&accept_result) {\n-                        log(debug, ~\"SERVER: error accept connection\");\n+                        debug!(\"SERVER: error accept connection\");\n                         let err_data = result::get_err(&accept_result);\n                         oldcomm::send(kill_ch, Some(err_data));\n-                        log(debug,\n-                            ~\"SERVER/WORKER: send on err cont ch\");\n+                        debug!(\"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n                     }\n                     else {\n-                        log(debug,\n-                            ~\"SERVER/WORKER: send on cont ch\");\n+                        debug!(\"SERVER/WORKER: send on cont ch\");\n                         cont_ch.send(());\n                         let sock = result::unwrap(move accept_result);\n                         let peer_addr = sock.get_peer_addr();\n-                        log(debug, ~\"SERVER: successfully accepted\"+\n-                            fmt!(\" connection from %s:%u\",\n+                        debug!(\"SERVER: successfully accepted connection from %s:%u\",\n                                  ip::format_addr(&peer_addr),\n-                                 ip::get_port(&peer_addr)));\n+                                 ip::get_port(&peer_addr));\n                         let received_req_bytes = read(&sock, 0u);\n                         match move received_req_bytes {\n                           result::Ok(move data) => {\n-                            log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n-                            log(debug, fmt!(\"SERVER: REQ data len: %?\",\n-                                            vec::len(data)));\n+                            debug!(\"SERVER: got REQ str::from_bytes..\");\n+                            debug!(\"SERVER: REQ data len: %?\",\n+                                            vec::len(data));\n                             server_ch.send(\n                                 str::from_bytes(data));\n-                            log(debug, ~\"SERVER: before write\");\n+                            debug!(\"SERVER: before write\");\n                             tcp_write_single(&sock, str::to_bytes(resp));\n-                            log(debug, ~\"SERVER: after write.. die\");\n+                            debug!(\"SERVER: after write.. die\");\n                             oldcomm::send(kill_ch, None);\n                           }\n                           result::Err(move err_data) => {\n-                            log(debug, fmt!(\"SERVER: error recvd: %s %s\",\n-                                err_data.err_name, err_data.err_msg));\n+                            debug!(\"SERVER: error recvd: %s %s\",\n+                                err_data.err_name, err_data.err_msg);\n                             oldcomm::send(kill_ch, Some(err_data));\n                             server_ch.send(~\"\");\n                           }\n                         }\n-                        log(debug, ~\"SERVER: worker spinning down\");\n+                        debug!(\"SERVER: worker spinning down\");\n                     }\n                 }\n-                log(debug, ~\"SERVER: waiting to recv on cont_ch\");\n+                debug!(\"SERVER: waiting to recv on cont_ch\");\n                 cont_ch.recv()\n             };\n-            log(debug, ~\"SERVER: recv'd on cont_ch..leaving listen cb\");\n+            debug!(\"SERVER: recv'd on cont_ch..leaving listen cb\");\n         });\n         // err check on listen_result\n         if result::is_err(&listen_result) {\n@@ -1882,7 +1877,7 @@ pub mod test {\n             }\n         }\n         let ret_val = server_ch.recv();\n-        log(debug, fmt!(\"SERVER: exited and got return val: '%s'\", ret_val));\n+        debug!(\"SERVER: exited and got return val: '%s'\", ret_val);\n         ret_val\n     }\n \n@@ -1893,8 +1888,7 @@ pub mod test {\n                                    iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, fmt!(\"establish_cb %?\",\n-                    kill_ch));\n+                debug!(\"establish_cb %?\", kill_ch);\n             },\n             |new_conn, kill_ch| {\n                 fail fmt!(\"SERVER: shouldn't be called.. %? %?\",\n@@ -1915,11 +1909,11 @@ pub mod test {\n                                                     TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n-        log(debug, ~\"CLIENT: starting..\");\n+        debug!(\"CLIENT: starting..\");\n         let connect_result = connect(move server_ip_addr, server_port,\n                                      iotask);\n         if result::is_err(&connect_result) {\n-            log(debug, ~\"CLIENT: failed to connect\");\n+            debug!(\"CLIENT: failed to connect\");\n             let err_data = result::get_err(&connect_result);\n             Err(err_data)\n         }\n@@ -1929,14 +1923,13 @@ pub mod test {\n             tcp_write_single(&sock, resp_bytes);\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n-                log(debug, ~\"CLIENT: failure to read\");\n+                debug!(\"CLIENT: failure to read\");\n                 Ok(~\"\")\n             }\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n-                log(debug, fmt!(\"CLIENT: after client_ch recv ret: '%s'\",\n-                   ret_val));\n+                debug!(\"CLIENT: after client_ch recv ret: '%s'\", ret_val);\n                 Ok(ret_val)\n             }\n         }\n@@ -1946,10 +1939,10 @@ pub mod test {\n         let write_result_future = sock.write_future(val);\n         let write_result = write_result_future.get();\n         if result::is_err(&write_result) {\n-            log(debug, ~\"tcp_write_single: write failed!\");\n+            debug!(\"tcp_write_single: write failed!\");\n             let err_data = result::get_err(&write_result);\n-            log(debug, fmt!(\"tcp_write_single err name: %s msg: %s\",\n-                err_data.err_name, err_data.err_msg));\n+            debug!(\"tcp_write_single err name: %s msg: %s\",\n+                err_data.err_name, err_data.err_msg);\n             // meh. torn on what to do here.\n             fail ~\"tcp_write_single failed\";\n         }"}]}