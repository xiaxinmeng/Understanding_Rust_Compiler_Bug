{"sha": "cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNGQ0ZjY0NmI2MjI3MjQyYjJkNGUyMTZlOGUzMGI1ZTExMWUwMmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-08T22:09:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-08T22:09:03Z"}, "message": "Merge #8773\n\n8773: fix: Correctly support SelfType when searching for usages r=Veykril a=Veykril\n\nFixes #7443\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "eb8a2ca7b63125f6975067b2ee1439244b3cbf97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb8a2ca7b63125f6975067b2ee1439244b3cbf97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglwv/CRBK7hj4Ov3rIwAAeBcIAAHRK0rrrB5RAq7mrX+05k7B\nqMvYBq7IWO5RKT8dNqxot2EU9bNPichb38E0flw3QRm/19RvPJnrCdO2y/HzkImf\n9U5uRDnB1la449sMoUwbFV/Ve0P74gpjvPUCdSgl9gidH8JUPzMbI38txNBUiC+W\nWL0C9r3czA7v9xXAqifF8QiVscSF0I24W+BEId6dwkIXqse4XTyTPpf1H+TegUye\nStpozDK0W+SlDhuiW+VdcGnOwmpe2gKjWaB+fGvkLxFJPtTe+GSt+L53Frha+K8r\nRJbas6wHtGzYgFx0SY5ue31HEmC21JeICLzoaq9CT79KlNW5yGwVYep9w4qPXxA=\n=nvW0\n-----END PGP SIGNATURE-----\n", "payload": "tree eb8a2ca7b63125f6975067b2ee1439244b3cbf97\nparent 6cd11bbbc235bcc3891f20c6d4097834cf1990e5\nparent 3a346412cf8ce2f04e123195452bf1b1c86211a7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620511743 +0000\ncommitter GitHub <noreply@github.com> 1620511743 +0000\n\nMerge #8773\n\n8773: fix: Correctly support SelfType when searching for usages r=Veykril a=Veykril\n\nFixes #7443\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "html_url": "https://github.com/rust-lang/rust/commit/cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cd11bbbc235bcc3891f20c6d4097834cf1990e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd11bbbc235bcc3891f20c6d4097834cf1990e5", "html_url": "https://github.com/rust-lang/rust/commit/6cd11bbbc235bcc3891f20c6d4097834cf1990e5"}, {"sha": "3a346412cf8ce2f04e123195452bf1b1c86211a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a346412cf8ce2f04e123195452bf1b1c86211a7", "html_url": "https://github.com/rust-lang/rust/commit/3a346412cf8ce2f04e123195452bf1b1c86211a7"}], "stats": {"total": 300, "additions": 222, "deletions": 78}, "files": [{"sha": "c9ef4b42056878205e3644197067bbe9a7779408", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -2071,6 +2071,10 @@ impl Type {\n         Some(adt.into())\n     }\n \n+    pub fn as_builtin(&self) -> Option<BuiltinType> {\n+        self.ty.as_builtin().map(|inner| BuiltinType { inner })\n+    }\n+\n     pub fn as_dyn_trait(&self) -> Option<Trait> {\n         self.ty.dyn_trait().map(Into::into)\n     }"}, {"sha": "5232a7d80387fcdf4d68ffac43e84195b043d0f0", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -1,8 +1,10 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::Mutability;\n+use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n use hir_def::{\n-    type_ref::Rawness, AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup, TraitId,\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n+    type_ref::Rawness,\n+    AssocContainerId, FunctionId, GenericDefId, HasModule, Lookup, TraitId,\n };\n \n use crate::{\n@@ -18,6 +20,7 @@ pub trait TyExt {\n     fn is_unknown(&self) -> bool;\n \n     fn as_adt(&self) -> Option<(hir_def::AdtId, &Substitution)>;\n+    fn as_builtin(&self) -> Option<BuiltinType>;\n     fn as_tuple(&self) -> Option<&Substitution>;\n     fn as_fn_def(&self, db: &dyn HirDatabase) -> Option<FunctionId>;\n     fn as_reference(&self) -> Option<(&Ty, Lifetime, Mutability)>;\n@@ -59,6 +62,35 @@ impl TyExt for Ty {\n         }\n     }\n \n+    fn as_builtin(&self) -> Option<BuiltinType> {\n+        match self.kind(&Interner) {\n+            TyKind::Str => Some(BuiltinType::Str),\n+            TyKind::Scalar(Scalar::Bool) => Some(BuiltinType::Bool),\n+            TyKind::Scalar(Scalar::Char) => Some(BuiltinType::Char),\n+            TyKind::Scalar(Scalar::Float(fty)) => Some(BuiltinType::Float(match fty {\n+                FloatTy::F64 => BuiltinFloat::F64,\n+                FloatTy::F32 => BuiltinFloat::F32,\n+            })),\n+            TyKind::Scalar(Scalar::Int(ity)) => Some(BuiltinType::Int(match ity {\n+                IntTy::Isize => BuiltinInt::Isize,\n+                IntTy::I8 => BuiltinInt::I8,\n+                IntTy::I16 => BuiltinInt::I16,\n+                IntTy::I32 => BuiltinInt::I32,\n+                IntTy::I64 => BuiltinInt::I64,\n+                IntTy::I128 => BuiltinInt::I128,\n+            })),\n+            TyKind::Scalar(Scalar::Uint(ity)) => Some(BuiltinType::Uint(match ity {\n+                UintTy::Usize => BuiltinUint::Usize,\n+                UintTy::U8 => BuiltinUint::U8,\n+                UintTy::U16 => BuiltinUint::U16,\n+                UintTy::U32 => BuiltinUint::U32,\n+                UintTy::U64 => BuiltinUint::U64,\n+                UintTy::U128 => BuiltinUint::U128,\n+            })),\n+            _ => None,\n+        }\n+    }\n+\n     fn as_tuple(&self) -> Option<&Substitution> {\n         match self.kind(&Interner) {\n             TyKind::Tuple(_, substs) => Some(substs),"}, {"sha": "ae492a264f7aa6898c7f98e503c467a7ed5c1f79", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn find_all_refs(\n             (find_def(&sema, &syntax, position)?, false)\n         };\n \n-    let mut usages = def.usages(sema).set_scope(search_scope).all();\n+    let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n     if is_literal_search {\n         // filter for constructor-literals\n         let refs = usages.references.values_mut();\n@@ -1163,21 +1163,75 @@ fn foo<const FOO$0: usize>() -> usize {\n     }\n \n     #[test]\n-    fn test_find_self_ty_in_trait_def() {\n+    fn test_trait() {\n         check(\n             r#\"\n-trait Foo {\n-    fn f() -> Self$0;\n+trait Foo$0 where Self: {}\n+\n+impl Foo for () {}\n+\"#,\n+            expect![[r#\"\n+                Foo Trait FileId(0) 0..24 6..9\n+\n+                FileId(0) 31..34\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_trait_self() {\n+        check(\n+            r#\"\n+trait Foo where Self$0 {\n+    fn f() -> Self;\n }\n+\n+impl Foo for () {}\n \"#,\n             expect![[r#\"\n                 Self TypeParam FileId(0) 6..9 6..9\n \n-                FileId(0) 26..30\n+                FileId(0) 16..20\n+                FileId(0) 37..41\n             \"#]],\n         );\n     }\n \n+    #[test]\n+    fn test_self_ty() {\n+        check(\n+            r#\"\n+        struct $0Foo;\n+\n+        impl Foo where Self: {\n+            fn f() -> Self;\n+        }\n+        \"#,\n+            expect![[r#\"\n+                Foo Struct FileId(0) 0..11 7..10\n+\n+                FileId(0) 18..21\n+                FileId(0) 28..32\n+                FileId(0) 50..54\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+struct Foo;\n+\n+impl Foo where Self: {\n+    fn f() -> Self$0;\n+}\n+\"#,\n+            expect![[r#\"\n+                impl Impl FileId(0) 13..57 18..21\n+\n+                FileId(0) 18..21\n+                FileId(0) 28..32\n+                FileId(0) 50..54\n+            \"#]],\n+        );\n+    }\n     #[test]\n     fn test_self_variant_with_payload() {\n         check("}, {"sha": "2bf9533052a26c1f8ce394e6f017470bfc8e5dad", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -1888,4 +1888,21 @@ impl Foo {\n             \"error: Cannot rename `Self`\",\n         );\n     }\n+\n+    #[test]\n+    fn test_rename_ignores_self_ty() {\n+        check(\n+            \"Fo0\",\n+            r#\"\n+struct $0Foo;\n+\n+impl Foo where Self: {}\n+\"#,\n+            r#\"\n+struct Fo0;\n+\n+impl Fo0 where Self: {}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "70949ca3580f7c3df6a9c9784305a3e281ba3434", "filename": "crates/ide_assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -107,7 +107,7 @@ fn edit_struct_references(\n     names: &[ast::Name],\n ) {\n     let strukt_def = Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(strukt)));\n-    let usages = strukt_def.usages(&ctx.sema).include_self_kw_refs(true).all();\n+    let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n \n     let edit_node = |edit: &mut AssistBuilder, node: SyntaxNode| -> Option<()> {\n         match_ast! {"}, {"sha": "67840602bb8f9c482511ba9fa2015cfbacca610f", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 107, "deletions": 70, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4d4f646b6227242b2d4e216e8e30b5e111e02e/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=cf4d4f646b6227242b2d4e216e8e30b5e111e02e", "patch": "@@ -233,6 +233,13 @@ impl Definition {\n             };\n         }\n \n+        if let Definition::SelfType(impl_) = self {\n+            return match impl_.source(db).map(|src| src.value.syntax().text_range()) {\n+                Some(range) => SearchScope::file_range(FileRange { file_id, range }),\n+                None => SearchScope::single_file(file_id),\n+            };\n+        }\n+\n         if let Definition::GenericParam(hir::GenericParam::LifetimeParam(param)) = self {\n             let range = match param.parent(db) {\n                 hir::GenericDef::Function(it) => {\n@@ -297,20 +304,21 @@ impl Definition {\n     }\n \n     pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n-        FindUsages { def: self, sema, scope: None, include_self_kw_refs: false }\n+        FindUsages { def: self, sema, scope: None, include_self_kw_refs: None }\n     }\n }\n \n pub struct FindUsages<'a> {\n     def: &'a Definition,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n-    include_self_kw_refs: bool,\n+    include_self_kw_refs: Option<hir::Type>,\n }\n \n impl<'a> FindUsages<'a> {\n-    pub fn include_self_kw_refs(mut self, include: bool) -> FindUsages<'a> {\n-        self.include_self_kw_refs = include;\n+    /// Enable searching for `Self` when the definition is a type.\n+    pub fn include_self_refs(mut self) -> FindUsages<'a> {\n+        self.include_self_kw_refs = def_to_ty(self.sema, self.def);\n         self\n     }\n \n@@ -354,13 +362,18 @@ impl<'a> FindUsages<'a> {\n             }\n         };\n \n-        let name = match self.def.name(sema.db) {\n-            Some(it) => it.to_string(),\n+        let name = self.def.name(sema.db).or_else(|| {\n+            self.include_self_kw_refs.as_ref().and_then(|ty| {\n+                ty.as_adt()\n+                    .map(|adt| adt.name(self.sema.db))\n+                    .or_else(|| ty.as_builtin().map(|builtin| builtin.name()))\n+            })\n+        });\n+        let name = match name {\n+            Some(name) => name.to_string(),\n             None => return,\n         };\n-\n-        let pat = name.as_str();\n-        let search_for_self = self.include_self_kw_refs;\n+        let name = name.as_str();\n \n         for (file_id, search_range) in search_scope {\n             let text = sema.db.file_text(file_id);\n@@ -369,51 +382,63 @@ impl<'a> FindUsages<'a> {\n \n             let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n \n-            let mut handle_match = |idx: usize| -> bool {\n+            for (idx, _) in text.match_indices(name) {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n-                    return false;\n+                    continue;\n                 }\n \n                 if let Some(name) = sema.find_node_at_offset_with_descend(&tree, offset) {\n-                    match name {\n-                        ast::NameLike::NameRef(name_ref) => {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return true;\n-                            }\n-                        }\n-                        ast::NameLike::Name(name) => {\n-                            if self.found_name(&name, sink) {\n-                                return true;\n-                            }\n-                        }\n-                        ast::NameLike::Lifetime(lifetime) => {\n-                            if self.found_lifetime(&lifetime, sink) {\n-                                return true;\n-                            }\n-                        }\n+                    if match name {\n+                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n+                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n+                    } {\n+                        return;\n                     }\n                 }\n-\n-                return false;\n-            };\n-\n-            for (idx, _) in text.match_indices(pat) {\n-                if handle_match(idx) {\n-                    return;\n-                }\n             }\n-\n-            if search_for_self {\n+            if let Some(self_ty) = &self.include_self_kw_refs {\n                 for (idx, _) in text.match_indices(\"Self\") {\n-                    if handle_match(idx) {\n-                        return;\n+                    let offset: TextSize = idx.try_into().unwrap();\n+                    if !search_range.contains_inclusive(offset) {\n+                        continue;\n+                    }\n+\n+                    if let Some(ast::NameLike::NameRef(name_ref)) =\n+                        sema.find_node_at_offset_with_descend(&tree, offset)\n+                    {\n+                        if self.found_self_ty_name_ref(&self_ty, &name_ref, sink) {\n+                            return;\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n+    fn found_self_ty_name_ref(\n+        &self,\n+        self_ty: &hir::Type,\n+        name_ref: &ast::NameRef,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n+    ) -> bool {\n+        match NameRefClass::classify(self.sema, &name_ref) {\n+            Some(NameRefClass::Definition(Definition::SelfType(impl_)))\n+                if impl_.self_ty(self.sema.db) == *self_ty =>\n+            {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::NameRef(name_ref.clone()),\n+                    access: None,\n+                };\n+                sink(file_id, reference)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn found_lifetime(\n         &self,\n         lifetime: &ast::Lifetime,\n@@ -429,7 +454,7 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n \n@@ -448,42 +473,35 @@ impl<'a> FindUsages<'a> {\n                 };\n                 sink(file_id, reference)\n             }\n-            Some(NameRefClass::Definition(Definition::SelfType(impl_))) => {\n-                let ty = impl_.self_ty(self.sema.db);\n-\n-                if let Some(adt) = ty.as_adt() {\n-                    if &Definition::ModuleDef(ModuleDef::Adt(adt)) == self.def {\n-                        let FileRange { file_id, range } =\n-                            self.sema.original_range(name_ref.syntax());\n-                        let reference = FileReference {\n-                            range,\n-                            name: ast::NameLike::NameRef(name_ref.clone()),\n-                            access: None,\n-                        };\n-                        return sink(file_id, reference);\n-                    }\n+            Some(NameRefClass::Definition(def)) if self.include_self_kw_refs.is_some() => {\n+                if self.include_self_kw_refs == def_to_ty(self.sema, &def) {\n+                    let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                    let reference = FileReference {\n+                        range,\n+                        name: ast::NameLike::NameRef(name_ref.clone()),\n+                        access: reference_access(&def, &name_ref),\n+                    };\n+                    sink(file_id, reference)\n+                } else {\n+                    false\n                 }\n-\n-                false\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n-                let reference = match self.def {\n-                    Definition::Field(_) if &field == self.def => FileReference {\n-                        range,\n-                        name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&field, &name_ref),\n-                    },\n-                    Definition::Local(l) if &local == l => FileReference {\n-                        range,\n-                        name: ast::NameLike::NameRef(name_ref.clone()),\n-                        access: reference_access(&Definition::Local(local), &name_ref),\n-                    },\n-                    _ => return false, // not a usage\n+                let access = match self.def {\n+                    Definition::Field(_) if &field == self.def => {\n+                        reference_access(&field, &name_ref)\n+                    }\n+                    Definition::Local(l) if &local == l => {\n+                        reference_access(&Definition::Local(local), &name_ref)\n+                    }\n+                    _ => return false,\n                 };\n+                let reference =\n+                    FileReference { range, name: ast::NameLike::NameRef(name_ref.clone()), access };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n \n@@ -513,11 +531,30 @@ impl<'a> FindUsages<'a> {\n                     FileReference { range, name: ast::NameLike::Name(name.clone()), access: None };\n                 sink(file_id, reference)\n             }\n-            _ => false, // not a usage\n+            _ => false,\n         }\n     }\n }\n \n+fn def_to_ty(sema: &Semantics<RootDatabase>, def: &Definition) -> Option<hir::Type> {\n+    match def {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Adt(adt) => Some(adt.ty(sema.db)),\n+            ModuleDef::TypeAlias(it) => Some(it.ty(sema.db)),\n+            ModuleDef::BuiltinType(it) => {\n+                let graph = sema.db.crate_graph();\n+                let krate = graph.iter().next()?;\n+                let root_file = graph[krate].root_file_id;\n+                let module = sema.to_module_def(root_file)?;\n+                Some(it.ty(sema.db, module))\n+            }\n+            _ => None,\n+        },\n+        Definition::SelfType(it) => Some(it.self_ty(sema.db)),\n+        _ => None,\n+    }\n+}\n+\n fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n     // Only Locals and Fields have accesses for now.\n     if !matches!(def, Definition::Local(_) | Definition::Field(_)) {"}]}