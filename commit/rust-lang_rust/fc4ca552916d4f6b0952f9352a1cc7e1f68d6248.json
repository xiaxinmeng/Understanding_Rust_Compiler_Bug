{"sha": "fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNGNhNTUyOTE2ZDRmNmIwOTUyZjkzNTJhMWNjN2UxZjY4ZDYyNDg=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-15T19:09:26Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-17T20:16:03Z"}, "message": "Add `from_def_id_and_kind` reducing duplication in rustdoc\n\n- Add `Item::from_hir_id_and_kind` convenience wrapper\n- Make name parameter mandatory\n\n  `tcx.opt_item_name` doesn't handle renames, so this is necessary\n  for any item that could be renamed, which is almost all of them.\n\n- Override visibilities to be `Inherited` for enum variants\n\n  `tcx.visibility` returns the effective visibility, not the visibility\n  that was written in the source code. `pub enum E { A, B }` always has\n  public variants `A` and `B`, so there's no sense printing `pub` again.\n\n- Don't duplicate handling of `Visibility::Crate`\n\n  Instead, represent it as just another `Restricted` path.", "tree": {"sha": "b64dbe7cab7e656bb761267463e8975279003796", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b64dbe7cab7e656bb761267463e8975279003796"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "html_url": "https://github.com/rust-lang/rust/commit/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9a17b1d3f27690da2991db76866a3edb0f6d6ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a17b1d3f27690da2991db76866a3edb0f6d6ac", "html_url": "https://github.com/rust-lang/rust/commit/c9a17b1d3f27690da2991db76866a3edb0f6d6ac"}], "stats": {"total": 453, "additions": 193, "deletions": 260}, "files": [{"sha": "cc3e8707e52768fcbf981d0a07509d963d378274", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "patch": "@@ -124,16 +124,8 @@ crate fn try_inline(\n     let attrs = merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n \n     cx.renderinfo.borrow_mut().inlined.insert(did);\n-    ret.push(clean::Item {\n-        source: cx.tcx.def_span(did).clean(cx),\n-        name: Some(name.clean(cx)),\n-        attrs,\n-        kind,\n-        visibility: clean::Public,\n-        stability: cx.tcx.lookup_stability(did).cloned(),\n-        deprecation: cx.tcx.lookup_deprecation(did).clean(cx),\n-        def_id: did,\n-    });\n+    let what_rustc_thinks = clean::Item::from_def_id_and_parts(did, Some(name), kind, cx);\n+    ret.push(clean::Item { attrs, ..what_rustc_thinks });\n     Some(ret)\n }\n \n@@ -443,8 +435,10 @@ crate fn build_impl(\n \n     debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n-    ret.push(clean::Item {\n-        kind: clean::ImplItem(clean::Impl {\n+    ret.push(clean::Item::from_def_id_and_parts(\n+        did,\n+        None,\n+        clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal,\n             generics,\n             provided_trait_methods: provided,\n@@ -455,14 +449,8 @@ crate fn build_impl(\n             synthetic: false,\n             blanket_impl: None,\n         }),\n-        source: tcx.def_span(did).clean(cx),\n-        name: None,\n-        attrs,\n-        visibility: clean::Inherited,\n-        stability: tcx.lookup_stability(did).cloned(),\n-        deprecation: tcx.lookup_deprecation(did).clean(cx),\n-        def_id: did,\n-    });\n+        cx,\n+    ));\n }\n \n fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>) -> clean::Module {"}, {"sha": "05c1d7a0d99cc0fde657eff26ccfb6af3e43e879", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 141, "deletions": 238, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "patch": "@@ -223,12 +223,6 @@ impl Clean<ExternalCrate> for CrateNum {\n \n impl Clean<Item> for doctree::Module<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let name = if self.name.is_some() {\n-            self.name.expect(\"No name provided\").clean(cx)\n-        } else {\n-            String::new()\n-        };\n-\n         // maintain a stack of mod ids, for doc comment path resolution\n         // but we also need to resolve the module's own docs based on whether its docs were written\n         // inside or outside the module, so check for that\n@@ -268,15 +262,17 @@ impl Clean<Item> for doctree::Module<'_> {\n             }\n         };\n \n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.id,\n+            self.name,\n+            ModuleItem(Module { is_crate: self.is_crate, items }),\n+            cx,\n+        );\n         Item {\n-            name: Some(name),\n+            name: Some(what_rustc_thinks.name.unwrap_or_default()),\n             attrs,\n             source: span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: ModuleItem(Module { is_crate: self.is_crate, items }),\n+            ..what_rustc_thinks\n         }\n     }\n }\n@@ -897,31 +893,26 @@ impl Clean<Item> for doctree::Function<'_> {\n         let (generics, decl) =\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n-        let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if is_const_fn(cx.tcx, did.to_def_id())\n-            && !is_unstable_const_fn(cx.tcx, did.to_def_id()).is_some()\n+        let did = cx.tcx.hir().local_def_id(self.id).to_def_id();\n+        let constness = if is_const_fn(cx.tcx, did) && !is_unstable_const_fn(cx.tcx, did).is_some()\n         {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n         };\n         let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: did.to_def_id(),\n-            kind: FunctionItem(Function {\n+        Item::from_def_id_and_parts(\n+            did,\n+            Some(self.name),\n+            FunctionItem(Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n                 all_types,\n                 ret_types,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1013,42 +1004,33 @@ impl Clean<Item> for doctree::Trait<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(sym::spotlight);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs,\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TraitItem(Trait {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TraitItem(Trait {\n                 unsafety: self.unsafety,\n                 items: self.items.iter().map(|ti| ti.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n                 is_spotlight,\n                 is_auto: self.is_auto.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::TraitAlias<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let attrs = self.attrs.clean(cx);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs,\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TraitAliasItem(TraitAlias {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TraitAliasItem(TraitAlias {\n                 generics: self.generics.clean(cx),\n                 bounds: self.bounds.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1098,15 +1080,15 @@ impl Clean<TypeKind> for hir::def::DefKind {\n \n impl Clean<Item> for hir::TraitItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let kind = match self.kind {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let inner = match self.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1119,7 +1101,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 let mut t = Function { header: sig.header, decl, generics, all_types, ret_types };\n                 if t.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     t.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1129,30 +1111,21 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                 AssocTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: local_did.to_def_id(),\n-            visibility: Visibility::Inherited,\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n     }\n }\n \n impl Clean<Item> for hir::ImplItem<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-        let kind = match self.kind {\n+        let local_did = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n+        let inner = match self.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 let mut m = (sig, &self.generics, body).clean(cx);\n                 if m.header.constness == hir::Constness::Const\n-                    && is_unstable_const_fn(cx.tcx, local_did.to_def_id()).is_some()\n+                    && is_unstable_const_fn(cx.tcx, local_did).is_some()\n                 {\n                     m.header.constness = hir::Constness::NotConst;\n                 }\n@@ -1164,16 +1137,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n         };\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            source: self.span.clean(cx),\n-            attrs: self.attrs.clean(cx),\n-            def_id: local_did.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx)\n     }\n }\n \n@@ -1329,21 +1293,7 @@ impl Clean<Item> for ty::AssocItem {\n             }\n         };\n \n-        let visibility = match self.container {\n-            ty::ImplContainer(_) => self.vis.clean(cx),\n-            ty::TraitContainer(_) => Inherited,\n-        };\n-\n-        Item {\n-            name: Some(self.ident.name.clean(cx)),\n-            visibility,\n-            stability: get_stability(cx, self.def_id),\n-            deprecation: get_deprecation(cx, self.def_id),\n-            def_id: self.def_id,\n-            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n-            source: cx.tcx.def_span(self.def_id).clean(cx),\n-            kind,\n-        }\n+        Item::from_def_id_and_parts(self.def_id, Some(self.ident.name), kind, cx)\n     }\n }\n \n@@ -1773,33 +1723,27 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n \n impl Clean<Item> for hir::StructField<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let local_did = cx.tcx.hir().local_def_id(self.hir_id);\n-\n-        Item {\n-            name: Some(self.ident.name).clean(cx),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, local_did.to_def_id()),\n-            deprecation: get_deprecation(cx, local_did.to_def_id()),\n-            def_id: local_did.to_def_id(),\n-            kind: StructFieldItem(self.ty.clean(cx)),\n-        }\n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.hir_id,\n+            Some(self.ident.name),\n+            StructFieldItem(self.ty.clean(cx)),\n+            cx,\n+        );\n+        // Don't show `pub` for fields on enum variants; they are always public\n+        Item { visibility: self.vis.clean(cx), ..what_rustc_thinks }\n     }\n }\n \n impl Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.ident.name).clean(cx),\n-            attrs: cx.tcx.get_attrs(self.did).clean(cx),\n-            source: cx.tcx.def_span(self.did).clean(cx),\n-            visibility: self.vis.clean(cx),\n-            stability: get_stability(cx, self.did),\n-            deprecation: get_deprecation(cx, self.did),\n-            def_id: self.did,\n-            kind: StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n-        }\n+        let what_rustc_thinks = Item::from_def_id_and_parts(\n+            self.did,\n+            Some(self.ident.name),\n+            StructFieldItem(cx.tcx.type_of(self.did).clean(cx)),\n+            cx,\n+        );\n+        // Don't show `pub` for fields on enum variants; they are always public\n+        Item { visibility: self.vis.clean(cx), ..what_rustc_thinks }\n     }\n }\n \n@@ -1808,7 +1752,10 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n-            hir::VisibilityKind::Crate(_) => Visibility::Crate,\n+            hir::VisibilityKind::Crate(_) => {\n+                let krate = DefId::local(CRATE_DEF_INDEX);\n+                Visibility::Restricted(krate, cx.tcx.def_path(krate))\n+            }\n             hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_res(cx, path.res);\n@@ -1819,48 +1766,46 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n }\n \n impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, _: &DocContext<'_>) -> Visibility {\n-        if *self == ty::Visibility::Public { Public } else { Inherited }\n+    fn clean(&self, cx: &DocContext<'_>) -> Visibility {\n+        match *self {\n+            ty::Visibility::Public => Visibility::Public,\n+            ty::Visibility::Invisible => Visibility::Inherited,\n+            ty::Visibility::Restricted(module) => {\n+                Visibility::Restricted(module, cx.tcx.def_path(module))\n+            }\n+        }\n     }\n }\n \n impl Clean<Item> for doctree::Struct<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: StructItem(Struct {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Union<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: UnionItem(Union {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            UnionItem(Union {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(cx),\n                 fields: self.fields.clean(cx),\n                 fields_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -1876,35 +1821,29 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n \n impl Clean<Item> for doctree::Enum<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: EnumItem(Enum {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            EnumItem(Enum {\n                 variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n                 generics: self.generics.clean(cx),\n                 variants_stripped: false,\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Inherited,\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: VariantItem(Variant { kind: self.def.clean(cx) }),\n-        }\n+        let what_rustc_thinks = Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            VariantItem(Variant { kind: self.def.clean(cx) }),\n+            cx,\n+        );\n+        // don't show `pub` for variants, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n \n@@ -1925,7 +1864,7 @@ impl Clean<Item> for ty::VariantDef {\n                         source: cx.tcx.def_span(field.did).clean(cx),\n                         name: Some(field.ident.name.clean(cx)),\n                         attrs: cx.tcx.get_attrs(field.did).clean(cx),\n-                        visibility: field.vis.clean(cx),\n+                        visibility: Visibility::Inherited,\n                         def_id: field.did,\n                         stability: get_stability(cx, field.did),\n                         deprecation: get_deprecation(cx, field.did),\n@@ -1934,16 +1873,14 @@ impl Clean<Item> for ty::VariantDef {\n                     .collect(),\n             }),\n         };\n-        Item {\n-            name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, self.def_id).clean(cx),\n-            source: cx.tcx.def_span(self.def_id).clean(cx),\n-            visibility: Inherited,\n-            def_id: self.def_id,\n-            kind: VariantItem(Variant { kind }),\n-            stability: get_stability(cx, self.def_id),\n-            deprecation: get_deprecation(cx, self.def_id),\n-        }\n+        let what_rustc_thinks = Item::from_def_id_and_parts(\n+            self.def_id,\n+            Some(self.ident.name),\n+            VariantItem(Variant { kind }),\n+            cx,\n+        );\n+        // don't show `pub` for fields, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n \n@@ -2048,34 +1985,26 @@ impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let type_ = self.ty.clean(cx);\n         let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n-        }\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::OpaqueTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: OpaqueTyItem(OpaqueTy {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            OpaqueTyItem(OpaqueTy {\n                 bounds: self.opaque_ty.bounds.clean(cx),\n                 generics: self.opaque_ty.generics.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -2091,42 +2020,34 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n impl Clean<Item> for doctree::Static<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: StaticItem(Static {\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            StaticItem(Static {\n                 type_: self.type_.clean(cx),\n                 mutability: self.mutability,\n                 expr: print_const_expr(cx, self.expr),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::Constant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let def_id = cx.tcx.hir().local_def_id(self.id);\n+        let def_id = cx.tcx.hir().local_def_id(self.id).to_def_id();\n \n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: def_id.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: ConstantItem(Constant {\n+        Item::from_def_id_and_parts(\n+            def_id,\n+            Some(self.name),\n+            ConstantItem(Constant {\n                 type_: self.type_.clean(cx),\n                 expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id.to_def_id()),\n+                value: print_evaluated_const(cx, def_id),\n                 is_literal: is_literal_expr(cx, self.expr.hir_id),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n@@ -2355,57 +2276,39 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };\n \n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind,\n-        }\n+        Item::from_hir_id_and_parts(self.id, Some(self.name), kind, cx)\n     }\n }\n \n impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let name = self.name.clean(cx);\n-        Item {\n-            name: Some(name.clone()),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Public,\n-            stability: cx.stability(self.hid),\n-            deprecation: cx.deprecation(self.hid).clean(cx),\n-            def_id: self.def_id,\n-            kind: MacroItem(Macro {\n+        Item::from_def_id_and_parts(\n+            self.def_id,\n+            Some(self.name),\n+            MacroItem(Macro {\n                 source: format!(\n                     \"macro_rules! {} {{\\n{}}}\",\n-                    name,\n+                    self.name,\n                     self.matchers\n                         .iter()\n                         .map(|span| { format!(\"    {} => {{ ... }};\\n\", span.to_src(cx)) })\n                         .collect::<String>()\n                 ),\n                 imported_from: self.imported_from.clean(cx),\n             }),\n-        }\n+            cx,\n+        )\n     }\n }\n \n impl Clean<Item> for doctree::ProcMacro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item {\n-            name: Some(self.name.clean(cx)),\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            visibility: Public,\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n-            kind: ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n-        }\n+        Item::from_hir_id_and_parts(\n+            self.id,\n+            Some(self.name),\n+            ProcMacroItem(ProcMacro { kind: self.kind, helpers: self.helpers.clean(cx) }),\n+            cx,\n+        )\n     }\n }\n "}, {"sha": "43b986aae1c321155e1ea5880814717db7824d34", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "patch": "@@ -112,6 +112,48 @@ impl Item {\n         self.attrs.doc_value()\n     }\n \n+    /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n+    /// `hir_id` to a [`DefId`]\n+    pub fn from_hir_id_and_parts(\n+        hir_id: hir::HirId,\n+        name: Option<Symbol>,\n+        kind: ItemKind,\n+        cx: &DocContext<'_>,\n+    ) -> Item {\n+        Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n+    }\n+\n+    pub fn from_def_id_and_parts(\n+        def_id: DefId,\n+        name: Option<Symbol>,\n+        kind: ItemKind,\n+        cx: &DocContext<'_>,\n+    ) -> Item {\n+        use super::Clean;\n+\n+        debug!(\"name={:?}, def_id={:?}\", name, def_id);\n+\n+        // `span_if_local()` lies about functions and only gives the span of the function signature\n+        let source = def_id.as_local().map_or_else(\n+            || cx.tcx.def_span(def_id),\n+            |local| {\n+                let hir = cx.tcx.hir();\n+                hir.span_with_body(hir.local_def_id_to_hir_id(local))\n+            },\n+        );\n+\n+        Item {\n+            def_id,\n+            kind,\n+            name: name.clean(cx),\n+            source: source.clean(cx),\n+            attrs: cx.tcx.get_attrs(def_id).clean(cx),\n+            visibility: cx.tcx.visibility(def_id).clean(cx),\n+            stability: cx.tcx.lookup_stability(def_id).cloned(),\n+            deprecation: cx.tcx.lookup_deprecation(def_id).clean(cx),\n+        }\n+    }\n+\n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n     crate fn collapsed_doc_value(&self) -> Option<String> {\n@@ -1464,7 +1506,6 @@ impl From<hir::PrimTy> for PrimitiveType {\n crate enum Visibility {\n     Public,\n     Inherited,\n-    Crate,\n     Restricted(DefId, rustc_hir::definitions::DefPath),\n }\n "}, {"sha": "536c2e08fdef84a7b868e8547bb31072f887f143", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "patch": "@@ -1094,7 +1094,6 @@ impl clean::Visibility {\n         display_fn(move |f| match *self {\n             clean::Public => f.write_str(\"pub \"),\n             clean::Inherited => Ok(()),\n-            clean::Visibility::Crate => write!(f, \"pub(crate) \"),\n             // If this is `pub(crate)`, `path` will be empty.\n             clean::Visibility::Restricted(did, _) if did.index == CRATE_DEF_INDEX => {\n                 write!(f, \"pub(crate) \")"}, {"sha": "13468c153132e7b602c9243b14b5e52f993db57a", "filename": "src/test/rustdoc/issue-32395.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4ca552916d4f6b0952f9352a1cc7e1f68d6248/src%2Ftest%2Frustdoc%2Fissue-32395.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32395.rs?ref=fc4ca552916d4f6b0952f9352a1cc7e1f68d6248", "patch": "@@ -4,10 +4,12 @@\n \n // @has variant_struct/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub(crate) qux'\n // @!has - 'pub Bar'\n extern crate variant_struct;\n \n // @has issue_32395/enum.Foo.html\n // @!has - 'pub qux'\n+// @!has - 'pub(crate) qux'\n // @!has - 'pub Bar'\n pub use variant_struct::Foo;"}]}