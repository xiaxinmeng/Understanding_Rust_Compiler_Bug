{"sha": "a59a6d8a5687dd6aee871de0e7c9f734709ac544", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OWE2ZDhhNTY4N2RkNmFlZTg3MWRlMGU3YzlmNzM0NzA5YWM1NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-01T10:40:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-01T10:40:18Z"}, "message": "Auto merge of #44171 - eddyb:scope, r=nikomatsakis\n\nUse hir::ItemLocalId instead of ast::NodeId in rustc::middle::region::CodeExtent.\n\nThis is an alternative to @michaelwoerister's #43887, changing `CodeExtent` instead of `ReScope`.\n\nThe benefit here is that the same `Region`s are used same-crate and cross-crate, while preserving the incremental recompilation properties of the stable `hir::ItemLocalId`.\n\nOnly places which needed to get back to the `ast::NodeId` from `CodeExtent` was its `span` method, used in error reporting - passing the `&RegionMaps` down allowed using `hir_to_node_id`.\n`rustc::cfg` and `dataflow` also had to be converted to `hir::ItemLocalId` because of their interactions with `CodeExtent`, especially in `borrowck`, and from that we have 3 more `hir_to_node_id` calls: `cfg::graphviz` node labels, `borrowck` move reporting, and the `unconditional_recursion` lint.\n\nOut of all of those, *only* the lint actually makes a decision (on whether code will compile) based on the result of the conversion, the others only use it to know how to print information to the user.\nSo I think we're safe to say that the bulk of the code working with a `CodeExtent` is fine with local IDs.\n\nr? @nikomatsakis", "tree": {"sha": "cd9918ad7389205be8218d9e30e182dff1cfc8ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd9918ad7389205be8218d9e30e182dff1cfc8ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a59a6d8a5687dd6aee871de0e7c9f734709ac544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a59a6d8a5687dd6aee871de0e7c9f734709ac544", "html_url": "https://github.com/rust-lang/rust/commit/a59a6d8a5687dd6aee871de0e7c9f734709ac544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a59a6d8a5687dd6aee871de0e7c9f734709ac544/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d31e73108b2a92d45a1a82b3e2846348112f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d31e73108b2a92d45a1a82b3e2846348112f57", "html_url": "https://github.com/rust-lang/rust/commit/45d31e73108b2a92d45a1a82b3e2846348112f57"}, {"sha": "e4996ec49c832610f3044f49437b16527f2a726f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4996ec49c832610f3044f49437b16527f2a726f", "html_url": "https://github.com/rust-lang/rust/commit/e4996ec49c832610f3044f49437b16527f2a726f"}], "stats": {"total": 1427, "additions": 670, "deletions": 757}, "files": [{"sha": "8908bcb88655901d0b7926d13a933bff4ee05c8d", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 47, "deletions": 46, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::graph;\n use cfg::*;\n use middle::region::CodeExtent;\n use ty::{self, TyCtxt};\n-use syntax::ast;\n use syntax::ptr::P;\n \n use hir::{self, PatKind};\n@@ -30,13 +29,13 @@ struct CFGBuilder<'a, 'tcx: 'a> {\n \n #[derive(Copy, Clone)]\n struct BlockScope {\n-    block_expr_id: ast::NodeId, // id of breakable block expr node\n+    block_expr_id: hir::ItemLocalId, // id of breakable block expr node\n     break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n-    loop_id: ast::NodeId,     // id of loop/while node\n+    loop_id: hir::ItemLocalId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n     break_index: CFGIndex,    // where to go on a `break`\n }\n@@ -70,6 +69,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder { graph, .. } = cfg_builder;\n     CFG {\n+        owner_def_id,\n         graph,\n         entry,\n         exit: fn_exit,\n@@ -79,10 +79,10 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n         if blk.targeted_by_break {\n-            let expr_exit = self.add_ast_node(blk.id, &[]);\n+            let expr_exit = self.add_ast_node(blk.hir_id.local_id, &[]);\n \n             self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: blk.id,\n+                block_expr_id: blk.hir_id.local_id,\n                 break_index: expr_exit,\n             });\n \n@@ -104,21 +104,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-            self.add_ast_node(blk.id, &[expr_exit])\n+            self.add_ast_node(blk.hir_id.local_id, &[expr_exit])\n         }\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n+        let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n         match stmt.node {\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n \n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 let exit = self.expr(&expr, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n         }\n     }\n@@ -140,31 +141,31 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n-            PatKind::Wild => self.add_ast_node(pat.id, &[pred]),\n+            PatKind::Wild => self.add_ast_node(pat.hir_id.local_id, &[pred]),\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n             PatKind::Binding(.., Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n-                self.add_ast_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[subpat_exit])\n             }\n \n             PatKind::TupleStruct(_, ref subpats, _) |\n             PatKind::Tuple(ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Struct(_, ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_ast_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[post_exit])\n             }\n         }\n     }\n@@ -180,7 +181,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match expr.node {\n             hir::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&blk, pred);\n-                self.add_ast_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n             hir::ExprIf(ref cond, ref then, None) => {\n@@ -200,7 +201,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n-                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -221,7 +222,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n                 let else_exit = self.expr(&otherwise, cond_exit);      // 3\n-                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n+                self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             hir::ExprWhile(ref cond, ref body, _) => {\n@@ -245,12 +246,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n \n                 // Create expr_exit without pred (cond_exit)\n-                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);         // 3\n \n                 // The LoopScope needs to be on the loop_scopes stack while evaluating the\n                 // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n@@ -282,9 +283,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n@@ -295,7 +296,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                self.match_(expr.id, &discr, &arms, pred)\n+                self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n             }\n \n             hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n@@ -315,30 +316,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&l, pred);                      // 1\n                 let r_exit = self.expr(&r, l_exit);                    // 2\n-                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n             }\n \n             hir::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_ast_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let (scope_id, break_dest) =\n+                let (target_scope, break_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n-                let b = self.add_ast_node(expr.id, &[v]);\n-                self.add_exiting_edge(expr, b, scope_id, break_dest);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v]);\n+                self.add_exiting_edge(expr, b, target_scope, break_dest);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(destination) => {\n-                let (scope_id, cont_dest) =\n+                let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n-                let a = self.add_ast_node(expr.id, &[pred]);\n-                self.add_exiting_edge(expr, a, scope_id, cont_dest);\n+                let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n+                self.add_exiting_edge(expr, a, target_scope, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n@@ -397,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n                 let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n                 let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n-                self.add_ast_node(expr.id, &[post_inputs])\n+                self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n             }\n \n             hir::ExprClosure(..) |\n@@ -444,10 +445,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_ast_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n     }\n \n-    fn match_(&mut self, id: ast::NodeId, discr: &hir::Expr,\n+    fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n               arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n         // The CFG for match expression is quite complex, so no ASCII\n         // art for it (yet).\n@@ -552,8 +553,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n-        assert!(id != ast::DUMMY_NODE_ID);\n+    fn add_ast_node(&mut self, id: hir::ItemLocalId, preds: &[CFGIndex]) -> CFGIndex {\n         self.add_node(CFGNodeData::AST(id), preds)\n     }\n \n@@ -579,14 +579,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_exiting_edge(&mut self,\n                         from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n-                        scope_id: ast::NodeId,\n+                        target_scope: CodeExtent,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = CodeExtent::Misc(from_expr.id);\n-        let target_scope = CodeExtent::Misc(scope_id);\n+        let mut scope = CodeExtent::Misc(from_expr.hir_id.local_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(scope.node_id());\n+            data.exiting_scopes.push(scope.item_local_id());\n             scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n@@ -607,13 +606,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope_edge(&self,\n                   expr: &hir::Expr,\n                   destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (ast::NodeId, CFGIndex) {\n+                  scope_cf_kind: ScopeCfKind) -> (CodeExtent, CFGIndex) {\n \n         match destination.target_id {\n             hir::ScopeTarget::Block(block_expr_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == block_expr_id {\n-                        return (block_expr_id, match scope_cf_kind {\n+                    if b.block_expr_id == self.tcx.hir.node_to_hir_id(block_expr_id).local_id {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(block_expr_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n@@ -623,8 +623,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n             hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n-                        return (loop_id, match scope_cf_kind {\n+                    if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                        let scope_id = self.tcx.hir.node_to_hir_id(loop_id).local_id;\n+                        return (CodeExtent::Misc(scope_id), match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "9241240caf043b174a72fdd913d6c2bbf91b940d", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -15,40 +15,48 @@\n use graphviz as dot;\n use graphviz::IntoCow;\n \n-use syntax::ast;\n-\n-use hir::map as hir_map;\n use cfg;\n+use hir;\n+use ty::TyCtxt;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a, 'hir: 'a> {\n-    pub hir_map: &'a hir_map::Map<'hir>,\n+pub struct LabelledCFG<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges\n     pub labelled_edges: bool,\n }\n \n-fn replace_newline_with_backslash_l(s: String) -> String {\n-    // Replacing newlines with \\\\l causes each line to be left-aligned,\n-    // improving presentation of (long) pretty-printed expressions.\n-    if s.contains(\"\\n\") {\n-        let mut s = s.replace(\"\\n\", \"\\\\l\");\n-        // Apparently left-alignment applies to the line that precedes\n-        // \\l, not the line that follows; so, add \\l at end of string\n-        // if not already present, ensuring last line gets left-aligned\n-        // as well.\n-        let mut last_two: Vec<_> =\n-            s.chars().rev().take(2).collect();\n-        last_two.reverse();\n-        if last_two != ['\\\\', 'l'] {\n-            s.push_str(\"\\\\l\");\n+impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n+    fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n+        assert!(self.cfg.owner_def_id.is_local());\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.tcx.hir.def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n+            local_id\n+        });\n+        let s = self.tcx.hir.node_to_string(node_id);\n+\n+        // Replacing newlines with \\\\l causes each line to be left-aligned,\n+        // improving presentation of (long) pretty-printed expressions.\n+        if s.contains(\"\\n\") {\n+            let mut s = s.replace(\"\\n\", \"\\\\l\");\n+            // Apparently left-alignment applies to the line that precedes\n+            // \\l, not the line that follows; so, add \\l at end of string\n+            // if not already present, ensuring last line gets left-aligned\n+            // as well.\n+            let mut last_two: Vec<_> =\n+                s.chars().rev().take(2).collect();\n+            last_two.reverse();\n+            if last_two != ['\\\\', 'l'] {\n+                s.push_str(\"\\\\l\");\n+            }\n+            s\n+        } else {\n+            s\n         }\n-        s\n-    } else {\n-        s\n     }\n }\n \n@@ -66,12 +74,10 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id() == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == hir::DUMMY_ITEM_LOCAL_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.hir_map.node_to_string(n.data.id());\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(n.data.id());\n             dot::LabelText::EscStr(s.into_cow())\n         }\n     }\n@@ -82,15 +88,13 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             return dot::LabelText::EscStr(label.into_cow());\n         }\n         let mut put_one = false;\n-        for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n+        for (i, &id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {\n                 label.push_str(\",\\\\l\");\n             } else {\n                 put_one = true;\n             }\n-            let s = self.hir_map.node_to_string(node_id);\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(id);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n                                    &s[..]));"}, {"sha": "b379d3956e944b01b399b508ae025241ac12450b", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -13,40 +13,41 @@\n \n use rustc_data_structures::graph;\n use ty::TyCtxt;\n-use syntax::ast;\n use hir;\n+use hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n+    pub owner_def_id: DefId,\n     pub graph: CFGGraph,\n     pub entry: CFGIndex,\n     pub exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum CFGNodeData {\n-    AST(ast::NodeId),\n+    AST(hir::ItemLocalId),\n     Entry,\n     Exit,\n     Dummy,\n     Unreachable,\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> ast::NodeId {\n+    pub fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n-            ast::DUMMY_NODE_ID\n+            hir::DUMMY_ITEM_LOCAL_ID\n         }\n     }\n }\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<ast::NodeId>\n+    pub exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n pub type CFGIndex = graph::NodeIndex;\n@@ -63,7 +64,7 @@ impl CFG {\n         construct::construct(tcx, body)\n     }\n \n-    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n         self.graph.depth_traverse(self.entry, graph::OUTGOING)\n                   .any(|idx| self.graph.node_data(idx).id() == id)\n     }"}, {"sha": "e54df2d50d8ebde88366df3f70c8fbb2f6b50eab", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n \n use hir::*;\n use hir::print::Nested;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -251,6 +251,9 @@ pub struct Map<'hir> {\n \n     /// Bodies inlined from other crates are cached here.\n     inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n+\n+    /// The reverse mapping of `node_to_hir_id`.\n+    hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n impl<'hir> Map<'hir> {\n@@ -339,6 +342,11 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n+        self.hir_to_node_id[&hir_id]\n+    }\n+\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n         self.definitions.node_to_hir_id(node_id)\n@@ -1021,10 +1029,15 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n+    // Build the reverse mapping of `node_to_hir_id`.\n+    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n+        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n+\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),\n         map,\n+        hir_to_node_id,\n         definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n     };"}, {"sha": "90d781c6e36649e15357bf3faf14a802da7b165a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -64,7 +64,7 @@ use std::fmt;\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n-use middle::region;\n+use middle::region::{self, RegionMaps};\n use traits::{ObligationCause, ObligationCauseCode};\n use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n@@ -83,6 +83,7 @@ mod anon_anon_conflict;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n+                                   region_maps: &RegionMaps,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region<'tcx>,\n@@ -130,14 +131,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"{}unknown scope: {:?}{}.  Please report a bug.\",\n                             prefix, scope, suffix)\n                 };\n-                let span = match scope.span(&self.hir) {\n-                    Some(s) => s,\n-                    None => {\n-                        err.note(&unknown_scope());\n-                        return;\n-                    }\n-                };\n-                let tag = match self.hir.find(scope.node_id()) {\n+                let span = scope.span(self, region_maps);\n+                let tag = match self.hir.find(scope.node_id(self, region_maps)) {\n                     Some(hir_map::NodeBlock(_)) => \"block\",\n                     Some(hir_map::NodeExpr(expr)) => match expr.node {\n                         hir::ExprCall(..) => \"call\",\n@@ -260,8 +255,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-\n-    pub fn report_region_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>) {\n+    pub fn report_region_errors(&self,\n+                                region_maps: &RegionMaps,\n+                                errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -285,16 +281,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                   // the error. If all of these fails, we fall back to a rather\n                   // general bit of code that displays the error information\n                   ConcreteFailure(origin, sub, sup) => {\n-\n-                      self.report_concrete_failure(origin, sub, sup).emit();\n+                      self.report_concrete_failure(region_maps, origin, sub, sup).emit();\n                   }\n \n                   GenericBoundFailure(kind, param_ty, sub) => {\n-                      self.report_generic_bound_failure(kind, param_ty, sub);\n+                      self.report_generic_bound_failure(region_maps, kind, param_ty, sub);\n                   }\n \n                   SubSupConflict(var_origin, sub_origin, sub_r, sup_origin, sup_r) => {\n-                        self.report_sub_sup_conflict(var_origin,\n+                        self.report_sub_sup_conflict(region_maps,\n+                                                     var_origin,\n                                                      sub_origin,\n                                                      sub_r,\n                                                      sup_origin,\n@@ -773,6 +769,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_generic_bound_failure(&self,\n+                                    region_maps: &RegionMaps,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n                                     sub: Region<'tcx>)\n@@ -840,6 +837,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.help(&format!(\"consider adding an explicit lifetime bound for `{}`\",\n                                   bound_kind));\n                 self.tcx.note_and_explain_region(\n+                    region_maps,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n@@ -853,21 +851,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_sub_sup_conflict(&self,\n+                               region_maps: &RegionMaps,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n                                sub_region: Region<'tcx>,\n                                sup_origin: SubregionOrigin<'tcx>,\n                                sup_region: Region<'tcx>) {\n         let mut err = self.report_inference_failure(var_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"first, the lifetime cannot outlive \",\n             sup_region,\n             \"...\");\n \n         self.note_region_origin(&mut err, &sup_origin);\n \n-        self.tcx.note_and_explain_region(&mut err,\n+        self.tcx.note_and_explain_region(region_maps, &mut err,\n             \"but, the lifetime must be valid for \",\n             sub_region,\n             \"...\");"}, {"sha": "3e78cce80f594ad24657f502a58b773f17378fe8", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use infer::{self, InferCtxt, SubregionOrigin};\n+use middle::region::RegionMaps;\n use ty::{self, Region};\n use ty::error::TypeError;\n use errors::DiagnosticBuilder;\n@@ -144,26 +145,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub(super) fn report_concrete_failure(&self,\n+                                          region_maps: &RegionMaps,\n                                           origin: SubregionOrigin<'tcx>,\n                                           sub: Region<'tcx>,\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr)\n+                let mut err = self.report_and_explain_type_error(trace, &terr);\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"\", sup, \"...\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"...does not necessarily outlive \", sub, \"\");\n+                err\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0312,\n                                                \"lifetime of reference outlives lifetime of \\\n                                                 borrowed content...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the reference is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the borrowed content is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -177,27 +183,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 of captured variable `{}`...\",\n                                                self.tcx\n                                                    .local_var_name_str_def_index(upvar_id.var_id));\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx\n-                    .note_and_explain_region(\n-                      &mut err,\n-                      &format!(\"...but `{}` is only valid for \",\n-                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n-                      sup,\n-                      \"\");\n+                self.tcx.note_and_explain_region(\n+                    region_maps,\n+                    &mut err,\n+                    &format!(\"...but `{}` is only valid for \",\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                    sup,\n+                    \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0314, \"closure outlives stack frame\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...the closure must be valid for \",\n                                                  sub,\n                                                  \"...\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"...but the closure's stack frame is only valid \\\n                                                   for \",\n                                                  sup,\n@@ -209,17 +215,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                span,\n                                                E0315,\n                                                \"cannot invoke closure outside of its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the closure is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the closure is only valid for \", sup, \"\");\n                 err\n             }\n             infer::DerefPointer(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0473,\n                                                \"dereference of reference outside its lifetime\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the reference is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n             infer::FreeVariable(span, id) => {\n@@ -229,17 +235,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"captured variable `{}` does not outlive the \\\n                                                 enclosing closure\",\n                                                self.tcx.local_var_name_str(id));\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"captured variable is valid for \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"closure is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"captured variable is valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"closure is valid for \", sub, \"\");\n                 err\n             }\n             infer::IndexSlice(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0475,\n                                                \"index of slice outside its lifetime\");\n-                self.tcx.note_and_explain_region(&mut err, \"the slice is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the slice is only valid for \", sup, \"\");\n                 err\n             }\n             infer::RelateObjectBound(span) => {\n@@ -248,8 +256,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0476,\n                                                \"lifetime of the source pointer does not outlive \\\n                                                 lifetime bound of the object type\");\n-                self.tcx.note_and_explain_region(&mut err, \"object type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"object type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"source pointer is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -264,22 +273,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                self.ty_to_string(ty));\n                 match *sub {\n                     ty::ReStatic => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must satisfy \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must satisfy \", sub, \"\")\n                     }\n                     _ => {\n-                        self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\")\n+                        self.tcx.note_and_explain_region(region_maps, &mut err,\n+                            \"type must outlive \", sub, \"\")\n                     }\n                 }\n                 err\n             }\n             infer::RelateRegionParamBound(span) => {\n                 let mut err =\n                     struct_span_err!(self.tcx.sess, span, E0478, \"lifetime bound not satisfied\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"lifetime parameter instantiated with \",\n                                                  sup,\n                                                  \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but lifetime parameter must outlive \",\n                                                  sub,\n                                                  \"\");\n@@ -292,7 +303,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"the type `{}` (provided as the value of a type \\\n                                                 parameter) is not valid at this point\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"type must outlive \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type must outlive \", sub, \"\");\n                 err\n             }\n             infer::CallRcvr(span) => {\n@@ -301,8 +313,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0480,\n                                                \"lifetime of method receiver does not outlive the \\\n                                                 method call\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the receiver is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                \"the receiver is only valid for \", sup, \"\");\n                 err\n             }\n             infer::CallArg(span) => {\n@@ -311,7 +323,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0481,\n                                                \"lifetime of function argument does not outlive \\\n                                                 the function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the function argument is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -323,7 +335,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0482,\n                                                \"lifetime of return value does not outlive the \\\n                                                 function call\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the return value is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -335,17 +347,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0483,\n                                                \"lifetime of operand does not outlive the \\\n                                                 operation\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the operand is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the operand is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AddrOf(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0484,\n                                                \"reference is not valid at the time of borrow\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the borrow is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the borrow is only valid for \", sup, \"\");\n                 err\n             }\n             infer::AutoBorrow(span) => {\n@@ -354,7 +366,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0485,\n                                                \"automatically reference is not valid at the time \\\n                                                 of borrow\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"the automatic borrow is only valid for \",\n                                                  sup,\n                                                  \"\");\n@@ -367,7 +379,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"type of expression contains references that are \\\n                                                 not valid during the expression: `{}`\",\n                                                self.ty_to_string(t));\n-                self.tcx.note_and_explain_region(&mut err, \"type is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"type is only valid for \", sup, \"\");\n                 err\n             }\n             infer::SafeDestructor(span) => {\n@@ -377,8 +390,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"unsafe use of destructor: destructor might be \\\n                                                 called while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n-                self.tcx.note_and_explain_region(&mut err, \"superregion: \", sup, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"subregion: \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"superregion: \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err, \"subregion: \", sub, \"\");\n                 err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n@@ -387,17 +400,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0488,\n                                                \"lifetime of variable does not enclose its \\\n                                                 declaration\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the variable is only valid for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the variable is only valid for \", sup, \"\");\n                 err\n             }\n             infer::ParameterInScope(_, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0489,\n                                                \"type/lifetime parameter not in scope here\");\n-                self.tcx\n-                    .note_and_explain_region(&mut err, \"the parameter is only valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the parameter is only valid for \", sub, \"\");\n                 err\n             }\n             infer::DataBorrowed(ty, span) => {\n@@ -406,8 +419,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0490,\n                                                \"a value of type `{}` is borrowed for too long\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the type is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"but the borrow lasts for \", sup, \"\");\n                 err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n@@ -417,8 +432,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                \"in type `{}`, reference has a longer lifetime \\\n                                                 than the data it references\",\n                                                self.ty_to_string(ty));\n-                self.tcx.note_and_explain_region(&mut err, \"the pointer is valid for \", sub, \"\");\n-                self.tcx.note_and_explain_region(&mut err,\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n+                    \"the pointer is valid for \", sub, \"\");\n+                self.tcx.note_and_explain_region(region_maps, &mut err,\n                                                  \"but the referenced data is only valid for \",\n                                                  sup,\n                                                  \"\");"}, {"sha": "21af92a25e6845249be4e56f9f732dba18fc7063", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -1084,7 +1084,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(&errors); // see error_reporting module\n+            self.report_region_errors(region_map, &errors); // see error_reporting module\n         }\n     }\n "}, {"sha": "e88678dea1d747d485c0c72af523c2ee58be2f3e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -20,12 +20,11 @@ use ty::TyCtxt;\n use std::io;\n use std::mem;\n use std::usize;\n-use syntax::ast;\n use syntax::print::pprust::PrintState;\n \n use rustc_data_structures::graph::OUTGOING;\n \n-use util::nodemap::NodeMap;\n+use util::nodemap::FxHashMap;\n use hir;\n use hir::intravisit::{self, IdRange};\n use hir::print as pprust;\n@@ -56,7 +55,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n+    local_id_to_index: FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -97,15 +96,16 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n-    let opt_indices = index.get(&id);\n-    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n+fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n+                       index: &'a FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n+                       -> &'a [CFGIndex] {\n+    index.get(&id).map_or(&[], |v| &v[..])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n-        assert!(n != ast::DUMMY_NODE_ID);\n-        self.nodeid_to_index.contains_key(&n)\n+    fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n+        assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n+        self.local_id_to_index.contains_key(&n)\n     }\n }\n \n@@ -117,19 +117,20 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n-            pprust::NodeExpr(expr) => expr.id,\n-            pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n-            pprust::NodePat(pat) => pat.id\n+            pprust::NodeName(_) => return Ok(()),\n+            pprust::NodeExpr(expr) => expr.hir_id.local_id,\n+            pprust::NodeBlock(blk) => blk.hir_id.local_id,\n+            pprust::NodeItem(_) |\n+            pprust::NodeSubItem(_) => return Ok(()),\n+            pprust::NodePat(pat) => pat.hir_id.local_id\n         };\n \n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return Ok(());\n         }\n \n         assert!(self.bits_per_id > 0);\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n@@ -157,17 +158,18 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             };\n \n             ps.synth_comment(\n-                format!(\"id {}: {}{}{}{}\", id, entry_str,\n+                format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n                         gens_str, action_kills_str, scope_kills_str))?;\n             ps.s.space()?;\n         }\n         Ok(())\n     }\n }\n \n-fn build_nodeid_to_index(body: Option<&hir::Body>,\n-                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n-    let mut index = NodeMap();\n+fn build_local_id_to_index(body: Option<&hir::Body>,\n+                           cfg: &cfg::CFG)\n+                           -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n+    let mut index = FxHashMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n@@ -188,14 +190,14 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n \n     /// Add mappings from the ast nodes for the formal bindings to\n     /// the entry-node in the graph.\n-    fn add_entries_from_fn_body(index: &mut NodeMap<Vec<CFGIndex>>,\n+    fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n                                 body: &hir::Body,\n                                 entry: CFGIndex) {\n         use hir::intravisit::Visitor;\n \n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<Vec<CFGIndex>>,\n+            index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         for arg in &body.arguments {\n@@ -207,7 +209,7 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n             }\n \n             fn visit_pat(&mut self, p: &hir::Pat) {\n-                self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n+                self.index.entry(p.hir_id.local_id).or_insert(vec![]).push(self.entry);\n                 intravisit::walk_pat(self, p)\n             }\n         }\n@@ -259,13 +261,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills2 = zeroes;\n         let on_entry = vec![entry; num_nodes * words_per_id];\n \n-        let nodeid_to_index = build_nodeid_to_index(body, cfg);\n+        let local_id_to_index = build_local_id_to_index(body, cfg);\n \n         DataFlowContext {\n             tcx,\n             analysis_name,\n             words_per_id,\n-            nodeid_to_index,\n+            local_id_to_index,\n             bits_per_id,\n             oper,\n             gens,\n@@ -275,29 +277,29 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::NodeId, bit: usize) {\n+    pub fn add_gen(&mut self, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{} add_gen(id={}, bit={})\",\n+        debug!(\"{} add_gen(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &mut self.gens[start.. end];\n             set_bit(gens, bit);\n         }\n     }\n \n-    pub fn add_kill(&mut self, kind: KillFrom, id: ast::NodeId, bit: usize) {\n+    pub fn add_kill(&mut self, kind: KillFrom, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{} add_kill(id={}, bit={})\",\n+        debug!(\"{} add_kill(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let kills = match kind {\n@@ -341,15 +343,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             if !self.each_bit_for_node(EntryOrExit::Entry, cfgidx, |i| f(i)) {\n                 return false;\n@@ -387,11 +389,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n \n@@ -401,11 +403,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &self.gens[start.. end];\n-            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+            debug!(\"{} each_gen_bit(id={:?}, gens={})\",\n                    self.analysis_name, id, bits_to_string(gens));\n             if !self.each_bit(gens, |i| f(i)) {\n                 return false;\n@@ -472,26 +474,26 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             let mut orig_kills = self.scope_kills[start.. end].to_vec();\n \n             let mut changed = false;\n-            for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n+            for &id in &edge.data.exiting_scopes {\n+                let opt_cfg_idx = self.local_id_to_index.get(&id);\n                 match opt_cfg_idx {\n                     Some(indices) => {\n                         for &cfg_idx in indices {\n                             let (start, end) = self.compute_id_range(cfg_idx);\n                             let kills = &self.scope_kills[start.. end];\n                             if bitwise(&mut orig_kills, kills, &Union) {\n-                                debug!(\"scope exits: scope id={} \\\n+                                debug!(\"scope exits: scope id={:?} \\\n                                         (node={:?} of {:?}) added killset: {}\",\n-                                       node_id, cfg_idx, indices,\n+                                       id, cfg_idx, indices,\n                                        bits_to_string(kills));\n                                 changed = true;\n                             }\n                         }\n                     }\n                     None => {\n                         debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n-                                no cfg_idx for exiting_scope={}\",\n-                               self.analysis_name, flow_exit, node_id);\n+                                no cfg_idx for exiting_scope={:?}\",\n+                               self.analysis_name, flow_exit, id);\n                     }\n                 }\n             }\n@@ -559,7 +561,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         // Iterate over nodes in reverse postorder\n         for &node_index in nodes_po.iter().rev() {\n             let node = cfg.graph.node(node_index);\n-            debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n+            debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n                    node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);"}, {"sha": "1589ba60275904dc5ea7d0e398cf0b43e4c4983a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -23,7 +23,7 @@ use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n-use middle::region::RegionMaps;\n+use middle::region::{CodeExtent, RegionMaps};\n use ty::{self, TyCtxt, adjustment};\n \n use hir::{self, PatKind};\n@@ -298,7 +298,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         for arg in &body.arguments {\n             let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n-            let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n+            let fn_body_scope_r =\n+                self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(body.value.hir_id.local_id)));\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n@@ -542,16 +543,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n+                let call_scope = CodeExtent::Misc(call.hir_id.local_id);\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n-                        let call_scope_r = self.tcx().node_scope_region(call.id);\n+                        let call_scope_r = self.tcx().mk_region(ty::ReScope(call_scope));\n                         self.borrow_expr(callee,\n                                          call_scope_r,\n                                          ty::ImmBorrow,\n@@ -749,7 +751,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = self.tcx().node_scope_region(expr.id);\n+                let r = self.tcx().mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,"}, {"sha": "fdab71ee004419b8836ef3d44e995a302a2f2cd1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -861,8 +861,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n-    {\n+    pub fn temporary_scope(&self, id: hir::ItemLocalId) -> ty::Region<'tcx> {\n         let scope = self.region_maps.temporary_scope(id);\n         self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n@@ -890,7 +889,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if promotable {\n             self.tcx.types.re_static\n         } else {\n-            self.temporary_scope(id)\n+            self.temporary_scope(self.tcx.hir.node_to_hir_id(id).local_id)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);"}, {"sha": "f58d1a0b41fec859e249e3f0257c0e218f3b61bf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 159, "deletions": 215, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -16,24 +16,22 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n-use hir::map as hir_map;\n-use util::nodemap::{FxHashMap, NodeMap, NodeSet};\n+use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n+use std::collections::hash_map::Entry;\n use std::mem;\n use std::rc::Rc;\n use syntax::codemap;\n use syntax::ast;\n-use syntax::ast::NodeId;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use ty::TyCtxt;\n use ty::maps::Providers;\n \n use hir;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use hir::map::Node;\n use mir::transform::MirSource;\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -99,18 +97,18 @@ use mir::transform::MirSource;\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId),\n+    Misc(hir::ItemLocalId),\n \n     // extent of the call-site for a function or closure (outlives\n     // the parameters as well as the body).\n-    CallSiteScope(hir::BodyId),\n+    CallSiteScope(hir::ItemLocalId),\n \n     // extent of parameters passed to a function or closure (they\n     // outlive its body)\n-    ParameterScope(hir::BodyId),\n+    ParameterScope(hir::ItemLocalId),\n \n     // extent of destructors for temporaries of node-id\n-    DestructionScope(ast::NodeId),\n+    DestructionScope(hir::ItemLocalId),\n \n     // extent of code following a `let id = expr;` binding in a block\n     Remainder(BlockRemainder)\n@@ -136,66 +134,77 @@ pub enum CodeExtent {\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n-    pub block: ast::NodeId,\n+    pub block: hir::ItemLocalId,\n     pub first_statement_index: u32,\n }\n \n impl CodeExtent {\n-    /// Returns a node id associated with this scope.\n+    /// Returns a item-local id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n-    pub fn node_id(&self) -> ast::NodeId {\n+    pub fn item_local_id(&self) -> hir::ItemLocalId {\n         match *self {\n-            CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Misc(id) => id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n             CodeExtent::Remainder(br) => br.block,\n-            CodeExtent::DestructionScope(node_id) => node_id,\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => body_id.node_id,\n+            CodeExtent::DestructionScope(id) |\n+            CodeExtent::CallSiteScope(id) |\n+            CodeExtent::ParameterScope(id) => id,\n+        }\n+    }\n+\n+    pub fn node_id(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> ast::NodeId {\n+        match region_maps.root_body {\n+            Some(hir_id) => {\n+                tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: hir_id.owner,\n+                    local_id: self.item_local_id()\n+                })\n+            }\n+            None => ast::DUMMY_NODE_ID\n         }\n     }\n \n     /// Returns the span of this CodeExtent.  Note that in general the\n     /// returned span may not correspond to the span of any node id in\n     /// the AST.\n-    pub fn span(&self, hir_map: &hir_map::Map) -> Option<Span> {\n-        match hir_map.find(self.node_id()) {\n-            Some(hir_map::NodeBlock(ref blk)) => {\n-                match *self {\n-                    CodeExtent::CallSiteScope(_) |\n-                    CodeExtent::ParameterScope(_) |\n-                    CodeExtent::Misc(_) |\n-                    CodeExtent::DestructionScope(_) => Some(blk.span),\n-\n-                    CodeExtent::Remainder(r) => {\n-                        assert_eq!(r.block, blk.id);\n-                        // Want span for extent starting after the\n-                        // indexed statement and ending at end of\n-                        // `blk`; reuse span of `blk` and shift `lo`\n-                        // forward to end of indexed statement.\n-                        //\n-                        // (This is the special case aluded to in the\n-                        // doc-comment for this method)\n-                        let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span::new(stmt_span.hi(), blk.span.hi(), stmt_span.ctxt()))\n-                    }\n+    pub fn span(&self, tcx: TyCtxt, region_maps: &RegionMaps) -> Span {\n+        let node_id = self.node_id(tcx, region_maps);\n+        if node_id == ast::DUMMY_NODE_ID {\n+            return DUMMY_SP;\n+        }\n+        let span = tcx.hir.span(node_id);\n+        if let CodeExtent::Remainder(r) = *self {\n+            if let hir::map::NodeBlock(ref blk) = tcx.hir.get(node_id) {\n+                // Want span for extent starting after the\n+                // indexed statement and ending at end of\n+                // `blk`; reuse span of `blk` and shift `lo`\n+                // forward to end of indexed statement.\n+                //\n+                // (This is the special case aluded to in the\n+                // doc-comment for this method)\n+\n+                let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n+\n+                // To avoid issues with macro-generated spans, the span\n+                // of the statement must be nested in that of the block.\n+                if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n+                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n                 }\n             }\n-            Some(hir_map::NodeExpr(ref expr)) => Some(expr.span),\n-            Some(hir_map::NodeStmt(ref stmt)) => Some(stmt.span),\n-            Some(hir_map::NodeItem(ref item)) => Some(item.span),\n-            Some(_) | None => None,\n          }\n+         span\n     }\n }\n \n /// The region maps encode information about region relationships.\n+#[derive(Default)]\n pub struct RegionMaps {\n     /// If not empty, this body is the root of this region hierarchy.\n-    root_body: Option<hir::BodyId>,\n+    root_body: Option<hir::HirId>,\n \n     /// The parent of the root body owner, if the latter is an\n     /// an associated const or method, as impls/traits can also\n@@ -212,10 +221,10 @@ pub struct RegionMaps {\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent>,\n+    var_map: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: NodeMap<CodeExtent>,\n+    destruction_scopes: FxHashMap<hir::ItemLocalId, CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n@@ -225,7 +234,7 @@ pub struct RegionMaps {\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n     /// escape into 'static and should have no local cleanup scope.\n-    rvalue_scopes: NodeMap<Option<CodeExtent>>,\n+    rvalue_scopes: FxHashMap<hir::ItemLocalId, Option<CodeExtent>>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -237,7 +246,11 @@ pub struct RegionMaps {\n     /// closure defined by that fn. See the \"Modeling closures\"\n     /// section of the README in infer::region_inference for\n     /// more details.\n-    fn_tree: NodeMap<ast::NodeId>,\n+    closure_tree: FxHashMap<hir::ItemLocalId, hir::ItemLocalId>,\n+\n+    /// If there are any `yield` nested within a scope, this map\n+    /// stores the `Span` of the first one.\n+    yield_in_scope: FxHashMap<CodeExtent, Span>,\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -248,7 +261,7 @@ pub struct Context {\n     /// arranged into a tree. See the \"Modeling closures\" section of\n     /// the README in infer::region_inference for more\n     /// details.\n-    root_id: Option<ast::NodeId>,\n+    root_id: Option<hir::ItemLocalId>,\n \n     /// the scope that contains any new variables declared\n     var_parent: Option<CodeExtent>,\n@@ -285,23 +298,11 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// arbitrary amounts of stack space. Terminating scopes end\n     /// up being contained in a DestructionScope that contains the\n     /// destructor's execution.\n-    terminating_scopes: NodeSet,\n+    terminating_scopes: FxHashSet<hir::ItemLocalId>,\n }\n \n \n impl<'tcx> RegionMaps {\n-    pub fn new() -> Self {\n-        RegionMaps {\n-            root_body: None,\n-            root_parent: None,\n-            scope_map: FxHashMap(),\n-            destruction_scopes: FxHashMap(),\n-            var_map: NodeMap(),\n-            rvalue_scopes: NodeMap(),\n-            fn_tree: NodeMap(),\n-        }\n-    }\n-\n     pub fn record_code_extent(&mut self,\n                               child: CodeExtent,\n                               parent: Option<CodeExtent>) {\n@@ -324,46 +325,51 @@ impl<'tcx> RegionMaps {\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent) {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&hir::ItemLocalId, CodeExtent) {\n         for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn opt_destruction_extent(&self, n: hir::ItemLocalId) -> Option<CodeExtent> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_fn` is defined within `sup_fn`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n-    fn record_fn_parent(&mut self, sub_fn: ast::NodeId, sup_fn: ast::NodeId) {\n-        debug!(\"record_fn_parent(sub_fn={:?}, sup_fn={:?})\", sub_fn, sup_fn);\n-        assert!(sub_fn != sup_fn);\n-        let previous = self.fn_tree.insert(sub_fn, sup_fn);\n+    fn record_closure_parent(&mut self,\n+                             sub_closure: hir::ItemLocalId,\n+                             sup_closure: hir::ItemLocalId) {\n+        debug!(\"record_closure_parent(sub_closure={:?}, sup_closure={:?})\",\n+               sub_closure, sup_closure);\n+        assert!(sub_closure != sup_closure);\n+        let previous = self.closure_tree.insert(sub_closure, sup_closure);\n         assert!(previous.is_none());\n     }\n \n-    fn fn_is_enclosed_by(&self, mut sub_fn: ast::NodeId, sup_fn: ast::NodeId) -> bool {\n+    fn closure_is_enclosed_by(&self,\n+                              mut sub_closure: hir::ItemLocalId,\n+                              sup_closure: hir::ItemLocalId) -> bool {\n         loop {\n-            if sub_fn == sup_fn { return true; }\n-            match self.fn_tree.get(&sub_fn) {\n-                Some(&s) => { sub_fn = s; }\n+            if sub_closure == sup_closure { return true; }\n+            match self.closure_tree.get(&sub_closure) {\n+                Some(&s) => { sub_closure = s; }\n                 None => { return false; }\n             }\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n+    fn record_var_scope(&mut self, var: hir::ItemLocalId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n-        assert!(var != lifetime.node_id());\n+        assert!(var != lifetime.item_local_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: Option<CodeExtent>) {\n+    fn record_rvalue_scope(&mut self, var: hir::ItemLocalId, lifetime: Option<CodeExtent>) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         if let Some(lifetime) = lifetime {\n-            assert!(var != lifetime.node_id());\n+            assert!(var != lifetime.item_local_id());\n         }\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n@@ -380,14 +386,14 @@ impl<'tcx> RegionMaps {\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n+    pub fn var_scope(&self, var_id: hir::ItemLocalId) -> CodeExtent {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n+    pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -417,7 +423,7 @@ impl<'tcx> RegionMaps {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind {\n+    pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -497,10 +503,10 @@ impl<'tcx> RegionMaps {\n             return match (a_root_scope, b_root_scope) {\n                 (CodeExtent::DestructionScope(a_root_id),\n                  CodeExtent::DestructionScope(b_root_id)) => {\n-                    if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n+                    if self.closure_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n-                    } else if self.fn_is_enclosed_by(b_root_id, a_root_id) {\n+                    } else if self.closure_is_enclosed_by(b_root_id, a_root_id) {\n                         // `b` is enclosed by `a`, hence `a` is the ancestor of everything in `b`\n                         scope_a\n                     } else {\n@@ -565,20 +571,23 @@ impl<'tcx> RegionMaps {\n         let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id).unwrap_or_else(|| {\n+        let scope = tcx.hir.maybe_body_owned_by(param_owner_id).map(|body_id| {\n+            tcx.hir.body(body_id).value.hir_id.local_id\n+        }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n             // which in practice can only mean a trait or an impl, that\n             // is the parent of a method, and that is enforced below.\n             assert_eq!(Some(param_owner_id), self.root_parent,\n-                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n+                       \"free_extent: {:?} not recognized by the region maps for {:?} / {:?}\",\n                        param_owner,\n-                       self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n+                       self.root_parent.map(|id| tcx.hir.local_def_id(id)),\n+                       self.root_body.map(|hir_id| DefId::local(hir_id.owner)));\n \n             // The trait/impl lifetime is in scope for the method's body.\n-            self.root_body.unwrap()\n+            self.root_body.unwrap().local_id\n         });\n \n-        CodeExtent::CallSiteScope(body_id)\n+        CodeExtent::CallSiteScope(scope)\n     }\n \n     /// Assuming that the provided region was defined within this `RegionMaps`,\n@@ -597,13 +606,20 @@ impl<'tcx> RegionMaps {\n         assert_eq!(param_owner, fr.scope);\n \n         let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n-        CodeExtent::CallSiteScope(tcx.hir.body_owned_by(param_owner_id))\n+        let body_id = tcx.hir.body_owned_by(param_owner_id);\n+        CodeExtent::CallSiteScope(tcx.hir.body(body_id).value.hir_id.local_id)\n+    }\n+\n+    /// Checks whether the given code extent contains a `yield`. If so,\n+    /// returns `Some(span)` with the span of a yield we found.\n+    pub fn yield_in_scope(&self, scope: CodeExtent) -> Option<Span> {\n+        self.yield_in_scope.get(&scope).cloned()\n     }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n-                       var_id: ast::NodeId,\n+                       var_id: hir::ItemLocalId,\n                        _sp: Span) {\n     match visitor.cx.var_parent {\n         None => {\n@@ -646,7 +662,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.enter_node_extent_with_dtor(blk.id);\n+    visitor.enter_node_extent_with_dtor(blk.hir_id.local_id);\n     visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n@@ -665,7 +681,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // block itself as a parent.\n                 visitor.enter_code_extent(\n                     CodeExtent::Remainder(BlockRemainder {\n-                        block: blk.id,\n+                        block: blk.hir_id.local_id,\n                         first_statement_index: i as u32\n                     })\n                 );\n@@ -680,28 +696,28 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n }\n \n fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &'tcx hir::Arm) {\n-    visitor.terminating_scopes.insert(arm.body.id);\n+    visitor.terminating_scopes.insert(arm.body.hir_id.local_id);\n \n     if let Some(ref expr) = arm.guard {\n-        visitor.terminating_scopes.insert(expr.id);\n+        visitor.terminating_scopes.insert(expr.hir_id.local_id);\n     }\n \n     intravisit::walk_arm(visitor, arm);\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.record_code_extent(CodeExtent::Misc(pat.id));\n+    visitor.record_code_extent(CodeExtent::Misc(pat.hir_id.local_id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n-        record_var_lifetime(visitor, pat.id, pat.span);\n+        record_var_lifetime(visitor, pat.hir_id.local_id, pat.span);\n     }\n \n     intravisit::walk_pat(visitor, pat);\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = stmt.node.id();\n+    let stmt_id = visitor.tcx.hir.node_to_hir_id(stmt.node.id()).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during\n@@ -723,11 +739,11 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let prev_cx = visitor.cx;\n-    visitor.enter_node_extent_with_dtor(expr.id);\n+    visitor.enter_node_extent_with_dtor(expr.hir_id.local_id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n-        let mut terminating = |id: ast::NodeId| {\n+        let mut terminating = |id: hir::ItemLocalId| {\n             terminating_scopes.insert(id);\n         };\n         match expr.node {\n@@ -739,27 +755,27 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             hir::ExprBinary(codemap::Spanned { node: hir::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r.id);\n+                terminating(r.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, Some(ref otherwise)) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n-                terminating(otherwise.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n+                terminating(otherwise.hir_id.local_id);\n             }\n \n             hir::ExprIf(ref expr, ref then, None) => {\n-                terminating(expr.id);\n-                terminating(then.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(then.hir_id.local_id);\n             }\n \n             hir::ExprLoop(ref body, _, _) => {\n-                terminating(body.id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprWhile(ref expr, ref body, _) => {\n-                terminating(expr.id);\n-                terminating(body.id);\n+                terminating(expr.hir_id.local_id);\n+                terminating(body.hir_id.local_id);\n             }\n \n             hir::ExprMatch(..) => {\n@@ -788,6 +804,29 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n                 // record_superlifetime(new_cx, expr.callee_id);\n             }\n \n+            hir::ExprYield(..) => {\n+                // Mark this expr's scope and all parent scopes as containing `yield`.\n+                let mut scope = CodeExtent::Misc(expr.hir_id.local_id);\n+                loop {\n+                    match visitor.region_maps.yield_in_scope.entry(scope) {\n+                        // Another `yield` has already been found.\n+                        Entry::Occupied(_) => break,\n+\n+                        Entry::Vacant(entry) => {\n+                            entry.insert(expr.span);\n+                        }\n+                    }\n+\n+                    // Keep traversing up while we can.\n+                    match visitor.region_maps.scope_map.get(&scope) {\n+                        // Don't cross from closure bodies to their parent.\n+                        Some(&CodeExtent::CallSiteScope(_)) => break,\n+                        Some(&superscope) => scope = superscope,\n+                        None => break\n+                    }\n+                }\n+            }\n+\n             _ => {}\n         }\n     }\n@@ -1018,7 +1057,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             // because in trans if we must compile e.g. `*rvalue()`\n             // into a temporary, we request the temporary scope of the\n             // outer expression.\n-            visitor.region_maps.record_rvalue_scope(expr.id, blk_scope);\n+            visitor.region_maps.record_rvalue_scope(expr.hir_id.local_id, blk_scope);\n \n             match expr.node {\n                 hir::ExprAddrOf(_, ref subexpr) |\n@@ -1050,7 +1089,7 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n         self.cx.parent = Some(child_scope);\n     }\n \n-    fn enter_node_extent_with_dtor(&mut self, id: ast::NodeId) {\n+    fn enter_node_extent_with_dtor(&mut self, id: hir::ItemLocalId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n@@ -1082,16 +1121,16 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n                self.cx.parent);\n \n         let outer_cx = self.cx;\n-        let outer_ts = mem::replace(&mut self.terminating_scopes, NodeSet());\n-        self.terminating_scopes.insert(body_id.node_id);\n+        let outer_ts = mem::replace(&mut self.terminating_scopes, FxHashSet());\n+        self.terminating_scopes.insert(body.value.hir_id.local_id);\n \n         if let Some(root_id) = self.cx.root_id {\n-            self.region_maps.record_fn_parent(body_id.node_id, root_id);\n+            self.region_maps.record_closure_parent(body.value.hir_id.local_id, root_id);\n         }\n-        self.cx.root_id = Some(body_id.node_id);\n+        self.cx.root_id = Some(body.value.hir_id.local_id);\n \n-        self.enter_code_extent(CodeExtent::CallSiteScope(body_id));\n-        self.enter_code_extent(CodeExtent::ParameterScope(body_id));\n+        self.enter_code_extent(CodeExtent::CallSiteScope(body.value.hir_id.local_id));\n+        self.enter_code_extent(CodeExtent::ParameterScope(body.value.hir_id.local_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1157,19 +1196,20 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     }\n \n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let maps = if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n+    let maps = if let Some(body_id) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n-            region_maps: RegionMaps::new(),\n+            region_maps: RegionMaps::default(),\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n                 var_parent: None,\n             },\n-            terminating_scopes: NodeSet(),\n+            terminating_scopes: FxHashSet(),\n         };\n \n-        visitor.region_maps.root_body = Some(body);\n+        let body = tcx.hir.body(body_id);\n+        visitor.region_maps.root_body = Some(body.value.hir_id);\n \n         // If the item is an associated const or a method,\n         // record its impl/trait parent, as it can also have\n@@ -1182,112 +1222,16 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             _ => {}\n         }\n \n-        visitor.visit_body(tcx.hir.body(body));\n+        visitor.visit_body(body);\n \n         visitor.region_maps\n     } else {\n-        RegionMaps::new()\n+        RegionMaps::default()\n     };\n \n     Rc::new(maps)\n }\n \n-struct YieldFinder<'a> {\n-    cache: &'a mut FxHashMap<NodeId, Option<Span>>,\n-    result: Option<Span>,\n-}\n-\n-impl<'a> YieldFinder<'a> {\n-    fn lookup<F: FnOnce(&mut Self)>(&mut self, id: NodeId, f: F) {\n-        // Don't traverse further if we found a yield expression\n-        if self.result.is_some() {\n-            return;\n-        }\n-\n-        // See if there's an entry in the cache\n-        if let Some(result) = self.cache.get(&id) {\n-            self.result = *result;\n-            return;\n-        }\n-\n-        // Otherwise calculate the result and insert it into the cache\n-        f(self);\n-        self.cache.insert(id, self.result);\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for YieldFinder<'a> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if let hir::ExprYield(..) = expr.node {\n-            self.result = Some(expr.span);\n-            return;\n-        }\n-\n-        self.lookup(expr.id, |this| {\n-            intravisit::walk_expr(this, expr);\n-        });\n-    }\n-\n-    fn visit_block(&mut self, block: &'tcx hir::Block) {\n-        self.lookup(block.id, |this| {\n-            intravisit::walk_block(this, block);\n-        });\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Checks whether the given code extent contains a `yield`. If so,\n-    /// returns `Some(span)` with the span of a yield we found.\n-    pub fn yield_in_extent(self,\n-                          extent: CodeExtent,\n-                          cache: &mut FxHashMap<NodeId, Option<Span>>) -> Option<Span> {\n-        let mut finder = YieldFinder {\n-            cache,\n-            result: None,\n-        };\n-\n-        match extent {\n-            CodeExtent::DestructionScope(node_id) |\n-            CodeExtent::Misc(node_id) => {\n-                match self.hir.get(node_id) {\n-                    Node::NodeItem(_) |\n-                    Node::NodeTraitItem(_) |\n-                    Node::NodeImplItem(_) => {\n-                        let body = self.hir.body(self.hir.body_owned_by(node_id));\n-                        finder.visit_body(body);\n-                    }\n-                    Node::NodeExpr(expr) => finder.visit_expr(expr),\n-                    Node::NodeStmt(stmt) => finder.visit_stmt(stmt),\n-                    Node::NodeBlock(block) => finder.visit_block(block),\n-                    _ => bug!(),\n-                }\n-            }\n-\n-            CodeExtent::CallSiteScope(body_id) |\n-            CodeExtent::ParameterScope(body_id) => {\n-                finder.visit_body(self.hir.body(body_id))\n-            }\n-\n-            CodeExtent::Remainder(r) => {\n-                if let Node::NodeBlock(block) = self.hir.get(r.block) {\n-                    for stmt in &block.stmts[(r.first_statement_index as usize + 1)..] {\n-                        finder.visit_stmt(stmt);\n-                    }\n-                    block.expr.as_ref().map(|e| finder.visit_expr(e));\n-                } else {\n-                    bug!()\n-                }\n-            }\n-        }\n-\n-        finder.result\n-    }\n-}\n-\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         region_maps,"}, {"sha": "35ca8eb14228379563fed15283de2c720f9d6347", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -532,7 +532,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "49d7f40000f079b7847c5846c3b49f3b9b5521bc", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -36,11 +36,11 @@ pub enum TypeError<'tcx> {\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<usize>),\n     ArgCount,\n+\n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n-    RegionsNotSame(Region<'tcx>, Region<'tcx>),\n-    RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n     RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n     RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n+\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n@@ -110,12 +110,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n-            RegionsNotSame(..) => {\n-                write!(f, \"lifetimes are not the same\")\n-            }\n-            RegionsNoOverlap(..) => {\n-                write!(f, \"lifetimes do not intersect\")\n-            }\n             RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n@@ -243,33 +237,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         use self::TypeError::*;\n \n         match err.clone() {\n-            RegionsDoesNotOutlive(subregion, superregion) => {\n-                self.note_and_explain_region(db, \"\", subregion, \"...\");\n-                self.note_and_explain_region(db, \"...does not necessarily outlive \",\n-                                           superregion, \"\");\n-            }\n-            RegionsNotSame(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...is not the same lifetime as \",\n-                                           region2, \"\");\n-            }\n-            RegionsNoOverlap(region1, region2) => {\n-                self.note_and_explain_region(db, \"\", region1, \"...\");\n-                self.note_and_explain_region(db, \"...does not overlap \",\n-                                           region2, \"\");\n-            }\n-            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n-                                           conc_region, \"\");\n-            }\n-            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n-                // don't bother to print out the message below for\n-                // inference variables, it's not very illuminating.\n-            }\n-            RegionsOverlyPolymorphic(_, conc_region) => {\n-                self.note_and_explain_region(db, \"expected concrete lifetime is \",\n-                                           conc_region, \"\");\n-            }\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);"}, {"sha": "1851e1b8d34bbe595469f394cfe04c43104ddd9b", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -23,7 +23,6 @@ use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n-use middle::region::CodeExtent;\n use mir::Mir;\n use mir::GeneratorLayout;\n use traits;\n@@ -2309,10 +2308,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n-        self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n-    }\n-\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "ae05568ab414854a6edbbbfb27ac3a9d45c57774", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -371,12 +371,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n             }\n-            RegionsNotSame(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNotSame(a, b))\n-            }\n-            RegionsNoOverlap(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n-            }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n             }\n@@ -1057,12 +1051,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsDoesNotOutlive(a, b) => {\n                 RegionsDoesNotOutlive(a.fold_with(folder), b.fold_with(folder))\n             },\n-            RegionsNotSame(a, b) => {\n-                RegionsNotSame(a.fold_with(folder), b.fold_with(folder))\n-            },\n-            RegionsNoOverlap(a, b) => {\n-                RegionsNoOverlap(a.fold_with(folder), b.fold_with(folder))\n-            },\n             RegionsInsufficientlyPolymorphic(a, b) => {\n                 RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n             },\n@@ -1088,9 +1076,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n         match *self {\n             UnsafetyMismatch(x) => x.visit_with(visitor),\n             AbiMismatch(x) => x.visit_with(visitor),\n-            RegionsDoesNotOutlive(a, b) |\n-            RegionsNotSame(a, b) |\n-            RegionsNoOverlap(a, b) => {\n+            RegionsDoesNotOutlive(a, b) => {\n                 a.visit_with(visitor) || b.visit_with(visitor)\n             },\n             RegionsInsufficientlyPolymorphic(_, b) |"}, {"sha": "2f5f31e0f63bc8c8646ba3427c4e459948263216", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::BodyId;\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n use middle::region::{CodeExtent, BlockRemainder};\n@@ -527,16 +526,16 @@ impl fmt::Display for ty::RegionKind {\n             }\n             ty::ReScope(code_extent) if identify_regions() => {\n                 match code_extent {\n-                    CodeExtent::Misc(node_id) =>\n-                        write!(f, \"'{}mce\", node_id.as_u32()),\n-                    CodeExtent::CallSiteScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}cce\", node_id.as_u32()),\n-                    CodeExtent::ParameterScope(BodyId { node_id }) =>\n-                        write!(f, \"'{}pce\", node_id.as_u32()),\n-                    CodeExtent::DestructionScope(node_id) =>\n-                        write!(f, \"'{}dce\", node_id.as_u32()),\n+                    CodeExtent::Misc(id) =>\n+                        write!(f, \"'{}mce\", id.as_usize()),\n+                    CodeExtent::CallSiteScope(id) =>\n+                        write!(f, \"'{}cce\", id.as_usize()),\n+                    CodeExtent::ParameterScope(id) =>\n+                        write!(f, \"'{}pce\", id.as_usize()),\n+                    CodeExtent::DestructionScope(id) =>\n+                        write!(f, \"'{}dce\", id.as_usize()),\n                     CodeExtent::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rce\", block, first_statement_index),\n+                        write!(f, \"'{}_{}rce\", block.as_usize(), first_statement_index),\n                 }\n             }\n             ty::ReVar(region_vid) if identify_regions() => {"}, {"sha": "7f31c53e63caf70ccc772d7360e3731447415acc", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -103,7 +103,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        self.consume_common(consume_id, consume_span, cmt, mode);\n+        let hir_id = self.tcx().hir.node_to_hir_id(consume_id);\n+        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -120,7 +121,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                cmt,\n                mode);\n \n-        self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n+        self.consume_common(consume_pat.hir_id.local_id, consume_pat.span, cmt, mode);\n     }\n \n     fn borrow(&mut self,\n@@ -136,15 +137,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n+        let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(&cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(borrow_id);\n+        self.check_for_conflicting_loans(hir_id.local_id);\n     }\n \n     fn mutate(&mut self,\n@@ -163,7 +165,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // have to be *FULLY* initialized, but we still\n                     // must be careful lest it contains derefs of\n                     // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_assigned_path_is_moved(hir_id.local_id,\n                                                          assignment_span,\n                                                          MovedInUse,\n                                                          &lp);\n@@ -172,14 +175,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // In a case like `path += 1`, then path must be\n                     // fully initialized, since we will read it before\n                     // we write it.\n-                    self.check_if_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_path_is_moved(hir_id.local_id,\n                                                 assignment_span,\n                                                 MovedInUse,\n                                                 &lp);\n                 }\n             }\n         }\n-        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n+        self.check_assignment(self.tcx().hir.node_to_hir_id(assignment_id).local_id,\n+                              assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -220,7 +225,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n+    pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Iterates over each loan that has been issued\n@@ -241,7 +246,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        self.each_issued_loan(scope.node_id(), |loan| {\n+        self.each_issued_loan(scope.item_local_id(), |loan| {\n             if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -325,7 +330,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, node: ast::NodeId) -> Vec<usize> {\n+    pub fn loans_generated_by(&self, node: hir::ItemLocalId) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n         //! we enter `node`.\n \n@@ -337,7 +342,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, node: ast::NodeId) {\n+    pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n         //! Checks to see whether any of the loans that are issued\n         //! on entrance to `node` conflict with loans that have already been\n         //! issued when we enter `node` (for example, we do not\n@@ -462,7 +467,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             // 3. Where does old loan expire.\n \n             let previous_end_span =\n-                self.tcx().hir.span(old_loan.kill_scope.node_id()).end_point();\n+                old_loan.kill_scope.span(self.tcx(), &self.bccx.region_maps).end_point();\n \n             let mut err = match (new_loan.kind, old_loan.kind) {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n@@ -590,7 +595,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn consume_common(&self,\n-                      id: ast::NodeId,\n+                      id: hir::ItemLocalId,\n                       span: Span,\n                       cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n@@ -628,7 +633,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_copy_of_frozen_path(&self,\n-                                     id: ast::NodeId,\n+                                     id: hir::ItemLocalId,\n                                      span: Span,\n                                      copy_path: &LoanPath<'tcx>) {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n@@ -649,7 +654,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_move_of_borrowed_path(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        move_path: &LoanPath<'tcx>,\n                                        move_kind: move_data::MoveKind) {\n@@ -699,13 +704,12 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn analyze_restrictions_on_use(&self,\n-                                       expr_id: ast::NodeId,\n+                                       expr_id: hir::ItemLocalId,\n                                        use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n-        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n-               self.tcx().hir.node_to_string(expr_id),\n-               use_path);\n+        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n+               expr_id, use_path);\n \n         let mut ret = UseOk;\n \n@@ -725,11 +729,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// Reports an error if `expr` (which should be a path)\n     /// is using a moved/uninitialized value\n     fn check_if_path_is_moved(&self,\n-                              id: ast::NodeId,\n+                              id: hir::ItemLocalId,\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={:?})\",\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={:?})\",\n                id, use_kind, lp);\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n@@ -772,7 +776,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        use_kind: MovedValueUseKind,\n                                        lp: &Rc<LoanPath<'tcx>>)\n@@ -822,7 +826,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_assignment(&self,\n-                        assignment_id: ast::NodeId,\n+                        assignment_id: hir::ItemLocalId,\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);"}, {"sha": "465457f5ab39a56a01e54412945bf2969d32c73a", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::*;\n \n struct GatherMoveInfo<'tcx> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     kind: MoveKind,\n     cmt: mc::cmt<'tcx>,\n     span_path_opt: Option<MovePlace<'tcx>>\n@@ -79,13 +79,14 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              var_id: ast::NodeId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id, Declared);\n+    let hir_id = bccx.tcx.hir.node_to_hir_id(var_id);\n+    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n                                        move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                       move_expr_id: ast::NodeId,\n+                                       move_expr_id: hir::ItemLocalId,\n                                        cmt: mc::cmt<'tcx>,\n                                        move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n@@ -118,7 +119,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         _ => None,\n     };\n     let move_info = GatherMoveInfo {\n-        id: move_pat.id,\n+        id: move_pat.hir_id.local_id,\n         kind: MovePat,\n         cmt,\n         span_path_opt: pat_span_path_opt,\n@@ -135,7 +136,7 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &mut MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n-    debug!(\"gather_move(move_id={}, cmt={:?})\",\n+    debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n     let potentially_illegal_move =\n@@ -161,10 +162,10 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                    move_data: &MoveData<'tcx>,\n-                                   assignment_id: ast::NodeId,\n+                                   assignment_id: hir::ItemLocalId,\n                                    assignment_span: Span,\n                                    assignee_loan_path: Rc<LoanPath<'tcx>>,\n-                                   assignee_id: ast::NodeId,\n+                                   assignee_id: hir::ItemLocalId,\n                                    mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,"}, {"sha": "461f1d6a43283930a7addae2b77a0bb1e737de27", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -115,8 +115,9 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n+                let hir_id = self.bccx.tcx.hir.node_to_hir_id(local_id);\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.region_maps.var_scope(local_id)))\n+                    self.bccx.region_maps.var_scope(hir_id.local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(_, mc::UnsafePtr(..)) => {"}, {"sha": "5689a30fd38c0c26b82ea614b3d780ecd0bb4bab", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -43,8 +43,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     let mut glcx = GatherLoanCtxt {\n         bccx,\n         all_loans: Vec::new(),\n-        item_ub: region::CodeExtent::Misc(body.node_id),\n-        move_data: MoveData::new(),\n+        item_ub: region::CodeExtent::Misc(bccx.tcx.hir.body(body).value.hir_id.local_id),\n+        move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    consume_id, cmt, move_reason);\n+                    self.bccx.tcx.hir.node_to_hir_id(consume_id).local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -126,7 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        self.guarantee_valid(borrow_id,\n+        let hir_id = self.bccx.tcx.hir.node_to_hir_id(borrow_id);\n+        self.guarantee_valid(hir_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -272,8 +273,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     self.mark_loan_path_as_mutated(&lp);\n                 }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id, assignment_span,\n-                                                lp, cmt.id, mode);\n+                                                self.bccx.tcx.hir.node_to_hir_id(assignment_id)\n+                                                    .local_id,\n+                                                assignment_span,\n+                                                lp,\n+                                                self.bccx.tcx.hir.node_to_hir_id(cmt.id).local_id,\n+                                                mode);\n             }\n             None => {\n                 // This can occur with e.g. `*foo() = 5`.  In such\n@@ -287,13 +292,13 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     /// reports an error.  This may entail taking out loans, which will be added to the\n     /// `req_loan_map`.\n     fn guarantee_valid(&mut self,\n-                       borrow_id: ast::NodeId,\n+                       borrow_id: hir::ItemLocalId,\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n                        loan_region: ty::Region<'tcx>,\n                        cause: euv::LoanCause) {\n-        debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n+        debug!(\"guarantee_valid(borrow_id={:?}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt,\n@@ -392,7 +397,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n         };\n \n-        debug!(\"guarantee_valid(borrow_id={}), loan={:?}\",\n+        debug!(\"guarantee_valid(borrow_id={:?}), loan={:?}\",\n                borrow_id, loan);\n \n         // let loan_path = loan.loan_path;"}, {"sha": "25aac92c13d8572773e07dd7455c7a923dc1e838", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -36,7 +36,6 @@ use rustc::middle::region::{self, RegionMaps};\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::util::nodemap::FxHashMap;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::fmt;\n@@ -167,9 +166,10 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n+        loan_dfcx.add_gen(loan.gen_scope.item_local_id(), loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.node_id(), loan_idx);\n+                           loan.kill_scope.item_local_id(),\n+                           loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, this.body);\n@@ -364,10 +364,14 @@ fn closure_to_block(closure_id: DefIndex,\n impl<'a, 'tcx> LoanPath<'tcx> {\n     pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n-            LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n+            LpVar(local_id) => {\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(local_id);\n+                bccx.region_maps.var_scope(hir_id.local_id)\n+            }\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                region::CodeExtent::Misc(block_id)\n+                let hir_id = bccx.tcx.hir.node_to_hir_id(block_id);\n+                region::CodeExtent::Misc(hir_id.local_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),\n@@ -640,19 +644,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.body.value.hir_id.owner,\n+            local_id: the_move.id\n+        });\n         let (move_span, move_note) = match the_move.kind {\n             move_data::Declared => {\n                 unreachable!();\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat =>\n-                (self.tcx.hir.span(the_move.id), \"\"),\n+            move_data::MovePat => (self.tcx.hir.span(node_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir.expect_expr(the_move.id).node {\n+                (match self.tcx.hir.expect_expr(node_id).node {\n                     hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n-                    ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n+                    ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n         };\n@@ -813,7 +820,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 debug!(\"err_out_of_scope: self.body.is_generator = {:?}\",\n                        self.body.is_generator);\n                 let maybe_borrow_across_yield = if self.body.is_generator {\n-                    let body_extent = region::CodeExtent::Misc(self.body.id().node_id);\n+                    let body_extent = region::CodeExtent::Misc(self.body.value.hir_id.local_id);\n                     debug!(\"err_out_of_scope: body_extent = {:?}\", body_extent);\n                     debug!(\"err_out_of_scope: super_scope = {:?}\", super_scope);\n                     debug!(\"err_out_of_scope: sub_scope = {:?}\", sub_scope);\n@@ -839,7 +846,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                 // block remainder that starts with\n                                 // `let a`) for a yield. We can cite\n                                 // that for the user.\n-                                self.tcx.yield_in_extent(value_extent, &mut FxHashMap())\n+                                self.region_maps.yield_in_scope(value_extent)\n                             } else {\n                                 None\n                             }\n@@ -938,6 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"borrowed value must be valid for \",\n                                     sub_scope,\n@@ -950,6 +958,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             }\n                             None => {\n                                 self.tcx.note_and_explain_region(\n+                                    &self.region_maps,\n                                     &mut db,\n                                     \"...but borrowed value is only valid for \",\n                                     super_scope,\n@@ -959,8 +968,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if let Some(_) = statement_scope_span(self.tcx, super_scope) {\n-                    db.note(\"consider using a `let` binding to increase its lifetime\");\n+                if let ty::ReScope(scope) = *super_scope {\n+                    let node_id = scope.node_id(self.tcx, &self.region_maps);\n+                    match self.tcx.hir.find(node_id) {\n+                        Some(hir_map::NodeStmt(_)) => {\n+                            db.note(\"consider using a `let` binding to increase its lifetime\");\n+                        }\n+                        _ => {}\n+                    }\n                 }\n \n                 db.emit();\n@@ -979,12 +994,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => self.cmt_to_string(&err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"{} would have to be valid for \",\n                             descr),\n                     loan_scope,\n                     \"...\");\n                 self.tcx.note_and_explain_region(\n+                    &self.region_maps,\n                     &mut db,\n                     &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n@@ -1240,14 +1257,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     fn region_end_span(&self, region: ty::Region<'tcx>) -> Option<Span> {\n         match *region {\n             ty::ReScope(scope) => {\n-                match scope.span(&self.tcx.hir) {\n-                    Some(s) => {\n-                        Some(s.end_point())\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n+                Some(scope.span(self.tcx, &self.region_maps).end_point())\n             }\n             _ => None\n         }\n@@ -1384,18 +1394,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n-    match *region {\n-        ty::ReScope(scope) => {\n-            match tcx.hir.find(scope.node_id()) {\n-                Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),\n-                _ => None\n-            }\n-        }\n-        _ => None\n-    }\n-}\n-\n impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n     fn join(&self, succ: usize, pred: usize) -> usize {"}, {"sha": "7915eccbf74451cc447b6d779d949979b03250f2", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -23,16 +23,16 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n+#[derive(Default)]\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -54,7 +54,7 @@ pub struct MoveData<'tcx> {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n-    pub assignee_ids: RefCell<NodeSet>,\n+    pub assignee_ids: RefCell<FxHashSet<hir::ItemLocalId>>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -133,7 +133,7 @@ pub struct Move {\n     pub path: MovePathIndex,\n \n     /// id of node that is doing the move.\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// Kind of move, for error messages.\n     pub kind: MoveKind,\n@@ -148,13 +148,13 @@ pub struct Assignment {\n     pub path: MovePathIndex,\n \n     /// id where assignment occurs\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// span of node where assignment occurs\n     pub span: Span,\n \n     /// id for l-value expression on lhs of assignment\n-    pub assignee_id: ast::NodeId,\n+    pub assignee_id: hir::ItemLocalId,\n }\n \n #[derive(Clone, Copy)]\n@@ -189,17 +189,6 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n }\n \n impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn new() -> MoveData<'tcx> {\n-        MoveData {\n-            paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FxHashMap()),\n-            moves: RefCell::new(Vec::new()),\n-            path_assignments: RefCell::new(Vec::new()),\n-            var_assignments: RefCell::new(Vec::new()),\n-            assignee_ids: RefCell::new(NodeSet()),\n-        }\n-    }\n-\n     /// return true if there are no trackable assignments or moves\n     /// in this move data - that means that there is nothing that\n     /// could cause a borrow error.\n@@ -345,7 +334,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n     pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     orig_lp: Rc<LoanPath<'tcx>>,\n-                    id: ast::NodeId,\n+                    id: hir::ItemLocalId,\n                     kind: MoveKind) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n@@ -373,9 +362,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        lp: Rc<LoanPath<'tcx>>,\n-                       id: ast::NodeId,\n+                       id: hir::ItemLocalId,\n                        kind: MoveKind) {\n-        debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n+        debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n                lp,\n                id,\n                kind);\n@@ -398,9 +387,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// `span`.\n     pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n-                          assign_id: ast::NodeId,\n+                          assign_id: hir::ItemLocalId,\n                           span: Span,\n-                          assignee_id: ast::NodeId,\n+                          assignee_id: hir::ItemLocalId,\n                           mode: euv::MutateMode) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n@@ -429,11 +418,11 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n-                             assign_id: ast::NodeId,\n+                             assign_id: hir::ItemLocalId,\n                              span: Span,\n-                             assignee_id: ast::NodeId,\n+                             assignee_id: hir::ItemLocalId,\n                              mode: euv::MutateMode) {\n-        debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n+        debug!(\"add_assignment(lp={:?}, assign_id={:?}, assignee_id={:?}\",\n                lp, assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -496,7 +485,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(),\n+                    self.kill_moves(path, kill_scope.item_local_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -511,7 +500,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(),\n+                                         kill_scope.item_local_id(),\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {\n@@ -579,7 +568,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n-                  kill_id: ast::NodeId,\n+                  kill_id: hir::ItemLocalId,\n                   kill_kind: KillFrom,\n                   dfcx_moves: &mut MoveDataFlow) {\n         // We can only perform kills for paths that refer to a unique location,\n@@ -589,7 +578,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let loan_path = self.path_loan_path(path);\n         if loan_path_is_precise(&loan_path) {\n             self.each_applicable_move(path, |move_index| {\n-                debug!(\"kill_moves add_kill {:?} kill_id={} move_index={}\",\n+                debug!(\"kill_moves add_kill {:?} kill_id={:?} move_index={}\",\n                        kill_kind, kill_id, move_index.get());\n                 dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n                 true\n@@ -642,7 +631,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     }\n \n     pub fn kind_of_move_of_path(&self,\n-                                id: ast::NodeId,\n+                                id: hir::ItemLocalId,\n                                 loan_path: &Rc<LoanPath<'tcx>>)\n                                 -> Option<MoveKind> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n@@ -667,7 +656,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n     /// that would invalidate a reference to `loan_path` at location `id`.\n     pub fn each_move_of<F>(&self,\n-                           id: ast::NodeId,\n+                           id: hir::ItemLocalId,\n                            loan_path: &Rc<LoanPath<'tcx>>,\n                            mut f: F)\n                            -> bool where\n@@ -724,7 +713,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n     /// `loan_path` must be a single variable.\n     pub fn each_assignment_of<F>(&self,\n-                                 id: ast::NodeId,\n+                                 id: hir::ItemLocalId,\n                                  loan_path: &Rc<LoanPath<'tcx>>,\n                                  mut f: F)\n                                  -> bool where"}, {"sha": "22867ba5b55a4ae779ebef38fa6469abc5e90ed0", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.1.data.id();\n-        debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n+        debug!(\"dataflow_for({:?}, id={:?}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n         for &variant in &self.variants {"}, {"sha": "6a58b7fb75360ba040058d142624c99bce0168e0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -765,7 +765,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = cfg::CFG::new(tcx, &body);\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        hir_map: &tcx.hir,\n+        tcx,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges,"}, {"sha": "247f51b1da4437ee4a8c785a307428f97a17a687", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -50,7 +50,7 @@ struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n struct RH<'a> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     sub: &'a [RH<'a>],\n }\n \n@@ -157,7 +157,7 @@ fn test_env<F>(source_string: &str,\n                              \"test_crate\",\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n-            let mut region_maps = RegionMaps::new();\n+            let mut region_maps = RegionMaps::default();\n             body(Env {\n                 infcx: &infcx,\n                 region_maps: &mut region_maps,\n@@ -188,21 +188,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // creates a region hierarchy where 1 is root, 10 and 11 are\n         // children of 1, etc\n \n-        let node = ast::NodeId::from_u32;\n-        let dscope = CodeExtent::DestructionScope(node(1));\n+        let dscope = CodeExtent::DestructionScope(hir::ItemLocalId(1));\n         self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n-                                         id: node(1),\n-                                         sub: &[RH {\n-                                                    id: node(10),\n-                                                    sub: &[],\n-                                                },\n-                                                RH {\n-                                                    id: node(11),\n-                                                    sub: &[],\n-                                                }],\n-                                     },\n-                                     dscope);\n+            id: hir::ItemLocalId(1),\n+            sub: &[RH {\n+                id: hir::ItemLocalId(10),\n+                sub: &[],\n+            },\n+            RH {\n+                id: hir::ItemLocalId(11),\n+                sub: &[],\n+            }],\n+        }, dscope);\n     }\n \n     #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n@@ -335,7 +333,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(CodeExtent::Misc(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(CodeExtent::Misc(hir::ItemLocalId(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n "}, {"sha": "52b645638b86f37377a2829c9e2c729af1036500", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -850,23 +850,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             }\n             visited.insert(cfg_id);\n \n-            let node_id = cfg.graph.node_data(idx).id();\n-\n             // is this a recursive call?\n-            let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n-                match method {\n+            let local_id = cfg.graph.node_data(idx).id();\n+            if local_id != hir::DUMMY_ITEM_LOCAL_ID {\n+                let node_id = cx.tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: body.value.hir_id.owner,\n+                    local_id\n+                });\n+                let self_recursive = match method {\n                     Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n                     None => expr_refers_to_this_fn(cx, id, node_id),\n+                };\n+                if self_recursive {\n+                    self_call_spans.push(cx.tcx.hir.span(node_id));\n+                    // this is a self call, so we shouldn't explore past\n+                    // this node in the CFG.\n+                    continue;\n                 }\n-            } else {\n-                false\n-            };\n-            if self_recursive {\n-                self_call_spans.push(cx.tcx.hir.span(node_id));\n-                // this is a self call, so we shouldn't explore past\n-                // this node in the CFG.\n-                continue;\n             }\n+\n             // add the successors of this node to explore the graph further.\n             for (_, edge) in cfg.graph.outgoing_edges(idx) {\n                 let target_idx = edge.target();"}, {"sha": "5c0388a020c76b63e3724cb42cc2751e6c254fd3", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let outer_visibility_scope = this.visibility_scope;\n         let source_info = this.source_info(span);\n         for stmt in stmts {\n-            let Stmt { span, kind, opt_destruction_extent } = this.hir.mirror(stmt);\n+            let Stmt { kind, opt_destruction_extent } = this.hir.mirror(stmt);\n             match kind {\n                 StmtKind::Expr { scope, expr } => {\n                     unpack!(block = this.in_opt_scope(\n@@ -83,15 +83,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }));\n                 }\n                 StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                    let tcx = this.hir.tcx();\n-\n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n                     this.push_scope((remainder_scope, source_info));\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope.\n-                    let remainder_span = remainder_scope.span(&tcx.hir);\n-                    let remainder_span = remainder_span.unwrap_or(span);\n+                    let remainder_span = remainder_scope.span(this.hir.tcx(),\n+                                                              &this.hir.region_maps);\n                     let scope = this.declare_bindings(None, remainder_span, &pattern);\n \n                     // Evaluate the initializer, if present."}, {"sha": "fc6eca466a811b43015bccc7886f15a062f42e3d", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -202,7 +202,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n-        let extent = self.hir.region_maps.var_scope(var);\n+        let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n+        let extent = self.hir.region_maps.var_scope(hir_id.local_id);\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n "}, {"sha": "5cced32f7e69bae9f2b94c33ababc0577cdba52b", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -355,8 +355,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         arguments.len(),\n         return_ty);\n \n-    let call_site_extent = CodeExtent::CallSiteScope(body.id());\n-    let arg_extent = CodeExtent::ParameterScope(body.id());\n+    let call_site_extent = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n+    let arg_extent = CodeExtent::ParameterScope(body.value.hir_id.local_id);\n     let mut block = START_BLOCK;\n     let source_info = builder.source_info(span);\n     unpack!(block = builder.in_scope((call_site_extent, source_info), block, |builder| {"}, {"sha": "2471d8c2c56f7d66fe9710fe402ae3f482de36e2", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -633,8 +633,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 if let DropKind::Value { .. } = drop_kind {\n                     scope.needs_cleanup = true;\n                 }\n-                let tcx = self.hir.tcx();\n-                let extent_span = extent.span(&tcx.hir).unwrap();\n+                let extent_span = extent.span(self.hir.tcx(), &self.hir.region_maps);\n                 // Attribute scope exit drops to scope's closing brace\n                 let scope_end = extent_span.with_lo(extent_span.hi());\n                 scope.drops.push(DropData {"}, {"sha": "8a87751d846c8922446a65ff615f769a254e06d4", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -13,19 +13,18 @@ use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtent};\n use rustc::hir;\n-use syntax::ast;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n-        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.id);\n+        let stmts = mirror_stmts(cx, self.hir_id.local_id, &*self.stmts);\n+        let opt_destruction_extent = cx.region_maps.opt_destruction_extent(self.hir_id.local_id);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: CodeExtent::Misc(self.id),\n+            extent: CodeExtent::Misc(self.hir_id.local_id),\n             opt_destruction_extent,\n             span: self.span,\n             stmts,\n@@ -35,25 +34,25 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n }\n \n fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                block_id: ast::NodeId,\n+                                block_id: hir::ItemLocalId,\n                                 stmts: &'tcx [hir::Stmt])\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(stmt.node.id());\n+        let hir_id = cx.tcx.hir.node_to_hir_id(stmt.node.id());\n+        let opt_dxn_ext = cx.region_maps.opt_destruction_extent(hir_id.local_id);\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n-                    span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: CodeExtent::Misc(id),\n+                        scope: CodeExtent::Misc(hir_id.local_id),\n                         expr: expr.to_ref(),\n                     },\n                     opt_destruction_extent: opt_dxn_ext,\n                 })))\n             }\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     hir::DeclItem(..) => {\n                         // ignore for purposes of the MIR\n@@ -69,10 +68,9 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                                         cx.tables(),\n                                                         &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: CodeExtent::Misc(id),\n+                                init_scope: CodeExtent::Misc(hir_id.local_id),\n                                 pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -90,7 +88,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.hir_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(block.hir_id.local_id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime,"}, {"sha": "a877c61a47a912b35531d310e24c8a054cee789a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -25,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let temp_lifetime = cx.region_maps.temporary_scope(self.id);\n-        let expr_extent = CodeExtent::Misc(self.id);\n+        let temp_lifetime = cx.region_maps.temporary_scope(self.hir_id.local_id);\n+        let expr_extent = CodeExtent::Misc(self.hir_id.local_id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -52,7 +52,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.hir_id.local_id) {\n             expr = Expr {\n                 temp_lifetime,\n                 ty: expr.ty,\n@@ -125,7 +125,7 @@ fn apply_adjustment<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // Convert this to a suitable `&foo` and\n             // then an unsafe coercion. Limit the region to be just this\n             // expression.\n-            let region = ty::ReScope(CodeExtent::Misc(hir_expr.id));\n+            let region = ty::ReScope(CodeExtent::Misc(hir_expr.hir_id.local_id));\n             let region = cx.tcx.mk_region(region);\n             expr = Expr {\n                 temp_lifetime,\n@@ -160,7 +160,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -487,7 +487,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: CodeExtent::Misc(target_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(target_id).local_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -498,7 +498,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: CodeExtent::Misc(loop_id),\n+                    label: CodeExtent::Misc(cx.tcx.hir.node_to_hir_id(loop_id).local_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -585,7 +585,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  expr: &hir::Expr,\n                                  custom_callee: Option<(DefId, &'tcx Substs<'tcx>)>)\n                                  -> Expr<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n         (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n          cx.tables().node_substs(expr.hir_id))\n@@ -676,7 +676,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -867,7 +867,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(expr.hir_id.local_id);\n     let fun = method_callee(cx, expr, custom_callee);\n     let ref_expr = Expr {\n         temp_lifetime,\n@@ -896,7 +896,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n-    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n+    let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.hir_id.local_id);\n     let var_ty = cx.tables()\n                    .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {"}, {"sha": "58051aaecdaab464ae057200a7454b367064a53c", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -46,7 +46,6 @@ pub enum StmtRef<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Stmt<'tcx> {\n-    pub span: Span,\n     pub kind: StmtKind<'tcx>,\n     pub opt_destruction_extent: Option<CodeExtent>,\n }"}, {"sha": "a4bbedfb26b3874036b07693b7b3cf33ab6f57bc", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -340,7 +340,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n-            let region_maps = RegionMaps::new();\n+            let region_maps = RegionMaps::default();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n             infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);"}, {"sha": "fd7dd052cd16d524cf99daf90fdef0bbe29e3dbb", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -114,7 +114,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let free_regions = FreeRegionMap::new();\n         infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n         Ok(())"}, {"sha": "60762134f0ffd884920c38c397bf9b2a57e6e46b", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -13,21 +13,17 @@\n //! is calculated in `rustc_mir::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use log;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Body, Pat, PatKind, Expr};\n use rustc::middle::region::{RegionMaps, CodeExtent};\n use rustc::ty::Ty;\n-use syntax::ast::NodeId;\n-use syntax::codemap::Span;\n use std::rc::Rc;\n use super::FnCtxt;\n use util::nodemap::FxHashMap;\n \n struct InteriorVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    cache: FxHashMap<NodeId, Option<Span>>,\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_maps: Rc<RegionMaps>,\n }\n@@ -36,18 +32,15 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n     fn record(&mut self, ty: Ty<'tcx>, scope: Option<CodeExtent>, expr: Option<&'tcx Expr>) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map(|s| {\n-            self.fcx.tcx.yield_in_extent(s, &mut self.cache).is_some()\n-        }).unwrap_or(true);\n+        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n+            self.region_maps.yield_in_scope(s)\n+        });\n \n-        if live_across_yield {\n+        if let Some(span) = live_across_yield {\n             let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n \n-            if log_enabled!(log::LogLevel::Debug) {\n-                let span = scope.map(|s| s.span(&self.fcx.tcx.hir).unwrap_or(DUMMY_SP));\n-                debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n-                       expr, scope, ty, span);\n-            }\n+            debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, span = {:?}\",\n+                   expr, scope, ty, span);\n \n             // Map the type to the number of types added before it\n             let entries = self.types.len();\n@@ -66,7 +59,6 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap(),\n-        cache: FxHashMap(),\n         region_maps: fcx.tcx.region_maps(def_id),\n     };\n     intravisit::walk_body(&mut visitor, body);\n@@ -101,7 +93,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx Pat) {\n         if let PatKind::Binding(..) = pat.node {\n-            let scope = self.region_maps.var_scope(pat.id);\n+            let scope = self.region_maps.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.tables.borrow().pat_ty(pat);\n             self.record(ty, Some(scope), None);\n         }\n@@ -110,7 +102,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        let scope = self.region_maps.temporary_scope(expr.id);\n+        let scope = self.region_maps.temporary_scope(expr.hir_id.local_id);\n         let ty = self.fcx.tables.borrow().expr_ty_adjusted(expr);\n         self.record(ty, scope, Some(expr));\n "}, {"sha": "2fa80a10d12e48929b44a7007cee197c7d713816", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -606,8 +606,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir.as_local_node_id(def_id);\n         let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n-        let implicit_region_bound = body_id.map(|body| {\n-            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body)))\n+        let implicit_region_bound = body_id.map(|body_id| {\n+            let body = tcx.hir.body(body_id);\n+            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body.value.hir_id.local_id)))\n         });\n \n         Inherited {"}, {"sha": "0cd38a49adef206772a6fc4851ad8772f4a30bc5", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = CodeExtent::CallSiteScope(body_id);\n+        let call_site = CodeExtent::CallSiteScope(body.value.hir_id.local_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(CodeExtent::Misc(body_id.node_id), &body.arguments);\n+        self.link_fn_args(CodeExtent::Misc(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -610,11 +610,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n \n-            let var_scope = self.region_maps.var_scope(id);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let var_scope = self.region_maps.var_scope(hir_id.local_id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n             self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n             let typ = self.resolve_node_type(hir_id);\n@@ -668,7 +668,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -950,7 +950,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = CodeExtent::Misc(call_expr.id);\n+        let callee_scope = CodeExtent::Misc(call_expr.hir_id.local_id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -1002,7 +1002,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // expression.\n         self.check_safety_of_rvalue_destructor_if_necessary(cmt.clone(), expr.span);\n \n-        let expr_region = self.tcx.node_scope_region(expr.id);\n+        let expr_region = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n         for adjustment in adjustments {\n             debug!(\"constrain_adjustments: adjustment={:?}, cmt={:?}\",\n                    adjustment, cmt);\n@@ -1095,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.id));\n+        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.hir_id.local_id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1232,7 +1232,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                let r = self.tcx.node_scope_region(expr.id);\n+                let r = self.tcx.mk_region(ty::ReScope(CodeExtent::Misc(expr.hir_id.local_id)));\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }"}, {"sha": "9cf15e2145d36ff811b202b43b817b98cf17c0ab", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -390,7 +390,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n-        let region_maps = RegionMaps::new();\n+        let region_maps = RegionMaps::default();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n         infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);"}, {"sha": "7be677c184b735a9478bbc7e9b6d86ed55afb18a", "filename": "src/test/mir-opt/end_region_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_1.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -22,16 +22,16 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _1: i32;\n-//     let _2: &'6_1rce i32;\n+//     let _2: &'10_1rce i32;\n //\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 3i32;\n //         StorageLive(_2);\n-//         _2 = &'6_1rce _1;\n+//         _2 = &'10_1rce _1;\n //         _0 = ();\n //         StorageDead(_2);\n-//         EndRegion('6_1rce);\n+//         EndRegion('10_1rce);\n //         StorageDead(_1);\n //         return;\n //     }"}, {"sha": "2cb9b38e7bb94928390385e5b2d9c2abb88393e8", "filename": "src/test/mir-opt/end_region_2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_2.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -27,8 +27,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _2: bool;\n-//     let _3: &'7_1rce bool;\n-//     let _7: &'7_3rce bool;\n+//     let _3: &'23_1rce bool;\n+//     let _7: &'23_3rce bool;\n //     let mut _4: ();\n //     let mut _5: bool;\n //     bb0: {\n@@ -38,7 +38,7 @@ fn main() {\n //         StorageLive(_2);\n //         _2 = const true;\n //         StorageLive(_3);\n-//         _3 = &'7_1rce _2;\n+//         _3 = &'23_1rce _2;\n //         StorageLive(_5);\n //         _5 = _2;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -47,19 +47,19 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         return;\n //     }\n //     bb3: {\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'7_3rce _2;\n+//         _7 = &'23_3rce _2;\n //         _1 = ();\n //         StorageDead(_7);\n-//         EndRegion('7_3rce);\n+//         EndRegion('23_3rce);\n //         StorageDead(_3);\n-//         EndRegion('7_1rce);\n+//         EndRegion('23_1rce);\n //         StorageDead(_2);\n //         goto -> bb1;\n //     }"}, {"sha": "001bb9c1a02849749695657b121e35df195e4557", "filename": "src/test/mir-opt/end_region_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_3.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -28,8 +28,8 @@ fn main() {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let mut _1: bool;\n-//     let _3: &'9_1rce bool;\n-//     let _7: &'9_3rce bool;\n+//     let _3: &'26_1rce bool;\n+//     let _7: &'26_3rce bool;\n //     let mut _2: ();\n //     let mut _4: ();\n //     let mut _5: bool;\n@@ -41,7 +41,7 @@ fn main() {\n //     bb1: {\n //         _1 = const true;\n //         StorageLive(_3);\n-//         _3 = &'9_1rce _1;\n+//         _3 = &'26_1rce _1;\n //         StorageLive(_5);\n //         _5 = _1;\n //         switchInt(_5) -> [0u8: bb3, otherwise: bb2];\n@@ -50,20 +50,20 @@ fn main() {\n //         _0 = ();\n //         StorageDead(_5);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         StorageDead(_1);\n //         return;\n //     }\n //     bb3: {\n //         _4 = ();\n //         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'9_3rce _1;\n+//         _7 = &'26_3rce _1;\n //         _2 = ();\n //         StorageDead(_7);\n-//         EndRegion('9_3rce);\n+//         EndRegion('26_3rce);\n //         StorageDead(_3);\n-//         EndRegion('9_1rce);\n+//         EndRegion('26_1rce);\n //         goto -> bb1;\n //     }\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "8c854ce87a2c6b100b2e398f73190633b420aa72", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -33,8 +33,8 @@ fn foo(i: i32) {\n //     let mut _0: ();\n //     let _1: D;\n //     let _2: i32;\n-//     let _3: &'6_2rce i32;\n-//     let _6: &'6_4rce i32;\n+//     let _3: &'26_2rce i32;\n+//     let _6: &'26_4rce i32;\n //     let mut _4: ();\n //     let mut _5: i32;\n //     bb0: {\n@@ -43,28 +43,28 @@ fn foo(i: i32) {\n //         StorageLive(_2);\n //         _2 = const 0i32;\n //         StorageLive(_3);\n-//         _3 = &'6_2rce _2;\n+//         _3 = &'26_2rce _2;\n //         StorageLive(_5);\n //         _5 = (*_3);\n //         _4 = const foo(_5) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_5);\n //         StorageLive(_6);\n-//         _6 = &'6_4rce _2;\n+//         _6 = &'26_4rce _2;\n //         _0 = ();\n //         StorageDead(_6);\n-//         EndRegion('6_4rce);\n+//         EndRegion('26_4rce);\n //         StorageDead(_3);\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         StorageDead(_2);\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('6_2rce);\n+//         EndRegion('26_2rce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {"}, {"sha": "ae1b4e2e83abb9ed22d052a6f4b73e1f2edb9859", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(18) d:&'19mce D];\n-//     let mut _4: &'19mce D;\n+//     let mut _3: [closure@NodeId(18) d:&'14mce D];\n+//     let mut _4: &'14mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'19mce _1;\n+//         _4 = &'14mce _1;\n //         _3 = [closure@NodeId(18)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('19mce);\n+//         EndRegion('14mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -64,13 +64,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node18.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'19mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(18) d:&'14mce D]) -> i32 {\n //    let mut _0: i32;\n //    let mut _2: i32;\n //\n //    bb0: {\n //        StorageLive(_2);\n-//        _2 = ((*(_1.0: &'19mce D)).0: i32);\n+//        _2 = ((*(_1.0: &'14mce D)).0: i32);\n //        _0 = _2;\n //        StorageDead(_2);\n //        return;"}, {"sha": "8054b64400669c05f5cebf9d4a920ec6a612b1b9", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -31,29 +31,29 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: [closure@NodeId(22) d:&'23mce D];\n-//     let mut _4: &'23mce D;\n+//     let mut _3: [closure@NodeId(22) d:&'19mce D];\n+//     let mut _4: &'19mce D;\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n //         StorageLive(_3);\n //         StorageLive(_4);\n-//         _4 = &'23mce _1;\n+//         _4 = &'19mce _1;\n //         _3 = [closure@NodeId(22)] { d: _4 };\n //         StorageDead(_4);\n //         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n //         StorageDead(_3);\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n //     bb2: {\n //         resume;\n //     }\n //     bb3: {\n-//         EndRegion('23mce);\n+//         EndRegion('19mce);\n //         drop(_1) -> bb2;\n //     }\n //     bb4: {\n@@ -63,20 +63,20 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'23mce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) d:&'19mce D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (*(_1.0: &'23mce D));\n+//         _2 = &'15_0rce (*(_1.0: &'19mce D));\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         return;\n //     }\n // END rustc.node22.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "d68439087615b93d80361aea7f3e32bce5d9b10b", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -74,18 +74,18 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n-//     let _2: &'14_0rce D;\n+//     let _2: &'15_0rce D;\n //     let mut _3: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = &'14_0rce (_1.0: D);\n+//         _2 = &'15_0rce (_1.0: D);\n //         StorageLive(_3);\n //         _3 = ((*_2).0: i32);\n //         _0 = _3;\n //         StorageDead(_3);\n //         StorageDead(_2);\n-//         EndRegion('14_0rce);\n+//         EndRegion('15_0rce);\n //         drop(_1) -> bb1;\n //     }\n //     bb1: {"}, {"sha": "8d7050941e7ebfe060b9bc8ebce967d544aae4ac", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -31,15 +31,15 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main() -> () {\n //    let mut _0: ();\n //    let _1: D;\n-//    let _2: &'6_1rce D;\n+//    let _2: &'21_1rce D;\n //    let mut _3: ();\n-//    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n-//    let mut _5: &'6_1rce D;\n+//    let mut _4: [closure@NodeId(22) r:&'21_1rce D];\n+//    let mut _5: &'21_1rce D;\n //    bb0: {\n //        StorageLive(_1);\n //        _1 = D::{{constructor}}(const 0i32,);\n //        StorageLive(_2);\n-//        _2 = &'6_1rce _1;\n+//        _2 = &'21_1rce _1;\n //        StorageLive(_4);\n //        StorageLive(_5);\n //        _5 = _2;\n@@ -51,14 +51,14 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //        StorageDead(_4);\n //        _0 = ();\n //        StorageDead(_2);\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb4;\n //    }\n //    bb2: {\n //        resume;\n //    }\n //    bb3: {\n-//        EndRegion('6_1rce);\n+//        EndRegion('21_1rce);\n //        drop(_1) -> bb2;\n //    }\n //    bb4: {\n@@ -69,13 +69,13 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n \n // START rustc.node22.SimplifyCfg-qualify-consts.after.mir\n-// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'6_1rce D]) -> i32 {\n+// fn main::{{closure}}(_1: [closure@NodeId(22) r:&'21_1rce D]) -> i32 {\n //     let mut _0: i32;\n //     let mut _2: i32;\n //\n //     bb0: {\n //         StorageLive(_2);\n-//         _2 = ((*(_1.0: &'6_1rce D)).0: i32);\n+//         _2 = ((*(_1.0: &'21_1rce D)).0: i32);\n //         _0 = _2;\n //         StorageDead(_2);\n //         return;"}, {"sha": "9c528da8b348dda7bc3481a2f9dbada0a6a1e120", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -37,19 +37,19 @@ fn main() {\n // START rustc.node23.EraseRegions.after.mir\n // fn main() -> () {\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [_1: i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [_1: i32]);\n //         _6 = &ReErased mut _1;\n-//         Validate(Acquire, [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Acquire, [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(10)))), [(*_6): i32/ReScope(Misc(ItemLocalId(10)))]);\n //         _5 = &ReErased mut (*_6);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(34)))]);\n-//         Validate(Release, [_2: (), _3: &ReScope(Misc(NodeId(34))) Test, _5: &ReScope(Misc(NodeId(34))) mut i32]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(10)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Misc(ItemLocalId(10))) Test, _5: &ReScope(Misc(ItemLocalId(10))) mut i32]);\n //         _2 = const Test::foo(_3, _5) -> bb1;\n //     }\n //\n //     bb1: {\n //         Validate(Acquire, [_2: ()]);\n-//         EndRegion(ReScope(Misc(NodeId(34))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(10))));\n //         return;\n //     }\n // }\n@@ -61,15 +61,15 @@ fn main() {\n //         StorageLive(_3);\n //         _3 = _2;\n //         StorageLive(_4);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 }))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_3): i32]);\n //         _4 = &ReErased (*_3);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })) (imm)]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })) (imm)]);\n //         StorageLive(_5);\n //         _5 = (*_4);\n //         _0 = _5;\n //         StorageDead(_5);\n //         StorageDead(_4);\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(41), first_statement_index: 0 })));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 })));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "cd556564b7913d39bfaf8fc6e073f46044b279e3", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -32,18 +32,18 @@ fn main() {\n // fn main() -> () {\n //     let mut _5: &ReErased i32;\n //     bb0: {\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(17)))), [(*_5): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n //         _4 = &ReErased (*_5);\n-//         Validate(Acquire, [(*_4): i32/ReScope(Misc(NodeId(46))) (imm)]);\n-//         Validate(Release, [_3: (), _4: &ReScope(Misc(NodeId(46))) i32]);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Misc(ItemLocalId(17))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Misc(ItemLocalId(17))) i32]);\n //         _3 = const foo(_4) -> bb1;\n //     }\n //     bb1: {\n-//         EndRegion(ReScope(Misc(NodeId(46))));\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n+//         EndRegion(ReScope(Misc(ItemLocalId(17))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(19), first_statement_index: 3 })));\n //         return;\n //     }\n // }"}, {"sha": "224f4ce2effe3294cd47269c84c8a74c1311ed95", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -50,12 +50,12 @@ fn main() {\n //         _3 = _2;\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Misc(NodeId(44)))), [(*_3): i32]);\n+//         Validate(Suspend(ReScope(Misc(ItemLocalId(9)))), [(*_3): i32]);\n //         _5 = &ReErased mut (*_3);\n-//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(44)))]);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(ItemLocalId(9)))]);\n //         _4 = _5 as *mut i32 (Misc);\n //         StorageDead(_5);\n-//         EndRegion(ReScope(Misc(NodeId(44))));\n+//         EndRegion(ReScope(Misc(ItemLocalId(9))));\n //         Validate(Release, [_0: bool, _4: *mut i32]);\n //         _0 = const write_42(_4) -> bb1;\n //     }"}, {"sha": "d928a6a0a8e64b0299ca3fc2bf807963dbce1fbd", "filename": "src/test/ui/mismatched_types/closure-mismatch.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a59a6d8a5687dd6aee871de0e7c9f734709ac544/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-mismatch.stderr?ref=a59a6d8a5687dd6aee871de0e7c9f734709ac544", "patch": "@@ -4,7 +4,6 @@ error[E0271]: type mismatch resolving `for<'r> <[closure@$DIR/closure-mismatch.r\n 18 |     baz(|_| ());\n    |     ^^^ expected bound lifetime parameter, found concrete lifetime\n    |\n-   = note: concrete lifetime that was found is lifetime '_#0r\n    = note: required because of the requirements on the impl of `Foo` for `[closure@$DIR/closure-mismatch.rs:18:9: 18:15]`\n    = note: required by `baz`\n "}]}