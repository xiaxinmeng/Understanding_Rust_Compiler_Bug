{"sha": "01828fde5345299636f6c029b333f42e91ffd140", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODI4ZmRlNTM0NTI5OTYzNmY2YzAyOWIzMzNmNDJlOTFmZmQxNDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-19T17:51:41Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-22T14:48:10Z"}, "message": "respect memory's privacy", "tree": {"sha": "a4b1801f69cf9ba34e7dd7ebea8349bd313f0430", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4b1801f69cf9ba34e7dd7ebea8349bd313f0430"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01828fde5345299636f6c029b333f42e91ffd140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01828fde5345299636f6c029b333f42e91ffd140", "html_url": "https://github.com/rust-lang/rust/commit/01828fde5345299636f6c029b333f42e91ffd140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01828fde5345299636f6c029b333f42e91ffd140/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fda03e9d7db66f59f4c1ae9ca752b68c53d1fe88", "url": "https://api.github.com/repos/rust-lang/rust/commits/fda03e9d7db66f59f4c1ae9ca752b68c53d1fe88", "html_url": "https://github.com/rust-lang/rust/commit/fda03e9d7db66f59f4c1ae9ca752b68c53d1fe88"}], "stats": {"total": 107, "additions": 54, "deletions": 53}, "files": [{"sha": "04601b3cd1ff7be81b5549fe65b1536f8cabfc5f", "filename": "src/fn_call.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/01828fde5345299636f6c029b333f42e91ffd140/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01828fde5345299636f6c029b333f42e91ffd140/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=01828fde5345299636f6c029b333f42e91ffd140", "patch": "@@ -125,15 +125,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     self.write_null(dest)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n+                    let ptr = self.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n                     self.write_scalar(Scalar::Ptr(ptr), dest)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n                 if !ptr.is_null() {\n-                    self.memory.deallocate(\n+                    self.memory_mut().deallocate(\n                         ptr.to_ptr()?.with_default_tag(),\n                         None,\n                         MiriMemoryKind::C.into(),\n@@ -150,7 +150,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                let ptr = self.memory_mut().allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                MiriMemoryKind::Rust.into())?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n@@ -164,10 +164,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n+                let ptr = self.memory_mut().allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                MiriMemoryKind::Rust.into())?;\n-                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                self.memory_mut().write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -180,7 +180,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(\n+                self.memory_mut().deallocate(\n                     ptr.with_default_tag(),\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n@@ -197,7 +197,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let new_ptr = self.memory.reallocate(\n+                let new_ptr = self.memory_mut().reallocate(\n                     ptr.with_default_tag(),\n                     Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n@@ -231,7 +231,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n                 let symbol = self.read_scalar(args[1])?.to_ptr()?.erase_tag();\n-                let symbol_name = self.memory.read_c_str(symbol.with_default_tag())?;\n+                let symbol_name = self.memory().read_c_str(symbol.with_default_tag())?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -245,7 +245,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let f = self.read_scalar(args[0])?.to_ptr()?;\n                 let data = self.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = self.memory.get_fn(f)?;\n+                let f_instance = self.memory().get_fn(f)?;\n                 self.write_null(dest)?;\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n@@ -289,8 +289,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(&self)?);\n \n                 let result = {\n-                    let left_bytes = self.memory.read_bytes(left.with_default_tag(), n)?;\n-                    let right_bytes = self.memory.read_bytes(right.with_default_tag(), n)?;\n+                    let left_bytes = self.memory().read_bytes(left.with_default_tag(), n)?;\n+                    let right_bytes = self.memory().read_bytes(right.with_default_tag(), n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -311,7 +311,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?\n+                if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?\n                     .iter().rev().position(|&c| c == val)\n                 {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n@@ -326,7 +326,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n+                if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n@@ -340,7 +340,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"getenv\" => {\n                 let result = {\n                     let name_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let name = self.memory.read_c_str(name_ptr.with_default_tag())?;\n+                    let name = self.memory().read_c_str(name_ptr.with_default_tag())?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(*self.tcx),\n@@ -354,15 +354,16 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n+                        let name = self.memory().read_c_str(name_ptr.to_ptr()?\n+                            .with_default_tag())?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.machine.env_vars.remove(name));\n+                            success = Some(self.machine.env_vars.remove(&name));\n                         }\n                     }\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                        self.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -375,30 +376,30 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let value = self.memory.read_c_str(value_ptr.with_default_tag())?;\n+                    let value = self.memory().read_c_str(value_ptr.with_default_tag())?;\n                     if !name_ptr.is_null() {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n+                        let name = self.memory().read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n                     }\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate(\n+                    let value_copy = self.memory_mut().allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n                     )?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    self.memory_mut().write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n-                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n                     )\n                     {\n-                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                        self.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -415,7 +416,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n+                    let buf_cont = self.memory().read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -437,7 +438,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"strlen\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag();\n-                let n = self.memory.read_c_str(ptr.with_default_tag())?.len();\n+                let n = self.memory().read_c_str(ptr.with_default_tag())?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -487,9 +488,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n-                    Scalar::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    Scalar::Ptr(dtor_ptr) => Some(self.memory().get_fn(dtor_ptr)?),\n                     Scalar::Bits { bits: 0, size } => {\n-                        assert_eq!(size as u64, self.memory.pointer_size().bytes());\n+                        assert_eq!(size as u64, self.memory().pointer_size().bytes());\n                         None\n                     },\n                     Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n@@ -505,7 +506,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory.write_scalar(\n+                self.memory_mut().write_scalar(\n                     key_ptr.with_default_tag(),\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),"}, {"sha": "98c57894a9d6277421a7cab2e226122830e601f6", "filename": "src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/01828fde5345299636f6c029b333f42e91ffd140/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01828fde5345299636f6c029b333f42e91ffd140/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=01828fde5345299636f6c029b333f42e91ffd140", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // erase tags: this is a raw ptr operation\n                 let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n                 let dest = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n-                self.memory.copy(\n+                self.memory_mut().copy(\n                     src.with_default_tag(),\n                     elem_align,\n                     dest.with_default_tag(),\n@@ -260,7 +260,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                            self.memory_mut().write_repeat(mplace.ptr, 0, dest.layout.size)?;\n                         }\n                     }\n                 }\n@@ -423,7 +423,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory.mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n+                            self.memory_mut().mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n                         }\n                     }\n                 }\n@@ -435,8 +435,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n-                self.memory.check_align(ptr, ty_layout.align)?;\n-                self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n+                self.memory().check_align(ptr, ty_layout.align)?;\n+                self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;\n             }\n \n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "8925afa5f600137c1025e2619bfefd18f8260c29", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01828fde5345299636f6c029b333f42e91ffd140/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01828fde5345299636f6c029b333f42e91ffd140/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=01828fde5345299636f6c029b333f42e91ffd140", "patch": "@@ -119,12 +119,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // FIXME: extract main source file path\n         // Third argument (argv): &[b\"foo\"]\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let foo = ecx.memory.allocate_static_bytes(b\"foo\\0\");\n+        let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\");\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n         let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n         ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory.mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n+        ecx.memory_mut().mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n         ecx.write_scalar(foo_place.ptr, dest)?;\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");"}, {"sha": "0eac5c11276a71c32ee987e34e393f9632844bf7", "filename": "src/operator.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/01828fde5345299636f6c029b333f42e91ffd140/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01828fde5345299636f6c029b333f42e91ffd140/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=01828fde5345299636f6c029b333f42e91ffd140", "patch": "@@ -80,8 +80,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                         Ge => left.offset >= right.offset,\n                         Sub => {\n                             // subtract the offsets\n-                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory.pointer_size());\n-                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory.pointer_size());\n+                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory().pointer_size());\n+                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory().pointer_size());\n                             let layout = self.layout_of(self.tcx.types.usize)?;\n                             return self.binary_op(\n                                 Sub,\n@@ -103,7 +103,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     left.to_ptr().expect(\"we checked is_ptr\"),\n-                    right.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     right_layout.abi.is_signed(),\n                 )\n             }\n@@ -113,7 +113,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     right.to_ptr().expect(\"we checked is_ptr\"),\n-                    left.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    left.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     left_layout.abi.is_signed(),\n                 )\n             }\n@@ -142,8 +142,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // allocations sit right next to each other.  The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n-                    self.memory.check_bounds_ptr(left, false)?;\n-                    self.memory.check_bounds_ptr(right, false)?;\n+                    self.memory().check_bounds_ptr(left, false)?;\n+                    self.memory().check_bounds_ptr(right, false)?;\n                     // Two live in-bounds pointers, we can compare across allocations\n                     left == right\n                 }\n@@ -153,7 +153,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n                 let bits = bits as u64;\n-                let (alloc_size, alloc_align) = self.memory.get_size_and_align(ptr.alloc_id);\n+                let (alloc_size, alloc_align) = self.memory().get_size_and_align(ptr.alloc_id);\n \n                 // Case I: Comparing with NULL\n                 if bits == 0 {\n@@ -223,15 +223,15 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n                 let base_mask = {\n                     // FIXME: Use interpret::truncate, once that takes a Size instead of a Layout\n-                    let shift = 128 - self.memory.pointer_size().bits();\n+                    let shift = 128 - self.memory().pointer_size().bits();\n                     let value = !(ptr_base_align as u128 - 1);\n                     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n                     (value << shift) >> shift\n                 };\n-                let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 trace!(\"Ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n                     ptr_base_align, right, base_mask);\n                 if right & base_mask == base_mask {\n@@ -256,9 +256,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             Rem if !signed => {\n                 // Doing modulo a divisor of the alignment is allowed.\n                 // (Intuition: Modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n                 let right = right as u64;\n-                let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 if right == 1 {\n                     // modulo 1 is always 0\n                     (Scalar::Bits { bits: 0, size: ptr_size }, false)\n@@ -295,9 +295,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory.check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, false)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory.check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, false)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "993287502ae0022d183ab0c42754e65ead905ec1", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/01828fde5345299636f6c029b333f42e91ffd140/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01828fde5345299636f6c029b333f42e91ffd140/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=01828fde5345299636f6c029b333f42e91ffd140", "patch": "@@ -372,11 +372,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n-        self.memory.check_bounds(ptr, size, false)?;\n+        self.memory().check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n-        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         let permit_redundant = ref_kind == RefKind::Shr; // redundant shared refs are okay\n         alloc.extra.reborrow(ptr, size, new_bor, permit_redundant)?;\n \n@@ -435,8 +435,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         }\n         // Even if we don't touch the tag, this operation is only okay if we *could*\n         // activate it.  Also it must not be dangling.\n-        self.memory.check_bounds(ptr, size, false)?;\n-        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        self.memory().check_bounds(ptr, size, false)?;\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         let mut stacks = alloc.extra.stacks.borrow_mut();\n         // We need `iter_mut` because `iter` would skip gaps!\n         for stack in stacks.iter_mut(ptr.offset, size) {"}]}