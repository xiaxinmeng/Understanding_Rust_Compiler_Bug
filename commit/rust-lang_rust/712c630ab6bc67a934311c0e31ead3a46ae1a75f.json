{"sha": "712c630ab6bc67a934311c0e31ead3a46ae1a75f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMmM2MzBhYjZiYzY3YTkzNDMxMWMwZTMxZWFkM2E0NmFlMWE3NWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-05T06:06:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-05T06:06:38Z"}, "message": "auto merge of #12300 : DaGenix/rust/uppercase-variable-lint, r=alexcrichton\n\nI added a new lint for variables whose names contain uppercase characters, since, by convention, variable names should be all lowercase. What motivated me to work on this was when I ran into something like the following:\r\n\r\n```rust\r\nuse std::io::File;\r\nuse std::io::IoError;\r\n\r\nfn main() {\r\n    let mut f = File::open(&Path::new(\"/something.txt\"));\r\n    let mut buff = [0u8, ..16];\r\n    match f.read(buff) {\r\n        Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\r\n        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_str()),\r\n    }\r\n}\r\n```\r\n\r\nI then got compile errors when I tried to add a wildcard match pattern at the end which I found very confusing since I believed that the 2nd match arm was only matching the EndOfFile condition. The problem is that I hadn't imported io::EndOfFile into the local scope. So, I thought that I was using EndOfFile as a sub-pattern, however, what I was actually doing was creating a new local variable named EndOfFile. This lint makes this error easier to spot by providing a warning that the variable name EndOfFile contains a uppercase characters which provides a nice hint as to why the code isn't doing what is intended.\r\n\r\nThe lint warns on local bindings as well:\r\n\r\n```rust\r\nlet Hi = 0;\r\n```\r\n\r\nAnd also struct fields:\r\n\r\n```rust\r\nstruct Something {\r\n    X: uint\r\n}\r\n```", "tree": {"sha": "c2adb219abe4b1a5d8e414c099246053d15683ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2adb219abe4b1a5d8e414c099246053d15683ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/712c630ab6bc67a934311c0e31ead3a46ae1a75f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/712c630ab6bc67a934311c0e31ead3a46ae1a75f", "html_url": "https://github.com/rust-lang/rust/commit/712c630ab6bc67a934311c0e31ead3a46ae1a75f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/712c630ab6bc67a934311c0e31ead3a46ae1a75f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc761f3f97b0a5ff5e355430bb4e52b15f567b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc761f3f97b0a5ff5e355430bb4e52b15f567b6", "html_url": "https://github.com/rust-lang/rust/commit/3cc761f3f97b0a5ff5e355430bb4e52b15f567b6"}, {"sha": "258dbd09ba4aa868b373df7e82721ba0c40167ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/258dbd09ba4aa868b373df7e82721ba0c40167ba", "html_url": "https://github.com/rust-lang/rust/commit/258dbd09ba4aa868b373df7e82721ba0c40167ba"}], "stats": {"total": 1303, "additions": 698, "deletions": 605}, "files": [{"sha": "47e1118459d6701f4057031959c15358de62ccbc", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -73,31 +73,31 @@ pub fn run_metrics(config: config, testfile: ~str, mm: &mut MetricMap) {\n }\n \n fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n-    let ProcRes = compile_test(config, props, testfile);\n+    let proc_res = compile_test(config, props, testfile);\n \n-    if ProcRes.status.success() {\n-        fatal_ProcRes(~\"compile-fail test compiled successfully!\", &ProcRes);\n+    if proc_res.status.success() {\n+        fatal_ProcRes(~\"compile-fail test compiled successfully!\", &proc_res);\n     }\n \n-    check_correct_failure_status(&ProcRes);\n+    check_correct_failure_status(&proc_res);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(~\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, &ProcRes);\n+        check_expected_errors(expected_errors, testfile, &proc_res);\n     } else {\n-        check_error_patterns(props, testfile, &ProcRes);\n+        check_error_patterns(props, testfile, &proc_res);\n     }\n }\n \n fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n-    let ProcRes = if !config.jit {\n-        let ProcRes = compile_test(config, props, testfile);\n+    let proc_res = if !config.jit {\n+        let proc_res = compile_test(config, props, testfile);\n \n-        if !ProcRes.status.success() {\n-            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n+        if !proc_res.status.success() {\n+            fatal_ProcRes(~\"compilation failed!\", &proc_res);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -107,41 +107,41 @@ fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n \n     // The value our Makefile configures valgrind to return on failure\n     static VALGRIND_ERR: int = 100;\n-    if ProcRes.status.matches_exit_status(VALGRIND_ERR) {\n-        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &ProcRes);\n+    if proc_res.status.matches_exit_status(VALGRIND_ERR) {\n+        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &proc_res);\n     }\n \n-    check_correct_failure_status(&ProcRes);\n-    check_error_patterns(props, testfile, &ProcRes);\n+    check_correct_failure_status(&proc_res);\n+    check_error_patterns(props, testfile, &proc_res);\n }\n \n-fn check_correct_failure_status(ProcRes: &ProcRes) {\n+fn check_correct_failure_status(proc_res: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static RUST_ERR: int = 101;\n-    if !ProcRes.status.matches_exit_status(RUST_ERR) {\n+    if !proc_res.status.matches_exit_status(RUST_ERR) {\n         fatal_ProcRes(\n-            format!(\"failure produced the wrong error: {}\", ProcRes.status),\n-            ProcRes);\n+            format!(\"failure produced the wrong error: {}\", proc_res.status),\n+            proc_res);\n     }\n }\n \n fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n     if !config.jit {\n-        let mut ProcRes = compile_test(config, props, testfile);\n+        let mut proc_res = compile_test(config, props, testfile);\n \n-        if !ProcRes.status.success() {\n-            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n+        if !proc_res.status.success() {\n+            fatal_ProcRes(~\"compilation failed!\", &proc_res);\n         }\n \n-        ProcRes = exec_compiled_test(config, props, testfile);\n+        proc_res = exec_compiled_test(config, props, testfile);\n \n-        if !ProcRes.status.success() {\n-            fatal_ProcRes(~\"test run failed!\", &ProcRes);\n+        if !proc_res.status.success() {\n+            fatal_ProcRes(~\"test run failed!\", &proc_res);\n         }\n     } else {\n-        let ProcRes = jit_test(config, props, testfile);\n+        let proc_res = jit_test(config, props, testfile);\n \n-        if !ProcRes.status.success() { fatal_ProcRes(~\"jit failed!\", &ProcRes); }\n+        if !proc_res.status.success() { fatal_ProcRes(~\"jit failed!\", &proc_res); }\n     }\n }\n \n@@ -160,14 +160,14 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, format!(\"pretty-printing round {}\", round));\n-        let ProcRes = print_source(config, testfile, srcs[round].clone());\n+        let proc_res = print_source(config, testfile, srcs[round].clone());\n \n-        if !ProcRes.status.success() {\n+        if !proc_res.status.success() {\n             fatal_ProcRes(format!(\"pretty-printing failed in round {}\", round),\n-                          &ProcRes);\n+                          &proc_res);\n         }\n \n-        let ProcRes{ stdout, .. } = ProcRes;\n+        let ProcRes{ stdout, .. } = proc_res;\n         srcs.push(stdout);\n         round += 1;\n     }\n@@ -192,10 +192,10 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     compare_source(expected, actual);\n \n     // Finally, let's make sure it actually appears to remain valid code\n-    let ProcRes = typecheck_source(config, props, testfile, actual);\n+    let proc_res = typecheck_source(config, props, testfile, actual);\n \n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"pretty-printed source does not typecheck\", &ProcRes);\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"pretty-printed source does not typecheck\", &proc_res);\n     }\n \n     return;\n@@ -269,14 +269,14 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     let mut cmds = props.debugger_cmds.connect(\"\\n\");\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n-    let mut ProcRes = compile_test(config, props, testfile);\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n+    let mut proc_res = compile_test(config, props, testfile);\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n     }\n \n     let exe_file = make_exe_name(config, testfile);\n \n-    let mut ProcArgs;\n+    let mut proc_args;\n     match config.target {\n         ~\"arm-linux-androideabi\" => {\n \n@@ -356,7 +356,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n                 cmdline\n             };\n \n-            ProcRes = ProcRes {status: status,\n+            proc_res = ProcRes {status: status,\n                                stdout: out,\n                                stderr: err,\n                                cmdline: cmdline};\n@@ -383,12 +383,12 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             let debugger_opts = ~[~\"-quiet\", ~\"-batch\", ~\"-nx\",\n                 \"-command=\" + debugger_script.as_str().unwrap().to_owned(),\n                 exe_file.as_str().unwrap().to_owned()];\n-            ProcArgs = ProcArgs {prog: debugger(), args: debugger_opts};\n-            ProcRes = compose_and_run(config, testfile, ProcArgs, ~[], \"\", None);\n+            proc_args = ProcArgs {prog: debugger(), args: debugger_opts};\n+            proc_res = compose_and_run(config, testfile, proc_args, ~[], \"\", None);\n         }\n     }\n \n-    if !ProcRes.status.success() {\n+    if !proc_res.status.success() {\n         fatal(~\"gdb failed to execute\");\n     }\n     let num_check_lines = check_lines.len();\n@@ -399,7 +399,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for line in ProcRes.stdout.lines() {\n+        for line in proc_res.stdout.lines() {\n             let mut rest = line.trim();\n             let mut first = true;\n             let mut failed = false;\n@@ -430,7 +430,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n         }\n         if i != num_check_lines {\n             fatal_ProcRes(format!(\"line not found in debugger output: {}\",\n-                                  check_lines[i]), &ProcRes);\n+                                  check_lines[i]), &proc_res);\n         }\n     }\n \n@@ -451,22 +451,22 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n \n fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n-                        ProcRes: &ProcRes) {\n+                        proc_res: &ProcRes) {\n     if props.error_patterns.is_empty() {\n         fatal(~\"no error pattern specified in \" + testfile.display().as_maybe_owned().as_slice());\n     }\n \n-    if ProcRes.status.success() {\n+    if proc_res.status.success() {\n         fatal(~\"process did not return an error status\");\n     }\n \n     let mut next_err_idx = 0u;\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     let output_to_check = if props.check_stdout {\n-        ProcRes.stdout + ProcRes.stderr\n+        proc_res.stdout + proc_res.stderr\n     } else {\n-        ProcRes.stderr.clone()\n+        proc_res.stderr.clone()\n     };\n     for line in output_to_check.lines() {\n         if line.contains(*next_err_pat) {\n@@ -486,24 +486,24 @@ fn check_error_patterns(props: &TestProps,\n         props.error_patterns.slice(next_err_idx, props.error_patterns.len());\n     if missing_patterns.len() == 1u {\n         fatal_ProcRes(format!(\"error pattern '{}' not found!\",\n-                              missing_patterns[0]), ProcRes);\n+                              missing_patterns[0]), proc_res);\n     } else {\n         for pattern in missing_patterns.iter() {\n             error(format!(\"error pattern '{}' not found!\", *pattern));\n         }\n-        fatal_ProcRes(~\"multiple error patterns not found\", ProcRes);\n+        fatal_ProcRes(~\"multiple error patterns not found\", proc_res);\n     }\n }\n \n fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          testfile: &Path,\n-                         ProcRes: &ProcRes) {\n+                         proc_res: &ProcRes) {\n \n     // true if we found the error in question\n     let mut found_flags = vec::from_elem(\n         expected_errors.len(), false);\n \n-    if ProcRes.status.success() {\n+    if proc_res.status.success() {\n         fatal(~\"process did not return an error status\");\n     }\n \n@@ -542,7 +542,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for line in ProcRes.stderr.lines() {\n+    for line in proc_res.stderr.lines() {\n         let mut was_expected = false;\n         for (i, ee) in expected_errors.iter().enumerate() {\n             if !found_flags[i] {\n@@ -566,15 +566,15 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         if !was_expected && is_compiler_error_or_warning(line) {\n             fatal_ProcRes(format!(\"unexpected compiler error or warning: '{}'\",\n                                line),\n-                          ProcRes);\n+                          proc_res);\n         }\n     }\n \n     for (i, &flag) in found_flags.iter().enumerate() {\n         if !flag {\n             let ee = &expected_errors[i];\n             fatal_ProcRes(format!(\"expected {} on line {} not found: {}\",\n-                               ee.kind, ee.line, ee.msg), ProcRes);\n+                               ee.kind, ee.line, ee.msg), proc_res);\n         }\n     }\n }\n@@ -933,7 +933,7 @@ fn error(err: ~str) { println!(\"\\nerror: {}\", err); }\n \n fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n+fn fatal_ProcRes(err: ~str, proc_res: &ProcRes) -> ! {\n     print!(\"\\n\\\n error: {}\\n\\\n command: {}\\n\\\n@@ -946,7 +946,7 @@ stderr:\\n\\\n {}\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, ProcRes.cmdline, ProcRes.stdout, ProcRes.stderr);\n+             err, proc_res.cmdline, proc_res.stdout, proc_res.stderr);\n     fail!();\n }\n \n@@ -1094,15 +1094,15 @@ fn compile_cc_with_clang_and_save_bitcode(config: &config, _props: &TestProps,\n     let bitcodefile = output_base_name(config, testfile).with_extension(\"bc\");\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, \"clang\");\n     let testcc = testfile.with_extension(\"cc\");\n-    let ProcArgs = ProcArgs {\n+    let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: config.clang_path.get_ref().as_str().unwrap().to_owned(),\n         args: ~[~\"-c\",\n                 ~\"-emit-llvm\",\n                 ~\"-o\", bitcodefile.as_str().unwrap().to_owned(),\n                 testcc.as_str().unwrap().to_owned() ]\n     };\n-    compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n }\n \n fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n@@ -1112,14 +1112,14 @@ fn extract_function_from_bitcode(config: &config, _props: &TestProps,\n     let bitcodefile = append_suffix_to_stem(&bitcodefile, suffix);\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-extract\");\n-    let ProcArgs = ProcArgs {\n+    let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n         args: ~[\"-func=\" + fname,\n                 \"-o=\" + extracted_bc.as_str().unwrap(),\n                 bitcodefile.as_str().unwrap().to_owned() ]\n     };\n-    compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n }\n \n fn disassemble_extract(config: &config, _props: &TestProps,\n@@ -1129,13 +1129,13 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n     let extracted_bc = append_suffix_to_stem(&bitcodefile, \"extract\");\n     let extracted_ll = extracted_bc.with_extension(\"ll\");\n     let prog = config.llvm_bin_path.get_ref().join(\"llvm-dis\");\n-    let ProcArgs = ProcArgs {\n+    let proc_args = ProcArgs {\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prog: prog.as_str().unwrap().to_owned(),\n         args: ~[\"-o=\" + extracted_ll.as_str().unwrap(),\n                 extracted_bc.as_str().unwrap().to_owned() ]\n     };\n-    compose_and_run(config, testfile, ProcArgs, ~[], \"\", None)\n+    compose_and_run(config, testfile, proc_args, ~[], \"\", None)\n }\n \n \n@@ -1157,35 +1157,35 @@ fn run_codegen_test(config: &config, props: &TestProps,\n         fatal(~\"missing --clang-path\");\n     }\n \n-    let mut ProcRes = compile_test_and_save_bitcode(config, props, testfile);\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n+    let mut proc_res = compile_test_and_save_bitcode(config, props, testfile);\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n     }\n \n-    ProcRes = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"extracting 'test' function failed\", &ProcRes);\n+    proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"\");\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"extracting 'test' function failed\", &proc_res);\n     }\n \n-    ProcRes = disassemble_extract(config, props, testfile, \"\");\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"disassembling extract failed\", &ProcRes);\n+    proc_res = disassemble_extract(config, props, testfile, \"\");\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"disassembling extract failed\", &proc_res);\n     }\n \n \n-    let mut ProcRes = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n+    let mut proc_res = compile_cc_with_clang_and_save_bitcode(config, props, testfile);\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"compilation failed!\", &proc_res);\n     }\n \n-    ProcRes = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"extracting 'test' function failed\", &ProcRes);\n+    proc_res = extract_function_from_bitcode(config, props, \"test\", testfile, \"clang\");\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"extracting 'test' function failed\", &proc_res);\n     }\n \n-    ProcRes = disassemble_extract(config, props, testfile, \"clang\");\n-    if !ProcRes.status.success() {\n-        fatal_ProcRes(~\"disassembling extract failed\", &ProcRes);\n+    proc_res = disassemble_extract(config, props, testfile, \"clang\");\n+    if !proc_res.status.success() {\n+        fatal_ProcRes(~\"disassembling extract failed\", &proc_res);\n     }\n \n     let base = output_base_name(config, testfile);"}, {"sha": "ea8720751d8b0f1c6bb4eabf0ad6bf4694096b05", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -266,14 +266,14 @@ impl Mul<BigUint, BigUint> for BigUint {\n         //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n         //   a0*b0\n         let half_len = cmp::max(s_len, o_len) / 2;\n-        let (sHi, sLo) = cut_at(self,  half_len);\n-        let (oHi, oLo) = cut_at(other, half_len);\n+        let (s_hi, s_lo) = cut_at(self,  half_len);\n+        let (o_hi, o_lo) = cut_at(other, half_len);\n \n-        let ll = sLo * oLo;\n-        let hh = sHi * oHi;\n+        let ll = s_lo * o_lo;\n+        let hh = s_hi * o_hi;\n         let mm = {\n-            let (s1, n1) = sub_sign(sHi, sLo);\n-            let (s2, n2) = sub_sign(oHi, oLo);\n+            let (s1, n1) = sub_sign(s_hi, s_lo);\n+            let (s2, n2) = sub_sign(o_hi, o_lo);\n             match (s1, s2) {\n                 (Equal, _) | (_, Equal) => hh + ll,\n                 (Less, Greater) | (Greater, Less) => hh + ll + (n1 * n2),\n@@ -1778,10 +1778,10 @@ mod biguint_tests {\n     #[test]\n     fn test_add() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(a + b == c);\n             assert!(b + a == c);\n@@ -1791,10 +1791,10 @@ mod biguint_tests {\n     #[test]\n     fn test_sub() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(c - a == b);\n             assert!(c - b == a);\n@@ -1842,21 +1842,21 @@ mod biguint_tests {\n     #[test]\n     fn test_mul() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             assert!(a * b == c);\n             assert!(b * a == c);\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-            let d = BigUint::from_slice(dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n+            let d = BigUint::from_slice(d_vec);\n \n             assert!(a == b * c + d);\n             assert!(a == c * b + d);\n@@ -1866,10 +1866,10 @@ mod biguint_tests {\n     #[test]\n     fn test_div_rem() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n \n             if !a.is_zero() {\n                 assert_eq!(c.div_rem(&a), (b.clone(), Zero::zero()));\n@@ -1880,11 +1880,11 @@ mod biguint_tests {\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigUint::from_slice(aVec);\n-            let b = BigUint::from_slice(bVec);\n-            let c = BigUint::from_slice(cVec);\n-            let d = BigUint::from_slice(dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigUint::from_slice(a_vec);\n+            let b = BigUint::from_slice(b_vec);\n+            let c = BigUint::from_slice(c_vec);\n+            let d = BigUint::from_slice(d_vec);\n \n             if !b.is_zero() { assert!(a.div_rem(&b) == (c, d)); }\n         }\n@@ -2351,10 +2351,10 @@ mod bigint_tests {\n     #[test]\n     fn test_add() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(a + b == c);\n             assert!(b + a == c);\n@@ -2370,10 +2370,10 @@ mod bigint_tests {\n     #[test]\n     fn test_sub() {\n         for elm in sum_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(c - a == b);\n             assert!(c - b == a);\n@@ -2427,10 +2427,10 @@ mod bigint_tests {\n     #[test]\n     fn test_mul() {\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             assert!(a * b == c);\n             assert!(b * a == c);\n@@ -2440,11 +2440,11 @@ mod bigint_tests {\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n-            let d = BigInt::from_slice(Plus, dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n+            let d = BigInt::from_slice(Plus, d_vec);\n \n             assert!(a == b * c + d);\n             assert!(a == c * b + d);\n@@ -2479,21 +2479,21 @@ mod bigint_tests {\n         }\n \n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n-            let d = BigInt::from_slice(Plus, dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n+            let d = BigInt::from_slice(Plus, d_vec);\n \n             if !b.is_zero() {\n                 check(&a, &b, &c, &d);\n@@ -2522,21 +2522,21 @@ mod bigint_tests {\n             check_sub(&a.neg(), &b.neg(), q, &r.neg());\n         }\n         for elm in mul_triples.iter() {\n-            let (aVec, bVec, cVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n+            let (a_vec, b_vec, c_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n \n             if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n         for elm in div_rem_quadruples.iter() {\n-            let (aVec, bVec, cVec, dVec) = *elm;\n-            let a = BigInt::from_slice(Plus, aVec);\n-            let b = BigInt::from_slice(Plus, bVec);\n-            let c = BigInt::from_slice(Plus, cVec);\n-            let d = BigInt::from_slice(Plus, dVec);\n+            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n+            let a = BigInt::from_slice(Plus, a_vec);\n+            let b = BigInt::from_slice(Plus, b_vec);\n+            let c = BigInt::from_slice(Plus, c_vec);\n+            let d = BigInt::from_slice(Plus, d_vec);\n \n             if !b.is_zero() {\n                 check(&a, &b, &c, &d);"}, {"sha": "3a1c646144ba51ac4eaac05ba73d2958dbd7ef4d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -68,15 +68,15 @@ pub fn llvm_err(sess: Session, msg: ~str) -> ! {\n \n pub fn WriteOutputFile(\n         sess: Session,\n-        Target: lib::llvm::TargetMachineRef,\n-        PM: lib::llvm::PassManagerRef,\n-        M: ModuleRef,\n-        Output: &Path,\n-        FileType: lib::llvm::FileType) {\n+        target: lib::llvm::TargetMachineRef,\n+        pm: lib::llvm::PassManagerRef,\n+        m: ModuleRef,\n+        output: &Path,\n+        file_type: lib::llvm::FileType) {\n     unsafe {\n-        Output.with_c_str(|Output| {\n+        output.with_c_str(|output| {\n             let result = llvm::LLVMRustWriteOutputFile(\n-                    Target, PM, M, Output, FileType);\n+                    target, pm, m, output, file_type);\n             if !result {\n                 llvm_err(sess, ~\"could not write output\");\n             }\n@@ -138,7 +138,7 @@ pub mod write {\n                 })\n             }\n \n-            let OptLevel = match sess.opts.optimize {\n+            let opt_level = match sess.opts.optimize {\n               session::No => lib::llvm::CodeGenLevelNone,\n               session::Less => lib::llvm::CodeGenLevelLess,\n               session::Default => lib::llvm::CodeGenLevelDefault,\n@@ -152,14 +152,14 @@ pub mod write {\n                              (sess.targ_cfg.os == abi::OsMacos &&\n                               sess.targ_cfg.arch == abi::X86_64);\n \n-            let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|T| {\n-                sess.opts.cg.target_cpu.with_c_str(|CPU| {\n-                    target_feature(&sess).with_c_str(|Features| {\n+            let tm = sess.targ_cfg.target_strs.target_triple.with_c_str(|t| {\n+                sess.opts.cg.target_cpu.with_c_str(|cpu| {\n+                    target_feature(&sess).with_c_str(|features| {\n                         llvm::LLVMRustCreateTargetMachine(\n-                            T, CPU, Features,\n+                            t, cpu, features,\n                             lib::llvm::CodeModelDefault,\n                             lib::llvm::RelocPIC,\n-                            OptLevel,\n+                            opt_level,\n                             true,\n                             use_softfp,\n                             no_fp_elim\n@@ -185,7 +185,7 @@ pub mod write {\n             if !sess.opts.cg.no_prepopulate_passes {\n                 llvm::LLVMRustAddAnalysisPasses(tm, fpm, llmod);\n                 llvm::LLVMRustAddAnalysisPasses(tm, mpm, llmod);\n-                populate_llvm_passes(fpm, mpm, llmod, OptLevel);\n+                populate_llvm_passes(fpm, mpm, llmod, opt_level);\n             }\n \n             for pass in sess.opts.cg.passes.iter() {"}, {"sha": "bea08366db3926356ade8f5d61acc9f4aa2019f7", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -1774,25 +1774,25 @@ pub mod llvm {\n     }\n }\n \n-pub fn SetInstructionCallConv(Instr: ValueRef, CC: CallConv) {\n+pub fn SetInstructionCallConv(instr: ValueRef, cc: CallConv) {\n     unsafe {\n-        llvm::LLVMSetInstructionCallConv(Instr, CC as c_uint);\n+        llvm::LLVMSetInstructionCallConv(instr, cc as c_uint);\n     }\n }\n-pub fn SetFunctionCallConv(Fn: ValueRef, CC: CallConv) {\n+pub fn SetFunctionCallConv(fn_: ValueRef, cc: CallConv) {\n     unsafe {\n-        llvm::LLVMSetFunctionCallConv(Fn, CC as c_uint);\n+        llvm::LLVMSetFunctionCallConv(fn_, cc as c_uint);\n     }\n }\n-pub fn SetLinkage(Global: ValueRef, Link: Linkage) {\n+pub fn SetLinkage(global: ValueRef, link: Linkage) {\n     unsafe {\n-        llvm::LLVMSetLinkage(Global, Link as c_uint);\n+        llvm::LLVMSetLinkage(global, link as c_uint);\n     }\n }\n \n-pub fn SetUnnamedAddr(Global: ValueRef, Unnamed: bool) {\n+pub fn SetUnnamedAddr(global: ValueRef, unnamed: bool) {\n     unsafe {\n-        llvm::LLVMSetUnnamedAddr(Global, Unnamed as Bool);\n+        llvm::LLVMSetUnnamedAddr(global, unnamed as Bool);\n     }\n }\n \n@@ -1802,20 +1802,20 @@ pub fn set_thread_local(global: ValueRef, is_thread_local: bool) {\n     }\n }\n \n-pub fn ConstICmp(Pred: IntPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n+pub fn ConstICmp(pred: IntPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstICmp(Pred as c_ushort, V1, V2)\n+        llvm::LLVMConstICmp(pred as c_ushort, v1, v2)\n     }\n }\n-pub fn ConstFCmp(Pred: RealPredicate, V1: ValueRef, V2: ValueRef) -> ValueRef {\n+pub fn ConstFCmp(pred: RealPredicate, v1: ValueRef, v2: ValueRef) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstFCmp(Pred as c_ushort, V1, V2)\n+        llvm::LLVMConstFCmp(pred as c_ushort, v1, v2)\n     }\n }\n \n-pub fn SetFunctionAttribute(Fn: ValueRef, attr: Attribute) {\n+pub fn SetFunctionAttribute(fn_: ValueRef, attr: Attribute) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(Fn, attr as c_uint)\n+        llvm::LLVMAddFunctionAttr(fn_, attr as c_uint)\n     }\n }\n /* Memory-managed object interface to type handles. */\n@@ -1868,20 +1868,20 @@ impl TypeNames {\n /* Memory-managed interface to target data. */\n \n pub struct target_data_res {\n-    TD: TargetDataRef,\n+    td: TargetDataRef,\n }\n \n impl Drop for target_data_res {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeTargetData(self.TD);\n+            llvm::LLVMDisposeTargetData(self.td);\n         }\n     }\n }\n \n-pub fn target_data_res(TD: TargetDataRef) -> target_data_res {\n+pub fn target_data_res(td: TargetDataRef) -> target_data_res {\n     target_data_res {\n-        TD: TD\n+        td: td\n     }\n }\n \n@@ -1904,20 +1904,20 @@ pub fn mk_target_data(string_rep: &str) -> TargetData {\n /* Memory-managed interface to pass managers. */\n \n pub struct pass_manager_res {\n-    PM: PassManagerRef,\n+    pm: PassManagerRef,\n }\n \n impl Drop for pass_manager_res {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposePassManager(self.PM);\n+            llvm::LLVMDisposePassManager(self.pm);\n         }\n     }\n }\n \n-pub fn pass_manager_res(PM: PassManagerRef) -> pass_manager_res {\n+pub fn pass_manager_res(pm: PassManagerRef) -> pass_manager_res {\n     pass_manager_res {\n-        PM: PM\n+        pm: pm\n     }\n }\n \n@@ -1971,20 +1971,20 @@ impl Drop for ObjectFile {\n /* Memory-managed interface to section iterators. */\n \n pub struct section_iter_res {\n-    SI: SectionIteratorRef,\n+    si: SectionIteratorRef,\n }\n \n impl Drop for section_iter_res {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeSectionIterator(self.SI);\n+            llvm::LLVMDisposeSectionIterator(self.si);\n         }\n     }\n }\n \n-pub fn section_iter_res(SI: SectionIteratorRef) -> section_iter_res {\n+pub fn section_iter_res(si: SectionIteratorRef) -> section_iter_res {\n     section_iter_res {\n-        SI: SI\n+        si: si\n     }\n }\n "}, {"sha": "f8cf376582aab516fcb1adfb570fceb6897f9763", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -80,6 +80,7 @@ pub enum Lint {\n     NonCamelCaseTypes,\n     NonUppercaseStatics,\n     NonUppercasePatternStatics,\n+    UppercaseVariables,\n     UnnecessaryParens,\n     TypeLimits,\n     TypeOverflow,\n@@ -208,7 +209,14 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n          default: warn\n      }),\n \n-    (\"unnecessary_parens\",\n+    (\"uppercase_variables\",\n+     LintSpec {\n+         lint: UppercaseVariables,\n+         desc: \"variable and structure field names should start with a lowercase character\",\n+         default: warn\n+     }),\n+\n+     (\"unnecessary_parens\",\n      LintSpec {\n         lint: UnnecessaryParens,\n         desc: \"`if`, `match`, `while` and `return` do not need parentheses\",\n@@ -1169,6 +1177,47 @@ fn check_pat_non_uppercase_statics(cx: &Context, p: &ast::Pat) {\n     }\n }\n \n+fn check_pat_uppercase_variable(cx: &Context, p: &ast::Pat) {\n+    let def_map = cx.tcx.def_map.borrow();\n+    match &p.node {\n+        &ast::PatIdent(_, ref path, _) => {\n+            match def_map.get().find(&p.id) {\n+                Some(&ast::DefLocal(_, _)) | Some(&ast::DefBinding(_, _)) |\n+                        Some(&ast::DefArg(_, _)) => {\n+                    // last identifier alone is right choice for this lint.\n+                    let ident = path.segments.last().unwrap().identifier;\n+                    let s = token::get_ident(ident);\n+                    if s.get().char_at(0).is_uppercase() {\n+                        cx.span_lint(\n+                            UppercaseVariables,\n+                            path.span,\n+                            \"variable names should start with a lowercase character\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn check_struct_uppercase_variable(cx: &Context, s: &ast::StructDef) {\n+    for sf in s.fields.iter() {\n+        match sf.node {\n+            ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n+                let s = token::get_ident(ident);\n+                if s.get().char_at(0).is_uppercase() {\n+                    cx.span_lint(\n+                        UppercaseVariables,\n+                        sf.span,\n+                        \"structure field names should start with a lowercase character\");\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n fn check_unnecessary_parens_core(cx: &Context, value: &ast::Expr, msg: &str) {\n     match value.node {\n         ast::ExprParen(_) => {\n@@ -1553,6 +1602,7 @@ impl<'a> Visitor<()> for Context<'a> {\n \n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n         check_pat_non_uppercase_statics(self, p);\n+        check_pat_uppercase_variable(self, p);\n         check_unused_mut_pat(self, p);\n \n         visit::walk_pat(self, p, ());\n@@ -1632,6 +1682,8 @@ impl<'a> Visitor<()> for Context<'a> {\n                         g: &ast::Generics,\n                         id: ast::NodeId,\n                         _: ()) {\n+        check_struct_uppercase_variable(self, s);\n+\n         let old_id = self.cur_struct_def_id;\n         self.cur_struct_def_id = id;\n         visit::walk_struct_def(self, s, i, g, id, ());"}, {"sha": "59ef31751ebf36f40145470ad35feecb3530d15c", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -82,12 +82,12 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n \n     debug!(\"Asm Constraints: {:?}\", constraints);\n \n-    let numOutputs = outputs.len();\n+    let num_outputs = outputs.len();\n \n     // Depending on how many outputs we have, the return type is different\n-    let output_type = if numOutputs == 0 {\n+    let output_type = if num_outputs == 0 {\n         Type::void()\n-    } else if numOutputs == 1 {\n+    } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n         Type::struct_(output_types, false)\n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     });\n \n     // Again, based on how many outputs we have\n-    if numOutputs == 1 {\n+    if num_outputs == 1 {\n         Store(bcx, r, *outputs.get(0));\n     } else {\n         for (i, o) in outputs.iter().enumerate() {"}, {"sha": "f838bcf9c5ec25406784650ca8e50e3c76ef9581", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -1853,7 +1853,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                 llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llfn, buf)\n             }\n         });\n-        let bld = ccx.builder.B;\n+        let bld = ccx.builder.b;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n "}, {"sha": "d208394402cf34ab81de8fabdfb78b2980954eeb", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 266, "deletions": 266, "changes": 532, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -54,64 +54,64 @@ pub fn RetVoid(cx: &Block) {\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: &Block, V: ValueRef) {\n+pub fn Ret(cx: &Block, v: ValueRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n-    B(cx).ret(V);\n+    B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: &Block, RetVals: &[ValueRef]) {\n+pub fn AggregateRet(cx: &Block, ret_vals: &[ValueRef]) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n-    B(cx).aggregate_ret(RetVals);\n+    B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: &Block, Dest: BasicBlockRef) {\n+pub fn Br(cx: &Block, dest: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n-    B(cx).br(Dest);\n+    B(cx).br(dest);\n }\n \n pub fn CondBr(cx: &Block,\n-              If: ValueRef,\n-              Then: BasicBlockRef,\n-              Else: BasicBlockRef) {\n+              if_: ValueRef,\n+              then: BasicBlockRef,\n+              else_: BasicBlockRef) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n-    B(cx).cond_br(If, Then, Else);\n+    B(cx).cond_br(if_, then, else_);\n }\n \n-pub fn Switch(cx: &Block, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+pub fn Switch(cx: &Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n     -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n+    if cx.unreachable.get() { return _Undef(v); }\n     check_not_terminated(cx);\n     terminate(cx, \"Switch\");\n-    B(cx).switch(V, Else, NumCases)\n+    B(cx).switch(v, else_, num_cases)\n }\n \n-pub fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n+pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     unsafe {\n-        if llvm::LLVMIsUndef(S) == lib::llvm::True { return; }\n-        llvm::LLVMAddCase(S, OnVal, Dest);\n+        if llvm::LLVMIsUndef(s) == lib::llvm::True { return; }\n+        llvm::LLVMAddCase(s, on_val, dest);\n     }\n }\n \n-pub fn IndirectBr(cx: &Block, Addr: ValueRef, NumDests: uint) {\n+pub fn IndirectBr(cx: &Block, addr: ValueRef, num_dests: uint) {\n     if cx.unreachable.get() { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n-    B(cx).indirect_br(Addr, NumDests);\n+    B(cx).indirect_br(addr, num_dests);\n }\n \n pub fn Invoke(cx: &Block,\n-              Fn: ValueRef,\n-              Args: &[ValueRef],\n-              Then: BasicBlockRef,\n-              Catch: BasicBlockRef,\n+              fn_: ValueRef,\n+              args: &[ValueRef],\n+              then: BasicBlockRef,\n+              catch: BasicBlockRef,\n               attributes: &[(uint, lib::llvm::Attribute)])\n               -> ValueRef {\n     if cx.unreachable.get() {\n@@ -120,9 +120,9 @@ pub fn Invoke(cx: &Block,\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke({} with arguments ({}))\",\n-           cx.val_to_str(Fn),\n-           Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n-    B(cx).invoke(Fn, Args, Then, Catch, attributes)\n+           cx.val_to_str(fn_),\n+           args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n+    B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n pub fn Unreachable(cx: &Block) {\n@@ -142,242 +142,242 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).add(LHS, RHS)\n+pub fn Add(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nswadd(LHS, RHS)\n+pub fn NSWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nuwadd(LHS, RHS)\n+pub fn NUWAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).fadd(LHS, RHS)\n+pub fn FAdd(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).sub(LHS, RHS)\n+pub fn Sub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nswsub(LHS, RHS)\n+pub fn NSWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nuwsub(LHS, RHS)\n+pub fn NUWSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).fsub(LHS, RHS)\n+pub fn FSub(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).mul(LHS, RHS)\n+pub fn Mul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nswmul(LHS, RHS)\n+pub fn NSWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).nuwmul(LHS, RHS)\n+pub fn NUWMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).fmul(LHS, RHS)\n+pub fn FMul(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).udiv(LHS, RHS)\n+pub fn UDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).sdiv(LHS, RHS)\n+pub fn SDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).exactsdiv(LHS, RHS)\n+pub fn ExactSDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).fdiv(LHS, RHS)\n+pub fn FDiv(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).urem(LHS, RHS)\n+pub fn URem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).srem(LHS, RHS)\n+pub fn SRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).frem(LHS, RHS)\n+pub fn FRem(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).shl(LHS, RHS)\n+pub fn Shl(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).lshr(LHS, RHS)\n+pub fn LShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).ashr(LHS, RHS)\n+pub fn AShr(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).and(LHS, RHS)\n+pub fn And(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).or(LHS, RHS)\n+pub fn Or(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).xor(LHS, RHS)\n+pub fn Xor(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: &Block, Op: Opcode, LHS: ValueRef, RHS: ValueRef)\n+pub fn BinOp(cx: &Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n           -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(LHS); }\n-    B(cx).binop(Op, LHS, RHS)\n+    if cx.unreachable.get() { return _Undef(lhs); }\n+    B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n-    B(cx).neg(V)\n+pub fn Neg(cx: &Block, v: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(v); }\n+    B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n-    B(cx).nswneg(V)\n+pub fn NSWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(v); }\n+    B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n-    B(cx).nuwneg(V)\n+pub fn NUWNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(v); }\n+    B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n-    B(cx).fneg(V)\n+pub fn FNeg(cx: &Block, v: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(v); }\n+    B(cx).fneg(v)\n }\n \n-pub fn Not(cx: &Block, V: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(V); }\n-    B(cx).not(V)\n+pub fn Not(cx: &Block, v: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(v); }\n+    B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: &Block, Ty: Type) -> ValueRef {\n+pub fn Malloc(cx: &Block, ty: Type) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        B(cx).malloc(Ty)\n+        B(cx).malloc(ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        B(cx).array_malloc(Ty, Val)\n+        B(cx).array_malloc(ty, val)\n     }\n }\n \n-pub fn Alloca(cx: &Block, Ty: Type, name: &str) -> ValueRef {\n+pub fn Alloca(cx: &Block, ty: Type, name: &str) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        AllocaFcx(cx.fcx, Ty, name)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n+        AllocaFcx(cx.fcx, ty, name)\n     }\n }\n \n-pub fn AllocaFcx(fcx: &FunctionContext, Ty: Type, name: &str) -> ValueRef {\n+pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     let b = fcx.ccx.builder();\n     b.position_before(fcx.alloca_insert_pt.get().unwrap());\n-    b.alloca(Ty, name)\n+    b.alloca(ty, name)\n }\n \n-pub fn ArrayAlloca(cx: &Block, Ty: Type, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: &Block, ty: Type, val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n-        b.array_alloca(Ty, Val)\n+        b.array_alloca(ty, val)\n     }\n }\n \n-pub fn Free(cx: &Block, PointerVal: ValueRef) {\n+pub fn Free(cx: &Block, pointer_val: ValueRef) {\n     if cx.unreachable.get() { return; }\n-    B(cx).free(PointerVal)\n+    B(cx).free(pointer_val)\n }\n \n-pub fn Load(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n+pub fn Load(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n-            let ty = val_ty(PointerVal);\n+            let ty = val_ty(pointer_val);\n             let eltty = if ty.kind() == lib::llvm::Array {\n                 ty.element_type()\n             } else {\n                 ccx.int_type\n             };\n             return llvm::LLVMGetUndef(eltty.to_ref());\n         }\n-        B(cx).load(PointerVal)\n+        B(cx).load(pointer_val)\n     }\n }\n \n-pub fn VolatileLoad(cx: &Block, PointerVal: ValueRef) -> ValueRef {\n+pub fn VolatileLoad(cx: &Block, pointer_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).volatile_load(PointerVal)\n+        B(cx).volatile_load(pointer_val)\n     }\n }\n \n-pub fn AtomicLoad(cx: &Block, PointerVal: ValueRef, order: AtomicOrdering) -> ValueRef {\n+pub fn AtomicLoad(cx: &Block, pointer_val: ValueRef, order: AtomicOrdering) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(ccx.int_type.to_ref());\n         }\n-        B(cx).atomic_load(PointerVal, order)\n+        B(cx).atomic_load(pointer_val, order)\n     }\n }\n \n \n-pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n+pub fn LoadRangeAssert(cx: &Block, pointer_val: ValueRef, lo: c_ulonglong,\n                        hi: c_ulonglong, signed: lib::llvm::Bool) -> ValueRef {\n     if cx.unreachable.get() {\n         let ccx = cx.fcx.ccx;\n-        let ty = val_ty(PointerVal);\n+        let ty = val_ty(pointer_val);\n         let eltty = if ty.kind() == lib::llvm::Array {\n             ty.element_type()\n         } else {\n@@ -387,29 +387,29 @@ pub fn LoadRangeAssert(cx: &Block, PointerVal: ValueRef, lo: c_ulonglong,\n             llvm::LLVMGetUndef(eltty.to_ref())\n         }\n     } else {\n-        B(cx).load_range_assert(PointerVal, lo, hi, signed)\n+        B(cx).load_range_assert(pointer_val, lo, hi, signed)\n     }\n }\n \n-pub fn Store(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn Store(cx: &Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n-    B(cx).store(Val, Ptr)\n+    B(cx).store(val, ptr)\n }\n \n-pub fn VolatileStore(cx: &Block, Val: ValueRef, Ptr: ValueRef) {\n+pub fn VolatileStore(cx: &Block, val: ValueRef, ptr: ValueRef) {\n     if cx.unreachable.get() { return; }\n-    B(cx).volatile_store(Val, Ptr)\n+    B(cx).volatile_store(val, ptr)\n }\n \n-pub fn AtomicStore(cx: &Block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrdering) {\n+pub fn AtomicStore(cx: &Block, val: ValueRef, ptr: ValueRef, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n-    B(cx).atomic_store(Val, Ptr, order)\n+    B(cx).atomic_store(val, ptr, order)\n }\n \n-pub fn GEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        B(cx).gep(Pointer, Indices)\n+        B(cx).gep(pointer, indices)\n     }\n }\n \n@@ -423,199 +423,199 @@ pub fn GEPi(cx: &Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n     }\n }\n \n-pub fn InBoundsGEP(cx: &Block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n+pub fn InBoundsGEP(cx: &Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        B(cx).inbounds_gep(Pointer, Indices)\n+        B(cx).inbounds_gep(pointer, indices)\n     }\n }\n \n-pub fn StructGEP(cx: &Block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: &Block, pointer: ValueRef, idx: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n-        B(cx).struct_gep(Pointer, Idx)\n+        B(cx).struct_gep(pointer, idx)\n     }\n }\n \n-pub fn GlobalString(cx: &Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalString(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        B(cx).global_string(_Str)\n+        B(cx).global_string(_str)\n     }\n }\n \n-pub fn GlobalStringPtr(cx: &Block, _Str: *c_char) -> ValueRef {\n+pub fn GlobalStringPtr(cx: &Block, _str: *c_char) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n-        B(cx).global_string_ptr(_Str)\n+        B(cx).global_string_ptr(_str)\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn Trunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).trunc(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).trunc(val, dest_ty)\n     }\n }\n \n-pub fn ZExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).zext(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).zext(val, dest_ty)\n     }\n }\n \n-pub fn SExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).sext(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).sext(val, dest_ty)\n     }\n }\n \n-pub fn FPToUI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToUI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).fptoui(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).fptoui(val, dest_ty)\n     }\n }\n \n-pub fn FPToSI(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPToSI(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).fptosi(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).fptosi(val, dest_ty)\n     }\n }\n \n-pub fn UIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn UIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).uitofp(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).uitofp(val, dest_ty)\n     }\n }\n \n-pub fn SIToFP(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SIToFP(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).sitofp(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).sitofp(val, dest_ty)\n     }\n }\n \n-pub fn FPTrunc(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPTrunc(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).fptrunc(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).fptrunc(val, dest_ty)\n     }\n }\n \n-pub fn FPExt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPExt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).fpext(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).fpext(val, dest_ty)\n     }\n }\n \n-pub fn PtrToInt(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PtrToInt(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).ptrtoint(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).ptrtoint(val, dest_ty)\n     }\n }\n \n-pub fn IntToPtr(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntToPtr(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).inttoptr(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).inttoptr(val, dest_ty)\n     }\n }\n \n-pub fn BitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn BitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).bitcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).bitcast(val, dest_ty)\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).zext_or_bitcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).zext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn SExtOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn SExtOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).sext_or_bitcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).sext_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn TruncOrBitCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn TruncOrBitCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).trunc_or_bitcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).trunc_or_bitcast(val, dest_ty)\n     }\n }\n \n-pub fn Cast(cx: &Block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n+pub fn Cast(cx: &Block, op: Opcode, val: ValueRef, dest_ty: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).cast(Op, Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).cast(op, val, dest_ty)\n     }\n }\n \n-pub fn PointerCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn PointerCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).pointercast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).pointercast(val, dest_ty)\n     }\n }\n \n-pub fn IntCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn IntCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).intcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).intcast(val, dest_ty)\n     }\n }\n \n-pub fn FPCast(cx: &Block, Val: ValueRef, DestTy: Type) -> ValueRef {\n+pub fn FPCast(cx: &Block, val: ValueRef, dest_ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n-        B(cx).fpcast(Val, DestTy)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(dest_ty.to_ref()); }\n+        B(cx).fpcast(val, dest_ty)\n     }\n }\n \n \n /* Comparisons */\n-pub fn ICmp(cx: &Block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn ICmp(cx: &Block, op: IntPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        B(cx).icmp(Op, LHS, RHS)\n+        B(cx).icmp(op, lhs, rhs)\n     }\n }\n \n-pub fn FCmp(cx: &Block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n+pub fn FCmp(cx: &Block, op: RealPredicate, lhs: ValueRef, rhs: ValueRef)\n      -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        B(cx).fcmp(Op, LHS, RHS)\n+        B(cx).fcmp(op, lhs, rhs)\n     }\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: &Block, Ty: Type) -> ValueRef {\n+pub fn EmptyPhi(cx: &Block, ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        B(cx).empty_phi(Ty)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n+        B(cx).empty_phi(ty)\n     }\n }\n \n-pub fn Phi(cx: &Block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n+pub fn Phi(cx: &Block, ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        B(cx).phi(Ty, vals, bbs)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n+        B(cx).phi(ty, vals, bbs)\n     }\n }\n \n@@ -626,10 +626,10 @@ pub fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     }\n }\n \n-pub fn _UndefReturn(cx: &Block, Fn: ValueRef) -> ValueRef {\n+pub fn _UndefReturn(cx: &Block, fn_: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n-        let ty = val_ty(Fn);\n+        let ty = val_ty(fn_);\n         let retty = if ty.kind() == lib::llvm::Integer {\n             ty.return_type()\n         } else {\n@@ -655,98 +655,98 @@ pub fn InlineAsmCall(cx: &Block, asm: *c_char, cons: *c_char,\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: &Block, Fn: ValueRef, Args: &[ValueRef],\n+pub fn Call(cx: &Block, fn_: ValueRef, args: &[ValueRef],\n             attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n-    B(cx).call(Fn, Args, attributes)\n+    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+    B(cx).call(fn_, args, attributes)\n }\n \n-pub fn CallWithConv(cx: &Block, Fn: ValueRef, Args: &[ValueRef], Conv: CallConv,\n+pub fn CallWithConv(cx: &Block, fn_: ValueRef, args: &[ValueRef], conv: CallConv,\n                     attributes: &[(uint, lib::llvm::Attribute)]) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, Fn); }\n-    B(cx).call_with_conv(Fn, Args, Conv, attributes)\n+    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+    B(cx).call_with_conv(fn_, args, conv, attributes)\n }\n \n pub fn AtomicFence(cx: &Block, order: AtomicOrdering) {\n     if cx.unreachable.get() { return; }\n     B(cx).atomic_fence(order)\n }\n \n-pub fn Select(cx: &Block, If: ValueRef, Then: ValueRef, Else: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(Then); }\n-    B(cx).select(If, Then, Else)\n+pub fn Select(cx: &Block, if_: ValueRef, then: ValueRef, else_: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return _Undef(then); }\n+    B(cx).select(if_, then, else_)\n }\n \n-pub fn VAArg(cx: &Block, list: ValueRef, Ty: Type) -> ValueRef {\n+pub fn VAArg(cx: &Block, list: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable.get() { return llvm::LLVMGetUndef(Ty.to_ref()); }\n-        B(cx).va_arg(list, Ty)\n+        if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.to_ref()); }\n+        B(cx).va_arg(list, ty)\n     }\n }\n \n-pub fn ExtractElement(cx: &Block, VecVal: ValueRef, Index: ValueRef) -> ValueRef {\n+pub fn ExtractElement(cx: &Block, vec_val: ValueRef, index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).extract_element(VecVal, Index)\n+        B(cx).extract_element(vec_val, index)\n     }\n }\n \n-pub fn InsertElement(cx: &Block, VecVal: ValueRef, EltVal: ValueRef,\n-                     Index: ValueRef) -> ValueRef {\n+pub fn InsertElement(cx: &Block, vec_val: ValueRef, elt_val: ValueRef,\n+                     index: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).insert_element(VecVal, EltVal, Index)\n+        B(cx).insert_element(vec_val, elt_val, index)\n     }\n }\n \n-pub fn ShuffleVector(cx: &Block, V1: ValueRef, V2: ValueRef,\n-                     Mask: ValueRef) -> ValueRef {\n+pub fn ShuffleVector(cx: &Block, v1: ValueRef, v2: ValueRef,\n+                     mask: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).shuffle_vector(V1, V2, Mask)\n+        B(cx).shuffle_vector(v1, v2, mask)\n     }\n }\n \n-pub fn VectorSplat(cx: &Block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: &Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).vector_splat(NumElts, EltVal)\n+        B(cx).vector_splat(num_elts, elt_val)\n     }\n }\n \n-pub fn ExtractValue(cx: &Block, AggVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: &Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).extract_value(AggVal, Index)\n+        B(cx).extract_value(agg_val, index)\n     }\n }\n \n-pub fn InsertValue(cx: &Block, AggVal: ValueRef, EltVal: ValueRef, Index: uint) -> ValueRef {\n+pub fn InsertValue(cx: &Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n-        B(cx).insert_value(AggVal, EltVal, Index)\n+        B(cx).insert_value(agg_val, elt_val, index)\n     }\n }\n \n-pub fn IsNull(cx: &Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        B(cx).is_null(Val)\n+        B(cx).is_null(val)\n     }\n }\n \n-pub fn IsNotNull(cx: &Block, Val: ValueRef) -> ValueRef {\n+pub fn IsNotNull(cx: &Block, val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n-        B(cx).is_not_null(Val)\n+        B(cx).is_not_null(val)\n     }\n }\n \n-pub fn PtrDiff(cx: &Block, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+pub fn PtrDiff(cx: &Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     unsafe {\n         let ccx = cx.fcx.ccx;\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ccx.int_type.to_ref()); }\n-        B(cx).ptrdiff(LHS, RHS)\n+        B(cx).ptrdiff(lhs, rhs)\n     }\n }\n \n@@ -755,21 +755,21 @@ pub fn Trap(cx: &Block) {\n     B(cx).trap();\n }\n \n-pub fn LandingPad(cx: &Block, Ty: Type, PersFn: ValueRef,\n-                  NumClauses: uint) -> ValueRef {\n+pub fn LandingPad(cx: &Block, ty: Type, pers_fn: ValueRef,\n+                  num_clauses: uint) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable.get());\n-    B(cx).landing_pad(Ty, PersFn, NumClauses)\n+    B(cx).landing_pad(ty, pers_fn, num_clauses)\n }\n \n-pub fn SetCleanup(cx: &Block, LandingPad: ValueRef) {\n-    B(cx).set_cleanup(LandingPad)\n+pub fn SetCleanup(cx: &Block, landing_pad: ValueRef) {\n+    B(cx).set_cleanup(landing_pad)\n }\n \n-pub fn Resume(cx: &Block, Exn: ValueRef) -> ValueRef {\n+pub fn Resume(cx: &Block, exn: ValueRef) -> ValueRef {\n     check_not_terminated(cx);\n     terminate(cx, \"Resume\");\n-    B(cx).resume(Exn)\n+    B(cx).resume(exn)\n }\n \n // Atomic Operations"}, {"sha": "92f2ffa08ecb200f980d78a6a09a99c0bb826746", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -36,7 +36,7 @@ pub fn noname() -> *c_char {\n impl<'a> Builder<'a> {\n     pub fn new(ccx: &'a CrateContext) -> Builder<'a> {\n         Builder {\n-            llbuilder: ccx.builder.B,\n+            llbuilder: ccx.builder.b,\n             ccx: ccx,\n         }\n     }\n@@ -362,37 +362,37 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn neg(&self, V: ValueRef) -> ValueRef {\n+    pub fn neg(&self, v: ValueRef) -> ValueRef {\n         self.count_insn(\"neg\");\n         unsafe {\n-            llvm::LLVMBuildNeg(self.llbuilder, V, noname())\n+            llvm::LLVMBuildNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nswneg(&self, V: ValueRef) -> ValueRef {\n+    pub fn nswneg(&self, v: ValueRef) -> ValueRef {\n         self.count_insn(\"nswneg\");\n         unsafe {\n-            llvm::LLVMBuildNSWNeg(self.llbuilder, V, noname())\n+            llvm::LLVMBuildNSWNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn nuwneg(&self, V: ValueRef) -> ValueRef {\n+    pub fn nuwneg(&self, v: ValueRef) -> ValueRef {\n         self.count_insn(\"nuwneg\");\n         unsafe {\n-            llvm::LLVMBuildNUWNeg(self.llbuilder, V, noname())\n+            llvm::LLVMBuildNUWNeg(self.llbuilder, v, noname())\n         }\n     }\n-    pub fn fneg(&self, V: ValueRef) -> ValueRef {\n+    pub fn fneg(&self, v: ValueRef) -> ValueRef {\n         self.count_insn(\"fneg\");\n         unsafe {\n-            llvm::LLVMBuildFNeg(self.llbuilder, V, noname())\n+            llvm::LLVMBuildFNeg(self.llbuilder, v, noname())\n         }\n     }\n \n-    pub fn not(&self, V: ValueRef) -> ValueRef {\n+    pub fn not(&self, v: ValueRef) -> ValueRef {\n         self.count_insn(\"not\");\n         unsafe {\n-            llvm::LLVMBuildNot(self.llbuilder, V, noname())\n+            llvm::LLVMBuildNot(self.llbuilder, v, noname())\n         }\n     }\n \n@@ -561,17 +561,17 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn global_string(&self, _Str: *c_char) -> ValueRef {\n+    pub fn global_string(&self, _str: *c_char) -> ValueRef {\n         self.count_insn(\"globalstring\");\n         unsafe {\n-            llvm::LLVMBuildGlobalString(self.llbuilder, _Str, noname())\n+            llvm::LLVMBuildGlobalString(self.llbuilder, _str, noname())\n         }\n     }\n \n-    pub fn global_string_ptr(&self, _Str: *c_char) -> ValueRef {\n+    pub fn global_string_ptr(&self, _str: *c_char) -> ValueRef {\n         self.count_insn(\"globalstringptr\");\n         unsafe {\n-            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _Str, noname())\n+            llvm::LLVMBuildGlobalStringPtr(self.llbuilder, _str, noname())\n         }\n     }\n \n@@ -857,9 +857,9 @@ impl<'a> Builder<'a> {\n     pub fn vector_splat(&self, num_elts: uint, elt: ValueRef) -> ValueRef {\n         unsafe {\n             let elt_ty = val_ty(elt);\n-            let Undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n-            let vec = self.insert_element(Undef, elt, C_i32(0));\n-            self.shuffle_vector(vec, Undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n+            let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n+            let vec = self.insert_element(undef, elt, C_i32(0));\n+            self.shuffle_vector(vec, undef, C_null(Type::vector(&Type::i32(), num_elts as u64)))\n         }\n     }\n \n@@ -902,17 +902,17 @@ impl<'a> Builder<'a> {\n \n     pub fn trap(&self) {\n         unsafe {\n-            let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n-            let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n-            let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-            let T: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n-                llvm::LLVMGetNamedFunction(M, buf)\n+            let bb: BasicBlockRef = llvm::LLVMGetInsertBlock(self.llbuilder);\n+            let fn_: ValueRef = llvm::LLVMGetBasicBlockParent(bb);\n+            let m: ModuleRef = llvm::LLVMGetGlobalParent(fn_);\n+            let t: ValueRef = \"llvm.trap\".with_c_str(|buf| {\n+                llvm::LLVMGetNamedFunction(m, buf)\n             });\n-            assert!((T as int != 0));\n+            assert!((t as int != 0));\n             let args: &[ValueRef] = [];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n-                self.llbuilder, T, args.as_ptr(), args.len() as c_uint, noname());\n+                self.llbuilder, t, args.as_ptr(), args.len() as c_uint, noname());\n         }\n     }\n "}, {"sha": "de36074d2e690ce94da4d59ecb01f2e0be3ae073", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -164,20 +164,20 @@ pub struct Stats {\n }\n \n pub struct BuilderRef_res {\n-    B: BuilderRef,\n+    b: BuilderRef,\n }\n \n impl Drop for BuilderRef_res {\n     fn drop(&mut self) {\n         unsafe {\n-            llvm::LLVMDisposeBuilder(self.B);\n+            llvm::LLVMDisposeBuilder(self.b);\n         }\n     }\n }\n \n-pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n+pub fn BuilderRef_res(b: BuilderRef) -> BuilderRef_res {\n     BuilderRef_res {\n-        B: B\n+        b: b\n     }\n }\n \n@@ -654,9 +654,9 @@ pub fn C_struct(elts: &[ValueRef], packed: bool) -> ValueRef {\n     }\n }\n \n-pub fn C_named_struct(T: Type, elts: &[ValueRef]) -> ValueRef {\n+pub fn C_named_struct(t: Type, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        llvm::LLVMConstNamedStruct(T.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n+        llvm::LLVMConstNamedStruct(t.to_ref(), elts.as_ptr(), elts.len() as c_uint)\n     }\n }\n "}, {"sha": "55d44e00bae462eafd8ab6baab859c59c4e6f727", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -302,8 +302,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                          is_local: bool) -> (ValueRef, bool) {\n     let map_list = |exprs: &[@ast::Expr]| {\n         exprs.iter().map(|&e| const_expr(cx, e, is_local))\n-             .fold((~[], true), |(L, all_inlineable), (val, inlineable)| {\n-                (vec::append_one(L, val), all_inlineable && inlineable)\n+             .fold((~[], true), |(l, all_inlineable), (val, inlineable)| {\n+                (vec::append_one(l, val), all_inlineable && inlineable)\n              })\n     };\n     unsafe {"}, {"sha": "2aab89262234ca41b4e9edf9c07a9d2840ca176f", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -330,17 +330,17 @@ pub fn trans_fail<'a>(\n                   sp: Span,\n                   fail_str: InternedString)\n                   -> &'a Block<'a> {\n-    let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n+    let v_fail_str = C_cstr(bcx.ccx(), fail_str);\n     let _icx = push_ctxt(\"trans_fail_value\");\n     let ccx = bcx.ccx();\n     let sess = bcx.sess();\n     let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-    let V_filename = C_cstr(bcx.ccx(),\n+    let v_filename = C_cstr(bcx.ccx(),\n                             token::intern_and_get_ident(loc.file.name));\n-    let V_line = loc.line as int;\n-    let V_str = PointerCast(bcx, V_fail_str, Type::i8p());\n-    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n-    let args = ~[V_str, V_filename, C_int(ccx, V_line)];\n+    let v_line = loc.line as int;\n+    let v_str = PointerCast(bcx, v_fail_str, Type::i8p());\n+    let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n+    let args = ~[v_str, v_filename, C_int(ccx, v_line)];\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n     let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n     Unreachable(bcx);"}, {"sha": "fef559698abded4fd3c4c33fc5ff5afb75f9c801", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -2171,7 +2171,7 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n     };\n \n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(cx.builder.B, metadata_node);\n+        llvm::LLVMSetCurrentDebugLocation(cx.builder.b, metadata_node);\n     }\n \n     debug_context(cx).current_debug_location.set(debug_location);"}, {"sha": "f836a1312c5cca4b7136987c289ccea619e1497a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -499,7 +499,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n             \"the block\".with_c_str(\n                 |s| llvm::LLVMAppendBasicBlockInContext(ccx.llcx, llwrapfn, s));\n \n-        let builder = ccx.builder.B;\n+        let builder = ccx.builder.b;\n         llvm::LLVMPositionBuilderAtEnd(builder, the_block);\n \n         // Array for the arguments we will pass to the rust function."}, {"sha": "2741dc285f99a738ddc9f1f28c4bf6b0e973d3a2", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -269,39 +269,39 @@ pub trait Digest {\n // A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n // functions\n struct Engine256State {\n-    H0: u32,\n-    H1: u32,\n-    H2: u32,\n-    H3: u32,\n-    H4: u32,\n-    H5: u32,\n-    H6: u32,\n-    H7: u32,\n+    h0: u32,\n+    h1: u32,\n+    h2: u32,\n+    h3: u32,\n+    h4: u32,\n+    h5: u32,\n+    h6: u32,\n+    h7: u32,\n }\n \n impl Engine256State {\n     fn new(h: &[u32, ..8]) -> Engine256State {\n         return Engine256State {\n-            H0: h[0],\n-            H1: h[1],\n-            H2: h[2],\n-            H3: h[3],\n-            H4: h[4],\n-            H5: h[5],\n-            H6: h[6],\n-            H7: h[7]\n+            h0: h[0],\n+            h1: h[1],\n+            h2: h[2],\n+            h3: h[3],\n+            h4: h[4],\n+            h5: h[5],\n+            h6: h[6],\n+            h7: h[7]\n         };\n     }\n \n     fn reset(&mut self, h: &[u32, ..8]) {\n-        self.H0 = h[0];\n-        self.H1 = h[1];\n-        self.H2 = h[2];\n-        self.H3 = h[3];\n-        self.H4 = h[4];\n-        self.H5 = h[5];\n-        self.H6 = h[6];\n-        self.H7 = h[7];\n+        self.h0 = h[0];\n+        self.h1 = h[1];\n+        self.h2 = h[2];\n+        self.h3 = h[3];\n+        self.h4 = h[4];\n+        self.h5 = h[5];\n+        self.h6 = h[6];\n+        self.h7 = h[7];\n     }\n \n     fn process_block(&mut self, data: &[u8]) {\n@@ -329,36 +329,36 @@ impl Engine256State {\n             ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n         }\n \n-        let mut a = self.H0;\n-        let mut b = self.H1;\n-        let mut c = self.H2;\n-        let mut d = self.H3;\n-        let mut e = self.H4;\n-        let mut f = self.H5;\n-        let mut g = self.H6;\n-        let mut h = self.H7;\n+        let mut a = self.h0;\n+        let mut b = self.h1;\n+        let mut c = self.h2;\n+        let mut d = self.h3;\n+        let mut e = self.h4;\n+        let mut f = self.h5;\n+        let mut g = self.h6;\n+        let mut h = self.h7;\n \n-        let mut W = [0u32, ..64];\n+        let mut w = [0u32, ..64];\n \n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n         macro_rules! schedule_round( ($t:expr) => (\n-                W[$t] = sigma1(W[$t - 2]) + W[$t - 7] + sigma0(W[$t - 15]) + W[$t - 16];\n+                w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n                 )\n         )\n \n         macro_rules! sha2_round(\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n-                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + W[$t];\n+                    $H += sum1($E) + ch($E, $F, $G) + $K[$t] + w[$t];\n                     $D += $H;\n                     $H += sum0($A) + maj($A, $B, $C);\n                 }\n              )\n         )\n \n-        read_u32v_be(W.mut_slice(0, 16), data);\n+        read_u32v_be(w.mut_slice(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -393,14 +393,14 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        self.H0 += a;\n-        self.H1 += b;\n-        self.H2 += c;\n-        self.H3 += d;\n-        self.H4 += e;\n-        self.H5 += f;\n-        self.H6 += g;\n-        self.H7 += h;\n+        self.h0 += a;\n+        self.h1 += b;\n+        self.h2 += c;\n+        self.h3 += d;\n+        self.h4 += e;\n+        self.h5 += f;\n+        self.h6 += g;\n+        self.h7 += h;\n     }\n }\n \n@@ -494,14 +494,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n-        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n-        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n-        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n-        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n-        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n-        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n-        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.h0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.h1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.h2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.h3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.h4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.h5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.h6);\n+        write_u32_be(out.mut_slice(28, 32), self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "ea9a922f2244f27492a95a3aac887f8154251666", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -199,9 +199,9 @@ impl<'a> FromBase64 for &'a str {\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let optBytes = str::from_utf8_owned(res.unwrap());\n-     *       if optBytes.is_some() {\n-     *         println!(\"decoded from base64: {}\", optBytes.unwrap());\n+     *       let opt_bytes = str::from_utf8_owned(res.unwrap());\n+     *       if opt_bytes.is_some() {\n+     *         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n      *       }\n      *     }\n      * }"}, {"sha": "ad7585d98086ca389529b071e0850a907e4bbc96", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -1672,15 +1672,15 @@ mod tests {\n             ]\"\n         );\n \n-        let longTestList = List(~[\n+        let long_test_list = List(~[\n             Boolean(false),\n             Null,\n             List(~[String(~\"foo\\nbar\"), Number(3.5)])]);\n \n-        assert_eq!(longTestList.to_str(),\n+        assert_eq!(long_test_list.to_str(),\n             ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n         assert_eq!(\n-            longTestList.to_pretty_str(),\n+            long_test_list.to_pretty_str(),\n             ~\"\\\n             [\\n  \\\n                 false,\\n  \\\n@@ -1710,15 +1710,15 @@ mod tests {\n             }\"\n         );\n \n-        let complexObj = mk_object([\n+        let complex_obj = mk_object([\n                 (~\"b\", List(~[\n                     mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n                     mk_object([(~\"d\", String(~\"\"))])\n                 ]))\n             ]);\n \n         assert_eq!(\n-            complexObj.to_str(),\n+            complex_obj.to_str(),\n             ~\"{\\\n                 \\\"b\\\":[\\\n                     {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n@@ -1727,7 +1727,7 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            complexObj.to_pretty_str(),\n+            complex_obj.to_pretty_str(),\n             ~\"\\\n             {\\n  \\\n                 \\\"b\\\": [\\n    \\"}, {"sha": "6c0ae280ed078baef4c1bc631f778fd4d2805f74", "filename": "src/libstd/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fmod.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -181,7 +181,7 @@ macro_rules! impl_hash_tuple(\n     );\n )\n \n-impl_hash_tuple!(A0 A1 A2 A3 A4 A5 A6 A7)\n+impl_hash_tuple!(a0 a1 a2 a3 a4 a5 a6 a7)\n \n impl<'a, S: Writer, T: Hash<S>> Hash<S> for &'a [T] {\n     #[inline]"}, {"sha": "8eaa86ea707db1e8e393480bf255b6137d686709", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -36,7 +36,7 @@ impl UdpSocket {\n     }\n \n     pub fn connect(self, other: SocketAddr) -> UdpStream {\n-        UdpStream { socket: self, connectedTo: other }\n+        UdpStream { socket: self, connected_to: other }\n     }\n \n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n@@ -59,7 +59,7 @@ impl Clone for UdpSocket {\n \n pub struct UdpStream {\n     priv socket: UdpSocket,\n-    priv connectedTo: SocketAddr\n+    priv connected_to: SocketAddr\n }\n \n impl UdpStream {\n@@ -72,7 +72,7 @@ impl UdpStream {\n \n impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        let peer = self.connectedTo;\n+        let peer = self.connected_to;\n         self.as_socket(|sock| {\n             match sock.recvfrom(buf) {\n                 Ok((_nread, src)) if src != peer => Ok(0),\n@@ -85,8 +85,8 @@ impl Reader for UdpStream {\n \n impl Writer for UdpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        let connectedTo = self.connectedTo;\n-        self.as_socket(|sock| sock.sendto(buf, connectedTo))\n+        let connected_to = self.connected_to;\n+        self.as_socket(|sock| sock.sendto(buf, connected_to))\n     }\n }\n "}, {"sha": "0ef8570ce3046471fed66d27f1334ef83c52e42b", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -65,6 +65,7 @@\n #[allow(non_camel_case_types)];\n #[allow(non_uppercase_statics)];\n #[allow(missing_doc)];\n+#[allow(uppercase_variables)];\n \n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code."}, {"sha": "41a106ec887f277918dc503c47de4e38841fa88d", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -213,8 +213,8 @@ mod ziggurat_tables;\n fn ziggurat<R:Rng>(\n             rng: &mut R,\n             symmetric: bool,\n-            X: ziggurat_tables::ZigTable,\n-            F: ziggurat_tables::ZigTable,\n+            x_tab: ziggurat_tables::ZigTable,\n+            f_tab: ziggurat_tables::ZigTable,\n             pdf: 'static |f64| -> f64,\n             zero_case: 'static |&mut R, f64| -> f64)\n             -> f64 {\n@@ -233,19 +233,19 @@ fn ziggurat<R:Rng>(\n         // u is either U(-1, 1) or U(0, 1) depending on if this is a\n         // symmetric distribution or not.\n         let u = if symmetric {2.0 * f - 1.0} else {f};\n-        let x = u * X[i];\n+        let x = u * x_tab[i];\n \n         let test_x = if symmetric {num::abs(x)} else {x};\n \n-        // algebraically equivalent to |u| < X[i+1]/X[i] (or u < X[i+1]/X[i])\n-        if test_x < X[i + 1] {\n+        // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n+        if test_x < x_tab[i + 1] {\n             return x;\n         }\n         if i == 0 {\n             return zero_case(rng, u);\n         }\n         // algebraically equivalent to f1 + DRanU()*(f0 - f1) < 1\n-        if F[i + 1] + (F[i] - F[i + 1]) * rng.gen() < pdf(x) {\n+        if f_tab[i + 1] + (f_tab[i] - f_tab[i + 1]) * rng.gen() < pdf(x) {\n             return x;\n         }\n     }"}, {"sha": "20bce8d20589c0714760eb07ba7c9c6b79740e6a", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -803,19 +803,19 @@ mod test {\n \n     #[test]\n     fn test_sample() {\n-        let MIN_VAL = 1;\n-        let MAX_VAL = 100;\n+        let min_val = 1;\n+        let max_val = 100;\n \n         let mut r = rng();\n-        let vals = range(MIN_VAL, MAX_VAL).to_owned_vec();\n+        let vals = range(min_val, max_val).to_owned_vec();\n         let small_sample = r.sample(vals.iter(), 5);\n         let large_sample = r.sample(vals.iter(), vals.len() + 5);\n \n         assert_eq!(small_sample.len(), 5);\n         assert_eq!(large_sample.len(), vals.len());\n \n         assert!(small_sample.iter().all(|e| {\n-            **e >= MIN_VAL && **e <= MAX_VAL\n+            **e >= min_val && **e <= max_val\n         }));\n     }\n "}, {"sha": "ef9be6ee70c40422f57ebe853608383da5d0b087", "filename": "src/libstd/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -575,9 +575,9 @@ fn canonical_sort(comb: &mut [(char, u8)]) {\n     for i in range(0, len) {\n         let mut swapped = false;\n         for j in range(1, len-i) {\n-            let classA = *comb[j-1].ref1();\n-            let classB = *comb[j].ref1();\n-            if classA != 0 && classB != 0 && classA > classB {\n+            let class_a = *comb[j-1].ref1();\n+            let class_b = *comb[j].ref1();\n+            if class_a != 0 && class_b != 0 && class_a > class_b {\n                 comb.swap(j-1, j);\n                 swapped = true;\n             }\n@@ -3427,8 +3427,8 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let a = ~\"\u0e1b\u0e23\u0e30\u0e40\";\n-        let A = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(a, repl), A);\n+        let a2 = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_eq!(data.replace(a, repl), a2);\n     }\n \n     #[test]\n@@ -3437,8 +3437,8 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let b = ~\"\u0e30\u0e40\";\n-        let B = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(b,   repl), B);\n+        let b2 = ~\"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_eq!(data.replace(b, repl), b2);\n     }\n \n     #[test]\n@@ -3447,8 +3447,8 @@ mod tests {\n         let repl = ~\"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let c = ~\"\u4e2d\u534e\";\n-        let C = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert_eq!(data.replace(c, repl), C);\n+        let c2 = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        assert_eq!(data.replace(c, repl), c2);\n     }\n \n     #[test]"}, {"sha": "34ec4ca28cfaf039628c4c227e9a368983f11548", "filename": "src/libsync/sync/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsync%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsync%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmod.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -217,7 +217,7 @@ impl<'a> Condvar<'a> {\n      * wait() is equivalent to wait_on(0).\n      */\n     pub fn wait_on(&self, condvar_id: uint) {\n-        let mut WaitEnd = None;\n+        let mut wait_end = None;\n         let mut out_of_bounds = None;\n         // Release lock, 'atomically' enqueuing ourselves in so doing.\n         unsafe {\n@@ -230,7 +230,7 @@ impl<'a> Condvar<'a> {\n                     }\n                     // Create waiter nobe, and enqueue ourself to\n                     // be woken up by a signaller.\n-                    WaitEnd = Some(state.blocked[condvar_id].wait_end());\n+                    wait_end = Some(state.blocked[condvar_id].wait_end());\n                 } else {\n                     out_of_bounds = Some(state.blocked.len());\n                 }\n@@ -244,7 +244,7 @@ impl<'a> Condvar<'a> {\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n             (|| {\n-                let _ = WaitEnd.take_unwrap().recv();\n+                let _ = wait_end.take_unwrap().recv();\n             }).finally(|| {\n                 // Reacquire the condvar.\n                 match self.order {"}, {"sha": "0cf13cfaba5a13fe1c2f40f683d0ee78198640ab", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -339,12 +339,12 @@ fn highlight_lines(err: &mut EmitterWriter,\n         for _ in range(0, skip) { s.push_char(' '); }\n         let orig = fm.get_line(*lines.lines.get(0) as int);\n         for pos in range(0u, left-skip) {\n-            let curChar = orig[pos] as char;\n+            let cur_char = orig[pos] as char;\n             // Whenever a tab occurs on the previous line, we insert one on\n             // the error-point-squiggly-line as well (instead of a space).\n             // That way the squiggly line will usually appear in the correct\n             // position.\n-            match curChar {\n+            match cur_char {\n                 '\\t' => s.push_char('\\t'),\n                 _ => s.push_char(' '),\n             };"}, {"sha": "5540b26d9e769608c51f42de65c6e0000a2a556f", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -124,10 +124,10 @@ pub fn buf_str(toks: Vec<Token> , szs: Vec<int> , left: uint, right: uint,\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n-    let mut L = lim;\n+    let mut l = lim;\n     let mut s = ~\"[\";\n-    while i != right && L != 0u {\n-        L -= 1u;\n+    while i != right && l != 0u {\n+        l -= 1u;\n         if i != left {\n             s.push_str(\", \");\n         }\n@@ -427,15 +427,15 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self, x: Token, L: int) -> io::IoResult<()> {\n+    pub fn advance_left(&mut self, x: Token, l: int) -> io::IoResult<()> {\n         debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n-               self.left, L);\n-        if L >= 0 {\n-            let ret = self.print(x.clone(), L);\n+               self.left, l);\n+        if l >= 0 {\n+            let ret = self.print(x.clone(), l);\n             match x {\n               Break(b) => self.left_total += b.blank_space,\n               String(_, len) => {\n-                assert_eq!(len, L); self.left_total += len;\n+                assert_eq!(len, l); self.left_total += len;\n               }\n               _ => ()\n             }\n@@ -510,8 +510,8 @@ impl Printer {\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, x: Token, L: int) -> io::IoResult<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), L,\n+    pub fn print(&mut self, x: Token, l: int) -> io::IoResult<()> {\n+        debug!(\"print {} {} (remaining line space={})\", tok_str(x.clone()), l,\n                self.space);\n         debug!(\"{}\", buf_str(self.token.clone(),\n                              self.size.clone(),\n@@ -520,7 +520,7 @@ impl Printer {\n                              6));\n         match x {\n           Begin(b) => {\n-            if L > self.space {\n+            if l > self.space {\n                 let col = self.margin - self.space + b.offset;\n                 debug!(\"print Begin -> push broken block at col {}\", col);\n                 self.print_stack.push(PrintStackElem {\n@@ -560,7 +560,7 @@ impl Printer {\n                 ret\n               }\n               Broken(Inconsistent) => {\n-                if L > self.space {\n+                if l > self.space {\n                     debug!(\"print Break({}+{}) w/ newline in inconsistent\",\n                            top.offset, b.offset);\n                     let ret = self.print_newline(top.offset + b.offset);\n@@ -578,8 +578,8 @@ impl Printer {\n           }\n           String(s, len) => {\n             debug!(\"print String({})\", s);\n-            assert_eq!(L, len);\n-            // assert!(L <= space);\n+            assert_eq!(l, len);\n+            // assert!(l <= space);\n             self.space -= len;\n             self.print_str(s)\n           }"}, {"sha": "114d5d4fdf042f04471e6adb05c47140c6002237", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/712c630ab6bc67a934311c0e31ead3a46ae1a75f/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=712c630ab6bc67a934311c0e31ead3a46ae1a75f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deny(uppercase_variables)];\n+\n+use std::io::File;\n+use std::io::IoError;\n+\n+struct Something {\n+    X: uint //~ ERROR structure field names should start with a lowercase character\n+}\n+\n+fn test(Xx: uint) { //~ ERROR variable names should start with a lowercase character\n+    println!(\"{}\", Xx);\n+}\n+\n+fn main() {\n+    let Test: uint = 0; //~ ERROR variable names should start with a lowercase character\n+    println!(\"{}\", Test);\n+\n+    let mut f = File::open(&Path::new(\"something.txt\"));\n+    let mut buff = [0u8, ..16];\n+    match f.read(buff) {\n+        Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n+        Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_str()),\n+                        //~^ ERROR variable names should start with a lowercase character\n+    }\n+\n+    test(1);\n+\n+    let _ = Something { X: 0 };\n+}\n+"}]}