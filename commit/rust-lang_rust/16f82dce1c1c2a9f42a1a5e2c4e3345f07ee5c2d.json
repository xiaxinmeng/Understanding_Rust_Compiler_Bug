{"sha": "16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZjgyZGNlMWMxYzJhOWY0MmExYTVlMmM0ZTMzNDVmMDdlZTVjMmQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-07T14:14:00Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-07T15:54:58Z"}, "message": "Clean up trans_arg_expr\n\nAs a preparation for implementing the temporary-move optimization for\nargument passing. The optimization itself isn't in yet, since it\nmysteriously corrupts memory.", "tree": {"sha": "36478e3287c19f6f6b8981b4a1e9ad78cb380af6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36478e3287c19f6f6b8981b4a1e9ad78cb380af6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d", "html_url": "https://github.com/rust-lang/rust/commit/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bdbf74d4703771571fdee1733b7b3d919b5ede8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdbf74d4703771571fdee1733b7b3d919b5ede8", "html_url": "https://github.com/rust-lang/rust/commit/3bdbf74d4703771571fdee1733b7b3d919b5ede8"}], "stats": {"total": 70, "additions": 25, "deletions": 45}, "files": [{"sha": "487f79d661bf9d285656f019ab5208e0338fbf89", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=16f82dce1c1c2a9f42a1a5e2c4e3345f07ee5c2d", "patch": "@@ -5666,64 +5666,44 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n                   &@ast::expr e) -> result {\n-    auto val;\n-    auto bcx = cx;\n-    auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-    if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n-        auto re = trans_expr(bcx, e);\n-        val = re.val;\n-        bcx = re.bcx;\n-    } else if (arg.mode != ty::mo_val) {\n-        let lval_result lv;\n-        if (ty::is_lval(e)) {\n-            lv = trans_lval(bcx, e);\n-        } else {\n-            auto r = trans_expr(bcx, e);\n-            if (type_is_immediate(cx.fcx.lcx.ccx, e_ty)) {\n-                lv = lval_val(r.bcx, r.val);\n-            } else { lv = lval_mem(r.bcx, r.val); }\n-        }\n-        bcx = lv.res.bcx;\n-        if (lv.is_mem) {\n-            val = lv.res.val;\n-        } else {\n-            // Non-mem but we're trying to alias; synthesize an\n-            // alloca, spill to it and pass its address.\n-            val = do_spill(lv.res.bcx, lv.res.val);\n-        }\n-    } else { auto re = trans_expr(bcx, e); val = re.val; bcx = re.bcx; }\n-    auto is_bot = ty::type_is_bot(cx.fcx.lcx.ccx.tcx, e_ty);\n-\n-    // Make a copy here if the type is structural and we're passing by value.\n-    if (arg.mode == ty::mo_val && !is_bot) {\n-        if (ty::type_owns_heap_mem(cx.fcx.lcx.ccx.tcx, e_ty)) {\n-            auto rslt = alloc_ty(bcx, e_ty);\n-            bcx = rslt.bcx;\n-            auto dst = rslt.val;\n-            rslt = copy_val(bcx, INIT, dst, val, e_ty);\n-            bcx = rslt.bcx;\n-            val = dst;\n-        } else {\n-            bcx = copy_ty(bcx, val, e_ty).bcx;\n-        }\n-    }\n-\n+    auto ccx = cx.fcx.lcx.ccx;\n+    auto e_ty = ty::expr_ty(ccx.tcx, e);\n+    auto is_bot = ty::type_is_bot(ccx.tcx, e_ty);\n+    auto lv = trans_lval(cx, e);\n+    auto bcx = lv.res.bcx;\n+    auto val = lv.res.val;\n     if (is_bot) {\n         // For values of type _|_, we generate an\n         // \"undef\" value, as such a value should never\n         // be inspected. It's important for the value\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n-    } else if (ty::type_contains_params(cx.fcx.lcx.ccx.tcx, arg.ty)) {\n+    } else if (arg.mode == ty::mo_val) {\n+        if (ty::type_owns_heap_mem(ccx.tcx, e_ty)) {\n+            auto dst = alloc_ty(bcx, e_ty);\n+            val = dst.val;\n+            bcx = move_val_if_temp(dst.bcx, INIT, val, lv, e_ty).bcx;\n+        } else {\n+            if (lv.is_mem) { val = load_if_immediate(bcx, val, e_ty); }\n+            // FIXME for non-is-mem lvals, we should be able to just drop the\n+            // cleanup. However, this currently leads to a memory-corrupting\n+            // stage2/rustc . Find out why.\n+            bcx = copy_ty(bcx, val, e_ty).bcx;\n+        }\n+    } else if (type_is_immediate(ccx, e_ty) && !lv.is_mem) {\n+        val = do_spill(bcx, val);\n+    }\n+\n+    if (!is_bot && ty::type_contains_params(ccx.tcx, arg.ty)) {\n         auto lldestty = lldestty0;\n         if (arg.mode == ty::mo_val\n-            && ty::type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n+            && ty::type_is_structural(ccx.tcx, e_ty)) {\n             lldestty = T_ptr(lldestty);\n         }\n         val = bcx.build.PointerCast(val, lldestty);\n     }\n     if (arg.mode == ty::mo_val\n-        && ty::type_is_structural(cx.fcx.lcx.ccx.tcx, e_ty)) {\n+        && ty::type_is_structural(ccx.tcx, e_ty)) {\n         // Until here we've been treating structures by pointer;\n         // we are now passing it as an arg, so need to load it.\n         val = bcx.build.Load(val);"}]}