{"sha": "891e1a859b52486936e021235fdc36fbdd9b4100", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MWUxYTg1OWI1MjQ4NjkzNmUwMjEyMzVmZGMzNmZiZGQ5YjQxMDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-18T09:05:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-18T09:05:41Z"}, "message": "Auto merge of #5427 - pmk21:implicit-sat-sub, r=flip1995\n\nAdd lint named implicit_saturating_sub\n\nFixes: #5399\nI've made a basic skeleton of the lint, would love more feedback on how to make it better.\nchangelog: Add lint [`implicit_saturating_sub`]", "tree": {"sha": "fbda13012e306cf624cb423714827091b5b99ecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbda13012e306cf624cb423714827091b5b99ecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/891e1a859b52486936e021235fdc36fbdd9b4100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/891e1a859b52486936e021235fdc36fbdd9b4100", "html_url": "https://github.com/rust-lang/rust/commit/891e1a859b52486936e021235fdc36fbdd9b4100", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/891e1a859b52486936e021235fdc36fbdd9b4100/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c0e4e5b97f05d6f397bf941b16e1e826310a5ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c0e4e5b97f05d6f397bf941b16e1e826310a5ed", "html_url": "https://github.com/rust-lang/rust/commit/1c0e4e5b97f05d6f397bf941b16e1e826310a5ed"}, {"sha": "1c1103561ea3ce6d9ddba97061496a25884ee671", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1103561ea3ce6d9ddba97061496a25884ee671", "html_url": "https://github.com/rust-lang/rust/commit/1c1103561ea3ce6d9ddba97061496a25884ee671"}], "stats": {"total": 739, "additions": 739, "deletions": 0}, "files": [{"sha": "e513787a53a659edc2cbfc0c5241c12dd92c7568", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -1293,6 +1293,7 @@ Released 2018-09-13\n [`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n [`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n [`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n+[`implicit_saturating_sub`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_saturating_sub\n [`imprecise_flops`]: https://rust-lang.github.io/rust-clippy/master/index.html#imprecise_flops\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing"}, {"sha": "155a93de4facfd5aeaef5a3e77397e6bd3c345c1", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -0,0 +1,173 @@\n+use crate::utils::{higher, in_macro, match_qpath, span_lint_and_sugg, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for implicit saturating subtraction.\n+    ///\n+    /// **Why is this bad?** Simplicity and readability. Instead we can easily use an builtin function.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let end: u32 = 10;\n+    /// let start: u32 = 5;\n+    ///\n+    /// let mut i: u32 = end - start;\n+    ///\n+    /// // Bad\n+    /// if i != 0 {\n+    ///     i -= 1;\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let end: u32 = 10;\n+    /// let start: u32 = 5;\n+    ///\n+    /// let mut i: u32 = end - start;\n+    ///\n+    /// // Good\n+    /// i = i.saturating_sub(1);\n+    /// ```\n+    pub IMPLICIT_SATURATING_SUB,\n+    pedantic,\n+    \"Perform saturating subtraction instead of implicitly checking lower bound of data type\"\n+}\n+\n+declare_lint_pass!(ImplicitSaturatingSub => [IMPLICIT_SATURATING_SUB]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitSaturatingSub {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if in_macro(expr.span) {\n+            return;\n+        }\n+        if_chain! {\n+            if let Some((ref cond, ref then, None)) = higher::if_block(&expr);\n+\n+            // Check if the conditional expression is a binary operation\n+            if let ExprKind::Binary(ref cond_op, ref cond_left, ref cond_right) = cond.kind;\n+\n+            // Ensure that the binary operator is >, != and <\n+            if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n+\n+            // Check if the true condition block has only one statement\n+            if let ExprKind::Block(ref block, _) = then.kind;\n+            if block.stmts.len() == 1 && block.expr.is_none();\n+\n+            // Check if assign operation is done\n+            if let StmtKind::Semi(ref e) = block.stmts[0].kind;\n+            if let Some(target) = subtracts_one(cx, e);\n+\n+            // Extracting out the variable name\n+            if let ExprKind::Path(ref assign_path) = target.kind;\n+            if let QPath::Resolved(_, ref ares_path) = assign_path;\n+\n+            then {\n+                // Handle symmetric conditions in the if statement\n+                let (cond_var, cond_num_val) = if SpanlessEq::new(cx).eq_expr(cond_left, target) {\n+                    if BinOpKind::Gt == cond_op.node || BinOpKind::Ne == cond_op.node {\n+                        (cond_left, cond_right)\n+                    } else {\n+                        return;\n+                    }\n+                } else if SpanlessEq::new(cx).eq_expr(cond_right, target) {\n+                    if BinOpKind::Lt == cond_op.node || BinOpKind::Ne == cond_op.node {\n+                        (cond_right, cond_left)\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                };\n+\n+                // Check if the variable in the condition statement is an integer\n+                if !cx.tables.expr_ty(cond_var).is_integral() {\n+                    return;\n+                }\n+\n+                // Get the variable name\n+                let var_name = ares_path.segments[0].ident.name.as_str();\n+                const INT_TYPES: [&str; 5] = [\"i8\", \"i16\", \"i32\", \"i64\", \"i128\"];\n+\n+                match cond_num_val.kind {\n+                    ExprKind::Lit(ref cond_lit) => {\n+                        // Check if the constant is zero\n+                        if let LitKind::Int(0, _) = cond_lit.node {\n+                            if cx.tables.expr_ty(cond_left).is_signed() {\n+                            } else {\n+                                print_lint_and_sugg(cx, &var_name, expr);\n+                            };\n+                        }\n+                    },\n+                    ExprKind::Path(ref cond_num_path) => {\n+                        if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"MIN\"])) {\n+                            print_lint_and_sugg(cx, &var_name, expr);\n+                        };\n+                    },\n+                    ExprKind::Call(ref func, _) => {\n+                        if let ExprKind::Path(ref cond_num_path) = func.kind {\n+                            if INT_TYPES.iter().any(|int_type| match_qpath(cond_num_path, &[int_type, \"min_value\"])) {\n+                                print_lint_and_sugg(cx, &var_name, expr);\n+                            }\n+                        };\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn subtracts_one<'a>(cx: &LateContext<'_, '_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n+    match expr.kind {\n+        ExprKind::AssignOp(ref op1, ref target, ref value) => {\n+            if_chain! {\n+                if BinOpKind::Sub == op1.node;\n+                // Check if literal being subtracted is one\n+                if let ExprKind::Lit(ref lit1) = value.kind;\n+                if let LitKind::Int(1, _) = lit1.node;\n+                then {\n+                    Some(target)\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        ExprKind::Assign(ref target, ref value, _) => {\n+            if_chain! {\n+                if let ExprKind::Binary(ref op1, ref left1, ref right1) = value.kind;\n+                if BinOpKind::Sub == op1.node;\n+\n+                if SpanlessEq::new(cx).eq_expr(left1, target);\n+\n+                if let ExprKind::Lit(ref lit1) = right1.kind;\n+                if let LitKind::Int(1, _) = lit1.node;\n+                then {\n+                    Some(target)\n+                } else {\n+                    None\n+                }\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn print_lint_and_sugg(cx: &LateContext<'_, '_>, var_name: &str, expr: &Expr<'_>) {\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_SATURATING_SUB,\n+        expr.span,\n+        \"Implicitly performing saturating subtraction\",\n+        \"try\",\n+        format!(\"{} = {}.saturating_sub({});\", var_name, var_name, 1.to_string()),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "b8415fa3af12506f8d2cef72caff81a32d80856f", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -225,6 +225,7 @@ mod identity_op;\n mod if_let_some_result;\n mod if_not_else;\n mod implicit_return;\n+mod implicit_saturating_sub;\n mod indexing_slicing;\n mod infinite_iter;\n mod inherent_impl;\n@@ -574,6 +575,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &if_let_some_result::IF_LET_SOME_RESULT,\n         &if_not_else::IF_NOT_ELSE,\n         &implicit_return::IMPLICIT_RETURN,\n+        &implicit_saturating_sub::IMPLICIT_SATURATING_SUB,\n         &indexing_slicing::INDEXING_SLICING,\n         &indexing_slicing::OUT_OF_BOUNDS_INDEXING,\n         &infinite_iter::INFINITE_ITER,\n@@ -888,6 +890,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box unicode::Unicode);\n     store.register_late_pass(|| box strings::StringAdd);\n     store.register_late_pass(|| box implicit_return::ImplicitReturn);\n+    store.register_late_pass(|| box implicit_saturating_sub::ImplicitSaturatingSub);\n     store.register_late_pass(|| box methods::Methods);\n     store.register_late_pass(|| box map_clone::MapClone);\n     store.register_late_pass(|| box shadow::Shadow);\n@@ -1111,6 +1114,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&functions::MUST_USE_CANDIDATE),\n         LintId::of(&functions::TOO_MANY_LINES),\n         LintId::of(&if_not_else::IF_NOT_ELSE),\n+        LintId::of(&implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n         LintId::of(&infinite_iter::MAYBE_INFINITE_ITER),\n         LintId::of(&items_after_statements::ITEMS_AFTER_STATEMENTS),\n         LintId::of(&large_stack_arrays::LARGE_STACK_ARRAYS),"}, {"sha": "213d054e403dac1814d8953342aebd2fa5523b65", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -773,6 +773,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"implicit_return\",\n     },\n+    Lint {\n+        name: \"implicit_saturating_sub\",\n+        group: \"pedantic\",\n+        desc: \"Perform saturating subtraction instead of implicitly checking lower bound of data type\",\n+        deprecation: None,\n+        module: \"implicit_saturating_sub\",\n+    },\n     Lint {\n         name: \"imprecise_flops\",\n         group: \"nursery\","}, {"sha": "fd4ba71f6afcb04e9186262554768de531e255b6", "filename": "tests/ui/implicit_saturating_sub.fixed", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.fixed?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -0,0 +1,160 @@\n+// run-rustfix\n+#![allow(unused_assignments, unused_mut, clippy::assign_op_pattern)]\n+#![warn(clippy::implicit_saturating_sub)]\n+\n+fn main() {\n+    // Tests for unsigned integers\n+\n+    let end_8: u8 = 10;\n+    let start_8: u8 = 5;\n+    let mut u_8: u8 = end_8 - start_8;\n+\n+    // Lint\n+    u_8 = u_8.saturating_sub(1);\n+\n+    match end_8 {\n+        10 => {\n+            // Lint\n+            u_8 = u_8.saturating_sub(1);\n+        },\n+        11 => u_8 += 1,\n+        _ => u_8 = 0,\n+    }\n+\n+    let end_16: u16 = 35;\n+    let start_16: u16 = 40;\n+\n+    let mut u_16: u16 = end_16 - start_16;\n+\n+    // Lint\n+    u_16 = u_16.saturating_sub(1);\n+\n+    let mut end_32: u32 = 7000;\n+    let mut start_32: u32 = 7010;\n+\n+    let mut u_32: u32 = end_32 - start_32;\n+\n+    // Lint\n+    u_32 = u_32.saturating_sub(1);\n+\n+    // No Lint\n+    if u_32 > 0 {\n+        u_16 += 1;\n+    }\n+\n+    // No Lint\n+    if u_32 != 0 {\n+        end_32 -= 1;\n+        start_32 += 1;\n+    }\n+\n+    let mut end_64: u64 = 75001;\n+    let mut start_64: u64 = 75000;\n+\n+    let mut u_64: u64 = end_64 - start_64;\n+\n+    // Lint\n+    u_64 = u_64.saturating_sub(1);\n+\n+    // Lint\n+    u_64 = u_64.saturating_sub(1);\n+\n+    // Lint\n+    u_64 = u_64.saturating_sub(1);\n+\n+    // No Lint\n+    if u_64 >= 1 {\n+        u_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if u_64 > 0 {\n+        end_64 -= 1;\n+    }\n+\n+    // Tests for usize\n+    let end_usize: usize = 8054;\n+    let start_usize: usize = 8050;\n+\n+    let mut u_usize: usize = end_usize - start_usize;\n+\n+    // Lint\n+    u_usize = u_usize.saturating_sub(1);\n+\n+    // Tests for signed integers\n+\n+    let endi_8: i8 = 10;\n+    let starti_8: i8 = 50;\n+\n+    let mut i_8: i8 = endi_8 - starti_8;\n+\n+    // Lint\n+    i_8 = i_8.saturating_sub(1);\n+\n+    // Lint\n+    i_8 = i_8.saturating_sub(1);\n+\n+    // Lint\n+    i_8 = i_8.saturating_sub(1);\n+\n+    // Lint\n+    i_8 = i_8.saturating_sub(1);\n+\n+    let endi_16: i16 = 45;\n+    let starti_16: i16 = 44;\n+\n+    let mut i_16: i16 = endi_16 - starti_16;\n+\n+    // Lint\n+    i_16 = i_16.saturating_sub(1);\n+\n+    // Lint\n+    i_16 = i_16.saturating_sub(1);\n+\n+    // Lint\n+    i_16 = i_16.saturating_sub(1);\n+\n+    // Lint\n+    i_16 = i_16.saturating_sub(1);\n+\n+    let endi_32: i32 = 45;\n+    let starti_32: i32 = 44;\n+\n+    let mut i_32: i32 = endi_32 - starti_32;\n+\n+    // Lint\n+    i_32 = i_32.saturating_sub(1);\n+\n+    // Lint\n+    i_32 = i_32.saturating_sub(1);\n+\n+    // Lint\n+    i_32 = i_32.saturating_sub(1);\n+\n+    // Lint\n+    i_32 = i_32.saturating_sub(1);\n+\n+    let endi_64: i64 = 45;\n+    let starti_64: i64 = 44;\n+\n+    let mut i_64: i64 = endi_64 - starti_64;\n+\n+    // Lint\n+    i_64 = i_64.saturating_sub(1);\n+\n+    // Lint\n+    i_64 = i_64.saturating_sub(1);\n+\n+    // Lint\n+    i_64 = i_64.saturating_sub(1);\n+\n+    // No Lint\n+    if i_64 > 0 {\n+        i_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if i_64 != 0 {\n+        i_64 -= 1;\n+    }\n+}"}, {"sha": "56c1be005c044f97d7c5045dc486a7426e422098", "filename": "tests/ui/implicit_saturating_sub.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.rs?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -0,0 +1,206 @@\n+// run-rustfix\n+#![allow(unused_assignments, unused_mut, clippy::assign_op_pattern)]\n+#![warn(clippy::implicit_saturating_sub)]\n+\n+fn main() {\n+    // Tests for unsigned integers\n+\n+    let end_8: u8 = 10;\n+    let start_8: u8 = 5;\n+    let mut u_8: u8 = end_8 - start_8;\n+\n+    // Lint\n+    if u_8 > 0 {\n+        u_8 = u_8 - 1;\n+    }\n+\n+    match end_8 {\n+        10 => {\n+            // Lint\n+            if u_8 > 0 {\n+                u_8 -= 1;\n+            }\n+        },\n+        11 => u_8 += 1,\n+        _ => u_8 = 0,\n+    }\n+\n+    let end_16: u16 = 35;\n+    let start_16: u16 = 40;\n+\n+    let mut u_16: u16 = end_16 - start_16;\n+\n+    // Lint\n+    if u_16 > 0 {\n+        u_16 -= 1;\n+    }\n+\n+    let mut end_32: u32 = 7000;\n+    let mut start_32: u32 = 7010;\n+\n+    let mut u_32: u32 = end_32 - start_32;\n+\n+    // Lint\n+    if u_32 != 0 {\n+        u_32 -= 1;\n+    }\n+\n+    // No Lint\n+    if u_32 > 0 {\n+        u_16 += 1;\n+    }\n+\n+    // No Lint\n+    if u_32 != 0 {\n+        end_32 -= 1;\n+        start_32 += 1;\n+    }\n+\n+    let mut end_64: u64 = 75001;\n+    let mut start_64: u64 = 75000;\n+\n+    let mut u_64: u64 = end_64 - start_64;\n+\n+    // Lint\n+    if u_64 > 0 {\n+        u_64 -= 1;\n+    }\n+\n+    // Lint\n+    if 0 < u_64 {\n+        u_64 -= 1;\n+    }\n+\n+    // Lint\n+    if 0 != u_64 {\n+        u_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if u_64 >= 1 {\n+        u_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if u_64 > 0 {\n+        end_64 -= 1;\n+    }\n+\n+    // Tests for usize\n+    let end_usize: usize = 8054;\n+    let start_usize: usize = 8050;\n+\n+    let mut u_usize: usize = end_usize - start_usize;\n+\n+    // Lint\n+    if u_usize > 0 {\n+        u_usize -= 1;\n+    }\n+\n+    // Tests for signed integers\n+\n+    let endi_8: i8 = 10;\n+    let starti_8: i8 = 50;\n+\n+    let mut i_8: i8 = endi_8 - starti_8;\n+\n+    // Lint\n+    if i_8 > i8::MIN {\n+        i_8 -= 1;\n+    }\n+\n+    // Lint\n+    if i_8 > i8::min_value() {\n+        i_8 -= 1;\n+    }\n+\n+    // Lint\n+    if i_8 != i8::MIN {\n+        i_8 -= 1;\n+    }\n+\n+    // Lint\n+    if i_8 != i8::min_value() {\n+        i_8 -= 1;\n+    }\n+\n+    let endi_16: i16 = 45;\n+    let starti_16: i16 = 44;\n+\n+    let mut i_16: i16 = endi_16 - starti_16;\n+\n+    // Lint\n+    if i_16 > i16::MIN {\n+        i_16 -= 1;\n+    }\n+\n+    // Lint\n+    if i_16 > i16::min_value() {\n+        i_16 -= 1;\n+    }\n+\n+    // Lint\n+    if i_16 != i16::MIN {\n+        i_16 -= 1;\n+    }\n+\n+    // Lint\n+    if i_16 != i16::min_value() {\n+        i_16 -= 1;\n+    }\n+\n+    let endi_32: i32 = 45;\n+    let starti_32: i32 = 44;\n+\n+    let mut i_32: i32 = endi_32 - starti_32;\n+\n+    // Lint\n+    if i_32 > i32::MIN {\n+        i_32 -= 1;\n+    }\n+\n+    // Lint\n+    if i_32 > i32::min_value() {\n+        i_32 -= 1;\n+    }\n+\n+    // Lint\n+    if i_32 != i32::MIN {\n+        i_32 -= 1;\n+    }\n+\n+    // Lint\n+    if i_32 != i32::min_value() {\n+        i_32 -= 1;\n+    }\n+\n+    let endi_64: i64 = 45;\n+    let starti_64: i64 = 44;\n+\n+    let mut i_64: i64 = endi_64 - starti_64;\n+\n+    // Lint\n+    if i64::min_value() < i_64 {\n+        i_64 -= 1;\n+    }\n+\n+    // Lint\n+    if i64::MIN != i_64 {\n+        i_64 -= 1;\n+    }\n+\n+    // Lint\n+    if i64::MIN < i_64 {\n+        i_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if i_64 > 0 {\n+        i_64 -= 1;\n+    }\n+\n+    // No Lint\n+    if i_64 != 0 {\n+        i_64 -= 1;\n+    }\n+}"}, {"sha": "a8ba870b1dda6b03e76b533851d0c5a671458f7d", "filename": "tests/ui/implicit_saturating_sub.stderr", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/891e1a859b52486936e021235fdc36fbdd9b4100/tests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.stderr?ref=891e1a859b52486936e021235fdc36fbdd9b4100", "patch": "@@ -0,0 +1,188 @@\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:13:5\n+   |\n+LL | /     if u_8 > 0 {\n+LL | |         u_8 = u_8 - 1;\n+LL | |     }\n+   | |_____^ help: try: `u_8 = u_8.saturating_sub(1);`\n+   |\n+   = note: `-D clippy::implicit-saturating-sub` implied by `-D warnings`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:20:13\n+   |\n+LL | /             if u_8 > 0 {\n+LL | |                 u_8 -= 1;\n+LL | |             }\n+   | |_____________^ help: try: `u_8 = u_8.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:34:5\n+   |\n+LL | /     if u_16 > 0 {\n+LL | |         u_16 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_16 = u_16.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:44:5\n+   |\n+LL | /     if u_32 != 0 {\n+LL | |         u_32 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_32 = u_32.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:65:5\n+   |\n+LL | /     if u_64 > 0 {\n+LL | |         u_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:70:5\n+   |\n+LL | /     if 0 < u_64 {\n+LL | |         u_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:75:5\n+   |\n+LL | /     if 0 != u_64 {\n+LL | |         u_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:96:5\n+   |\n+LL | /     if u_usize > 0 {\n+LL | |         u_usize -= 1;\n+LL | |     }\n+   | |_____^ help: try: `u_usize = u_usize.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:108:5\n+   |\n+LL | /     if i_8 > i8::MIN {\n+LL | |         i_8 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:113:5\n+   |\n+LL | /     if i_8 > i8::min_value() {\n+LL | |         i_8 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:118:5\n+   |\n+LL | /     if i_8 != i8::MIN {\n+LL | |         i_8 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:123:5\n+   |\n+LL | /     if i_8 != i8::min_value() {\n+LL | |         i_8 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:133:5\n+   |\n+LL | /     if i_16 > i16::MIN {\n+LL | |         i_16 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:138:5\n+   |\n+LL | /     if i_16 > i16::min_value() {\n+LL | |         i_16 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:143:5\n+   |\n+LL | /     if i_16 != i16::MIN {\n+LL | |         i_16 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:148:5\n+   |\n+LL | /     if i_16 != i16::min_value() {\n+LL | |         i_16 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:158:5\n+   |\n+LL | /     if i_32 > i32::MIN {\n+LL | |         i_32 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:163:5\n+   |\n+LL | /     if i_32 > i32::min_value() {\n+LL | |         i_32 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:168:5\n+   |\n+LL | /     if i_32 != i32::MIN {\n+LL | |         i_32 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:173:5\n+   |\n+LL | /     if i_32 != i32::min_value() {\n+LL | |         i_32 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:183:5\n+   |\n+LL | /     if i64::min_value() < i_64 {\n+LL | |         i_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:188:5\n+   |\n+LL | /     if i64::MIN != i_64 {\n+LL | |         i_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n+\n+error: Implicitly performing saturating subtraction\n+  --> $DIR/implicit_saturating_sub.rs:193:5\n+   |\n+LL | /     if i64::MIN < i_64 {\n+LL | |         i_64 -= 1;\n+LL | |     }\n+   | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n+\n+error: aborting due to 23 previous errors\n+"}]}