{"sha": "cf048cc115860cc110865f460f3f2b9b4308ad92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMDQ4Y2MxMTU4NjBjYzExMDg2NWY0NjBmM2YyYjliNDMwOGFkOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T15:22:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-02T15:22:50Z"}, "message": "Auto merge of #63207 - petrochenkov:outest2, r=Mark-Simulacrum\n\nUnconfigure compiler unit test files during normal build\n\nI haven't touched libstd though, it had a lot of tests and I'm not sure the people maintaining it want this.\n\nCloses https://github.com/rust-lang/rust/issues/61097\nr? @Mark-Simulacrum", "tree": {"sha": "883bd4b5406aa47155d362bbadfe0b6f3d795793", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/883bd4b5406aa47155d362bbadfe0b6f3d795793"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf048cc115860cc110865f460f3f2b9b4308ad92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf048cc115860cc110865f460f3f2b9b4308ad92", "html_url": "https://github.com/rust-lang/rust/commit/cf048cc115860cc110865f460f3f2b9b4308ad92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf048cc115860cc110865f460f3f2b9b4308ad92/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1df512fcaeaf17639c5d28a3045814d6f7a7db97", "url": "https://api.github.com/repos/rust-lang/rust/commits/1df512fcaeaf17639c5d28a3045814d6f7a7db97", "html_url": "https://github.com/rust-lang/rust/commit/1df512fcaeaf17639c5d28a3045814d6f7a7db97"}, {"sha": "62ec2cb7acb1b16d0abd8a2cf40da545a13d29f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/62ec2cb7acb1b16d0abd8a2cf40da545a13d29f3", "html_url": "https://github.com/rust-lang/rust/commit/62ec2cb7acb1b16d0abd8a2cf40da545a13d29f3"}], "stats": {"total": 12081, "additions": 6020, "deletions": 6061}, "files": [{"sha": "53071df855297e30f17598f8dd03d159f412a151", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -266,8 +266,10 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+}\n \n-    #[cfg(test)]\n+#[cfg(test)]\n+impl Cache {\n     pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n         let cache = self.0.get_mut();\n         let type_id = TypeId::of::<S>();\n@@ -279,7 +281,6 @@ impl Cache {\n         v\n     }\n \n-    #[cfg(test)]\n     pub fn contains<S: Step>(&self) -> bool {\n         self.0.borrow().contains_key(&TypeId::of::<S>())\n     }"}, {"sha": "dc7fd1adc295895016dd2c71f34df41355ca02ea", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -10,6 +10,9 @@ use core::usize;\n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n     // them from the `#[global_allocator]` attribute if there is one, or uses the\n@@ -244,36 +247,3 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     }\n     unsafe { oom_impl(layout) }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::boxed::Box;\n-    use crate::alloc::{Global, Alloc, Layout, handle_alloc_error};\n-\n-    #[test]\n-    fn allocate_zeroed() {\n-        unsafe {\n-            let layout = Layout::from_size_align(1024, 1).unwrap();\n-            let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| handle_alloc_error(layout));\n-\n-            let mut i = ptr.cast::<u8>().as_ptr();\n-            let end = i.add(layout.size());\n-            while i < end {\n-                assert_eq!(*i, 0);\n-                i = i.offset(1);\n-            }\n-            Global.dealloc(ptr, layout);\n-        }\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = box 10;\n-        })\n-    }\n-}"}, {"sha": "c69f4e49ee1e3994e6621496129e54fceea84e52", "filename": "src/liballoc/alloc/tests.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,30 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+use crate::boxed::Box;\n+\n+#[test]\n+fn allocate_zeroed() {\n+    unsafe {\n+        let layout = Layout::from_size_align(1024, 1).unwrap();\n+        let ptr = Global.alloc_zeroed(layout.clone())\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        let mut i = ptr.cast::<u8>().as_ptr();\n+        let end = i.add(layout.size());\n+        while i < end {\n+            assert_eq!(*i, 0);\n+            i = i.offset(1);\n+        }\n+        Global.dealloc(ptr, layout);\n+    }\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn alloc_owned_small(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = box 10;\n+    })\n+}"}, {"sha": "a14a3fe9994abb59c517411f62ec9400ad22a6ef", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 3, "deletions": 270, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -23,6 +23,9 @@ use core::ptr::NonNull;\n use crate::boxed::Box;\n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A doubly-linked list with owned nodes.\n ///\n /// The `LinkedList` allows pushing and popping elements at either end\n@@ -1244,273 +1247,3 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::thread;\n-    use std::vec::Vec;\n-\n-    use rand::{thread_rng, RngCore};\n-\n-    use super::{LinkedList, Node};\n-\n-    #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-        v.iter().cloned().collect()\n-    }\n-\n-    pub fn check_links<T>(list: &LinkedList<T>) {\n-        unsafe {\n-            let mut len = 0;\n-            let mut last_ptr: Option<&Node<T>> = None;\n-            let mut node_ptr: &Node<T>;\n-            match list.head {\n-                None => {\n-                    // tail node should also be None.\n-                    assert!(list.tail.is_none());\n-                    assert_eq!(0, list.len);\n-                    return;\n-                }\n-                Some(node) => node_ptr = &*node.as_ptr(),\n-            }\n-            loop {\n-                match (last_ptr, node_ptr.prev) {\n-                    (None, None) => {}\n-                    (None, _) => panic!(\"prev link for head\"),\n-                    (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n-                    }\n-                    _ => panic!(\"prev link is none, not good\"),\n-                }\n-                match node_ptr.next {\n-                    Some(next) => {\n-                        last_ptr = Some(node_ptr);\n-                        node_ptr = &*next.as_ptr();\n-                        len += 1;\n-                    }\n-                    None => {\n-                        len += 1;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // verify that the tail node points to the last node.\n-            let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n-            assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n-            // check that len matches interior links.\n-            assert_eq!(len, list.len);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        // Empty to empty\n-        {\n-            let mut m = LinkedList::<i32>::new();\n-            let mut n = LinkedList::new();\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(n.len(), 0);\n-        }\n-        // Non-empty to empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            n.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            assert_eq!(n.len(), 0);\n-            check_links(&m);\n-        }\n-        // Empty to non-empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            m.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        // Non-empty to non-empty\n-        let v = vec![1, 2, 3, 4, 5];\n-        let u = vec![9, 8, 1, 2, 3, 4, 5];\n-        let mut m = list_from(&v);\n-        let mut n = list_from(&u);\n-        m.append(&mut n);\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.extend_from_slice(&u);\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-        assert_eq!(n.len(), 0);\n-        // let's make sure it's working properly, since we\n-        // did some direct changes to private members\n-        n.push_back(3);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(3));\n-        check_links(&n);\n-    }\n-\n-    #[test]\n-    fn test_insert_prev() {\n-        let mut m = list_from(&[0, 2, 4, 6, 8]);\n-        let len = m.len();\n-        {\n-            let mut it = m.iter_mut();\n-            it.insert_next(-2);\n-            loop {\n-                match it.next() {\n-                    None => break,\n-                    Some(elt) => {\n-                        it.insert_next(*elt + 1);\n-                        match it.peek_next() {\n-                            Some(x) => assert_eq!(*x, *elt + 2),\n-                            None => assert_eq!(8, *elt),\n-                        }\n-                    }\n-                }\n-            }\n-            it.insert_next(0);\n-            it.insert_next(1);\n-        }\n-        check_links(&m);\n-        assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_send() {\n-        let n = list_from(&[1, 2, 3]);\n-        thread::spawn(move || {\n-                check_links(&n);\n-                let a: &[_] = &[&1, &2, &3];\n-                assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-            })\n-            .join()\n-            .ok()\n-            .unwrap();\n-    }\n-\n-    #[test]\n-    fn test_fuzz() {\n-        for _ in 0..25 {\n-            fuzz_test(3);\n-            fuzz_test(16);\n-            #[cfg(not(miri))] // Miri is too slow\n-            fuzz_test(189);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_26021() {\n-        // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n-        // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n-        // its nodes.\n-        //\n-        // https://github.com/rust-lang/rust/issues/26021\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n-        assert_eq!(v1.len(), 3);\n-\n-        assert_eq!(v1.iter().len(), 3);\n-        assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-\n-        // test all splits\n-        for ix in 0..1 + v1.len() {\n-            let mut a = v1.clone();\n-            let b = a.split_off(ix);\n-            check_links(&a);\n-            check_links(&b);\n-            a.extend(b);\n-            assert_eq!(v1, a);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn fuzz_test(sz: i32) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        let mut v = vec![];\n-        for i in 0..sz {\n-            check_links(&m);\n-            let r: u8 = thread_rng().next_u32() as u8;\n-            match r % 6 {\n-                0 => {\n-                    m.pop_back();\n-                    v.pop();\n-                }\n-                1 => {\n-                    if !v.is_empty() {\n-                        m.pop_front();\n-                        v.remove(0);\n-                    }\n-                }\n-                2 | 4 => {\n-                    m.push_front(-i);\n-                    v.insert(0, -i);\n-                }\n-                3 | 5 | _ => {\n-                    m.push_back(i);\n-                    v.push(i);\n-                }\n-            }\n-        }\n-\n-        check_links(&m);\n-\n-        let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(&v) {\n-            i += 1;\n-            assert_eq!(a, b);\n-        }\n-        assert_eq!(i, v.len());\n-    }\n-\n-    #[test]\n-    fn drain_filter_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n-    }\n-\n-    #[test]\n-    fn drain_to_empty_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n-    }\n-}"}, {"sha": "9a6c57d286970d997a9ca4612f30b0cab3bd6383", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,264 @@\n+use super::*;\n+\n+use std::thread;\n+use std::vec::Vec;\n+\n+use rand::{thread_rng, RngCore};\n+\n+fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+    v.iter().cloned().collect()\n+}\n+\n+pub fn check_links<T>(list: &LinkedList<T>) {\n+    unsafe {\n+        let mut len = 0;\n+        let mut last_ptr: Option<&Node<T>> = None;\n+        let mut node_ptr: &Node<T>;\n+        match list.head {\n+            None => {\n+                // tail node should also be None.\n+                assert!(list.tail.is_none());\n+                assert_eq!(0, list.len);\n+                return;\n+            }\n+            Some(node) => node_ptr = &*node.as_ptr(),\n+        }\n+        loop {\n+            match (last_ptr, node_ptr.prev) {\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for head\"),\n+                (Some(p), Some(pptr)) => {\n+                    assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n+                }\n+                _ => panic!(\"prev link is none, not good\"),\n+            }\n+            match node_ptr.next {\n+                Some(next) => {\n+                    last_ptr = Some(node_ptr);\n+                    node_ptr = &*next.as_ptr();\n+                    len += 1;\n+                }\n+                None => {\n+                    len += 1;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // verify that the tail node points to the last node.\n+        let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n+        assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n+        // check that len matches interior links.\n+        assert_eq!(len, list.len);\n+    }\n+}\n+\n+#[test]\n+fn test_append() {\n+    // Empty to empty\n+    {\n+        let mut m = LinkedList::<i32>::new();\n+        let mut n = LinkedList::new();\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(n.len(), 0);\n+    }\n+    // Non-empty to empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        n.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        assert_eq!(n.len(), 0);\n+        check_links(&m);\n+    }\n+    // Empty to non-empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        m.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    // Non-empty to non-empty\n+    let v = vec![1, 2, 3, 4, 5];\n+    let u = vec![9, 8, 1, 2, 3, 4, 5];\n+    let mut m = list_from(&v);\n+    let mut n = list_from(&u);\n+    m.append(&mut n);\n+    check_links(&m);\n+    let mut sum = v;\n+    sum.extend_from_slice(&u);\n+    assert_eq!(sum.len(), m.len());\n+    for elt in sum {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+    assert_eq!(n.len(), 0);\n+    // let's make sure it's working properly, since we\n+    // did some direct changes to private members\n+    n.push_back(3);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(3));\n+    check_links(&n);\n+}\n+\n+#[test]\n+fn test_insert_prev() {\n+    let mut m = list_from(&[0, 2, 4, 6, 8]);\n+    let len = m.len();\n+    {\n+        let mut it = m.iter_mut();\n+        it.insert_next(-2);\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => {\n+                    it.insert_next(*elt + 1);\n+                    match it.peek_next() {\n+                        Some(x) => assert_eq!(*x, *elt + 2),\n+                        None => assert_eq!(8, *elt),\n+                    }\n+                }\n+            }\n+        }\n+        it.insert_next(0);\n+        it.insert_next(1);\n+    }\n+    check_links(&m);\n+    assert_eq!(m.len(), 3 + len * 2);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_send() {\n+    let n = list_from(&[1, 2, 3]);\n+    thread::spawn(move || {\n+            check_links(&n);\n+            let a: &[_] = &[&1, &2, &3];\n+            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+        })\n+        .join()\n+        .ok()\n+        .unwrap();\n+}\n+\n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_26021() {\n+    // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n+    // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n+    // its nodes.\n+    //\n+    // https://github.com/rust-lang/rust/issues/26021\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n+    assert_eq!(v1.len(), 3);\n+\n+    assert_eq!(v1.iter().len(), 3);\n+    assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+\n+    // test all splits\n+    for ix in 0..1 + v1.len() {\n+        let mut a = v1.clone();\n+        let b = a.split_off(ix);\n+        check_links(&a);\n+        check_links(&b);\n+        a.extend(b);\n+        assert_eq!(v1, a);\n+    }\n+}\n+\n+fn fuzz_test(sz: i32) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    let mut v = vec![];\n+    for i in 0..sz {\n+        check_links(&m);\n+        let r: u8 = thread_rng().next_u32() as u8;\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                v.pop();\n+            }\n+            1 => {\n+                if !v.is_empty() {\n+                    m.pop_front();\n+                    v.remove(0);\n+                }\n+            }\n+            2 | 4 => {\n+                m.push_front(-i);\n+                v.insert(0, -i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0;\n+    for (a, &b) in m.into_iter().zip(&v) {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+\n+#[test]\n+fn drain_filter_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+}\n+\n+#[test]\n+fn drain_to_empty_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+}"}, {"sha": "9240346ace93169a39ecce59759c86cbb32d79be", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 3, "deletions": 386, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! A double-ended queue implemented with a growable ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n@@ -24,6 +22,9 @@ use crate::collections::CollectionAllocErr;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n #[cfg(target_pointer_width = \"16\")]\n@@ -2838,387 +2839,3 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use ::test;\n-\n-    use super::VecDeque;\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_back(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_front(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_back());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_front());\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_swap_front_back_remove() {\n-        fn test(back: bool) {\n-            // This test checks that every single combination of tail position and length is tested.\n-            // Capacity 15 should be large enough to cover every case.\n-            let mut tester = VecDeque::with_capacity(15);\n-            let usable_cap = tester.capacity();\n-            let final_len = usable_cap / 2;\n-\n-            for len in 0..final_len {\n-                let expected: VecDeque<_> = if back {\n-                    (0..len).collect()\n-                } else {\n-                    (0..len).rev().collect()\n-                };\n-                for tail_pos in 0..usable_cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    if back {\n-                        for i in 0..len * 2 {\n-                            tester.push_front(i);\n-                        }\n-                        for i in 0..len {\n-                            assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n-                        }\n-                    } else {\n-                        for i in 0..len * 2 {\n-                            tester.push_back(i);\n-                        }\n-                        for i in 0..len {\n-                            let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n-                        }\n-                    }\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-        test(true);\n-        test(false);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-\n-        // len is the length *after* insertion\n-        for len in 1..cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_insert in 0..len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i != to_insert {\n-                            tester.push_back(i);\n-                        }\n-                    }\n-                    tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        // This test checks that every single combination of tail position, length, and\n-        // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *after* removal\n-        for len in 0..cap - 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_remove in 0..=len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i == to_remove {\n-                            tester.push_back(1234);\n-                        }\n-                        tester.push_back(i);\n-                    }\n-                    if to_remove == len {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n-\n-        let cap = tester.capacity();\n-        for len in 0..=cap {\n-            for tail in 0..=cap {\n-                for drain_start in 0..=len {\n-                    for drain_end in drain_start..=len {\n-                        tester.tail = tail;\n-                        tester.head = tail;\n-                        for i in 0..len {\n-                            tester.push_back(i);\n-                        }\n-\n-                        // Check that we drain the correct values\n-                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n-                        assert_eq!(drained, drained_expected);\n-\n-                        // We shouldn't have changed the capacity or made the\n-                        // head or tail out of bounds\n-                        assert_eq!(tester.capacity(), cap);\n-                        assert!(tester.tail < tester.cap());\n-                        assert!(tester.head < tester.cap());\n-\n-                        // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> = (0..drain_start)\n-                            .chain(drain_end..len)\n-                            .collect();\n-                        assert_eq!(expected, tester);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        // This test checks that every single combination of head and tail position,\n-        // is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-        tester.reserve(63);\n-        let max_cap = tester.capacity();\n-\n-        for len in 0..=cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..=max_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                tester.reserve(63);\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                tester.shrink_to_fit();\n-                assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // This test checks that every single combination of tail position, length, and\n-        // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *before* splitting\n-        for len in 0..cap {\n-            // index to split at\n-            for at in 0..=len {\n-                // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n-                // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n-\n-                for tail_pos in 0..cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        tester.push_back(i);\n-                    }\n-                    let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert!(result.tail < result.cap());\n-                    assert!(result.head < result.cap());\n-                    assert_eq!(tester, expected_self);\n-                    assert_eq!(result, expected_other);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        use crate::vec::Vec;\n-        for cap in 0..35 {\n-            for len in 0..=cap {\n-                let mut vec = Vec::with_capacity(cap);\n-                vec.extend(0..len);\n-\n-                let vd = VecDeque::from(vec.clone());\n-                assert!(vd.cap().is_power_of_two());\n-                assert_eq!(vd.len(), vec.len());\n-                assert!(vd.into_iter().eq(vec));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_from_vecdeque() {\n-        use crate::vec::Vec;\n-\n-        fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n-            let mut vd = VecDeque::with_capacity(capacity);\n-            for _ in 0..offset {\n-                vd.push_back(0);\n-                vd.pop_front();\n-            }\n-            vd.extend(0..len);\n-\n-            let vec: Vec<_> = Vec::from(vd.clone());\n-            assert_eq!(vec.len(), vd.len());\n-            assert!(vec.into_iter().eq(vd));\n-        }\n-\n-        #[cfg(not(miri))] // Miri is too slow\n-        let max_pwr = 7;\n-        #[cfg(miri)]\n-        let max_pwr = 5;\n-\n-        for cap_pwr in 0..max_pwr {\n-            // Make capacity as a (2^x)-1, so that the ring size is 2^x\n-            let cap = (2i32.pow(cap_pwr) - 1) as usize;\n-\n-            // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap + 1) / 2) {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-\n-            // Now there's not (necessarily) space to straighten the ring with simple copies,\n-            // the ring will use swapping when:\n-            // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n-            //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap + 1) / 2)..cap {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn issue_53529() {\n-        use crate::boxed::Box;\n-\n-        let mut dst = VecDeque::new();\n-        dst.push_front(Box::new(1));\n-        dst.push_front(Box::new(2));\n-        assert_eq!(*dst.pop_back().unwrap(), 1);\n-\n-        let mut src = VecDeque::new();\n-        src.push_front(Box::new(2));\n-        dst.append(&mut src);\n-        for a in dst {\n-            assert_eq!(*a, 2);\n-        }\n-    }\n-\n-}"}, {"sha": "d25352399796e684ec503bc05ed8b1597ed48806", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,379 @@\n+use super::*;\n+\n+use ::test;\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_back(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_front(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_back());\n+        }\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_front());\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_swap_front_back_remove() {\n+    fn test(back: bool) {\n+        // This test checks that every single combination of tail position and length is tested.\n+        // Capacity 15 should be large enough to cover every case.\n+        let mut tester = VecDeque::with_capacity(15);\n+        let usable_cap = tester.capacity();\n+        let final_len = usable_cap / 2;\n+\n+        for len in 0..final_len {\n+            let expected: VecDeque<_> = if back {\n+                (0..len).collect()\n+            } else {\n+                (0..len).rev().collect()\n+            };\n+            for tail_pos in 0..usable_cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                if back {\n+                    for i in 0..len * 2 {\n+                        tester.push_front(i);\n+                    }\n+                    for i in 0..len {\n+                        assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n+                    }\n+                } else {\n+                    for i in 0..len * 2 {\n+                        tester.push_back(i);\n+                    }\n+                    for i in 0..len {\n+                        let idx = tester.len() - 1 - i;\n+                        assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n+                    }\n+                }\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+    test(true);\n+    test(false);\n+}\n+\n+#[test]\n+fn test_insert() {\n+    // This test checks that every single combination of tail position, length, and\n+    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+\n+    // len is the length *after* insertion\n+    for len in 1..cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_insert in 0..len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i != to_insert {\n+                        tester.push_back(i);\n+                    }\n+                }\n+                tester.insert(to_insert, to_insert);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    // This test checks that every single combination of tail position, length, and\n+    // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *after* removal\n+    for len in 0..cap - 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_remove in 0..=len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i == to_remove {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.push_back(i);\n+                }\n+                if to_remove == len {\n+                    tester.push_back(1234);\n+                }\n+                tester.remove(to_remove);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for drain_start in 0..=len {\n+                for drain_end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we drain the correct values\n+                    let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                    let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n+                    assert_eq!(drained, drained_expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n+\n+                    // We should see the correct values in the VecDeque\n+                    let expected: VecDeque<_> = (0..drain_start)\n+                        .chain(drain_end..len)\n+                        .collect();\n+                    assert_eq!(expected, tester);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_shrink_to_fit() {\n+    // This test checks that every single combination of head and tail position,\n+    // is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+    tester.reserve(63);\n+    let max_cap = tester.capacity();\n+\n+    for len in 0..=cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..=max_cap {\n+            tester.tail = tail_pos;\n+            tester.head = tail_pos;\n+            tester.reserve(63);\n+            for i in 0..len {\n+                tester.push_back(i);\n+            }\n+            tester.shrink_to_fit();\n+            assert!(tester.capacity() <= cap);\n+            assert!(tester.tail < tester.cap());\n+            assert!(tester.head < tester.cap());\n+            assert_eq!(tester, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    // This test checks that every single combination of tail position, length, and\n+    // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *before* splitting\n+    for len in 0..cap {\n+        // index to split at\n+        for at in 0..=len {\n+            // 0, 1, 2, .., at - 1 (may be empty)\n+            let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n+            // at, at + 1, .., len - 1 (may be empty)\n+            let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n+\n+            for tail_pos in 0..cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                let result = tester.split_off(at);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert!(result.tail < result.cap());\n+                assert!(result.head < result.cap());\n+                assert_eq!(tester, expected_self);\n+                assert_eq!(result, expected_other);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    use crate::vec::Vec;\n+    for cap in 0..35 {\n+        for len in 0..=cap {\n+            let mut vec = Vec::with_capacity(cap);\n+            vec.extend(0..len);\n+\n+            let vd = VecDeque::from(vec.clone());\n+            assert!(vd.cap().is_power_of_two());\n+            assert_eq!(vd.len(), vec.len());\n+            assert!(vd.into_iter().eq(vec));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_vec_from_vecdeque() {\n+    use crate::vec::Vec;\n+\n+    fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n+        let mut vd = VecDeque::with_capacity(capacity);\n+        for _ in 0..offset {\n+            vd.push_back(0);\n+            vd.pop_front();\n+        }\n+        vd.extend(0..len);\n+\n+        let vec: Vec<_> = Vec::from(vd.clone());\n+        assert_eq!(vec.len(), vd.len());\n+        assert!(vec.into_iter().eq(vd));\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    let max_pwr = 7;\n+    #[cfg(miri)]\n+    let max_pwr = 5;\n+\n+    for cap_pwr in 0..max_pwr {\n+        // Make capacity as a (2^x)-1, so that the ring size is 2^x\n+        let cap = (2i32.pow(cap_pwr) - 1) as usize;\n+\n+        // In these cases there is enough free space to solve it with copies\n+        for len in 0..((cap + 1) / 2) {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+\n+        // Now there's not (necessarily) space to straighten the ring with simple copies,\n+        // the ring will use swapping when:\n+        // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n+        //  right block size  >   free space    &&      left block size       >    free space\n+        for len in ((cap + 1) / 2)..cap {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn issue_53529() {\n+    use crate::boxed::Box;\n+\n+    let mut dst = VecDeque::new();\n+    dst.push_front(Box::new(1));\n+    dst.push_front(Box::new(2));\n+    assert_eq!(*dst.pop_back().unwrap(), 1);\n+\n+    let mut src = VecDeque::new();\n+    src.push_front(Box::new(2));\n+    dst.append(&mut src);\n+    for a in dst {\n+        assert_eq!(*a, 2);\n+    }\n+}"}, {"sha": "0abab45e920cc8bd7ad88ac2b6551b857804bc2c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -11,6 +11,9 @@ use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n use crate::collections::CollectionAllocErr::{self, *};\n use crate::boxed::Box;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -748,82 +751,3 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n fn capacity_overflow() -> ! {\n     panic!(\"capacity overflow\")\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn allocator_param() {\n-        use crate::alloc::AllocErr;\n-\n-        // Writing a test of integration between third-party\n-        // allocators and RawVec is a little tricky because the RawVec\n-        // API does not expose fallible allocation methods, so we\n-        // cannot check what happens when allocator is exhausted\n-        // (beyond detecting a panic).\n-        //\n-        // Instead, this just checks that the RawVec methods do at\n-        // least go through the Allocator API when it reserves\n-        // storage.\n-\n-        // A dumb allocator that consumes a fixed amount of fuel\n-        // before allocation attempts start failing.\n-        struct BoundedAlloc { fuel: usize }\n-        unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-                let size = layout.size();\n-                if size > self.fuel {\n-                    return Err(AllocErr);\n-                }\n-                match Global.alloc(layout) {\n-                    ok @ Ok(_) => { self.fuel -= size; ok }\n-                    err @ Err(_) => err,\n-                }\n-            }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-                Global.dealloc(ptr, layout)\n-            }\n-        }\n-\n-        let a = BoundedAlloc { fuel: 500 };\n-        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-        assert_eq!(v.a.fuel, 450);\n-        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-        assert_eq!(v.a.fuel, 250);\n-    }\n-\n-    #[test]\n-    fn reserve_does_not_overallocate() {\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            // First `reserve` allocates like `reserve_exact`\n-            v.reserve(0, 9);\n-            assert_eq!(9, v.capacity());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 7);\n-            assert_eq!(7, v.capacity());\n-            // 97 if more than double of 7, so `reserve` should work\n-            // like `reserve_exact`.\n-            v.reserve(7, 90);\n-            assert_eq!(97, v.capacity());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 12);\n-            assert_eq!(12, v.capacity());\n-            v.reserve(12, 3);\n-            // 3 is less than half of 12, so `reserve` must grow\n-            // exponentially. At the time of writing this test grow\n-            // factor is 2, so new capacity is 24, however, grow factor\n-            // of 1.5 is OK too. Hence `>= 18` in assert.\n-            assert!(v.capacity() >= 12 + 12 / 2);\n-        }\n-    }\n-\n-\n-}"}, {"sha": "c389898d1ef0450c3bdf3f168b45fbb40e71e089", "filename": "src/liballoc/raw_vec/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+#[test]\n+fn allocator_param() {\n+    use crate::alloc::AllocErr;\n+\n+    // Writing a test of integration between third-party\n+    // allocators and RawVec is a little tricky because the RawVec\n+    // API does not expose fallible allocation methods, so we\n+    // cannot check what happens when allocator is exhausted\n+    // (beyond detecting a panic).\n+    //\n+    // Instead, this just checks that the RawVec methods do at\n+    // least go through the Allocator API when it reserves\n+    // storage.\n+\n+    // A dumb allocator that consumes a fixed amount of fuel\n+    // before allocation attempts start failing.\n+    struct BoundedAlloc { fuel: usize }\n+    unsafe impl Alloc for BoundedAlloc {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+            let size = layout.size();\n+            if size > self.fuel {\n+                return Err(AllocErr);\n+            }\n+            match Global.alloc(layout) {\n+                ok @ Ok(_) => { self.fuel -= size; ok }\n+                err @ Err(_) => err,\n+            }\n+        }\n+        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+            Global.dealloc(ptr, layout)\n+        }\n+    }\n+\n+    let a = BoundedAlloc { fuel: 500 };\n+    let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n+    assert_eq!(v.a.fuel, 450);\n+    v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n+    assert_eq!(v.a.fuel, 250);\n+}\n+\n+#[test]\n+fn reserve_does_not_overallocate() {\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        // First `reserve` allocates like `reserve_exact`\n+        v.reserve(0, 9);\n+        assert_eq!(9, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 7);\n+        assert_eq!(7, v.capacity());\n+        // 97 if more than double of 7, so `reserve` should work\n+        // like `reserve_exact`.\n+        v.reserve(7, 90);\n+        assert_eq!(97, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 12);\n+        assert_eq!(12, v.capacity());\n+        v.reserve(12, 3);\n+        // 3 is less than half of 12, so `reserve` must grow\n+        // exponentially. At the time of writing this test grow\n+        // factor is 2, so new capacity is 24, however, grow factor\n+        // of 1.5 is OK too. Hence `>= 18` in assert.\n+        assert!(v.capacity() >= 12 + 12 / 2);\n+    }\n+}"}, {"sha": "e33aac3af474e4435093d95cda8b6e45efdbf664", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 430, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -252,6 +252,9 @@ use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -1851,436 +1854,6 @@ impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::{Rc, Weak};\n-    use std::boxed::Box;\n-    use std::cell::RefCell;\n-    use std::option::Option::{self, None, Some};\n-    use std::result::Result::{Err, Ok};\n-    use std::mem::drop;\n-    use std::clone::Clone;\n-    use std::convert::From;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.clone();\n-        *x.borrow_mut() = 20;\n-        assert_eq!(*y.borrow(), 20);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Rc::new(5);\n-        assert_eq!(*x, 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Rc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x, 5);\n-        assert_eq!(*y, 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x: Rc<Box<_>> = Rc::new(box 5);\n-        assert_eq!(**x, 5);\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: RefCell<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = Rc::downgrade(&a.clone());\n-        *a.x.borrow_mut() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn is_unique() {\n-        let x = Rc::new(3);\n-        assert!(Rc::is_unique(&x));\n-        let y = x.clone();\n-        assert!(!Rc::is_unique(&x));\n-        drop(y);\n-        assert!(Rc::is_unique(&x));\n-        let w = Rc::downgrade(&x);\n-        assert!(!Rc::is_unique(&x));\n-        drop(w);\n-        assert!(Rc::is_unique(&x));\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Rc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 1);\n-        drop(w);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Rc::strong_count(&a) == 2);\n-        assert!(Rc::weak_count(&a) == 0);\n-        drop(c);\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Rc::new(0);\n-        let w = Rc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Rc::new(3);\n-        assert_eq!(Rc::try_unwrap(x), Ok(3));\n-        let x = Rc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n-        let x = Rc::new(5);\n-        let _w = Rc::downgrade(&x);\n-        assert_eq!(Rc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Rc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Rc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Rc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let rc: Rc<str> = Rc::from(\"foo\");\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(rc, rc2);\n-\n-        let rc: Rc<dyn Display> = Rc::new(123);\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(rc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn get_mut() {\n-        let mut x = Rc::new(3);\n-        *Rc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Rc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = Rc::downgrade(&x);\n-        assert!(Rc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_make_unique() {\n-        let mut cow0 = Rc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Rc::make_mut(&mut cow0));\n-        assert!(75 == *Rc::make_mut(&mut cow1));\n-        assert!(75 == *Rc::make_mut(&mut cow2));\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-        *Rc::make_mut(&mut cow1) += 2;\n-        *Rc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_unique2() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_weak() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1_weak = Rc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let foo = Rc::new(75);\n-        assert_eq!(format!(\"{:?}\", foo), \"75\");\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n-        assert_eq!(foo, foo.clone());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_rc = Rc::from(foo);\n-        assert!(123 == *foo_rc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Rc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Rc::new(5);\n-\n-        assert!(Rc::ptr_eq(&five, &same_five));\n-        assert!(!Rc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Rc<str> = Rc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Rc<[X]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Rc<[Fail]> = Rc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Rc<u32> = Rc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Rc<str> = Rc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Rc<dyn Display> = Rc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Rc<dyn Debug> = Rc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n-        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "72816a5c120c80843bdfd3455af725e8747f39d5", "filename": "src/liballoc/rc/tests.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,427 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::cell::RefCell;\n+use std::option::Option::{self, None, Some};\n+use std::result::Result::{Err, Ok};\n+use std::mem::drop;\n+use std::clone::Clone;\n+use std::convert::From;\n+\n+#[test]\n+fn test_clone() {\n+    let x = Rc::new(RefCell::new(5));\n+    let y = x.clone();\n+    *x.borrow_mut() = 20;\n+    assert_eq!(*y.borrow(), 20);\n+}\n+\n+#[test]\n+fn test_simple() {\n+    let x = Rc::new(5);\n+    assert_eq!(*x, 5);\n+}\n+\n+#[test]\n+fn test_simple_clone() {\n+    let x = Rc::new(5);\n+    let y = x.clone();\n+    assert_eq!(*x, 5);\n+    assert_eq!(*y, 5);\n+}\n+\n+#[test]\n+fn test_destructor() {\n+    let x: Rc<Box<_>> = Rc::new(box 5);\n+    assert_eq!(**x, 5);\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: RefCell<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Rc::new(Cycle { x: RefCell::new(None) });\n+    let b = Rc::downgrade(&a.clone());\n+    *a.x.borrow_mut() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn is_unique() {\n+    let x = Rc::new(3);\n+    assert!(Rc::is_unique(&x));\n+    let y = x.clone();\n+    assert!(!Rc::is_unique(&x));\n+    drop(y);\n+    assert!(Rc::is_unique(&x));\n+    let w = Rc::downgrade(&x);\n+    assert!(!Rc::is_unique(&x));\n+    drop(w);\n+    assert!(Rc::is_unique(&x));\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Rc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 1);\n+    drop(w);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Rc::strong_count(&a) == 2);\n+    assert!(Rc::weak_count(&a) == 0);\n+    drop(c);\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Rc::new(0);\n+    let w = Rc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Rc::new(3);\n+    assert_eq!(Rc::try_unwrap(x), Ok(3));\n+    let x = Rc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    let x = Rc::new(5);\n+    let _w = Rc::downgrade(&x);\n+    assert_eq!(Rc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Rc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Rc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Rc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let rc: Rc<str> = Rc::from(\"foo\");\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(rc, rc2);\n+\n+    let rc: Rc<dyn Display> = Rc::new(123);\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(rc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn get_mut() {\n+    let mut x = Rc::new(3);\n+    *Rc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Rc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Rc::get_mut(&mut x).is_some());\n+    let _w = Rc::downgrade(&x);\n+    assert!(Rc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn test_cowrc_clone_make_unique() {\n+    let mut cow0 = Rc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Rc::make_mut(&mut cow0));\n+    assert!(75 == *Rc::make_mut(&mut cow1));\n+    assert!(75 == *Rc::make_mut(&mut cow2));\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+    *Rc::make_mut(&mut cow1) += 2;\n+    *Rc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_unique2() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_weak() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1_weak = Rc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let foo = Rc::new(75);\n+    assert_eq!(format!(\"{:?}\", foo), \"75\");\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n+    assert_eq!(foo, foo.clone());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_rc = Rc::from(foo);\n+    assert!(123 == *foo_rc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Rc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Rc::new(5);\n+\n+    assert!(Rc::ptr_eq(&five, &same_five));\n+    assert!(!Rc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Rc<str> = Rc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Rc<[X]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Rc<[Fail]> = Rc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Rc<u32> = Rc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Rc<str> = Rc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Rc<dyn Display> = Rc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Rc<dyn Debug> = Rc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r2: Rc<dyn Any> = Rc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n+}"}, {"sha": "e11873218e8a41f7522f14bfdcd896df54f5c007", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 3, "deletions": 483, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -30,6 +30,9 @@ use crate::rc::is_dangling;\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n /// Going above this limit will abort your program (although not\n@@ -1915,489 +1918,6 @@ impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use std::boxed::Box;\n-    use std::clone::Clone;\n-    use std::sync::mpsc::channel;\n-    use std::mem::drop;\n-    use std::ops::Drop;\n-    use std::option::Option::{self, None, Some};\n-    use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n-    use std::thread;\n-    use std::sync::Mutex;\n-    use std::convert::From;\n-\n-    use super::{Arc, Weak};\n-    use crate::vec::Vec;\n-\n-    struct Canary(*mut atomic::AtomicUsize);\n-\n-    impl Drop for Canary {\n-        fn drop(&mut self) {\n-            unsafe {\n-                match *self {\n-                    Canary(c) => {\n-                        (*c).fetch_add(1, SeqCst);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn manually_share_arc() {\n-        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = Arc::new(v);\n-\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move || {\n-            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n-            assert_eq!((*arc_v)[3], 4);\n-        });\n-\n-        tx.send(arc_v.clone()).unwrap();\n-\n-        assert_eq!((*arc_v)[2], 3);\n-        assert_eq!((*arc_v)[4], 5);\n-    }\n-\n-    #[test]\n-    fn test_arc_get_mut() {\n-        let mut x = Arc::new(3);\n-        *Arc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Arc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = Arc::downgrade(&x);\n-        assert!(Arc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Arc::new(0);\n-        let w = Arc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Arc::new(3);\n-        assert_eq!(Arc::try_unwrap(x), Ok(3));\n-        let x = Arc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n-        let x = Arc::new(5);\n-        let _w = Arc::downgrade(&x);\n-        assert_eq!(Arc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Arc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Arc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Arc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let arc: Arc<str> = Arc::from(\"foo\");\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(arc, arc2);\n-\n-        let arc: Arc<dyn Display> = Arc::new(123);\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(arc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_make_mut() {\n-        let mut cow0 = Arc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Arc::make_mut(&mut cow0));\n-        assert!(75 == *Arc::make_mut(&mut cow1));\n-        assert!(75 == *Arc::make_mut(&mut cow2));\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        *Arc::make_mut(&mut cow1) += 2;\n-        *Arc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_unique2() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_weak() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1_weak = Arc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: Mutex<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = Arc::downgrade(&a.clone());\n-        *a.x.lock().unwrap() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn drop_arc() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        drop(x);\n-        assert!(canary.load(Acquire) == 1);\n-    }\n-\n-    #[test]\n-    fn drop_arc_weak() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = Arc::downgrade(&arc);\n-        assert!(canary.load(Acquire) == 0);\n-        drop(arc);\n-        assert!(canary.load(Acquire) == 1);\n-        drop(arc_weak);\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"\");\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Arc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 1);\n-        let x = w.clone();\n-        assert!(Arc::weak_count(&a) == 2);\n-        drop(w);\n-        drop(x);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Arc::strong_count(&a) == 2);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let d = Arc::downgrade(&c);\n-        assert!(Arc::weak_count(&c) == 1);\n-        assert!(Arc::strong_count(&c) == 2);\n-\n-        drop(a);\n-        drop(c);\n-        drop(d);\n-    }\n-\n-    #[test]\n-    fn show_arc() {\n-        let a = Arc::new(5);\n-        assert_eq!(format!(\"{:?}\", a), \"5\");\n-    }\n-\n-    // Make sure deriving works with Arc<T>\n-    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo {\n-        inner: Arc<i32>,\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n-        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = Arc::downgrade(&x.clone());\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_arc = Arc::from(foo);\n-        assert!(123 == *foo_arc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Arc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Arc::new(5);\n-\n-        assert!(Arc::ptr_eq(&five, &same_five));\n-        assert!(!Arc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_weak_count_locked() {\n-        let mut a = Arc::new(atomic::AtomicBool::new(false));\n-        let a2 = a.clone();\n-        let t = thread::spawn(move || {\n-            for _i in 0..1000000 {\n-                Arc::get_mut(&mut a);\n-            }\n-            a.store(true, SeqCst);\n-        });\n-\n-        while !a2.load(SeqCst) {\n-            let n = Arc::weak_count(&a2);\n-            assert!(n < 2, \"bad weak count: {}\", n);\n-        }\n-        t.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Arc<str> = Arc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Arc<[X]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Arc<[Fail]> = Arc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Arc<u32> = Arc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Arc<str> = Arc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Arc<dyn Display> = Arc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Arc<dyn Debug> = Arc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n-        let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n     fn borrow(&self) -> &T {"}, {"sha": "2e0c62f50c1678f7e2b6eefa695baa9e3b612707", "filename": "src/liballoc/sync/tests.rs", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,480 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::clone::Clone;\n+use std::sync::mpsc::channel;\n+use std::mem::drop;\n+use std::ops::Drop;\n+use std::option::Option::{self, None, Some};\n+use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n+use std::thread;\n+use std::sync::Mutex;\n+use std::convert::From;\n+\n+use crate::vec::Vec;\n+\n+struct Canary(*mut atomic::AtomicUsize);\n+\n+impl Drop for Canary {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match *self {\n+                Canary(c) => {\n+                    (*c).fetch_add(1, SeqCst);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn manually_share_arc() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let arc_v = Arc::new(v);\n+\n+    let (tx, rx) = channel();\n+\n+    let _t = thread::spawn(move || {\n+        let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n+        assert_eq!((*arc_v)[3], 4);\n+    });\n+\n+    tx.send(arc_v.clone()).unwrap();\n+\n+    assert_eq!((*arc_v)[2], 3);\n+    assert_eq!((*arc_v)[4], 5);\n+}\n+\n+#[test]\n+fn test_arc_get_mut() {\n+    let mut x = Arc::new(3);\n+    *Arc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Arc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Arc::get_mut(&mut x).is_some());\n+    let _w = Arc::downgrade(&x);\n+    assert!(Arc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Arc::new(0);\n+    let w = Arc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    let x = Arc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Arc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Arc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Arc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Arc<str> = Arc::from(\"foo\");\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(arc, arc2);\n+\n+    let arc: Arc<dyn Display> = Arc::new(123);\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(arc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_cowarc_clone_make_mut() {\n+    let mut cow0 = Arc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Arc::make_mut(&mut cow0));\n+    assert!(75 == *Arc::make_mut(&mut cow1));\n+    assert!(75 == *Arc::make_mut(&mut cow2));\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    *Arc::make_mut(&mut cow1) += 2;\n+    *Arc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_unique2() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_weak() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1_weak = Arc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: Mutex<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Arc::new(Cycle { x: Mutex::new(None) });\n+    let b = Arc::downgrade(&a.clone());\n+    *a.x.lock().unwrap() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn drop_arc() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    drop(x);\n+    assert!(canary.load(Acquire) == 1);\n+}\n+\n+#[test]\n+fn drop_arc_weak() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    let arc_weak = Arc::downgrade(&arc);\n+    assert!(canary.load(Acquire) == 0);\n+    drop(arc);\n+    assert!(canary.load(Acquire) == 1);\n+    drop(arc_weak);\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"\");\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Arc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 1);\n+    let x = w.clone();\n+    assert!(Arc::weak_count(&a) == 2);\n+    drop(w);\n+    drop(x);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Arc::strong_count(&a) == 2);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let d = Arc::downgrade(&c);\n+    assert!(Arc::weak_count(&c) == 1);\n+    assert!(Arc::strong_count(&c) == 2);\n+\n+    drop(a);\n+    drop(c);\n+    drop(d);\n+}\n+\n+#[test]\n+fn show_arc() {\n+    let a = Arc::new(5);\n+    assert_eq!(format!(\"{:?}\", a), \"5\");\n+}\n+\n+// Make sure deriving works with Arc<T>\n+#[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n+struct Foo {\n+    inner: Arc<i32>,\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n+    assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n+    let y = Arc::downgrade(&x.clone());\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_arc = Arc::from(foo);\n+    assert!(123 == *foo_arc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Arc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Arc::new(5);\n+\n+    assert!(Arc::ptr_eq(&five, &same_five));\n+    assert!(!Arc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_weak_count_locked() {\n+    let mut a = Arc::new(atomic::AtomicBool::new(false));\n+    let a2 = a.clone();\n+    let t = thread::spawn(move || {\n+        for _i in 0..1000000 {\n+            Arc::get_mut(&mut a);\n+        }\n+        a.store(true, SeqCst);\n+    });\n+\n+    while !a2.load(SeqCst) {\n+        let n = Arc::weak_count(&a2);\n+        assert!(n < 2, \"bad weak count: {}\", n);\n+    }\n+    t.join().unwrap();\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Arc<str> = Arc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Arc<[X]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Arc<[Fail]> = Arc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Arc<u32> = Arc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Arc<str> = Arc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Arc<dyn Display> = Arc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Arc<dyn Debug> = Arc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n+}"}, {"sha": "8a26454c389d7c6855b661199084f7e386ebd97b", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -40,12 +40,10 @@ fn test_basic() {\n     assert_eq!(n.pop_front(), Some(1));\n }\n \n-#[cfg(test)]\n fn generate_test() -> LinkedList<i32> {\n     list_from(&[0, 1, 2, 3, 4, 5, 6])\n }\n \n-#[cfg(test)]\n fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n     v.iter().cloned().collect()\n }"}, {"sha": "1bbcca97b3c78056ee0a8d818d09eae5d4538ee6", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -44,7 +44,6 @@ fn test_simple() {\n     assert_eq!(d[3], 4);\n }\n \n-#[cfg(test)]\n fn test_parameterized<T: Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n     let mut deq = VecDeque::new();\n     assert_eq!(deq.len(), 0);"}, {"sha": "34128e60d3638bc6bbf2ba04e158e5a4e1432b42", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -6,6 +6,9 @@\n // are compiling it everywhere to avoid regressions.\n #![allow(unused)]\n \n+#[cfg(test)]\n+mod tests;\n+\n pub mod eh;\n \n use core::mem;\n@@ -68,21 +71,3 @@ impl DwarfReader {\n         result as i64\n     }\n }\n-\n-#[test]\n-fn dwarf_reader() {\n-    let encoded: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 0xE5, 0x8E, 0x26, 0x9B, 0xF1, 0x59, 0xFF, 0xFF];\n-\n-    let mut reader = DwarfReader::new(encoded.as_ptr());\n-\n-    unsafe {\n-        assert!(reader.read::<u8>() == u8::to_be(1u8));\n-        assert!(reader.read::<u16>() == u16::to_be(0x0203));\n-        assert!(reader.read::<u32>() == u32::to_be(0x04050607));\n-\n-        assert!(reader.read_uleb128() == 624485);\n-        assert!(reader.read_sleb128() == -624485);\n-\n-        assert!(reader.read::<i8>() == i8::to_be(-1));\n-    }\n-}"}, {"sha": "1644f37083a5bbdaa3f7f8fc2b44f4f93b6a9982", "filename": "src/libpanic_unwind/dwarf/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,19 @@\n+use super::*;\n+\n+#[test]\n+fn dwarf_reader() {\n+    let encoded: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 0xE5, 0x8E, 0x26, 0x9B, 0xF1, 0x59, 0xFF, 0xFF];\n+\n+    let mut reader = DwarfReader::new(encoded.as_ptr());\n+\n+    unsafe {\n+        assert!(reader.read::<u8>() == u8::to_be(1u8));\n+        assert!(reader.read::<u16>() == u16::to_be(0x0203));\n+        assert!(reader.read::<u32>() == u32::to_be(0x04050607));\n+\n+        assert!(reader.read_uleb128() == 624485);\n+        assert!(reader.read_sleb128() == -624485);\n+\n+        assert!(reader.read::<i8>() == i8::to_be(-1));\n+    }\n+}"}, {"sha": "8e0581b41ef7aeb99d4ae44659c4e0a4e9d8d7a7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -80,6 +80,9 @@ extern crate libc;\n // librustc_driver and libtest.\n extern crate test as _;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[macro_use]\n mod macros;\n \n@@ -138,18 +141,5 @@ pub mod util {\n // Allows macros to refer to this crate as `::rustc`\n extern crate self as rustc;\n \n-// FIXME(#27438): right now the unit tests of librustc don't refer to any actual\n-//                functions generated in librustc_data_structures (all\n-//                references are through generic functions), but statics are\n-//                referenced from time to time. Due to this bug we won't\n-//                actually correctly link in the statics unless we also\n-//                reference a function, so be sure to reference a dummy\n-//                function.\n-#[test]\n-fn noop() {\n-    rustc_data_structures::__noop_fix_for_27438();\n-}\n-\n-\n // Build the diagnostics array at the end so that the metadata includes error use sites.\n __build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "cf3ea2ffa9397f1a9bfa12ef9deccff8a74d2968", "filename": "src/librustc/tests.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,13 @@\n+use super::*;\n+\n+// FIXME(#27438): right now the unit tests of librustc don't refer to any actual\n+//                functions generated in librustc_data_structures (all\n+//                references are through generic functions), but statics are\n+//                referenced from time to time. Due to this bug we won't\n+//                actually correctly link in the statics unless we also\n+//                reference a function, so be sure to reference a dummy\n+//                function.\n+#[test]\n+fn noop() {\n+    rustc_data_structures::__noop_fix_for_27438();\n+}"}, {"sha": "7118d05204c3be500733e05294d2e26b879f256e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -18,6 +18,9 @@ use crate::dep_graph::{DepNode};\n use lazy_static;\n use crate::session::Session;\n \n+#[cfg(test)]\n+mod tests;\n+\n // The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n@@ -349,16 +352,3 @@ impl<K, V> MemoizationMap for RefCell<FxHashMap<K,V>>\n         }\n     }\n }\n-\n-#[test]\n-fn test_to_readable_str() {\n-    assert_eq!(\"0\", to_readable_str(0));\n-    assert_eq!(\"1\", to_readable_str(1));\n-    assert_eq!(\"99\", to_readable_str(99));\n-    assert_eq!(\"999\", to_readable_str(999));\n-    assert_eq!(\"1_000\", to_readable_str(1_000));\n-    assert_eq!(\"1_001\", to_readable_str(1_001));\n-    assert_eq!(\"999_999\", to_readable_str(999_999));\n-    assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n-    assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n-}"}, {"sha": "9a9fb203c625e3d84846cddafa8fe3c8e7a38225", "filename": "src/librustc/util/common/tests.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Futil%2Fcommon%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc%2Futil%2Fcommon%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,14 @@\n+use super::*;\n+\n+#[test]\n+fn test_to_readable_str() {\n+    assert_eq!(\"0\", to_readable_str(0));\n+    assert_eq!(\"1\", to_readable_str(1));\n+    assert_eq!(\"99\", to_readable_str(99));\n+    assert_eq!(\"999\", to_readable_str(999));\n+    assert_eq!(\"1_000\", to_readable_str(1_000));\n+    assert_eq!(\"1_001\", to_readable_str(1_001));\n+    assert_eq!(\"999_999\", to_readable_str(999_999));\n+    assert_eq!(\"1_000_000\", to_readable_str(1_000_000));\n+    assert_eq!(\"1_234_567\", to_readable_str(1_234_567));\n+}"}, {"sha": "9b63a892b8c93773a25cb3dd8ba100b00cdd32a1", "filename": "src/librustc_data_structures/base_n.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -3,6 +3,9 @@\n \n use std::str;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub const MAX_BASE: usize = 64;\n pub const ALPHANUMERIC_ONLY: usize = 62;\n pub const CASE_INSENSITIVE: usize = 36;\n@@ -38,24 +41,3 @@ pub fn encode(n: u128, base: usize) -> String {\n     push_str(n, base, &mut s);\n     s\n }\n-\n-#[test]\n-fn test_encode() {\n-    fn test(n: u128, base: usize) {\n-        assert_eq!(Ok(n), u128::from_str_radix(&encode(n, base), base as u32));\n-    }\n-\n-    for base in 2..37 {\n-        test(0, base);\n-        test(1, base);\n-        test(35, base);\n-        test(36, base);\n-        test(37, base);\n-        test(u64::max_value() as u128, base);\n-        test(u128::max_value(), base);\n-\n-        for i in 0 .. 1_000 {\n-            test(i * 983, base);\n-        }\n-    }\n-}"}, {"sha": "0b0a8c5e256e47cd1fc93e4a3525efb1d5ac6721", "filename": "src/librustc_data_structures/base_n/tests.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbase_n%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,22 @@\n+use super::*;\n+\n+#[test]\n+fn test_encode() {\n+    fn test(n: u128, base: usize) {\n+        assert_eq!(Ok(n), u128::from_str_radix(&encode(n, base), base as u32));\n+    }\n+\n+    for base in 2..37 {\n+        test(0, base);\n+        test(1, base);\n+        test(35, base);\n+        test(36, base);\n+        test(37, base);\n+        test(u64::max_value() as u128, base);\n+        test(u128::max_value(), base);\n+\n+        for i in 0 .. 1_000 {\n+            test(i * 983, base);\n+        }\n+    }\n+}"}, {"sha": "6d1e1abbcef1d0c9692bd733f11c443be83a18d2", "filename": "src/librustc_data_structures/binary_search_util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,5 +1,5 @@\n #[cfg(test)]\n-mod test;\n+mod tests;\n \n /// Uses a sorted slice `data: &[E]` as a kind of \"multi-map\". The\n /// `key_fn` extracts a key of type `K` from the data, and this"}, {"sha": "d74febb5c0fc4a13e2530de71982520e3a944fcf", "filename": "src/librustc_data_structures/binary_search_util/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbinary_search_util%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "previous_filename": "src/librustc_data_structures/binary_search_util/test.rs"}, {"sha": "fe8ef642430adcc6bd7628034a61208be730b4b0", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 2, "deletions": 368, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -5,10 +5,9 @@ use std::iter;\n use std::marker::PhantomData;\n use std::mem;\n use std::slice;\n+\n #[cfg(test)]\n-extern crate test;\n-#[cfg(test)]\n-use test::Bencher;\n+mod tests;\n \n pub type Word = u64;\n pub const WORD_BYTES: usize = mem::size_of::<Word>();\n@@ -983,368 +982,3 @@ fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n     let mask = 1 << (elem % WORD_BITS);\n     (word_index, mask)\n }\n-\n-#[test]\n-fn test_new_filled() {\n-    for i in 0..128 {\n-        let idx_buf = BitSet::new_filled(i);\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..i).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn bitset_iter_works() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(100);\n-    bitset.insert(1);\n-    bitset.insert(10);\n-    bitset.insert(19);\n-    bitset.insert(62);\n-    bitset.insert(63);\n-    bitset.insert(64);\n-    bitset.insert(65);\n-    bitset.insert(66);\n-    bitset.insert(99);\n-    assert_eq!(\n-        bitset.iter().collect::<Vec<_>>(),\n-        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n-    );\n-}\n-\n-#[test]\n-fn bitset_iter_works_2() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n-    bitset.insert(0);\n-    bitset.insert(127);\n-    bitset.insert(191);\n-    bitset.insert(255);\n-    bitset.insert(319);\n-    assert_eq!(bitset.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n-}\n-\n-#[test]\n-fn union_two_sets() {\n-    let mut set1: BitSet<usize> = BitSet::new_empty(65);\n-    let mut set2: BitSet<usize> = BitSet::new_empty(65);\n-    assert!(set1.insert(3));\n-    assert!(!set1.insert(3));\n-    assert!(set2.insert(5));\n-    assert!(set2.insert(64));\n-    assert!(set1.union(&set2));\n-    assert!(!set1.union(&set2));\n-    assert!(set1.contains(3));\n-    assert!(!set1.contains(4));\n-    assert!(set1.contains(5));\n-    assert!(!set1.contains(63));\n-    assert!(set1.contains(64));\n-}\n-\n-#[test]\n-fn hybrid_bitset() {\n-    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    assert!(sparse038.is_empty());\n-    assert!(sparse038.insert(0));\n-    assert!(sparse038.insert(1));\n-    assert!(sparse038.insert(8));\n-    assert!(sparse038.insert(3));\n-    assert!(!sparse038.insert(3));\n-    assert!(sparse038.remove(1));\n-    assert!(!sparse038.is_empty());\n-    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n-\n-    for i in 0..256 {\n-        if i == 0 || i == 3 || i == 8 {\n-            assert!(sparse038.contains(i));\n-        } else {\n-            assert!(!sparse038.contains(i));\n-        }\n-    }\n-\n-    let mut sparse01358 = sparse038.clone();\n-    assert!(sparse01358.insert(1));\n-    assert!(sparse01358.insert(5));\n-    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n-\n-    let mut dense10 = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(dense10.insert(i));\n-    }\n-    assert!(!dense10.is_empty());\n-    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n-\n-    let mut dense256 = HybridBitSet::new_empty(256);\n-    assert!(dense256.is_empty());\n-    dense256.insert_all();\n-    assert!(!dense256.is_empty());\n-    for i in 0..256 {\n-        assert!(dense256.contains(i));\n-    }\n-\n-    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n-    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n-    assert!(dense10.superset(&sparse038));      // dense + sparse\n-    assert!(dense10.superset(&dense10));        // dense + dense (self)\n-    assert!(dense256.superset(&dense10));       // dense + dense\n-\n-    let mut hybrid = sparse038;\n-    assert!(!sparse01358.union(&hybrid));       // no change\n-    assert!(hybrid.union(&sparse01358));\n-    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n-    assert!(!dense10.union(&sparse01358));\n-    assert!(!dense256.union(&dense10));\n-    let mut dense = dense10;\n-    assert!(dense.union(&dense256));\n-    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n-    assert!(hybrid.union(&dense256));\n-    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n-\n-    assert_eq!(dense256.iter().count(), 256);\n-    let mut dense0 = dense256;\n-    for i in 0..256 {\n-        assert!(dense0.remove(i));\n-    }\n-    assert!(!dense0.remove(0));\n-    assert!(dense0.is_empty());\n-}\n-\n-#[test]\n-fn grow() {\n-    let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);\n-    for index in 0..65 {\n-        assert!(set.insert(index));\n-        assert!(!set.insert(index));\n-    }\n-    set.ensure(128);\n-\n-    // Check if the bits set before growing are still set\n-    for index in 0..65 {\n-        assert!(set.contains(index));\n-    }\n-\n-    // Check if the new bits are all un-set\n-    for index in 65..128 {\n-        assert!(!set.contains(index));\n-    }\n-\n-    // Check that we can set all new bits without running out of bounds\n-    for index in 65..128 {\n-        assert!(set.insert(index));\n-        assert!(!set.insert(index));\n-    }\n-}\n-\n-#[test]\n-fn matrix_intersection() {\n-    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n-\n-    // (*) Elements reachable from both 2 and 65.\n-\n-    matrix.insert(2, 3);\n-    matrix.insert(2, 6);\n-    matrix.insert(2, 10); // (*)\n-    matrix.insert(2, 64); // (*)\n-    matrix.insert(2, 65);\n-    matrix.insert(2, 130);\n-    matrix.insert(2, 160); // (*)\n-\n-    matrix.insert(64, 133);\n-\n-    matrix.insert(65, 2);\n-    matrix.insert(65, 8);\n-    matrix.insert(65, 10); // (*)\n-    matrix.insert(65, 64); // (*)\n-    matrix.insert(65, 68);\n-    matrix.insert(65, 133);\n-    matrix.insert(65, 160); // (*)\n-\n-    let intersection = matrix.intersect_rows(2, 64);\n-    assert!(intersection.is_empty());\n-\n-    let intersection = matrix.intersect_rows(2, 65);\n-    assert_eq!(intersection, &[10, 64, 160]);\n-}\n-\n-#[test]\n-fn matrix_iter() {\n-    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n-    matrix.insert(3, 22);\n-    matrix.insert(3, 75);\n-    matrix.insert(2, 99);\n-    matrix.insert(4, 0);\n-    matrix.union_rows(3, 5);\n-    matrix.insert_all_into_row(6);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(3), expected.len());\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(4), expected.len());\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    assert_eq!(matrix.count(5), expected.len());\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    assert_eq!(matrix.count(6), 100);\n-    let mut count = 0;\n-    for (idx, i) in matrix.iter(6).enumerate() {\n-        assert_eq!(idx, i);\n-        count += 1;\n-    }\n-    assert_eq!(count, 100);\n-\n-    if let Some(i) = matrix.iter(7).next() {\n-        panic!(\"expected no elements in row, but contains element {:?}\", i);\n-    }\n-}\n-\n-#[test]\n-fn sparse_matrix_iter() {\n-    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n-    matrix.insert(3, 22);\n-    matrix.insert(3, 75);\n-    matrix.insert(2, 99);\n-    matrix.insert(4, 0);\n-    matrix.union_rows(3, 5);\n-\n-    let expected = [99];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(2) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(3) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [0];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(4) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-\n-    let expected = [22, 75];\n-    let mut iter = expected.iter();\n-    for i in matrix.iter(5) {\n-        let j = *iter.next().unwrap();\n-        assert_eq!(i, j);\n-    }\n-    assert!(iter.next().is_none());\n-}\n-\n-/// Merge dense hybrid set into empty sparse hybrid set.\n-#[bench]\n-fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set with same indices.\n-#[bench]\n-fn union_hybrid_sparse_full_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set with indices over the whole domain.\n-#[bench]\n-fn union_hybrid_sparse_domain_to_dense(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n-    for i in 0..10 {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i*64));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into empty hybrid set where the domain is very small.\n-#[bench]\n-fn union_hybrid_sparse_empty_small_domain(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}\n-\n-/// Merge dense hybrid set into full hybrid set where the domain is very small.\n-#[bench]\n-fn union_hybrid_sparse_full_small_domain(b: &mut Bencher) {\n-    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_dense.insert(i));\n-    }\n-    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n-    for i in 0..SPARSE_MAX {\n-        assert!(pre_sparse.insert(i));\n-    }\n-    b.iter(|| {\n-        let dense = pre_dense.clone();\n-        let mut sparse = pre_sparse.clone();\n-        sparse.union(&dense);\n-    })\n-}"}, {"sha": "ac7913815ffd434fce82663fd2263ec4af5bcb1f", "filename": "src/librustc_data_structures/bit_set/tests.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,369 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[test]\n+fn test_new_filled() {\n+    for i in 0..128 {\n+        let idx_buf = BitSet::new_filled(i);\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..i).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn bitset_iter_works() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(100);\n+    bitset.insert(1);\n+    bitset.insert(10);\n+    bitset.insert(19);\n+    bitset.insert(62);\n+    bitset.insert(63);\n+    bitset.insert(64);\n+    bitset.insert(65);\n+    bitset.insert(66);\n+    bitset.insert(99);\n+    assert_eq!(\n+        bitset.iter().collect::<Vec<_>>(),\n+        [1, 10, 19, 62, 63, 64, 65, 66, 99]\n+    );\n+}\n+\n+#[test]\n+fn bitset_iter_works_2() {\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n+    bitset.insert(0);\n+    bitset.insert(127);\n+    bitset.insert(191);\n+    bitset.insert(255);\n+    bitset.insert(319);\n+    assert_eq!(bitset.iter().collect::<Vec<_>>(), [0, 127, 191, 255, 319]);\n+}\n+\n+#[test]\n+fn union_two_sets() {\n+    let mut set1: BitSet<usize> = BitSet::new_empty(65);\n+    let mut set2: BitSet<usize> = BitSet::new_empty(65);\n+    assert!(set1.insert(3));\n+    assert!(!set1.insert(3));\n+    assert!(set2.insert(5));\n+    assert!(set2.insert(64));\n+    assert!(set1.union(&set2));\n+    assert!(!set1.union(&set2));\n+    assert!(set1.contains(3));\n+    assert!(!set1.contains(4));\n+    assert!(set1.contains(5));\n+    assert!(!set1.contains(63));\n+    assert!(set1.contains(64));\n+}\n+\n+#[test]\n+fn hybrid_bitset() {\n+    let mut sparse038: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    assert!(sparse038.is_empty());\n+    assert!(sparse038.insert(0));\n+    assert!(sparse038.insert(1));\n+    assert!(sparse038.insert(8));\n+    assert!(sparse038.insert(3));\n+    assert!(!sparse038.insert(3));\n+    assert!(sparse038.remove(1));\n+    assert!(!sparse038.is_empty());\n+    assert_eq!(sparse038.iter().collect::<Vec<_>>(), [0, 3, 8]);\n+\n+    for i in 0..256 {\n+        if i == 0 || i == 3 || i == 8 {\n+            assert!(sparse038.contains(i));\n+        } else {\n+            assert!(!sparse038.contains(i));\n+        }\n+    }\n+\n+    let mut sparse01358 = sparse038.clone();\n+    assert!(sparse01358.insert(1));\n+    assert!(sparse01358.insert(5));\n+    assert_eq!(sparse01358.iter().collect::<Vec<_>>(), [0, 1, 3, 5, 8]);\n+\n+    let mut dense10 = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(dense10.insert(i));\n+    }\n+    assert!(!dense10.is_empty());\n+    assert_eq!(dense10.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut dense256 = HybridBitSet::new_empty(256);\n+    assert!(dense256.is_empty());\n+    dense256.insert_all();\n+    assert!(!dense256.is_empty());\n+    for i in 0..256 {\n+        assert!(dense256.contains(i));\n+    }\n+\n+    assert!(sparse038.superset(&sparse038));    // sparse + sparse (self)\n+    assert!(sparse01358.superset(&sparse038));  // sparse + sparse\n+    assert!(dense10.superset(&sparse038));      // dense + sparse\n+    assert!(dense10.superset(&dense10));        // dense + dense (self)\n+    assert!(dense256.superset(&dense10));       // dense + dense\n+\n+    let mut hybrid = sparse038;\n+    assert!(!sparse01358.union(&hybrid));       // no change\n+    assert!(hybrid.union(&sparse01358));\n+    assert!(hybrid.superset(&sparse01358) && sparse01358.superset(&hybrid));\n+    assert!(!dense10.union(&sparse01358));\n+    assert!(!dense256.union(&dense10));\n+    let mut dense = dense10;\n+    assert!(dense.union(&dense256));\n+    assert!(dense.superset(&dense256) && dense256.superset(&dense));\n+    assert!(hybrid.union(&dense256));\n+    assert!(hybrid.superset(&dense256) && dense256.superset(&hybrid));\n+\n+    assert_eq!(dense256.iter().count(), 256);\n+    let mut dense0 = dense256;\n+    for i in 0..256 {\n+        assert!(dense0.remove(i));\n+    }\n+    assert!(!dense0.remove(0));\n+    assert!(dense0.is_empty());\n+}\n+\n+#[test]\n+fn grow() {\n+    let mut set: GrowableBitSet<usize> = GrowableBitSet::with_capacity(65);\n+    for index in 0..65 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+    set.ensure(128);\n+\n+    // Check if the bits set before growing are still set\n+    for index in 0..65 {\n+        assert!(set.contains(index));\n+    }\n+\n+    // Check if the new bits are all un-set\n+    for index in 65..128 {\n+        assert!(!set.contains(index));\n+    }\n+\n+    // Check that we can set all new bits without running out of bounds\n+    for index in 65..128 {\n+        assert!(set.insert(index));\n+        assert!(!set.insert(index));\n+    }\n+}\n+\n+#[test]\n+fn matrix_intersection() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n+\n+    // (*) Elements reachable from both 2 and 65.\n+\n+    matrix.insert(2, 3);\n+    matrix.insert(2, 6);\n+    matrix.insert(2, 10); // (*)\n+    matrix.insert(2, 64); // (*)\n+    matrix.insert(2, 65);\n+    matrix.insert(2, 130);\n+    matrix.insert(2, 160); // (*)\n+\n+    matrix.insert(64, 133);\n+\n+    matrix.insert(65, 2);\n+    matrix.insert(65, 8);\n+    matrix.insert(65, 10); // (*)\n+    matrix.insert(65, 64); // (*)\n+    matrix.insert(65, 68);\n+    matrix.insert(65, 133);\n+    matrix.insert(65, 160); // (*)\n+\n+    let intersection = matrix.intersect_rows(2, 64);\n+    assert!(intersection.is_empty());\n+\n+    let intersection = matrix.intersect_rows(2, 65);\n+    assert_eq!(intersection, &[10, 64, 160]);\n+}\n+\n+#[test]\n+fn matrix_iter() {\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+    matrix.insert_all_into_row(6);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(3), expected.len());\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(4), expected.len());\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    assert_eq!(matrix.count(5), expected.len());\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    assert_eq!(matrix.count(6), 100);\n+    let mut count = 0;\n+    for (idx, i) in matrix.iter(6).enumerate() {\n+        assert_eq!(idx, i);\n+        count += 1;\n+    }\n+    assert_eq!(count, 100);\n+\n+    if let Some(i) = matrix.iter(7).next() {\n+        panic!(\"expected no elements in row, but contains element {:?}\", i);\n+    }\n+}\n+\n+#[test]\n+fn sparse_matrix_iter() {\n+    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n+    matrix.insert(3, 22);\n+    matrix.insert(3, 75);\n+    matrix.insert(2, 99);\n+    matrix.insert(4, 0);\n+    matrix.union_rows(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}\n+\n+/// Merge dense hybrid set into empty sparse hybrid set.\n+#[bench]\n+fn union_hybrid_sparse_empty_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with same indices.\n+#[bench]\n+fn union_hybrid_sparse_full_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(256);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set with indices over the whole domain.\n+#[bench]\n+fn union_hybrid_sparse_domain_to_dense(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..10 {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX*64);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i*64));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into empty hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_empty_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}\n+\n+/// Merge dense hybrid set into full hybrid set where the domain is very small.\n+#[bench]\n+fn union_hybrid_sparse_full_small_domain(b: &mut Bencher) {\n+    let mut pre_dense: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_dense.insert(i));\n+    }\n+    let mut pre_sparse: HybridBitSet<usize> = HybridBitSet::new_empty(SPARSE_MAX);\n+    for i in 0..SPARSE_MAX {\n+        assert!(pre_sparse.insert(i));\n+    }\n+    b.iter(|| {\n+        let dense = pre_dense.clone();\n+        let mut sparse = pre_sparse.clone();\n+        sparse.union(&dense);\n+    })\n+}"}, {"sha": "41e6b72953e83211d8dbe9d4ba61c815f071e89a", "filename": "src/librustc_data_structures/graph/dominators/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -9,7 +9,7 @@ use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     let start_node = graph.start_node();\n@@ -127,11 +127,6 @@ impl<Node: Idx> Dominators<Node> {\n         // FIXME -- could be optimized by using post-order-rank\n         self.dominators(node).any(|n| n == dom)\n     }\n-\n-    #[cfg(test)]\n-    fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n-        &self.immediate_dominators\n-    }\n }\n \n pub struct Iter<'dom, Node: Idx> {"}, {"sha": "92301ff6526d107dd454b3aae881b7c9a2671fd5", "filename": "src/librustc_data_structures/graph/dominators/tests.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fdominators%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,13 +1,13 @@\n-use super::super::test::TestGraph;\n-\n use super::*;\n \n+use super::super::tests::TestGraph;\n+\n #[test]\n fn diamond() {\n     let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n \n     let dominators = dominators(&graph);\n-    let immediate_dominators = dominators.all_immediate_dominators();\n+    let immediate_dominators = &dominators.immediate_dominators;\n     assert_eq!(immediate_dominators[0], Some(0));\n     assert_eq!(immediate_dominators[1], Some(0));\n     assert_eq!(immediate_dominators[2], Some(0));\n@@ -22,7 +22,7 @@ fn paper() {\n                                  (2, 1)]);\n \n     let dominators = dominators(&graph);\n-    let immediate_dominators = dominators.all_immediate_dominators();\n+    let immediate_dominators = &dominators.immediate_dominators;\n     assert_eq!(immediate_dominators[0], None); // <-- note that 0 is not in graph\n     assert_eq!(immediate_dominators[1], Some(6));\n     assert_eq!(immediate_dominators[2], Some(6));", "previous_filename": "src/librustc_data_structures/graph/dominators/test.rs"}, {"sha": "c4185fc7cd9c3f60b52960473f8ea176d39042d4", "filename": "src/librustc_data_structures/graph/iterate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -3,7 +3,7 @@ use super::{DirectedGraph, WithNumNodes, WithSuccessors};\n use crate::bit_set::BitSet;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub fn post_order_from<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n     graph: &G,"}, {"sha": "6c7cfd6d8a7779852ac38d555c048e8cf7b06eee", "filename": "src/librustc_data_structures/graph/iterate/tests.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fiterate%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,4 +1,4 @@\n-use super::super::test::TestGraph;\n+use super::super::tests::TestGraph;\n \n use super::*;\n ", "previous_filename": "src/librustc_data_structures/graph/iterate/test.rs"}, {"sha": "662581ca1e4984d6a5808f282e5fa433aec04388", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -8,7 +8,7 @@ pub mod scc;\n pub mod vec_graph;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub trait DirectedGraph {\n     type Node: Idx;"}, {"sha": "23a1a2a90a4d52fee2f6fff34f76ab1e023b3056", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -9,7 +9,8 @@ use crate::graph::vec_graph::VecGraph;\n use crate::indexed_vec::{Idx, IndexVec};\n use std::ops::Range;\n \n-mod test;\n+#[cfg(test)]\n+mod tests;\n \n /// Strongly connected components (SCC) of a graph. The type `N` is\n /// the index type for the graph nodes and `S` is the index type for"}, {"sha": "6da3ac0ecb8b9b59a36b06be6b5d6d8cd36e14ff", "filename": "src/librustc_data_structures/graph/scc/tests.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,6 +1,4 @@\n-#![cfg(test)]\n-\n-use crate::graph::test::TestGraph;\n+use crate::graph::tests::TestGraph;\n use super::*;\n \n #[test]", "previous_filename": "src/librustc_data_structures/graph/scc/test.rs"}, {"sha": "bc142144e930f24e8790df0d40e4b13dc1c8fff3", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "previous_filename": "src/librustc_data_structures/graph/test.rs"}, {"sha": "19c61f2680d1d9a5dba559462f3000d7b4af143b", "filename": "src/librustc_data_structures/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -2,7 +2,7 @@ use crate::indexed_vec::{Idx, IndexVec};\n use crate::graph::{DirectedGraph, WithNumNodes, WithNumEdges, WithSuccessors, GraphSuccessors};\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub struct VecGraph<N: Idx> {\n     /// Maps from a given node to an index where the set of successors"}, {"sha": "97a9bd2ad0b08c74fb5528ddcef46aab09669409", "filename": "src/librustc_data_structures/graph/vec_graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fvec_graph%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "previous_filename": "src/librustc_data_structures/graph/vec_graph/test.rs"}, {"sha": "04d2b23ab1a1c4ee36b72d7e301e3a0f7e01bc55", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -94,7 +94,7 @@ use self::node_index::NodeIndex;\n mod graphviz;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub trait ForestObligation : Clone + Debug {\n     type Predicate : Clone + hash::Hash + Eq + Debug;"}, {"sha": "e20466572a26f43d1c4785954022e6fda610b0f4", "filename": "src/librustc_data_structures/obligation_forest/tests.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,6 +1,4 @@\n-#![cfg(test)]\n-\n-use super::{Error, DoCompleted, ObligationForest, ObligationProcessor, Outcome, ProcessResult};\n+use super::*;\n \n use std::fmt;\n use std::marker::PhantomData;", "previous_filename": "src/librustc_data_structures/obligation_forest/test.rs"}, {"sha": "1c58eda24f459be23ec2fbb0c4808d1ba672f5c3", "filename": "src/librustc_data_structures/sip128.rs", "status": "modified", "additions": 3, "deletions": 230, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -6,6 +6,9 @@ use std::slice;\n use std::ptr;\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Debug, Clone)]\n pub struct SipHasher128 {\n     k0: u64,\n@@ -291,233 +294,3 @@ impl Sip24Rounds {\n         compress!(state);\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use std::hash::{Hash, Hasher};\n-    use std::{slice, mem};\n-    use super::SipHasher128;\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'a>(&'a [u8]);\n-\n-    impl<'a> Hash for Bytes<'a> {\n-        #[allow(unused_must_use)]\n-        fn hash<H: Hasher>(&self, state: &mut H) {\n-            for byte in self.0 {\n-                state.write_u8(*byte);\n-            }\n-        }\n-    }\n-\n-    fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n-        x.hash(&mut st);\n-        st.finish128()\n-    }\n-\n-    fn hash<T: Hash>(x: &T) -> (u64, u64) {\n-        hash_with(SipHasher128::new_with_keys(0, 0), x)\n-    }\n-\n-    const TEST_VECTOR : [[u8; 16]; 64] = [\n-        [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n-        [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n-        [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n-        [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n-        [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n-        [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n-        [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n-        [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n-        [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n-        [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n-        [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n-        [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n-        [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n-        [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n-        [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n-        [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n-        [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n-        [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n-        [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n-        [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n-        [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n-        [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n-        [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n-        [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n-        [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n-        [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n-        [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n-        [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n-        [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n-        [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n-        [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n-        [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n-        [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n-        [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n-        [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n-        [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n-        [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n-        [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n-        [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n-        [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n-        [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n-        [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n-        [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n-        [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n-        [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n-        [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n-        [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n-        [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n-        [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n-        [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n-        [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n-        [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n-        [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n-        [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n-        [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n-        [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n-        [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n-        [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n-        [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n-        [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n-        [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n-        [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n-        [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n-        [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n-    ];\n-\n-    // Test vector from reference implementation\n-    #[test]\n-    fn test_siphash_2_4_test_vector() {\n-        let k0 = 0x_07_06_05_04_03_02_01_00;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n-\n-        let mut input: Vec<u8> = Vec::new();\n-\n-        for i in 0 .. 64 {\n-            let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n-                                &Bytes(&input[..]));\n-            let expected = (\n-                ((TEST_VECTOR[i][0] as u64) <<  0) |\n-                ((TEST_VECTOR[i][1] as u64) <<  8) |\n-                ((TEST_VECTOR[i][2] as u64) << 16) |\n-                ((TEST_VECTOR[i][3] as u64) << 24) |\n-                ((TEST_VECTOR[i][4] as u64) << 32) |\n-                ((TEST_VECTOR[i][5] as u64) << 40) |\n-                ((TEST_VECTOR[i][6] as u64) << 48) |\n-                ((TEST_VECTOR[i][7] as u64) << 56),\n-\n-                ((TEST_VECTOR[i][8] as u64) <<  0) |\n-                ((TEST_VECTOR[i][9] as u64) <<  8) |\n-                ((TEST_VECTOR[i][10] as u64) << 16) |\n-                ((TEST_VECTOR[i][11] as u64) << 24) |\n-                ((TEST_VECTOR[i][12] as u64) << 32) |\n-                ((TEST_VECTOR[i][13] as u64) << 40) |\n-                ((TEST_VECTOR[i][14] as u64) << 48) |\n-                ((TEST_VECTOR[i][15] as u64) << 56),\n-            );\n-\n-            assert_eq!(out, expected);\n-            input.push(i as u8);\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n-        assert!(hash(&(val as u32)) != hash(&(val as usize)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_usize() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&val64), hash(&val64));\n-        let val32 = 0xdeadbeef_u32;\n-        assert_eq!(hash(&val32), hash(&val32));\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n-\n-        fn zero_byte(val: u64, byte: usize) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-\n-        fn zero_byte(val: u32, byte: usize) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        assert!(s != t && t != u);\n-        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n-\n-        let u = [1, 0, 0, 0];\n-        let v = (&u[..1], &u[1..3], &u[3..]);\n-        let w = (&u[..], &u[4..4], &u[4..4]);\n-\n-        assert!(v != w);\n-        assert!(hash(&v) != hash(&w));\n-    }\n-\n-    #[test]\n-    fn test_write_short_works() {\n-        let test_usize = 0xd0c0b0a0usize;\n-        let mut h1 = SipHasher128::new_with_keys(0, 0);\n-        h1.write_usize(test_usize);\n-        h1.write(b\"bytes\");\n-        h1.write(b\"string\");\n-        h1.write_u8(0xFFu8);\n-        h1.write_u8(0x01u8);\n-        let mut h2 = SipHasher128::new_with_keys(0, 0);\n-        h2.write(unsafe {\n-            slice::from_raw_parts(&test_usize as *const _ as *const u8,\n-                                  mem::size_of::<usize>())\n-        });\n-        h2.write(b\"bytes\");\n-        h2.write(b\"string\");\n-        h2.write(&[0xFFu8, 0x01u8]);\n-        assert_eq!(h1.finish128(), h2.finish128());\n-    }\n-\n-}"}, {"sha": "90cc54448b40737a7c1bf82d7a39e78fed13558c", "filename": "src/librustc_data_structures/sip128/tests.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,226 @@\n+use super::*;\n+\n+use std::hash::{Hash, Hasher};\n+use std::{slice, mem};\n+\n+// Hash just the bytes of the slice, without length prefix\n+struct Bytes<'a>(&'a [u8]);\n+\n+impl<'a> Hash for Bytes<'a> {\n+    #[allow(unused_must_use)]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        for byte in self.0 {\n+            state.write_u8(*byte);\n+        }\n+    }\n+}\n+\n+fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n+    x.hash(&mut st);\n+    st.finish128()\n+}\n+\n+fn hash<T: Hash>(x: &T) -> (u64, u64) {\n+    hash_with(SipHasher128::new_with_keys(0, 0), x)\n+}\n+\n+const TEST_VECTOR : [[u8; 16]; 64] = [\n+    [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n+    [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n+    [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n+    [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n+    [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n+    [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n+    [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n+    [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n+    [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n+    [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n+    [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n+    [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n+    [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n+    [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n+    [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n+    [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n+    [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n+    [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n+    [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n+    [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n+    [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n+    [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n+    [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n+    [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n+    [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n+    [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n+    [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n+    [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n+    [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n+    [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n+    [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n+    [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n+    [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n+    [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n+    [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n+    [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n+    [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n+    [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n+    [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n+    [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n+    [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n+    [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n+    [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n+    [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n+    [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n+    [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n+    [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n+    [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n+    [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n+    [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n+    [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n+    [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n+    [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n+    [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n+    [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n+    [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n+    [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n+    [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n+    [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n+    [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n+    [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n+    [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n+    [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n+    [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n+];\n+\n+// Test vector from reference implementation\n+#[test]\n+fn test_siphash_2_4_test_vector() {\n+    let k0 = 0x_07_06_05_04_03_02_01_00;\n+    let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+\n+    let mut input: Vec<u8> = Vec::new();\n+\n+    for i in 0 .. 64 {\n+        let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n+                            &Bytes(&input[..]));\n+        let expected = (\n+            ((TEST_VECTOR[i][0] as u64) <<  0) |\n+            ((TEST_VECTOR[i][1] as u64) <<  8) |\n+            ((TEST_VECTOR[i][2] as u64) << 16) |\n+            ((TEST_VECTOR[i][3] as u64) << 24) |\n+            ((TEST_VECTOR[i][4] as u64) << 32) |\n+            ((TEST_VECTOR[i][5] as u64) << 40) |\n+            ((TEST_VECTOR[i][6] as u64) << 48) |\n+            ((TEST_VECTOR[i][7] as u64) << 56),\n+\n+            ((TEST_VECTOR[i][8] as u64) <<  0) |\n+            ((TEST_VECTOR[i][9] as u64) <<  8) |\n+            ((TEST_VECTOR[i][10] as u64) << 16) |\n+            ((TEST_VECTOR[i][11] as u64) << 24) |\n+            ((TEST_VECTOR[i][12] as u64) << 32) |\n+            ((TEST_VECTOR[i][13] as u64) << 40) |\n+            ((TEST_VECTOR[i][14] as u64) << 48) |\n+            ((TEST_VECTOR[i][15] as u64) << 56),\n+        );\n+\n+        assert_eq!(out, expected);\n+        input.push(i as u8);\n+    }\n+}\n+\n+#[test] #[cfg(target_arch = \"arm\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+}\n+#[test] #[cfg(target_arch = \"x86_64\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+    assert!(hash(&(val as u32)) != hash(&(val as usize)));\n+}\n+#[test] #[cfg(target_arch = \"x86\")]\n+fn test_hash_usize() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+}\n+\n+#[test]\n+fn test_hash_idempotent() {\n+    let val64 = 0xdeadbeef_deadbeef_u64;\n+    assert_eq!(hash(&val64), hash(&val64));\n+    let val32 = 0xdeadbeef_u32;\n+    assert_eq!(hash(&val32), hash(&val32));\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_64() {\n+    let val = 0xdeadbeef_deadbeef_u64;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+    fn zero_byte(val: u64, byte: usize) -> u64 {\n+        assert!(byte < 8);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_bytes_dropped_32() {\n+    let val = 0xdeadbeef_u32;\n+\n+    assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+    assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+    fn zero_byte(val: u32, byte: usize) -> u32 {\n+        assert!(byte < 4);\n+        val & !(0xff << (byte * 8))\n+    }\n+}\n+\n+#[test]\n+fn test_hash_no_concat_alias() {\n+    let s = (\"aa\", \"bb\");\n+    let t = (\"aabb\", \"\");\n+    let u = (\"a\", \"abb\");\n+\n+    assert!(s != t && t != u);\n+    assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+    let u = [1, 0, 0, 0];\n+    let v = (&u[..1], &u[1..3], &u[3..]);\n+    let w = (&u[..], &u[4..4], &u[4..4]);\n+\n+    assert!(v != w);\n+    assert!(hash(&v) != hash(&w));\n+}\n+\n+#[test]\n+fn test_write_short_works() {\n+    let test_usize = 0xd0c0b0a0usize;\n+    let mut h1 = SipHasher128::new_with_keys(0, 0);\n+    h1.write_usize(test_usize);\n+    h1.write(b\"bytes\");\n+    h1.write(b\"string\");\n+    h1.write_u8(0xFFu8);\n+    h1.write_u8(0x01u8);\n+    let mut h2 = SipHasher128::new_with_keys(0, 0);\n+    h2.write(unsafe {\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                                mem::size_of::<usize>())\n+    });\n+    h2.write(b\"bytes\");\n+    h2.write(b\"string\");\n+    h2.write(&[0xFFu8, 0x01u8]);\n+    assert_eq!(h1.finish128(), h2.finish128());\n+}"}, {"sha": "9d90b9052d1c200f9724c1e8ddb1c6bd01072a2b", "filename": "src/librustc_data_structures/small_c_str.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -3,6 +3,9 @@ use std::ops::Deref;\n \n use smallvec::SmallVec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const SIZE: usize = 36;\n \n /// Like SmallVec but for C strings.\n@@ -66,47 +69,3 @@ impl Deref for SmallCStr {\n         self.as_c_str()\n     }\n }\n-\n-#[test]\n-fn short() {\n-    const TEXT: &str = \"abcd\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(!scs.spilled());\n-}\n-\n-#[test]\n-fn empty() {\n-    const TEXT: &str = \"\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(!scs.spilled());\n-}\n-\n-#[test]\n-fn long() {\n-    const TEXT: &str = \"01234567890123456789012345678901234567890123456789\\\n-                        01234567890123456789012345678901234567890123456789\\\n-                        01234567890123456789012345678901234567890123456789\";\n-    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n-\n-    let scs = SmallCStr::new(TEXT);\n-\n-    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n-    assert_eq!(scs.as_c_str(), reference.as_c_str());\n-    assert!(scs.spilled());\n-}\n-\n-#[test]\n-#[should_panic]\n-fn internal_nul() {\n-    let _ = SmallCStr::new(\"abcd\\0def\");\n-}"}, {"sha": "47277604b2b71e8a5da91d85cb8b2c11e550c3e1", "filename": "src/librustc_data_structures/small_c_str/tests.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_c_str%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,45 @@\n+use super::*;\n+\n+#[test]\n+fn short() {\n+    const TEXT: &str = \"abcd\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(!scs.spilled());\n+}\n+\n+#[test]\n+fn empty() {\n+    const TEXT: &str = \"\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(!scs.spilled());\n+}\n+\n+#[test]\n+fn long() {\n+    const TEXT: &str = \"01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\\\n+                        01234567890123456789012345678901234567890123456789\";\n+    let reference = ffi::CString::new(TEXT.to_string()).unwrap();\n+\n+    let scs = SmallCStr::new(TEXT);\n+\n+    assert_eq!(scs.len_with_nul(), TEXT.len() + 1);\n+    assert_eq!(scs.as_c_str(), reference.as_c_str());\n+    assert!(scs.spilled());\n+}\n+\n+#[test]\n+#[should_panic]\n+fn internal_nul() {\n+    let _ = SmallCStr::new(\"abcd\\0def\");\n+}"}, {"sha": "ce0aa07cc282c4787d39a6a2ddb34799ccc5d356", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -4,7 +4,7 @@ use std::ops;\n use std::mem;\n \n #[cfg(test)]\n-mod test;\n+mod tests;\n \n pub struct SnapshotMap<K, V>\n     where K: Hash + Clone + Eq"}, {"sha": "72ca53c2be9ed2fe2750444de3f037aee806bd9f", "filename": "src/librustc_data_structures/snapshot_map/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "previous_filename": "src/librustc_data_structures/snapshot_map/test.rs"}, {"sha": "1c0d9360f2511217816ab2a0b4ddc52187511474", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 3, "deletions": 136, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -11,6 +11,9 @@\n //! If you expect to store more than 1 element in the common case, steer clear\n //! and use a `Vec<T>`, `Box<[T]>`, or a `SmallVec<T>`.\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Hash, Debug, PartialEq)]\n pub struct TinyList<T: PartialEq> {\n     head: Option<Element<T>>\n@@ -118,139 +121,3 @@ impl<T: PartialEq> Element<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    extern crate test;\n-    use test::Bencher;\n-\n-    #[test]\n-    fn test_contains_and_insert() {\n-        fn do_insert(i : u32) -> bool {\n-            i % 2 == 0\n-        }\n-\n-        let mut list = TinyList::new();\n-\n-        for i in 0 .. 10 {\n-            for j in 0 .. i {\n-                if do_insert(j) {\n-                    assert!(list.contains(&j));\n-                } else {\n-                    assert!(!list.contains(&j));\n-                }\n-            }\n-\n-            assert!(!list.contains(&i));\n-\n-            if do_insert(i) {\n-                list.insert(i);\n-                assert!(list.contains(&i));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove_first() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&4));\n-        assert!(!list.contains(&4));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&1));\n-        assert!(list.contains(&2));\n-        assert!(list.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_remove_last() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&1));\n-        assert!(!list.contains(&1));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&2));\n-        assert!(list.contains(&3));\n-        assert!(list.contains(&4));\n-    }\n-\n-    #[test]\n-    fn test_remove_middle() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        list.insert(2);\n-        list.insert(3);\n-        list.insert(4);\n-        assert_eq!(list.len(), 4);\n-\n-        assert!(list.remove(&2));\n-        assert!(!list.contains(&2));\n-\n-        assert_eq!(list.len(), 3);\n-        assert!(list.contains(&1));\n-        assert!(list.contains(&3));\n-        assert!(list.contains(&4));\n-    }\n-\n-    #[test]\n-    fn test_remove_single() {\n-        let mut list = TinyList::new();\n-        list.insert(1);\n-        assert_eq!(list.len(), 1);\n-\n-        assert!(list.remove(&1));\n-        assert!(!list.contains(&1));\n-\n-        assert_eq!(list.len(), 0);\n-    }\n-\n-    #[bench]\n-    fn bench_insert_empty(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut list = TinyList::new();\n-            list.insert(1);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_insert_one(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut list = TinyList::new_single(0);\n-            list.insert(1);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_remove_empty(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new().remove(&1)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove_unknown(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new_single(0).remove(&1)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_remove_one(b: &mut Bencher) {\n-        b.iter(|| {\n-            TinyList::new_single(1).remove(&1)\n-        });\n-    }\n-}"}, {"sha": "8374659e1e67b021d9ef0761b90e58406d8e94ca", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,133 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+\n+#[test]\n+fn test_contains_and_insert() {\n+    fn do_insert(i : u32) -> bool {\n+        i % 2 == 0\n+    }\n+\n+    let mut list = TinyList::new();\n+\n+    for i in 0 .. 10 {\n+        for j in 0 .. i {\n+            if do_insert(j) {\n+                assert!(list.contains(&j));\n+            } else {\n+                assert!(!list.contains(&j));\n+            }\n+        }\n+\n+        assert!(!list.contains(&i));\n+\n+        if do_insert(i) {\n+            list.insert(i);\n+            assert!(list.contains(&i));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove_first() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&4));\n+    assert!(!list.contains(&4));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&1));\n+    assert!(list.contains(&2));\n+    assert!(list.contains(&3));\n+}\n+\n+#[test]\n+fn test_remove_last() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&1));\n+    assert!(!list.contains(&1));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&2));\n+    assert!(list.contains(&3));\n+    assert!(list.contains(&4));\n+}\n+\n+#[test]\n+fn test_remove_middle() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    list.insert(2);\n+    list.insert(3);\n+    list.insert(4);\n+    assert_eq!(list.len(), 4);\n+\n+    assert!(list.remove(&2));\n+    assert!(!list.contains(&2));\n+\n+    assert_eq!(list.len(), 3);\n+    assert!(list.contains(&1));\n+    assert!(list.contains(&3));\n+    assert!(list.contains(&4));\n+}\n+\n+#[test]\n+fn test_remove_single() {\n+    let mut list = TinyList::new();\n+    list.insert(1);\n+    assert_eq!(list.len(), 1);\n+\n+    assert!(list.remove(&1));\n+    assert!(!list.contains(&1));\n+\n+    assert_eq!(list.len(), 0);\n+}\n+\n+#[bench]\n+fn bench_insert_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut list = TinyList::new();\n+        list.insert(1);\n+    })\n+}\n+\n+#[bench]\n+fn bench_insert_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        let mut list = TinyList::new_single(0);\n+        list.insert(1);\n+    })\n+}\n+\n+#[bench]\n+fn bench_remove_empty(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new().remove(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_remove_unknown(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new_single(0).remove(&1)\n+    });\n+}\n+\n+#[bench]\n+fn bench_remove_one(b: &mut Bencher) {\n+    b.iter(|| {\n+        TinyList::new_single(1).remove(&1)\n+    });\n+}"}, {"sha": "ffc964ddb5ae2cece3901fe2d2cdc2a6ad5a9bd2", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 356, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -7,6 +7,8 @@ use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n \n #[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n@@ -481,359 +483,3 @@ impl<CTX> HashStable<CTX> for Index {\n         idx.hash_stable(hcx, hasher);\n     }\n }\n-\n-#[test]\n-fn test_one_step() {\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"b\");\n-    relation.add(\"a\", \"c\");\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(!relation.contains(&\"b\", &\"a\"));\n-    assert!(!relation.contains(&\"a\", &\"d\"));\n-}\n-\n-#[test]\n-fn test_many_steps() {\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"b\");\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"a\", \"f\");\n-\n-    relation.add(\"b\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    relation.add(\"e\", \"g\");\n-\n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"d\"));\n-    assert!(relation.contains(&\"a\", &\"e\"));\n-    assert!(relation.contains(&\"a\", &\"f\"));\n-    assert!(relation.contains(&\"a\", &\"g\"));\n-\n-    assert!(relation.contains(&\"b\", &\"g\"));\n-\n-    assert!(!relation.contains(&\"a\", &\"x\"));\n-    assert!(!relation.contains(&\"b\", &\"f\"));\n-}\n-\n-#[test]\n-fn mubs_triangle() {\n-    // a -> tcx\n-    //      ^\n-    //      |\n-    //      b\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"tcx\");\n-    relation.add(\"b\", \"tcx\");\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n-}\n-\n-#[test]\n-fn mubs_best_choice1() {\n-    // 0 -> 1 <- 3\n-    // |    ^    |\n-    // |    |    |\n-    // +--> 2 <--+\n-    //\n-    // mubs(0,3) = [1]\n-\n-    // This tests a particular state in the algorithm, in which we\n-    // need the second pare down call to get the right result (after\n-    // intersection, we have [1, 2], but 2 -> 1).\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"2\", \"1\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n-    assert!(relation.parents(&\"1\").is_empty());\n-}\n-\n-#[test]\n-fn mubs_best_choice2() {\n-    // 0 -> 1 <- 3\n-    // |    |    |\n-    // |    v    |\n-    // +--> 2 <--+\n-    //\n-    // mubs(0,3) = [2]\n-\n-    // Like the precedecing test, but in this case intersection is [2,\n-    // 1], and hence we rely on the first pare down call.\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"1\", \"2\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n-    assert!(relation.parents(&\"2\").is_empty());\n-}\n-\n-#[test]\n-fn mubs_no_best_choice() {\n-    // in this case, the intersection yields [1, 2], and the \"pare\n-    // down\" calls find nothing to remove.\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n-}\n-\n-#[test]\n-fn mubs_best_choice_scc() {\n-    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n-    // consistently).\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"0\", \"1\");\n-    relation.add(\"0\", \"2\");\n-\n-    relation.add(\"1\", \"2\");\n-    relation.add(\"2\", \"1\");\n-\n-    relation.add(\"3\", \"1\");\n-    relation.add(\"3\", \"2\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n-}\n-\n-#[test]\n-fn pdub_crisscross() {\n-    // diagonal edges run left-to-right\n-    // a -> a1 -> x\n-    //   \\/       ^\n-    //   /\\       |\n-    // b -> b1 ---+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"a\", \"b1\");\n-    relation.add(\"b\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-    relation.add(\"a1\", \"x\");\n-    relation.add(\"b1\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n-               vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn pdub_crisscross_more() {\n-    // diagonal edges run left-to-right\n-    // a -> a1 -> a2 -> a3 -> x\n-    //   \\/    \\/             ^\n-    //   /\\    /\\             |\n-    // b -> b1 -> b2 ---------+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"a\", \"b1\");\n-    relation.add(\"b\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-\n-    relation.add(\"a1\", \"a2\");\n-    relation.add(\"a1\", \"b2\");\n-    relation.add(\"b1\", \"a2\");\n-    relation.add(\"b1\", \"b2\");\n-\n-    relation.add(\"a2\", \"a3\");\n-\n-    relation.add(\"a3\", \"x\");\n-    relation.add(\"b2\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n-               vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n-               vec![&\"a2\", &\"b2\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn pdub_lub() {\n-    // a -> a1 -> x\n-    //            ^\n-    //            |\n-    // b -> b1 ---+\n-\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"a1\");\n-    relation.add(\"b\", \"b1\");\n-    relation.add(\"a1\", \"x\");\n-    relation.add(\"b1\", \"x\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n-    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n-}\n-\n-#[test]\n-fn mubs_intermediate_node_on_one_side_only() {\n-    // a -> c -> d\n-    //           ^\n-    //           |\n-    //           b\n-\n-    // \"digraph { a -> c -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"b\", \"d\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_1() {\n-    // +-------------+\n-    // |    +----+   |\n-    // |    v    |   |\n-    // a -> c -> d <-+\n-    //           ^\n-    //           |\n-    //           b\n-\n-    // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"c\");\n-    relation.add(\"a\", \"d\");\n-    relation.add(\"b\", \"d\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_2() {\n-    //      +----+\n-    //      v    |\n-    // a -> c -> d\n-    //      ^    ^\n-    //      |    |\n-    //      +--- b\n-\n-    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"c\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_3() {\n-    //      +---------+\n-    //      v         |\n-    // a -> c -> d -> e\n-    //           ^    ^\n-    //           |    |\n-    //           b ---+\n-\n-    // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"e\");\n-    relation.add(\"e\", \"c\");\n-    relation.add(\"b\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn mubs_scc_4() {\n-    //      +---------+\n-    //      v         |\n-    // a -> c -> d -> e\n-    // |         ^    ^\n-    // +---------+    |\n-    //                |\n-    //           b ---+\n-\n-    // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n-    let mut relation = TransitiveRelation::default();\n-    relation.add(\"a\", \"c\");\n-    relation.add(\"c\", \"d\");\n-    relation.add(\"d\", \"e\");\n-    relation.add(\"e\", \"c\");\n-    relation.add(\"a\", \"d\");\n-    relation.add(\"b\", \"e\");\n-\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n-}\n-\n-#[test]\n-fn parent() {\n-    // An example that was misbehaving in the compiler.\n-    //\n-    // 4 -> 1 -> 3\n-    //   \\  |   /\n-    //    \\ v  /\n-    // 2 -> 0\n-    //\n-    // plus a bunch of self-loops\n-    //\n-    // Here `->` represents `<=` and `0` is `'static`.\n-\n-    let pairs = vec![\n-        (2, /*->*/ 0),\n-        (2, /*->*/ 2),\n-        (0, /*->*/ 0),\n-        (0, /*->*/ 0),\n-        (1, /*->*/ 0),\n-        (1, /*->*/ 1),\n-        (3, /*->*/ 0),\n-        (3, /*->*/ 3),\n-        (4, /*->*/ 0),\n-        (4, /*->*/ 1),\n-        (1, /*->*/ 3),\n-    ];\n-\n-    let mut relation = TransitiveRelation::default();\n-    for (a, b) in pairs {\n-        relation.add(a, b);\n-    }\n-\n-    let p = relation.postdom_parent(&3);\n-    assert_eq!(p, Some(&0));\n-}"}, {"sha": "a462dbdb58383dcd650138b79cf23717909c1600", "filename": "src/librustc_data_structures/transitive_relation/tests.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,357 @@\n+use super::*;\n+\n+#[test]\n+fn test_one_step() {\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(!relation.contains(&\"b\", &\"a\"));\n+    assert!(!relation.contains(&\"a\", &\"d\"));\n+}\n+\n+#[test]\n+fn test_many_steps() {\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"b\");\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"a\", \"f\");\n+\n+    relation.add(\"b\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    relation.add(\"e\", \"g\");\n+\n+    assert!(relation.contains(&\"a\", &\"b\"));\n+    assert!(relation.contains(&\"a\", &\"c\"));\n+    assert!(relation.contains(&\"a\", &\"d\"));\n+    assert!(relation.contains(&\"a\", &\"e\"));\n+    assert!(relation.contains(&\"a\", &\"f\"));\n+    assert!(relation.contains(&\"a\", &\"g\"));\n+\n+    assert!(relation.contains(&\"b\", &\"g\"));\n+\n+    assert!(!relation.contains(&\"a\", &\"x\"));\n+    assert!(!relation.contains(&\"b\", &\"f\"));\n+}\n+\n+#[test]\n+fn mubs_triangle() {\n+    // a -> tcx\n+    //      ^\n+    //      |\n+    //      b\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"tcx\");\n+    relation.add(\"b\", \"tcx\");\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice1() {\n+    // 0 -> 1 <- 3\n+    // |    ^    |\n+    // |    |    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [1]\n+\n+    // This tests a particular state in the algorithm, in which we\n+    // need the second pare down call to get the right result (after\n+    // intersection, we have [1, 2], but 2 -> 1).\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n+    assert!(relation.parents(&\"1\").is_empty());\n+}\n+\n+#[test]\n+fn mubs_best_choice2() {\n+    // 0 -> 1 <- 3\n+    // |    |    |\n+    // |    v    |\n+    // +--> 2 <--+\n+    //\n+    // mubs(0,3) = [2]\n+\n+    // Like the precedecing test, but in this case intersection is [2,\n+    // 1], and hence we rely on the first pare down call.\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n+    assert!(relation.parents(&\"2\").is_empty());\n+}\n+\n+#[test]\n+fn mubs_no_best_choice() {\n+    // in this case, the intersection yields [1, 2], and the \"pare\n+    // down\" calls find nothing to remove.\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n+}\n+\n+#[test]\n+fn mubs_best_choice_scc() {\n+    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n+    // consistently).\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"0\", \"1\");\n+    relation.add(\"0\", \"2\");\n+\n+    relation.add(\"1\", \"2\");\n+    relation.add(\"2\", \"1\");\n+\n+    relation.add(\"3\", \"1\");\n+    relation.add(\"3\", \"2\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+}\n+\n+#[test]\n+fn pdub_crisscross() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> x\n+    //   \\/       ^\n+    //   /\\       |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_crisscross_more() {\n+    // diagonal edges run left-to-right\n+    // a -> a1 -> a2 -> a3 -> x\n+    //   \\/    \\/             ^\n+    //   /\\    /\\             |\n+    // b -> b1 -> b2 ---------+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"a\", \"b1\");\n+    relation.add(\"b\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+\n+    relation.add(\"a1\", \"a2\");\n+    relation.add(\"a1\", \"b2\");\n+    relation.add(\"b1\", \"a2\");\n+    relation.add(\"b1\", \"b2\");\n+\n+    relation.add(\"a2\", \"a3\");\n+\n+    relation.add(\"a3\", \"x\");\n+    relation.add(\"b2\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n+               vec![&\"a1\", &\"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n+               vec![&\"a2\", &\"b2\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn pdub_lub() {\n+    // a -> a1 -> x\n+    //            ^\n+    //            |\n+    // b -> b1 ---+\n+\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"a1\");\n+    relation.add(\"b\", \"b1\");\n+    relation.add(\"a1\", \"x\");\n+    relation.add(\"b1\", \"x\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n+    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n+    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n+}\n+\n+#[test]\n+fn mubs_intermediate_node_on_one_side_only() {\n+    // a -> c -> d\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"b\", \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_1() {\n+    // +-------------+\n+    // |    +----+   |\n+    // |    v    |   |\n+    // a -> c -> d <-+\n+    //           ^\n+    //           |\n+    //           b\n+\n+    // \"digraph { a -> c -> d; d -> c; a -> d; b -> d; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"d\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_2() {\n+    //      +----+\n+    //      v    |\n+    // a -> c -> d\n+    //      ^    ^\n+    //      |    |\n+    //      +--- b\n+\n+    // \"digraph { a -> c -> d; d -> c; b -> d; b -> c; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"c\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_3() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    //           ^    ^\n+    //           |    |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; b -> d; b -> e; }\",\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"b\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn mubs_scc_4() {\n+    //      +---------+\n+    //      v         |\n+    // a -> c -> d -> e\n+    // |         ^    ^\n+    // +---------+    |\n+    //                |\n+    //           b ---+\n+\n+    // \"digraph { a -> c -> d -> e -> c; a -> d; b -> e; }\"\n+    let mut relation = TransitiveRelation::default();\n+    relation.add(\"a\", \"c\");\n+    relation.add(\"c\", \"d\");\n+    relation.add(\"d\", \"e\");\n+    relation.add(\"e\", \"c\");\n+    relation.add(\"a\", \"d\");\n+    relation.add(\"b\", \"e\");\n+\n+    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+}\n+\n+#[test]\n+fn parent() {\n+    // An example that was misbehaving in the compiler.\n+    //\n+    // 4 -> 1 -> 3\n+    //   \\  |   /\n+    //    \\ v  /\n+    // 2 -> 0\n+    //\n+    // plus a bunch of self-loops\n+    //\n+    // Here `->` represents `<=` and `0` is `'static`.\n+\n+    let pairs = vec![\n+        (2, /*->*/ 0),\n+        (2, /*->*/ 2),\n+        (0, /*->*/ 0),\n+        (0, /*->*/ 0),\n+        (1, /*->*/ 0),\n+        (1, /*->*/ 1),\n+        (3, /*->*/ 0),\n+        (3, /*->*/ 3),\n+        (4, /*->*/ 0),\n+        (4, /*->*/ 1),\n+        (1, /*->*/ 3),\n+    ];\n+\n+    let mut relation = TransitiveRelation::default();\n+    for (a, b) in pairs {\n+        relation.add(a, b);\n+    }\n+\n+    let p = relation.postdom_parent(&3);\n+    assert_eq!(p, Some(&0));\n+}"}, {"sha": "511175de5d8d1c043509f9ed4239ef2769e00896", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 3, "deletions": 64, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -117,6 +117,9 @@ use std::time::{UNIX_EPOCH, SystemTime, Duration};\n \n use rand::{RngCore, thread_rng};\n \n+#[cfg(test)]\n+mod tests;\n+\n const LOCK_FILE_EXT: &str = \".lock\";\n const DEP_GRAPH_FILENAME: &str = \"dep-graph.bin\";\n const WORK_PRODUCTS_FILENAME: &str = \"work-products.bin\";\n@@ -894,67 +897,3 @@ fn safe_remove_file(p: &Path) -> io::Result<()> {\n         Ok(())\n     }\n }\n-\n-#[test]\n-fn test_all_except_most_recent() {\n-    assert_eq!(all_except_most_recent(\n-        vec![\n-            (UNIX_EPOCH + Duration::new(4, 0), PathBuf::from(\"4\"), None),\n-            (UNIX_EPOCH + Duration::new(1, 0), PathBuf::from(\"1\"), None),\n-            (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n-            (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n-            (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n-        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n-        vec![\n-            PathBuf::from(\"1\"),\n-            PathBuf::from(\"2\"),\n-            PathBuf::from(\"3\"),\n-            PathBuf::from(\"4\"),\n-        ].into_iter().collect::<FxHashSet<PathBuf>>()\n-    );\n-\n-    assert_eq!(all_except_most_recent(\n-        vec![\n-        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n-        FxHashSet::default()\n-    );\n-}\n-\n-#[test]\n-fn test_timestamp_serialization() {\n-    for i in 0 .. 1_000u64 {\n-        let time = UNIX_EPOCH + Duration::new(i * 1_434_578, (i as u32) * 239_000);\n-        let s = timestamp_to_string(time);\n-        assert_eq!(Ok(time), string_to_timestamp(&s));\n-    }\n-}\n-\n-#[test]\n-fn test_find_source_directory_in_iter() {\n-    let already_visited = FxHashSet::default();\n-\n-    // Find newest\n-    assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"crate-dir/s-3234-0000-svh\"),\n-             PathBuf::from(\"crate-dir/s-2234-0000-svh\"),\n-             PathBuf::from(\"crate-dir/s-1234-0000-svh\")].into_iter(), &already_visited),\n-        Some(PathBuf::from(\"crate-dir/s-3234-0000-svh\")));\n-\n-    // Filter out \"-working\"\n-    assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"crate-dir/s-3234-0000-working\"),\n-             PathBuf::from(\"crate-dir/s-2234-0000-svh\"),\n-             PathBuf::from(\"crate-dir/s-1234-0000-svh\")].into_iter(), &already_visited),\n-        Some(PathBuf::from(\"crate-dir/s-2234-0000-svh\")));\n-\n-    // Handle empty\n-    assert_eq!(find_source_directory_in_iter(vec![].into_iter(), &already_visited),\n-               None);\n-\n-    // Handle only working\n-    assert_eq!(find_source_directory_in_iter(\n-        vec![PathBuf::from(\"crate-dir/s-3234-0000-working\"),\n-             PathBuf::from(\"crate-dir/s-2234-0000-working\"),\n-             PathBuf::from(\"crate-dir/s-1234-0000-working\")].into_iter(), &already_visited),\n-        None);\n-}"}, {"sha": "09c2fc146383623c2d4544a2d4688a6bdc4b4496", "filename": "src/librustc_incremental/persist/fs/tests.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_incremental%2Fpersist%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_incremental%2Fpersist%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,65 @@\n+use super::*;\n+\n+#[test]\n+fn test_all_except_most_recent() {\n+    assert_eq!(all_except_most_recent(\n+        vec![\n+            (UNIX_EPOCH + Duration::new(4, 0), PathBuf::from(\"4\"), None),\n+            (UNIX_EPOCH + Duration::new(1, 0), PathBuf::from(\"1\"), None),\n+            (UNIX_EPOCH + Duration::new(5, 0), PathBuf::from(\"5\"), None),\n+            (UNIX_EPOCH + Duration::new(3, 0), PathBuf::from(\"3\"), None),\n+            (UNIX_EPOCH + Duration::new(2, 0), PathBuf::from(\"2\"), None),\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n+        vec![\n+            PathBuf::from(\"1\"),\n+            PathBuf::from(\"2\"),\n+            PathBuf::from(\"3\"),\n+            PathBuf::from(\"4\"),\n+        ].into_iter().collect::<FxHashSet<PathBuf>>()\n+    );\n+\n+    assert_eq!(all_except_most_recent(\n+        vec![\n+        ]).keys().cloned().collect::<FxHashSet<PathBuf>>(),\n+        FxHashSet::default()\n+    );\n+}\n+\n+#[test]\n+fn test_timestamp_serialization() {\n+    for i in 0 .. 1_000u64 {\n+        let time = UNIX_EPOCH + Duration::new(i * 1_434_578, (i as u32) * 239_000);\n+        let s = timestamp_to_string(time);\n+        assert_eq!(Ok(time), string_to_timestamp(&s));\n+    }\n+}\n+\n+#[test]\n+fn test_find_source_directory_in_iter() {\n+    let already_visited = FxHashSet::default();\n+\n+    // Find newest\n+    assert_eq!(find_source_directory_in_iter(\n+        vec![PathBuf::from(\"crate-dir/s-3234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/s-2234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/s-1234-0000-svh\")].into_iter(), &already_visited),\n+        Some(PathBuf::from(\"crate-dir/s-3234-0000-svh\")));\n+\n+    // Filter out \"-working\"\n+    assert_eq!(find_source_directory_in_iter(\n+        vec![PathBuf::from(\"crate-dir/s-3234-0000-working\"),\n+             PathBuf::from(\"crate-dir/s-2234-0000-svh\"),\n+             PathBuf::from(\"crate-dir/s-1234-0000-svh\")].into_iter(), &already_visited),\n+        Some(PathBuf::from(\"crate-dir/s-2234-0000-svh\")));\n+\n+    // Handle empty\n+    assert_eq!(find_source_directory_in_iter(vec![].into_iter(), &already_visited),\n+               None);\n+\n+    // Handle only working\n+    assert_eq!(find_source_directory_in_iter(\n+        vec![PathBuf::from(\"crate-dir/s-3234-0000-working\"),\n+             PathBuf::from(\"crate-dir/s-2234-0000-working\"),\n+             PathBuf::from(\"crate-dir/s-1234-0000-working\")].into_iter(), &already_visited),\n+        None);\n+}"}, {"sha": "d8e00d4c7c5ea9a66a97c24f8d07eb4789005804", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 3, "deletions": 280, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -4,6 +4,9 @@\n use std::str::Chars;\n use std::ops::Range;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum EscapeError {\n     ZeroChars,\n@@ -320,283 +323,3 @@ fn byte_from_char(c: char) -> u8 {\n fn is_ascii(x: u32) -> bool {\n     x <= 0x7F\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_unescape_char_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n-        check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n-        check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-        check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-        check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n-\n-        check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-\n-        check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n-        check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n-    }\n-\n-    #[test]\n-    fn test_unescape_char_good() {\n-        fn check(literal_text: &str, expected_char: char) {\n-            let actual_result = unescape_char(literal_text);\n-            assert_eq!(actual_result, Ok(expected_char));\n-        }\n-\n-        check(\"a\", 'a');\n-        check(\"\u044b\", '\u044b');\n-        check(\"\ud83e\udd80\", '\ud83e\udd80');\n-\n-        check(r#\"\\\"\"#, '\"');\n-        check(r\"\\n\", '\\n');\n-        check(r\"\\r\", '\\r');\n-        check(r\"\\t\", '\\t');\n-        check(r\"\\\\\", '\\\\');\n-        check(r\"\\'\", '\\'');\n-        check(r\"\\0\", '\\0');\n-\n-        check(r\"\\x00\", '\\0');\n-        check(r\"\\x5a\", 'Z');\n-        check(r\"\\x5A\", 'Z');\n-        check(r\"\\x7f\", 127 as char);\n-\n-        check(r\"\\u{0}\", '\\0');\n-        check(r\"\\u{000000}\", '\\0');\n-        check(r\"\\u{41}\", 'A');\n-        check(r\"\\u{0041}\", 'A');\n-        check(r\"\\u{00_41}\", 'A');\n-        check(r\"\\u{4__1__}\", 'A');\n-        check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n-    }\n-\n-    #[test]\n-    fn test_unescape_str_good() {\n-        fn check(literal_text: &str, expected: &str) {\n-            let mut buf = Ok(String::with_capacity(literal_text.len()));\n-            unescape_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", \"foo\");\n-        check(\"\", \"\");\n-        check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", \"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", \"hello world\");\n-        check(\"thread's\", \"thread's\")\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_bad() {\n-        fn check(literal_text: &str, expected_error: EscapeError) {\n-            let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-            assert_eq!(actual_result, Err(expected_error));\n-        }\n-\n-        check(\"\", EscapeError::ZeroChars);\n-        check(r\"\\\", EscapeError::LoneSlash);\n-\n-        check(\"\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n-        check(\"\\t\", EscapeError::EscapeOnlyChar);\n-        check(\"'\", EscapeError::EscapeOnlyChar);\n-        check(\"\\r\", EscapeError::BareCarriageReturn);\n-\n-        check(\"spam\", EscapeError::MoreThanOneChar);\n-        check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n-        check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n-        check(r\"\\na\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ra\", EscapeError::MoreThanOneChar);\n-        check(r\"\\ta\", EscapeError::MoreThanOneChar);\n-        check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\'a\", EscapeError::MoreThanOneChar);\n-        check(r\"\\0a\", EscapeError::MoreThanOneChar);\n-\n-        check(r\"\\v\", EscapeError::InvalidEscape);\n-        check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n-        check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n-\n-        check(r\"\\x\", EscapeError::TooShortHexEscape);\n-        check(r\"\\x0\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xa\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xf\", EscapeError::TooShortHexEscape);\n-        check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n-        check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n-\n-        check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n-        check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n-        check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n-        check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n-        check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n-        check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n-\n-        check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n-        check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n-\n-        check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n-        check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_good() {\n-        fn check(literal_text: &str, expected_byte: u8) {\n-            let actual_result = unescape_byte(literal_text);\n-            assert_eq!(actual_result, Ok(expected_byte));\n-        }\n-\n-        check(\"a\", b'a');\n-\n-        check(r#\"\\\"\"#, b'\"');\n-        check(r\"\\n\", b'\\n');\n-        check(r\"\\r\", b'\\r');\n-        check(r\"\\t\", b'\\t');\n-        check(r\"\\\\\", b'\\\\');\n-        check(r\"\\'\", b'\\'');\n-        check(r\"\\0\", b'\\0');\n-\n-        check(r\"\\x00\", b'\\0');\n-        check(r\"\\x5a\", b'Z');\n-        check(r\"\\x5A\", b'Z');\n-        check(r\"\\x7f\", 127);\n-        check(r\"\\x80\", 128);\n-        check(r\"\\xff\", 255);\n-        check(r\"\\xFF\", 255);\n-    }\n-\n-    #[test]\n-    fn test_unescape_byte_str_good() {\n-        fn check(literal_text: &str, expected: &[u8]) {\n-            let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-            unescape_byte_str(literal_text, &mut |range, c| {\n-                if let Ok(b) = &mut buf {\n-                    match c {\n-                        Ok(c) => b.push(c),\n-                        Err(e) => buf = Err((range, e)),\n-                    }\n-                }\n-            });\n-            let buf = buf.as_ref().map(|it| it.as_ref());\n-            assert_eq!(buf, Ok(expected))\n-        }\n-\n-        check(\"foo\", b\"foo\");\n-        check(\"\", b\"\");\n-        check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n-\n-        check(\"hello \\\\\\n     world\", b\"hello world\");\n-        check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n-        check(\"thread's\", b\"thread's\")\n-    }\n-\n-    #[test]\n-    fn test_unescape_raw_str() {\n-        fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n-            let mut unescaped = Vec::with_capacity(literal.len());\n-            unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n-            assert_eq!(unescaped, expected);\n-        }\n-\n-        check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n-        check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-        check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n-    }\n-\n-    #[test]\n-    fn test_unescape_raw_byte_str() {\n-        fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n-            let mut unescaped = Vec::with_capacity(literal.len());\n-            unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n-            assert_eq!(unescaped, expected);\n-        }\n-\n-        check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n-        check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-        check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n-        check(\n-            \"\ud83e\udd80a\",\n-            &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n-        );\n-    }\n-}"}, {"sha": "496527eb265b06f7f825b6b3bb22e3d8bcf77516", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,276 @@\n+use super::*;\n+\n+#[test]\n+fn test_unescape_char_bad() {\n+    fn check(literal_text: &str, expected_error: EscapeError) {\n+        let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n+        assert_eq!(actual_result, Err(expected_error));\n+    }\n+\n+    check(\"\", EscapeError::ZeroChars);\n+    check(r\"\\\", EscapeError::LoneSlash);\n+\n+    check(\"\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\t\", EscapeError::EscapeOnlyChar);\n+    check(\"'\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+    check(\"spam\", EscapeError::MoreThanOneChar);\n+    check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+    check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+    check(r\"\\na\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+    check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\u{0}x\", EscapeError::MoreThanOneChar);\n+    check(r\"\\u{1F63b}}\", EscapeError::MoreThanOneChar);\n+\n+    check(r\"\\v\", EscapeError::InvalidEscape);\n+    check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+    check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+    check(r\"\\x\", EscapeError::TooShortHexEscape);\n+    check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xff\", EscapeError::OutOfRangeHexEscape);\n+    check(r\"\\xFF\", EscapeError::OutOfRangeHexEscape);\n+    check(r\"\\x80\", EscapeError::OutOfRangeHexEscape);\n+\n+    check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+    check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+    check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+    check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+    check(r\"\\u{FFFFFF}\", EscapeError::OutOfRangeUnicodeEscape);\n+    check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+    check(r\"\\u{ffffff}\", EscapeError::OutOfRangeUnicodeEscape);\n+\n+    check(r\"\\u{DC00}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DDDD}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DFFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+\n+    check(r\"\\u{D800}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DAAA}\", EscapeError::LoneSurrogateUnicodeEscape);\n+    check(r\"\\u{DBFF}\", EscapeError::LoneSurrogateUnicodeEscape);\n+}\n+\n+#[test]\n+fn test_unescape_char_good() {\n+    fn check(literal_text: &str, expected_char: char) {\n+        let actual_result = unescape_char(literal_text);\n+        assert_eq!(actual_result, Ok(expected_char));\n+    }\n+\n+    check(\"a\", 'a');\n+    check(\"\u044b\", '\u044b');\n+    check(\"\ud83e\udd80\", '\ud83e\udd80');\n+\n+    check(r#\"\\\"\"#, '\"');\n+    check(r\"\\n\", '\\n');\n+    check(r\"\\r\", '\\r');\n+    check(r\"\\t\", '\\t');\n+    check(r\"\\\\\", '\\\\');\n+    check(r\"\\'\", '\\'');\n+    check(r\"\\0\", '\\0');\n+\n+    check(r\"\\x00\", '\\0');\n+    check(r\"\\x5a\", 'Z');\n+    check(r\"\\x5A\", 'Z');\n+    check(r\"\\x7f\", 127 as char);\n+\n+    check(r\"\\u{0}\", '\\0');\n+    check(r\"\\u{000000}\", '\\0');\n+    check(r\"\\u{41}\", 'A');\n+    check(r\"\\u{0041}\", 'A');\n+    check(r\"\\u{00_41}\", 'A');\n+    check(r\"\\u{4__1__}\", 'A');\n+    check(r\"\\u{1F63b}\", '\ud83d\ude3b');\n+}\n+\n+#[test]\n+fn test_unescape_str_good() {\n+    fn check(literal_text: &str, expected: &str) {\n+        let mut buf = Ok(String::with_capacity(literal_text.len()));\n+        unescape_str(literal_text, &mut |range, c| {\n+            if let Ok(b) = &mut buf {\n+                match c {\n+                    Ok(c) => b.push(c),\n+                    Err(e) => buf = Err((range, e)),\n+                }\n+            }\n+        });\n+        let buf = buf.as_ref().map(|it| it.as_ref());\n+        assert_eq!(buf, Ok(expected))\n+    }\n+\n+    check(\"foo\", \"foo\");\n+    check(\"\", \"\");\n+    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+\n+    check(\"hello \\\\\\n     world\", \"hello world\");\n+    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n+    check(\"thread's\", \"thread's\")\n+}\n+\n+#[test]\n+fn test_unescape_byte_bad() {\n+    fn check(literal_text: &str, expected_error: EscapeError) {\n+        let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n+        assert_eq!(actual_result, Err(expected_error));\n+    }\n+\n+    check(\"\", EscapeError::ZeroChars);\n+    check(r\"\\\", EscapeError::LoneSlash);\n+\n+    check(\"\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n+    check(\"\\t\", EscapeError::EscapeOnlyChar);\n+    check(\"'\", EscapeError::EscapeOnlyChar);\n+    check(\"\\r\", EscapeError::BareCarriageReturn);\n+\n+    check(\"spam\", EscapeError::MoreThanOneChar);\n+    check(r\"\\x0ff\", EscapeError::MoreThanOneChar);\n+    check(r#\"\\\"a\"#, EscapeError::MoreThanOneChar);\n+    check(r\"\\na\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ra\", EscapeError::MoreThanOneChar);\n+    check(r\"\\ta\", EscapeError::MoreThanOneChar);\n+    check(r\"\\\\a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\'a\", EscapeError::MoreThanOneChar);\n+    check(r\"\\0a\", EscapeError::MoreThanOneChar);\n+\n+    check(r\"\\v\", EscapeError::InvalidEscape);\n+    check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n+    check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+\n+    check(r\"\\x\", EscapeError::TooShortHexEscape);\n+    check(r\"\\x0\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xa\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xf\", EscapeError::TooShortHexEscape);\n+    check(r\"\\xx\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\u044b\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\x\ud83e\udd80\", EscapeError::InvalidCharInHexEscape);\n+    check(r\"\\xtt\", EscapeError::InvalidCharInHexEscape);\n+\n+    check(r\"\\u\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u[0123]\", EscapeError::NoBraceInUnicodeEscape);\n+    check(r\"\\u{0x}\", EscapeError::InvalidCharInUnicodeEscape);\n+    check(r\"\\u{\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{0000\", EscapeError::UnclosedUnicodeEscape);\n+    check(r\"\\u{}\", EscapeError::EmptyUnicodeEscape);\n+    check(r\"\\u{_0000}\", EscapeError::LeadingUnderscoreUnicodeEscape);\n+    check(r\"\\u{0000000}\", EscapeError::OverlongUnicodeEscape);\n+\n+    check(\"\u044b\", EscapeError::NonAsciiCharInByte);\n+    check(\"\ud83e\udd80\", EscapeError::NonAsciiCharInByte);\n+\n+    check(r\"\\u{0}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{000000}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{41}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{0041}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{00_41}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{4__1__}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{1F63b}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{0}x\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{1F63b}}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{FFFFFF}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{ffffff}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DC00}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DDDD}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DFFF}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{D800}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DAAA}\", EscapeError::UnicodeEscapeInByte);\n+    check(r\"\\u{DBFF}\", EscapeError::UnicodeEscapeInByte);\n+}\n+\n+#[test]\n+fn test_unescape_byte_good() {\n+    fn check(literal_text: &str, expected_byte: u8) {\n+        let actual_result = unescape_byte(literal_text);\n+        assert_eq!(actual_result, Ok(expected_byte));\n+    }\n+\n+    check(\"a\", b'a');\n+\n+    check(r#\"\\\"\"#, b'\"');\n+    check(r\"\\n\", b'\\n');\n+    check(r\"\\r\", b'\\r');\n+    check(r\"\\t\", b'\\t');\n+    check(r\"\\\\\", b'\\\\');\n+    check(r\"\\'\", b'\\'');\n+    check(r\"\\0\", b'\\0');\n+\n+    check(r\"\\x00\", b'\\0');\n+    check(r\"\\x5a\", b'Z');\n+    check(r\"\\x5A\", b'Z');\n+    check(r\"\\x7f\", 127);\n+    check(r\"\\x80\", 128);\n+    check(r\"\\xff\", 255);\n+    check(r\"\\xFF\", 255);\n+}\n+\n+#[test]\n+fn test_unescape_byte_str_good() {\n+    fn check(literal_text: &str, expected: &[u8]) {\n+        let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n+        unescape_byte_str(literal_text, &mut |range, c| {\n+            if let Ok(b) = &mut buf {\n+                match c {\n+                    Ok(c) => b.push(c),\n+                    Err(e) => buf = Err((range, e)),\n+                }\n+            }\n+        });\n+        let buf = buf.as_ref().map(|it| it.as_ref());\n+        assert_eq!(buf, Ok(expected))\n+    }\n+\n+    check(\"foo\", b\"foo\");\n+    check(\"\", b\"\");\n+    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+\n+    check(\"hello \\\\\\n     world\", b\"hello world\");\n+    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n+    check(\"thread's\", b\"thread's\")\n+}\n+\n+#[test]\n+fn test_unescape_raw_str() {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n+        let mut unescaped = Vec::with_capacity(literal.len());\n+        unescape_raw_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        assert_eq!(unescaped, expected);\n+    }\n+\n+    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n+    check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n+    check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n+}\n+\n+#[test]\n+fn test_unescape_raw_byte_str() {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n+        let mut unescaped = Vec::with_capacity(literal.len());\n+        unescape_raw_byte_str(literal, &mut |range, res| unescaped.push((range, res)));\n+        assert_eq!(unescaped, expected);\n+    }\n+\n+    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n+    check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n+    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n+    check(\n+        \"\ud83e\udd80a\",\n+        &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n+    );\n+}"}, {"sha": "909f0fc53fcea63197a9323ba9e4abfa602738f1", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,5 +1,8 @@\n use std::fmt;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n pub enum Abi {\n     // N.B., this ordering MUST match the AbiDatas array below.\n@@ -100,29 +103,3 @@ impl fmt::Display for Abi {\n         write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }\n-\n-#[allow(non_snake_case)]\n-#[test]\n-fn lookup_Rust() {\n-    let abi = lookup(\"Rust\");\n-    assert!(abi.is_some() && abi.unwrap().data().name == \"Rust\");\n-}\n-\n-#[test]\n-fn lookup_cdecl() {\n-    let abi = lookup(\"cdecl\");\n-    assert!(abi.is_some() && abi.unwrap().data().name == \"cdecl\");\n-}\n-\n-#[test]\n-fn lookup_baz() {\n-    let abi = lookup(\"baz\");\n-    assert!(abi.is_none());\n-}\n-\n-#[test]\n-fn indices_are_correct() {\n-    for (i, abi_data) in AbiDatas.iter().enumerate() {\n-        assert_eq!(i, abi_data.abi.index());\n-    }\n-}"}, {"sha": "8bea5e5efe3b0b04442f6552c3d8712a34d3b589", "filename": "src/librustc_target/spec/abi/tests.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fabi%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fabi%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,27 @@\n+use super::*;\n+\n+#[allow(non_snake_case)]\n+#[test]\n+fn lookup_Rust() {\n+    let abi = lookup(\"Rust\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"Rust\");\n+}\n+\n+#[test]\n+fn lookup_cdecl() {\n+    let abi = lookup(\"cdecl\");\n+    assert!(abi.is_some() && abi.unwrap().data().name == \"cdecl\");\n+}\n+\n+#[test]\n+fn lookup_baz() {\n+    let abi = lookup(\"baz\");\n+    assert!(abi.is_none());\n+}\n+\n+#[test]\n+fn indices_are_correct() {\n+    for (i, abi_data) in AbiDatas.iter().enumerate() {\n+        assert_eq!(i, abi_data.abi.index());\n+    }\n+}"}, {"sha": "53d66186c368c3b02c3b5a53a7c48d63aef83d12", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -312,7 +312,7 @@ macro_rules! supported_targets {\n             $(use super::$module;)+\n \n             $(\n-                #[test]\n+                #[test] // `#[test]` - this is hard to put into a separate file, make an exception\n                 fn $module() {\n                     // Grab the TargetResult struct. If we successfully retrieved\n                     // a Target, then the test JSON encoding/decoding can run for this"}, {"sha": "b9b3e621bb740dc6892258843d85d60624529340", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 3, "deletions": 417, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -16,6 +16,9 @@ use syntax_pos::Span;\n \n use crate::html::escape::Escape;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum Cfg {\n     /// Accepts all configurations.\n@@ -408,420 +411,3 @@ impl<'a> fmt::Display for Html<'a> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Cfg;\n-\n-    use syntax_pos::DUMMY_SP;\n-    use syntax::ast::*;\n-    use syntax::attr;\n-    use syntax::source_map::dummy_spanned;\n-    use syntax::symbol::Symbol;\n-    use syntax::with_default_globals;\n-\n-    fn word_cfg(s: &str) -> Cfg {\n-        Cfg::Cfg(Symbol::intern(s), None)\n-    }\n-\n-    fn name_value_cfg(name: &str, value: &str) -> Cfg {\n-        Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n-    }\n-\n-    fn dummy_meta_item_word(name: &str) -> MetaItem {\n-        MetaItem {\n-            path: Path::from_ident(Ident::from_str(name)),\n-            node: MetaItemKind::Word,\n-            span: DUMMY_SP,\n-        }\n-    }\n-\n-    macro_rules! dummy_meta_item_list {\n-        ($name:ident, [$($list:ident),* $(,)?]) => {\n-            MetaItem {\n-                path: Path::from_ident(Ident::from_str(stringify!($name))),\n-                node: MetaItemKind::List(vec![\n-                    $(\n-                        NestedMetaItem::MetaItem(\n-                            dummy_meta_item_word(stringify!($list)),\n-                        ),\n-                    )*\n-                ]),\n-                span: DUMMY_SP,\n-            }\n-        };\n-\n-        ($name:ident, [$($list:expr),* $(,)?]) => {\n-            MetaItem {\n-                path: Path::from_ident(Ident::from_str(stringify!($name))),\n-                node: MetaItemKind::List(vec![\n-                    $(\n-                        NestedMetaItem::MetaItem($list),\n-                    )*\n-                ]),\n-                span: DUMMY_SP,\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn test_cfg_not() {\n-        with_default_globals(|| {\n-            assert_eq!(!Cfg::False, Cfg::True);\n-            assert_eq!(!Cfg::True, Cfg::False);\n-            assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n-            assert_eq!(\n-                !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-                Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n-            );\n-            assert_eq!(\n-                !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-                Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n-            );\n-            assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_cfg_and() {\n-        with_default_globals(|| {\n-            let mut x = Cfg::False;\n-            x &= Cfg::True;\n-            assert_eq!(x, Cfg::False);\n-\n-            x = word_cfg(\"test\");\n-            x &= Cfg::False;\n-            assert_eq!(x, Cfg::False);\n-\n-            x = word_cfg(\"test2\");\n-            x &= Cfg::True;\n-            assert_eq!(x, word_cfg(\"test2\"));\n-\n-            x = Cfg::True;\n-            x &= word_cfg(\"test3\");\n-            assert_eq!(x, word_cfg(\"test3\"));\n-\n-            x &= word_cfg(\"test4\");\n-            assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n-\n-            x &= word_cfg(\"test5\");\n-            assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n-\n-            x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n-            assert_eq!(x, Cfg::All(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-            ]));\n-\n-            let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n-            y &= x;\n-            assert_eq!(y, Cfg::All(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-                Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-            ]));\n-\n-            assert_eq!(\n-                word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n-                Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_cfg_or() {\n-        with_default_globals(|| {\n-            let mut x = Cfg::True;\n-            x |= Cfg::False;\n-            assert_eq!(x, Cfg::True);\n-\n-            x = word_cfg(\"test\");\n-            x |= Cfg::True;\n-            assert_eq!(x, Cfg::True);\n-\n-            x = word_cfg(\"test2\");\n-            x |= Cfg::False;\n-            assert_eq!(x, word_cfg(\"test2\"));\n-\n-            x = Cfg::False;\n-            x |= word_cfg(\"test3\");\n-            assert_eq!(x, word_cfg(\"test3\"));\n-\n-            x |= word_cfg(\"test4\");\n-            assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n-\n-            x |= word_cfg(\"test5\");\n-            assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n-\n-            x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n-            assert_eq!(x, Cfg::Any(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-            ]));\n-\n-            let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n-            y |= x;\n-            assert_eq!(y, Cfg::Any(vec![\n-                word_cfg(\"test3\"),\n-                word_cfg(\"test4\"),\n-                word_cfg(\"test5\"),\n-                word_cfg(\"test6\"),\n-                word_cfg(\"test7\"),\n-                Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n-            ]));\n-\n-            assert_eq!(\n-                word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n-                Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_parse_ok() {\n-        with_default_globals(|| {\n-            let mi = dummy_meta_item_word(\"all\");\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n-\n-            let mi = attr::mk_name_value_item_str(\n-                Ident::from_str(\"all\"),\n-                dummy_spanned(Symbol::intern(\"done\"))\n-            );\n-            assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n-\n-            let mi = dummy_meta_item_list!(all, [a, b]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n-\n-            let mi = dummy_meta_item_list!(any, [a, b]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n-\n-            let mi = dummy_meta_item_list!(not, [a]);\n-            assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n-\n-            let mi = dummy_meta_item_list!(not, [\n-                dummy_meta_item_list!(any, [\n-                    dummy_meta_item_word(\"a\"),\n-                    dummy_meta_item_list!(all, [b, c]),\n-                ]),\n-            ]);\n-            assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n-\n-            let mi = dummy_meta_item_list!(all, [a, b, c]);\n-            assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n-        })\n-    }\n-\n-    #[test]\n-    fn test_parse_err() {\n-        with_default_globals(|| {\n-            let mi = attr::mk_name_value_item(\n-                DUMMY_SP,\n-                Ident::from_str(\"foo\"),\n-                LitKind::Bool(false),\n-                DUMMY_SP,\n-            );\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, [a, b]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, []);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(foo, []);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(all, [\n-                dummy_meta_item_list!(foo, []),\n-                dummy_meta_item_word(\"b\"),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(any, [\n-                dummy_meta_item_word(\"a\"),\n-                dummy_meta_item_list!(foo, []),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-\n-            let mi = dummy_meta_item_list!(not, [\n-                dummy_meta_item_list!(foo, []),\n-            ]);\n-            assert!(Cfg::parse(&mi).is_err());\n-        })\n-    }\n-\n-    #[test]\n-    fn test_render_short_html() {\n-        with_default_globals(|| {\n-            assert_eq!(\n-                word_cfg(\"unix\").render_short_html(),\n-                \"Unix\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n-                \"macOS\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n-                \"16-bit\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n-                \"Little-endian\"\n-            );\n-            assert_eq!(\n-                (!word_cfg(\"windows\")).render_short_html(),\n-                \"Non-Windows\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n-                \"Unix and Windows\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n-                \"Unix or Windows\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n-                ).render_short_html(),\n-                \"Unix and Windows and debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n-                ).render_short_html(),\n-                \"Unix or Windows or debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n-                ).render_short_html(),\n-                \"Neither Unix nor Windows nor debug-assertions enabled\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n-                    (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n-                ).render_short_html(),\n-                \"Unix and x86-64, or Windows and 64-bit\"\n-            );\n-            assert_eq!(\n-                (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n-                \"Not (Unix and Windows)\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n-                ).render_short_html(),\n-                \"(Debug-assertions enabled or Windows) and Unix\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_feature\", \"sse2\").render_short_html(),\n-                \"<code>sse2</code>\"\n-            );\n-            assert_eq!(\n-                (\n-                    name_value_cfg(\"target_arch\", \"x86_64\") &\n-                    name_value_cfg(\"target_feature\", \"sse2\")\n-                ).render_short_html(),\n-                \"x86-64 and <code>sse2</code>\"\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_render_long_html() {\n-        with_default_globals(|| {\n-            assert_eq!(\n-                word_cfg(\"unix\").render_long_html(),\n-                \"This is supported on <strong>Unix</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n-                \"This is supported on <strong>macOS</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n-                \"This is supported on <strong>16-bit</strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n-                \"This is supported on <strong>little-endian</strong> only.\"\n-            );\n-            assert_eq!(\n-                (!word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>non-Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>Unix and Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n-                \"This is supported on <strong>Unix or Windows</strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix and Windows and debug-assertions enabled\\\n-                 </strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix or Windows or debug-assertions enabled\\\n-                 </strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n-                ).render_long_html(),\n-                \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n-                    enabled</strong>.\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n-                    (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n-                ).render_long_html(),\n-                \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> \\\n-                 only.\"\n-            );\n-            assert_eq!(\n-                (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n-                \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n-            );\n-            assert_eq!(\n-                (\n-                    (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix\\\n-                </strong> only.\"\n-            );\n-            assert_eq!(\n-                name_value_cfg(\"target_feature\", \"sse2\").render_long_html(),\n-                \"This is supported with <strong>target feature <code>sse2</code></strong> only.\"\n-            );\n-            assert_eq!(\n-                (\n-                    name_value_cfg(\"target_arch\", \"x86_64\") &\n-                    name_value_cfg(\"target_feature\", \"sse2\")\n-                ).render_long_html(),\n-                \"This is supported on <strong>x86-64 and target feature \\\n-                <code>sse2</code></strong> only.\"\n-            );\n-        })\n-    }\n-}"}, {"sha": "d0df9f8f7e4101242b2e5ae4faf6ef2d679e047d", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,413 @@\n+use super::*;\n+\n+use syntax_pos::DUMMY_SP;\n+use syntax::ast::*;\n+use syntax::attr;\n+use syntax::source_map::dummy_spanned;\n+use syntax::symbol::Symbol;\n+use syntax::with_default_globals;\n+\n+fn word_cfg(s: &str) -> Cfg {\n+    Cfg::Cfg(Symbol::intern(s), None)\n+}\n+\n+fn name_value_cfg(name: &str, value: &str) -> Cfg {\n+    Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n+}\n+\n+fn dummy_meta_item_word(name: &str) -> MetaItem {\n+    MetaItem {\n+        path: Path::from_ident(Ident::from_str(name)),\n+        node: MetaItemKind::Word,\n+        span: DUMMY_SP,\n+    }\n+}\n+\n+macro_rules! dummy_meta_item_list {\n+    ($name:ident, [$($list:ident),* $(,)?]) => {\n+        MetaItem {\n+            path: Path::from_ident(Ident::from_str(stringify!($name))),\n+            node: MetaItemKind::List(vec![\n+                $(\n+                    NestedMetaItem::MetaItem(\n+                        dummy_meta_item_word(stringify!($list)),\n+                    ),\n+                )*\n+            ]),\n+            span: DUMMY_SP,\n+        }\n+    };\n+\n+    ($name:ident, [$($list:expr),* $(,)?]) => {\n+        MetaItem {\n+            path: Path::from_ident(Ident::from_str(stringify!($name))),\n+            node: MetaItemKind::List(vec![\n+                $(\n+                    NestedMetaItem::MetaItem($list),\n+                )*\n+            ]),\n+            span: DUMMY_SP,\n+        }\n+    };\n+}\n+\n+#[test]\n+fn test_cfg_not() {\n+    with_default_globals(|| {\n+        assert_eq!(!Cfg::False, Cfg::True);\n+        assert_eq!(!Cfg::True, Cfg::False);\n+        assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n+        assert_eq!(\n+            !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(\n+            !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n+    })\n+}\n+\n+#[test]\n+fn test_cfg_and() {\n+    with_default_globals(|| {\n+        let mut x = Cfg::False;\n+        x &= Cfg::True;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test\");\n+        x &= Cfg::False;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test2\");\n+        x &= Cfg::True;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::True;\n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x &= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y &= x;\n+        assert_eq!(y, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_cfg_or() {\n+    with_default_globals(|| {\n+        let mut x = Cfg::True;\n+        x |= Cfg::False;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test\");\n+        x |= Cfg::True;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test2\");\n+        x |= Cfg::False;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::False;\n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x |= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y |= x;\n+        assert_eq!(y, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_parse_ok() {\n+    with_default_globals(|| {\n+        let mi = dummy_meta_item_word(\"all\");\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n+\n+        let mi = attr::mk_name_value_item_str(\n+            Ident::from_str(\"all\"),\n+            dummy_spanned(Symbol::intern(\"done\"))\n+        );\n+        assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n+\n+        let mi = dummy_meta_item_list!(all, [a, b]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n+\n+        let mi = dummy_meta_item_list!(any, [a, b]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n+\n+        let mi = dummy_meta_item_list!(not, [a]);\n+        assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n+\n+        let mi = dummy_meta_item_list!(not, [\n+            dummy_meta_item_list!(any, [\n+                dummy_meta_item_word(\"a\"),\n+                dummy_meta_item_list!(all, [b, c]),\n+            ]),\n+        ]);\n+        assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n+\n+        let mi = dummy_meta_item_list!(all, [a, b, c]);\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n+    })\n+}\n+\n+#[test]\n+fn test_parse_err() {\n+    with_default_globals(|| {\n+        let mi = attr::mk_name_value_item(\n+            DUMMY_SP,\n+            Ident::from_str(\"foo\"),\n+            LitKind::Bool(false),\n+            DUMMY_SP,\n+        );\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, [a, b]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, []);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(foo, []);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(all, [\n+            dummy_meta_item_list!(foo, []),\n+            dummy_meta_item_word(\"b\"),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(any, [\n+            dummy_meta_item_word(\"a\"),\n+            dummy_meta_item_list!(foo, []),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = dummy_meta_item_list!(not, [\n+            dummy_meta_item_list!(foo, []),\n+        ]);\n+        assert!(Cfg::parse(&mi).is_err());\n+    })\n+}\n+\n+#[test]\n+fn test_render_short_html() {\n+    with_default_globals(|| {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_short_html(),\n+            \"Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n+            \"macOS\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n+            \"16-bit\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n+            \"Little-endian\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_short_html(),\n+            \"Non-Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n+            \"Unix and Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n+            \"Unix or Windows\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix and Windows and debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix or Windows or debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_short_html(),\n+            \"Neither Unix nor Windows nor debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_short_html(),\n+            \"Unix and x86-64, or Windows and 64-bit\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n+            \"Not (Unix and Windows)\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_short_html(),\n+            \"(Debug-assertions enabled or Windows) and Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_feature\", \"sse2\").render_short_html(),\n+            \"<code>sse2</code>\"\n+        );\n+        assert_eq!(\n+            (\n+                name_value_cfg(\"target_arch\", \"x86_64\") &\n+                name_value_cfg(\"target_feature\", \"sse2\")\n+            ).render_short_html(),\n+            \"x86-64 and <code>sse2</code>\"\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_render_long_html() {\n+    with_default_globals(|| {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_long_html(),\n+            \"This is supported on <strong>Unix</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n+            \"This is supported on <strong>macOS</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n+            \"This is supported on <strong>16-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n+            \"This is supported on <strong>little-endian</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>non-Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows and debug-assertions enabled\\\n+                </strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows or debug-assertions enabled\\\n+                </strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n+                enabled</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n+            \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix\\\n+            </strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_feature\", \"sse2\").render_long_html(),\n+            \"This is supported with <strong>target feature <code>sse2</code></strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                name_value_cfg(\"target_arch\", \"x86_64\") &\n+                name_value_cfg(\"target_feature\", \"sse2\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>x86-64 and target feature \\\n+            <code>sse2</code></strong> only.\"\n+        );\n+    })\n+}"}, {"sha": "ef52ce62875c7d15db5dd42e832658047c053bcb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -39,6 +39,9 @@ use crate::test;\n \n use pulldown_cmark::{html, CowStr, Event, Options, Parser, Tag};\n \n+#[cfg(test)]\n+mod tests;\n+\n fn opts() -> Options {\n     Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n }\n@@ -1032,27 +1035,3 @@ impl IdMap {\n         id\n     }\n }\n-\n-#[cfg(test)]\n-#[test]\n-fn test_unique_id() {\n-    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n-                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n-                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n-    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n-                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n-                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n-\n-    let map = RefCell::new(IdMap::new());\n-    let test = || {\n-        let mut map = map.borrow_mut();\n-        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n-        assert_eq!(&actual[..], expected);\n-    };\n-    test();\n-    map.borrow_mut().reset();\n-    test();\n-}\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "681f363544a615493e94121928c73c0a9520804d", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -3,6 +3,26 @@ use super::plain_summary_line;\n use std::cell::RefCell;\n use syntax::edition::{Edition, DEFAULT_EDITION};\n \n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let map = RefCell::new(IdMap::new());\n+    let test = || {\n+        let mut map = map.borrow_mut();\n+        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    map.borrow_mut().reset();\n+    test();\n+}\n+\n #[test]\n fn test_lang_string_parse() {\n     fn t(s: &str,"}, {"sha": "c7bda534d07d683913fc3c18e5a4fcf0e6fa5f70", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -75,6 +75,9 @@ use crate::html::{highlight, layout, static_files};\n \n use minifier;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n \n@@ -5238,33 +5241,3 @@ fn get_generics(clean_type: &clean::Type) -> Option<Vec<String>> {\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n-\n-#[cfg(test)]\n-#[test]\n-fn test_name_key() {\n-    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n-    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n-    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n-    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n-    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n-    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n-    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n-    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n-}\n-\n-#[cfg(test)]\n-#[test]\n-fn test_name_sorting() {\n-    let names = [\"Apple\",\n-                 \"Banana\",\n-                 \"Fruit\", \"Fruit0\", \"Fruit00\",\n-                 \"Fruit1\", \"Fruit01\",\n-                 \"Fruit2\", \"Fruit02\",\n-                 \"Fruit20\",\n-                 \"Fruit30x\",\n-                 \"Fruit100\",\n-                 \"Pear\"];\n-    let mut sorted = names.to_owned();\n-    sorted.sort_by_key(|&s| name_key(s));\n-    assert_eq!(names, sorted);\n-}"}, {"sha": "1848b575e4d6730f573380a70972aab5ba3bf0a2", "filename": "src/librustdoc/html/render/tests.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,29 @@\n+use super::*;\n+\n+#[test]\n+fn test_name_key() {\n+    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n+    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n+    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n+    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n+    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n+    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n+    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n+    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n+}\n+\n+#[test]\n+fn test_name_sorting() {\n+    let names = [\"Apple\",\n+                 \"Banana\",\n+                 \"Fruit\", \"Fruit0\", \"Fruit00\",\n+                 \"Fruit1\", \"Fruit01\",\n+                 \"Fruit2\", \"Fruit02\",\n+                 \"Fruit20\",\n+                 \"Fruit30x\",\n+                 \"Fruit100\",\n+                 \"Pear\"];\n+    let mut sorted = names.to_owned();\n+    sorted.sort_by_key(|&s| name_key(s));\n+    assert_eq!(names, sorted);\n+}"}, {"sha": "7ad98242fdc92c285b714c61136f031bb3c144f4", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -7,6 +7,9 @@ use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub const UNINDENT_COMMENTS: Pass = Pass {\n     name: \"unindent-comments\",\n     pass: unindent_comments,\n@@ -102,79 +105,3 @@ fn unindent(s: &str) -> String {\n         s.to_string()\n     }\n }\n-\n-#[cfg(test)]\n-mod unindent_tests {\n-    use super::unindent;\n-\n-    #[test]\n-    fn should_unindent() {\n-        let s = \"    line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_multiple_paragraphs() {\n-        let s = \"    line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_leave_multiple_indent_levels() {\n-        // Line 2 is indented another level beyond the\n-        // base indentation and should be preserved\n-        let s = \"    line1\\n\\n        line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_ignore_first_line_indent() {\n-        // The first line of the first paragraph may not be indented as\n-        // far due to the way the doc string was written:\n-        //\n-        // #[doc = \"Start way over here\n-        //          and continue here\"]\n-        let s = \"line1\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-        let s = \"line1\\n\\n    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\n\\n    line2\");\n-    }\n-\n-    #[test]\n-    fn should_unindent_tabs() {\n-        let s = \"\\tline1\\n\\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_trim_mixed_indentation() {\n-        let s = \"\\t    line1\\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-\n-        let s = \"    \\tline1\\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1\\nline2\");\n-    }\n-\n-    #[test]\n-    fn should_not_trim() {\n-        let s = \"\\t    line1  \\n\\t    line2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1  \\nline2\");\n-\n-        let s = \"    \\tline1  \\n    \\tline2\".to_string();\n-        let r = unindent(&s);\n-        assert_eq!(r, \"line1  \\nline2\");\n-    }\n-}"}, {"sha": "c39c03e1249c61a760f07d150013d72e4a12148a", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,72 @@\n+use super::*;\n+\n+#[test]\n+fn should_unindent() {\n+    let s = \"    line1\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_unindent_multiple_paragraphs() {\n+    let s = \"    line1\\n\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\nline2\");\n+}\n+\n+#[test]\n+fn should_leave_multiple_indent_levels() {\n+    // Line 2 is indented another level beyond the\n+    // base indentation and should be preserved\n+    let s = \"    line1\\n\\n        line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\n    line2\");\n+}\n+\n+#[test]\n+fn should_ignore_first_line_indent() {\n+    // The first line of the first paragraph may not be indented as\n+    // far due to the way the doc string was written:\n+    //\n+    // #[doc = \"Start way over here\n+    //          and continue here\"]\n+    let s = \"line1\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n+    let s = \"line1\\n\\n    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\n\\n    line2\");\n+}\n+\n+#[test]\n+fn should_unindent_tabs() {\n+    let s = \"\\tline1\\n\\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_trim_mixed_indentation() {\n+    let s = \"\\t    line1\\n\\t    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+\n+    let s = \"    \\tline1\\n    \\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1\\nline2\");\n+}\n+\n+#[test]\n+fn should_not_trim() {\n+    let s = \"\\t    line1  \\n\\t    line2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1  \\nline2\");\n+\n+    let s = \"    \\tline1  \\n    \\tline2\".to_string();\n+    let r = unindent(&s);\n+    assert_eq!(r, \"line1  \\nline2\");\n+}"}, {"sha": "7037a146c50ab23e566f86947b2a84499442e7cf", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 3, "deletions": 106, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -5,6 +5,9 @@ use std::path::Path;\n \n use errors::Handler;\n \n+#[cfg(test)]\n+mod tests;\n+\n macro_rules! try_something {\n     ($e:expr, $diag:expr, $out:expr) => ({\n         match $e {\n@@ -275,109 +278,3 @@ pub fn test_theme_against<P: AsRef<Path>>(\n     get_differences(against, &paths, &mut ret);\n     (true, ret)\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-\n-    #[test]\n-    fn test_comments_in_rules() {\n-        let text = r#\"\n-rule a {}\n-\n-rule b, c\n-// a line comment\n-{}\n-\n-rule d\n-// another line comment\n-e {}\n-\n-rule f/* a multine\n-\n-comment*/{}\n-\n-rule g/* another multine\n-\n-comment*/h\n-\n-i {}\n-\n-rule j/*commeeeeent\n-\n-you like things like \"{}\" in there? :)\n-*/\n-end {}\"#;\n-\n-        let against = r#\"\n-rule a {}\n-\n-rule b, c {}\n-\n-rule d e {}\n-\n-rule f {}\n-\n-rule gh i {}\n-\n-rule j end {}\n-\"#;\n-\n-        let mut ret = Vec::new();\n-        get_differences(&load_css_paths(against.as_bytes()),\n-                        &load_css_paths(text.as_bytes()),\n-                        &mut ret);\n-        assert!(ret.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_text() {\n-        let text = r#\"\n-a\n-/* sdfs\n-*/ b\n-c // sdf\n-d {}\n-\"#;\n-        let paths = load_css_paths(text.as_bytes());\n-        assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n-    }\n-\n-    #[test]\n-    fn test_comparison() {\n-        let x = r#\"\n-a {\n-    b {\n-        c {}\n-    }\n-}\n-\"#;\n-\n-        let y = r#\"\n-a {\n-    b {}\n-}\n-\"#;\n-\n-        let against = load_css_paths(y.as_bytes());\n-        let other = load_css_paths(x.as_bytes());\n-\n-        let mut ret = Vec::new();\n-        get_differences(&against, &other, &mut ret);\n-        assert!(ret.is_empty());\n-        get_differences(&other, &against, &mut ret);\n-        assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n-    }\n-\n-    #[test]\n-    fn check_empty_css() {\n-        let events = load_css_events(&[]);\n-        assert_eq!(events.len(), 0);\n-    }\n-\n-    #[test]\n-    fn check_invalid_css() {\n-        let events = load_css_events(b\"*\");\n-        assert_eq!(events.len(), 0);\n-    }\n-}"}, {"sha": "ab0935bc494261d95f6ef5efca3a80d46957b4f0", "filename": "src/librustdoc/theme/tests.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,102 @@\n+use super::*;\n+\n+#[test]\n+fn test_comments_in_rules() {\n+    let text = r#\"\n+rule a {}\n+\n+rule b, c\n+// a line comment\n+{}\n+\n+rule d\n+// another line comment\n+e {}\n+\n+rule f/* a multine\n+\n+comment*/{}\n+\n+rule g/* another multine\n+\n+comment*/h\n+\n+i {}\n+\n+rule j/*commeeeeent\n+\n+you like things like \"{}\" in there? :)\n+*/\n+end {}\"#;\n+\n+    let against = r#\"\n+rule a {}\n+\n+rule b, c {}\n+\n+rule d e {}\n+\n+rule f {}\n+\n+rule gh i {}\n+\n+rule j end {}\n+\"#;\n+\n+    let mut ret = Vec::new();\n+    get_differences(&load_css_paths(against.as_bytes()),\n+                    &load_css_paths(text.as_bytes()),\n+                    &mut ret);\n+    assert!(ret.is_empty());\n+}\n+\n+#[test]\n+fn test_text() {\n+    let text = r#\"\n+a\n+/* sdfs\n+*/ b\n+c // sdf\n+d {}\n+\"#;\n+    let paths = load_css_paths(text.as_bytes());\n+    assert!(paths.children.contains(&CssPath::new(\"a b c d\".to_owned())));\n+}\n+\n+#[test]\n+fn test_comparison() {\n+    let x = r#\"\n+a {\n+    b {\n+        c {}\n+    }\n+}\n+\"#;\n+\n+    let y = r#\"\n+a {\n+    b {}\n+}\n+\"#;\n+\n+    let against = load_css_paths(y.as_bytes());\n+    let other = load_css_paths(x.as_bytes());\n+\n+    let mut ret = Vec::new();\n+    get_differences(&against, &other, &mut ret);\n+    assert!(ret.is_empty());\n+    get_differences(&other, &against, &mut ret);\n+    assert_eq!(ret, vec![\"  Missing \\\"c\\\" rule\".to_owned()]);\n+}\n+\n+#[test]\n+fn check_empty_css() {\n+    let events = load_css_events(&[]);\n+    assert_eq!(events.len(), 0);\n+}\n+\n+#[test]\n+fn check_invalid_css() {\n+    let events = load_css_events(b\"*\");\n+    assert_eq!(events.len(), 0);\n+}"}, {"sha": "88ce6d81d75784c5829c48ab7e11eb63704e28a0", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -138,47 +138,3 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n \n     (result, position - start_position)\n }\n-\n-macro_rules! impl_test_unsigned_leb128 {\n-    ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => (\n-        #[test]\n-        fn $test_name() {\n-            let mut stream = Vec::new();\n-\n-            for x in 0..62 {\n-                $write_fn_name(&mut stream, (3u64 << x) as $int_ty);\n-            }\n-\n-            let mut position = 0;\n-            for x in 0..62 {\n-                let expected = (3u64 << x) as $int_ty;\n-                let (actual, bytes_read) = $read_fn_name(&stream[position ..]);\n-                assert_eq!(expected, actual);\n-                position += bytes_read;\n-            }\n-            assert_eq!(stream.len(), position);\n-        }\n-    )\n-}\n-\n-impl_test_unsigned_leb128!(test_u16_leb128, write_u16_leb128, read_u16_leb128, u16);\n-impl_test_unsigned_leb128!(test_u32_leb128, write_u32_leb128, read_u32_leb128, u32);\n-impl_test_unsigned_leb128!(test_u64_leb128, write_u64_leb128, read_u64_leb128, u64);\n-impl_test_unsigned_leb128!(test_u128_leb128, write_u128_leb128, read_u128_leb128, u128);\n-impl_test_unsigned_leb128!(test_usize_leb128, write_usize_leb128, read_usize_leb128, usize);\n-\n-#[test]\n-fn test_signed_leb128() {\n-    let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n-    let mut stream = Vec::new();\n-    for &x in &values {\n-        write_signed_leb128(&mut stream, x);\n-    }\n-    let mut pos = 0;\n-    for &x in &values {\n-        let (value, bytes_read) = read_signed_leb128(&mut stream, pos);\n-        pos += bytes_read;\n-        assert_eq!(x, value);\n-    }\n-    assert_eq!(pos, stream.len());\n-}"}, {"sha": "4eb4397fecc39f4892fb90b8741d52e9ff05c714", "filename": "src/libserialize/tests/leb128.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibserialize%2Ftests%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibserialize%2Ftests%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Ftests%2Fleb128.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,46 @@\n+extern crate serialize as rustc_serialize;\n+use rustc_serialize::leb128::*;\n+\n+macro_rules! impl_test_unsigned_leb128 {\n+    ($test_name:ident, $write_fn_name:ident, $read_fn_name:ident, $int_ty:ident) => (\n+        #[test]\n+        fn $test_name() {\n+            let mut stream = Vec::new();\n+\n+            for x in 0..62 {\n+                $write_fn_name(&mut stream, (3u64 << x) as $int_ty);\n+            }\n+\n+            let mut position = 0;\n+            for x in 0..62 {\n+                let expected = (3u64 << x) as $int_ty;\n+                let (actual, bytes_read) = $read_fn_name(&stream[position ..]);\n+                assert_eq!(expected, actual);\n+                position += bytes_read;\n+            }\n+            assert_eq!(stream.len(), position);\n+        }\n+    )\n+}\n+\n+impl_test_unsigned_leb128!(test_u16_leb128, write_u16_leb128, read_u16_leb128, u16);\n+impl_test_unsigned_leb128!(test_u32_leb128, write_u32_leb128, read_u32_leb128, u32);\n+impl_test_unsigned_leb128!(test_u64_leb128, write_u64_leb128, read_u64_leb128, u64);\n+impl_test_unsigned_leb128!(test_u128_leb128, write_u128_leb128, read_u128_leb128, u128);\n+impl_test_unsigned_leb128!(test_usize_leb128, write_usize_leb128, read_usize_leb128, usize);\n+\n+#[test]\n+fn test_signed_leb128() {\n+    let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n+    let mut stream = Vec::new();\n+    for &x in &values {\n+        write_signed_leb128(&mut stream, x);\n+    }\n+    let mut pos = 0;\n+    for &x in &values {\n+        let (value, bytes_read) = read_signed_leb128(&mut stream, pos);\n+        pos += bytes_read;\n+        assert_eq!(x, value);\n+    }\n+    assert_eq!(pos, stream.len());\n+}"}, {"sha": "87113b4b98efcbea3404508b712999d66410cedc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -27,6 +27,9 @@ use std::fmt;\n \n pub use rustc_target::abi::FloatTy;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct Label {\n     pub ident: Ident,\n@@ -2432,15 +2435,3 @@ impl ForeignItemKind {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    // Are ASTs encodable?\n-    #[test]\n-    fn check_asts_encodable() {\n-        fn assert_encodable<T: rustc_serialize::Encodable>() {}\n-        assert_encodable::<Crate>();\n-    }\n-}"}, {"sha": "7558e9cc3a3afd676fde5742d528273bd41a534f", "filename": "src/libsyntax/ast/tests.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fast%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fast%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,8 @@\n+use super::*;\n+\n+// Are ASTs encodable?\n+#[test]\n+fn check_asts_encodable() {\n+    fn assert_encodable<T: rustc_serialize::Encodable>() {}\n+    assert_encodable::<Crate>();\n+}"}, {"sha": "8ac48d8d74a42dcf463854e36358a07010a59ee8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -33,6 +33,9 @@ pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n use syntax_pos::edition::Edition;\n \n+#[cfg(test)]\n+mod tests;\n+\n const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n@@ -132,8 +135,6 @@ pub mod util {\n     pub mod lev_distance;\n     pub mod node_count;\n     pub mod parser;\n-    #[cfg(test)]\n-    pub mod parser_testing;\n     pub mod map_in_place;\n }\n \n@@ -183,7 +184,4 @@ pub mod ext {\n \n pub mod early_buffered_lints;\n \n-#[cfg(test)]\n-mod test_snippet;\n-\n __build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}, {"sha": "a5085c5f879601cb50629c9fad95aa520a1d39a1", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -22,6 +22,9 @@ use rustc_data_structures::sync::Lrc;\n use std::ops::DerefMut;\n use std::{panic, process, ptr};\n \n+#[cfg(test)]\n+mod tests;\n+\n pub trait ExpectOne<A: Array> {\n     fn expect_one(self, err: &'static str) -> A::Item;\n }\n@@ -1255,77 +1258,3 @@ pub fn noop_visit_vis<T: MutVisitor>(Spanned { node, span }: &mut Visibility, vi\n     }\n     vis.visit_span(span);\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::ast::{self, Ident};\n-    use crate::util::parser_testing::{string_to_crate, matches_codepattern};\n-    use crate::print::pprust;\n-    use crate::mut_visit;\n-    use crate::with_default_globals;\n-    use super::*;\n-\n-    // this version doesn't care about getting comments or docstrings in.\n-    fn fake_print_crate(s: &mut pprust::State<'_>,\n-                        krate: &ast::Crate) {\n-        s.print_mod(&krate.module, &krate.attrs)\n-    }\n-\n-    // change every identifier to \"zz\"\n-    struct ToZzIdentMutVisitor;\n-\n-    impl MutVisitor for ToZzIdentMutVisitor {\n-        fn visit_ident(&mut self, ident: &mut ast::Ident) {\n-            *ident = Ident::from_str(\"zz\");\n-        }\n-        fn visit_mac(&mut self, mac: &mut ast::Mac) {\n-            mut_visit::noop_visit_mac(mac, self)\n-        }\n-    }\n-\n-    // maybe add to expand.rs...\n-    macro_rules! assert_pred {\n-        ($pred:expr, $predname:expr, $a:expr , $b:expr) => (\n-            {\n-                let pred_val = $pred;\n-                let a_val = $a;\n-                let b_val = $b;\n-                if !(pred_val(&a_val, &b_val)) {\n-                    panic!(\"expected args satisfying {}, got {} and {}\",\n-                          $predname, a_val, b_val);\n-                }\n-            }\n-        )\n-    }\n-\n-    // make sure idents get transformed everywhere\n-    #[test] fn ident_transformation () {\n-        with_default_globals(|| {\n-            let mut zz_visitor = ToZzIdentMutVisitor;\n-            let mut krate = string_to_crate(\n-                \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_string());\n-            zz_visitor.visit_crate(&mut krate);\n-            assert_pred!(\n-                matches_codepattern,\n-                \"matches_codepattern\",\n-                pprust::to_string(|s| fake_print_crate(s, &krate)),\n-                \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n-        })\n-    }\n-\n-    // even inside macro defs....\n-    #[test] fn ident_transformation_in_defs () {\n-        with_default_globals(|| {\n-            let mut zz_visitor = ToZzIdentMutVisitor;\n-            let mut krate = string_to_crate(\n-                \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n-                (g $(d $d $e)+))} \".to_string());\n-            zz_visitor.visit_crate(&mut krate);\n-            assert_pred!(\n-                matches_codepattern,\n-                \"matches_codepattern\",\n-                pprust::to_string(|s| fake_print_crate(s, &krate)),\n-                \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string());\n-        })\n-    }\n-}"}, {"sha": "6868736976b253f9b2ccb150a9e1fc678f784423", "filename": "src/libsyntax/mut_visit/tests.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,71 @@\n+use super::*;\n+\n+use crate::ast::{self, Ident};\n+use crate::tests::{string_to_crate, matches_codepattern};\n+use crate::print::pprust;\n+use crate::mut_visit;\n+use crate::with_default_globals;\n+\n+// this version doesn't care about getting comments or docstrings in.\n+fn fake_print_crate(s: &mut pprust::State<'_>,\n+                    krate: &ast::Crate) {\n+    s.print_mod(&krate.module, &krate.attrs)\n+}\n+\n+// change every identifier to \"zz\"\n+struct ToZzIdentMutVisitor;\n+\n+impl MutVisitor for ToZzIdentMutVisitor {\n+    fn visit_ident(&mut self, ident: &mut ast::Ident) {\n+        *ident = Ident::from_str(\"zz\");\n+    }\n+    fn visit_mac(&mut self, mac: &mut ast::Mac) {\n+        mut_visit::noop_visit_mac(mac, self)\n+    }\n+}\n+\n+// maybe add to expand.rs...\n+macro_rules! assert_pred {\n+    ($pred:expr, $predname:expr, $a:expr , $b:expr) => (\n+        {\n+            let pred_val = $pred;\n+            let a_val = $a;\n+            let b_val = $b;\n+            if !(pred_val(&a_val, &b_val)) {\n+                panic!(\"expected args satisfying {}, got {} and {}\",\n+                        $predname, a_val, b_val);\n+            }\n+        }\n+    )\n+}\n+\n+// make sure idents get transformed everywhere\n+#[test] fn ident_transformation () {\n+    with_default_globals(|| {\n+        let mut zz_visitor = ToZzIdentMutVisitor;\n+        let mut krate = string_to_crate(\n+            \"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\".to_string());\n+        zz_visitor.visit_crate(&mut krate);\n+        assert_pred!(\n+            matches_codepattern,\n+            \"matches_codepattern\",\n+            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            \"#[zz]mod zz{fn zz(zz:zz,zz:zz){zz!(zz,zz,zz);zz;zz}}\".to_string());\n+    })\n+}\n+\n+// even inside macro defs....\n+#[test] fn ident_transformation_in_defs () {\n+    with_default_globals(|| {\n+        let mut zz_visitor = ToZzIdentMutVisitor;\n+        let mut krate = string_to_crate(\n+            \"macro_rules! a {(b $c:expr $(d $e:token)f+ => \\\n+            (g $(d $d $e)+))} \".to_string());\n+        zz_visitor.visit_crate(&mut krate);\n+        assert_pred!(\n+            matches_codepattern,\n+            \"matches_codepattern\",\n+            pprust::to_string(|s| fake_print_crate(s, &krate)),\n+            \"macro_rules! zz{(zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+))}\".to_string());\n+    })\n+}"}, {"sha": "5121a9ef7b5fca2561fb727c387dff0939892c7b", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -9,6 +9,9 @@ use syntax_pos::{BytePos, CharPos, Pos, FileName};\n \n use std::usize;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum CommentStyle {\n     /// No code on either side of each line of the comment\n@@ -249,54 +252,3 @@ pub fn gather_comments(sess: &ParseSess, path: FileName, src: String) -> Vec<Com\n \n     comments\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_block_doc_comment_1() {\n-        let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n-        let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n-    }\n-\n-    #[test]\n-    fn test_block_doc_comment_2() {\n-        let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n-        let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" Test\\n  Test\");\n-    }\n-\n-    #[test]\n-    fn test_block_doc_comment_3() {\n-        let comment = \"/**\\n let a: *i32;\\n *a = 5;\\n*/\";\n-        let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n-    }\n-\n-    #[test]\n-    fn test_block_doc_comment_4() {\n-        let comment = \"/*******************\\n test\\n *********************/\";\n-        let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" test\");\n-    }\n-\n-    #[test]\n-    fn test_line_doc_comment() {\n-        let stripped = strip_doc_comment_decoration(\"/// test\");\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(\"///! test\");\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(\"// test\");\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(\"///test\");\n-        assert_eq!(stripped, \"test\");\n-        let stripped = strip_doc_comment_decoration(\"///!test\");\n-        assert_eq!(stripped, \"test\");\n-        let stripped = strip_doc_comment_decoration(\"//test\");\n-        assert_eq!(stripped, \"test\");\n-    }\n-}"}, {"sha": "f9cd69fb50d7472c9b3044c9c5f2fc3be279cdb2", "filename": "src/libsyntax/parse/lexer/comments/tests.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,47 @@\n+use super::*;\n+\n+#[test]\n+fn test_block_doc_comment_1() {\n+    let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n+    let stripped = strip_doc_comment_decoration(comment);\n+    assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n+}\n+\n+#[test]\n+fn test_block_doc_comment_2() {\n+    let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n+    let stripped = strip_doc_comment_decoration(comment);\n+    assert_eq!(stripped, \" Test\\n  Test\");\n+}\n+\n+#[test]\n+fn test_block_doc_comment_3() {\n+    let comment = \"/**\\n let a: *i32;\\n *a = 5;\\n*/\";\n+    let stripped = strip_doc_comment_decoration(comment);\n+    assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n+}\n+\n+#[test]\n+fn test_block_doc_comment_4() {\n+    let comment = \"/*******************\\n test\\n *********************/\";\n+    let stripped = strip_doc_comment_decoration(comment);\n+    assert_eq!(stripped, \" test\");\n+}\n+\n+#[test]\n+fn test_line_doc_comment() {\n+    let stripped = strip_doc_comment_decoration(\"/// test\");\n+    assert_eq!(stripped, \" test\");\n+    let stripped = strip_doc_comment_decoration(\"///! test\");\n+    assert_eq!(stripped, \" test\");\n+    let stripped = strip_doc_comment_decoration(\"// test\");\n+    assert_eq!(stripped, \" test\");\n+    let stripped = strip_doc_comment_decoration(\"// test\");\n+    assert_eq!(stripped, \" test\");\n+    let stripped = strip_doc_comment_decoration(\"///test\");\n+    assert_eq!(stripped, \"test\");\n+    let stripped = strip_doc_comment_decoration(\"///!test\");\n+    assert_eq!(stripped, \"test\");\n+    let stripped = strip_doc_comment_decoration(\"//test\");\n+    assert_eq!(stripped, \"test\");\n+}"}, {"sha": "950b1b2ff53404639abe034df636a5b1e1b1f900", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 259, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -15,6 +15,9 @@ use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub mod comments;\n mod tokentrees;\n mod unicode_chars;\n@@ -777,262 +780,3 @@ fn is_block_doc_comment(s: &str) -> bool {\n     debug!(\"is {:?} a doc comment? {}\", s, res);\n     res\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::ast::CrateConfig;\n-    use crate::symbol::Symbol;\n-    use crate::source_map::{SourceMap, FilePathMapping};\n-    use crate::feature_gate::UnstableFeatures;\n-    use crate::parse::token;\n-    use crate::diagnostics::plugin::ErrorMap;\n-    use crate::with_default_globals;\n-    use std::io;\n-    use std::path::PathBuf;\n-    use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n-    use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-    use rustc_data_structures::sync::{Lock, Once};\n-\n-    fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n-        let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n-                                                          Some(sm.clone()),\n-                                                          false,\n-                                                          false,\n-                                                          false);\n-        ParseSess {\n-            span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),\n-            unstable_features: UnstableFeatures::from_environment(),\n-            config: CrateConfig::default(),\n-            included_mod_stack: Lock::new(Vec::new()),\n-            source_map: sm,\n-            missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n-            raw_identifier_spans: Lock::new(Vec::new()),\n-            registered_diagnostics: Lock::new(ErrorMap::new()),\n-            buffered_lints: Lock::new(vec![]),\n-            edition: Edition::from_session(),\n-            ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            param_attr_spans: Lock::new(Vec::new()),\n-            let_chains_spans: Lock::new(Vec::new()),\n-            async_closure_spans: Lock::new(Vec::new()),\n-            injected_crate_name: Once::new(),\n-        }\n-    }\n-\n-    // open a string reader for the given string\n-    fn setup<'a>(sm: &SourceMap,\n-                 sess: &'a ParseSess,\n-                 teststr: String)\n-                 -> StringReader<'a> {\n-        let sf = sm.new_source_file(PathBuf::from(teststr.clone()).into(), teststr);\n-        StringReader::new(sess, sf, None)\n-    }\n-\n-    #[test]\n-    fn t1() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            let mut string_reader = setup(&sm,\n-                                        &sh,\n-                                        \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n-                                            .to_string());\n-            assert_eq!(string_reader.next_token(), token::Comment);\n-            assert_eq!(string_reader.next_token(), token::Whitespace);\n-            let tok1 = string_reader.next_token();\n-            let tok2 = Token::new(\n-                mk_ident(\"fn\"),\n-                Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n-            );\n-            assert_eq!(tok1.kind, tok2.kind);\n-            assert_eq!(tok1.span, tok2.span);\n-            assert_eq!(string_reader.next_token(), token::Whitespace);\n-            // read another token:\n-            let tok3 = string_reader.next_token();\n-            assert_eq!(string_reader.pos.clone(), BytePos(28));\n-            let tok4 = Token::new(\n-                mk_ident(\"main\"),\n-                Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n-            );\n-            assert_eq!(tok3.kind, tok4.kind);\n-            assert_eq!(tok3.span, tok4.span);\n-\n-            assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n-            assert_eq!(string_reader.pos.clone(), BytePos(29))\n-        })\n-    }\n-\n-    // check that the given reader produces the desired stream\n-    // of tokens (stop checking after exhausting the expected vec)\n-    fn check_tokenization(mut string_reader: StringReader<'_>, expected: Vec<TokenKind>) {\n-        for expected_tok in &expected {\n-            assert_eq!(&string_reader.next_token(), expected_tok);\n-        }\n-    }\n-\n-    // make the identifier by looking up the string in the interner\n-    fn mk_ident(id: &str) -> TokenKind {\n-        token::Ident(Symbol::intern(id), false)\n-    }\n-\n-    fn mk_lit(kind: token::LitKind, symbol: &str, suffix: Option<&str>) -> TokenKind {\n-        TokenKind::lit(kind, Symbol::intern(symbol), suffix.map(Symbol::intern))\n-    }\n-\n-    #[test]\n-    fn doublecolonparsing() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            check_tokenization(setup(&sm, &sh, \"a b\".to_string()),\n-                            vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n-        })\n-    }\n-\n-    #[test]\n-    fn dcparsing_2() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            check_tokenization(setup(&sm, &sh, \"a::b\".to_string()),\n-                            vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n-        })\n-    }\n-\n-    #[test]\n-    fn dcparsing_3() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            check_tokenization(setup(&sm, &sh, \"a ::b\".to_string()),\n-                            vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n-        })\n-    }\n-\n-    #[test]\n-    fn dcparsing_4() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            check_tokenization(setup(&sm, &sh, \"a:: b\".to_string()),\n-                            vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n-        })\n-    }\n-\n-    #[test]\n-    fn character_a() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            assert_eq!(setup(&sm, &sh, \"'a'\".to_string()).next_token(),\n-                       mk_lit(token::Char, \"a\", None));\n-        })\n-    }\n-\n-    #[test]\n-    fn character_space() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            assert_eq!(setup(&sm, &sh, \"' '\".to_string()).next_token(),\n-                       mk_lit(token::Char, \" \", None));\n-        })\n-    }\n-\n-    #[test]\n-    fn character_escaped() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            assert_eq!(setup(&sm, &sh, \"'\\\\n'\".to_string()).next_token(),\n-                       mk_lit(token::Char, \"\\\\n\", None));\n-        })\n-    }\n-\n-    #[test]\n-    fn lifetime_name() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            assert_eq!(setup(&sm, &sh, \"'abc\".to_string()).next_token(),\n-                       token::Lifetime(Symbol::intern(\"'abc\")));\n-        })\n-    }\n-\n-    #[test]\n-    fn raw_string() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            assert_eq!(setup(&sm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token(),\n-                       mk_lit(token::StrRaw(3), \"\\\"#a\\\\b\\x00c\\\"\", None));\n-        })\n-    }\n-\n-    #[test]\n-    fn literal_suffixes() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            macro_rules! test {\n-                ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n-                    assert_eq!(setup(&sm, &sh, format!(\"{}suffix\", $input)).next_token(),\n-                               mk_lit(token::$tok_type, $tok_contents, Some(\"suffix\")));\n-                    // with a whitespace separator:\n-                    assert_eq!(setup(&sm, &sh, format!(\"{} suffix\", $input)).next_token(),\n-                               mk_lit(token::$tok_type, $tok_contents, None));\n-                }}\n-            }\n-\n-            test!(\"'a'\", Char, \"a\");\n-            test!(\"b'a'\", Byte, \"a\");\n-            test!(\"\\\"a\\\"\", Str, \"a\");\n-            test!(\"b\\\"a\\\"\", ByteStr, \"a\");\n-            test!(\"1234\", Integer, \"1234\");\n-            test!(\"0b101\", Integer, \"0b101\");\n-            test!(\"0xABC\", Integer, \"0xABC\");\n-            test!(\"1.0\", Float, \"1.0\");\n-            test!(\"1.0e10\", Float, \"1.0e10\");\n-\n-            assert_eq!(setup(&sm, &sh, \"2us\".to_string()).next_token(),\n-                       mk_lit(token::Integer, \"2\", Some(\"us\")));\n-            assert_eq!(setup(&sm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token(),\n-                       mk_lit(token::StrRaw(3), \"raw\", Some(\"suffix\")));\n-            assert_eq!(setup(&sm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token(),\n-                       mk_lit(token::ByteStrRaw(3), \"raw\", Some(\"suffix\")));\n-        })\n-    }\n-\n-    #[test]\n-    fn line_doc_comments() {\n-        assert!(is_doc_comment(\"///\"));\n-        assert!(is_doc_comment(\"/// blah\"));\n-        assert!(!is_doc_comment(\"////\"));\n-    }\n-\n-    #[test]\n-    fn nested_block_comments() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            let mut lexer = setup(&sm, &sh, \"/* /* */ */'a'\".to_string());\n-            assert_eq!(lexer.next_token(), token::Comment);\n-            assert_eq!(lexer.next_token(), mk_lit(token::Char, \"a\", None));\n-        })\n-    }\n-\n-    #[test]\n-    fn crlf_comments() {\n-        with_default_globals(|| {\n-            let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            let sh = mk_sess(sm.clone());\n-            let mut lexer = setup(&sm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n-            let comment = lexer.next_token();\n-            assert_eq!(comment.kind, token::Comment);\n-            assert_eq!((comment.span.lo(), comment.span.hi()), (BytePos(0), BytePos(7)));\n-            assert_eq!(lexer.next_token(), token::Whitespace);\n-            assert_eq!(lexer.next_token(), token::DocComment(Symbol::intern(\"/// test\")));\n-        })\n-    }\n-}"}, {"sha": "fc47e4f0b185ac219b164ddb646dedea5f465619", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,255 @@\n+use super::*;\n+\n+use crate::ast::CrateConfig;\n+use crate::symbol::Symbol;\n+use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::feature_gate::UnstableFeatures;\n+use crate::parse::token;\n+use crate::diagnostics::plugin::ErrorMap;\n+use crate::with_default_globals;\n+use std::io;\n+use std::path::PathBuf;\n+use syntax_pos::{BytePos, Span, NO_EXPANSION, edition::Edition};\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::sync::{Lock, Once};\n+\n+fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n+    let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n+                                                        Some(sm.clone()),\n+                                                        false,\n+                                                        false,\n+                                                        false);\n+    ParseSess {\n+        span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),\n+        unstable_features: UnstableFeatures::from_environment(),\n+        config: CrateConfig::default(),\n+        included_mod_stack: Lock::new(Vec::new()),\n+        source_map: sm,\n+        missing_fragment_specifiers: Lock::new(FxHashSet::default()),\n+        raw_identifier_spans: Lock::new(Vec::new()),\n+        registered_diagnostics: Lock::new(ErrorMap::new()),\n+        buffered_lints: Lock::new(vec![]),\n+        edition: Edition::from_session(),\n+        ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n+        param_attr_spans: Lock::new(Vec::new()),\n+        let_chains_spans: Lock::new(Vec::new()),\n+        async_closure_spans: Lock::new(Vec::new()),\n+        injected_crate_name: Once::new(),\n+    }\n+}\n+\n+// open a string reader for the given string\n+fn setup<'a>(sm: &SourceMap,\n+                sess: &'a ParseSess,\n+                teststr: String)\n+                -> StringReader<'a> {\n+    let sf = sm.new_source_file(PathBuf::from(teststr.clone()).into(), teststr);\n+    StringReader::new(sess, sf, None)\n+}\n+\n+#[test]\n+fn t1() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        let mut string_reader = setup(&sm,\n+                                    &sh,\n+                                    \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n+                                        .to_string());\n+        assert_eq!(string_reader.next_token(), token::Comment);\n+        assert_eq!(string_reader.next_token(), token::Whitespace);\n+        let tok1 = string_reader.next_token();\n+        let tok2 = Token::new(\n+            mk_ident(\"fn\"),\n+            Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n+        );\n+        assert_eq!(tok1.kind, tok2.kind);\n+        assert_eq!(tok1.span, tok2.span);\n+        assert_eq!(string_reader.next_token(), token::Whitespace);\n+        // read another token:\n+        let tok3 = string_reader.next_token();\n+        assert_eq!(string_reader.pos.clone(), BytePos(28));\n+        let tok4 = Token::new(\n+            mk_ident(\"main\"),\n+            Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n+        );\n+        assert_eq!(tok3.kind, tok4.kind);\n+        assert_eq!(tok3.span, tok4.span);\n+\n+        assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n+        assert_eq!(string_reader.pos.clone(), BytePos(29))\n+    })\n+}\n+\n+// check that the given reader produces the desired stream\n+// of tokens (stop checking after exhausting the expected vec)\n+fn check_tokenization(mut string_reader: StringReader<'_>, expected: Vec<TokenKind>) {\n+    for expected_tok in &expected {\n+        assert_eq!(&string_reader.next_token(), expected_tok);\n+    }\n+}\n+\n+// make the identifier by looking up the string in the interner\n+fn mk_ident(id: &str) -> TokenKind {\n+    token::Ident(Symbol::intern(id), false)\n+}\n+\n+fn mk_lit(kind: token::LitKind, symbol: &str, suffix: Option<&str>) -> TokenKind {\n+    TokenKind::lit(kind, Symbol::intern(symbol), suffix.map(Symbol::intern))\n+}\n+\n+#[test]\n+fn doublecolonparsing() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        check_tokenization(setup(&sm, &sh, \"a b\".to_string()),\n+                        vec![mk_ident(\"a\"), token::Whitespace, mk_ident(\"b\")]);\n+    })\n+}\n+\n+#[test]\n+fn dcparsing_2() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        check_tokenization(setup(&sm, &sh, \"a::b\".to_string()),\n+                        vec![mk_ident(\"a\"), token::ModSep, mk_ident(\"b\")]);\n+    })\n+}\n+\n+#[test]\n+fn dcparsing_3() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        check_tokenization(setup(&sm, &sh, \"a ::b\".to_string()),\n+                        vec![mk_ident(\"a\"), token::Whitespace, token::ModSep, mk_ident(\"b\")]);\n+    })\n+}\n+\n+#[test]\n+fn dcparsing_4() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        check_tokenization(setup(&sm, &sh, \"a:: b\".to_string()),\n+                        vec![mk_ident(\"a\"), token::ModSep, token::Whitespace, mk_ident(\"b\")]);\n+    })\n+}\n+\n+#[test]\n+fn character_a() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        assert_eq!(setup(&sm, &sh, \"'a'\".to_string()).next_token(),\n+                    mk_lit(token::Char, \"a\", None));\n+    })\n+}\n+\n+#[test]\n+fn character_space() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        assert_eq!(setup(&sm, &sh, \"' '\".to_string()).next_token(),\n+                    mk_lit(token::Char, \" \", None));\n+    })\n+}\n+\n+#[test]\n+fn character_escaped() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        assert_eq!(setup(&sm, &sh, \"'\\\\n'\".to_string()).next_token(),\n+                    mk_lit(token::Char, \"\\\\n\", None));\n+    })\n+}\n+\n+#[test]\n+fn lifetime_name() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        assert_eq!(setup(&sm, &sh, \"'abc\".to_string()).next_token(),\n+                    token::Lifetime(Symbol::intern(\"'abc\")));\n+    })\n+}\n+\n+#[test]\n+fn raw_string() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        assert_eq!(setup(&sm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string()).next_token(),\n+                    mk_lit(token::StrRaw(3), \"\\\"#a\\\\b\\x00c\\\"\", None));\n+    })\n+}\n+\n+#[test]\n+fn literal_suffixes() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        macro_rules! test {\n+            ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n+                assert_eq!(setup(&sm, &sh, format!(\"{}suffix\", $input)).next_token(),\n+                            mk_lit(token::$tok_type, $tok_contents, Some(\"suffix\")));\n+                // with a whitespace separator:\n+                assert_eq!(setup(&sm, &sh, format!(\"{} suffix\", $input)).next_token(),\n+                            mk_lit(token::$tok_type, $tok_contents, None));\n+            }}\n+        }\n+\n+        test!(\"'a'\", Char, \"a\");\n+        test!(\"b'a'\", Byte, \"a\");\n+        test!(\"\\\"a\\\"\", Str, \"a\");\n+        test!(\"b\\\"a\\\"\", ByteStr, \"a\");\n+        test!(\"1234\", Integer, \"1234\");\n+        test!(\"0b101\", Integer, \"0b101\");\n+        test!(\"0xABC\", Integer, \"0xABC\");\n+        test!(\"1.0\", Float, \"1.0\");\n+        test!(\"1.0e10\", Float, \"1.0e10\");\n+\n+        assert_eq!(setup(&sm, &sh, \"2us\".to_string()).next_token(),\n+                    mk_lit(token::Integer, \"2\", Some(\"us\")));\n+        assert_eq!(setup(&sm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token(),\n+                    mk_lit(token::StrRaw(3), \"raw\", Some(\"suffix\")));\n+        assert_eq!(setup(&sm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token(),\n+                    mk_lit(token::ByteStrRaw(3), \"raw\", Some(\"suffix\")));\n+    })\n+}\n+\n+#[test]\n+fn line_doc_comments() {\n+    assert!(is_doc_comment(\"///\"));\n+    assert!(is_doc_comment(\"/// blah\"));\n+    assert!(!is_doc_comment(\"////\"));\n+}\n+\n+#[test]\n+fn nested_block_comments() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        let mut lexer = setup(&sm, &sh, \"/* /* */ */'a'\".to_string());\n+        assert_eq!(lexer.next_token(), token::Comment);\n+        assert_eq!(lexer.next_token(), mk_lit(token::Char, \"a\", None));\n+    })\n+}\n+\n+#[test]\n+fn crlf_comments() {\n+    with_default_globals(|| {\n+        let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+        let sh = mk_sess(sm.clone());\n+        let mut lexer = setup(&sm, &sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n+        let comment = lexer.next_token();\n+        assert_eq!(comment.kind, token::Comment);\n+        assert_eq!((comment.span.lo(), comment.span.hi()), (BytePos(0), BytePos(7)));\n+        assert_eq!(lexer.next_token(), token::Whitespace);\n+        assert_eq!(lexer.next_token(), token::DocComment(Symbol::intern(\"/// test\")));\n+    })\n+}"}, {"sha": "80aa7a35266ebb9e54161ac17dea4a6581a9f293", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 292, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -22,7 +22,8 @@ use std::borrow::Cow;\n use std::path::{Path, PathBuf};\n use std::str;\n \n-pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n+#[cfg(test)]\n+mod tests;\n \n #[macro_use]\n pub mod parser;\n@@ -35,6 +36,8 @@ crate mod diagnostics;\n crate mod literal;\n crate mod unescape_error_reporting;\n \n+pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n+\n /// Info about a parsing session.\n pub struct ParseSess {\n     pub span_diagnostic: Handler,\n@@ -389,294 +392,3 @@ impl SeqSep {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::ast::{self, Name, PatKind};\n-    use crate::attr::first_attr_value_str_by_name;\n-    use crate::ptr::P;\n-    use crate::parse::token::Token;\n-    use crate::print::pprust::item_to_string;\n-    use crate::symbol::{kw, sym};\n-    use crate::tokenstream::{DelimSpan, TokenTree};\n-    use crate::util::parser_testing::string_to_stream;\n-    use crate::util::parser_testing::{string_to_expr, string_to_item};\n-    use crate::with_default_globals;\n-    use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n-\n-    /// Parses an item.\n-    ///\n-    /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n-    /// when a syntax error occurred.\n-    fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                        -> PResult<'_, Option<P<ast::Item>>> {\n-        new_parser_from_source_str(sess, name, source).parse_item()\n-    }\n-\n-    // produce a syntax_pos::span\n-    fn sp(a: u32, b: u32) -> Span {\n-        Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n-    }\n-\n-    #[should_panic]\n-    #[test] fn bad_path_expr_1() {\n-        with_default_globals(|| {\n-            string_to_expr(\"::abc::def::return\".to_string());\n-        })\n-    }\n-\n-    // check the token-tree-ization of macros\n-    #[test]\n-    fn string_to_tts_macro () {\n-        with_default_globals(|| {\n-            let tts: Vec<_> =\n-                string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n-            let tts: &[TokenTree] = &tts[..];\n-\n-            match tts {\n-                [\n-                    TokenTree::Token(Token { kind: token::Ident(name_macro_rules, false), .. }),\n-                    TokenTree::Token(Token { kind: token::Not, .. }),\n-                    TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. }),\n-                    TokenTree::Delimited(_, macro_delim,  macro_tts)\n-                ]\n-                if name_macro_rules == &sym::macro_rules && name_zip.as_str() == \"zip\" => {\n-                    let tts = &macro_tts.trees().collect::<Vec<_>>();\n-                    match &tts[..] {\n-                        [\n-                            TokenTree::Delimited(_, first_delim, first_tts),\n-                            TokenTree::Token(Token { kind: token::FatArrow, .. }),\n-                            TokenTree::Delimited(_, second_delim, second_tts),\n-                        ]\n-                        if macro_delim == &token::Paren => {\n-                            let tts = &first_tts.trees().collect::<Vec<_>>();\n-                            match &tts[..] {\n-                                [\n-                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n-                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n-                                ]\n-                                if first_delim == &token::Paren && name.as_str() == \"a\" => {},\n-                                _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n-                            }\n-                            let tts = &second_tts.trees().collect::<Vec<_>>();\n-                            match &tts[..] {\n-                                [\n-                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n-                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n-                                ]\n-                                if second_delim == &token::Paren && name.as_str() == \"a\" => {},\n-                                _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n-                            }\n-                        },\n-                        _ => panic!(\"value 2: {:?} {:?}\", macro_delim, macro_tts),\n-                    }\n-                },\n-                _ => panic!(\"value: {:?}\",tts),\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn string_to_tts_1() {\n-        with_default_globals(|| {\n-            let tts = string_to_stream(\"fn a (b : i32) { b; }\".to_string());\n-\n-            let expected = TokenStream::new(vec![\n-                TokenTree::token(token::Ident(kw::Fn, false), sp(0, 2)).into(),\n-                TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(3, 4)).into(),\n-                TokenTree::Delimited(\n-                    DelimSpan::from_pair(sp(5, 6), sp(13, 14)),\n-                    token::DelimToken::Paren,\n-                    TokenStream::new(vec![\n-                        TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(6, 7)).into(),\n-                        TokenTree::token(token::Colon, sp(8, 9)).into(),\n-                        TokenTree::token(token::Ident(sym::i32, false), sp(10, 13)).into(),\n-                    ]).into(),\n-                ).into(),\n-                TokenTree::Delimited(\n-                    DelimSpan::from_pair(sp(15, 16), sp(20, 21)),\n-                    token::DelimToken::Brace,\n-                    TokenStream::new(vec![\n-                        TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(17, 18)).into(),\n-                        TokenTree::token(token::Semi, sp(18, 19)).into(),\n-                    ]).into(),\n-                ).into()\n-            ]);\n-\n-            assert_eq!(tts, expected);\n-        })\n-    }\n-\n-    #[test] fn parse_use() {\n-        with_default_globals(|| {\n-            let use_s = \"use foo::bar::baz;\";\n-            let vitem = string_to_item(use_s.to_string()).unwrap();\n-            let vitem_s = item_to_string(&vitem);\n-            assert_eq!(&vitem_s[..], use_s);\n-\n-            let use_s = \"use foo::bar as baz;\";\n-            let vitem = string_to_item(use_s.to_string()).unwrap();\n-            let vitem_s = item_to_string(&vitem);\n-            assert_eq!(&vitem_s[..], use_s);\n-        })\n-    }\n-\n-    #[test] fn parse_extern_crate() {\n-        with_default_globals(|| {\n-            let ex_s = \"extern crate foo;\";\n-            let vitem = string_to_item(ex_s.to_string()).unwrap();\n-            let vitem_s = item_to_string(&vitem);\n-            assert_eq!(&vitem_s[..], ex_s);\n-\n-            let ex_s = \"extern crate foo as bar;\";\n-            let vitem = string_to_item(ex_s.to_string()).unwrap();\n-            let vitem_s = item_to_string(&vitem);\n-            assert_eq!(&vitem_s[..], ex_s);\n-        })\n-    }\n-\n-    fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n-        let item = string_to_item(src.to_string()).unwrap();\n-\n-        struct PatIdentVisitor {\n-            spans: Vec<Span>\n-        }\n-        impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n-            fn visit_pat(&mut self, p: &'a ast::Pat) {\n-                match p.node {\n-                    PatKind::Ident(_ , ref spannedident, _) => {\n-                        self.spans.push(spannedident.span.clone());\n-                    }\n-                    _ => {\n-                        crate::visit::walk_pat(self, p);\n-                    }\n-                }\n-            }\n-        }\n-        let mut v = PatIdentVisitor { spans: Vec::new() };\n-        crate::visit::walk_item(&mut v, &item);\n-        return v.spans;\n-    }\n-\n-    #[test] fn span_of_self_arg_pat_idents_are_correct() {\n-        with_default_globals(|| {\n-\n-            let srcs = [\"impl z { fn a (&self, &myarg: i32) {} }\",\n-                        \"impl z { fn a (&mut self, &myarg: i32) {} }\",\n-                        \"impl z { fn a (&'a self, &myarg: i32) {} }\",\n-                        \"impl z { fn a (self, &myarg: i32) {} }\",\n-                        \"impl z { fn a (self: Foo, &myarg: i32) {} }\",\n-                        ];\n-\n-            for &src in &srcs {\n-                let spans = get_spans_of_pat_idents(src);\n-                let (lo, hi) = (spans[0].lo(), spans[0].hi());\n-                assert!(\"self\" == &src[lo.to_usize()..hi.to_usize()],\n-                        \"\\\"{}\\\" != \\\"self\\\". src=\\\"{}\\\"\",\n-                        &src[lo.to_usize()..hi.to_usize()], src)\n-            }\n-        })\n-    }\n-\n-    #[test] fn parse_exprs () {\n-        with_default_globals(|| {\n-            // just make sure that they parse....\n-            string_to_expr(\"3 + 4\".to_string());\n-            string_to_expr(\"a::z.froob(b,&(987+3))\".to_string());\n-        })\n-    }\n-\n-    #[test] fn attrs_fix_bug () {\n-        with_default_globals(|| {\n-            string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<Box<Writer>, String> {\n-    #[cfg(windows)]\n-    fn wb() -> c_int {\n-      (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n-    }\n-\n-    #[cfg(unix)]\n-    fn wb() -> c_int { O_WRONLY as c_int }\n-\n-    let mut fflags: c_int = wb();\n-}\".to_string());\n-        })\n-    }\n-\n-    #[test] fn crlf_doc_comments() {\n-        with_default_globals(|| {\n-            let sess = ParseSess::new(FilePathMapping::empty());\n-\n-            let name_1 = FileName::Custom(\"crlf_source_1\".to_string());\n-            let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n-            let item = parse_item_from_source_str(name_1, source, &sess)\n-                .unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n-            assert_eq!(doc.as_str(), \"/// doc comment\");\n-\n-            let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n-            let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n-            let item = parse_item_from_source_str(name_2, source, &sess)\n-                .unwrap().unwrap();\n-            let docs = item.attrs.iter().filter(|a| a.path == sym::doc)\n-                        .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n-            let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n-            assert_eq!(&docs[..], b);\n-\n-            let name_3 = FileName::Custom(\"clrf_source_3\".to_string());\n-            let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n-            let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n-            let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n-            assert_eq!(doc.as_str(), \"/** doc comment\\n *  with CRLF */\");\n-        });\n-    }\n-\n-    #[test]\n-    fn ttdelim_span() {\n-        fn parse_expr_from_source_str(\n-            name: FileName, source: String, sess: &ParseSess\n-        ) -> PResult<'_, P<ast::Expr>> {\n-            new_parser_from_source_str(sess, name, source).parse_expr()\n-        }\n-\n-        with_default_globals(|| {\n-            let sess = ParseSess::new(FilePathMapping::empty());\n-            let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n-                \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n-\n-            let tts: Vec<_> = match expr.node {\n-                ast::ExprKind::Mac(ref mac) => mac.node.stream().trees().collect(),\n-                _ => panic!(\"not a macro\"),\n-            };\n-\n-            let span = tts.iter().rev().next().unwrap().span();\n-\n-            match sess.source_map().span_to_snippet(span) {\n-                Ok(s) => assert_eq!(&s[..], \"{ body }\"),\n-                Err(_) => panic!(\"could not get snippet\"),\n-            }\n-        });\n-    }\n-\n-    // This tests that when parsing a string (rather than a file) we don't try\n-    // and read in a file for a module declaration and just parse a stub.\n-    // See `recurse_into_file_modules` in the parser.\n-    #[test]\n-    fn out_of_line_mod() {\n-        with_default_globals(|| {\n-            let sess = ParseSess::new(FilePathMapping::empty());\n-            let item = parse_item_from_source_str(\n-                PathBuf::from(\"foo\").into(),\n-                \"mod foo { struct S; mod this_does_not_exist; }\".to_owned(),\n-                &sess,\n-            ).unwrap().unwrap();\n-\n-            if let ast::ItemKind::Mod(ref m) = item.node {\n-                assert!(m.items.len() == 2);\n-            } else {\n-                panic!();\n-            }\n-        });\n-    }\n-}"}, {"sha": "e619fd17fb5bc2ed71cb4d9bf4b0baac439cec21", "filename": "src/libsyntax/parse/tests.rs", "status": "added", "additions": 339, "deletions": 0, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,339 @@\n+use super::*;\n+\n+use crate::ast::{self, Name, PatKind};\n+use crate::attr::first_attr_value_str_by_name;\n+use crate::parse::{ParseSess, PResult};\n+use crate::parse::new_parser_from_source_str;\n+use crate::parse::token::Token;\n+use crate::print::pprust::item_to_string;\n+use crate::ptr::P;\n+use crate::source_map::FilePathMapping;\n+use crate::symbol::{kw, sym};\n+use crate::tests::{matches_codepattern, string_to_stream, with_error_checking_parse};\n+use crate::tokenstream::{DelimSpan, TokenTree, TokenStream};\n+use crate::with_default_globals;\n+use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n+\n+use std::path::PathBuf;\n+\n+/// Parses an item.\n+///\n+/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n+/// when a syntax error occurred.\n+fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n+                                    -> PResult<'_, Option<P<ast::Item>>> {\n+    new_parser_from_source_str(sess, name, source).parse_item()\n+}\n+\n+// produce a syntax_pos::span\n+fn sp(a: u32, b: u32) -> Span {\n+    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+}\n+\n+/// Parse a string, return an expr\n+fn string_to_expr(source_str : String) -> P<ast::Expr> {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    with_error_checking_parse(source_str, &ps, |p| {\n+        p.parse_expr()\n+    })\n+}\n+\n+/// Parse a string, return an item\n+fn string_to_item(source_str : String) -> Option<P<ast::Item>> {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    with_error_checking_parse(source_str, &ps, |p| {\n+        p.parse_item()\n+    })\n+}\n+\n+#[should_panic]\n+#[test] fn bad_path_expr_1() {\n+    with_default_globals(|| {\n+        string_to_expr(\"::abc::def::return\".to_string());\n+    })\n+}\n+\n+// check the token-tree-ization of macros\n+#[test]\n+fn string_to_tts_macro () {\n+    with_default_globals(|| {\n+        let tts: Vec<_> =\n+            string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n+        let tts: &[TokenTree] = &tts[..];\n+\n+        match tts {\n+            [\n+                TokenTree::Token(Token { kind: token::Ident(name_macro_rules, false), .. }),\n+                TokenTree::Token(Token { kind: token::Not, .. }),\n+                TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. }),\n+                TokenTree::Delimited(_, macro_delim,  macro_tts)\n+            ]\n+            if name_macro_rules == &sym::macro_rules && name_zip.as_str() == \"zip\" => {\n+                let tts = &macro_tts.trees().collect::<Vec<_>>();\n+                match &tts[..] {\n+                    [\n+                        TokenTree::Delimited(_, first_delim, first_tts),\n+                        TokenTree::Token(Token { kind: token::FatArrow, .. }),\n+                        TokenTree::Delimited(_, second_delim, second_tts),\n+                    ]\n+                    if macro_delim == &token::Paren => {\n+                        let tts = &first_tts.trees().collect::<Vec<_>>();\n+                        match &tts[..] {\n+                            [\n+                                TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                            ]\n+                            if first_delim == &token::Paren && name.as_str() == \"a\" => {},\n+                            _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n+                        }\n+                        let tts = &second_tts.trees().collect::<Vec<_>>();\n+                        match &tts[..] {\n+                            [\n+                                TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                            ]\n+                            if second_delim == &token::Paren && name.as_str() == \"a\" => {},\n+                            _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n+                        }\n+                    },\n+                    _ => panic!(\"value 2: {:?} {:?}\", macro_delim, macro_tts),\n+                }\n+            },\n+            _ => panic!(\"value: {:?}\",tts),\n+        }\n+    })\n+}\n+\n+#[test]\n+fn string_to_tts_1() {\n+    with_default_globals(|| {\n+        let tts = string_to_stream(\"fn a (b : i32) { b; }\".to_string());\n+\n+        let expected = TokenStream::new(vec![\n+            TokenTree::token(token::Ident(kw::Fn, false), sp(0, 2)).into(),\n+            TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(3, 4)).into(),\n+            TokenTree::Delimited(\n+                DelimSpan::from_pair(sp(5, 6), sp(13, 14)),\n+                token::DelimToken::Paren,\n+                TokenStream::new(vec![\n+                    TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(6, 7)).into(),\n+                    TokenTree::token(token::Colon, sp(8, 9)).into(),\n+                    TokenTree::token(token::Ident(sym::i32, false), sp(10, 13)).into(),\n+                ]).into(),\n+            ).into(),\n+            TokenTree::Delimited(\n+                DelimSpan::from_pair(sp(15, 16), sp(20, 21)),\n+                token::DelimToken::Brace,\n+                TokenStream::new(vec![\n+                    TokenTree::token(token::Ident(Name::intern(\"b\"), false), sp(17, 18)).into(),\n+                    TokenTree::token(token::Semi, sp(18, 19)).into(),\n+                ]).into(),\n+            ).into()\n+        ]);\n+\n+        assert_eq!(tts, expected);\n+    })\n+}\n+\n+#[test] fn parse_use() {\n+    with_default_globals(|| {\n+        let use_s = \"use foo::bar::baz;\";\n+        let vitem = string_to_item(use_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&vitem);\n+        assert_eq!(&vitem_s[..], use_s);\n+\n+        let use_s = \"use foo::bar as baz;\";\n+        let vitem = string_to_item(use_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&vitem);\n+        assert_eq!(&vitem_s[..], use_s);\n+    })\n+}\n+\n+#[test] fn parse_extern_crate() {\n+    with_default_globals(|| {\n+        let ex_s = \"extern crate foo;\";\n+        let vitem = string_to_item(ex_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&vitem);\n+        assert_eq!(&vitem_s[..], ex_s);\n+\n+        let ex_s = \"extern crate foo as bar;\";\n+        let vitem = string_to_item(ex_s.to_string()).unwrap();\n+        let vitem_s = item_to_string(&vitem);\n+        assert_eq!(&vitem_s[..], ex_s);\n+    })\n+}\n+\n+fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n+    let item = string_to_item(src.to_string()).unwrap();\n+\n+    struct PatIdentVisitor {\n+        spans: Vec<Span>\n+    }\n+    impl<'a> crate::visit::Visitor<'a> for PatIdentVisitor {\n+        fn visit_pat(&mut self, p: &'a ast::Pat) {\n+            match p.node {\n+                PatKind::Ident(_ , ref spannedident, _) => {\n+                    self.spans.push(spannedident.span.clone());\n+                }\n+                _ => {\n+                    crate::visit::walk_pat(self, p);\n+                }\n+            }\n+        }\n+    }\n+    let mut v = PatIdentVisitor { spans: Vec::new() };\n+    crate::visit::walk_item(&mut v, &item);\n+    return v.spans;\n+}\n+\n+#[test] fn span_of_self_arg_pat_idents_are_correct() {\n+    with_default_globals(|| {\n+\n+        let srcs = [\"impl z { fn a (&self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (&mut self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (&'a self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (self: Foo, &myarg: i32) {} }\",\n+                    ];\n+\n+        for &src in &srcs {\n+            let spans = get_spans_of_pat_idents(src);\n+            let (lo, hi) = (spans[0].lo(), spans[0].hi());\n+            assert!(\"self\" == &src[lo.to_usize()..hi.to_usize()],\n+                    \"\\\"{}\\\" != \\\"self\\\". src=\\\"{}\\\"\",\n+                    &src[lo.to_usize()..hi.to_usize()], src)\n+        }\n+    })\n+}\n+\n+#[test] fn parse_exprs () {\n+    with_default_globals(|| {\n+        // just make sure that they parse....\n+        string_to_expr(\"3 + 4\".to_string());\n+        string_to_expr(\"a::z.froob(b,&(987+3))\".to_string());\n+    })\n+}\n+\n+#[test] fn attrs_fix_bug () {\n+    with_default_globals(|| {\n+        string_to_item(\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+                -> Result<Box<Writer>, String> {\n+#[cfg(windows)]\n+fn wb() -> c_int {\n+    (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n+}\n+\n+#[cfg(unix)]\n+fn wb() -> c_int { O_WRONLY as c_int }\n+\n+let mut fflags: c_int = wb();\n+}\".to_string());\n+    })\n+}\n+\n+#[test] fn crlf_doc_comments() {\n+    with_default_globals(|| {\n+        let sess = ParseSess::new(FilePathMapping::empty());\n+\n+        let name_1 = FileName::Custom(\"crlf_source_1\".to_string());\n+        let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name_1, source, &sess)\n+            .unwrap().unwrap();\n+        let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n+        assert_eq!(doc.as_str(), \"/// doc comment\");\n+\n+        let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n+        let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name_2, source, &sess)\n+            .unwrap().unwrap();\n+        let docs = item.attrs.iter().filter(|a| a.path == sym::doc)\n+                    .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n+        let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n+        assert_eq!(&docs[..], b);\n+\n+        let name_3 = FileName::Custom(\"clrf_source_3\".to_string());\n+        let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n+        let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n+        let doc = first_attr_value_str_by_name(&item.attrs, sym::doc).unwrap();\n+        assert_eq!(doc.as_str(), \"/** doc comment\\n *  with CRLF */\");\n+    });\n+}\n+\n+#[test]\n+fn ttdelim_span() {\n+    fn parse_expr_from_source_str(\n+        name: FileName, source: String, sess: &ParseSess\n+    ) -> PResult<'_, P<ast::Expr>> {\n+        new_parser_from_source_str(sess, name, source).parse_expr()\n+    }\n+\n+    with_default_globals(|| {\n+        let sess = ParseSess::new(FilePathMapping::empty());\n+        let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n+            \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n+\n+        let tts: Vec<_> = match expr.node {\n+            ast::ExprKind::Mac(ref mac) => mac.node.stream().trees().collect(),\n+            _ => panic!(\"not a macro\"),\n+        };\n+\n+        let span = tts.iter().rev().next().unwrap().span();\n+\n+        match sess.source_map().span_to_snippet(span) {\n+            Ok(s) => assert_eq!(&s[..], \"{ body }\"),\n+            Err(_) => panic!(\"could not get snippet\"),\n+        }\n+    });\n+}\n+\n+// This tests that when parsing a string (rather than a file) we don't try\n+// and read in a file for a module declaration and just parse a stub.\n+// See `recurse_into_file_modules` in the parser.\n+#[test]\n+fn out_of_line_mod() {\n+    with_default_globals(|| {\n+        let sess = ParseSess::new(FilePathMapping::empty());\n+        let item = parse_item_from_source_str(\n+            PathBuf::from(\"foo\").into(),\n+            \"mod foo { struct S; mod this_does_not_exist; }\".to_owned(),\n+            &sess,\n+        ).unwrap().unwrap();\n+\n+        if let ast::ItemKind::Mod(ref m) = item.node {\n+            assert!(m.items.len() == 2);\n+        } else {\n+            panic!();\n+        }\n+    });\n+}\n+\n+#[test]\n+fn eqmodws() {\n+    assert_eq!(matches_codepattern(\"\",\"\"),true);\n+    assert_eq!(matches_codepattern(\"\",\"a\"),false);\n+    assert_eq!(matches_codepattern(\"a\",\"\"),false);\n+    assert_eq!(matches_codepattern(\"a\",\"a\"),true);\n+    assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b\"),true);\n+    assert_eq!(matches_codepattern(\"a b \",\"a   \\n\\t\\r  b\"),true);\n+    assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b \"),false);\n+    assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n+    assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n+    assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n+    assert_eq!(matches_codepattern(\" a   b\",\"ab\"),true);\n+}\n+\n+#[test]\n+fn pattern_whitespace() {\n+    assert_eq!(matches_codepattern(\"\",\"\\x0C\"), false);\n+    assert_eq!(matches_codepattern(\"a b \",\"a   \\u{0085}\\n\\t\\r  b\"),true);\n+    assert_eq!(matches_codepattern(\"a b\",\"a   \\u{0085}\\n\\t\\r  b \"),false);\n+}\n+\n+#[test]\n+fn non_pattern_whitespace() {\n+    // These have the property 'White_Space' but not 'Pattern_White_Space'\n+    assert_eq!(matches_codepattern(\"a b\",\"a\\u{2002}b\"), false);\n+    assert_eq!(matches_codepattern(\"a   b\",\"a\\u{2002}b\"), false);\n+    assert_eq!(matches_codepattern(\"\\u{205F}a   b\",\"ab\"), false);\n+    assert_eq!(matches_codepattern(\"a  \\u{3000}b\",\"ab\"), false);\n+}"}, {"sha": "3645ab88d552f35c32c2748d9be9214131d73255", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -19,6 +19,9 @@ use syntax_pos::{DUMMY_SP, FileName, Span};\n \n use std::borrow::Cow;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub enum MacHeader<'a> {\n     Path(&'a ast::Path),\n     Keyword(&'static str),\n@@ -381,21 +384,6 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     to_string(|s| s.print_visibility(v))\n }\n \n-#[cfg(test)]\n-fn fun_to_string(decl: &ast::FnDecl,\n-                     header: ast::FnHeader,\n-                     name: ast::Ident,\n-                     generics: &ast::Generics)\n-                     -> String {\n-    to_string(|s| {\n-        s.head(\"\");\n-        s.print_fn(decl, header, Some(name),\n-                   generics, &source_map::dummy_spanned(ast::VisibilityKind::Inherited));\n-        s.end(); // Close the head box\n-        s.end(); // Close the outer box\n-    })\n-}\n-\n fn block_to_string(blk: &ast::Block) -> String {\n     to_string(|s| {\n         // containing cbox, will be closed by print-block at }\n@@ -418,11 +406,6 @@ pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     to_string(|s| s.print_attribute(attr))\n }\n \n-#[cfg(test)]\n-fn variant_to_string(var: &ast::Variant) -> String {\n-    to_string(|s| s.print_variant(var))\n-}\n-\n pub fn arg_to_string(arg: &ast::Arg) -> String {\n     to_string(|s| s.print_arg(arg, false))\n }\n@@ -2888,60 +2871,3 @@ impl<'a> State<'a> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::ast;\n-    use crate::source_map;\n-    use crate::with_default_globals;\n-    use syntax_pos;\n-\n-    #[test]\n-    fn test_fun_to_string() {\n-        with_default_globals(|| {\n-            let abba_ident = ast::Ident::from_str(\"abba\");\n-\n-            let decl = ast::FnDecl {\n-                inputs: Vec::new(),\n-                output: ast::FunctionRetTy::Default(syntax_pos::DUMMY_SP),\n-                c_variadic: false\n-            };\n-            let generics = ast::Generics::default();\n-            assert_eq!(\n-                fun_to_string(\n-                    &decl,\n-                    ast::FnHeader {\n-                        unsafety: ast::Unsafety::Normal,\n-                        constness: source_map::dummy_spanned(ast::Constness::NotConst),\n-                        asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),\n-                        abi: Abi::Rust,\n-                    },\n-                    abba_ident,\n-                    &generics\n-                ),\n-                \"fn abba()\"\n-            );\n-        })\n-    }\n-\n-    #[test]\n-    fn test_variant_to_string() {\n-        with_default_globals(|| {\n-            let ident = ast::Ident::from_str(\"principal_skinner\");\n-\n-            let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n-                ident,\n-                attrs: Vec::new(),\n-                id: ast::DUMMY_NODE_ID,\n-                // making this up as I go.... ?\n-                data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n-                disr_expr: None,\n-            });\n-\n-            let varstr = variant_to_string(&var);\n-            assert_eq!(varstr, \"principal_skinner\");\n-        })\n-    }\n-}"}, {"sha": "082a430e0ede1714345fc441b39362e8e19081ab", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,69 @@\n+use super::*;\n+\n+use crate::ast;\n+use crate::source_map;\n+use crate::with_default_globals;\n+use syntax_pos;\n+\n+fn fun_to_string(\n+    decl: &ast::FnDecl, header: ast::FnHeader, name: ast::Ident, generics: &ast::Generics\n+) -> String {\n+    to_string(|s| {\n+        s.head(\"\");\n+        s.print_fn(decl, header, Some(name),\n+                   generics, &source_map::dummy_spanned(ast::VisibilityKind::Inherited));\n+        s.end(); // Close the head box\n+        s.end(); // Close the outer box\n+    })\n+}\n+\n+fn variant_to_string(var: &ast::Variant) -> String {\n+    to_string(|s| s.print_variant(var))\n+}\n+\n+#[test]\n+fn test_fun_to_string() {\n+    with_default_globals(|| {\n+        let abba_ident = ast::Ident::from_str(\"abba\");\n+\n+        let decl = ast::FnDecl {\n+            inputs: Vec::new(),\n+            output: ast::FunctionRetTy::Default(syntax_pos::DUMMY_SP),\n+            c_variadic: false\n+        };\n+        let generics = ast::Generics::default();\n+        assert_eq!(\n+            fun_to_string(\n+                &decl,\n+                ast::FnHeader {\n+                    unsafety: ast::Unsafety::Normal,\n+                    constness: source_map::dummy_spanned(ast::Constness::NotConst),\n+                    asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),\n+                    abi: Abi::Rust,\n+                },\n+                abba_ident,\n+                &generics\n+            ),\n+            \"fn abba()\"\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_variant_to_string() {\n+    with_default_globals(|| {\n+        let ident = ast::Ident::from_str(\"principal_skinner\");\n+\n+        let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n+            ident,\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            // making this up as I go.... ?\n+            data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n+            disr_expr: None,\n+        });\n+\n+        let varstr = variant_to_string(&var);\n+        assert_eq!(varstr, \"principal_skinner\");\n+    })\n+}"}, {"sha": "f83c1dbf7eed0842bb8ffd3b802490a8c0ae4905", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 3, "deletions": 220, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -24,6 +24,9 @@ use log::debug;\n \n use errors::SourceMapper;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Returns the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n@@ -1020,223 +1023,3 @@ impl FilePathMapping {\n         (path, false)\n     }\n }\n-\n-// _____________________________________________________________________________\n-// Tests\n-//\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use rustc_data_structures::sync::Lrc;\n-\n-    fn init_source_map() -> SourceMap {\n-        let sm = SourceMap::new(FilePathMapping::empty());\n-        sm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n-                       \"first line.\\nsecond line\".to_string());\n-        sm.new_source_file(PathBuf::from(\"empty.rs\").into(),\n-                       String::new());\n-        sm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n-                       \"first line.\\nsecond line\".to_string());\n-        sm\n-    }\n-\n-    #[test]\n-    fn t3() {\n-        // Test lookup_byte_offset\n-        let sm = init_source_map();\n-\n-        let srcfbp1 = sm.lookup_byte_offset(BytePos(23));\n-        assert_eq!(srcfbp1.sf.name, PathBuf::from(\"blork.rs\").into());\n-        assert_eq!(srcfbp1.pos, BytePos(23));\n-\n-        let srcfbp1 = sm.lookup_byte_offset(BytePos(24));\n-        assert_eq!(srcfbp1.sf.name, PathBuf::from(\"empty.rs\").into());\n-        assert_eq!(srcfbp1.pos, BytePos(0));\n-\n-        let srcfbp2 = sm.lookup_byte_offset(BytePos(25));\n-        assert_eq!(srcfbp2.sf.name, PathBuf::from(\"blork2.rs\").into());\n-        assert_eq!(srcfbp2.pos, BytePos(0));\n-    }\n-\n-    #[test]\n-    fn t4() {\n-        // Test bytepos_to_file_charpos\n-        let sm = init_source_map();\n-\n-        let cp1 = sm.bytepos_to_file_charpos(BytePos(22));\n-        assert_eq!(cp1, CharPos(22));\n-\n-        let cp2 = sm.bytepos_to_file_charpos(BytePos(25));\n-        assert_eq!(cp2, CharPos(0));\n-    }\n-\n-    #[test]\n-    fn t5() {\n-        // Test zero-length source_files.\n-        let sm = init_source_map();\n-\n-        let loc1 = sm.lookup_char_pos(BytePos(22));\n-        assert_eq!(loc1.file.name, PathBuf::from(\"blork.rs\").into());\n-        assert_eq!(loc1.line, 2);\n-        assert_eq!(loc1.col, CharPos(10));\n-\n-        let loc2 = sm.lookup_char_pos(BytePos(25));\n-        assert_eq!(loc2.file.name, PathBuf::from(\"blork2.rs\").into());\n-        assert_eq!(loc2.line, 1);\n-        assert_eq!(loc2.col, CharPos(0));\n-    }\n-\n-    fn init_source_map_mbc() -> SourceMap {\n-        let sm = SourceMap::new(FilePathMapping::empty());\n-        // \u20ac is a three byte utf8 char.\n-        sm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n-                       \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n-        sm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n-                       \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n-        sm\n-    }\n-\n-    #[test]\n-    fn t6() {\n-        // Test bytepos_to_file_charpos in the presence of multi-byte chars\n-        let sm = init_source_map_mbc();\n-\n-        let cp1 = sm.bytepos_to_file_charpos(BytePos(3));\n-        assert_eq!(cp1, CharPos(3));\n-\n-        let cp2 = sm.bytepos_to_file_charpos(BytePos(6));\n-        assert_eq!(cp2, CharPos(4));\n-\n-        let cp3 = sm.bytepos_to_file_charpos(BytePos(56));\n-        assert_eq!(cp3, CharPos(12));\n-\n-        let cp4 = sm.bytepos_to_file_charpos(BytePos(61));\n-        assert_eq!(cp4, CharPos(15));\n-    }\n-\n-    #[test]\n-    fn t7() {\n-        // Test span_to_lines for a span ending at the end of source_file\n-        let sm = init_source_map();\n-        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n-        let file_lines = sm.span_to_lines(span).unwrap();\n-\n-        assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n-        assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0].line_index, 1);\n-    }\n-\n-    /// Given a string like \" ~~~~~~~~~~~~ \", produces a span\n-    /// converting that range. The idea is that the string has the same\n-    /// length as the input, and we uncover the byte positions. Note\n-    /// that this can span lines and so on.\n-    fn span_from_selection(input: &str, selection: &str) -> Span {\n-        assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('~').unwrap() as u32;\n-        let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-        Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n-    }\n-\n-    /// Tests span_to_snippet and span_to_lines for a span converting 3\n-    /// lines in the middle of a file.\n-    #[test]\n-    fn span_to_snippet_and_lines_spanning_multiple_lines() {\n-        let sm = SourceMap::new(FilePathMapping::empty());\n-        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        sm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n-        let span = span_from_selection(inputtext, selection);\n-\n-        // check that we are extracting the text we thought we were extracting\n-        assert_eq!(&sm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n-\n-        // check that span_to_lines gives us the complete result with the lines/cols we expected\n-        let lines = sm.span_to_lines(span).unwrap();\n-        let expected = vec![\n-            LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n-            LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },\n-            LineInfo { line_index: 3, start_col: CharPos(0), end_col: CharPos(5) }\n-            ];\n-        assert_eq!(lines.lines, expected);\n-    }\n-\n-    #[test]\n-    fn t8() {\n-        // Test span_to_snippet for a span ending at the end of source_file\n-        let sm = init_source_map();\n-        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n-        let snippet = sm.span_to_snippet(span);\n-\n-        assert_eq!(snippet, Ok(\"second line\".to_string()));\n-    }\n-\n-    #[test]\n-    fn t9() {\n-        // Test span_to_str for a span ending at the end of source_file\n-        let sm = init_source_map();\n-        let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n-        let sstr =  sm.span_to_string(span);\n-\n-        assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n-    }\n-\n-    /// Tests failing to merge two spans on different lines\n-    #[test]\n-    fn span_merging_fail() {\n-        let sm = SourceMap::new(FilePathMapping::empty());\n-        let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n-        let selection1 = \"     ~~\\n      \\n\";\n-        let selection2 = \"       \\n   ~~~\\n\";\n-        sm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_owned());\n-        let span1 = span_from_selection(inputtext, selection1);\n-        let span2 = span_from_selection(inputtext, selection2);\n-\n-        assert!(sm.merge_spans(span1, span2).is_none());\n-    }\n-\n-    /// Returns the span corresponding to the `n`th occurrence of\n-    /// `substring` in `source_text`.\n-    trait SourceMapExtension {\n-        fn span_substr(&self,\n-                    file: &Lrc<SourceFile>,\n-                    source_text: &str,\n-                    substring: &str,\n-                    n: usize)\n-                    -> Span;\n-    }\n-\n-    impl SourceMapExtension for SourceMap {\n-        fn span_substr(&self,\n-                    file: &Lrc<SourceFile>,\n-                    source_text: &str,\n-                    substring: &str,\n-                    n: usize)\n-                    -> Span\n-        {\n-            println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n-                    file.name, file.start_pos, substring, n);\n-            let mut i = 0;\n-            let mut hi = 0;\n-            loop {\n-                let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n-                    panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n-                        source_text, n, substring, i);\n-                });\n-                let lo = hi + offset;\n-                hi = lo + substring.len();\n-                if i == n {\n-                    let span = Span::new(\n-                        BytePos(lo as u32 + file.start_pos.0),\n-                        BytePos(hi as u32 + file.start_pos.0),\n-                        NO_EXPANSION,\n-                    );\n-                    assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n-                            substring);\n-                    return span;\n-                }\n-                i += 1;\n-            }\n-        }\n-    }\n-}"}, {"sha": "427e86b56e12b39827e2916cdfd21aa253d0b1d5", "filename": "src/libsyntax/source_map/tests.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,213 @@\n+use super::*;\n+\n+use rustc_data_structures::sync::Lrc;\n+\n+fn init_source_map() -> SourceMap {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    sm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n+                    \"first line.\\nsecond line\".to_string());\n+    sm.new_source_file(PathBuf::from(\"empty.rs\").into(),\n+                    String::new());\n+    sm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n+                    \"first line.\\nsecond line\".to_string());\n+    sm\n+}\n+\n+#[test]\n+fn t3() {\n+    // Test lookup_byte_offset\n+    let sm = init_source_map();\n+\n+    let srcfbp1 = sm.lookup_byte_offset(BytePos(23));\n+    assert_eq!(srcfbp1.sf.name, PathBuf::from(\"blork.rs\").into());\n+    assert_eq!(srcfbp1.pos, BytePos(23));\n+\n+    let srcfbp1 = sm.lookup_byte_offset(BytePos(24));\n+    assert_eq!(srcfbp1.sf.name, PathBuf::from(\"empty.rs\").into());\n+    assert_eq!(srcfbp1.pos, BytePos(0));\n+\n+    let srcfbp2 = sm.lookup_byte_offset(BytePos(25));\n+    assert_eq!(srcfbp2.sf.name, PathBuf::from(\"blork2.rs\").into());\n+    assert_eq!(srcfbp2.pos, BytePos(0));\n+}\n+\n+#[test]\n+fn t4() {\n+    // Test bytepos_to_file_charpos\n+    let sm = init_source_map();\n+\n+    let cp1 = sm.bytepos_to_file_charpos(BytePos(22));\n+    assert_eq!(cp1, CharPos(22));\n+\n+    let cp2 = sm.bytepos_to_file_charpos(BytePos(25));\n+    assert_eq!(cp2, CharPos(0));\n+}\n+\n+#[test]\n+fn t5() {\n+    // Test zero-length source_files.\n+    let sm = init_source_map();\n+\n+    let loc1 = sm.lookup_char_pos(BytePos(22));\n+    assert_eq!(loc1.file.name, PathBuf::from(\"blork.rs\").into());\n+    assert_eq!(loc1.line, 2);\n+    assert_eq!(loc1.col, CharPos(10));\n+\n+    let loc2 = sm.lookup_char_pos(BytePos(25));\n+    assert_eq!(loc2.file.name, PathBuf::from(\"blork2.rs\").into());\n+    assert_eq!(loc2.line, 1);\n+    assert_eq!(loc2.col, CharPos(0));\n+}\n+\n+fn init_source_map_mbc() -> SourceMap {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    // \u20ac is a three byte utf8 char.\n+    sm.new_source_file(PathBuf::from(\"blork.rs\").into(),\n+                    \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n+    sm.new_source_file(PathBuf::from(\"blork2.rs\").into(),\n+                    \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n+    sm\n+}\n+\n+#[test]\n+fn t6() {\n+    // Test bytepos_to_file_charpos in the presence of multi-byte chars\n+    let sm = init_source_map_mbc();\n+\n+    let cp1 = sm.bytepos_to_file_charpos(BytePos(3));\n+    assert_eq!(cp1, CharPos(3));\n+\n+    let cp2 = sm.bytepos_to_file_charpos(BytePos(6));\n+    assert_eq!(cp2, CharPos(4));\n+\n+    let cp3 = sm.bytepos_to_file_charpos(BytePos(56));\n+    assert_eq!(cp3, CharPos(12));\n+\n+    let cp4 = sm.bytepos_to_file_charpos(BytePos(61));\n+    assert_eq!(cp4, CharPos(15));\n+}\n+\n+#[test]\n+fn t7() {\n+    // Test span_to_lines for a span ending at the end of source_file\n+    let sm = init_source_map();\n+    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let file_lines = sm.span_to_lines(span).unwrap();\n+\n+    assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n+    assert_eq!(file_lines.lines.len(), 1);\n+    assert_eq!(file_lines.lines[0].line_index, 1);\n+}\n+\n+/// Given a string like \" ~~~~~~~~~~~~ \", produces a span\n+/// converting that range. The idea is that the string has the same\n+/// length as the input, and we uncover the byte positions. Note\n+/// that this can span lines and so on.\n+fn span_from_selection(input: &str, selection: &str) -> Span {\n+    assert_eq!(input.len(), selection.len());\n+    let left_index = selection.find('~').unwrap() as u32;\n+    let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n+    Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n+}\n+\n+/// Tests span_to_snippet and span_to_lines for a span converting 3\n+/// lines in the middle of a file.\n+#[test]\n+fn span_to_snippet_and_lines_spanning_multiple_lines() {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+    let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+    sm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_string());\n+    let span = span_from_selection(inputtext, selection);\n+\n+    // check that we are extracting the text we thought we were extracting\n+    assert_eq!(&sm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+    // check that span_to_lines gives us the complete result with the lines/cols we expected\n+    let lines = sm.span_to_lines(span).unwrap();\n+    let expected = vec![\n+        LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n+        LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },\n+        LineInfo { line_index: 3, start_col: CharPos(0), end_col: CharPos(5) }\n+        ];\n+    assert_eq!(lines.lines, expected);\n+}\n+\n+#[test]\n+fn t8() {\n+    // Test span_to_snippet for a span ending at the end of source_file\n+    let sm = init_source_map();\n+    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let snippet = sm.span_to_snippet(span);\n+\n+    assert_eq!(snippet, Ok(\"second line\".to_string()));\n+}\n+\n+#[test]\n+fn t9() {\n+    // Test span_to_str for a span ending at the end of source_file\n+    let sm = init_source_map();\n+    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let sstr =  sm.span_to_string(span);\n+\n+    assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n+}\n+\n+/// Tests failing to merge two spans on different lines\n+#[test]\n+fn span_merging_fail() {\n+    let sm = SourceMap::new(FilePathMapping::empty());\n+    let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n+    let selection1 = \"     ~~\\n      \\n\";\n+    let selection2 = \"       \\n   ~~~\\n\";\n+    sm.new_source_file(Path::new(\"blork.rs\").to_owned().into(), inputtext.to_owned());\n+    let span1 = span_from_selection(inputtext, selection1);\n+    let span2 = span_from_selection(inputtext, selection2);\n+\n+    assert!(sm.merge_spans(span1, span2).is_none());\n+}\n+\n+/// Returns the span corresponding to the `n`th occurrence of\n+/// `substring` in `source_text`.\n+trait SourceMapExtension {\n+    fn span_substr(&self,\n+                file: &Lrc<SourceFile>,\n+                source_text: &str,\n+                substring: &str,\n+                n: usize)\n+                -> Span;\n+}\n+\n+impl SourceMapExtension for SourceMap {\n+    fn span_substr(&self,\n+                file: &Lrc<SourceFile>,\n+                source_text: &str,\n+                substring: &str,\n+                n: usize)\n+                -> Span\n+    {\n+        println!(\"span_substr(file={:?}/{:?}, substring={:?}, n={})\",\n+                file.name, file.start_pos, substring, n);\n+        let mut i = 0;\n+        let mut hi = 0;\n+        loop {\n+            let offset = source_text[hi..].find(substring).unwrap_or_else(|| {\n+                panic!(\"source_text `{}` does not have {} occurrences of `{}`, only {}\",\n+                    source_text, n, substring, i);\n+            });\n+            let lo = hi + offset;\n+            hi = lo + substring.len();\n+            if i == n {\n+                let span = Span::new(\n+                    BytePos(lo as u32 + file.start_pos.0),\n+                    BytePos(hi as u32 + file.start_pos.0),\n+                    NO_EXPANSION,\n+                );\n+                assert_eq!(&self.span_to_snippet(span).unwrap()[..],\n+                        substring);\n+                return span;\n+            }\n+            i += 1;\n+        }\n+    }\n+}"}, {"sha": "cff034fdeb1e3892847d2b19982db4d5cabf2bf7", "filename": "src/libsyntax/tests.rs", "status": "renamed", "additions": 94, "deletions": 4, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,16 +1,106 @@\n+use crate::{ast, panictry};\n+use crate::parse::{ParseSess, PResult, source_file_to_stream};\n+use crate::parse::new_parser_from_source_str;\n+use crate::parse::parser::Parser;\n use crate::source_map::{SourceMap, FilePathMapping};\n+use crate::tokenstream::TokenStream;\n use crate::with_default_globals;\n \n-use errors::Handler;\n use errors::emitter::EmitterWriter;\n+use errors::Handler;\n+use rustc_data_structures::sync::Lrc;\n+use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n \n use std::io;\n use std::io::prelude::*;\n-use rustc_data_structures::sync::Lrc;\n+use std::iter::Peekable;\n+use std::path::{Path, PathBuf};\n use std::str;\n use std::sync::{Arc, Mutex};\n-use std::path::Path;\n-use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n+\n+/// Map string to parser (via tts)\n+fn string_to_parser(ps: &ParseSess, source_str: String) -> Parser<'_> {\n+    new_parser_from_source_str(ps, PathBuf::from(\"bogofile\").into(), source_str)\n+}\n+\n+crate fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where\n+    F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n+{\n+    let mut p = string_to_parser(&ps, s);\n+    let x = panictry!(f(&mut p));\n+    p.sess.span_diagnostic.abort_if_errors();\n+    x\n+}\n+\n+/// Map a string to tts, using a made-up filename:\n+crate fn string_to_stream(source_str: String) -> TokenStream {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    source_file_to_stream(\n+        &ps,\n+        ps.source_map().new_source_file(PathBuf::from(\"bogofile\").into(),\n+        source_str,\n+    ), None).0\n+}\n+\n+/// Parse a string, return a crate.\n+crate fn string_to_crate(source_str : String) -> ast::Crate {\n+    let ps = ParseSess::new(FilePathMapping::empty());\n+    with_error_checking_parse(source_str, &ps, |p| {\n+        p.parse_crate_mod()\n+    })\n+}\n+\n+/// Does the given string match the pattern? whitespace in the first string\n+/// may be deleted or replaced with other whitespace to match the pattern.\n+/// This function is relatively Unicode-ignorant; fortunately, the careful design\n+/// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n+crate fn matches_codepattern(a : &str, b : &str) -> bool {\n+    let mut a_iter = a.chars().peekable();\n+    let mut b_iter = b.chars().peekable();\n+\n+    loop {\n+        let (a, b) = match (a_iter.peek(), b_iter.peek()) {\n+            (None, None) => return true,\n+            (None, _) => return false,\n+            (Some(&a), None) => {\n+                if is_pattern_whitespace(a) {\n+                    break // trailing whitespace check is out of loop for borrowck\n+                } else {\n+                    return false\n+                }\n+            }\n+            (Some(&a), Some(&b)) => (a, b)\n+        };\n+\n+        if is_pattern_whitespace(a) && is_pattern_whitespace(b) {\n+            // skip whitespace for a and b\n+            scan_for_non_ws_or_end(&mut a_iter);\n+            scan_for_non_ws_or_end(&mut b_iter);\n+        } else if is_pattern_whitespace(a) {\n+            // skip whitespace for a\n+            scan_for_non_ws_or_end(&mut a_iter);\n+        } else if a == b {\n+            a_iter.next();\n+            b_iter.next();\n+        } else {\n+            return false\n+        }\n+    }\n+\n+    // check if a has *only* trailing whitespace\n+    a_iter.all(is_pattern_whitespace)\n+}\n+\n+/// Advances the given peekable `Iterator` until it reaches a non-whitespace character\n+fn scan_for_non_ws_or_end<I: Iterator<Item = char>>(iter: &mut Peekable<I>) {\n+    while iter.peek().copied().map(|c| is_pattern_whitespace(c)) == Some(true) {\n+        iter.next();\n+    }\n+}\n+\n+fn is_pattern_whitespace(c: char) -> bool {\n+    rustc_lexer::character_properties::is_whitespace(c)\n+}\n \n /// Identify a position in the text by the Nth occurrence of a string.\n struct Position {", "previous_filename": "src/libsyntax/test_snippet.rs"}, {"sha": "6ff8898fe21629e62e8f85052f9e80b5946b3a8d", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -29,6 +29,9 @@ use smallvec::{SmallVec, smallvec};\n use std::borrow::Cow;\n use std::{fmt, iter, mem};\n \n+#[cfg(test)]\n+mod tests;\n+\n /// When the main rust parser encounters a syntax-extension invocation, it\n /// parses the arguments to the invocation as a token-tree. This is a very\n /// loose structure, such that all sorts of different AST-fragments can\n@@ -552,114 +555,3 @@ impl DelimSpan {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::ast::Name;\n-    use crate::with_default_globals;\n-    use crate::util::parser_testing::string_to_stream;\n-    use syntax_pos::{Span, BytePos, NO_EXPANSION};\n-\n-    fn string_to_ts(string: &str) -> TokenStream {\n-        string_to_stream(string.to_owned())\n-    }\n-\n-    fn sp(a: u32, b: u32) -> Span {\n-        Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n-    }\n-\n-    #[test]\n-    fn test_concat() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"foo::bar::baz\");\n-            let test_fst = string_to_ts(\"foo::bar\");\n-            let test_snd = string_to_ts(\"::baz\");\n-            let eq_res = TokenStream::from_streams(smallvec![test_fst, test_snd]);\n-            assert_eq!(test_res.trees().count(), 5);\n-            assert_eq!(eq_res.trees().count(), 5);\n-            assert_eq!(test_res.eq_unspanned(&eq_res), true);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_to_from_bijection() {\n-        with_default_globals(|| {\n-            let test_start = string_to_ts(\"foo::bar(baz)\");\n-            let test_end = test_start.trees().collect();\n-            assert_eq!(test_start, test_end)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_eq_0() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"foo\");\n-            let test_eqs = string_to_ts(\"foo\");\n-            assert_eq!(test_res, test_eqs)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_eq_1() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"::bar::baz\");\n-            let test_eqs = string_to_ts(\"::bar::baz\");\n-            assert_eq!(test_res, test_eqs)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_eq_3() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"\");\n-            let test_eqs = string_to_ts(\"\");\n-            assert_eq!(test_res, test_eqs)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_diseq_0() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"::bar::baz\");\n-            let test_eqs = string_to_ts(\"bar::baz\");\n-            assert_eq!(test_res == test_eqs, false)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_diseq_1() {\n-        with_default_globals(|| {\n-            let test_res = string_to_ts(\"(bar,baz)\");\n-            let test_eqs = string_to_ts(\"bar,baz\");\n-            assert_eq!(test_res == test_eqs, false)\n-        })\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        with_default_globals(|| {\n-            let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n-            let test1: TokenStream =\n-                TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(0, 1)).into();\n-            let test2 = string_to_ts(\"foo(bar::baz)\");\n-\n-            assert_eq!(test0.is_empty(), true);\n-            assert_eq!(test1.is_empty(), false);\n-            assert_eq!(test2.is_empty(), false);\n-        })\n-    }\n-\n-    #[test]\n-    fn test_dotdotdot() {\n-        with_default_globals(|| {\n-            let mut builder = TokenStreamBuilder::new();\n-            builder.push(TokenTree::token(token::Dot, sp(0, 1)).joint());\n-            builder.push(TokenTree::token(token::Dot, sp(1, 2)).joint());\n-            builder.push(TokenTree::token(token::Dot, sp(2, 3)));\n-            let stream = builder.build();\n-            assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n-            assert_eq!(stream.trees().count(), 1);\n-        })\n-    }\n-}"}, {"sha": "72e22a49876e8f85924567b6687cc0ff0e2ba093", "filename": "src/libsyntax/tokenstream/tests.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,108 @@\n+use super::*;\n+\n+use crate::ast::Name;\n+use crate::with_default_globals;\n+use crate::tests::string_to_stream;\n+use syntax_pos::{Span, BytePos, NO_EXPANSION};\n+\n+fn string_to_ts(string: &str) -> TokenStream {\n+    string_to_stream(string.to_owned())\n+}\n+\n+fn sp(a: u32, b: u32) -> Span {\n+    Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n+}\n+\n+#[test]\n+fn test_concat() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"foo::bar::baz\");\n+        let test_fst = string_to_ts(\"foo::bar\");\n+        let test_snd = string_to_ts(\"::baz\");\n+        let eq_res = TokenStream::from_streams(smallvec![test_fst, test_snd]);\n+        assert_eq!(test_res.trees().count(), 5);\n+        assert_eq!(eq_res.trees().count(), 5);\n+        assert_eq!(test_res.eq_unspanned(&eq_res), true);\n+    })\n+}\n+\n+#[test]\n+fn test_to_from_bijection() {\n+    with_default_globals(|| {\n+        let test_start = string_to_ts(\"foo::bar(baz)\");\n+        let test_end = test_start.trees().collect();\n+        assert_eq!(test_start, test_end)\n+    })\n+}\n+\n+#[test]\n+fn test_eq_0() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"foo\");\n+        let test_eqs = string_to_ts(\"foo\");\n+        assert_eq!(test_res, test_eqs)\n+    })\n+}\n+\n+#[test]\n+fn test_eq_1() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"::bar::baz\");\n+        let test_eqs = string_to_ts(\"::bar::baz\");\n+        assert_eq!(test_res, test_eqs)\n+    })\n+}\n+\n+#[test]\n+fn test_eq_3() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"\");\n+        let test_eqs = string_to_ts(\"\");\n+        assert_eq!(test_res, test_eqs)\n+    })\n+}\n+\n+#[test]\n+fn test_diseq_0() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"::bar::baz\");\n+        let test_eqs = string_to_ts(\"bar::baz\");\n+        assert_eq!(test_res == test_eqs, false)\n+    })\n+}\n+\n+#[test]\n+fn test_diseq_1() {\n+    with_default_globals(|| {\n+        let test_res = string_to_ts(\"(bar,baz)\");\n+        let test_eqs = string_to_ts(\"bar,baz\");\n+        assert_eq!(test_res == test_eqs, false)\n+    })\n+}\n+\n+#[test]\n+fn test_is_empty() {\n+    with_default_globals(|| {\n+        let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n+        let test1: TokenStream =\n+            TokenTree::token(token::Ident(Name::intern(\"a\"), false), sp(0, 1)).into();\n+        let test2 = string_to_ts(\"foo(bar::baz)\");\n+\n+        assert_eq!(test0.is_empty(), true);\n+        assert_eq!(test1.is_empty(), false);\n+        assert_eq!(test2.is_empty(), false);\n+    })\n+}\n+\n+#[test]\n+fn test_dotdotdot() {\n+    with_default_globals(|| {\n+        let mut builder = TokenStreamBuilder::new();\n+        builder.push(TokenTree::token(token::Dot, sp(0, 1)).joint());\n+        builder.push(TokenTree::token(token::Dot, sp(1, 2)).joint());\n+        builder.push(TokenTree::token(token::Dot, sp(2, 3)));\n+        let stream = builder.build();\n+        assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n+        assert_eq!(stream.trees().count(), 1);\n+    })\n+}"}, {"sha": "4127a8c7fce2502650e8d52868b0b8320632fab8", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,6 +1,9 @@\n use std::cmp;\n use crate::symbol::Symbol;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Finds the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n     // cases which don't require further computation\n@@ -77,60 +80,3 @@ pub fn find_best_match_for_name<'a, T>(iter_names: T,\n         if let Some((candidate, _)) = levenstein_match { Some(candidate) } else { None }\n     }\n }\n-\n-#[test]\n-fn test_lev_distance() {\n-    use std::char::{from_u32, MAX};\n-    // Test bytelength agnosticity\n-    for c in (0..MAX as u32)\n-             .filter_map(|i| from_u32(i))\n-             .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n-    }\n-\n-    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b), 1);\n-    assert_eq!(lev_distance(b, a), 1);\n-    assert_eq!(lev_distance(a, c), 2);\n-    assert_eq!(lev_distance(c, a), 2);\n-    assert_eq!(lev_distance(b, c), 1);\n-    assert_eq!(lev_distance(c, b), 1);\n-}\n-\n-#[test]\n-fn test_find_best_match_for_name() {\n-    use crate::with_default_globals;\n-    with_default_globals(|| {\n-        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), \"aaaa\", None),\n-            Some(Symbol::intern(\"aaab\"))\n-        );\n-\n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), \"1111111111\", None),\n-            None\n-        );\n-\n-        let input = vec![Symbol::intern(\"aAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), \"AAAA\", None),\n-            Some(Symbol::intern(\"aAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        // Returns None because `lev_distance > max_dist / 3`\n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), \"aaaa\", None),\n-            None\n-        );\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(input.iter(), \"aaaa\", Some(4)),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-    })\n-}"}, {"sha": "1a746a67ec0521414cb306710bcf143b4eea98fd", "filename": "src/libsyntax/util/lev_distance/tests.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,58 @@\n+use super::*;\n+\n+#[test]\n+fn test_lev_distance() {\n+    use std::char::{from_u32, MAX};\n+    // Test bytelength agnosticity\n+    for c in (0..MAX as u32)\n+             .filter_map(|i| from_u32(i))\n+             .map(|i| i.to_string()) {\n+        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(lev_distance(a, b), 1);\n+    assert_eq!(lev_distance(b, a), 1);\n+    assert_eq!(lev_distance(a, c), 2);\n+    assert_eq!(lev_distance(c, a), 2);\n+    assert_eq!(lev_distance(b, c), 1);\n+    assert_eq!(lev_distance(c, b), 1);\n+}\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use crate::with_default_globals;\n+    with_default_globals(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"1111111111\", None),\n+            None\n+        );\n+\n+        let input = vec![Symbol::intern(\"aAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"AAAA\", None),\n+            Some(Symbol::intern(\"aAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        // Returns None because `lev_distance > max_dist / 3`\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", None),\n+            None\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"aaaa\", Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+    })\n+}"}, {"sha": "627422df1db1c9cc8c9edc4818638f9770a1df87", "filename": "src/libsyntax/util/parser_testing.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df512fcaeaf17639c5d28a3045814d6f7a7db97/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=1df512fcaeaf17639c5d28a3045814d6f7a7db97", "patch": "@@ -1,160 +0,0 @@\n-use crate::ast::{self, Ident};\n-use crate::source_map::FilePathMapping;\n-use crate::parse::{ParseSess, PResult, source_file_to_stream};\n-use crate::parse::new_parser_from_source_str;\n-use crate::parse::parser::Parser;\n-use crate::ptr::P;\n-use crate::tokenstream::TokenStream;\n-\n-use std::iter::Peekable;\n-use std::path::PathBuf;\n-\n-/// Map a string to tts, using a made-up filename:\n-pub fn string_to_stream(source_str: String) -> TokenStream {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    source_file_to_stream(\n-        &ps,\n-        ps.source_map().new_source_file(PathBuf::from(\"bogofile\").into(),\n-        source_str,\n-    ), None).0\n-}\n-\n-/// Map string to parser (via tts)\n-pub fn string_to_parser(ps: &ParseSess, source_str: String) -> Parser<'_> {\n-    new_parser_from_source_str(ps, PathBuf::from(\"bogofile\").into(), source_str)\n-}\n-\n-fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where\n-    F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n-{\n-    let mut p = string_to_parser(&ps, s);\n-    let x = panictry!(f(&mut p));\n-    p.sess.span_diagnostic.abort_if_errors();\n-    x\n-}\n-\n-/// Parse a string, return a crate.\n-pub fn string_to_crate(source_str : String) -> ast::Crate {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    with_error_checking_parse(source_str, &ps, |p| {\n-        p.parse_crate_mod()\n-    })\n-}\n-\n-/// Parse a string, return an expr\n-pub fn string_to_expr(source_str : String) -> P<ast::Expr> {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    with_error_checking_parse(source_str, &ps, |p| {\n-        p.parse_expr()\n-    })\n-}\n-\n-/// Parse a string, return an item\n-pub fn string_to_item(source_str : String) -> Option<P<ast::Item>> {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    with_error_checking_parse(source_str, &ps, |p| {\n-        p.parse_item()\n-    })\n-}\n-\n-/// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n-/// (currently) affect parsing.\n-pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    let ps = ParseSess::new(FilePathMapping::empty());\n-    with_error_checking_parse(source_str, &ps, |p| {\n-        p.parse_pat(None)\n-    })\n-}\n-\n-/// Converts a vector of strings to a vector of Ident's\n-pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<Ident> {\n-    ids.iter().map(|u| Ident::from_str(*u)).collect()\n-}\n-\n-/// Does the given string match the pattern? whitespace in the first string\n-/// may be deleted or replaced with other whitespace to match the pattern.\n-/// This function is relatively Unicode-ignorant; fortunately, the careful design\n-/// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n-pub fn matches_codepattern(a : &str, b : &str) -> bool {\n-    let mut a_iter = a.chars().peekable();\n-    let mut b_iter = b.chars().peekable();\n-\n-    loop {\n-        let (a, b) = match (a_iter.peek(), b_iter.peek()) {\n-            (None, None) => return true,\n-            (None, _) => return false,\n-            (Some(&a), None) => {\n-                if is_pattern_whitespace(a) {\n-                    break // trailing whitespace check is out of loop for borrowck\n-                } else {\n-                    return false\n-                }\n-            }\n-            (Some(&a), Some(&b)) => (a, b)\n-        };\n-\n-        if is_pattern_whitespace(a) && is_pattern_whitespace(b) {\n-            // skip whitespace for a and b\n-            scan_for_non_ws_or_end(&mut a_iter);\n-            scan_for_non_ws_or_end(&mut b_iter);\n-        } else if is_pattern_whitespace(a) {\n-            // skip whitespace for a\n-            scan_for_non_ws_or_end(&mut a_iter);\n-        } else if a == b {\n-            a_iter.next();\n-            b_iter.next();\n-        } else {\n-            return false\n-        }\n-    }\n-\n-    // check if a has *only* trailing whitespace\n-    a_iter.all(is_pattern_whitespace)\n-}\n-\n-/// Advances the given peekable `Iterator` until it reaches a non-whitespace character\n-fn scan_for_non_ws_or_end<I: Iterator<Item = char>>(iter: &mut Peekable<I>) {\n-    while iter.peek().copied().map(|c| is_pattern_whitespace(c)) == Some(true) {\n-        iter.next();\n-    }\n-}\n-\n-pub fn is_pattern_whitespace(c: char) -> bool {\n-    rustc_lexer::character_properties::is_whitespace(c)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn eqmodws() {\n-        assert_eq!(matches_codepattern(\"\",\"\"),true);\n-        assert_eq!(matches_codepattern(\"\",\"a\"),false);\n-        assert_eq!(matches_codepattern(\"a\",\"\"),false);\n-        assert_eq!(matches_codepattern(\"a\",\"a\"),true);\n-        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b\"),true);\n-        assert_eq!(matches_codepattern(\"a b \",\"a   \\n\\t\\r  b\"),true);\n-        assert_eq!(matches_codepattern(\"a b\",\"a   \\n\\t\\r  b \"),false);\n-        assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n-        assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n-        assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n-        assert_eq!(matches_codepattern(\" a   b\",\"ab\"),true);\n-    }\n-\n-    #[test]\n-    fn pattern_whitespace() {\n-        assert_eq!(matches_codepattern(\"\",\"\\x0C\"), false);\n-        assert_eq!(matches_codepattern(\"a b \",\"a   \\u{0085}\\n\\t\\r  b\"),true);\n-        assert_eq!(matches_codepattern(\"a b\",\"a   \\u{0085}\\n\\t\\r  b \"),false);\n-    }\n-\n-    #[test]\n-    fn non_pattern_whitespace() {\n-        // These have the property 'White_Space' but not 'Pattern_White_Space'\n-        assert_eq!(matches_codepattern(\"a b\",\"a\\u{2002}b\"), false);\n-        assert_eq!(matches_codepattern(\"a   b\",\"a\\u{2002}b\"), false);\n-        assert_eq!(matches_codepattern(\"\\u{205F}a   b\",\"ab\"), false);\n-        assert_eq!(matches_codepattern(\"a  \\u{3000}b\",\"ab\"), false);\n-    }\n-}"}, {"sha": "e01a14f14a8488776904ce0d2100dc5d7881213c", "filename": "src/libsyntax_pos/analyze_source_file.rs", "status": "modified", "additions": 3, "deletions": 152, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fanalyze_source_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fanalyze_source_file.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,6 +1,9 @@\n use unicode_width::UnicodeWidthChar;\n use super::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Finds all newlines, multi-byte characters, and non-narrow characters in a\n /// SourceFile.\n ///\n@@ -271,155 +274,3 @@ fn analyze_source_file_generic(src: &str,\n \n     i - scan_len\n }\n-\n-\n-\n-macro_rules! test {\n-    (case: $test_name:ident,\n-     text: $text:expr,\n-     source_file_start_pos: $source_file_start_pos:expr,\n-     lines: $lines:expr,\n-     multi_byte_chars: $multi_byte_chars:expr,\n-     non_narrow_chars: $non_narrow_chars:expr,) => (\n-\n-    #[test]\n-    fn $test_name() {\n-\n-        let (lines, multi_byte_chars, non_narrow_chars) =\n-            analyze_source_file($text, BytePos($source_file_start_pos));\n-\n-        let expected_lines: Vec<BytePos> = $lines\n-            .into_iter()\n-            .map(|pos| BytePos(pos))\n-            .collect();\n-\n-        assert_eq!(lines, expected_lines);\n-\n-        let expected_mbcs: Vec<MultiByteChar> = $multi_byte_chars\n-            .into_iter()\n-            .map(|(pos, bytes)| MultiByteChar {\n-                pos: BytePos(pos),\n-                bytes,\n-            })\n-            .collect();\n-\n-        assert_eq!(multi_byte_chars, expected_mbcs);\n-\n-        let expected_nncs: Vec<NonNarrowChar> = $non_narrow_chars\n-            .into_iter()\n-            .map(|(pos, width)| {\n-                NonNarrowChar::new(BytePos(pos), width)\n-            })\n-            .collect();\n-\n-        assert_eq!(non_narrow_chars, expected_nncs);\n-    })\n-}\n-\n-test!(\n-    case: empty_text,\n-    text: \"\",\n-    source_file_start_pos: 0,\n-    lines: vec![],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: newlines_short,\n-    text: \"a\\nc\",\n-    source_file_start_pos: 0,\n-    lines: vec![0, 2],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: newlines_long,\n-    text: \"012345678\\nabcdef012345678\\na\",\n-    source_file_start_pos: 0,\n-    lines: vec![0, 10, 26],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: newline_and_multi_byte_char_in_same_chunk,\n-    text: \"01234\u03b2789\\nbcdef0123456789abcdef\",\n-    source_file_start_pos: 0,\n-    lines: vec![0, 11],\n-    multi_byte_chars: vec![(5, 2)],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: newline_and_control_char_in_same_chunk,\n-    text: \"01234\\u{07}6789\\nbcdef0123456789abcdef\",\n-    source_file_start_pos: 0,\n-    lines: vec![0, 11],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![(5, 0)],\n-);\n-\n-test!(\n-    case: multi_byte_char_short,\n-    text: \"a\u03b2c\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![(1, 2)],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: multi_byte_char_long,\n-    text: \"0123456789abc\u0394f012345\u03b2\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![(13, 2), (22, 2)],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: multi_byte_char_across_chunk_boundary,\n-    text: \"0123456789abcde\u0394123456789abcdef01234\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![(15, 2)],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: multi_byte_char_across_chunk_boundary_tail,\n-    text: \"0123456789abcde\u0394....\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![(15, 2)],\n-    non_narrow_chars: vec![],\n-);\n-\n-test!(\n-    case: non_narrow_short,\n-    text: \"0\\t2\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![(1, 4)],\n-);\n-\n-test!(\n-    case: non_narrow_long,\n-    text: \"01\\t3456789abcdef01234567\\u{07}9\",\n-    source_file_start_pos: 0,\n-    lines: vec![0],\n-    multi_byte_chars: vec![],\n-    non_narrow_chars: vec![(2, 4), (24, 0)],\n-);\n-\n-test!(\n-    case: output_offset_all,\n-    text: \"01\\t345\\n789abc\u0394f01234567\\u{07}9\\nbc\u0394f\",\n-    source_file_start_pos: 1000,\n-    lines: vec![0 + 1000, 7 + 1000, 27 + 1000],\n-    multi_byte_chars: vec![(13 + 1000, 2), (29 + 1000, 2)],\n-    non_narrow_chars: vec![(2 + 1000, 4), (24 + 1000, 0)],\n-);"}, {"sha": "fd485a7f3a92f5f2fe9f61a039746ed727ef89e7", "filename": "src/libsyntax_pos/analyze_source_file/tests.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fanalyze_source_file%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fanalyze_source_file%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fanalyze_source_file%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,151 @@\n+use super::*;\n+\n+macro_rules! test {\n+    (case: $test_name:ident,\n+     text: $text:expr,\n+     source_file_start_pos: $source_file_start_pos:expr,\n+     lines: $lines:expr,\n+     multi_byte_chars: $multi_byte_chars:expr,\n+     non_narrow_chars: $non_narrow_chars:expr,) => (\n+\n+    #[test]\n+    fn $test_name() {\n+\n+        let (lines, multi_byte_chars, non_narrow_chars) =\n+            analyze_source_file($text, BytePos($source_file_start_pos));\n+\n+        let expected_lines: Vec<BytePos> = $lines\n+            .into_iter()\n+            .map(|pos| BytePos(pos))\n+            .collect();\n+\n+        assert_eq!(lines, expected_lines);\n+\n+        let expected_mbcs: Vec<MultiByteChar> = $multi_byte_chars\n+            .into_iter()\n+            .map(|(pos, bytes)| MultiByteChar {\n+                pos: BytePos(pos),\n+                bytes,\n+            })\n+            .collect();\n+\n+        assert_eq!(multi_byte_chars, expected_mbcs);\n+\n+        let expected_nncs: Vec<NonNarrowChar> = $non_narrow_chars\n+            .into_iter()\n+            .map(|(pos, width)| {\n+                NonNarrowChar::new(BytePos(pos), width)\n+            })\n+            .collect();\n+\n+        assert_eq!(non_narrow_chars, expected_nncs);\n+    })\n+}\n+\n+test!(\n+    case: empty_text,\n+    text: \"\",\n+    source_file_start_pos: 0,\n+    lines: vec![],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newlines_short,\n+    text: \"a\\nc\",\n+    source_file_start_pos: 0,\n+    lines: vec![0, 2],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newlines_long,\n+    text: \"012345678\\nabcdef012345678\\na\",\n+    source_file_start_pos: 0,\n+    lines: vec![0, 10, 26],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newline_and_multi_byte_char_in_same_chunk,\n+    text: \"01234\u03b2789\\nbcdef0123456789abcdef\",\n+    source_file_start_pos: 0,\n+    lines: vec![0, 11],\n+    multi_byte_chars: vec![(5, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: newline_and_control_char_in_same_chunk,\n+    text: \"01234\\u{07}6789\\nbcdef0123456789abcdef\",\n+    source_file_start_pos: 0,\n+    lines: vec![0, 11],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(5, 0)],\n+);\n+\n+test!(\n+    case: multi_byte_char_short,\n+    text: \"a\u03b2c\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(1, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_long,\n+    text: \"0123456789abc\u0394f012345\u03b2\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(13, 2), (22, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_across_chunk_boundary,\n+    text: \"0123456789abcde\u0394123456789abcdef01234\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(15, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: multi_byte_char_across_chunk_boundary_tail,\n+    text: \"0123456789abcde\u0394....\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![(15, 2)],\n+    non_narrow_chars: vec![],\n+);\n+\n+test!(\n+    case: non_narrow_short,\n+    text: \"0\\t2\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(1, 4)],\n+);\n+\n+test!(\n+    case: non_narrow_long,\n+    text: \"01\\t3456789abcdef01234567\\u{07}9\",\n+    source_file_start_pos: 0,\n+    lines: vec![0],\n+    multi_byte_chars: vec![],\n+    non_narrow_chars: vec![(2, 4), (24, 0)],\n+);\n+\n+test!(\n+    case: output_offset_all,\n+    text: \"01\\t345\\n789abc\u0394f01234567\\u{07}9\\nbc\u0394f\",\n+    source_file_start_pos: 1000,\n+    lines: vec![0 + 1000, 7 + 1000, 27 + 1000],\n+    multi_byte_chars: vec![(13 + 1000, 2), (29 + 1000, 2)],\n+    non_narrow_chars: vec![(2 + 1000, 4), (24 + 1000, 0)],\n+);"}, {"sha": "fa6e3609138e6b7513b3199849837c04ab43b0cb", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -42,6 +42,9 @@ use std::hash::{Hasher, Hash};\n use std::ops::{Add, Sub};\n use std::path::PathBuf;\n \n+#[cfg(test)]\n+mod tests;\n+\n pub struct Globals {\n     symbol_interner: Lock<symbol::Interner>,\n     span_interner: Lock<span_encoding::SpanInterner>,\n@@ -1420,25 +1423,3 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n         Err(line) => line as isize - 1\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{lookup_line, BytePos};\n-\n-    #[test]\n-    fn test_lookup_line() {\n-\n-        let lines = &[BytePos(3), BytePos(17), BytePos(28)];\n-\n-        assert_eq!(lookup_line(lines, BytePos(0)), -1);\n-        assert_eq!(lookup_line(lines, BytePos(3)),  0);\n-        assert_eq!(lookup_line(lines, BytePos(4)),  0);\n-\n-        assert_eq!(lookup_line(lines, BytePos(16)), 0);\n-        assert_eq!(lookup_line(lines, BytePos(17)), 1);\n-        assert_eq!(lookup_line(lines, BytePos(18)), 1);\n-\n-        assert_eq!(lookup_line(lines, BytePos(28)), 2);\n-        assert_eq!(lookup_line(lines, BytePos(29)), 2);\n-    }\n-}"}, {"sha": "476368e835177e1dad24590893291bdbb81f9800", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -17,6 +17,9 @@ use std::str;\n use crate::hygiene::SyntaxContext;\n use crate::{Span, DUMMY_SP, GLOBALS};\n \n+#[cfg(test)]\n+mod tests;\n+\n symbols! {\n     // After modifying this list adjust `is_special`, `is_used_keyword`/`is_unused_keyword`,\n     // this should be rarely necessary though if the keywords are kept in alphabetic order.\n@@ -1345,39 +1348,3 @@ impl Encodable for InternedString {\n         self.with(|string| s.emit_str(string))\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::Globals;\n-    use crate::edition;\n-\n-    #[test]\n-    fn interner_tests() {\n-        let mut i: Interner = Interner::default();\n-        // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n-        assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-        let z = i.intern(\"zebra\");\n-        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n-        // gensym of same string gets new number:\n-        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n-        // gensym of *existing* string gets new number:\n-        let d = i.intern(\"dog\");\n-        assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n-    }\n-\n-    #[test]\n-    fn without_first_quote_test() {\n-        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n-            let i = Ident::from_str(\"'break\");\n-            assert_eq!(i.without_first_quote().name, kw::Break);\n-        });\n-    }\n-}"}, {"sha": "1b91c9bb845a4a660e081dd977fe5730057b7ed0", "filename": "src/libsyntax_pos/symbol/tests.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,32 @@\n+use super::*;\n+\n+use crate::{edition, Globals};\n+\n+#[test]\n+fn interner_tests() {\n+    let mut i: Interner = Interner::default();\n+    // first one is zero:\n+    assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n+    // re-use gets the same entry:\n+    assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n+    // different string gets a different #:\n+    assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n+    assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n+    // dog is still at zero\n+    assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n+    let z = i.intern(\"zebra\");\n+    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n+    // gensym of same string gets new number:\n+    assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n+    // gensym of *existing* string gets new number:\n+    let d = i.intern(\"dog\");\n+    assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n+}\n+\n+#[test]\n+fn without_first_quote_test() {\n+    GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n+        let i = Ident::from_str(\"'break\");\n+        assert_eq!(i.without_first_quote().name, kw::Break);\n+    });\n+}"}, {"sha": "78c4e18e6aee01f6f16332b8b0eb1bf5cf2e19be", "filename": "src/libsyntax_pos/tests.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,18 @@\n+use super::*;\n+\n+#[test]\n+fn test_lookup_line() {\n+\n+    let lines = &[BytePos(3), BytePos(17), BytePos(28)];\n+\n+    assert_eq!(lookup_line(lines, BytePos(0)), -1);\n+    assert_eq!(lookup_line(lines, BytePos(3)),  0);\n+    assert_eq!(lookup_line(lines, BytePos(4)),  0);\n+\n+    assert_eq!(lookup_line(lines, BytePos(16)), 0);\n+    assert_eq!(lookup_line(lines, BytePos(17)), 1);\n+    assert_eq!(lookup_line(lines, BytePos(18)), 1);\n+\n+    assert_eq!(lookup_line(lines, BytePos(28)), 2);\n+    assert_eq!(lookup_line(lines, BytePos(29)), 2);\n+}"}, {"sha": "c7466daa2baa6f671b1d3caa7b9e93fd70ff2b46", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 141, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -5,6 +5,9 @@ use self::States::*;\n \n use std::iter::repeat;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Clone, Copy, PartialEq)]\n enum States {\n     Nothing,\n@@ -526,144 +529,3 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     }\n     Ok(s)\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{expand, Variables};\n-    use super::Param::{self, Words, Number};\n-    use std::result::Result::Ok;\n-\n-    #[test]\n-    fn test_basic_setabf() {\n-        let s = b\"\\\\E[48;5;%p1%dm\";\n-        assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n-                   \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_multiple_int_constants() {\n-        assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n-                   \"21\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_op_i() {\n-        let mut vars = Variables::new();\n-        assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n-                          &[Number(1), Number(2), Number(3)],\n-                          &mut vars),\n-                   Ok(\"123233\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n-                   Ok(\"0011\".bytes().collect::<Vec<_>>()));\n-    }\n-\n-    #[test]\n-    fn test_param_stack_failure_conditions() {\n-        let mut varstruct = Variables::new();\n-        let vars = &mut varstruct;\n-        fn get_res(fmt: &str,\n-                   cap: &str,\n-                   params: &[Param],\n-                   vars: &mut Variables)\n-                   -> Result<Vec<u8>, String> {\n-            let mut u8v: Vec<_> = fmt.bytes().collect();\n-            u8v.extend(cap.as_bytes().iter().map(|&b| b));\n-            expand(&u8v, params, vars)\n-        }\n-\n-        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n-        for &cap in caps.iter() {\n-            let res = get_res(\"\", cap, &[], vars);\n-            assert!(res.is_err(),\n-                    \"Op {} succeeded incorrectly with 0 stack entries\",\n-                    cap);\n-            let p = if cap == \"%s\" || cap == \"%l\" {\n-                Words(\"foo\".to_string())\n-            } else {\n-                Number(97)\n-            };\n-            let res = get_res(\"%p1\", cap, &[p], vars);\n-            assert!(res.is_ok(),\n-                    \"Op {} failed with 1 stack entry: {}\",\n-                    cap,\n-                    res.unwrap_err());\n-        }\n-        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n-        for &cap in caps.iter() {\n-            let res = expand(cap.as_bytes(), &[], vars);\n-            assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 0 stack entries\",\n-                    cap);\n-            let res = get_res(\"%{1}\", cap, &[], vars);\n-            assert!(res.is_err(),\n-                    \"Binop {} succeeded incorrectly with 1 stack entry\",\n-                    cap);\n-            let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n-            assert!(res.is_ok(),\n-                    \"Binop {} failed with 2 stack entries: {}\",\n-                    cap,\n-                    res.unwrap_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_push_bad_param() {\n-        assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n-    }\n-\n-    #[test]\n-    fn test_comparison_ops() {\n-        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n-        for &(op, bs) in v.iter() {\n-            let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n-            let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n-            let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n-            assert!(res.is_ok(), res.unwrap_err());\n-            assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_conditionals() {\n-        let mut vars = Variables::new();\n-        let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n-        let res = expand(s, &[Number(1)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n-        let res = expand(s, &[Number(8)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n-        let res = expand(s, &[Number(42)], &mut vars);\n-        assert!(res.is_ok(), res.unwrap_err());\n-        assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n-    }\n-\n-    #[test]\n-    fn test_format() {\n-        let mut varstruct = Variables::new();\n-        let vars = &mut varstruct;\n-        assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-                          &[Words(\"foo\".to_string()),\n-                            Words(\"foo\".to_string()),\n-                            Words(\"f\".to_string()),\n-                            Words(\"foo\".to_string())],\n-                          vars),\n-                   Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n-                   Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n-\n-        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n-                   Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n-        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n-                          &[Number(15), Number(27)],\n-                          vars),\n-                   Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n-    }\n-}"}, {"sha": "4d38715424e8a202bb9c76e52ad60ef74c7761c5", "filename": "src/libterm/terminfo/parm/tests.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,137 @@\n+use super::*;\n+\n+use std::result::Result::Ok;\n+\n+#[test]\n+fn test_basic_setabf() {\n+    let s = b\"\\\\E[48;5;%p1%dm\";\n+    assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n+                \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_multiple_int_constants() {\n+    assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n+                \"21\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_op_i() {\n+    let mut vars = Variables::new();\n+    assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n+                        &[Number(1), Number(2), Number(3)],\n+                        &mut vars),\n+                Ok(\"123233\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n+                Ok(\"0011\".bytes().collect::<Vec<_>>()));\n+}\n+\n+#[test]\n+fn test_param_stack_failure_conditions() {\n+    let mut varstruct = Variables::new();\n+    let vars = &mut varstruct;\n+    fn get_res(fmt: &str,\n+                cap: &str,\n+                params: &[Param],\n+                vars: &mut Variables)\n+                -> Result<Vec<u8>, String> {\n+        let mut u8v: Vec<_> = fmt.bytes().collect();\n+        u8v.extend(cap.as_bytes().iter().map(|&b| b));\n+        expand(&u8v, params, vars)\n+    }\n+\n+    let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+    for &cap in caps.iter() {\n+        let res = get_res(\"\", cap, &[], vars);\n+        assert!(res.is_err(),\n+                \"Op {} succeeded incorrectly with 0 stack entries\",\n+                cap);\n+        let p = if cap == \"%s\" || cap == \"%l\" {\n+            Words(\"foo\".to_string())\n+        } else {\n+            Number(97)\n+        };\n+        let res = get_res(\"%p1\", cap, &[p], vars);\n+        assert!(res.is_ok(),\n+                \"Op {} failed with 1 stack entry: {}\",\n+                cap,\n+                res.unwrap_err());\n+    }\n+    let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+    for &cap in caps.iter() {\n+        let res = expand(cap.as_bytes(), &[], vars);\n+        assert!(res.is_err(),\n+                \"Binop {} succeeded incorrectly with 0 stack entries\",\n+                cap);\n+        let res = get_res(\"%{1}\", cap, &[], vars);\n+        assert!(res.is_err(),\n+                \"Binop {} succeeded incorrectly with 1 stack entry\",\n+                cap);\n+        let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n+        assert!(res.is_ok(),\n+                \"Binop {} failed with 2 stack entries: {}\",\n+                cap,\n+                res.unwrap_err());\n+    }\n+}\n+\n+#[test]\n+fn test_push_bad_param() {\n+    assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n+}\n+\n+#[test]\n+fn test_comparison_ops() {\n+    let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+    for &(op, bs) in v.iter() {\n+        let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n+        let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n+        let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n+        let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n+    }\n+}\n+\n+#[test]\n+fn test_conditionals() {\n+    let mut vars = Variables::new();\n+    let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n+    let res = expand(s, &[Number(1)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n+    let res = expand(s, &[Number(8)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n+    let res = expand(s, &[Number(42)], &mut vars);\n+    assert!(res.is_ok(), res.unwrap_err());\n+    assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n+}\n+\n+#[test]\n+fn test_format() {\n+    let mut varstruct = Variables::new();\n+    let vars = &mut varstruct;\n+    assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n+                        &[Words(\"foo\".to_string()),\n+                        Words(\"foo\".to_string()),\n+                        Words(\"f\".to_string()),\n+                        Words(\"foo\".to_string())],\n+                        vars),\n+                Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n+                Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n+\n+    assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n+                Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n+    assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n+                        &[Number(15), Number(27)],\n+                        vars),\n+                Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n+}"}, {"sha": "a8653a22f2538c2ecc8f0e6798a2535c5325a713", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -7,6 +7,9 @@ use std::io;\n use std::io::prelude::*;\n use super::super::TermInfo;\n \n+#[cfg(test)]\n+mod tests;\n+\n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n \n #[rustfmt::skip]\n@@ -331,16 +334,3 @@ pub fn msys_terminfo() -> TermInfo {\n         strings,\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{boolnames, boolfnames, numnames, numfnames, stringnames, stringfnames};\n-\n-    #[test]\n-    fn test_veclens() {\n-        assert_eq!(boolfnames.len(), boolnames.len());\n-        assert_eq!(numfnames.len(), numnames.len());\n-        assert_eq!(stringfnames.len(), stringnames.len());\n-    }\n-}"}, {"sha": "8a9187b0495cc9a6e314cc01fd3b3cee21b9aed6", "filename": "src/libterm/terminfo/parser/compiled/tests.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,8 @@\n+use super::*;\n+\n+#[test]\n+fn test_veclens() {\n+    assert_eq!(boolfnames.len(), boolnames.len());\n+    assert_eq!(numfnames.len(), numnames.len());\n+    assert_eq!(stringfnames.len(), stringnames.len());\n+}"}, {"sha": "5499e240e66e54268b5acbe00a3ceae2ad1a500c", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -6,6 +6,9 @@ use std::env;\n use std::fs;\n use std::path::PathBuf;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Return path to database entry for `term`\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n@@ -64,21 +67,3 @@ pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n     }\n     None\n }\n-\n-#[test]\n-#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\n-fn test_get_dbpath_for_term() {\n-    // woefully inadequate test coverage\n-    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n-    use std::env;\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    fn x(t: &str) -> String {\n-        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.to_str().unwrap().to_string()\n-    }\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n-    assert!(get_dbpath_for_term(\"\") == None);\n-    env::set_var(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n-    env::remove_var(\"TERMINFO_DIRS\");\n-}"}, {"sha": "4227a585e2f59e22e7f1dd129110f3115539f90d", "filename": "src/libterm/terminfo/searcher/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,19 @@\n+use super::*;\n+\n+#[test]\n+#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\n+fn test_get_dbpath_for_term() {\n+    // woefully inadequate test coverage\n+    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n+    use std::env;\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    fn x(t: &str) -> String {\n+        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n+        p.to_str().unwrap().to_string()\n+    }\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    assert!(get_dbpath_for_term(\"\") == None);\n+    env::set_var(\"TERMINFO_DIRS\", \":\");\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    env::remove_var(\"TERMINFO_DIRS\");\n+}"}, {"sha": "ef66c4df99da7a7ceb859723972af870e525c9f0", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 15, "deletions": 81, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -70,6 +70,9 @@ use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Duration, Instant};\n \n+#[cfg(test)]\n+mod tests;\n+\n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n \n@@ -377,28 +380,6 @@ pub struct TestOpts {\n     pub options: Options,\n }\n \n-impl TestOpts {\n-    #[cfg(test)]\n-    fn new() -> TestOpts {\n-        TestOpts {\n-            list: false,\n-            filter: None,\n-            filter_exact: false,\n-            exclude_should_panic: false,\n-            run_ignored: RunIgnored::No,\n-            run_tests: false,\n-            bench_benchmarks: false,\n-            logfile: None,\n-            nocapture: false,\n-            color: AutoColor,\n-            format: OutputFormat::Pretty,\n-            test_threads: None,\n-            skip: vec![],\n-            options: Options::new(),\n-        }\n-    }\n-}\n-\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, String>;\n \n@@ -495,18 +476,18 @@ environment variable to a value other than \"0\". Logging is not captured by defau\n \n Test Attributes:\n \n-    #[test]        - Indicates a function is a test to be run. This function\n-                     takes no arguments.\n-    #[bench]       - Indicates a function is a benchmark to be run. This\n-                     function takes one argument (test::Bencher).\n-    #[should_panic] - This function (also labeled with #[test]) will only pass if\n-                     the code causes a panic (an assertion failure or panic!)\n-                     A message may be provided, which the failure string must\n-                     contain: #[should_panic(expected = \"foo\")].\n-    #[ignore]      - When applied to a function which is already attributed as a\n-                     test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored or --include-ignored will run\n-                     these tests.\"#,\n+    `#[test]`        - Indicates a function is a test to be run. This function\n+                       takes no arguments.\n+    `#[bench]`       - Indicates a function is a benchmark to be run. This\n+                       function takes one argument (test::Bencher).\n+    `#[should_panic]` - This function (also labeled with `#[test]`) will only pass if\n+                        the code causes a panic (an assertion failure or panic!)\n+                        A message may be provided, which the failure string must\n+                        contain: #[should_panic(expected = \"foo\")].\n+    `#[ignore]`       - When applied to a function which is already attributed as a\n+                        test, then the test runner will ignore these tests during\n+                        normal test runs. Running with --ignored or --include-ignored will run\n+                        these tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -974,50 +955,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n     return out.write_run_finish(&st);\n }\n \n-#[test]\n-fn should_sort_failures_before_printing_them() {\n-    let test_a = TestDesc {\n-        name: StaticTestName(\"a\"),\n-        ignore: false,\n-        should_panic: ShouldPanic::No,\n-        allow_fail: false,\n-    };\n-\n-    let test_b = TestDesc {\n-        name: StaticTestName(\"b\"),\n-        ignore: false,\n-        should_panic: ShouldPanic::No,\n-        allow_fail: false,\n-    };\n-\n-    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n-\n-    let st = ConsoleTestState {\n-        log_out: None,\n-        total: 0,\n-        passed: 0,\n-        failed: 0,\n-        ignored: 0,\n-        allowed_fail: 0,\n-        filtered_out: 0,\n-        measured: 0,\n-        metrics: MetricMap::new(),\n-        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n-        options: Options::new(),\n-        not_failures: Vec::new(),\n-    };\n-\n-    out.write_failures(&st).unwrap();\n-    let s = match out.output_location() {\n-        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        &Pretty(_) => unreachable!(),\n-    };\n-\n-    let apos = s.find(\"a\").unwrap();\n-    let bpos = s.find(\"b\").unwrap();\n-    assert!(apos < bpos);\n-}\n-\n fn use_color(opts: &TestOpts) -> bool {\n     match opts.color {\n         AutoColor => !opts.nocapture && stdout_isatty(),\n@@ -1775,6 +1712,3 @@ pub mod bench {\n         bs.bench(f);\n     }\n }\n-\n-#[cfg(test)]\n-mod tests;"}, {"sha": "6577ec8ad2391923dd918e45a294cedfa1346735", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -4,6 +4,9 @@\n use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;\n \n+#[cfg(test)]\n+mod tests;\n+\n fn local_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n     if y.is_nan() {\n@@ -314,34 +317,3 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n         }\n     }\n }\n-\n-// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n-\n-#[cfg(test)]\n-mod tests;\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use crate::stats::Stats;\n-\n-    #[bench]\n-    pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| {\n-            [1e20f64, 1.5f64, -1e20f64].sum();\n-        })\n-    }\n-    #[bench]\n-    pub fn sum_many_f64(b: &mut Bencher) {\n-        let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n-\n-        b.iter(|| {\n-            v.sum();\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn no_iter(_: &mut Bencher) {}\n-}"}, {"sha": "7d1d635186fba1b3f3a25d3ac41eb5709e1c1347", "filename": "src/libtest/stats/tests.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,8 +1,12 @@\n-use crate::stats::Stats;\n-use crate::stats::Summary;\n+use super::*;\n+\n+extern crate test;\n use std::f64;\n use std::io::prelude::*;\n use std::io;\n+use self::test::Bencher;\n+\n+// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n \n macro_rules! assert_approx_eq {\n     ($a: expr, $b: expr) => {{\n@@ -572,3 +576,22 @@ fn test_sum_f64s() {\n fn test_sum_f64_between_ints_that_sum_to_0() {\n     assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n }\n+\n+#[bench]\n+pub fn sum_three_items(b: &mut Bencher) {\n+    b.iter(|| {\n+        [1e20f64, 1.5f64, -1e20f64].sum();\n+    })\n+}\n+#[bench]\n+pub fn sum_many_f64(b: &mut Bencher) {\n+    let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n+    let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n+\n+    b.iter(|| {\n+        v.sum();\n+    })\n+}\n+\n+#[bench]\n+pub fn no_iter(_: &mut Bencher) {}"}, {"sha": "f574743e4b6698c5f16fdbdd1c4ee8054dd5c89e", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,13 +1,33 @@\n-use crate::bench;\n+use super::*;\n+\n use crate::test::{\n     filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n     ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n     TrIgnored, TrOk,\n };\n-use crate::Bencher;\n-use crate::Concurrent;\n use std::sync::mpsc::channel;\n \n+impl TestOpts {\n+    fn new() -> TestOpts {\n+        TestOpts {\n+            list: false,\n+            filter: None,\n+            filter_exact: false,\n+            exclude_should_panic: false,\n+            run_ignored: RunIgnored::No,\n+            run_tests: false,\n+            bench_benchmarks: false,\n+            logfile: None,\n+            nocapture: false,\n+            color: AutoColor,\n+            format: OutputFormat::Pretty,\n+            test_threads: None,\n+            skip: vec![],\n+            options: Options::new(),\n+        }\n+    }\n+}\n+\n fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n     vec![\n         TestDescAndFn {\n@@ -451,3 +471,47 @@ pub fn test_bench_iter() {\n     crate::bench::benchmark(desc, tx, true, f);\n     rx.recv().unwrap();\n }\n+\n+#[test]\n+fn should_sort_failures_before_printing_them() {\n+    let test_a = TestDesc {\n+        name: StaticTestName(\"a\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    let test_b = TestDesc {\n+        name: StaticTestName(\"b\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n+\n+    let st = ConsoleTestState {\n+        log_out: None,\n+        total: 0,\n+        passed: 0,\n+        failed: 0,\n+        ignored: 0,\n+        allowed_fail: 0,\n+        filtered_out: 0,\n+        measured: 0,\n+        metrics: MetricMap::new(),\n+        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n+        options: Options::new(),\n+        not_failures: Vec::new(),\n+    };\n+\n+    out.write_failures(&st).unwrap();\n+    let s = match out.output_location() {\n+        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &Pretty(_) => unreachable!(),\n+    };\n+\n+    let apos = s.find(\"a\").unwrap();\n+    let bpos = s.find(\"b\").unwrap();\n+    assert!(apos < bpos);\n+}"}, {"sha": "076ad87c70fc4e6c72cb74e6d32008320adc5276", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -8,9 +8,11 @@ use log::*;\n \n use crate::common::{self, CompareMode, Config, Mode, PassMode};\n use crate::util;\n-\n use crate::extract_gdb_version;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Whether to ignore the test.\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Ignore {\n@@ -969,29 +971,3 @@ fn parse_normalization_string(line: &mut &str) -> Option<String> {\n     *line = &line[end + 1..];\n     Some(result)\n }\n-\n-#[test]\n-fn test_parse_normalization_string() {\n-    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits)\\\" -> \\\"something ($WORD bits)\\\".\";\n-    let first = parse_normalization_string(&mut s);\n-    assert_eq!(first, Some(\"something (32 bits)\".to_owned()));\n-    assert_eq!(s, \" -> \\\"something ($WORD bits)\\\".\");\n-\n-    // Nothing to normalize (No quotes)\n-    let mut s = \"normalize-stderr-32bit: something (32 bits) -> something ($WORD bits).\";\n-    let first = parse_normalization_string(&mut s);\n-    assert_eq!(first, None);\n-    assert_eq!(s, r#\"normalize-stderr-32bit: something (32 bits) -> something ($WORD bits).\"#);\n-\n-    // Nothing to normalize (Only a single quote)\n-    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits) -> something ($WORD bits).\";\n-    let first = parse_normalization_string(&mut s);\n-    assert_eq!(first, None);\n-    assert_eq!(s, \"normalize-stderr-32bit: \\\"something (32 bits) -> something ($WORD bits).\");\n-\n-    // Nothing to normalize (Three quotes)\n-    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits)\\\" -> \\\"something ($WORD bits).\";\n-    let first = parse_normalization_string(&mut s);\n-    assert_eq!(first, Some(\"something (32 bits)\".to_owned()));\n-    assert_eq!(s, \" -> \\\"something ($WORD bits).\");\n-}"}, {"sha": "2a1831d5ee80c940095d55d097f0098f655b622a", "filename": "src/tools/compiletest/src/header/tests.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,27 @@\n+use super::*;\n+\n+#[test]\n+fn test_parse_normalization_string() {\n+    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits)\\\" -> \\\"something ($WORD bits)\\\".\";\n+    let first = parse_normalization_string(&mut s);\n+    assert_eq!(first, Some(\"something (32 bits)\".to_owned()));\n+    assert_eq!(s, \" -> \\\"something ($WORD bits)\\\".\");\n+\n+    // Nothing to normalize (No quotes)\n+    let mut s = \"normalize-stderr-32bit: something (32 bits) -> something ($WORD bits).\";\n+    let first = parse_normalization_string(&mut s);\n+    assert_eq!(first, None);\n+    assert_eq!(s, r#\"normalize-stderr-32bit: something (32 bits) -> something ($WORD bits).\"#);\n+\n+    // Nothing to normalize (Only a single quote)\n+    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits) -> something ($WORD bits).\";\n+    let first = parse_normalization_string(&mut s);\n+    assert_eq!(first, None);\n+    assert_eq!(s, \"normalize-stderr-32bit: \\\"something (32 bits) -> something ($WORD bits).\");\n+\n+    // Nothing to normalize (Three quotes)\n+    let mut s = \"normalize-stderr-32bit: \\\"something (32 bits)\\\" -> \\\"something ($WORD bits).\";\n+    let first = parse_normalization_string(&mut s);\n+    assert_eq!(first, Some(\"something (32 bits)\".to_owned()));\n+    assert_eq!(s, \" -> \\\"something ($WORD bits).\");\n+}"}, {"sha": "bde49ff391c8c5a7c01ecc1d49b7f4923672baa9", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -25,6 +25,9 @@ use log::*;\n \n use self::header::{EarlyProps, Ignore};\n \n+#[cfg(test)]\n+mod tests;\n+\n pub mod common;\n pub mod errors;\n pub mod header;\n@@ -1093,53 +1096,3 @@ fn extract_lldb_version(full_version_line: Option<String>) -> (Option<String>, b\n fn is_blacklisted_lldb_version(version: &str) -> bool {\n     version == \"350\"\n }\n-\n-#[test]\n-fn test_extract_gdb_version() {\n-    macro_rules! test { ($($expectation:tt: $input:tt,)*) => {{$(\n-        assert_eq!(extract_gdb_version($input), Some($expectation));\n-    )*}}}\n-\n-    test! {\n-        7000001: \"GNU gdb (GDB) CentOS (7.0.1-45.el5.centos)\",\n-\n-        7002000: \"GNU gdb (GDB) Red Hat Enterprise Linux (7.2-90.el6)\",\n-\n-        7004000: \"GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04\",\n-        7004001: \"GNU gdb (GDB) 7.4.1-debian\",\n-\n-        7006001: \"GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7\",\n-\n-        7007001: \"GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1\",\n-        7007001: \"GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1\",\n-        7007001: \"GNU gdb (GDB) Fedora 7.7.1-21.fc20\",\n-\n-        7008000: \"GNU gdb (GDB; openSUSE 13.2) 7.8\",\n-        7009001: \"GNU gdb (GDB) Fedora 7.9.1-20.fc22\",\n-        7010001: \"GNU gdb (GDB) Fedora 7.10.1-31.fc23\",\n-\n-        7011000: \"GNU gdb (Ubuntu 7.11-0ubuntu1) 7.11\",\n-        7011001: \"GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\",\n-        7011001: \"GNU gdb (Debian 7.11.1-2) 7.11.1\",\n-        7011001: \"GNU gdb (GDB) Fedora 7.11.1-86.fc24\",\n-        7011001: \"GNU gdb (GDB; openSUSE Leap 42.1) 7.11.1\",\n-        7011001: \"GNU gdb (GDB; openSUSE Tumbleweed) 7.11.1\",\n-\n-        7011090: \"7.11.90\",\n-        7011090: \"GNU gdb (Ubuntu 7.11.90.20161005-0ubuntu1) 7.11.90.20161005-git\",\n-\n-        7012000: \"7.12\",\n-        7012000: \"GNU gdb (GDB) 7.12\",\n-        7012000: \"GNU gdb (GDB) 7.12.20161027-git\",\n-        7012050: \"GNU gdb (GDB) 7.12.50.20161027-git\",\n-    }\n-}\n-\n-#[test]\n-fn is_test_test() {\n-    assert_eq!(true, is_test(&OsString::from(\"a_test.rs\")));\n-    assert_eq!(false, is_test(&OsString::from(\".a_test.rs\")));\n-    assert_eq!(false, is_test(&OsString::from(\"a_cat.gif\")));\n-    assert_eq!(false, is_test(&OsString::from(\"#a_dog_gif\")));\n-    assert_eq!(false, is_test(&OsString::from(\"~a_temp_file\")));\n-}"}, {"sha": "05cfdf1ce53bff4eaae21743c98019562b2a95e9", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 3, "deletions": 65, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -35,6 +35,9 @@ use log::*;\n use crate::extract_gdb_version;\n use crate::is_android_gdb_target;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[cfg(windows)]\n fn disable_error_reporting<F: FnOnce() -> R, R>(f: F) -> R {\n     use std::sync::Mutex;\n@@ -3706,68 +3709,3 @@ fn read2_abbreviated(mut child: Child) -> io::Result<Output> {\n         stderr: stderr.into_bytes(),\n     })\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::TestCx;\n-\n-    #[test]\n-    fn normalize_platform_differences() {\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\foo.rs\"),\n-            \"$DIR/foo.rs\"\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$BUILD_DIR\\..\\parser.rs\"),\n-            \"$BUILD_DIR/../parser.rs\"\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\bar.rs hello\\nworld\"),\n-            r\"$DIR/bar.rs hello\\nworld\"\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"either bar\\baz.rs or bar\\baz\\mod.rs\"),\n-            r\"either bar/baz.rs or bar/baz/mod.rs\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"`.\\some\\path.rs`\"),\n-            r\"`./some/path.rs`\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"`some\\path.rs`\"),\n-            r\"`some/path.rs`\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\path-with-dashes.rs\"),\n-            r\"$DIR/path-with-dashes.rs\"\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\path_with_underscores.rs\"),\n-            r\"$DIR/path_with_underscores.rs\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\foo.rs:12:11\"), \"$DIR/foo.rs:12:11\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\path with spaces 'n' quotes\"),\n-            \"$DIR/path with spaces 'n' quotes\",\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r\"$DIR\\file_with\\no_extension\"),\n-            \"$DIR/file_with/no_extension\",\n-        );\n-\n-        assert_eq!(TestCx::normalize_platform_differences(r\"\\n\"), r\"\\n\");\n-        assert_eq!(TestCx::normalize_platform_differences(r\"{ \\n\"), r\"{ \\n\");\n-        assert_eq!(TestCx::normalize_platform_differences(r\"`\\]`\"), r\"`\\]`\");\n-        assert_eq!(TestCx::normalize_platform_differences(r#\"\"\\{\"\"#), r#\"\"\\{\"\"#);\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r#\"write!(&mut v, \"Hello\\n\")\"#),\n-            r#\"write!(&mut v, \"Hello\\n\")\"#\n-        );\n-        assert_eq!(\n-            TestCx::normalize_platform_differences(r#\"println!(\"test\\ntest\")\"#),\n-            r#\"println!(\"test\\ntest\")\"#,\n-        );\n-    }\n-}"}, {"sha": "79128aa9c696ae5301c9a5452fda1e16354a2757", "filename": "src/tools/compiletest/src/runtest/tests.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,61 @@\n+use super::*;\n+\n+#[test]\n+fn normalize_platform_differences() {\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\foo.rs\"),\n+        \"$DIR/foo.rs\"\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$BUILD_DIR\\..\\parser.rs\"),\n+        \"$BUILD_DIR/../parser.rs\"\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\bar.rs hello\\nworld\"),\n+        r\"$DIR/bar.rs hello\\nworld\"\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"either bar\\baz.rs or bar\\baz\\mod.rs\"),\n+        r\"either bar/baz.rs or bar/baz/mod.rs\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"`.\\some\\path.rs`\"),\n+        r\"`./some/path.rs`\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"`some\\path.rs`\"),\n+        r\"`some/path.rs`\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\path-with-dashes.rs\"),\n+        r\"$DIR/path-with-dashes.rs\"\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\path_with_underscores.rs\"),\n+        r\"$DIR/path_with_underscores.rs\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\foo.rs:12:11\"), \"$DIR/foo.rs:12:11\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\path with spaces 'n' quotes\"),\n+        \"$DIR/path with spaces 'n' quotes\",\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r\"$DIR\\file_with\\no_extension\"),\n+        \"$DIR/file_with/no_extension\",\n+    );\n+\n+    assert_eq!(TestCx::normalize_platform_differences(r\"\\n\"), r\"\\n\");\n+    assert_eq!(TestCx::normalize_platform_differences(r\"{ \\n\"), r\"{ \\n\");\n+    assert_eq!(TestCx::normalize_platform_differences(r\"`\\]`\"), r\"`\\]`\");\n+    assert_eq!(TestCx::normalize_platform_differences(r#\"\"\\{\"\"#), r#\"\"\\{\"\"#);\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r#\"write!(&mut v, \"Hello\\n\")\"#),\n+        r#\"write!(&mut v, \"Hello\\n\")\"#\n+    );\n+    assert_eq!(\n+        TestCx::normalize_platform_differences(r#\"println!(\"test\\ntest\")\"#),\n+        r#\"println!(\"test\\ntest\")\"#,\n+    );\n+}"}, {"sha": "388ad75757f61bc9d2a3b3866b69418225573fb0", "filename": "src/tools/compiletest/src/tests.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,51 @@\n+use super::*;\n+\n+#[test]\n+fn test_extract_gdb_version() {\n+    macro_rules! test { ($($expectation:tt: $input:tt,)*) => {{$(\n+        assert_eq!(extract_gdb_version($input), Some($expectation));\n+    )*}}}\n+\n+    test! {\n+        7000001: \"GNU gdb (GDB) CentOS (7.0.1-45.el5.centos)\",\n+\n+        7002000: \"GNU gdb (GDB) Red Hat Enterprise Linux (7.2-90.el6)\",\n+\n+        7004000: \"GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04\",\n+        7004001: \"GNU gdb (GDB) 7.4.1-debian\",\n+\n+        7006001: \"GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-80.el7\",\n+\n+        7007001: \"GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1\",\n+        7007001: \"GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1\",\n+        7007001: \"GNU gdb (GDB) Fedora 7.7.1-21.fc20\",\n+\n+        7008000: \"GNU gdb (GDB; openSUSE 13.2) 7.8\",\n+        7009001: \"GNU gdb (GDB) Fedora 7.9.1-20.fc22\",\n+        7010001: \"GNU gdb (GDB) Fedora 7.10.1-31.fc23\",\n+\n+        7011000: \"GNU gdb (Ubuntu 7.11-0ubuntu1) 7.11\",\n+        7011001: \"GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1\",\n+        7011001: \"GNU gdb (Debian 7.11.1-2) 7.11.1\",\n+        7011001: \"GNU gdb (GDB) Fedora 7.11.1-86.fc24\",\n+        7011001: \"GNU gdb (GDB; openSUSE Leap 42.1) 7.11.1\",\n+        7011001: \"GNU gdb (GDB; openSUSE Tumbleweed) 7.11.1\",\n+\n+        7011090: \"7.11.90\",\n+        7011090: \"GNU gdb (Ubuntu 7.11.90.20161005-0ubuntu1) 7.11.90.20161005-git\",\n+\n+        7012000: \"7.12\",\n+        7012000: \"GNU gdb (GDB) 7.12\",\n+        7012000: \"GNU gdb (GDB) 7.12.20161027-git\",\n+        7012050: \"GNU gdb (GDB) 7.12.50.20161027-git\",\n+    }\n+}\n+\n+#[test]\n+fn is_test_test() {\n+    assert_eq!(true, is_test(&OsString::from(\"a_test.rs\")));\n+    assert_eq!(false, is_test(&OsString::from(\".a_test.rs\")));\n+    assert_eq!(false, is_test(&OsString::from(\"a_cat.gif\")));\n+    assert_eq!(false, is_test(&OsString::from(\"#a_dog_gif\")));\n+    assert_eq!(false, is_test(&OsString::from(\"~a_temp_file\")));\n+}"}, {"sha": "56ebea7c20f368b2b1f7bb26b64904b91abed0c0", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -5,6 +5,9 @@ use crate::common::Config;\n \n use log::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// Conversion table from triple OS name to Rust SYSNAME\n const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"android\", \"android\"),\n@@ -157,34 +160,3 @@ impl PathBufExt for PathBuf {\n         }\n     }\n }\n-\n-#[test]\n-#[should_panic(expected = \"Cannot determine Architecture from triple\")]\n-fn test_get_arch_failure() {\n-    get_arch(\"abc\");\n-}\n-\n-#[test]\n-fn test_get_arch() {\n-    assert_eq!(\"x86_64\", get_arch(\"x86_64-unknown-linux-gnu\"));\n-    assert_eq!(\"x86_64\", get_arch(\"amd64\"));\n-    assert_eq!(\"nvptx64\", get_arch(\"nvptx64-nvidia-cuda\"));\n-}\n-\n-#[test]\n-#[should_panic(expected = \"Cannot determine OS from triple\")]\n-fn test_matches_os_failure() {\n-    matches_os(\"abc\", \"abc\");\n-}\n-\n-#[test]\n-fn test_matches_os() {\n-    assert!(matches_os(\"x86_64-unknown-linux-gnu\", \"linux\"));\n-    assert!(matches_os(\"wasm32-unknown-unknown\", \"emscripten\"));\n-    assert!(matches_os(\"wasm32-unknown-unknown\", \"wasm32-bare\"));\n-    assert!(!matches_os(\"wasm32-unknown-unknown\", \"windows\"));\n-    assert!(matches_os(\"thumbv6m0-none-eabi\", \"none\"));\n-    assert!(matches_os(\"riscv32imc-unknown-none-elf\", \"none\"));\n-    assert!(matches_os(\"nvptx64-nvidia-cuda\", \"cuda\"));\n-    assert!(matches_os(\"x86_64-fortanix-unknown-sgx\", \"sgx\"));\n-}"}, {"sha": "55bf659ba28f16428ae5dc6743631368aa57129a", "filename": "src/tools/compiletest/src/util/tests.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,32 @@\n+use super::*;\n+\n+#[test]\n+#[should_panic(expected = \"Cannot determine Architecture from triple\")]\n+fn test_get_arch_failure() {\n+    get_arch(\"abc\");\n+}\n+\n+#[test]\n+fn test_get_arch() {\n+    assert_eq!(\"x86_64\", get_arch(\"x86_64-unknown-linux-gnu\"));\n+    assert_eq!(\"x86_64\", get_arch(\"amd64\"));\n+    assert_eq!(\"nvptx64\", get_arch(\"nvptx64-nvidia-cuda\"));\n+}\n+\n+#[test]\n+#[should_panic(expected = \"Cannot determine OS from triple\")]\n+fn test_matches_os_failure() {\n+    matches_os(\"abc\", \"abc\");\n+}\n+\n+#[test]\n+fn test_matches_os() {\n+    assert!(matches_os(\"x86_64-unknown-linux-gnu\", \"linux\"));\n+    assert!(matches_os(\"wasm32-unknown-unknown\", \"emscripten\"));\n+    assert!(matches_os(\"wasm32-unknown-unknown\", \"wasm32-bare\"));\n+    assert!(!matches_os(\"wasm32-unknown-unknown\", \"windows\"));\n+    assert!(matches_os(\"thumbv6m0-none-eabi\", \"none\"));\n+    assert!(matches_os(\"riscv32imc-unknown-none-elf\", \"none\"));\n+    assert!(matches_os(\"nvptx64-nvidia-cuda\", \"cuda\"));\n+    assert!(matches_os(\"x86_64-fortanix-unknown-sgx\", \"sgx\"));\n+}"}, {"sha": "88a469ef9550cb719cb70acdd277cefcc33eb10c", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -16,6 +16,9 @@ use std::path::Path;\n \n use regex::Regex;\n \n+#[cfg(test)]\n+mod tests;\n+\n mod version;\n use version::Version;\n \n@@ -203,14 +206,6 @@ fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n         .map(|m| m.as_str())\n }\n \n-#[test]\n-fn test_find_attr_val() {\n-    let s = r#\"#[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\"#;\n-    assert_eq!(find_attr_val(s, \"feature\"), Some(\"checked_duration_since\"));\n-    assert_eq!(find_attr_val(s, \"issue\"), Some(\"58402\"));\n-    assert_eq!(find_attr_val(s, \"since\"), None);\n-}\n-\n fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n     let prefix = \"feature_gate_\";\n     if filen_underscore.starts_with(prefix) {"}, {"sha": "fa7a931ec865cd19960ad3e92e83afb69aac5402", "filename": "src/tools/tidy/src/features/tests.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,9 @@\n+use super::*;\n+\n+#[test]\n+fn test_find_attr_val() {\n+    let s = r#\"#[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\"#;\n+    assert_eq!(find_attr_val(s, \"feature\"), Some(\"checked_duration_since\"));\n+    assert_eq!(find_attr_val(s, \"issue\"), Some(\"58402\"));\n+    assert_eq!(find_attr_val(s, \"since\"), None);\n+}"}, {"sha": "cc3a65102448633b0607db5a3668691023609c2d", "filename": "src/tools/tidy/src/features/version.rs", "status": "modified", "additions": 3, "deletions": 42, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -2,6 +2,9 @@ use std::str::FromStr;\n use std::num::ParseIntError;\n use std::fmt;\n \n+#[cfg(test)]\n+mod tests;\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Version {\n     parts: [u32; 3],\n@@ -46,45 +49,3 @@ impl FromStr for Version {\n         Ok(Self { parts })\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Version;\n-\n-    #[test]\n-    fn test_try_from_invalid_version() {\n-        assert!(\"\".parse::<Version>().is_err());\n-        assert!(\"hello\".parse::<Version>().is_err());\n-        assert!(\"1.32.hi\".parse::<Version>().is_err());\n-        assert!(\"1.32..1\".parse::<Version>().is_err());\n-        assert!(\"1.32\".parse::<Version>().is_err());\n-        assert!(\"1.32.0.1\".parse::<Version>().is_err());\n-    }\n-\n-    #[test]\n-    fn test_try_from_single() {\n-        assert_eq!(\"1.32.0\".parse(), Ok(Version { parts: [1, 32, 0] }));\n-        assert_eq!(\"1.0.0\".parse(), Ok(Version { parts: [1, 0, 0] }));\n-    }\n-\n-    #[test]\n-    fn test_compare() {\n-        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n-        let v_1_32_0 = \"1.32.0\".parse::<Version>().unwrap();\n-        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n-        assert!(v_1_0_0 < v_1_32_1);\n-        assert!(v_1_0_0 < v_1_32_0);\n-        assert!(v_1_32_0 < v_1_32_1);\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n-        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n-\n-        assert_eq!(v_1_0_0.to_string(), \"1.0.0\");\n-        assert_eq!(v_1_32_1.to_string(), \"1.32.1\");\n-        assert_eq!(format!(\"{:<8}\", v_1_32_1), \"1.32.1  \");\n-        assert_eq!(format!(\"{:>8}\", v_1_32_1), \"  1.32.1\");\n-    }\n-}"}, {"sha": "31224fdf1eacfb5ecba627c3e16c3e720163a9db", "filename": "src/tools/tidy/src/features/version/tests.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion%2Ftests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -0,0 +1,38 @@\n+use super::*;\n+\n+#[test]\n+fn test_try_from_invalid_version() {\n+    assert!(\"\".parse::<Version>().is_err());\n+    assert!(\"hello\".parse::<Version>().is_err());\n+    assert!(\"1.32.hi\".parse::<Version>().is_err());\n+    assert!(\"1.32..1\".parse::<Version>().is_err());\n+    assert!(\"1.32\".parse::<Version>().is_err());\n+    assert!(\"1.32.0.1\".parse::<Version>().is_err());\n+}\n+\n+#[test]\n+fn test_try_from_single() {\n+    assert_eq!(\"1.32.0\".parse(), Ok(Version { parts: [1, 32, 0] }));\n+    assert_eq!(\"1.0.0\".parse(), Ok(Version { parts: [1, 0, 0] }));\n+}\n+\n+#[test]\n+fn test_compare() {\n+    let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+    let v_1_32_0 = \"1.32.0\".parse::<Version>().unwrap();\n+    let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+    assert!(v_1_0_0 < v_1_32_1);\n+    assert!(v_1_0_0 < v_1_32_0);\n+    assert!(v_1_32_0 < v_1_32_1);\n+}\n+\n+#[test]\n+fn test_to_string() {\n+    let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+    let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+\n+    assert_eq!(v_1_0_0.to_string(), \"1.0.0\");\n+    assert_eq!(v_1_32_1.to_string(), \"1.32.1\");\n+    assert_eq!(format!(\"{:<8}\", v_1_32_1), \"1.32.1  \");\n+    assert_eq!(format!(\"{:>8}\", v_1_32_1), \"  1.32.1\");\n+}"}, {"sha": "6286945ad26b528bd36b7ac3842f51ae528021fc", "filename": "src/tools/tidy/src/unit_tests.rs", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf048cc115860cc110865f460f3f2b9b4308ad92/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funit_tests.rs?ref=cf048cc115860cc110865f460f3f2b9b4308ad92", "patch": "@@ -1,61 +1,35 @@\n-//! Tidy check to ensure `#[test]` and `#[bench]` are not used directly inside\n-//! `libcore` or `liballoc`.\n+//! Tidy check to ensure `#[test]` and `#[bench]` are not used directly inside `libcore`.\n //!\n-//! `#![no_std]` libraries cannot be tested directly due to duplicating lang\n-//! items. All tests and benchmarks must be written externally in `libcore/{tests,benches}`\n-//! or `liballoc/{tests,benches}`.\n+//! `#![no_core]` libraries cannot be tested directly due to duplicating lang\n+//! items. All tests and benchmarks must be written externally in `libcore/{tests,benches}`.\n //!\n-//! Outside of libcore and liballoc tests and benchmarks should be outlined into separate files\n+//! Outside of libcore tests and benchmarks should be outlined into separate files\n //! named `tests.rs` or `benches.rs`, or directories named `tests` or `benches` unconfigured\n //! during normal build.\n \n use std::path::Path;\n \n pub fn check(root_path: &Path, bad: &mut bool) {\n     let libcore = &root_path.join(\"libcore\");\n-    let liballoc = &root_path.join(\"liballoc\");\n     let libcore_tests = &root_path.join(\"libcore/tests\");\n-    let liballoc_tests = &root_path.join(\"liballoc/tests\");\n     let libcore_benches = &root_path.join(\"libcore/benches\");\n-    let liballoc_benches = &root_path.join(\"liballoc/benches\");\n-    let is_core_or_alloc = |path: &Path| {\n-        let is_core = path.starts_with(libcore) &&\n-                      !(path.starts_with(libcore_tests) || path.starts_with(libcore_benches));\n-        let is_alloc = path.starts_with(liballoc) &&\n-                       !(path.starts_with(liballoc_tests) || path.starts_with(liballoc_benches));\n-        is_core || is_alloc\n+    let is_core = |path: &Path| {\n+        path.starts_with(libcore) &&\n+        !(path.starts_with(libcore_tests) || path.starts_with(libcore_benches))\n     };\n-    let fixme = [\n-        \"liballoc\",\n-        \"libpanic_unwind/dwarf\",\n-        \"librustc\",\n-        \"librustc_data_structures\",\n-        \"librustc_incremental/persist\",\n-        \"librustc_lexer/src\",\n-        \"librustc_target/spec\",\n-        \"librustdoc\",\n-        \"libserialize\",\n-        \"libstd\",\n-        \"libsyntax\",\n-        \"libsyntax_pos\",\n-        \"libterm/terminfo\",\n-        \"libtest\",\n-        \"tools/compiletest/src\",\n-        \"tools/tidy/src\",\n-    ];\n \n     let mut skip = |path: &Path| {\n         let file_name = path.file_name().unwrap_or_default();\n         if path.is_dir() {\n             super::filter_dirs(path) ||\n             path.ends_with(\"src/test\") ||\n             path.ends_with(\"src/doc\") ||\n-            (file_name == \"tests\" || file_name == \"benches\") && !is_core_or_alloc(path) ||\n-            fixme.iter().any(|p| path.ends_with(p))\n+            path.ends_with(\"src/libstd\") || // FIXME?\n+            (file_name == \"tests\" || file_name == \"benches\") && !is_core(path)\n         } else {\n             let extension = path.extension().unwrap_or_default();\n             extension != \"rs\" ||\n-            (file_name == \"tests.rs\" || file_name == \"benches.rs\") && !is_core_or_alloc(path)\n+            (file_name == \"tests.rs\" || file_name == \"benches.rs\") && !is_core(path)\n         }\n     };\n \n@@ -65,7 +39,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n         &mut |entry, contents| {\n             let path = entry.path();\n             let is_libcore = path.starts_with(libcore);\n-            let is_liballoc = path.starts_with(liballoc);\n             for (i, line) in contents.lines().enumerate() {\n                 let line = line.trim();\n                 let is_test = || line.contains(\"#[test]\") && !line.contains(\"`#[test]\");\n@@ -74,9 +47,6 @@ pub fn check(root_path: &Path, bad: &mut bool) {\n                     let explanation = if is_libcore {\n                         \"libcore unit tests and benchmarks must be placed into \\\n                          `libcore/tests` or `libcore/benches`\"\n-                    } else if is_liballoc {\n-                        \"liballoc unit tests and benchmarks must be placed into \\\n-                         `liballoc/tests` or `liballoc/benches`\"\n                     } else {\n                         \"unit tests and benchmarks must be placed into \\\n                          separate files or directories named \\"}]}