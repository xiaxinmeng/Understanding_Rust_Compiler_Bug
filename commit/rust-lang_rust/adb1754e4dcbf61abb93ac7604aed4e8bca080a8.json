{"sha": "adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjE3NTRlNGRjYmY2MWFiYjkzYWM3NjA0YWVkNGU4YmNhMDgwYTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-04T00:10:37Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-05T18:18:40Z"}, "message": "Move the option type to its own module", "tree": {"sha": "037acbf63e189a999291e04a9a9db4e777e9c003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/037acbf63e189a999291e04a9a9db4e777e9c003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "html_url": "https://github.com/rust-lang/rust/commit/adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e399926776e0d1ef7ebe6d9f0d7ef6d066eabfa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e399926776e0d1ef7ebe6d9f0d7ef6d066eabfa0", "html_url": "https://github.com/rust-lang/rust/commit/e399926776e0d1ef7ebe6d9f0d7ef6d066eabfa0"}], "stats": {"total": 208, "additions": 115, "deletions": 93}, "files": [{"sha": "154b87cbcf45c940f65d03c073627b214c464234", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -5,9 +5,9 @@ import front.token;\n import middle.trans;\n import middle.resolve;\n \n-import std.util.option;\n-import std.util.some;\n-import std.util.none;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n import std._str;\n import std._vec;\n \n@@ -39,8 +39,8 @@ fn usage(session.session sess, str argv0) {\n impure fn main(vec[str] args) {\n \n   auto sess = session.session();\n-  let option[str] input_file = none[str];\n-  let option[str] output_file = none[str];\n+  let option.t[str] input_file = none[str];\n+  let option.t[str] output_file = none[str];\n   let bool do_warn = true;\n \n   auto i = 1u;"}, {"sha": "a6cbf1ce793aa27538fe4af42f2743c162b1bcb9", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,7 +1,6 @@\n \n-import util.common.option;\n import std.map.hashmap;\n-import std.util.option;\n+import std.option;\n import util.common.span;\n import util.common.spanned;\n \n@@ -71,16 +70,16 @@ tag unop {\n type stmt = spanned[stmt_];\n tag stmt_ {\n     stmt_decl(@decl);\n-    stmt_ret(option[@expr]);\n+    stmt_ret(option.t[@expr]);\n     stmt_log(@expr);\n     stmt_check_expr(@expr);\n     stmt_expr(@expr);\n }\n \n-type local = rec(option[@ty] ty,\n+type local = rec(option.t[@ty] ty,\n                  bool infer,\n                  ident ident,\n-                 option[@expr] init,\n+                 option.t[@expr] init,\n                  def_id id);\n \n type decl = spanned[decl_];\n@@ -99,14 +98,14 @@ tag expr_ {\n     expr_unary(unop, @expr, ann);\n     expr_lit(@lit, ann);\n     expr_cast(@expr, @ty, ann);\n-    expr_if(@expr, block, option[block], ann);\n+    expr_if(@expr, block, option.t[block], ann);\n     expr_while(@expr, block, ann);\n     expr_do_while(block, @expr, ann);\n     expr_block(block, ann);\n     expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n-    expr_name(name, option[def], ann);\n+    expr_name(name, option.t[def], ann);\n }\n \n type lit = spanned[lit_];\n@@ -131,7 +130,7 @@ tag ty_ {\n     ty_box(@ty);\n     ty_vec(@ty);\n     ty_tup(vec[tup(bool /* mutability */, @ty)]);\n-    ty_path(path, option[def]);\n+    ty_path(path, option.t[def]);\n }\n \n tag mode {"}, {"sha": "6eb334ca81fa412333eca74e1a5f3ba7dbe4f9f9", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,7 +1,7 @@\n import std._io;\n-import std.util.option;\n-import std.util.some;\n-import std.util.none;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n import std.map.hashmap;\n \n import driver.session;\n@@ -157,7 +157,7 @@ impure fn parse_arg(parser p) -> ast.arg {\n \n impure fn parse_seq[T](token.token bra,\n                       token.token ket,\n-                      option[token.token] sep,\n+                      option.t[token.token] sep,\n                       (impure fn(parser) -> T) f,\n                       parser p) -> util.common.spanned[vec[T]] {\n     let bool first = true;\n@@ -185,7 +185,7 @@ impure fn parse_seq[T](token.token bra,\n     ret spanned(lo, hi, v);\n }\n \n-impure fn parse_lit(parser p) -> option[ast.lit] {\n+impure fn parse_lit(parser p) -> option.t[ast.lit] {\n     auto lo = p.get_span();\n     let ast.lit_ lit;\n     alt (p.peek()) {\n@@ -600,7 +600,7 @@ impure fn parse_if_expr(parser p) -> @ast.expr {\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     auto thn = parse_block(p);\n-    let option[ast.block] els = none[ast.block];\n+    let option.t[ast.block] els = none[ast.block];\n     hi = thn.span;\n     alt (p.peek()) {\n         case (token.ELSE) {\n@@ -664,7 +664,7 @@ impure fn parse_expr(parser p) -> @ast.expr {\n     }\n }\n \n-impure fn parse_initializer(parser p) -> option[@ast.expr] {\n+impure fn parse_initializer(parser p) -> option.t[@ast.expr] {\n     if (p.peek() == token.EQ) {\n         p.bump();\n         ret some(parse_expr(p));"}, {"sha": "48363437b3711f129427f7a8b3d934f6430e3465", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,7 +1,7 @@\n import std.map.hashmap;\n-import std.util.option;\n-import std.util.some;\n-import std.util.none;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n \n import util.common.new_str_hash;\n import util.common.spanned;\n@@ -47,7 +47,7 @@ type ast_fold[ENV] =\n          vec[tup(bool, @ty)] elts) -> @ty)        fold_ty_tup,\n \n      (fn(&ENV e, &span sp, ast.path p,\n-         &option[def] d) -> @ty)                  fold_ty_path,\n+         &option.t[def] d) -> @ty)                  fold_ty_path,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n@@ -79,7 +79,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          @expr cond, &block thn,\n-         &option[block] els,\n+         &option.t[block] els,\n          ann a) -> @expr)                         fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n@@ -107,7 +107,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &name n,\n-         &option[def] d,\n+         &option.t[def] d,\n          ann a) -> @expr)                         fold_expr_name,\n \n      // Decl folds.\n@@ -123,7 +123,7 @@ type ast_fold[ENV] =\n          @decl decl) -> @stmt)                    fold_stmt_decl,\n \n      (fn(&ENV e, &span sp,\n-         &option[@expr] rv) -> @stmt)             fold_stmt_ret,\n+         &option.t[@expr] rv) -> @stmt)           fold_stmt_ret,\n \n      (fn(&ENV e, &span sp,\n          @expr e) -> @stmt)                       fold_stmt_log,\n@@ -568,7 +568,7 @@ fn identity_fold_ty_tup[ENV](&ENV env, &span sp, vec[tup(bool,@ty)] elts)\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n-                        &option[def] d) -> @ty {\n+                        &option.t[def] d) -> @ty {\n     ret @respan(sp, ast.ty_path(p, d));\n }\n \n@@ -614,7 +614,7 @@ fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit,\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n                               @expr cond, &block thn,\n-                              &option[block] els, ann a) -> @expr {\n+                              &option.t[block] els, ann a) -> @expr {\n     ret @respan(sp, ast.expr_if(cond, thn, els, a));\n }\n \n@@ -650,7 +650,7 @@ fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n-                                &name n, &option[def] d,\n+                                &name n, &option.t[def] d,\n                                 ann a) -> @expr {\n     ret @respan(sp, ast.expr_name(n, d, a));\n }\n@@ -675,7 +675,7 @@ fn identity_fold_stmt_decl[ENV](&ENV env, &span sp, @decl d) -> @stmt {\n }\n \n fn identity_fold_stmt_ret[ENV](&ENV env, &span sp,\n-                               &option[@expr] rv) -> @stmt {\n+                               &option.t[@expr] rv) -> @stmt {\n     ret @respan(sp, ast.stmt_ret(rv));\n }\n "}, {"sha": "875996db12076cdcf1747b74744ea24d411dc629", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -8,9 +8,9 @@ import std.map.hashmap;\n import std.list.list;\n import std.list.nil;\n import std.list.cons;\n-import std.util.option;\n-import std.util.some;\n-import std.util.none;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n import std._str;\n \n tag scope {\n@@ -22,11 +22,11 @@ tag scope {\n type env = rec(list[scope] scopes,\n                session.session sess);\n \n-fn lookup_name(&env e, ast.ident i) -> option[def] {\n+fn lookup_name(&env e, ast.ident i) -> option.t[def] {\n \n     // log \"resolving name \" + i;\n \n-    fn found_def_item(@ast.item i) -> option[def] {\n+    fn found_def_item(@ast.item i) -> option.t[def] {\n         alt (i.node) {\n             case (ast.item_fn(_, _, ?id)) {\n                 ret some[def](ast.def_fn(id));\n@@ -40,7 +40,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n         }\n     }\n \n-    fn found_decl_stmt(@ast.stmt s) -> option[def] {\n+    fn found_decl_stmt(@ast.stmt s) -> option.t[def] {\n         alt (s.node) {\n             case (ast.stmt_decl(?d)) {\n                 alt (d.node) {\n@@ -56,7 +56,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n         ret none[def];\n     }\n \n-    fn check_mod(ast.ident i, ast._mod m) -> option[def] {\n+    fn check_mod(ast.ident i, ast._mod m) -> option.t[def] {\n         alt (m.index.find(i)) {\n             case (some[uint](?ix)) {\n                 ret found_def_item(m.items.(ix));\n@@ -66,7 +66,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n     }\n \n \n-    fn in_scope(ast.ident i, &scope s) -> option[def] {\n+    fn in_scope(ast.ident i, &scope s) -> option.t[def] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n@@ -103,7 +103,7 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n }\n \n fn fold_expr_name(&env e, &span sp, &ast.name n,\n-                  &option[def] d, ann a) -> @ast.expr {\n+                  &option.t[def] d, ann a) -> @ast.expr {\n \n     auto d_ = lookup_name(e, n.node.ident);\n "}, {"sha": "ba4f5cdfdd4cf3a7e9abc729f7b8c9523f5efdd2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -3,9 +3,9 @@ import std._vec;\n import std._str.rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n import std.map.hashmap;\n-import std.util.option;\n-import std.util.some;\n-import std.util.none;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n \n import front.ast;\n import driver.session;\n@@ -613,7 +613,7 @@ impure fn trans_binary(@block_ctxt cx, ast.binop op,\n }\n \n impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n-                   &ast.block thn, &option[ast.block] els) -> result {\n+                   &ast.block thn, &option.t[ast.block] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -868,7 +868,7 @@ impure fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-impure fn trans_ret(@block_ctxt cx, &option[@ast.expr] e) -> result {\n+impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     auto r = res(cx, C_nil());\n     alt (e) {\n         case (some[@ast.expr](?x)) {"}, {"sha": "c2ca95fcb6784f59734fb2634f8bdab976e7757c", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,5 +1,5 @@\n import vbuf = rustrt.vbuf;\n-import op = util.operator;\n+import std.option;\n \n native \"rust\" mod rustrt {\n     type vbuf;\n@@ -129,7 +129,7 @@ fn grow[T](&mutable vec[T] v, int n, &T initval) {\n     }\n }\n \n-fn map[T, U](&op[T,U] f, &vec[T] v) -> vec[U] {\n+fn map[T, U](&option.operator[T,U] f, &vec[T] v) -> vec[U] {\n     let vec[U] u = alloc[U](len[T](v));\n     for (T ve in v) {\n         u += vec(f(ve));"}, {"sha": "8e3051954e7b29edae5046d792b6a44ff8a20b73", "filename": "src/lib/deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -2,7 +2,7 @@\n  * A deque, for fun.  Untested as of yet.  Likely buggy.\n  */\n \n-import std.util;\n+import std.option;\n import std._vec;\n import std._int;\n \n@@ -23,7 +23,7 @@ type t[T] = obj {\n \n fn create[T]() -> t[T] {\n \n-    type cell[T] = mutable util.option[T];\n+    type cell[T] = mutable option.t[T];\n \n     let uint initial_capacity = 32u; // 2^5\n \n@@ -39,7 +39,7 @@ fn create[T]() -> t[T] {\n             if (i < nelts) {\n                 ret old.((lo + i) % nelts);\n             } else {\n-                ret util.none[T];\n+                ret option.none[T];\n             }\n         }\n \n@@ -50,7 +50,7 @@ fn create[T]() -> t[T] {\n \n     fn get[T](vec[cell[T]] elts, uint i) -> T {\n         alt (elts.(i)) {\n-            case (util.some[T](?t)) { ret t; }\n+            case (option.some[T](?t)) { ret t; }\n             case (_) { fail; }\n         }\n     }\n@@ -77,7 +77,7 @@ fn create[T]() -> t[T] {\n                     hi = nelts;\n                 }\n \n-                elts.(lo) = util.some[T](t);\n+                elts.(lo) = option.some[T](t);\n                 nelts += 1u;\n             }\n \n@@ -88,7 +88,7 @@ fn create[T]() -> t[T] {\n                     hi = nelts;\n                 }\n \n-                elts.(hi) = util.some[T](t);\n+                elts.(hi) = option.some[T](t);\n                 hi = (hi + 1u) % _vec.len[cell[T]](elts);\n                 nelts += 1u;\n             }\n@@ -99,7 +99,7 @@ fn create[T]() -> t[T] {\n              */\n             fn pop_front() -> T {\n                 let T t = get[T](elts, lo);\n-                elts.(lo) = util.none[T];\n+                elts.(lo) = option.none[T];\n                 lo = (lo + 1u) % _vec.len[cell[T]](elts);\n                 nelts -= 1u;\n                 ret t;\n@@ -113,7 +113,7 @@ fn create[T]() -> t[T] {\n                 }\n \n                 let T t = get[T](elts, hi);\n-                elts.(hi) = util.none[T];\n+                elts.(hi) = option.none[T];\n                 nelts -= 1u;\n                 ret t;\n             }\n@@ -132,7 +132,7 @@ fn create[T]() -> t[T] {\n             }\n \n         }\n-    let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T],\n+    let vec[cell[T]] v = _vec.init_elt[cell[T]](option.none[T],\n                                                 initial_capacity);\n \n     ret deque[T](0u, 0u, 0u, v);"}, {"sha": "c6a67c719645281048ba112126f973a31f6d0e65", "filename": "src/lib/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,7 +1,7 @@\n \n-import util.option;\n-import util.some;\n-import util.none;\n+import std.option;\n+import option.some;\n+import option.none;\n \n // FIXME: It would probably be more appealing to define this as\n // type list[T] = rec(T hd, option[@list[T]] tl), but at the moment\n@@ -27,7 +27,7 @@ fn foldl[T,U](&list[T] ls, &U u, fn(&T t, U u) -> U f) -> U {\n }\n \n fn find[T,U](&list[T] ls,\n-             (fn(&T) -> option[U]) f) -> option[U] {\n+             (fn(&T) -> option.t[U]) f) -> option.t[U] {\n   alt(ls) {\n     case (cons[T](?hd, ?tl)) {\n         alt (f(hd)) {"}, {"sha": "b20fd9c53e831b3c2f3d90ddc04de6b6fe6f14dd", "filename": "src/lib/map.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -5,7 +5,7 @@\n \n import std._int;\n import std.sys;\n-import std.util;\n+import std.option;\n import std._vec;\n \n \n@@ -17,8 +17,8 @@ abs state type hashmap[K, V] = state obj {\n                                  fn insert(&K key, &V val) -> bool;\n                                  fn contains_key(&K key) -> bool;\n                                  fn get(&K key) -> V;\n-                                 fn find(&K key) -> util.option[V];\n-                                 fn remove(&K key) -> util.option[V];\n+                                 fn find(&K key) -> option.t[V];\n+                                 fn remove(&K key) -> option.t[V];\n                                  fn rehash();\n                                  iter items() -> tup(K,V);\n };\n@@ -103,25 +103,25 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                          vec[mutable bucket[K, V]] bkts,\n                          uint nbkts,\n                          &K key)\n-        -> util.option[V]\n+        -> option.t[V]\n         {\n             let uint i = 0u;\n             while (i < nbkts) {\n                 let uint j = (hash[K](hasher, nbkts, key, i));\n                 alt (bkts.(j)) {\n                     case (some[K, V](?k, ?v)) {\n                         if (eqer(key, k)) {\n-                            ret util.some[V](v);\n+                            ret option.some[V](v);\n                         }\n                     }\n                     case (nil[K, V]) {\n-                        ret util.none[V];\n+                        ret option.none[V];\n                     }\n                     case (deleted[K, V]) { }\n                 }\n                 i += 1u;\n             }\n-            ret util.none[V];\n+            ret option.none[V];\n         }\n \n \n@@ -173,25 +173,25 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n             fn contains_key(&K key) -> bool {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (util.some[V](_)) { ret true; }\n+                    case (option.some[V](_)) { ret true; }\n                     case (_) { ret false; }\n                 }\n             }\n \n             fn get(&K key) -> V {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-                    case (util.some[V](?val)) { ret val; }\n+                    case (option.some[V](?val)) { ret val; }\n                     case (_) { fail; }\n                 }\n             }\n \n-            fn find(&K key) -> util.option[V] {\n+            fn find(&K key) -> option.t[V] {\n                 // FIXME: should be 'be' but parametric tail-calls don't\n                 // work at the moment.\n                 ret find_common[K, V](hasher, eqer, bkts, nbkts, key);\n             }\n \n-            fn remove(&K key) -> util.option[V] {\n+            fn remove(&K key) -> option.t[V] {\n                 let uint i = 0u;\n                 while (i < nbkts) {\n                     let uint j = (hash[K](hasher, nbkts, key, i));\n@@ -200,17 +200,17 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                             if (eqer(key, k)) {\n                                 bkts.(j) = deleted[K, V];\n                                 nelts -= 1u;\n-                                ret util.some[V](v);\n+                                ret option.some[V](v);\n                             }\n                         }\n                         case (deleted[K, V]) { }\n                         case (nil[K, V]) {\n-                            ret util.none[V];\n+                            ret option.none[V];\n                         }\n                     }\n                     i += 1u;\n                 }\n-                ret util.none[V];\n+                ret option.none[V];\n             }\n \n             fn rehash() {"}, {"sha": "dbf08b3e5f3f25f8aeae8b9fbe64910e6d4aca89", "filename": "src/lib/option.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -0,0 +1,40 @@\n+// lib/option.rs\n+\n+tag t[T] {\n+    none;\n+    some(T);\n+}\n+\n+type operator[T, U] = fn(&T) -> U;\n+\n+fn get[T](&t[T] opt) -> T {\n+    alt (opt) {\n+        case (some[T](?x)) {\n+            ret x;\n+        }\n+        case (none[T]) {\n+            fail;\n+        }\n+    }\n+}\n+\n+fn map[T, U](&operator[T, U] f, &t[T] opt) -> t[U] {\n+    alt (opt) {\n+        case (some[T](?x)) {\n+            ret some[U](f(x));\n+        }\n+        case (none[T]) {\n+            ret none[U];\n+        }\n+    }\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+"}, {"sha": "e00f2ef2eb28933d2dc934f91e6d35aa41f24fa3", "filename": "src/lib/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -20,6 +20,7 @@ mod _task;\n \n // Utility modules.\n \n+mod option;\n mod util;\n \n // Authorize various rule-bendings."}, {"sha": "72844d5f830eff3a92923577468165ee20f30d68", "filename": "src/lib/util.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -1,21 +1,3 @@\n-tag option[T] {\n-    none;\n-    some(T);\n-}\n-\n-type operator[T, U] = fn(&T) -> U;\n-\n-fn option_map[T, U](&operator[T, U] f, &option[T] opt) -> option[U] {\n-    alt (opt) {\n-        case (some[T](?x)) {\n-            ret some[U](f(x));\n-        }\n-        case (none[T]) {\n-            ret none[U];\n-        }\n-    }\n-}\n-\n fn id[T](&T x) -> T {\n     ret x;\n }"}, {"sha": "6f19715df2c22b6ae7a4dc6abed2ab6e3c4a17af", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb1754e4dcbf61abb93ac7604aed4e8bca080a8/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=adb1754e4dcbf61abb93ac7604aed4e8bca080a8", "patch": "@@ -32,7 +32,7 @@ fn test_slice() {\n \n fn test_map() {\n   fn square(&int x) -> int { ret x * x; }\n-  let std.util.operator[int, int] op = square;\n+  let std.option.operator[int, int] op = square;\n   let vec[int] v = vec(1, 2, 3, 4, 5);\n   let vec[int] s = std._vec.map[int, int](op, v);\n   let int i = 0;"}]}