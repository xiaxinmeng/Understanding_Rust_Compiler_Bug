{"sha": "2de64ef30577971dc80dfa38145d807aad72a264", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZTY0ZWYzMDU3Nzk3MWRjODBkZmEzODE0NWQ4MDdhYWQ3MmEyNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T13:19:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-29T13:19:46Z"}, "message": "Auto merge of #25760 - Ms2ger:tagged_docs, r=Manishearth", "tree": {"sha": "1b4ca49f9961716d54f45eb332cbc94cce8c3f19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4ca49f9961716d54f45eb332cbc94cce8c3f19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2de64ef30577971dc80dfa38145d807aad72a264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2de64ef30577971dc80dfa38145d807aad72a264", "html_url": "https://github.com/rust-lang/rust/commit/2de64ef30577971dc80dfa38145d807aad72a264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2de64ef30577971dc80dfa38145d807aad72a264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a433b968b4aa3e0894c7eff897e98b570141db9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a433b968b4aa3e0894c7eff897e98b570141db9", "html_url": "https://github.com/rust-lang/rust/commit/3a433b968b4aa3e0894c7eff897e98b570141db9"}, {"sha": "b700b37094a7215e4ac344f691b26c2e5fc81734", "url": "https://api.github.com/repos/rust-lang/rust/commits/b700b37094a7215e4ac344f691b26c2e5fc81734", "html_url": "https://github.com/rust-lang/rust/commit/b700b37094a7215e4ac344f691b26c2e5fc81734"}], "stats": {"total": 440, "additions": 168, "deletions": 272}, "files": [{"sha": "41ae0f2d5e203ca1c89dce2f0eda33e35f3a9353", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2de64ef30577971dc80dfa38145d807aad72a264/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de64ef30577971dc80dfa38145d807aad72a264/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=2de64ef30577971dc80dfa38145d807aad72a264", "patch": "@@ -436,23 +436,29 @@ pub mod reader {\n         }\n     }\n \n-    pub fn tagged_docs<F>(d: Doc, tg: usize, mut it: F) -> bool where\n-        F: FnMut(Doc) -> bool,\n-    {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = try_or!(tag_at(d.data, pos), false);\n-            let elt_size = try_or!(tag_len_at(d.data, elt_tag), false);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                let doc = Doc { data: d.data, start: elt_size.next,\n-                                end: pos };\n-                if !it(doc) {\n-                    return false;\n+    pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n+        TaggedDocsIterator {\n+            iter: docs(d),\n+            tag: tag,\n+        }\n+    }\n+\n+    pub struct TaggedDocsIterator<'a> {\n+        iter: DocsIterator<'a>,\n+        tag: usize,\n+    }\n+\n+    impl<'a> Iterator for TaggedDocsIterator<'a> {\n+        type Item = Doc<'a>;\n+\n+        fn next(&mut self) -> Option<Doc<'a>> {\n+            while let Some((tag, doc)) = self.iter.next() {\n+                if tag == self.tag {\n+                    return Some(doc);\n                 }\n             }\n+            None\n         }\n-        return true;\n     }\n \n     pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where"}, {"sha": "30886c84fd4400aef79c6e8b026fa12c91977b6f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 148, "deletions": 258, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/2de64ef30577971dc80dfa38145d807aad72a264/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de64ef30577971dc80dfa38145d807aad72a264/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2de64ef30577971dc80dfa38145d807aad72a264", "patch": "@@ -76,19 +76,12 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let pos = u32_from_be_bytes(&d.data[hash_pos..]) as usize;\n     let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n \n-    let belt = tag_index_buckets_bucket_elt;\n-\n-    let mut ret = None;\n-    reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n+    reader::tagged_docs(tagged_doc.doc, tag_index_buckets_bucket_elt).find(|elt| {\n+        eq_fn(&elt.data[elt.start + 4 .. elt.end])\n+    }).map(|elt| {\n         let pos = u32_from_be_bytes(&elt.data[elt.start..]) as usize;\n-        if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n-            ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n-            false\n-        } else {\n-            true\n-        }\n-    });\n-    ret\n+        reader::doc_at(d.data, pos).unwrap().doc\n+    })\n }\n \n pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n@@ -191,12 +184,9 @@ fn fn_constness(item: rbml::Doc) -> ast::Constness {\n }\n \n fn item_sort(item: rbml::Doc) -> Option<char> {\n-    let mut ret = None;\n-    reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n-        ret = Some(doc.as_str_slice().as_bytes()[0] as char);\n-        false\n-    });\n-    ret\n+    reader::tagged_docs(item, tag_item_trait_item_sort).nth(0).map(|doc| {\n+        doc.as_str_slice().as_bytes()[0] as char\n+    })\n }\n \n fn item_symbol(item: rbml::Doc) -> String {\n@@ -210,12 +200,9 @@ fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n }\n \n fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<ast::DefId> {\n-    let mut ret = None;\n-    reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n-        ret = Some(translated_def_id(cdata, did));\n-        false\n-    });\n-    ret\n+    reader::tagged_docs(d, tag_items_data_parent_item).nth(0).map(|did| {\n+        translated_def_id(cdata, did)\n+    })\n }\n \n fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n@@ -232,10 +219,8 @@ fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     })\n }\n \n-fn each_reexport<F>(d: rbml::Doc, f: F) -> bool where\n-    F: FnMut(rbml::Doc) -> bool,\n-{\n-    reader::tagged_docs(d, tag_items_data_item_reexport, f)\n+fn reexports<'a>(d: rbml::Doc<'a>) -> reader::TaggedDocsIterator<'a> {\n+    reader::tagged_docs(d, tag_items_data_item_reexport)\n }\n \n fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n@@ -284,12 +269,9 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n }\n \n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n-    let mut ids = vec![];\n-    reader::tagged_docs(item, tag_items_data_item_variant, |p| {\n-        ids.push(translated_def_id(cdata, p));\n-        true\n-    });\n-    ids\n+    reader::tagged_docs(item, tag_items_data_item_variant)\n+        .map(|p| translated_def_id(cdata, p))\n+        .collect()\n }\n \n fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n@@ -406,13 +388,9 @@ fn parse_polarity(item_doc: rbml::Doc) -> ast::ImplPolarity {\n \n fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n     let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n-    let mut names = Vec::new();\n-    reader::tagged_docs(names_doc, tag_associated_type_name, |name_doc| {\n-        let name = token::intern(name_doc.as_str_slice());\n-        names.push(name);\n-        true\n-    });\n-    names\n+    reader::tagged_docs(names_doc, tag_associated_type_name)\n+        .map(|name_doc| token::intern(name_doc.as_str_slice()))\n+        .collect()\n }\n \n pub fn get_trait_def<'tcx>(cdata: Cmd,\n@@ -546,7 +524,7 @@ pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n {\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n-    reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n+    reader::tagged_docs(lang_items, tag_lang_items_item).all(|item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n         let id = reader::doc_as_u32(id_doc) as usize;\n         let node_id_doc = reader::get_doc(item_doc,\n@@ -566,7 +544,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n-    let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n+    for child_info_doc in reader::tagged_docs(item_doc, tag_mod_child) {\n         let child_def_id = translated_def_id(cdata, child_info_doc);\n \n         // This item may be in yet another crate if it was the child of a\n@@ -592,26 +570,20 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                 let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n                 let visibility = item_visibility(child_item_doc);\n                 callback(def_like, child_name, visibility);\n-\n             }\n         }\n-\n-        true\n-    });\n+    }\n \n     // As a special case, iterate over all static methods of\n     // associated implementations too. This is a bit of a botch.\n     // --pcwalton\n-    let _ = reader::tagged_docs(item_doc,\n-                                tag_items_data_item_inherent_impl,\n-                                |inherent_impl_def_id_doc| {\n-        let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n-                                               cdata);\n+    for inherent_impl_def_id_doc in reader::tagged_docs(item_doc,\n+                                                             tag_items_data_item_inherent_impl) {\n+        let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc, cdata);\n         let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n         if let Some(inherent_impl_doc) = maybe_find_item(inherent_impl_def_id.node, items) {\n-            let _ = reader::tagged_docs(inherent_impl_doc,\n-                                        tag_item_impl_item,\n-                                        |impl_item_def_id_doc| {\n+            for impl_item_def_id_doc in reader::tagged_docs(inherent_impl_doc,\n+                                                                 tag_item_impl_item) {\n                 let impl_item_def_id = item_def_id(impl_item_def_id_doc,\n                                                    cdata);\n                 if let Some(impl_method_doc) = maybe_find_item(impl_item_def_id.node, items) {\n@@ -625,14 +597,11 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                  item_visibility(impl_method_doc));\n                     }\n                 }\n-                true\n-            });\n+            }\n         }\n-        true\n-    });\n+    }\n \n-    // Iterate over all reexports.\n-    let _ = each_reexport(item_doc, |reexport_doc| {\n+    for reexport_doc in reexports(item_doc) {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n         let child_def_id = translated_def_id(cdata, def_id_doc);\n@@ -662,9 +631,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             // a public re-export.\n             callback(def_like, token::intern(name), ast::Public);\n         }\n-\n-        true\n-    });\n+    }\n }\n \n /// Iterates over each child of the given item.\n@@ -841,22 +808,15 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n /// Returns the def IDs of all the items in the given implementation.\n pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n                       -> Vec<ty::ImplOrTraitItemId> {\n-    let mut impl_items = Vec::new();\n-    reader::tagged_docs(lookup_item(impl_id, cdata.data()),\n-                        tag_item_impl_item, |doc| {\n+    reader::tagged_docs(lookup_item(impl_id, cdata.data()), tag_item_impl_item).map(|doc| {\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n-            Some('C') => impl_items.push(ty::ConstTraitItemId(def_id)),\n-            Some('r') | Some('p') => {\n-                impl_items.push(ty::MethodTraitItemId(def_id))\n-            }\n-            Some('t') => impl_items.push(ty::TypeTraitItemId(def_id)),\n+            Some('C') => ty::ConstTraitItemId(def_id),\n+            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n+            Some('t') => ty::TypeTraitItemId(def_id),\n             _ => panic!(\"unknown impl item sort\"),\n         }\n-        true\n-    });\n-\n-    impl_items\n+    }).collect()\n }\n \n pub fn get_trait_name(intr: Rc<IdentInterner>,\n@@ -944,20 +904,15 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n                               -> Vec<ty::ImplOrTraitItemId> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = Vec::new();\n-    reader::tagged_docs(item, tag_item_trait_item, |mth| {\n+    reader::tagged_docs(item, tag_item_trait_item).map(|mth| {\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n-            Some('C') => result.push(ty::ConstTraitItemId(def_id)),\n-            Some('r') | Some('p') => {\n-                result.push(ty::MethodTraitItemId(def_id));\n-            }\n-            Some('t') => result.push(ty::TypeTraitItemId(def_id)),\n+            Some('C') => ty::ConstTraitItemId(def_id),\n+            Some('r') | Some('p') => ty::MethodTraitItemId(def_id),\n+            Some('t') => ty::TypeTraitItemId(def_id),\n             _ => panic!(\"unknown trait item sort\"),\n         }\n-        true\n-    });\n-    result\n+    }).collect()\n }\n \n pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n@@ -975,9 +930,8 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                         -> Vec<Rc<ty::Method<'tcx>>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = Vec::new();\n \n-    reader::tagged_docs(item, tag_item_trait_item, |mth_id| {\n+    reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n         let did = item_def_id(mth_id, cdata);\n         let mth = lookup_item(did.node, data);\n \n@@ -987,13 +941,14 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n                                                     did.node,\n                                                     tcx);\n             if let ty::MethodTraitItem(ref method) = trait_item {\n-                result.push((*method).clone())\n+                Some((*method).clone())\n+            } else {\n+                None\n             }\n+        } else {\n+            None\n         }\n-        true\n-    });\n-\n-    return result;\n+    }).collect()\n }\n \n pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n@@ -1003,10 +958,9 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                    -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = Vec::new();\n \n-    for &tag in &[tag_item_trait_item, tag_item_impl_item] {\n-        reader::tagged_docs(item, tag, |ac_id| {\n+    [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n+        reader::tagged_docs(item, tag).filter_map(|ac_id| {\n             let did = item_def_id(ac_id, cdata);\n             let ac_doc = lookup_item(did.node, data);\n \n@@ -1016,14 +970,15 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n                                                         did.node,\n                                                         tcx);\n                 if let ty::ConstTraitItem(ref ac) = trait_item {\n-                    result.push((*ac).clone())\n+                    Some((*ac).clone())\n+                } else {\n+                    None\n                 }\n+            } else {\n+                None\n             }\n-            true\n-        });\n-    }\n-\n-    return result;\n+        })\n+    }).collect()\n }\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n@@ -1033,13 +988,9 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n         return None;\n     }\n \n-    let mut ret = None;\n-    reader::tagged_docs(item, tag_item_impl_type_basename, |doc| {\n-        ret = Some(token::intern(doc.as_str_slice()));\n-        false\n-    });\n-\n-    ret\n+    reader::tagged_docs(item, tag_item_impl_type_basename).nth(0).map(|doc| {\n+        token::intern(doc.as_str_slice())\n+    })\n }\n \n pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n@@ -1052,20 +1003,15 @@ pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n     }\n \n     // If this impl implements a trait, don't consider it.\n-    let ret = reader::tagged_docs(item, tag_item_trait_ref, |_doc| {\n-        false\n-    });\n-\n-    if !ret { return None }\n+    if reader::tagged_docs(item, tag_item_trait_ref).next().is_some() {\n+        return None;\n+    }\n \n-    let mut impl_method_ids = Vec::new();\n-    reader::tagged_docs(item, tag_item_impl_item, |impl_method_doc| {\n-        impl_method_ids.push(item_def_id(impl_method_doc, cdata));\n-        true\n-    });\n+    let impl_method_ids = reader::tagged_docs(item, tag_item_impl_item)\n+        .map(|impl_method_doc| item_def_id(impl_method_doc, cdata));\n \n     let mut impl_methods = Vec::new();\n-    for impl_method_id in &impl_method_ids {\n+    for impl_method_id in impl_method_ids {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n         match family {\n@@ -1090,12 +1036,9 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     -> Option<ast::DefId>\n {\n     let item = lookup_item(node_id, cdata.data());\n-    let mut ret = None;\n-    reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n-        ret = Some(item_require_parent_item(cdata, item));\n-        false\n-    });\n-    ret\n+    reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor).next().map(|_| {\n+        item_require_parent_item(cdata, item)\n+    })\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n@@ -1113,14 +1056,11 @@ pub fn get_item_attrs(cdata: Cmd,\n pub fn get_struct_field_attrs(cdata: Cmd) -> HashMap<ast::NodeId, Vec<ast::Attribute>> {\n     let data = rbml::Doc::new(cdata.data());\n     let fields = reader::get_doc(data, tag_struct_fields);\n-    let mut map = HashMap::new();\n-    reader::tagged_docs(fields, tag_struct_field, |field| {\n+    reader::tagged_docs(fields, tag_struct_field).map(|field| {\n         let id = reader::doc_as_u32(reader::get_doc(field, tag_struct_field_id));\n         let attrs = get_attributes(field);\n-        map.insert(id, attrs);\n-        true\n-    });\n-    map\n+        (id, attrs)\n+    }).collect()\n }\n \n fn struct_field_family_to_visibility(family: Family) -> ast::Visibility {\n@@ -1135,81 +1075,69 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n     -> Vec<ty::field_ty> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n-    let mut result = Vec::new();\n-    reader::tagged_docs(item, tag_item_field, |an_item| {\n+    reader::tagged_docs(item, tag_item_field).filter_map(|an_item| {\n         let f = item_family(an_item);\n         if f == PublicField || f == InheritedField {\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n             let origin_id =  translated_def_id(cdata, tagdoc);\n-            result.push(ty::field_ty {\n+            Some(ty::field_ty {\n                 name: name,\n                 id: did,\n                 vis: struct_field_family_to_visibility(f),\n                 origin: origin_id,\n-            });\n+            })\n+        } else {\n+            None\n         }\n-        true\n-    });\n-    reader::tagged_docs(item, tag_item_unnamed_field, |an_item| {\n+    }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|an_item| {\n         let did = item_def_id(an_item, cdata);\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n         let origin_id =  translated_def_id(cdata, tagdoc);\n-        result.push(ty::field_ty {\n+        ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n             vis: struct_field_family_to_visibility(f),\n             origin: origin_id,\n-        });\n-        true\n-    });\n-    result\n+        }\n+    })).collect()\n }\n \n fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n-    let mut items: Vec<P<ast::MetaItem>> = Vec::new();\n-    reader::tagged_docs(md, tag_meta_item_word, |meta_item_doc| {\n+    reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n-        items.push(attr::mk_word_item(n));\n-        true\n-    });\n-    reader::tagged_docs(md, tag_meta_item_name_value, |meta_item_doc| {\n+        attr::mk_word_item(n)\n+    }).chain(reader::tagged_docs(md, tag_meta_item_name_value).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let v = token::intern_and_get_ident(vd.as_str_slice());\n         // FIXME (#623): Should be able to decode MetaNameValue variants,\n         // but currently the encoder just drops them\n-        items.push(attr::mk_name_value_item_str(n, v));\n-        true\n-    });\n-    reader::tagged_docs(md, tag_meta_item_list, |meta_item_doc| {\n+        attr::mk_name_value_item_str(n, v)\n+    })).chain(reader::tagged_docs(md, tag_meta_item_list).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let n = token::intern_and_get_ident(nd.as_str_slice());\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(n, subitems.into_iter().collect()));\n-        true\n-    });\n-    return items;\n+        attr::mk_list_item(n, subitems)\n+    })).collect()\n }\n \n fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n-    let mut attrs: Vec<ast::Attribute> = Vec::new();\n     match reader::maybe_get_doc(md, tag_attributes) {\n-      Some(attrs_d) => {\n-        reader::tagged_docs(attrs_d, tag_attribute, |attr_doc| {\n-            let is_sugared_doc = reader::doc_as_u8(\n-                reader::get_doc(attr_doc, tag_attribute_is_sugared_doc)\n-            ) == 1;\n-            let meta_items = get_meta_items(attr_doc);\n-            // Currently it's only possible to have a single meta item on\n-            // an attribute\n-            assert_eq!(meta_items.len(), 1);\n-            let meta_item = meta_items.into_iter().nth(0).unwrap();\n-            attrs.push(\n+        Some(attrs_d) => {\n+            reader::tagged_docs(attrs_d, tag_attribute).map(|attr_doc| {\n+                let is_sugared_doc = reader::doc_as_u8(\n+                    reader::get_doc(attr_doc, tag_attribute_is_sugared_doc)\n+                ) == 1;\n+                let meta_items = get_meta_items(attr_doc);\n+                // Currently it's only possible to have a single meta item on\n+                // an attribute\n+                assert_eq!(meta_items.len(), 1);\n+                let meta_item = meta_items.into_iter().nth(0).unwrap();\n                 codemap::Spanned {\n                     node: ast::Attribute_ {\n                         id: attr::mk_attr_id(),\n@@ -1218,13 +1146,11 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n                         is_sugared_doc: is_sugared_doc,\n                     },\n                     span: codemap::DUMMY_SP\n-                });\n-            true\n-        });\n-      }\n-      None => ()\n+                }\n+            }).collect()\n+        },\n+        None => vec![],\n     }\n-    return attrs;\n }\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n@@ -1251,26 +1177,23 @@ pub struct CrateDep {\n }\n \n pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n-    let mut deps: Vec<CrateDep> = Vec::new();\n     let cratedoc = rbml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n-    let mut crate_num = 1;\n+\n     fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_string()\n     }\n-    reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n+\n+    reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n         let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n-        deps.push(CrateDep {\n-            cnum: crate_num,\n+        CrateDep {\n+            cnum: crate_num as u32 + 1,\n             name: name,\n             hash: hash,\n-        });\n-        crate_num += 1;\n-        true\n-    });\n-    return deps;\n+        }\n+    }).collect()\n }\n \n fn list_crate_deps(data: &[u8], out: &mut io::Write) -> io::Result<()> {\n@@ -1362,14 +1285,11 @@ pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n     where F: FnMut(ast::DefId),\n {\n     let item_doc = lookup_item(id, cdata.data());\n-    reader::tagged_docs(item_doc,\n-                        tag_items_data_item_inherent_impl,\n-                        |impl_doc| {\n+    for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl) {\n         if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n             callback(item_def_id(impl_doc, cdata));\n         }\n-        true\n-    });\n+    }\n }\n \n pub fn each_implementation_for_trait<F>(cdata: Cmd,\n@@ -1379,12 +1299,9 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n {\n     if cdata.cnum == def_id.krate {\n         let item_doc = lookup_item(def_id.node, cdata.data());\n-        let _ = reader::tagged_docs(item_doc,\n-                                    tag_items_data_item_extension_impl,\n-                                    |impl_doc| {\n+        for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n             callback(item_def_id(impl_doc, cdata));\n-            true\n-        });\n+        }\n         return;\n     }\n \n@@ -1394,13 +1311,12 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n         let def_id_u64 = def_to_u64(crate_local_did);\n \n         let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-        let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n+        for impl_doc in reader::tagged_docs(impls_doc, tag_impls_impl) {\n             let impl_trait = reader::get_doc(impl_doc, tag_impls_impl_trait_def_id);\n             if reader::doc_as_u64(impl_trait) == def_id_u64 {\n                 callback(item_def_id(impl_doc, cdata));\n             }\n-            true\n-        });\n+        }\n     }\n }\n \n@@ -1427,17 +1343,14 @@ pub fn get_native_libraries(cdata: Cmd)\n                             -> Vec<(cstore::NativeLibraryKind, String)> {\n     let libraries = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                     tag_native_libraries);\n-    let mut result = Vec::new();\n-    reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n+    reader::tagged_docs(libraries, tag_native_libraries_lib).map(|lib_doc| {\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);\n         let name_doc = reader::get_doc(lib_doc, tag_native_libraries_name);\n         let kind: cstore::NativeLibraryKind =\n             cstore::NativeLibraryKind::from_u32(reader::doc_as_u32(kind_doc)).unwrap();\n         let name = name_doc.as_str().to_string();\n-        result.push((kind, name));\n-        true\n-    });\n-    return result;\n+        (kind, name)\n+    }).collect()\n }\n \n pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n@@ -1449,12 +1362,14 @@ pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n     F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n {\n     let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n-    reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n+    for macro_doc in reader::tagged_docs(macros, tag_macro_def) {\n         let name = item_name(intr, macro_doc);\n         let attrs = get_attributes(macro_doc);\n         let body = reader::get_doc(macro_doc, tag_macro_def_body);\n-        f(name, attrs, body.as_str().to_string())\n-    });\n+        if !f(name, attrs, body.as_str().to_string()) {\n+            break;\n+        }\n+    }\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)\n@@ -1487,43 +1402,32 @@ pub fn get_missing_lang_items(cdata: Cmd)\n     -> Vec<lang_items::LangItem>\n {\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_lang_items);\n-    let mut result = Vec::new();\n-    reader::tagged_docs(items, tag_lang_items_missing, |missing_docs| {\n-        let item: lang_items::LangItem =\n-            lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap();\n-        result.push(item);\n-        true\n-    });\n-    return result;\n+    reader::tagged_docs(items, tag_lang_items_missing).map(|missing_docs| {\n+        lang_items::LangItem::from_u32(reader::doc_as_u32(missing_docs)).unwrap()\n+    }).collect()\n }\n \n pub fn get_method_arg_names(cdata: Cmd, id: ast::NodeId) -> Vec<String> {\n-    let mut ret = Vec::new();\n     let method_doc = lookup_item(id, cdata.data());\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n-            reader::tagged_docs(args_doc, tag_method_argument_name, |name_doc| {\n-                ret.push(name_doc.as_str_slice().to_string());\n-                true\n-            });\n-        }\n-        None => {}\n+            reader::tagged_docs(args_doc, tag_method_argument_name).map(|name_doc| {\n+                name_doc.as_str_slice().to_string()\n+            }).collect()\n+        },\n+        None => vec![],\n     }\n-    return ret;\n }\n \n pub fn get_reachable_extern_fns(cdata: Cmd) -> Vec<ast::DefId> {\n-    let mut ret = Vec::new();\n     let items = reader::get_doc(rbml::Doc::new(cdata.data()),\n                                 tag_reachable_extern_fns);\n-    reader::tagged_docs(items, tag_reachable_extern_fn_id, |doc| {\n-        ret.push(ast::DefId {\n+    reader::tagged_docs(items, tag_reachable_extern_fn_id).map(|doc| {\n+        ast::DefId {\n             krate: cdata.cnum,\n             node: reader::doc_as_u32(doc),\n-        });\n-        true\n-    });\n-    return ret;\n+        }\n+    }).collect()\n }\n \n pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n@@ -1559,16 +1463,15 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut types = subst::VecPerParamSpace::empty();\n-    reader::tagged_docs(doc, tag_type_param_def, |p| {\n+    for p in reader::tagged_docs(doc, tag_type_param_def) {\n         let bd = parse_type_param_def_data(\n             p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         types.push(bd.space, bd);\n-        true\n-    });\n+    }\n \n     let mut regions = subst::VecPerParamSpace::empty();\n-    reader::tagged_docs(doc, tag_region_param_def, |rp_doc| {\n+    for rp_doc in reader::tagged_docs(doc, tag_region_param_def) {\n         let ident_str_doc = reader::get_doc(rp_doc,\n                                             tag_region_param_def_ident);\n         let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n@@ -1582,23 +1485,17 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n         let index = reader::doc_as_u64(doc) as u32;\n \n-        let mut bounds = Vec::new();\n-        reader::tagged_docs(rp_doc, tag_items_data_region, |p| {\n-            bounds.push(\n-                parse_region_data(\n-                    p.data, cdata.cnum, p.start, tcx,\n-                    |_, did| translate_def_id(cdata, did)));\n-            true\n-        });\n+        let bounds = reader::tagged_docs(rp_doc, tag_items_data_region).map(|p| {\n+            parse_region_data(p.data, cdata.cnum, p.start, tcx,\n+                              |_, did| translate_def_id(cdata, did))\n+        }).collect();\n \n         regions.push(space, ty::RegionParameterDef { name: name,\n                                                      def_id: def_id,\n                                                      space: space,\n                                                      index: index,\n                                                      bounds: bounds });\n-\n-        true\n-    });\n+    }\n \n     ty::Generics { types: types, regions: regions }\n }\n@@ -1612,7 +1509,7 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut predicates = subst::VecPerParamSpace::empty();\n-    reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n+    for predicate_doc in reader::tagged_docs(doc, tag_predicate) {\n         let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n \n@@ -1621,8 +1518,7 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n                                         |_, did| translate_def_id(cdata, did));\n \n         predicates.push(space, data);\n-        true\n-    });\n+    }\n \n     ty::GenericPredicates { predicates: predicates }\n }\n@@ -1643,14 +1539,8 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n     let crate_doc = rbml::Doc::new(metadata);\n     let cm_doc = reader::get_doc(crate_doc, tag_codemap);\n \n-    let mut filemaps = vec![];\n-\n-    reader::tagged_docs(cm_doc, tag_codemap_filemap, |filemap_doc| {\n+    reader::tagged_docs(cm_doc, tag_codemap_filemap).map(|filemap_doc| {\n         let mut decoder = reader::Decoder::new(filemap_doc);\n-        let filemap: codemap::FileMap = Decodable::decode(&mut decoder).unwrap();\n-        filemaps.push(filemap);\n-        true\n-    });\n-\n-    return filemaps;\n+        Decodable::decode(&mut decoder).unwrap()\n+    }).collect()\n }"}]}