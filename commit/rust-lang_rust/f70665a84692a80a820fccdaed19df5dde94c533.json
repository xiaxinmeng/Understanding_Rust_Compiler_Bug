{"sha": "f70665a84692a80a820fccdaed19df5dde94c533", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MDY2NWE4NDY5MmE4MGE4MjBmY2NkYWVkMTlkZjVkZGU5NGM1MzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-23T20:28:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-23T20:28:14Z"}, "message": "cleanup librustc_errors Handler code.", "tree": {"sha": "09f66d7a618998f9799ca5a0892190de59de8c24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09f66d7a618998f9799ca5a0892190de59de8c24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f70665a84692a80a820fccdaed19df5dde94c533", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f70665a84692a80a820fccdaed19df5dde94c533", "html_url": "https://github.com/rust-lang/rust/commit/f70665a84692a80a820fccdaed19df5dde94c533", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f70665a84692a80a820fccdaed19df5dde94c533/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62fc4d36dfeedbf0795f36a8d08c39e0f4e41632", "url": "https://api.github.com/repos/rust-lang/rust/commits/62fc4d36dfeedbf0795f36a8d08c39e0f4e41632", "html_url": "https://github.com/rust-lang/rust/commit/62fc4d36dfeedbf0795f36a8d08c39e0f4e41632"}], "stats": {"total": 313, "additions": 170, "deletions": 143}, "files": [{"sha": "c01dcd94c725e449e7ee87de5444866e19d762a5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 166, "deletions": 135, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=f70665a84692a80a820fccdaed19df5dde94c533", "patch": "@@ -302,6 +302,9 @@ pub struct Handler {\n     inner: Lock<HandlerInner>,\n }\n \n+/// This inner struct exists to keep it all behind a single lock;\n+/// this is done to prevent possible deadlocks in a multi-threaded compiler,\n+/// as well as inconsistent state observation.\n struct HandlerInner {\n     flags: HandlerFlags,\n     /// The number of errors that have been emitted, including duplicates.\n@@ -382,52 +385,65 @@ impl Drop for HandlerInner {\n }\n \n impl Handler {\n-    pub fn with_tty_emitter(color_config: ColorConfig,\n-                            can_emit_warnings: bool,\n-                            treat_err_as_bug: Option<usize>,\n-                            cm: Option<Lrc<SourceMapperDyn>>)\n-                            -> Handler {\n-        Handler::with_tty_emitter_and_flags(\n+    pub fn with_tty_emitter(\n+        color_config: ColorConfig,\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+    ) -> Self {\n+        Self::with_tty_emitter_and_flags(\n             color_config,\n             cm,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_tty_emitter_and_flags(color_config: ColorConfig,\n-                                      cm: Option<Lrc<SourceMapperDyn>>,\n-                                      flags: HandlerFlags)\n-                                      -> Handler {\n+    pub fn with_tty_emitter_and_flags(\n+        color_config: ColorConfig,\n+        cm: Option<Lrc<SourceMapperDyn>>,\n+        flags: HandlerFlags,\n+    ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n-            color_config, cm, false, false, None, flags.external_macro_backtrace));\n-        Handler::with_emitter_and_flags(emitter, flags)\n-    }\n-\n-    pub fn with_emitter(can_emit_warnings: bool,\n-                        treat_err_as_bug: Option<usize>,\n-                        e: Box<dyn Emitter + sync::Send>)\n-                        -> Handler {\n+            color_config,\n+            cm,\n+            false,\n+            false,\n+            None,\n+            flags.external_macro_backtrace,\n+        ));\n+        Self::with_emitter_and_flags(emitter, flags)\n+    }\n+\n+    pub fn with_emitter(\n+        can_emit_warnings: bool,\n+        treat_err_as_bug: Option<usize>,\n+        emitter: Box<dyn Emitter + sync::Send>,\n+    ) -> Self {\n         Handler::with_emitter_and_flags(\n-            e,\n+            emitter,\n             HandlerFlags {\n                 can_emit_warnings,\n                 treat_err_as_bug,\n                 .. Default::default()\n-            })\n+            },\n+        )\n     }\n \n-    pub fn with_emitter_and_flags(e: Box<dyn Emitter + sync::Send>, flags: HandlerFlags) -> Handler\n-    {\n-        Handler {\n+    pub fn with_emitter_and_flags(\n+        emitter: Box<dyn Emitter + sync::Send>,\n+        flags: HandlerFlags\n+    ) -> Self {\n+        Self {\n             flags,\n             inner: Lock::new(HandlerInner {\n                 flags,\n                 err_count: 0,\n                 deduplicated_err_count: 0,\n-                emitter: e,\n+                emitter,\n                 continue_after_error: true,\n                 delayed_span_bugs: Vec::new(),\n                 taught_diagnostics: Default::default(),\n@@ -474,7 +490,8 @@ impl Handler {\n                 \"{}:{}: already existing stashed diagnostic with (span = {:?}, key = {:?})\",\n                 file!(), line!(), span, key\n             ));\n-            inner.emit_explicit_bug(&old_diag);\n+            inner.emit_diag_at_span(old_diag, span);\n+            panic!(ExplicitBug);\n         }\n     }\n \n@@ -492,171 +509,177 @@ impl Handler {\n         self.inner.borrow_mut().emit_stashed_diagnostics();\n     }\n \n+    /// Construct a dummy builder with `Level::Cancelled`.\n+    ///\n+    /// Using this will neither report anything to the user (e.g. a warning),\n+    /// nor will compilation cancel as a result.\n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Cancelled, \"\")\n     }\n \n-    pub fn struct_span_warn<S: Into<MultiSpan>>(&self,\n-                                                sp: S,\n-                                                msg: &str)\n-                                                -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    pub fn struct_span_warn(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_warn(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(&self,\n-                                                          sp: S,\n-                                                          msg: &str,\n-                                                          code: DiagnosticId)\n-                                                          -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Warning` level at the given `span` and with the `msg`.\n+    /// Also include a code.\n+    pub fn struct_span_warn_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_warn(span, msg);\n         result.code(code);\n-        if !self.flags.can_emit_warnings {\n-            result.cancel();\n-        }\n         result\n     }\n+\n+    /// Construct a builder at the `Warning` level with the `msg`.\n     pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut result = DiagnosticBuilder::new(self, Level::Warning, msg);\n         if !self.flags.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n+    pub fn struct_span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Error` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_err_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_err(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n     pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Error, msg)\n     }\n-    pub fn struct_err_with_code(\n-        &self,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n+\n+    /// Construct a builder at the `Error` level with the `msg` and the `code`.\n+    pub fn struct_err_with_code(&self, msg: &str, code: DiagnosticId) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_err(msg);\n         result.code(code);\n         result\n     }\n-    pub fn struct_span_fatal<S: Into<MultiSpan>>(&self,\n-                                                 sp: S,\n-                                                 msg: &str)\n-                                                 -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span` and with the `msg`.\n+    pub fn struct_span_fatal(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_fatal(msg);\n+        result.set_span(span);\n         result\n     }\n-    pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                           sp: S,\n-                                                           msg: &str,\n-                                                           code: DiagnosticId)\n-                                                           -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Fatal, msg);\n-        result.set_span(sp);\n+\n+    /// Construct a builder at the `Fatal` level at the given `span`, with the `msg`, and `code`.\n+    pub fn struct_span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> DiagnosticBuilder<'_> {\n+        let mut result = self.struct_span_fatal(span, msg);\n         result.code(code);\n         result\n     }\n+\n+    /// Construct a builder at the `Error` level with the `msg`.\n     pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new(Fatal, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n-                                                    sp: S,\n-                                                    msg: &str,\n-                                                    code: DiagnosticId)\n-                                                    -> FatalError {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Fatal, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_fatal_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: &str,\n+        code: DiagnosticId,\n+    ) -> FatalError {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n         FatalError\n     }\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Error, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n-    }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self,\n-                                            sp: S,\n-                                            msg: &str)\n-                                            -> DiagnosticBuilder<'_> {\n-        let mut result = DiagnosticBuilder::new(self, Level::Error, msg);\n-        result.set_span(sp);\n-        result\n+\n+    pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Error, msg), span);\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Error, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_err_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Error, Some(code), msg), span);\n     }\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Warning, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Warning, msg), span);\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_diagnostic(Diagnostic::new_with_code(Warning, Some(code), msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_warn_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+        self.emit_diag_at_span(Diagnostic::new_with_code(Warning, Some(code), msg), span);\n     }\n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.inner.borrow_mut().span_bug(sp, msg)\n+\n+    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.inner.borrow_mut().span_bug(span, msg)\n     }\n-    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.inner.borrow_mut().delay_span_bug(sp, msg)\n+\n+    pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n-    pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit_diagnostic(Diagnostic::new(Note, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n+\n+    pub fn span_note_without_error(&self, span: impl Into<MultiSpan>, msg: &str) {\n+        self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n-    pub fn span_note_diag(&self,\n-                          sp: Span,\n-                          msg: &str)\n-                          -> DiagnosticBuilder<'_> {\n+\n+    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.set_span(sp);\n+        db.set_span(span);\n         db\n     }\n+\n     pub fn failure(&self, msg: &str) {\n         self.inner.borrow_mut().failure(msg);\n     }\n+\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n+\n     pub fn err(&self, msg: &str) {\n         self.inner.borrow_mut().err(msg);\n     }\n+\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n+\n     pub fn note_without_error(&self, msg: &str) {\n-        let mut db = DiagnosticBuilder::new(self, Note, msg);\n-        db.emit();\n+        DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n+\n     pub fn bug(&self, msg: &str) -> ! {\n         self.inner.borrow_mut().bug(msg)\n     }\n@@ -698,6 +721,12 @@ impl Handler {\n         self.inner.borrow_mut().emit_diagnostic(diagnostic)\n     }\n \n+    fn emit_diag_at_span(&self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        let mut inner = self.inner.borrow_mut();\n+        inner.emit_diagnostic(diag.set_span(sp));\n+        inner.abort_if_errors_and_should_abort();\n+    }\n+\n     pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n         self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n     }\n@@ -837,17 +866,17 @@ impl HandlerInner {\n         }\n     }\n \n-    fn span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> ! {\n-        self.emit_explicit_bug(Diagnostic::new(Bug, msg).set_span(sp));\n+    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ! {\n+        self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n+        panic!(ExplicitBug);\n     }\n \n-    fn emit_explicit_bug(&mut self, diag: &Diagnostic) -> ! {\n-        self.emit_diagnostic(diag);\n+    fn emit_diag_at_span(&mut self, mut diag: Diagnostic, sp: impl Into<MultiSpan>) {\n+        self.emit_diagnostic(diag.set_span(sp));\n         self.abort_if_errors_and_should_abort();\n-        panic!(ExplicitBug);\n     }\n \n-    fn delay_span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) {\n+    fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) {\n         if self.treat_err_as_bug() {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n@@ -862,18 +891,20 @@ impl HandlerInner {\n     }\n \n     fn fatal(&mut self, msg: &str) -> FatalError {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        self.emit_diagnostic(&Diagnostic::new(Fatal, msg));\n+        self.emit_error(Fatal, msg);\n         FatalError\n     }\n \n     fn err(&mut self, msg: &str) {\n+        self.emit_error(Error, msg);\n+    }\n+\n+    /// Emit an error; level should be `Error` or `Fatal`.\n+    fn emit_error(&mut self, level: Level, msg: &str,) {\n         if self.treat_err_as_bug() {\n             self.bug(msg);\n         }\n-        self.emit_diagnostic(&Diagnostic::new(Error, msg));\n+        self.emit_diagnostic(&Diagnostic::new(level, msg));\n     }\n \n     fn bug(&mut self, msg: &str) -> ! {"}, {"sha": "f7e766bb84d5740197ae84d16b64effcc475a877", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f70665a84692a80a820fccdaed19df5dde94c533", "patch": "@@ -832,7 +832,7 @@ fn check_method_receiver<'fcx, 'tcx>(\n }\n \n fn e0307(fcx: &FnCtxt<'fcx, 'tcx>, span: Span, receiver_ty: Ty<'_>) {\n-    fcx.tcx.sess.diagnostic().mut_span_err(\n+    fcx.tcx.sess.diagnostic().struct_span_err(\n         span,\n         &format!(\"invalid `self` parameter type: {:?}\", receiver_ty)\n     ).note(\"type of `self` must be `Self` or a type that dereferences to it\")"}, {"sha": "36d066b026933bab861a8c83f48ae0784bdbab62", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f70665a84692a80a820fccdaed19df5dde94c533", "patch": "@@ -1041,10 +1041,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n         self.parse_sess.span_diagnostic.span_err_with_code(sp, msg, code);\n     }\n-    pub fn mut_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str)\n-                        -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.mut_span_err(sp, msg)\n-    }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }"}, {"sha": "c3b1f91d5317d48db12910bd9b5136e3d420b580", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f70665a84692a80a820fccdaed19df5dde94c533", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let attr = attr::find_by_name(item.attrs(), sym::derive)\n                             .expect(\"`derive` attribute should exist\");\n                         let span = attr.span;\n-                        let mut err = self.cx.mut_span_err(span,\n+                        let mut err = self.cx.struct_span_err(span,\n                             \"`derive` may only be applied to structs, enums and unions\");\n                         if let ast::AttrStyle::Inner = attr.style {\n                             let trait_list = derives.iter()"}, {"sha": "2765346b333cf3e9fe68571574441322727955d2", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f70665a84692a80a820fccdaed19df5dde94c533/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f70665a84692a80a820fccdaed19df5dde94c533", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             .filter(|fmt| fmt.precision_span.is_some())\n             .count();\n         if self.names.is_empty() && !numbered_position_args && count != self.args.len() {\n-            e = self.ecx.mut_span_err(\n+            e = self.ecx.struct_span_err(\n                 sp,\n                 &format!(\n                     \"{} positional argument{} in format string, but {}\",\n@@ -336,7 +336,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 sp = MultiSpan::from_span(self.fmtsp);\n             }\n \n-            e = self.ecx.mut_span_err(sp,\n+            e = self.ecx.struct_span_err(sp,\n                 &format!(\"invalid reference to positional {} ({})\",\n                          arg_list,\n                          self.describe_num_args()));"}]}