{"sha": "a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NWVhNDhkMmJkM2I1NmNlNmU4NjY3ZThiZWJjNzIzNzFmMTdkZDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-11T23:19:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-11T23:56:47Z"}, "message": "libstd: refactor future, remove with(), remove ~ indirection.\n\nConflicts:\n\n\tsrc/libstd/future.rs", "tree": {"sha": "1ec99bd180198f8bbe11ef31f39fa959bcacba97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ec99bd180198f8bbe11ef31f39fa959bcacba97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "html_url": "https://github.com/rust-lang/rust/commit/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee1adb7ece94da682109707cca6cd08aacb131a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee1adb7ece94da682109707cca6cd08aacb131a", "html_url": "https://github.com/rust-lang/rust/commit/3ee1adb7ece94da682109707cca6cd08aacb131a"}], "stats": {"total": 130, "additions": 36, "deletions": 94}, "files": [{"sha": "ae4fa5f42c2c8eb88dd24a98dbd703faffe7adf3", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "patch": "@@ -283,7 +283,7 @@ pub fn future_writer_factory(\n         do task::spawn |move writer_ch| {\n             let (writer, future) = future_writer();\n             writer_ch.send(move writer);\n-            let s = future::get(&future);\n+            let s = future.get();\n             comm::send(markdown_ch, (page, s));\n         }\n         writer_po.recv()"}, {"sha": "960098c1db6268bdb3d074ca4907f18e8abe9e1b", "filename": "src/libstd/future.rs", "status": "modified", "additions": 32, "deletions": 90, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: allowing deprecated modes due to function issue.\n-// can re-forbid them after snapshot\n-#[forbid(deprecated_pattern)];\n-\n /*!\n  * A type representing values that may be computed concurrently and\n  * operations for working with them.\n@@ -44,27 +39,42 @@ impl<A> Future<A> : Drop {\n priv enum FutureState<A> {\n     Pending(fn~() -> A),\n     Evaluating,\n-    Forced(~A)\n+    Forced(A)\n }\n \n /// Methods on the `future` type\n impl<A:Copy> Future<A> {\n     fn get() -> A {\n         //! Get the value of the future\n-\n-        get(&self)\n+        *(self.get_ref())\n     }\n }\n \n impl<A> Future<A> {\n-    fn get_ref(&self) -> &self/A {\n-        get_ref(self)\n-    }\n-\n-    fn with<B>(blk: fn(&A) -> B) -> B {\n-        //! Work with the value without copying it\n \n-        with(&self, blk)\n+    pure fn get_ref(&self) -> &self/A {\n+        /*!\n+        * Executes the future's closure and then returns a borrowed\n+        * pointer to the result.  The borrowed pointer lasts as long as\n+        * the future.\n+        */\n+        unsafe {\n+            match self.state {\n+                Forced(ref mut v) => { return cast::transmute(v); }\n+                Evaluating => fail ~\"Recursive forcing of future!\",\n+                Pending(_) => {}\n+            }\n+\n+            let mut state = Evaluating;\n+            self.state <-> state;\n+            match move state {\n+                Forced(_) | Evaluating => fail ~\"Logic error.\",\n+                Pending(move f) => {\n+                    self.state = Forced(move f());\n+                    self.get_ref()\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -76,7 +86,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n      * not block.\n      */\n \n-    Future {state: Forced(~(move val))}\n+    Future {state: Forced(move val)}\n }\n \n pub fn from_port<A:Send>(port: PortOne<A>) ->\n@@ -130,76 +140,26 @@ pub fn spawn<A:Send>(blk: fn~() -> A) -> Future<A> {\n     return from_port(move port);\n }\n \n-pub fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n-    /*!\n-     * Executes the future's closure and then returns a borrowed\n-     * pointer to the result.  The borrowed pointer lasts as long as\n-     * the future.\n-     */\n-\n-    // The unsafety here is to hide the aliases from borrowck, which\n-    // would otherwise be concerned that someone might reassign\n-    // `future.state` and cause the value of the future to be freed.\n-    // But *we* know that once `future.state` is `Forced()` it will\n-    // never become \"unforced\"---so we can safely return a pointer\n-    // into the interior of the Forced() variant which will last as\n-    // long as the future itself.\n-\n-    match future.state {\n-      Forced(ref v) => { // v here has type &A, but with a shorter lifetime.\n-        return unsafe{ copy_lifetime(future, &**v) }; // ...extend it.\n-      }\n-      Evaluating => {\n-        fail ~\"Recursive forcing of future!\";\n-      }\n-      Pending(_) => {}\n-    }\n-\n-    let mut state = Evaluating;\n-    state <-> future.state;\n-    match move state {\n-      Forced(_) | Evaluating => {\n-        fail ~\"Logic error.\";\n-      }\n-      Pending(move f) => {\n-        future.state = Forced(~f());\n-        return get_ref(future);\n-      }\n-    }\n-}\n-\n-pub fn get<A:Copy>(future: &Future<A>) -> A {\n-    //! Get the value of the future\n-\n-    *get_ref(future)\n-}\n-\n-pub fn with<A,B>(future: &Future<A>, blk: fn(&A) -> B) -> B {\n-    //! Work with the value without copying it\n-\n-    blk(get_ref(future))\n-}\n-\n #[allow(non_implicitly_copyable_typarams)]\n pub mod test {\n     #[test]\n     pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n-        assert get(&f) == ~\"snail\";\n+        assert f.get() == ~\"snail\";\n     }\n \n     #[test]\n     pub fn test_from_port() {\n         let (ch, po) = oneshot::init();\n         send_one(move ch, ~\"whale\");\n         let f = from_port(move po);\n-        assert get(&f) == ~\"whale\";\n+        assert f.get() == ~\"whale\";\n     }\n \n     #[test]\n     pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n-        assert get(&f) == ~\"brail\";\n+        assert f.get() == ~\"brail\";\n     }\n \n     #[test]\n@@ -208,50 +168,32 @@ pub mod test {\n         assert f.get() == ~\"fail\";\n     }\n \n-    #[test]\n-    pub fn test_with() {\n-        let f = from_value(~\"nail\");\n-        assert with(&f, |v| copy *v) == ~\"nail\";\n-    }\n-\n     #[test]\n     pub fn test_get_ref_method() {\n         let f = from_value(22);\n         assert *f.get_ref() == 22;\n     }\n \n-    #[test]\n-    pub fn test_get_ref_fn() {\n-        let f = from_value(22);\n-        assert *get_ref(&f) == 22;\n-    }\n-\n-    #[test]\n-    pub fn test_interface_with() {\n-        let f = from_value(~\"kale\");\n-        assert f.with(|v| copy *v) == ~\"kale\";\n-    }\n-\n     #[test]\n     pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n-        assert get(&f) == ~\"bale\";\n+        assert f.get() == ~\"bale\";\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n     pub fn test_futurefail() {\n         let f = spawn(|| fail);\n-        let _x: ~str = get(&f);\n+        let _x: ~str = f.get();\n     }\n \n     #[test]\n     pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n         do task::spawn |move f, move expected| {\n-            let actual = get(&f);\n+            let actual = f.get();\n             assert actual == expected;\n         }\n     }"}, {"sha": "5e1ac20f5eb9fb0ac7b40f095384bddd1aa2fe92", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "patch": "@@ -107,7 +107,7 @@ fn main() {\n     thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(f) };\n+    for futures.each |f| { f.get() };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "e9281a0c417361f26c1d52d24ac3026d3a8576a0", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "patch": "@@ -101,7 +101,7 @@ fn main() {\n     thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(f) };\n+    for futures.each |f| { f.get() };\n \n     let stop = time::precise_time_s();\n "}, {"sha": "ff88eea598dfb0954e7249545e6be845ab94d30c", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=a55ea48d2bd3b56ce6e8667e8bebc72371f17dd8", "patch": "@@ -108,7 +108,7 @@ fn main() {\n     thread_ring(0, msg_per_task, option::unwrap(move num_chan), move num_port);\n \n     // synchronize\n-    for futures.each |f| { future::get(f) };\n+    for futures.each |f| { f.get() };\n \n     let stop = time::precise_time_s();\n "}]}