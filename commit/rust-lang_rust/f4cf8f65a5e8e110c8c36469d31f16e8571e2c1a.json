{"sha": "f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "node_id": "C_kwDOAAsO6NoAKGY0Y2Y4ZjY1YTVlOGUxMTBjOGMzNjQ2OWQzMWYxNmU4NTcxZTJjMWE", "commit": {"author": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-06-12T23:35:23Z"}, "committer": {"name": "Bryan Garza", "email": "1396101+bryangarza@users.noreply.github.com", "date": "2023-06-12T23:56:21Z"}, "message": "Safe Transmute: Refactor error handling and Answer type\n\n- Create `Answer` type that is not just a type alias of `Result`\n- Remove a usage of `map_layouts` to make the code easier to read\n- Don't hide errors related to Unknown Layout when computing transmutability", "tree": {"sha": "81d55477f266bac64272420ca537903b35a17fb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81d55477f266bac64272420ca537903b35a17fb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "html_url": "https://github.com/rust-lang/rust/commit/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/comments", "author": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bryangarza", "id": 1396101, "node_id": "MDQ6VXNlcjEzOTYxMDE=", "avatar_url": "https://avatars.githubusercontent.com/u/1396101?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bryangarza", "html_url": "https://github.com/bryangarza", "followers_url": "https://api.github.com/users/bryangarza/followers", "following_url": "https://api.github.com/users/bryangarza/following{/other_user}", "gists_url": "https://api.github.com/users/bryangarza/gists{/gist_id}", "starred_url": "https://api.github.com/users/bryangarza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bryangarza/subscriptions", "organizations_url": "https://api.github.com/users/bryangarza/orgs", "repos_url": "https://api.github.com/users/bryangarza/repos", "events_url": "https://api.github.com/users/bryangarza/events{/privacy}", "received_events_url": "https://api.github.com/users/bryangarza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64a54df86faf1f55148433753296dc2bc2a7e31d", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a54df86faf1f55148433753296dc2bc2a7e31d", "html_url": "https://github.com/rust-lang/rust/commit/64a54df86faf1f55148433753296dc2bc2a7e31d"}], "stats": {"total": 294, "additions": 167, "deletions": 127}, "files": [{"sha": "fb28faa2b7c2395602f41412f05c9f215fee3cb9", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -668,18 +668,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         scope: Ty<'tcx>,\n         assume: rustc_transmute::Assume,\n     ) -> Result<Certainty, NoSolution> {\n+        use rustc_transmute::Answer;\n         // FIXME(transmutability): This really should be returning nested goals for `Answer::If*`\n         match rustc_transmute::TransmuteTypeEnv::new(self.infcx).is_transmutable(\n             ObligationCause::dummy(),\n             src_and_dst,\n             scope,\n             assume,\n         ) {\n-            Ok(None) => Ok(Certainty::Yes),\n-            Err(_)\n-            | Ok(Some(rustc_transmute::Condition::IfTransmutable { .. }))\n-            | Ok(Some(rustc_transmute::Condition::IfAll(_)))\n-            | Ok(Some(rustc_transmute::Condition::IfAny(_))) => Err(NoSolution),\n+            Answer::Yes => Ok(Certainty::Yes),\n+            Answer::No(_) | Answer::If(_) => Err(NoSolution),\n         }\n     }\n }"}, {"sha": "36d5f3566c6ff9c206d212fde99c981beaafe17b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -65,6 +65,11 @@ pub struct ImplCandidate<'tcx> {\n     pub similarity: CandidateSimilarity,\n }\n \n+enum GetSafeTransmuteErrorAndReason {\n+    Silent,\n+    Error { err_msg: String, safe_transmute_explanation: String },\n+}\n+\n pub trait InferCtxtExt<'tcx> {\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n@@ -724,11 +729,17 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             == self.tcx.lang_items().transmute_trait()\n                         {\n                             // Recompute the safe transmute reason and use that for the error reporting\n-                            self.get_safe_transmute_error_and_reason(\n+                            match self.get_safe_transmute_error_and_reason(\n                                 obligation.clone(),\n                                 trait_ref,\n                                 span,\n-                            )\n+                            ) {\n+                                GetSafeTransmuteErrorAndReason::Silent => return,\n+                                GetSafeTransmuteErrorAndReason::Error {\n+                                    err_msg,\n+                                    safe_transmute_explanation,\n+                                } => (err_msg, Some(safe_transmute_explanation)),\n+                            }\n                         } else {\n                             (err_msg, None)\n                         };\n@@ -1292,7 +1303,7 @@ trait InferCtxtPrivExt<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n-    ) -> (String, Option<String>);\n+    ) -> GetSafeTransmuteErrorAndReason;\n \n     fn add_tuple_trait_message(\n         &self,\n@@ -2738,7 +2749,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         span: Span,\n-    ) -> (String, Option<String>) {\n+    ) -> GetSafeTransmuteErrorAndReason {\n+        use rustc_transmute::Answer;\n+\n         // Erase regions because layout code doesn't particularly care about regions.\n         let trait_ref = self.tcx.erase_regions(self.tcx.erase_late_bound_regions(trait_ref));\n \n@@ -2758,13 +2771,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             scope,\n             assume,\n         ) {\n-            Err(reason) => {\n+            Answer::No(reason) => {\n                 let dst = trait_ref.substs.type_at(0);\n                 let src = trait_ref.substs.type_at(1);\n-                let custom_err_msg = format!(\n+                let err_msg = format!(\n                     \"`{src}` cannot be safely transmuted into `{dst}` in the defining scope of `{scope}`\"\n                 );\n-                let reason_msg = match reason {\n+                let safe_transmute_explanation = match reason {\n                     rustc_transmute::Reason::SrcIsUnspecified => {\n                         format!(\"`{src}` does not have a well-specified layout\")\n                     }\n@@ -2794,11 +2807,21 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     rustc_transmute::Reason::DstIsMoreUnique => {\n                         format!(\"`{src}` is a shared reference, but `{dst}` is a unique reference\")\n                     }\n+                    // Already reported by rustc\n+                    rustc_transmute::Reason::TypeError => {\n+                        return GetSafeTransmuteErrorAndReason::Silent;\n+                    }\n+                    rustc_transmute::Reason::SrcLayoutUnknown => {\n+                        format!(\"`{src}` has an unknown layout\")\n+                    }\n+                    rustc_transmute::Reason::DstLayoutUnknown => {\n+                        format!(\"`{dst}` has an unknown layout\")\n+                    }\n                 };\n-                (custom_err_msg, Some(reason_msg))\n+                GetSafeTransmuteErrorAndReason::Error { err_msg, safe_transmute_explanation }\n             }\n             // Should never get a Yes at this point! We already ran it before, and did not get a Yes.\n-            Ok(None) => span_bug!(\n+            Answer::Yes => span_bug!(\n                 span,\n                 \"Inconsistent rustc_transmute::is_transmutable(...) result, got Yes\",\n             ),"}, {"sha": "404055e1df6c8dc0babb43a6a54afc1c6bbf50d7", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -285,28 +285,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Result<ImplSourceBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        use rustc_transmute::{Answer, Condition};\n         #[instrument(level = \"debug\", skip(tcx, obligation, predicate))]\n         fn flatten_answer_tree<'tcx>(\n             tcx: TyCtxt<'tcx>,\n             obligation: &TraitObligation<'tcx>,\n             predicate: TraitPredicate<'tcx>,\n-            answer: rustc_transmute::Condition<rustc_transmute::layout::rustc::Ref<'tcx>>,\n+            cond: Condition<rustc_transmute::layout::rustc::Ref<'tcx>>,\n         ) -> Vec<PredicateObligation<'tcx>> {\n-            match answer {\n+            match cond {\n                 // FIXME(bryangarza): Add separate `IfAny` case, instead of treating as `IfAll`\n                 // Not possible until the trait solver supports disjunctions of obligations\n-                rustc_transmute::Condition::IfAll(answers)\n-                | rustc_transmute::Condition::IfAny(answers) => {\n-                    let mut nested = vec![];\n-                    for flattened in answers\n-                        .into_iter()\n-                        .map(|answer| flatten_answer_tree(tcx, obligation, predicate, answer))\n-                    {\n-                        nested.extend(flattened);\n-                    }\n-                    nested\n-                }\n-                rustc_transmute::Condition::IfTransmutable { src, dst } => {\n+                Condition::IfAll(conds) | Condition::IfAny(conds) => conds\n+                    .into_iter()\n+                    .flat_map(|cond| flatten_answer_tree(tcx, obligation, predicate, cond))\n+                    .collect(),\n+                Condition::IfTransmutable { src, dst } => {\n                     let trait_def_id = obligation.predicate.def_id();\n                     let scope = predicate.trait_ref.substs.type_at(2);\n                     let assume_const = predicate.trait_ref.substs.const_at(3);\n@@ -333,11 +327,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // If Dst is mutable, check bidirectionally.\n                     // For example, transmuting bool -> u8 is OK as long as you can't update that u8\n                     // to be > 1, because you could later transmute the u8 back to a bool and get UB.\n-                    let mut obligations = vec![make_obl(src.ty, dst.ty)];\n-                    if dst.mutability == Mutability::Mut {\n-                        obligations.push(make_obl(dst.ty, src.ty));\n+                    match dst.mutability {\n+                        Mutability::Not => vec![make_obl(src.ty, dst.ty)],\n+                        Mutability::Mut => vec![make_obl(src.ty, dst.ty), make_obl(dst.ty, src.ty)],\n                     }\n-                    obligations\n                 }\n             }\n         }\n@@ -370,9 +363,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         );\n \n         let fully_flattened = match maybe_transmutable {\n-            Err(_) => Err(Unimplemented)?,\n-            Ok(Some(mt)) => flatten_answer_tree(self.tcx(), obligation, predicate, mt),\n-            Ok(None) => vec![],\n+            Answer::No(_) => Err(Unimplemented)?,\n+            Answer::If(cond) => flatten_answer_tree(self.tcx(), obligation, predicate, cond),\n+            Answer::Yes => vec![],\n         };\n \n         debug!(?fully_flattened);"}, {"sha": "6b718be7b1564c4cee1bcc5687db70757e310960", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -188,14 +188,14 @@ pub(crate) mod rustc {\n         /// The layout of the type is unspecified.\n         Unspecified,\n         /// This error will be surfaced elsewhere by rustc, so don't surface it.\n-        Unknown,\n+        UnknownLayout,\n         TypeError(ErrorGuaranteed),\n     }\n \n     impl<'tcx> From<LayoutError<'tcx>> for Err {\n         fn from(err: LayoutError<'tcx>) -> Self {\n             match err {\n-                LayoutError::Unknown(..) => Self::Unknown,\n+                LayoutError::Unknown(..) => Self::UnknownLayout,\n                 err => unimplemented!(\"{:?}\", err),\n             }\n         }"}, {"sha": "34ad6bd8c6923a822183ab163e387614303ad97f", "filename": "compiler/rustc_transmute/src/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flib.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -19,10 +19,16 @@ pub struct Assume {\n     pub validity: bool,\n }\n \n-/// Either we have an error, or we have an optional Condition that must hold.\n-pub type Answer<R> = Result<Option<Condition<R>>, Reason>;\n+/// Either we have an error, transmutation is allowed, or we have an optional\n+/// Condition that must hold.\n+#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+pub enum Answer<R> {\n+    Yes,\n+    No(Reason),\n+    If(Condition<R>),\n+}\n \n-/// A condition which must hold for safe transmutation to be possible\n+/// A condition which must hold for safe transmutation to be possible.\n #[derive(Debug, Hash, Eq, PartialEq, Clone)]\n pub enum Condition<R> {\n     /// `Src` is transmutable into `Dst`, if `src` is transmutable into `dst`.\n@@ -35,7 +41,7 @@ pub enum Condition<R> {\n     IfAny(Vec<Condition<R>>),\n }\n \n-/// Answers: Why wasn't the source type transmutable into the destination type?\n+/// Answers \"why wasn't the source type transmutable into the destination type?\"\n #[derive(Debug, Hash, Eq, PartialEq, PartialOrd, Ord, Clone)]\n pub enum Reason {\n     /// The layout of the source type is unspecified.\n@@ -52,6 +58,12 @@ pub enum Reason {\n     DstHasStricterAlignment { src_min_align: usize, dst_min_align: usize },\n     /// Can't go from shared pointer to unique pointer\n     DstIsMoreUnique,\n+    /// Encountered a type error\n+    TypeError,\n+    /// The layout of src is unknown\n+    SrcLayoutUnknown,\n+    /// The layout of dst is unknown\n+    DstLayoutUnknown,\n }\n \n #[cfg(feature = \"rustc\")]"}, {"sha": "b223a90f7514b24132a72fb193a7296b7f8221f4", "filename": "compiler/rustc_transmute/src/maybe_transmutable/mod.rs", "status": "modified", "additions": 74, "deletions": 78, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Fmod.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -33,6 +33,7 @@ where\n         Self { src, dst, scope, assume, context }\n     }\n \n+    // FIXME(bryangarza): Delete this when all usages are removed\n     pub(crate) fn map_layouts<F, M>(\n         self,\n         f: F,\n@@ -67,30 +68,26 @@ mod rustc {\n         /// then computes an answer using those trees.\n         #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n         pub fn answer(self) -> Answer<<TyCtxt<'tcx> as QueryContext>::Ref> {\n-            let query_or_answer = self.map_layouts(|src, dst, scope, &context| {\n-                // Convert `src` and `dst` from their rustc representations, to `Tree`-based\n-                // representations. If these conversions fail, conclude that the transmutation is\n-                // unacceptable; the layouts of both the source and destination types must be\n-                // well-defined.\n-                let src = Tree::from_ty(src, context);\n-                let dst = Tree::from_ty(dst, context);\n-\n-                match (src, dst) {\n-                    // Answer `Ok(None)` here, because 'unknown layout' and type errors will already\n-                    // be reported by rustc. No need to spam the user with more errors.\n-                    (Err(Err::TypeError(_)), _)\n-                    | (_, Err(Err::TypeError(_)))\n-                    | (Err(Err::Unknown), _)\n-                    | (_, Err(Err::Unknown)) => Err(Ok(None)),\n-                    (Err(Err::Unspecified), _) => Err(Err(Reason::SrcIsUnspecified)),\n-                    (_, Err(Err::Unspecified)) => Err(Err(Reason::DstIsUnspecified)),\n-                    (Ok(src), Ok(dst)) => Ok((src, dst)),\n+            let Self { src, dst, scope, assume, context } = self;\n+\n+            // Convert `src` and `dst` from their rustc representations, to `Tree`-based\n+            // representations. If these conversions fail, conclude that the transmutation is\n+            // unacceptable; the layouts of both the source and destination types must be\n+            // well-defined.\n+            let src = Tree::from_ty(src, context);\n+            let dst = Tree::from_ty(dst, context);\n+\n+            match (src, dst) {\n+                (Err(Err::TypeError(_)), _) | (_, Err(Err::TypeError(_))) => {\n+                    Answer::No(Reason::TypeError)\n+                }\n+                (Err(Err::UnknownLayout), _) => Answer::No(Reason::SrcLayoutUnknown),\n+                (_, Err(Err::UnknownLayout)) => Answer::No(Reason::DstLayoutUnknown),\n+                (Err(Err::Unspecified), _) => Answer::No(Reason::SrcIsUnspecified),\n+                (_, Err(Err::Unspecified)) => Answer::No(Reason::DstIsUnspecified),\n+                (Ok(src), Ok(dst)) => {\n+                    MaybeTransmutableQuery { src, dst, scope, assume, context }.answer()\n                 }\n-            });\n-\n-            match query_or_answer {\n-                Ok(query) => query.answer(),\n-                Err(answer) => answer,\n             }\n         }\n     }\n@@ -108,6 +105,7 @@ where\n     #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n     pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n         let assume_visibility = self.assume.safety;\n+        // FIXME(bryangarza): Refactor this code to get rid of `map_layouts`\n         let query_or_answer = self.map_layouts(|src, dst, scope, context| {\n             // Remove all `Def` nodes from `src`, without checking their visibility.\n             let src = src.prune(&|def| true);\n@@ -128,12 +126,13 @@ where\n             // Convert `src` from a tree-based representation to an NFA-based representation.\n             // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n             // is acceptable, because instances of the `src` type do not exist.\n-            let src = Nfa::from_tree(src).map_err(|Uninhabited| Ok(None))?;\n+            let src = Nfa::from_tree(src).map_err(|Uninhabited| Answer::Yes)?;\n \n             // Convert `dst` from a tree-based representation to an NFA-based representation.\n             // If the conversion fails because `src` is uninhabited, conclude that the transmutation\n             // is unacceptable, because instances of the `dst` type do not exist.\n-            let dst = Nfa::from_tree(dst).map_err(|Uninhabited| Err(Reason::DstIsPrivate))?;\n+            let dst =\n+                Nfa::from_tree(dst).map_err(|Uninhabited| Answer::No(Reason::DstIsPrivate))?;\n \n             Ok((src, dst))\n         });\n@@ -155,6 +154,7 @@ where\n     #[inline(always)]\n     #[instrument(level = \"debug\", skip(self), fields(src = ?self.src, dst = ?self.dst))]\n     pub(crate) fn answer(self) -> Answer<<C as QueryContext>::Ref> {\n+        // FIXME(bryangarza): Refactor this code to get rid of `map_layouts`\n         let query_or_answer = self\n             .map_layouts(|src, dst, scope, context| Ok((Dfa::from_nfa(src), Dfa::from_nfa(dst))));\n \n@@ -226,13 +226,13 @@ where\n                 // So, if it's possible to transmute to a smaller Dst by truncating, and we can guarantee\n                 // that none of the actually-used data can introduce an invalid state for Dst's type, we\n                 // are able to safely transmute, even with truncation.\n-                Ok(None)\n+                Answer::Yes\n             } else if src_state == self.src.accepting {\n                 // extension: `size_of(Src) >= size_of(Dst)`\n                 if let Some(dst_state_prime) = self.dst.byte_from(dst_state, Byte::Uninit) {\n                     self.answer_memo(cache, src_state, dst_state_prime)\n                 } else {\n-                    Err(Reason::DstIsTooBig)\n+                    Answer::No(Reason::DstIsTooBig)\n                 }\n             } else {\n                 let src_quantifier = if self.assume.validity {\n@@ -265,7 +265,7 @@ where\n                             } else {\n                                 // otherwise, we've exhausted our options.\n                                 // the DFAs, from this point onwards, are bit-incompatible.\n-                                Err(Reason::DstIsBitIncompatible)\n+                                Answer::No(Reason::DstIsBitIncompatible)\n                             }\n                         },\n                     ),\n@@ -282,8 +282,8 @@ where\n                 // the algoritm; only its performance.\n                 debug!(?bytes_answer);\n                 match bytes_answer {\n-                    Err(_) if !self.assume.validity => return bytes_answer,\n-                    Ok(None) if self.assume.validity => return bytes_answer,\n+                    Answer::No(_) if !self.assume.validity => return bytes_answer,\n+                    Answer::Yes if self.assume.validity => return bytes_answer,\n                     _ => {}\n                 };\n \n@@ -299,22 +299,22 @@ where\n                                     .into_iter()\n                                     .map(|(&dst_ref, &dst_state_prime)| {\n                                         if !src_ref.is_mutable() && dst_ref.is_mutable() {\n-                                            Err(Reason::DstIsMoreUnique)\n+                                            Answer::No(Reason::DstIsMoreUnique)\n                                         } else if !self.assume.alignment\n                                             && src_ref.min_align() < dst_ref.min_align()\n                                         {\n-                                            Err(Reason::DstHasStricterAlignment {\n+                                            Answer::No(Reason::DstHasStricterAlignment {\n                                                 src_min_align: src_ref.min_align(),\n                                                 dst_min_align: dst_ref.min_align(),\n                                             })\n                                         } else {\n                                             // ...such that `src` is transmutable into `dst`, if\n                                             // `src_ref` is transmutability into `dst_ref`.\n                                             and(\n-                                                Ok(Some(Condition::IfTransmutable {\n+                                                Answer::If(Condition::IfTransmutable {\n                                                     src: src_ref,\n                                                     dst: dst_ref,\n-                                                })),\n+                                                }),\n                                                 self.answer_memo(\n                                                     cache,\n                                                     src_state_prime,\n@@ -346,65 +346,56 @@ fn and<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R>\n where\n     R: PartialEq,\n {\n-    // If both are errors, then we should return the more specific one\n-    if lhs.is_err() && rhs.is_err() {\n-        if lhs == Err(Reason::DstIsBitIncompatible) {\n-            return rhs;\n-        } else {\n-            return lhs;\n-        }\n-    }\n-    Ok(match (lhs?, rhs?) {\n+    match (lhs, rhs) {\n+        // If both are errors, then we should return the more specific one\n+        (Answer::No(Reason::DstIsBitIncompatible), Answer::No(reason))\n+        | (Answer::No(reason), Answer::No(_))\n+        // If either is an error, return it\n+        | (Answer::No(reason), _) | (_, Answer::No(reason)) => Answer::No(reason),\n         // If only one side has a condition, pass it along\n-        (None, other) | (other, None) => other,\n+        | (Answer::Yes, other) | (other, Answer::Yes) => other,\n         // If both sides have IfAll conditions, merge them\n-        (Some(Condition::IfAll(mut lhs)), Some(Condition::IfAll(ref mut rhs))) => {\n+        (Answer::If(Condition::IfAll(mut lhs)), Answer::If(Condition::IfAll(ref mut rhs))) => {\n             lhs.append(rhs);\n-            Some(Condition::IfAll(lhs))\n+            Answer::If(Condition::IfAll(lhs))\n         }\n         // If only one side is an IfAll, add the other Condition to it\n-        (Some(cond), Some(Condition::IfAll(mut conds)))\n-        | (Some(Condition::IfAll(mut conds)), Some(cond)) => {\n+        (Answer::If(cond), Answer::If(Condition::IfAll(mut conds)))\n+        | (Answer::If(Condition::IfAll(mut conds)), Answer::If(cond)) => {\n             conds.push(cond);\n-            Some(Condition::IfAll(conds))\n+            Answer::If(Condition::IfAll(conds))\n         }\n         // Otherwise, both lhs and rhs conditions can be combined in a parent IfAll\n-        (Some(lhs), Some(rhs)) => Some(Condition::IfAll(vec![lhs, rhs])),\n-    })\n+        (Answer::If(lhs), Answer::If(rhs)) => Answer::If(Condition::IfAll(vec![lhs, rhs])),\n+    }\n }\n \n fn or<R>(lhs: Answer<R>, rhs: Answer<R>) -> Answer<R>\n where\n     R: PartialEq,\n {\n-    // If both are errors, then we should return the more specific one\n-    if lhs.is_err() && rhs.is_err() {\n-        if lhs == Err(Reason::DstIsBitIncompatible) {\n-            return rhs;\n-        } else {\n-            return lhs;\n-        }\n-    }\n-    // Otherwise, errors can be ignored for the rest of the pattern matching\n-    let lhs = lhs.unwrap_or(None);\n-    let rhs = rhs.unwrap_or(None);\n-    Ok(match (lhs, rhs) {\n+    match (lhs, rhs) {\n+        // If both are errors, then we should return the more specific one\n+        (Answer::No(Reason::DstIsBitIncompatible), Answer::No(reason))\n+        | (Answer::No(reason), Answer::No(_)) => Answer::No(reason),\n+        // Otherwise, errors can be ignored for the rest of the pattern matching\n+        (Answer::No(_), other) | (other, Answer::No(_)) => or(other, Answer::Yes),\n         // If only one side has a condition, pass it along\n-        (None, other) | (other, None) => other,\n+        (Answer::Yes, other) | (other, Answer::Yes) => other,\n         // If both sides have IfAny conditions, merge them\n-        (Some(Condition::IfAny(mut lhs)), Some(Condition::IfAny(ref mut rhs))) => {\n+        (Answer::If(Condition::IfAny(mut lhs)), Answer::If(Condition::IfAny(ref mut rhs))) => {\n             lhs.append(rhs);\n-            Some(Condition::IfAny(lhs))\n+            Answer::If(Condition::IfAny(lhs))\n         }\n         // If only one side is an IfAny, add the other Condition to it\n-        (Some(cond), Some(Condition::IfAny(mut conds)))\n-        | (Some(Condition::IfAny(mut conds)), Some(cond)) => {\n+        (Answer::If(cond), Answer::If(Condition::IfAny(mut conds)))\n+        | (Answer::If(Condition::IfAny(mut conds)), Answer::If(cond)) => {\n             conds.push(cond);\n-            Some(Condition::IfAny(conds))\n+            Answer::If(Condition::IfAny(conds))\n         }\n         // Otherwise, both lhs and rhs conditions can be combined in a parent IfAny\n-        (Some(lhs), Some(rhs)) => Some(Condition::IfAny(vec![lhs, rhs])),\n-    })\n+        (Answer::If(lhs), Answer::If(rhs)) => Answer::If(Condition::IfAny(vec![lhs, rhs])),\n+    }\n }\n \n pub enum Quantifier {\n@@ -421,16 +412,21 @@ impl Quantifier {\n         use std::ops::ControlFlow::{Break, Continue};\n \n         let (init, try_fold_f): (_, fn(_, _) -> _) = match self {\n-            Self::ThereExists => (Err(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n-                match or(accum, next) {\n-                    Ok(None) => Break(Ok(None)),\n+            Self::ThereExists => {\n+                (Answer::No(Reason::DstIsBitIncompatible), |accum: Answer<R>, next| {\n+                    match or(accum, next) {\n+                        Answer::Yes => Break(Answer::Yes),\n+                        maybe => Continue(maybe),\n+                    }\n+                })\n+            }\n+            Self::ForAll => (Answer::Yes, |accum: Answer<R>, next| {\n+                let answer = and(accum, next);\n+                match answer {\n+                    Answer::No(_) => Break(answer),\n                     maybe => Continue(maybe),\n                 }\n             }),\n-            Self::ForAll => (Ok(None), |accum: Answer<R>, next| match and(accum, next) {\n-                Err(reason) => Break(Err(reason)),\n-                maybe => Continue(maybe),\n-            }),\n         };\n \n         let (Continue(result) | Break(result)) = iter.into_iter().try_fold(init, try_fold_f);"}, {"sha": "e49bebf571deae4cd028a44178114088058a1014", "filename": "compiler/rustc_transmute/src/maybe_transmutable/tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Fmaybe_transmutable%2Ftests.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -4,6 +4,8 @@ use crate::{layout, Reason};\n use itertools::Itertools;\n \n mod bool {\n+    use crate::Answer;\n+\n     use super::*;\n \n     #[test]\n@@ -17,7 +19,7 @@ mod bool {\n             UltraMinimal,\n         )\n         .answer();\n-        assert_eq!(answer, Ok(None));\n+        assert_eq!(answer, Answer::Yes);\n     }\n \n     #[test]\n@@ -30,7 +32,7 @@ mod bool {\n             UltraMinimal,\n         )\n         .answer();\n-        assert_eq!(answer, Ok(None));\n+        assert_eq!(answer, Answer::Yes);\n     }\n \n     #[test]\n@@ -65,7 +67,7 @@ mod bool {\n \n                 if src_set.is_subset(&dst_set) {\n                     assert_eq!(\n-                        Ok(None),\n+                        Answer::Yes,\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),\n@@ -80,7 +82,7 @@ mod bool {\n                     );\n                 } else if !src_set.is_disjoint(&dst_set) {\n                     assert_eq!(\n-                        Ok(None),\n+                        Answer::Yes,\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),\n@@ -95,7 +97,7 @@ mod bool {\n                     );\n                 } else {\n                     assert_eq!(\n-                        Err(Reason::DstIsBitIncompatible),\n+                        Answer::No(Reason::DstIsBitIncompatible),\n                         MaybeTransmutableQuery::new(\n                             src_layout.clone(),\n                             dst_layout.clone(),"}, {"sha": "8d19cabc0f9f022602b11a2a58aad58f2242a0f9", "filename": "tests/ui/transmutability/malformed-program-gracefulness/unknown_src_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.rs?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -18,5 +18,5 @@ fn should_gracefully_handle_unknown_dst_field() {\n     struct Context;\n     #[repr(C)] struct Src;\n     #[repr(C)] struct Dst(Missing); //~ cannot find type\n-    assert::is_transmutable::<Src, Dst, Context>();\n+    assert::is_transmutable::<Src, Dst, Context>(); //~ ERROR cannot be safely transmuted\n }"}, {"sha": "c2df398b8ff91ee488e4fce987a8f4d3a22654fc", "filename": "tests/ui/transmutability/malformed-program-gracefulness/unknown_src_field.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmutability%2Fmalformed-program-gracefulness%2Funknown_src_field.stderr?ref=f4cf8f65a5e8e110c8c36469d31f16e8571e2c1a", "patch": "@@ -4,6 +4,22 @@ error[E0412]: cannot find type `Missing` in this scope\n LL |     #[repr(C)] struct Dst(Missing);\n    |                           ^^^^^^^ not found in this scope\n \n-error: aborting due to previous error\n+error[E0277]: `Src` cannot be safely transmuted into `Dst` in the defining scope of `should_gracefully_handle_unknown_dst_field::Context`\n+  --> $DIR/unknown_src_field.rs:21:36\n+   |\n+LL |     assert::is_transmutable::<Src, Dst, Context>();\n+   |                                    ^^^ `Dst` has an unknown layout\n+   |\n+note: required by a bound in `is_transmutable`\n+  --> $DIR/unknown_src_field.rs:13:14\n+   |\n+LL |     pub fn is_transmutable<Src, Dst, Context>()\n+   |            --------------- required by a bound in this function\n+LL |     where\n+LL |         Dst: BikeshedIntrinsicFrom<Src, Context>\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `is_transmutable`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0412`.\n+Some errors have detailed explanations: E0277, E0412.\n+For more information about an error, try `rustc --explain E0277`."}]}