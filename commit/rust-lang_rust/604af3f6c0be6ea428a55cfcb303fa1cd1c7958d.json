{"sha": "604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNGFmM2Y2YzBiZTZlYTQyOGE1NWNmY2IzMDNmYTFjZDFjNzk1OGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-11T16:32:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-14T21:14:26Z"}, "message": "librustc: Implement simple `where` clauses.\n\nThese `where` clauses are accepted everywhere generics are currently\naccepted and desugar during type collection to the type parameter bounds\nwe have today.\n\nA new keyword, `where`, has been added. Therefore, this is a breaking\nchange. Change uses of `where` to other identifiers.\n\n[breaking-change]", "tree": {"sha": "5d4c22c593c4701b829fdaad19e55ff803c84de7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d4c22c593c4701b829fdaad19e55ff803c84de7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "comment_count": 22, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "html_url": "https://github.com/rust-lang/rust/commit/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c8e3f80fd0355b2bb91337c6ad0bb0a38d5485", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c8e3f80fd0355b2bb91337c6ad0bb0a38d5485", "html_url": "https://github.com/rust-lang/rust/commit/a8c8e3f80fd0355b2bb91337c6ad0bb0a38d5485"}], "stats": {"total": 833, "additions": 626, "deletions": 207}, "files": [{"sha": "3ce6f72610095d2f9af5975528d9f92f2dfa06a0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -3671,6 +3671,7 @@ impl<'a> Resolver<'a> {\n                                                                ItemRibKind),\n                                              |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n+                    this.resolve_where_clause(&generics.where_clause);\n                     visit::walk_item(this, item, ());\n                 });\n             }\n@@ -3713,6 +3714,7 @@ impl<'a> Resolver<'a> {\n                                                                NormalRibKind),\n                                              |this| {\n                     this.resolve_type_parameters(&generics.ty_params);\n+                    this.resolve_where_clause(&generics.where_clause);\n \n                     // Resolve derived traits.\n                     for trt in traits.iter() {\n@@ -3744,6 +3746,8 @@ impl<'a> Resolver<'a> {\n                                 // parameters.\n                                 this.resolve_type_parameters(\n                                     &ty_m.generics.ty_params);\n+                                this.resolve_where_clause(&ty_m.generics\n+                                                               .where_clause);\n \n                                 for argument in ty_m.decl.inputs.iter() {\n                                     this.resolve_type(&*argument.ty);\n@@ -3907,6 +3911,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 HasTypeParameters(ref generics, _, _, _) => {\n                     this.resolve_type_parameters(&generics.ty_params);\n+                    this.resolve_where_clause(&generics.where_clause);\n                 }\n             }\n \n@@ -4022,6 +4027,30 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n+        for predicate in where_clause.predicates.iter() {\n+            match self.resolve_identifier(predicate.ident,\n+                                          TypeNS,\n+                                          true,\n+                                          predicate.span) {\n+                Some((def @ DefTyParam(_, _, _), last_private)) => {\n+                    self.record_def(predicate.id, (def, last_private));\n+                }\n+                _ => {\n+                    self.resolve_error(\n+                        predicate.span,\n+                        format!(\"undeclared type parameter `{}`\",\n+                                token::get_ident(\n+                                    predicate.ident)).as_slice());\n+                }\n+            }\n+\n+            for bound in predicate.bounds.iter() {\n+                self.resolve_type_parameter_bound(predicate.id, bound);\n+            }\n+        }\n+    }\n+\n     fn resolve_struct(&mut self,\n                       id: NodeId,\n                       generics: &Generics,\n@@ -4035,6 +4064,7 @@ impl<'a> Resolver<'a> {\n                                      |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n+            this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve the super struct.\n             match super_struct {\n@@ -4146,6 +4176,7 @@ impl<'a> Resolver<'a> {\n                                      |this| {\n             // Resolve the type parameters.\n             this.resolve_type_parameters(&generics.ty_params);\n+            this.resolve_where_clause(&generics.where_clause);\n \n             // Resolve the trait reference, if necessary.\n             this.with_optional_trait_ref(id, opt_trait_reference, |this| {"}, {"sha": "de5e718206d909c68b03353fdd718c51000c0672", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -208,7 +208,6 @@ use syntax::util::interner::Interner;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n use syntax::ast_util::PostExpansionMethod;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n \n@@ -1123,8 +1122,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n-    let empty_generics = ast::Generics { lifetimes: Vec::new(),\n-                                         ty_params: OwnedSlice::empty() };\n+    let empty_generics = ast_util::empty_generics();\n \n     let fnitem = cx.tcx.map.get(fn_ast_id);\n "}, {"sha": "0c5d58ae930b694f83b62e9ecde5352b838028d6", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 107, "deletions": 66, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -987,20 +987,26 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n \n fn ty_generics_for_type(ccx: &CrateCtxt,\n                         generics: &ast::Generics)\n-                        -> ty::Generics\n-{\n-    ty_generics(ccx, subst::TypeSpace, &generics.lifetimes,\n-                &generics.ty_params, ty::Generics::empty())\n+                        -> ty::Generics {\n+    ty_generics(ccx,\n+                subst::TypeSpace,\n+                &generics.lifetimes,\n+                &generics.ty_params,\n+                ty::Generics::empty(),\n+                &generics.where_clause)\n }\n \n fn ty_generics_for_trait(ccx: &CrateCtxt,\n                          trait_id: ast::NodeId,\n                          substs: &subst::Substs,\n                          generics: &ast::Generics)\n-                         -> ty::Generics\n-{\n-    let mut generics = ty_generics(ccx, subst::TypeSpace, &generics.lifetimes,\n-                                   &generics.ty_params, ty::Generics::empty());\n+                         -> ty::Generics {\n+    let mut generics = ty_generics(ccx,\n+                                   subst::TypeSpace,\n+                                   &generics.lifetimes,\n+                                   &generics.ty_params,\n+                                   ty::Generics::empty(),\n+                                   &generics.where_clause);\n \n     // Something of a hack: use the node id for the trait, also as\n     // the node id for the Self type parameter.\n@@ -1032,11 +1038,14 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n                                 generics: &ast::Generics,\n                                 base_generics: ty::Generics)\n-                                -> ty::Generics\n-{\n+                                -> ty::Generics {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(ccx, subst::FnSpace, &early_lifetimes,\n-                &generics.ty_params, base_generics)\n+    ty_generics(ccx,\n+                subst::FnSpace,\n+                &early_lifetimes,\n+                &generics.ty_params,\n+                base_generics,\n+                &generics.where_clause)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `Sized?`.\n@@ -1080,9 +1089,9 @@ fn ty_generics(ccx: &CrateCtxt,\n                space: subst::ParamSpace,\n                lifetimes: &Vec<ast::LifetimeDef>,\n                types: &OwnedSlice<ast::TyParam>,\n-               base_generics: ty::Generics)\n-               -> ty::Generics\n-{\n+               base_generics: ty::Generics,\n+               where_clause: &ast::WhereClause)\n+               -> ty::Generics {\n     let mut result = base_generics;\n \n     for (i, l) in lifetimes.iter().enumerate() {\n@@ -1095,7 +1104,11 @@ fn ty_generics(ccx: &CrateCtxt,\n     }\n \n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx, space, param, i);\n+        let def = get_or_create_type_parameter_def(ccx,\n+                                                   space,\n+                                                   param,\n+                                                   i,\n+                                                   where_clause);\n         debug!(\"ty_generics: def for type param: {}\", def.repr(ccx.tcx));\n         result.types.push(space, def);\n     }\n@@ -1105,9 +1118,9 @@ fn ty_generics(ccx: &CrateCtxt,\n     fn get_or_create_type_parameter_def(ccx: &CrateCtxt,\n                                         space: subst::ParamSpace,\n                                         param: &ast::TyParam,\n-                                        index: uint)\n-                                        -> ty::TypeParameterDef\n-    {\n+                                        index: uint,\n+                                        where_clause: &ast::WhereClause)\n+                                        -> ty::TypeParameterDef {\n         match ccx.tcx.ty_param_defs.borrow().find(&param.id) {\n             Some(d) => { return (*d).clone(); }\n             None => { }\n@@ -1121,7 +1134,8 @@ fn ty_generics(ccx: &CrateCtxt,\n                                             &param.bounds,\n                                             &param.unbound,\n                                             param.ident,\n-                                            param.span));\n+                                            param.span,\n+                                            where_clause));\n         let default = param.default.map(|path| {\n             let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*path);\n             let cur_idx = param_ty.idx;\n@@ -1154,14 +1168,14 @@ fn ty_generics(ccx: &CrateCtxt,\n         def\n     }\n \n-    fn compute_bounds(\n-        ccx: &CrateCtxt,\n-        param_ty: ty::ParamTy,\n-        ast_bounds: &OwnedSlice<ast::TyParamBound>,\n-        unbound: &Option<ast::TyParamBound>,\n-        ident: ast::Ident,\n-        span: Span) -> ty::ParamBounds\n-    {\n+    fn compute_bounds(ccx: &CrateCtxt,\n+                      param_ty: ty::ParamTy,\n+                      ast_bounds: &OwnedSlice<ast::TyParamBound>,\n+                      unbound: &Option<ast::TyParamBound>,\n+                      ident: ast::Ident,\n+                      span: Span,\n+                      where_clause: &ast::WhereClause)\n+                      -> ty::ParamBounds {\n         /*!\n          * Translate the AST's notion of ty param bounds (which are an\n          * enum consisting of a newtyped Ty or a region) to ty's\n@@ -1174,44 +1188,23 @@ fn ty_generics(ccx: &CrateCtxt,\n             trait_bounds: Vec::new()\n         };\n         for ast_bound in ast_bounds.iter() {\n-            match *ast_bound {\n-                TraitTyParamBound(ref b) => {\n-                    let ty = ty::mk_param(ccx.tcx, param_ty.space,\n-                                          param_ty.idx, param_ty.def_id);\n-                    let trait_ref = instantiate_trait_ref(ccx, b, ty);\n-                    if !ty::try_add_builtin_trait(\n-                            ccx.tcx, trait_ref.def_id,\n-                            &mut param_bounds.builtin_bounds) {\n-                        // Must be a user-defined trait\n-                        param_bounds.trait_bounds.push(trait_ref);\n-                    }\n-                }\n-\n-                StaticRegionTyParamBound => {\n-                    param_bounds.builtin_bounds.add(ty::BoundStatic);\n-                }\n-\n-                UnboxedFnTyParamBound(ref unboxed_function) => {\n-                    let rscope = ExplicitRscope;\n-                    let self_ty = ty::mk_param(ccx.tcx,\n-                                               param_ty.space,\n-                                               param_ty.idx,\n-                                               param_ty.def_id);\n-                    let trait_ref =\n-                        astconv::trait_ref_for_unboxed_function(ccx,\n-                                                                &rscope,\n-                                                                unboxed_function,\n-                                                                Some(self_ty));\n-                    param_bounds.trait_bounds.push(Rc::new(trait_ref));\n-                }\n-\n-                OtherRegionTyParamBound(span) => {\n-                    if !ccx.tcx.sess.features.issue_5723_bootstrap.get() {\n-                        ccx.tcx.sess.span_err(\n-                            span,\n-                            \"only the 'static lifetime is accepted here.\");\n-                    }\n-                }\n+            compute_bound(ccx, &mut param_bounds, param_ty, ast_bound);\n+        }\n+        for predicate in where_clause.predicates.iter() {\n+            let predicate_param_id = ccx.tcx\n+                                        .def_map\n+                                        .borrow()\n+                                        .find(&predicate.id)\n+                                        .expect(\"compute_bounds(): resolve \\\n+                                                 didn't resolve the type \\\n+                                                 parameter identifier in a \\\n+                                                 `where` clause\")\n+                                        .def_id();\n+            if param_ty.def_id != predicate_param_id {\n+                continue\n+            }\n+            for bound in predicate.bounds.iter() {\n+                compute_bound(ccx, &mut param_bounds, param_ty, bound);\n             }\n         }\n \n@@ -1228,6 +1221,54 @@ fn ty_generics(ccx: &CrateCtxt,\n         param_bounds\n     }\n \n+    /// Translates the AST's notion of a type parameter bound to\n+    /// typechecking's notion of the same, and pushes the resulting bound onto\n+    /// the appropriate section of `param_bounds`.\n+    fn compute_bound(ccx: &CrateCtxt,\n+                     param_bounds: &mut ty::ParamBounds,\n+                     param_ty: ty::ParamTy,\n+                     ast_bound: &ast::TyParamBound) {\n+        match *ast_bound {\n+            TraitTyParamBound(ref b) => {\n+                let ty = ty::mk_param(ccx.tcx, param_ty.space,\n+                                      param_ty.idx, param_ty.def_id);\n+                let trait_ref = instantiate_trait_ref(ccx, b, ty);\n+                if !ty::try_add_builtin_trait(\n+                        ccx.tcx, trait_ref.def_id,\n+                        &mut param_bounds.builtin_bounds) {\n+                    // Must be a user-defined trait\n+                    param_bounds.trait_bounds.push(trait_ref);\n+                }\n+            }\n+\n+            StaticRegionTyParamBound => {\n+                param_bounds.builtin_bounds.add(ty::BoundStatic);\n+            }\n+\n+            UnboxedFnTyParamBound(ref unboxed_function) => {\n+                let rscope = ExplicitRscope;\n+                let self_ty = ty::mk_param(ccx.tcx,\n+                                           param_ty.space,\n+                                           param_ty.idx,\n+                                           param_ty.def_id);\n+                let trait_ref =\n+                    astconv::trait_ref_for_unboxed_function(ccx,\n+                                                            &rscope,\n+                                                            unboxed_function,\n+                                                            Some(self_ty));\n+                param_bounds.trait_bounds.push(Rc::new(trait_ref));\n+            }\n+\n+            OtherRegionTyParamBound(span) => {\n+                if !ccx.tcx.sess.features.issue_5723_bootstrap.get() {\n+                    ccx.tcx.sess.span_err(\n+                        span,\n+                        \"only the 'static lifetime is accepted here.\");\n+                }\n+            }\n+        }\n+    }\n+\n     fn check_bounds_compatible(tcx: &ty::ctxt,\n                                param_bounds: &ty::ParamBounds,\n                                ident: ast::Ident,"}, {"sha": "beaf81409a38b39c91ad8dd6c37d1d7ae17817ac", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -781,6 +781,7 @@ impl<'a> Rebuilder<'a> {\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output;\n         let mut ty_params = self.generics.ty_params.clone();\n+        let where_clause = self.generics.where_clause.clone();\n         let mut kept_lifetimes = HashSet::new();\n         for sr in self.same_regions.iter() {\n             self.cur_anon.set(0);\n@@ -807,7 +808,8 @@ impl<'a> Rebuilder<'a> {\n                                              &fresh_lifetimes,\n                                              &kept_lifetimes,\n                                              &all_region_names,\n-                                             ty_params);\n+                                             ty_params,\n+                                             where_clause);\n         let new_fn_decl = ast::FnDecl {\n             inputs: inputs,\n             output: output,\n@@ -981,7 +983,8 @@ impl<'a> Rebuilder<'a> {\n                         add: &Vec<ast::Lifetime>,\n                         keep: &HashSet<ast::Name>,\n                         remove: &HashSet<ast::Name>,\n-                        ty_params: OwnedSlice<ast::TyParam>)\n+                        ty_params: OwnedSlice<ast::TyParam>,\n+                        where_clause: ast::WhereClause)\n                         -> ast::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add.iter() {\n@@ -990,14 +993,14 @@ impl<'a> Rebuilder<'a> {\n         }\n         for lt in generics.lifetimes.iter() {\n             if keep.contains(&lt.lifetime.name) ||\n-                !remove.contains(&lt.lifetime.name)\n-            {\n+                !remove.contains(&lt.lifetime.name) {\n                 lifetimes.push((*lt).clone());\n             }\n         }\n         ast::Generics {\n             lifetimes: lifetimes,\n-            ty_params: ty_params\n+            ty_params: ty_params,\n+            where_clause: where_clause,\n         }\n     }\n "}, {"sha": "68e1529fb1770f343903ecfa66e2c773a0c05cca", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -363,7 +363,7 @@ impl Clean<Item> for doctree::Module {\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n-        let where = {\n+        let whence = {\n             let ctxt = super::ctxtkey.get().unwrap();\n             let cm = ctxt.sess().codemap();\n             let outer = cm.lookup_char_pos(self.where_outer.lo);\n@@ -380,7 +380,7 @@ impl Clean<Item> for doctree::Module {\n         Item {\n             name: Some(name),\n             attrs: self.attrs.clean(),\n-            source: where.clean(),\n+            source: whence.clean(),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n@@ -781,7 +781,7 @@ impl Clean<Item> for doctree::Function {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n@@ -917,7 +917,7 @@ impl Clean<Item> for doctree::Trait {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -1397,7 +1397,7 @@ impl Clean<Item> for doctree::Struct {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -1443,7 +1443,7 @@ impl Clean<Item> for doctree::Enum {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -1466,7 +1466,7 @@ impl Clean<Item> for doctree::Variant {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n@@ -1652,7 +1652,7 @@ impl Clean<Item> for doctree::Typedef {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id.clone()),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -1702,7 +1702,7 @@ impl Clean<Item> for doctree::Static {\n         Item {\n             name: Some(self.name.clean()),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -1748,7 +1748,7 @@ impl Clean<Item> for doctree::Impl {\n         Item {\n             name: None,\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n             stability: self.stab.clean(),\n@@ -2115,12 +2115,12 @@ impl Clean<Item> for doctree::Macro {\n         Item {\n             name: Some(format!(\"{}!\", self.name.clean())),\n             attrs: self.attrs.clean(),\n-            source: self.where.clean(),\n+            source: self.whence.clean(),\n             visibility: ast::Public.clean(),\n             stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n-                source: self.where.to_src(),\n+                source: self.whence.to_src(),\n             }),\n         }\n     }"}, {"sha": "da45321e7fd98819ee6b296c21ef14b9003e786f", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -93,7 +93,7 @@ pub struct Struct {\n     pub generics: ast::Generics,\n     pub attrs: Vec<ast::Attribute>,\n     pub fields: Vec<ast::StructField>,\n-    pub where: Span,\n+    pub whence: Span,\n }\n \n pub struct Enum {\n@@ -103,7 +103,7 @@ pub struct Enum {\n     pub generics: ast::Generics,\n     pub attrs: Vec<ast::Attribute>,\n     pub id: NodeId,\n-    pub where: Span,\n+    pub whence: Span,\n     pub name: Ident,\n }\n \n@@ -114,7 +114,7 @@ pub struct Variant {\n     pub id: ast::NodeId,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n-    pub where: Span,\n+    pub whence: Span,\n }\n \n pub struct Function {\n@@ -125,7 +125,7 @@ pub struct Function {\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub fn_style: ast::FnStyle,\n-    pub where: Span,\n+    pub whence: Span,\n     pub generics: ast::Generics,\n }\n \n@@ -135,7 +135,7 @@ pub struct Typedef {\n     pub name: Ident,\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n-    pub where: Span,\n+    pub whence: Span,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n }\n@@ -149,7 +149,7 @@ pub struct Static {\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n-    pub where: Span,\n+    pub whence: Span,\n }\n \n pub struct Trait {\n@@ -159,7 +159,7 @@ pub struct Trait {\n     pub parents: Vec<ast::TraitRef>,\n     pub attrs: Vec<ast::Attribute>,\n     pub id: ast::NodeId,\n-    pub where: Span,\n+    pub whence: Span,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n }\n@@ -170,7 +170,7 @@ pub struct Impl {\n     pub for_: ast::P<ast::Ty>,\n     pub items: Vec<ast::ImplItem>,\n     pub attrs: Vec<ast::Attribute>,\n-    pub where: Span,\n+    pub whence: Span,\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n@@ -180,7 +180,7 @@ pub struct Macro {\n     pub name: Ident,\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n-    pub where: Span,\n+    pub whence: Span,\n     pub stab: Option<attr::Stability>,\n }\n "}, {"sha": "b67b3c394d6f4bf766404ac601ccefcbe1bb7feb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -91,7 +91,7 @@ impl<'a> RustdocVisitor<'a> {\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             generics: generics.clone(),\n             fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n-            where: item.span\n+            whence: item.span\n         }\n     }\n \n@@ -107,7 +107,7 @@ impl<'a> RustdocVisitor<'a> {\n                 stab: self.stability(x.node.id),\n                 id: x.node.id,\n                 kind: x.node.kind.clone(),\n-                where: x.span,\n+                whence: x.span,\n             });\n         }\n         Enum {\n@@ -118,7 +118,7 @@ impl<'a> RustdocVisitor<'a> {\n             generics: params.clone(),\n             attrs: it.attrs.iter().map(|x| *x).collect(),\n             id: it.id,\n-            where: it.span,\n+            whence: it.span,\n         }\n     }\n \n@@ -133,7 +133,7 @@ impl<'a> RustdocVisitor<'a> {\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             decl: fd.clone(),\n             name: item.ident,\n-            where: item.span,\n+            whence: item.span,\n             generics: gen.clone(),\n             fn_style: *fn_style,\n         }\n@@ -297,7 +297,7 @@ impl<'a> RustdocVisitor<'a> {\n                     name: item.ident,\n                     id: item.id,\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n-                    where: item.span,\n+                    whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n@@ -311,7 +311,7 @@ impl<'a> RustdocVisitor<'a> {\n                     id: item.id,\n                     name: item.ident,\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n-                    where: item.span,\n+                    whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n@@ -325,7 +325,7 @@ impl<'a> RustdocVisitor<'a> {\n                     parents: tr.iter().map(|x| (*x).clone()).collect(),\n                     id: item.id,\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n-                    where: item.span,\n+                    whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n@@ -339,7 +339,7 @@ impl<'a> RustdocVisitor<'a> {\n                     items: items.iter().map(|x| *x).collect(),\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     id: item.id,\n-                    where: item.span,\n+                    whence: item.span,\n                     vis: item.vis,\n                     stab: self.stability(item.id),\n                 };\n@@ -360,7 +360,7 @@ impl<'a> RustdocVisitor<'a> {\n             id: item.id,\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             name: item.ident,\n-            where: item.span,\n+            whence: item.span,\n             stab: self.stability(item.id),\n         }\n     }"}, {"sha": "c658a5c31922b6b576c2f16e5e15d8b45d1c4e03", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -245,6 +245,7 @@ pub struct TyParam {\n pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n     pub ty_params: OwnedSlice<TyParam>,\n+    pub where_clause: WhereClause,\n }\n \n impl Generics {\n@@ -259,9 +260,23 @@ impl Generics {\n     }\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereClause {\n+    pub id: NodeId,\n+    pub predicates: Vec<WherePredicate>,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WherePredicate {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub bounds: OwnedSlice<TyParamBound>,\n+}\n+\n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<Gc<MetaItem>> ;\n+pub type CrateConfig = Vec<Gc<MetaItem>>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Crate {"}, {"sha": "5fccf6cc3f025bbdf1a10e7d121e958a7852ee51", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -431,11 +431,14 @@ impl Map {\n     /// the iterator will produce node id's for items with paths\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n-    pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S]) -> NodesMatchingSuffix<'a,S> {\n-        NodesMatchingSuffix { map: self,\n-                              item_name: parts.last().unwrap(),\n-                              where: parts.slice_to(parts.len() - 1),\n-                              idx: 0 }\n+    pub fn nodes_matching_suffix<'a, S:Str>(&'a self, parts: &'a [S])\n+                                 -> NodesMatchingSuffix<'a,S> {\n+        NodesMatchingSuffix {\n+            map: self,\n+            item_name: parts.last().unwrap(),\n+            in_which: parts.slice_to(parts.len() - 1),\n+            idx: 0,\n+        }\n     }\n \n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n@@ -478,20 +481,20 @@ impl Map {\n pub struct NodesMatchingSuffix<'a, S> {\n     map: &'a Map,\n     item_name: &'a S,\n-    where: &'a [S],\n+    in_which: &'a [S],\n     idx: NodeId,\n }\n \n impl<'a,S:Str> NodesMatchingSuffix<'a,S> {\n     /// Returns true only if some suffix of the module path for parent\n-    /// matches `self.where`.\n+    /// matches `self.in_which`.\n     ///\n-    /// In other words: let `[x_0,x_1,...,x_k]` be `self.where`;\n+    /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n     /// returns true if parent's path ends with the suffix\n     /// `x_0::x_1::...::x_k`.\n     fn suffix_matches(&self, parent: NodeId) -> bool {\n         let mut cursor = parent;\n-        for part in self.where.iter().rev() {\n+        for part in self.in_which.iter().rev() {\n             let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),"}, {"sha": "5674c6675f96362bec27e655b90b3e403d79d42b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -320,8 +320,14 @@ pub fn operator_prec(op: ast::BinOp) -> uint {\n pub static as_prec: uint = 12u;\n \n pub fn empty_generics() -> Generics {\n-    Generics {lifetimes: Vec::new(),\n-              ty_params: OwnedSlice::empty()}\n+    Generics {\n+        lifetimes: Vec::new(),\n+        ty_params: OwnedSlice::empty(),\n+        where_clause: WhereClause {\n+            id: DUMMY_NODE_ID,\n+            predicates: Vec::new(),\n+        }\n+    }\n }\n \n // ______________________________________________________________________"}, {"sha": "f9f2a86d18249799789ec54e10389166930237ef", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -390,7 +390,7 @@ impl<'a> TraitDef<'a> {\n                            methods: Vec<Gc<ast::Method>> ) -> Gc<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        let Generics { mut lifetimes, ty_params } =\n+        let Generics { mut lifetimes, ty_params, where_clause: _ } =\n             self.generics.to_generics(cx, self.span, type_ident, generics);\n         let mut ty_params = ty_params.into_vec();\n \n@@ -418,7 +418,11 @@ impl<'a> TraitDef<'a> {\n         }));\n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n-            ty_params: OwnedSlice::from_vec(ty_params)\n+            ty_params: OwnedSlice::from_vec(ty_params),\n+            where_clause: ast::WhereClause {\n+                id: ast::DUMMY_NODE_ID,\n+                predicates: Vec::new(),\n+            },\n         };\n \n         // Create the reference to the trait."}, {"sha": "f4a9b85f75d23d62fff86fb8bbc53d72bc7c5e6e", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -202,10 +202,15 @@ fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str,\n     cx.typaram(span, cx.ident_of(name), bounds, unbound, None)\n }\n \n-fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam> ) -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n+               -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n-        ty_params: OwnedSlice::from_vec(ty_params)\n+        ty_params: OwnedSlice::from_vec(ty_params),\n+        where_clause: ast::WhereClause {\n+            id: ast::DUMMY_NODE_ID,\n+            predicates: Vec::new(),\n+        },\n     }\n }\n "}, {"sha": "9ad28f02e8034813f9e5fb76bcc4d43f273be3e8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -244,6 +244,16 @@ pub trait Folder {\n         noop_fold_field(field, self)\n     }\n \n+    fn fold_where_clause(&mut self, where_clause: &WhereClause)\n+                         -> WhereClause {\n+        noop_fold_where_clause(where_clause, self)\n+    }\n+\n+    fn fold_where_predicate(&mut self, where_predicate: &WherePredicate)\n+                            -> WherePredicate {\n+        noop_fold_where_predicate(where_predicate, self)\n+    }\n+\n // Helper methods:\n \n     fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n@@ -698,8 +708,37 @@ pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n }\n \n pub fn noop_fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n-    Generics {ty_params: fld.fold_ty_params(generics.ty_params.as_slice()),\n-              lifetimes: fld.fold_lifetime_defs(generics.lifetimes.as_slice())}\n+    Generics {\n+        ty_params: fld.fold_ty_params(generics.ty_params.as_slice()),\n+        lifetimes: fld.fold_lifetime_defs(generics.lifetimes.as_slice()),\n+        where_clause: fld.fold_where_clause(&generics.where_clause),\n+    }\n+}\n+\n+pub fn noop_fold_where_clause<T: Folder>(\n+                              where_clause: &WhereClause,\n+                              fld: &mut T)\n+                              -> WhereClause {\n+    WhereClause {\n+        id: fld.new_id(where_clause.id),\n+        predicates: where_clause.predicates.iter().map(|predicate| {\n+            fld.fold_where_predicate(predicate)\n+        }).collect(),\n+    }\n+}\n+\n+pub fn noop_fold_where_predicate<T: Folder>(\n+                                 predicate: &WherePredicate,\n+                                 fld: &mut T)\n+                                 -> WherePredicate {\n+    WherePredicate {\n+        id: fld.new_id(predicate.id),\n+        span: fld.new_span(predicate.span),\n+        ident: fld.fold_ident(predicate.ident),\n+        bounds: predicate.bounds.map(|x| {\n+            fld.fold_ty_param_bound(x)\n+        }),\n+    }\n }\n \n pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,"}, {"sha": "1724962898978d74bcff3a721020d899dd86e553", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -543,7 +543,7 @@ impl<'a> StringReader<'a> {\n     // favors rustc debugging effectiveness over runtime efficiency.\n \n     /// Scan through input of form \\x00name_NNNNNN,ctxt_CCCCCCC\\x00\n-    /// where: `NNNNNN` is a string of characters forming an integer\n+    /// whence: `NNNNNN` is a string of characters forming an integer\n     /// (the name) and `CCCCCCC` is a string of characters forming an\n     /// integer (the ctxt), separate by a comma and delimited by a\n     /// `\\x00` marker.\n@@ -552,22 +552,22 @@ impl<'a> StringReader<'a> {\n         fn bump_expecting_char<'a,D:fmt::Show>(r: &mut StringReader<'a>,\n                                                c: char,\n                                                described_c: D,\n-                                               where: &str) {\n+                                               whence: &str) {\n             match r.curr {\n                 Some(r_c) if r_c == c => r.bump(),\n-                Some(r_c) => fail!(\"expected {}, hit {}, {}\", described_c, r_c, where),\n-                None      => fail!(\"expected {}, hit EOF, {}\", described_c, where),\n+                Some(r_c) => fail!(\"expected {}, hit {}, {}\", described_c, r_c, whence),\n+                None      => fail!(\"expected {}, hit EOF, {}\", described_c, whence),\n             }\n         }\n \n-        let where = \"while scanning embedded hygienic ident\";\n+        let whence = \"while scanning embedded hygienic ident\";\n \n         // skip over the leading `\\x00`\n-        bump_expecting_char(self, '\\x00', \"nul-byte\", where);\n+        bump_expecting_char(self, '\\x00', \"nul-byte\", whence);\n \n         // skip over the \"name_\"\n         for c in \"name_\".chars() {\n-            bump_expecting_char(self, c, c, where);\n+            bump_expecting_char(self, c, c, whence);\n         }\n \n         let start_bpos = self.last_pos;\n@@ -578,29 +578,29 @@ impl<'a> StringReader<'a> {\n         let encoded_name : u32 = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n                 fail!(\"expected digits representing a name, got `{}`, {}, range [{},{}]\",\n-                      s, where, start_bpos, self.last_pos);\n+                      s, whence, start_bpos, self.last_pos);\n             })\n         });\n \n         // skip over the `,`\n-        bump_expecting_char(self, ',', \"comma\", where);\n+        bump_expecting_char(self, ',', \"comma\", whence);\n \n         // skip over the \"ctxt_\"\n         for c in \"ctxt_\".chars() {\n-            bump_expecting_char(self, c, c, where);\n+            bump_expecting_char(self, c, c, whence);\n         }\n \n         // find the integer representing the ctxt\n         let start_bpos = self.last_pos;\n         self.scan_digits(base);\n         let encoded_ctxt : ast::SyntaxContext = self.with_str_from(start_bpos, |s| {\n             num::from_str_radix(s, 10).unwrap_or_else(|| {\n-                fail!(\"expected digits representing a ctxt, got `{}`, {}\", s, where);\n+                fail!(\"expected digits representing a ctxt, got `{}`, {}\", s, whence);\n             })\n         });\n \n         // skip over the `\\x00`\n-        bump_expecting_char(self, '\\x00', \"nul-byte\", where);\n+        bump_expecting_char(self, '\\x00', \"nul-byte\", whence);\n \n         ast::Ident { name: ast::Name(encoded_name),\n                      ctxt: encoded_ctxt, }"}, {"sha": "271cefeaf038fcd260a515abd58edd2df249d517", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -1053,6 +1053,10 @@ mod test {\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n                                         ty_params: OwnedSlice::empty(),\n+                                        where_clause: ast::WhereClause {\n+                                            id: ast::DUMMY_NODE_ID,\n+                                            predicates: Vec::new(),\n+                                        }\n                                     },\n                                     ast::P(ast::Block {\n                                         view_items: Vec::new(),"}, {"sha": "577959ea36ad343491fff208e3c616407e49ce70", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 80, "deletions": 12, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -60,7 +60,7 @@ use ast::{UnboxedClosureKind, UnboxedFnTy, UnboxedFnTyParamBound};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use ast::Visibility;\n+use ast::{Visibility, WhereClause, WherePredicate};\n use ast;\n use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n use ast_util;\n@@ -1264,14 +1264,16 @@ impl<'a> Parser<'a> {\n             let style = p.parse_fn_style();\n             let ident = p.parse_ident();\n \n-            let generics = p.parse_generics();\n+            let mut generics = p.parse_generics();\n \n             let (explicit_self, d) = p.parse_fn_decl_with_self(|p| {\n                 // This is somewhat dubious; We don't want to allow argument\n                 // names to be left off if there is a definition...\n                 p.parse_arg_general(false)\n             });\n \n+            p.parse_where_clause(&mut generics);\n+\n             let hi = p.last_span.hi;\n             match p.token {\n               token::SEMI => {\n@@ -3742,7 +3744,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a set of optional generic type parameter declarations\n+    /// Parse a set of optional generic type parameter declarations. Where\n+    /// clauses are not parsed here, and must be added later via\n+    /// `parse_where_clause()`.\n+    ///\n     /// matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n     ///                  | ( < lifetimes , typaramseq ( , )? > )\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n@@ -3762,7 +3767,14 @@ impl<'a> Parser<'a> {\n                 }\n                 ty_param\n             });\n-            ast::Generics { lifetimes: lifetime_defs, ty_params: ty_params }\n+            ast::Generics {\n+                lifetimes: lifetime_defs,\n+                ty_params: ty_params,\n+                where_clause: WhereClause {\n+                    id: ast::DUMMY_NODE_ID,\n+                    predicates: Vec::new(),\n+                }\n+            }\n         } else {\n             ast_util::empty_generics()\n         }\n@@ -3788,6 +3800,52 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parses an optional `where` clause and places it in `generics`.\n+    fn parse_where_clause(&mut self, generics: &mut ast::Generics) {\n+        if !self.eat_keyword(keywords::Where) {\n+            return\n+        }\n+\n+        let mut parsed_something = false;\n+        loop {\n+            let lo = self.span.lo;\n+            let ident = match self.token {\n+                token::IDENT(..) => self.parse_ident(),\n+                _ => break,\n+            };\n+            self.expect(&token::COLON);\n+\n+            let (_, bounds) = self.parse_ty_param_bounds(false);\n+            let hi = self.span.hi;\n+            let span = mk_sp(lo, hi);\n+\n+            if bounds.len() == 0 {\n+                self.span_err(span,\n+                              \"each predicate in a `where` clause must have \\\n+                               at least one bound in it\");\n+            }\n+\n+            generics.where_clause.predicates.push(ast::WherePredicate {\n+                id: ast::DUMMY_NODE_ID,\n+                span: span,\n+                ident: ident,\n+                bounds: bounds,\n+            });\n+            parsed_something = true;\n+\n+            if !self.eat(&token::COMMA) {\n+                break\n+            }\n+        }\n+\n+        if !parsed_something {\n+            let last_span = self.last_span;\n+            self.span_err(last_span,\n+                          \"a `where` clause must have at least one predicate \\\n+                           in it\");\n+        }\n+    }\n+\n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n                      -> (Vec<Arg> , bool) {\n         let sp = self.span;\n@@ -4143,8 +4201,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse an item-position function declaration.\n     fn parse_item_fn(&mut self, fn_style: FnStyle, abi: abi::Abi) -> ItemInfo {\n-        let (ident, generics) = self.parse_fn_header();\n+        let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n+        self.parse_where_clause(&mut generics);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n         (ident, ItemFn(decl, fn_style, abi, generics, body), Some(inner_attrs))\n     }\n@@ -4200,10 +4259,11 @@ impl<'a> Parser<'a> {\n                 };\n                 let fn_style = self.parse_fn_style();\n                 let ident = self.parse_ident();\n-                let generics = self.parse_generics();\n+                let mut generics = self.parse_generics();\n                 let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n                         p.parse_arg()\n                     });\n+                self.parse_where_clause(&mut generics);\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let new_attrs = attrs.append(inner_attrs.as_slice());\n                 (ast::MethDecl(ident,\n@@ -4228,7 +4288,7 @@ impl<'a> Parser<'a> {\n     /// Parse trait Foo { ... }\n     fn parse_item_trait(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n-        let tps = self.parse_generics();\n+        let mut tps = self.parse_generics();\n         let sized = self.parse_for_sized();\n \n         // Parse traits, if necessary.\n@@ -4240,6 +4300,8 @@ impl<'a> Parser<'a> {\n             traits = Vec::new();\n         }\n \n+        self.parse_where_clause(&mut tps);\n+\n         let meths = self.parse_trait_methods();\n         (ident, ItemTrait(tps, sized, traits, meths), None)\n     }\n@@ -4261,7 +4323,7 @@ impl<'a> Parser<'a> {\n     ///    impl<T> ToString for ~[T] { ... }\n     fn parse_item_impl(&mut self) -> ItemInfo {\n         // First, parse type parameters if necessary.\n-        let generics = self.parse_generics();\n+        let mut generics = self.parse_generics();\n \n         // Special case: if the next identifier that follows is '(', don't\n         // allow this to be parsed as a trait.\n@@ -4297,6 +4359,7 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n+        self.parse_where_clause(&mut generics);\n         let (impl_items, attrs) = self.parse_impl_items();\n \n         let ident = ast_util::impl_pretty_name(&opt_trait, &*ty);\n@@ -4326,7 +4389,7 @@ impl<'a> Parser<'a> {\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self, is_virtual: bool) -> ItemInfo {\n         let class_name = self.parse_ident();\n-        let generics = self.parse_generics();\n+        let mut generics = self.parse_generics();\n \n         let super_struct = if self.eat(&token::COLON) {\n             let ty = self.parse_ty(true);\n@@ -4343,6 +4406,8 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n+        self.parse_where_clause(&mut generics);\n+\n         let mut fields: Vec<StructField>;\n         let is_tuple_like;\n \n@@ -4683,8 +4748,9 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         self.expect_keyword(keywords::Fn);\n \n-        let (ident, generics) = self.parse_fn_header();\n+        let (ident, mut generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(true);\n+        self.parse_where_clause(&mut generics);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         box(GC) ast::ForeignItem { ident: ident,\n@@ -4834,7 +4900,8 @@ impl<'a> Parser<'a> {\n     /// Parse type Foo = Bar;\n     fn parse_item_type(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n-        let tps = self.parse_generics();\n+        let mut tps = self.parse_generics();\n+        self.parse_where_clause(&mut tps);\n         self.expect(&token::EQ);\n         let ty = self.parse_ty(true);\n         self.expect(&token::SEMI);\n@@ -4925,7 +4992,8 @@ impl<'a> Parser<'a> {\n     /// Parse an \"enum\" declaration\n     fn parse_item_enum(&mut self) -> ItemInfo {\n         let id = self.parse_ident();\n-        let generics = self.parse_generics();\n+        let mut generics = self.parse_generics();\n+        self.parse_where_clause(&mut generics);\n         self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(&generics);"}, {"sha": "4c959932f415d112fd5734ba39a17c4bd3fea268", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -499,18 +499,19 @@ declare_special_idents_and_keywords! {\n         (41,                         Proc,       \"proc\");\n         (42,                         Box,        \"box\");\n         (43,                         Const,      \"const\");\n+        (44,                         Where,      \"where\");\n \n         'reserved:\n-        (44,                         Alignof,    \"alignof\");\n-        (45,                         Be,         \"be\");\n-        (46,                         Offsetof,   \"offsetof\");\n-        (47,                         Priv,       \"priv\");\n-        (48,                         Pure,       \"pure\");\n-        (49,                         Sizeof,     \"sizeof\");\n-        (50,                         Typeof,     \"typeof\");\n-        (51,                         Unsized,    \"unsized\");\n-        (52,                         Yield,      \"yield\");\n-        (53,                         Do,         \"do\");\n+        (45,                         Alignof,    \"alignof\");\n+        (46,                         Be,         \"be\");\n+        (47,                         Offsetof,   \"offsetof\");\n+        (48,                         Priv,       \"priv\");\n+        (49,                         Pure,       \"pure\");\n+        (50,                         Sizeof,     \"sizeof\");\n+        (51,                         Typeof,     \"typeof\");\n+        (52,                         Unsized,    \"unsized\");\n+        (53,                         Yield,      \"yield\");\n+        (54,                         Do,         \"do\");\n     }\n }\n "}, {"sha": "998049b83cc8305fd7811488b64c71211273e56a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 95, "deletions": 44, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -584,7 +584,11 @@ impl<'a> State<'a> {\n             ast::TyBareFn(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty()\n+                    ty_params: OwnedSlice::empty(),\n+                    where_clause: ast::WhereClause {\n+                        id: ast::DUMMY_NODE_ID,\n+                        predicates: Vec::new(),\n+                    },\n                 };\n                 try!(self.print_ty_fn(Some(f.abi),\n                                       None,\n@@ -601,7 +605,11 @@ impl<'a> State<'a> {\n             ast::TyClosure(f, ref region) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty()\n+                    ty_params: OwnedSlice::empty(),\n+                    where_clause: ast::WhereClause {\n+                        id: ast::DUMMY_NODE_ID,\n+                        predicates: Vec::new(),\n+                    },\n                 };\n                 try!(self.print_ty_fn(None,\n                                       Some('&'),\n@@ -618,7 +626,11 @@ impl<'a> State<'a> {\n             ast::TyProc(ref f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n-                    ty_params: OwnedSlice::empty()\n+                    ty_params: OwnedSlice::empty(),\n+                    where_clause: ast::WhereClause {\n+                        id: ast::DUMMY_NODE_ID,\n+                        predicates: Vec::new(),\n+                    },\n                 };\n                 try!(self.print_ty_fn(None,\n                                       Some('~'),\n@@ -765,6 +777,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_type(&**ty));\n+                try!(self.print_where_clause(params));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -808,6 +821,7 @@ impl<'a> State<'a> {\n                 }\n \n                 try!(self.print_type(&**ty));\n+                try!(self.print_where_clause(generics));\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n@@ -845,6 +859,7 @@ impl<'a> State<'a> {\n                         try!(self.print_path(&trait_.path, false));\n                     }\n                 }\n+                try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n                 for meth in methods.iter() {\n@@ -880,6 +895,7 @@ impl<'a> State<'a> {\n         try!(self.head(visibility_qualified(visibility, \"enum\").as_slice()));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n+        try!(self.print_where_clause(generics));\n         try!(space(&mut self.s));\n         self.print_variants(enum_definition.variants.as_slice(), span)\n     }\n@@ -2010,7 +2026,8 @@ impl<'a> State<'a> {\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n-        self.print_fn_args_and_ret(decl, opt_explicit_self)\n+        try!(self.print_fn_args_and_ret(decl, opt_explicit_self))\n+        self.print_where_clause(generics)\n     }\n \n     pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n@@ -2201,54 +2218,83 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_generics(&mut self,\n-                          generics: &ast::Generics) -> IoResult<()> {\n-        let total = generics.lifetimes.len() + generics.ty_params.len();\n-        if total > 0 {\n-            try!(word(&mut self.s, \"<\"));\n+    fn print_type_parameters(&mut self,\n+                             lifetimes: &[ast::LifetimeDef],\n+                             ty_params: &[ast::TyParam])\n+                             -> IoResult<()> {\n+        let total = lifetimes.len() + ty_params.len();\n+        let mut ints = Vec::new();\n+        for i in range(0u, total) {\n+            ints.push(i);\n+        }\n \n-            let mut ints = Vec::new();\n-            for i in range(0u, total) {\n-                ints.push(i);\n-            }\n-\n-            try!(self.commasep(\n-                Inconsistent, ints.as_slice(),\n-                |s, &idx| {\n-                    if idx < generics.lifetimes.len() {\n-                        let lifetime = generics.lifetimes.get(idx);\n-                        s.print_lifetime_def(lifetime)\n-                    } else {\n-                        let idx = idx - generics.lifetimes.len();\n-                        let param = generics.ty_params.get(idx);\n-                        match param.unbound {\n-                            Some(TraitTyParamBound(ref tref)) => {\n-                                try!(s.print_trait_ref(tref));\n-                                try!(s.word_space(\"?\"));\n-                            }\n-                            _ => {}\n-                        }\n-                        try!(s.print_ident(param.ident));\n-                        try!(s.print_bounds(&None,\n-                                            &param.bounds,\n-                                            false,\n-                                            false));\n-                        match param.default {\n-                            Some(ref default) => {\n-                                try!(space(&mut s.s));\n-                                try!(s.word_space(\"=\"));\n-                                s.print_type(&**default)\n-                            }\n-                            _ => Ok(())\n-                        }\n+        self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n+            if idx < lifetimes.len() {\n+                let lifetime = &lifetimes[idx];\n+                s.print_lifetime_def(lifetime)\n+            } else {\n+                let idx = idx - lifetimes.len();\n+                let param = &ty_params[idx];\n+                match param.unbound {\n+                    Some(TraitTyParamBound(ref tref)) => {\n+                        try!(s.print_trait_ref(tref));\n+                        try!(s.word_space(\"?\"));\n                     }\n-                }));\n+                    _ => {}\n+                }\n+                try!(s.print_ident(param.ident));\n+                try!(s.print_bounds(&None,\n+                                    &param.bounds,\n+                                    false,\n+                                    false));\n+                match param.default {\n+                    Some(ref default) => {\n+                        try!(space(&mut s.s));\n+                        try!(s.word_space(\"=\"));\n+                        s.print_type(&**default)\n+                    }\n+                    _ => Ok(())\n+                }\n+            }\n+        })\n+    }\n+\n+    pub fn print_generics(&mut self, generics: &ast::Generics)\n+                          -> IoResult<()> {\n+        if generics.lifetimes.len() + generics.ty_params.len() > 0 {\n+            try!(word(&mut self.s, \"<\"));\n+            try!(self.print_type_parameters(generics.lifetimes.as_slice(),\n+                                            generics.ty_params.as_slice()));\n             word(&mut self.s, \">\")\n         } else {\n             Ok(())\n         }\n     }\n \n+    pub fn print_where_clause(&mut self, generics: &ast::Generics)\n+                              -> IoResult<()> {\n+        if generics.where_clause.predicates.len() == 0 {\n+            return Ok(())\n+        }\n+\n+        try!(space(&mut self.s));\n+        try!(self.word_space(\"where\"));\n+\n+        for (i, predicate) in generics.where_clause\n+                                      .predicates\n+                                      .iter()\n+                                      .enumerate() {\n+            if i != 0 {\n+                try!(self.word_space(\",\"));\n+            }\n+\n+            try!(self.print_ident(predicate.ident));\n+            try!(self.print_bounds(&None, &predicate.bounds, false, false));\n+        }\n+\n+        Ok(())\n+    }\n+\n     pub fn print_meta_item(&mut self, item: &ast::MetaItem) -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n         match item.node {\n@@ -2472,6 +2518,11 @@ impl<'a> State<'a> {\n             }\n         }\n \n+        match generics {\n+            Some(generics) => try!(self.print_where_clause(generics)),\n+            None => {}\n+        }\n+\n         self.end()\n     }\n "}, {"sha": "ac1dbdc439ca0c4fe788c22efd4f8619f64e2d98", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -27,6 +27,7 @@\n use abi::Abi;\n use ast::*;\n use ast;\n+use ast_util;\n use codemap::Span;\n use parse;\n use owned_slice::OwnedSlice;\n@@ -58,12 +59,7 @@ pub fn generics_of_fn(fk: &FnKind) -> Generics {\n         FkMethod(_, generics, _) => {\n             (*generics).clone()\n         }\n-        FkFnBlock(..) => {\n-            Generics {\n-                lifetimes: Vec::new(),\n-                ty_params: OwnedSlice::empty(),\n-            }\n-        }\n+        FkFnBlock(..) => ast_util::empty_generics(),\n     }\n }\n \n@@ -559,7 +555,11 @@ pub fn walk_generics<E: Clone, V: Visitor<E>>(visitor: &mut V,\n             None => {}\n         }\n     }\n-    walk_lifetime_decls(visitor, &generics.lifetimes, env);\n+    walk_lifetime_decls(visitor, &generics.lifetimes, env.clone());\n+    for predicate in generics.where_clause.predicates.iter() {\n+        visitor.visit_ident(predicate.span, predicate.ident, env.clone());\n+        walk_ty_param_bounds(visitor, &predicate.bounds, env.clone());\n+    }\n }\n \n pub fn walk_fn_decl<E: Clone, V: Visitor<E>>(visitor: &mut V,"}, {"sha": "002b31f099f381587d20dfa5ad4bc9d9eb868c53", "filename": "src/test/auxiliary/where_clauses_xc.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fwhere_clauses_xc.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Equal {\n+    fn equal(&self, other: &Self) -> bool;\n+    fn equals<T,U>(&self, this: &T, that: &T, x: &U, y: &U) -> bool\n+            where T: Eq, U: Eq;\n+}\n+\n+impl<T> Equal for T where T: Eq {\n+    fn equal(&self, other: &T) -> bool {\n+        self == other\n+    }\n+    fn equals<U,X>(&self, this: &U, other: &U, x: &X, y: &X) -> bool\n+            where U: Eq, X: Eq {\n+        this == other && x == y\n+    }\n+}\n+\n+pub fn equal<T>(x: &T, y: &T) -> bool where T: Eq {\n+    x == y\n+}\n+"}, {"sha": "b96c7c2de6b3c356618c4be86cb855900db4a5f8", "filename": "src/test/compile-fail/where-clauses-no-bounds-or-predicates.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-no-bounds-or-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-no-bounds-or-predicates.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn equal1<T>(_: &T, _: &T) -> bool where {\n+//~^ ERROR a `where` clause must have at least one predicate in it\n+    true\n+}\n+\n+fn equal2<T>(_: &T, _: &T) -> bool where T: {\n+//~^ ERROR each predicate in a `where` clause must have at least one bound\n+    true\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "2817aa16e8e5ecb29dce23a3ebb4e6a507b6b3e1", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn equal<T>(_: &T, _: &T) -> bool where int : Eq {\n+    //~^ ERROR undeclared type parameter\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "1d21313975f6e63c0ba952b60f0a0d613f0dd02b", "filename": "src/test/compile-fail/where-clauses-unsatisfied.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-unsatisfied.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn equal<T>(_: &T, _: &T) -> bool where T : Eq {\n+}\n+\n+struct Struct;\n+\n+fn main() {\n+    equal(&Struct, &Struct)\n+    //~^ ERROR failed to find an implementation of trait\n+}\n+"}, {"sha": "648f646b6377f1a2fdea9149c8cfaf46380421d6", "filename": "src/test/run-pass/where-clauses-cross-crate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Frun-pass%2Fwhere-clauses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Frun-pass%2Fwhere-clauses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses-cross-crate.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:where_clauses_xc.rs\n+\n+extern crate where_clauses_xc;\n+\n+use where_clauses_xc::{Equal, equal};\n+\n+fn main() {\n+    println!(\"{}\", equal(&1i, &2i));\n+    println!(\"{}\", equal(&1i, &1i));\n+    println!(\"{}\", \"hello\".equal(&\"hello\"));\n+    println!(\"{}\", \"hello\".equals::<int,&str>(&1i, &1i, &\"foo\", &\"bar\"));\n+}\n+"}, {"sha": "807d95691f43acc358cefac8482257d4bb2c52fe", "filename": "src/test/run-pass/where-clauses.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Frun-pass%2Fwhere-clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604af3f6c0be6ea428a55cfcb303fa1cd1c7958d/src%2Ftest%2Frun-pass%2Fwhere-clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhere-clauses.rs?ref=604af3f6c0be6ea428a55cfcb303fa1cd1c7958d", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Equal {\n+    fn equal(&self, other: &Self) -> bool;\n+    fn equals<T,U>(&self, this: &T, that: &T, x: &U, y: &U) -> bool\n+            where T: Eq, U: Eq;\n+}\n+\n+impl<T> Equal for T where T: Eq {\n+    fn equal(&self, other: &T) -> bool {\n+        self == other\n+    }\n+    fn equals<U,X>(&self, this: &U, other: &U, x: &X, y: &X) -> bool\n+            where U: Eq, X: Eq {\n+        this == other && x == y\n+    }\n+}\n+\n+fn equal<T>(x: &T, y: &T) -> bool where T: Eq {\n+    x == y\n+}\n+\n+fn main() {\n+    println!(\"{}\", equal(&1i, &2i));\n+    println!(\"{}\", equal(&1i, &1i));\n+    println!(\"{}\", \"hello\".equal(&\"hello\"));\n+    println!(\"{}\", \"hello\".equals::<int,&str>(&1i, &1i, &\"foo\", &\"bar\"));\n+}\n+"}]}