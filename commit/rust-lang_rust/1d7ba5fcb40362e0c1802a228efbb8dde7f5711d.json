{"sha": "1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkN2JhNWZjYjQwMzYyZTBjMTgwMmEyMjhlZmJiOGRkZTdmNTcxMWQ=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-24T21:14:18Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-06-30T07:13:56Z"}, "message": "stop taking references in Relate", "tree": {"sha": "cd4fc56c89e1d1d7ffd0d0b3cea733a7d325dea5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd4fc56c89e1d1d7ffd0d0b3cea733a7d325dea5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "html_url": "https://github.com/rust-lang/rust/commit/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1528c432e45339d9b5602a19ac3571e2900d37b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1528c432e45339d9b5602a19ac3571e2900d37b", "html_url": "https://github.com/rust-lang/rust/commit/a1528c432e45339d9b5602a19ac3571e2900d37b"}], "stats": {"total": 410, "additions": 182, "deletions": 228}, "files": [{"sha": "a7749d33b7c1389edcd874c10151ac8403d17da7", "filename": "src/librustc_infer/infer/at.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).sub(a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -109,15 +109,15 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(&a, &b)\n+        self.trace_exp(a_is_expected, a, b).eq(a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(&expected, &actual)\n+        self.trace(expected, actual).eq(expected, actual)\n     }\n \n     pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(&expected, &actual)\n+        self.trace(expected, actual).lub(expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(&expected, &actual)\n+        self.trace(expected, actual).glb(expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n-    pub fn sub<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -203,7 +203,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n \n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n-    pub fn eq<T>(self, a: &T, b: &T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -218,7 +218,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn lub<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n         })\n     }\n \n-    pub fn glb<T>(self, a: &T, b: &T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "a6d7b403fe7a97bfb1ac7923f1166ee6b85f7ef0", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -271,7 +271,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n@@ -285,7 +285,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n                         },\n                         ty::Variance::Invariant,\n                     )\n-                    .relate(&v1, &v2)?;\n+                    .relate(v1, v2)?;\n                 }\n \n                 _ => {"}, {"sha": "fa54d815055eccda10869fd75983ae6a75470d19", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -318,10 +318,10 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // to associate causes/spans with each of the relations in\n         // the stack to get this right.\n         match dir {\n-            EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n-            SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+            EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n+            SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n             SupertypeOf => {\n-                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, &a_ty, &b_ty)\n+                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, a_ty, b_ty)\n             }\n         }?;\n \n@@ -379,7 +379,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             param_env: self.param_env,\n         };\n \n-        let ty = match generalize.relate(&ty, &ty) {\n+        let ty = match generalize.relate(ty, ty) {\n             Ok(ty) => ty,\n             Err(e) => {\n                 debug!(\"generalize: failure {:?}\", e);\n@@ -490,13 +490,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(ty::Binder::bind(self.relate(*a.skip_binder(), *b.skip_binder())?))\n     }\n \n     fn relate_item_substs(\n@@ -519,8 +519,8 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n@@ -552,7 +552,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     match probe {\n                         TypeVariableValue::Known { value: u } => {\n                             debug!(\"generalize: known value {:?}\", u);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n@@ -655,7 +655,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n-                    ConstVariableValue::Known { value: u } => self.relate(&u, &u),\n+                    ConstVariableValue::Known { value: u } => self.relate(u, u),\n                     ConstVariableValue::Unknown { universe } => {\n                         if self.for_universe.can_name(universe) {\n                             Ok(c)"}, {"sha": "6826956b38bd8c446bd5bb3596027270820c08fe", "filename": "src/librustc_infer/infer/equate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -59,8 +59,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -124,8 +124,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -135,8 +135,8 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n             self.fields.higher_ranked_sub(b, a, self.a_is_expected)\n         } else {\n             // Fast path for the common case.\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a.clone())\n+            self.relate(*a.skip_binder(), *b.skip_binder())?;\n+            Ok(a)\n         }\n     }\n }"}, {"sha": "8a0ab52f383065cd72205619ec3232cf0a6ce8a2", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -112,8 +112,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&v, &a)?;\n-        sub.relate(&v, &b)?;\n+        sub.relate(v, a)?;\n+        sub.relate(v, b)?;\n         Ok(())\n     }\n }"}, {"sha": "ea19dff7db125098ba4b1ad85f765af989cf64aa", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -11,8 +11,8 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: &Binder<T>,\n-        b: &Binder<T>,\n+        a: Binder<T>,\n+        b: Binder<T>,\n         a_is_expected: bool,\n     ) -> RelateResult<'tcx, Binder<T>>\n     where\n@@ -33,20 +33,20 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n         self.infcx.commit_if_ok(|_| {\n             // First, we instantiate each bound region in the supertype with a\n             // fresh placeholder region.\n-            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(b);\n+            let (b_prime, _) = self.infcx.replace_bound_vars_with_placeholders(&b);\n \n             // Next, we instantiate each bound region in the subtype\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n             let (a_prime, _) =\n-                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, a);\n+                self.infcx.replace_bound_vars_with_fresh_vars(span, HigherRankedType, &a);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n \n             // Compare types now that bound regions have been replaced.\n-            let result = self.sub(a_is_expected).relate(&a_prime, &b_prime)?;\n+            let result = self.sub(a_is_expected).relate(a_prime, b_prime)?;\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n "}, {"sha": "3e2ea3d0f8fbf19856222dcaefbed6e22acfa477", "filename": "src/librustc_infer/infer/lub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -43,8 +43,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -85,8 +85,8 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n         self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n \n@@ -118,8 +118,8 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n \n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n-        sub.relate(&a, &v)?;\n-        sub.relate(&b, &v)?;\n+        sub.relate(a, v)?;\n+        sub.relate(b, v)?;\n         Ok(())\n     }\n }"}, {"sha": "59e08b85f26e8370bca434c57c0d88f22feda1ff", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -159,6 +159,7 @@ where\n         }\n     }\n \n+    // FIXME: consider taking `ty::Binder` directly, without the reference.\n     fn create_scope(\n         &mut self,\n         value: &ty::Binder<impl TypeFoldable<'tcx>>,\n@@ -369,7 +370,7 @@ where\n             universe,\n         };\n \n-        generalizer.relate(&value, &value)\n+        generalizer.relate(value, value)\n     }\n }\n \n@@ -495,8 +496,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n \n@@ -613,8 +614,8 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -640,11 +641,10 @@ where\n \n         debug!(\"binders({:?}: {:?}, ambient_variance={:?})\", a, b, self.ambient_variance);\n \n-        if !a.skip_binder().has_escaping_bound_vars() && !b.skip_binder().has_escaping_bound_vars()\n-        {\n+        if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n-            self.relate(a.skip_binder(), b.skip_binder())?;\n-            return Ok(a.clone());\n+            self.relate(a, b)?;\n+            return Ok(ty::Binder::bind(a));\n         }\n \n         if self.ambient_covariance() {\n@@ -654,8 +654,8 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // universals).\n \n-            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n-            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n+            let b_scope = self.create_scope(&b, UniversallyQuantified(true));\n+            let a_scope = self.create_scope(&a, UniversallyQuantified(false));\n \n             debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n             debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n@@ -683,7 +683,7 @@ where\n             //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n             let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            self.relate(*a.skip_binder(), *b.skip_binder())?;\n \n             self.ambient_variance = variance;\n \n@@ -698,8 +698,8 @@ where\n             // instantiation of B (i.e., B instantiated with\n             // existentials). Opposite of above.\n \n-            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n-            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n+            let a_scope = self.create_scope(&a, UniversallyQuantified(true));\n+            let b_scope = self.create_scope(&b, UniversallyQuantified(false));\n \n             debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n             debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n@@ -712,7 +712,7 @@ where\n             let variance =\n                 ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Contravariant);\n \n-            self.relate(a.skip_binder(), b.skip_binder())?;\n+            self.relate(*a.skip_binder(), *b.skip_binder())?;\n \n             self.ambient_variance = variance;\n \n@@ -839,8 +839,8 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\n             \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n@@ -890,7 +890,7 @@ where\n                     match variables.probe(vid) {\n                         TypeVariableValue::Known { value: u } => {\n                             drop(variables);\n-                            self.relate(&u, &u)\n+                            self.relate(u, u)\n                         }\n                         TypeVariableValue::Unknown { universe: _universe } => {\n                             if self.ambient_variance == ty::Bivariant {\n@@ -984,7 +984,7 @@ where\n                 let variable_table = &mut inner.const_unification_table();\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n-                    Some(u) => self.relate(&u, &u),\n+                    Some(u) => self.relate(u, u),\n                     None => {\n                         let new_var_id = variable_table.new_key(ConstVarValue {\n                             origin: var_value.origin,\n@@ -1001,16 +1001,16 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        _: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        _: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n     {\n         debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n \n         self.first_free_index.shift_in(1);\n-        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        let result = self.relate(*a.skip_binder(), *a.skip_binder())?;\n         self.first_free_index.shift_out(1);\n         Ok(ty::Binder::bind(result))\n     }"}, {"sha": "d190f7e434298996252818144e695e96fcc61d75", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -62,8 +62,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n@@ -162,8 +162,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,"}, {"sha": "55aafc0b42aa457d9ec67e4366bdedfc2f608f98", "filename": "src/librustc_middle/ty/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_middle%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_middle%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2F_match.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -46,8 +46,8 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         self.relate(a, b)\n     }\n@@ -112,12 +112,12 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n     {\n-        Ok(ty::Binder::bind(self.relate(a.skip_binder(), b.skip_binder())?))\n+        Ok(ty::Binder::bind(self.relate(*a.skip_binder(), *b.skip_binder())?))\n     }\n }"}, {"sha": "cee04ce8c6a831f62212f0b73c461acacad8af27", "filename": "src/librustc_middle/ty/relate.rs", "status": "modified", "additions": 90, "deletions": 136, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_middle%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_middle%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Frelate.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -13,7 +13,6 @@ use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n use rustc_target::spec::abi;\n use std::iter;\n-use std::rc::Rc;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -42,7 +41,7 @@ pub trait TypeRelation<'tcx>: Sized {\n     }\n \n     /// Generic relation routine suitable for most anything.\n-    fn relate<T: Relate<'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+    fn relate<T: Relate<'tcx>>(&mut self, a: T, b: T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n     }\n \n@@ -68,8 +67,8 @@ pub trait TypeRelation<'tcx>: Sized {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T>;\n \n     // Overridable relations. You shouldn't typically call these\n@@ -94,18 +93,18 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>;\n }\n \n-pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self>;\n }\n \n@@ -115,8 +114,8 @@ pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TypeAndMut<'tcx>,\n-        b: &ty::TypeAndMut<'tcx>,\n+        a: ty::TypeAndMut<'tcx>,\n+        b: ty::TypeAndMut<'tcx>,\n     ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n         debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n         if a.mutbl != b.mutbl {\n@@ -127,7 +126,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::Not => ty::Covariant,\n                 ast::Mutability::Mut => ty::Invariant,\n             };\n-            let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n+            let ty = relation.relate_with_variance(variance, a.ty, b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })\n         }\n     }\n@@ -143,7 +142,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = a_subst.iter().zip(b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, &a, &b)\n+        relation.relate_with_variance(variance, a, b)\n     });\n \n     Ok(tcx.mk_substs(params)?)\n@@ -152,8 +151,8 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::FnSig<'tcx>,\n-        b: &ty::FnSig<'tcx>,\n+        a: ty::FnSig<'tcx>,\n+        b: ty::FnSig<'tcx>,\n     ) -> RelateResult<'tcx, ty::FnSig<'tcx>> {\n         let tcx = relation.tcx();\n \n@@ -164,8 +163,8 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 &b.c_variadic,\n             )));\n         }\n-        let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n-        let abi = relation.relate(&a.abi, &b.abi)?;\n+        let unsafety = relation.relate(a.unsafety, b.unsafety)?;\n+        let abi = relation.relate(a.abi, b.abi)?;\n \n         if a.inputs().len() != b.inputs().len() {\n             return Err(TypeError::ArgCount);\n@@ -180,9 +179,9 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n             .chain(iter::once(((a.output(), b.output()), true)))\n             .map(|((a, b), is_output)| {\n                 if is_output {\n-                    relation.relate(&a, &b)\n+                    relation.relate(a, b)\n                 } else {\n-                    relation.relate_with_variance(ty::Contravariant, &a, &b)\n+                    relation.relate_with_variance(ty::Contravariant, a, b)\n                 }\n             });\n         Ok(ty::FnSig {\n@@ -197,32 +196,32 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ast::Unsafety,\n-        b: &ast::Unsafety,\n+        a: ast::Unsafety,\n+        b: ast::Unsafety,\n     ) -> RelateResult<'tcx, ast::Unsafety> {\n         if a != b {\n-            Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n+            Err(TypeError::UnsafetyMismatch(expected_found(relation, &a, &b)))\n         } else {\n-            Ok(*a)\n+            Ok(a)\n         }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for abi::Abi {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &abi::Abi,\n-        b: &abi::Abi,\n+        a: abi::Abi,\n+        b: abi::Abi,\n     ) -> RelateResult<'tcx, abi::Abi> {\n-        if a == b { Ok(*a) } else { Err(TypeError::AbiMismatch(expected_found(relation, a, b))) }\n+        if a == b { Ok(a) } else { Err(TypeError::AbiMismatch(expected_found(relation, &a, &b))) }\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionTy<'tcx>,\n-        b: &ty::ProjectionTy<'tcx>,\n+        a: ty::ProjectionTy<'tcx>,\n+        b: ty::ProjectionTy<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionTy<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -231,7 +230,7 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let substs = relation.relate(&a.substs, &b.substs)?;\n+            let substs = relation.relate(a.substs, b.substs)?;\n             Ok(ty::ProjectionTy { item_def_id: a.item_def_id, substs: &substs })\n         }\n     }\n@@ -240,8 +239,8 @@ impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialProjection<'tcx>,\n-        b: &ty::ExistentialProjection<'tcx>,\n+        a: ty::ExistentialProjection<'tcx>,\n+        b: ty::ExistentialProjection<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialProjection<'tcx>> {\n         if a.item_def_id != b.item_def_id {\n             Err(TypeError::ProjectionMismatched(expected_found(\n@@ -250,37 +249,18 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 &b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(ty::Invariant, &a.ty, &b.ty)?;\n-            let substs = relation.relate_with_variance(ty::Invariant, &a.substs, &b.substs)?;\n+            let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n+            let substs = relation.relate_with_variance(ty::Invariant, a.substs, b.substs)?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-        b: &Vec<ty::PolyExistentialProjection<'tcx>>,\n-    ) -> RelateResult<'tcx, Vec<ty::PolyExistentialProjection<'tcx>>> {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(TypeError::ProjectionBoundsLength(expected_found(relation, &a.len(), &b.len())))\n-        } else {\n-            a.iter().zip(b).map(|(a, b)| relation.relate(a, b)).collect()\n-        }\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitRef<'tcx>,\n-        b: &ty::TraitRef<'tcx>,\n+        a: ty::TraitRef<'tcx>,\n+        b: ty::TraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -295,8 +275,8 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ExistentialTraitRef<'tcx>,\n-        b: &ty::ExistentialTraitRef<'tcx>,\n+        a: ty::ExistentialTraitRef<'tcx>,\n+        b: ty::ExistentialTraitRef<'tcx>,\n     ) -> RelateResult<'tcx, ty::ExistentialTraitRef<'tcx>> {\n         // Different traits cannot be related.\n         if a.def_id != b.def_id {\n@@ -308,27 +288,27 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-#[derive(Debug, Clone, TypeFoldable)]\n+#[derive(Copy, Debug, Clone, TypeFoldable)]\n struct GeneratorWitness<'tcx>(&'tcx ty::List<Ty<'tcx>>);\n \n impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GeneratorWitness<'tcx>,\n-        b: &GeneratorWitness<'tcx>,\n+        a: GeneratorWitness<'tcx>,\n+        b: GeneratorWitness<'tcx>,\n     ) -> RelateResult<'tcx, GeneratorWitness<'tcx>> {\n         assert_eq!(a.0.len(), b.0.len());\n         let tcx = relation.tcx();\n-        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(&a, &b)))?;\n+        let types = tcx.mk_type_list(a.0.iter().zip(b.0).map(|(a, b)| relation.relate(a, b)))?;\n         Ok(GeneratorWitness(types))\n     }\n }\n \n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Ty<'tcx>,\n-        b: &Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n         relation.tys(a, b)\n     }\n@@ -379,7 +359,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n \n         (&ty::Foreign(a_id), &ty::Foreign(b_id)) if a_id == b_id => Ok(tcx.mk_foreign(a_id)),\n \n-        (&ty::Dynamic(ref a_obj, ref a_region), &ty::Dynamic(ref b_obj, ref b_region)) => {\n+        (&ty::Dynamic(a_obj, a_region), &ty::Dynamic(b_obj, b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n                 relation.relate_with_variance(ty::Contravariant, a_region, b_region)\n             })?;\n@@ -392,7 +372,7 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             // All Generator types with the same id represent\n             // the (anonymous) type of the same generator expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_generator(a_id, substs, movability))\n         }\n \n@@ -402,34 +382,34 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n             let a_types = a_types.map_bound(GeneratorWitness);\n             let b_types = b_types.map_bound(GeneratorWitness);\n             // Then remove the GeneratorWitness for the result\n-            let types = relation.relate(&a_types, &b_types)?.map_bound(|witness| witness.0);\n+            let types = relation.relate(a_types, b_types)?.map_bound(|witness| witness.0);\n             Ok(tcx.mk_generator_witness(types))\n         }\n \n         (&ty::Closure(a_id, a_substs), &ty::Closure(b_id, b_substs)) if a_id == b_id => {\n             // All Closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(&a_substs, &b_substs)?;\n+            let substs = relation.relate(a_substs, b_substs)?;\n             Ok(tcx.mk_closure(a_id, &substs))\n         }\n \n-        (&ty::RawPtr(ref a_mt), &ty::RawPtr(ref b_mt)) => {\n+        (&ty::RawPtr(a_mt), &ty::RawPtr(b_mt)) => {\n             let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n+            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n-            let mt = relation.relate(&a_mt, &b_mt)?;\n+            let mt = relation.relate(a_mt, b_mt)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n-            match relation.relate(&sz_a, &sz_b) {\n+            let t = relation.relate(a_t, b_t)?;\n+            match relation.relate(sz_a, sz_b) {\n                 Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n                 // FIXME(#72219) Implement improved diagnostics for mismatched array\n                 // length?\n@@ -450,16 +430,14 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::Slice(a_t), &ty::Slice(b_t)) => {\n-            let t = relation.relate(&a_t, &b_t)?;\n+            let t = relation.relate(a_t, b_t)?;\n             Ok(tcx.mk_slice(t))\n         }\n \n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n                 Ok(tcx.mk_tup(\n-                    as_.iter()\n-                        .zip(bs)\n-                        .map(|(a, b)| relation.relate(&a.expect_ty(), &b.expect_ty())),\n+                    as_.iter().zip(bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n                 )?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, &as_.len(), &bs.len())))\n@@ -476,12 +454,12 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::FnPtr(a_fty), &ty::FnPtr(b_fty)) => {\n-            let fty = relation.relate(&a_fty, &b_fty)?;\n+            let fty = relation.relate(a_fty, b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n         // these two are already handled downstream in case of lazy normalization\n-        (ty::Projection(a_data), ty::Projection(b_data)) => {\n+        (&ty::Projection(a_data), &ty::Projection(b_data)) => {\n             let projection_ty = relation.relate(a_data, b_data)?;\n             Ok(tcx.mk_projection(projection_ty.item_def_id, projection_ty.substs))\n         }\n@@ -603,8 +581,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             ty::ConstKind::Unevaluated(b_def_id, b_substs, b_promoted),\n         ) if a_def_id == b_def_id && a_promoted == b_promoted => {\n             let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-            Ok(ty::ConstKind::Unevaluated(a_def_id, &substs, a_promoted))\n+                relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n+            Ok(ty::ConstKind::Unevaluated(a_def_id, substs, a_promoted))\n         }\n         _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     };\n@@ -614,8 +592,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &Self,\n-        b: &Self,\n+        a: Self,\n+        b: Self,\n     ) -> RelateResult<'tcx, Self> {\n         let tcx = relation.tcx();\n \n@@ -629,16 +607,16 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n         b_v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         b_v.dedup();\n         if a_v.len() != b_v.len() {\n-            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b)));\n         }\n \n         let v = a_v.into_iter().zip(b_v.into_iter()).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a, ep_b) {\n-                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n-                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n-                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n-                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b))),\n+                (Trait(a), Trait(b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(a), Projection(b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(a), AutoTrait(b)) if a == b => Ok(AutoTrait(a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, &a, &b))),\n             }\n         });\n         Ok(tcx.mk_existential_predicates(v)?)\n@@ -648,8 +626,8 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ClosureSubsts<'tcx>,\n-        b: &ty::ClosureSubsts<'tcx>,\n+        a: ty::ClosureSubsts<'tcx>,\n+        b: ty::ClosureSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::ClosureSubsts { substs })\n@@ -659,8 +637,8 @@ impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::GeneratorSubsts<'tcx>,\n-        b: &ty::GeneratorSubsts<'tcx>,\n+        a: ty::GeneratorSubsts<'tcx>,\n+        b: ty::GeneratorSubsts<'tcx>,\n     ) -> RelateResult<'tcx, ty::GeneratorSubsts<'tcx>> {\n         let substs = relate_substs(relation, None, a.substs, b.substs)?;\n         Ok(ty::GeneratorSubsts { substs })\n@@ -670,8 +648,8 @@ impl<'tcx> Relate<'tcx> for ty::GeneratorSubsts<'tcx> {\n impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &SubstsRef<'tcx>,\n-        b: &SubstsRef<'tcx>,\n+        a: SubstsRef<'tcx>,\n+        b: SubstsRef<'tcx>,\n     ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n         relate_substs(relation, None, a, b)\n     }\n@@ -680,72 +658,48 @@ impl<'tcx> Relate<'tcx> for SubstsRef<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Region<'tcx>,\n-        b: &ty::Region<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        relation.regions(*a, *b)\n+        relation.regions(a, b)\n     }\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &&'tcx ty::Const<'tcx>,\n-        b: &&'tcx ty::Const<'tcx>,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        relation.consts(*a, *b)\n+        relation.consts(a, b)\n     }\n }\n \n impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>> {\n         relation.binders(a, b)\n     }\n }\n \n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Rc<T>,\n-        b: &Rc<T>,\n-    ) -> RelateResult<'tcx, Rc<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Rc::new(relation.relate(a, b)?))\n-    }\n-}\n-\n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: &Box<T>,\n-        b: &Box<T>,\n-    ) -> RelateResult<'tcx, Box<T>> {\n-        let a: &T = a;\n-        let b: &T = b;\n-        Ok(Box::new(relation.relate(a, b)?))\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &GenericArg<'tcx>,\n-        b: &GenericArg<'tcx>,\n+        a: GenericArg<'tcx>,\n+        b: GenericArg<'tcx>,\n     ) -> RelateResult<'tcx, GenericArg<'tcx>> {\n         match (a.unpack(), b.unpack()) {\n             (GenericArgKind::Lifetime(a_lt), GenericArgKind::Lifetime(b_lt)) => {\n-                Ok(relation.relate(&a_lt, &b_lt)?.into())\n+                Ok(relation.relate(a_lt, b_lt)?.into())\n             }\n             (GenericArgKind::Type(a_ty), GenericArgKind::Type(b_ty)) => {\n-                Ok(relation.relate(&a_ty, &b_ty)?.into())\n+                Ok(relation.relate(a_ty, b_ty)?.into())\n             }\n             (GenericArgKind::Const(a_ct), GenericArgKind::Const(b_ct)) => {\n-                Ok(relation.relate(&a_ct, &b_ct)?.into())\n+                Ok(relation.relate(a_ct, b_ct)?.into())\n             }\n             (GenericArgKind::Lifetime(unpacked), x) => {\n                 bug!(\"impossible case reached: can't relate: {:?} with {:?}\", unpacked, x)\n@@ -763,22 +717,22 @@ impl<'tcx> Relate<'tcx> for GenericArg<'tcx> {\n impl<'tcx> Relate<'tcx> for ty::TraitPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::TraitPredicate<'tcx>,\n-        b: &ty::TraitPredicate<'tcx>,\n+        a: ty::TraitPredicate<'tcx>,\n+        b: ty::TraitPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::TraitPredicate<'tcx>> {\n-        Ok(ty::TraitPredicate { trait_ref: relation.relate(&a.trait_ref, &b.trait_ref)? })\n+        Ok(ty::TraitPredicate { trait_ref: relation.relate(a.trait_ref, b.trait_ref)? })\n     }\n }\n \n impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: &ty::ProjectionPredicate<'tcx>,\n-        b: &ty::ProjectionPredicate<'tcx>,\n+        a: ty::ProjectionPredicate<'tcx>,\n+        b: ty::ProjectionPredicate<'tcx>,\n     ) -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>> {\n         Ok(ty::ProjectionPredicate {\n-            projection_ty: relation.relate(&a.projection_ty, &b.projection_ty)?,\n-            ty: relation.relate(&a.ty, &b.ty)?,\n+            projection_ty: relation.relate(a.projection_ty, b.projection_ty)?,\n+            ty: relation.relate(a.ty, b.ty)?,\n         })\n     }\n }"}, {"sha": "91b1a1fbd97059492a75221f2ed13ebe3d9f46d2", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -31,7 +31,7 @@ pub(super) fn relate_types<'tcx>(\n         NllTypeRelatingDelegate::new(infcx, borrowck_context, locations, category),\n         v,\n     )\n-    .relate(&a, &b)?;\n+    .relate(a, b)?;\n     Ok(())\n }\n "}, {"sha": "c41a27c6f431f4e840f8953ef912f5415bb315b8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -748,8 +748,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             && stack.iter().skip(1).any(|prev| {\n                 stack.obligation.param_env == prev.obligation.param_env\n                     && self.match_fresh_trait_refs(\n-                        &stack.fresh_trait_ref,\n-                        &prev.fresh_trait_ref,\n+                        stack.fresh_trait_ref,\n+                        prev.fresh_trait_ref,\n                         prev.obligation.param_env,\n                     )\n             })\n@@ -1944,8 +1944,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_fresh_trait_refs(\n         &self,\n-        previous: &ty::PolyTraitRef<'tcx>,\n-        current: &ty::PolyTraitRef<'tcx>,\n+        previous: ty::PolyTraitRef<'tcx>,\n+        current: ty::PolyTraitRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n         let mut matcher = ty::_match::Match::new(self.tcx(), param_env);"}, {"sha": "e6b3224050e9bc755fd70a299060f86fe99fb834", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -964,7 +964,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(&a_sig, &b_sig)\n+                .lub(a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type."}, {"sha": "f2696f27ffd53fb98ab8cb658bb0fcbec5e872a8", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d7ba5fcb40362e0c1802a228efbb8dde7f5711d/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1d7ba5fcb40362e0c1802a228efbb8dde7f5711d", "patch": "@@ -227,10 +227,10 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n             match (predicate.kind(), p.kind()) {\n-                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n+                (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n-                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n+                (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n                     relator.relate(a, b).is_ok()\n                 }\n                 _ => predicate == p,\n@@ -310,8 +310,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n-        a: &T,\n-        b: &T,\n+        a: T,\n+        b: T,\n     ) -> RelateResult<'tcx, T> {\n         // Here we ignore variance because we require drop impl's types\n         // to be *exactly* the same as to the ones in the struct definition.\n@@ -354,8 +354,8 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: &ty::Binder<T>,\n-        b: &ty::Binder<T>,\n+        a: ty::Binder<T>,\n+        b: ty::Binder<T>,\n     ) -> RelateResult<'tcx, ty::Binder<T>>\n     where\n         T: Relate<'tcx>,\n@@ -364,9 +364,9 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n         // Anonymizing the LBRs is necessary to solve (Issue #59497).\n         // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n-        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n-        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n+        let anon_a = self.tcx.anonymize_late_bound_regions(&a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n+        self.relate(*anon_a.skip_binder(), *anon_b.skip_binder())?;\n \n         Ok(a.clone())\n     }"}]}