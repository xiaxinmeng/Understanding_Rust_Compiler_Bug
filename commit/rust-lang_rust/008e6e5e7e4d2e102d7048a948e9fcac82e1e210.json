{"sha": "008e6e5e7e4d2e102d7048a948e9fcac82e1e210", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOGU2ZTVlN2U0ZDJlMTAyZDcwNDhhOTQ4ZTlmY2FjODJlMWUyMTA=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-05-25T23:44:31Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-05-25T23:44:31Z"}, "message": "Make AtomicPtr use *mut, instead of ~", "tree": {"sha": "03f0b3ce552b9f54f65992cf442bdd54df70177f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03f0b3ce552b9f54f65992cf442bdd54df70177f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/008e6e5e7e4d2e102d7048a948e9fcac82e1e210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/008e6e5e7e4d2e102d7048a948e9fcac82e1e210", "html_url": "https://github.com/rust-lang/rust/commit/008e6e5e7e4d2e102d7048a948e9fcac82e1e210", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/008e6e5e7e4d2e102d7048a948e9fcac82e1e210/comments", "author": null, "committer": null, "parents": [{"sha": "523360415cca24ac0cbd198804d797dd05c48559", "url": "https://api.github.com/repos/rust-lang/rust/commits/523360415cca24ac0cbd198804d797dd05c48559", "html_url": "https://github.com/rust-lang/rust/commit/523360415cca24ac0cbd198804d797dd05c48559"}], "stats": {"total": 62, "additions": 15, "deletions": 47}, "files": [{"sha": "fd92bf2bdc6e8b74cadb8f9ced4e0fc032046bf8", "filename": "src/libstd/unstable/atomics.rs", "status": "modified", "additions": 15, "deletions": 47, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/008e6e5e7e4d2e102d7048a948e9fcac82e1e210/src%2Flibstd%2Funstable%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/008e6e5e7e4d2e102d7048a948e9fcac82e1e210/src%2Flibstd%2Funstable%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fatomics.rs?ref=008e6e5e7e4d2e102d7048a948e9fcac82e1e210", "patch": "@@ -17,23 +17,23 @@ use cast;\n use option::{Option,Some,None};\n \n pub struct AtomicFlag {\n-    priv v:int\n+    priv v: int\n }\n \n pub struct AtomicBool {\n-    priv v:uint\n+    priv v: uint\n }\n \n pub struct AtomicInt {\n-    priv v:int\n+    priv v: int\n }\n \n pub struct AtomicUint {\n-    priv v:uint\n+    priv v: uint\n }\n \n pub struct AtomicPtr<T> {\n-    priv p:~T\n+    priv p: *mut T\n }\n \n pub enum Ordering {\n@@ -173,60 +173,28 @@ impl AtomicUint {\n }\n \n impl<T> AtomicPtr<T> {\n-    fn new(p:~T) -> AtomicPtr<T> {\n+    fn new(p:*mut T) -> AtomicPtr<T> {\n         AtomicPtr { p:p }\n     }\n \n-    /**\n-     * Atomically swaps the stored pointer with the one given.\n-     *\n-     * Returns None if the pointer stored has been taken\n-     */\n     #[inline(always)]\n-    fn swap(&mut self, ptr:~T, order:Ordering) -> Option<~T> {\n-        unsafe {\n-            let p = atomic_swap(&mut self.p, ptr, order);\n-            let pv : &uint = cast::transmute(&p);\n-\n-            if *pv == 0 {\n-                None\n-            } else {\n-                Some(p)\n-            }\n-        }\n+    fn load(&self, order:Ordering) -> *mut T {\n+        unsafe { atomic_load(&self.p, order) }\n     }\n \n-    /**\n-     * Atomically takes the stored pointer out.\n-     *\n-     * Returns None if it was already taken.\n-     */\n     #[inline(always)]\n-    fn take(&mut self, order:Ordering) -> Option<~T> {\n-        unsafe { self.swap(cast::transmute(0), order) }\n+    fn store(&mut self, ptr:*mut T, order:Ordering) {\n+        unsafe { atomic_store(&mut self.p, ptr, order); }\n     }\n \n-    /**\n-     * Atomically stores the given pointer, this will overwrite\n-     * and previous value stored.\n-     */\n     #[inline(always)]\n-    fn give(&mut self, ptr:~T, order:Ordering) {\n-        let _ = self.swap(ptr, order);\n+    fn swap(&mut self, ptr:*mut T, order:Ordering) -> *mut T {\n+        unsafe { atomic_swap(&mut self.p, ptr, order) }\n     }\n \n-    /**\n-     * Checks to see if the stored pointer has been taken.\n-     */\n-    fn taken(&self, order:Ordering) -> bool {\n-        unsafe {\n-            let p : ~T = atomic_load(&self.p, order);\n-\n-            let pv : &uint = cast::transmute(&p);\n-\n-            cast::forget(p);\n-            *pv == 0\n-        }\n+    #[inline(always)]\n+    fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order:Ordering) -> *mut T {\n+        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n     }\n }\n "}]}