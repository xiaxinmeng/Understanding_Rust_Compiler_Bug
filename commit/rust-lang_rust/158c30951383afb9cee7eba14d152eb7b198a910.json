{"sha": "158c30951383afb9cee7eba14d152eb7b198a910", "node_id": "C_kwDOAAsO6NoAKDE1OGMzMDk1MTM4M2FmYjljZWU3ZWJhMTRkMTUyZWI3YjE5OGE5MTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T21:54:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T21:54:56Z"}, "message": "Auto merge of #110197 - cjgillot:codegen-discr, r=pnkfelix\n\nDo not attempt to commute comparison and cast to codegen discriminants\n\nThe general algorithm to compute a discriminant is:\n```\nrelative_tag = tag - niche_start\nis_niche = relative_tag <= (ule) relative_max\ndiscr = if is_niche {\n    cast(relative_tag) + niche_variants.start()\n} else {\n    untagged_variant\n}\n```\n\nWe have an optimization branch which attempts to merge the addition and the subtraction by commuting them with the cast. We currently get this optimization wrong.\n\nThis PR takes the easiest and safest way: remove the optimization, and let LLVM handle it. (Perf may not agree with that course of action :sweat_smile:)\n\nThere may be a less invasive solution, but I don't have the necessary knowledge of LLVM semantics to find it. Cranelift has the same optimization, which should be handled similarly.\ncc `@nikic` and `@bjorn3` if you have a better solution.\n\nFixes https://github.com/rust-lang/rust/issues/110128", "tree": {"sha": "b06561d7258ce152a9fe560a6fa6ee3c0ad3d05e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b06561d7258ce152a9fe560a6fa6ee3c0ad3d05e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/158c30951383afb9cee7eba14d152eb7b198a910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/158c30951383afb9cee7eba14d152eb7b198a910", "html_url": "https://github.com/rust-lang/rust/commit/158c30951383afb9cee7eba14d152eb7b198a910", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/158c30951383afb9cee7eba14d152eb7b198a910/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84dd17b56a931a631a23dfd5ef2018fd3ef49108", "url": "https://api.github.com/repos/rust-lang/rust/commits/84dd17b56a931a631a23dfd5ef2018fd3ef49108", "html_url": "https://github.com/rust-lang/rust/commit/84dd17b56a931a631a23dfd5ef2018fd3ef49108"}, {"sha": "a8857d2fe153717e428742f6a8537abbe6793c50", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8857d2fe153717e428742f6a8537abbe6793c50", "html_url": "https://github.com/rust-lang/rust/commit/a8857d2fe153717e428742f6a8537abbe6793c50"}], "stats": {"total": 221, "additions": 22, "deletions": 199}, "files": [{"sha": "670384663e83faba8801495a6bf76d49fe8af9d1", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -103,7 +103,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n-    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -122,21 +121,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            let tag_size = tag_scalar.size(fx);\n-            let max_unsigned = tag_size.unsigned_int_max();\n-            let max_signed = tag_size.signed_int_max() as u128;\n-            let min_signed = max_signed + 1;\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-            let range = tag_scalar.valid_range(fx);\n-\n-            let sle = |lhs: u128, rhs: u128| -> bool {\n-                // Signed and unsigned comparisons give the same results,\n-                // except that in signed comparisons an integer with the\n-                // sign bit set is less than one with the sign bit clear.\n-                // Toggle the sign bit to do a signed comparison.\n-                (lhs ^ min_signed) <= (rhs ^ min_signed)\n-            };\n \n             // We have a subrange `niche_start..=niche_end` inside `range`.\n             // If the value of the tag is inside this subrange, it's a\n@@ -153,45 +138,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             // }\n             // However, we will likely be able to emit simpler code.\n \n-            // Find the least and greatest values in `range`, considered\n-            // both as signed and unsigned.\n-            let (low_unsigned, high_unsigned) =\n-                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n-            let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                (range.start, range.end)\n-            } else {\n-                (min_signed, max_signed)\n-            };\n-\n-            let niches_ule = niche_start <= niche_end;\n-            let niches_sle = sle(niche_start, niche_end);\n-            let cast_smaller = cast_to_size <= tag_size;\n-\n-            // In the algorithm above, we can change\n-            // cast(relative_tag) + niche_variants.start()\n-            // into\n-            // cast(tag + (niche_variants.start() - niche_start))\n-            // if either the casted type is no larger than the original\n-            // type, or if the niche values are contiguous (in either the\n-            // signed or unsigned sense).\n-            let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n-                if !can_incr {\n-                    None\n-                } else if niche_start == low_unsigned {\n-                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_unsigned {\n-                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n-                } else if niche_start == low_signed {\n-                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_signed {\n-                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n-                } else {\n-                    None\n-                }\n-            };\n-\n             let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                 // Best case scenario: only one tagged variant. This will\n                 // likely become just a comparison and a jump.\n@@ -206,41 +152,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 let tagged_discr =\n                     fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n                 (is_niche, tagged_discr, 0)\n-            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                // The niche values are either the lowest or the highest in\n-                // `range`. We can avoid the first subtraction in the\n-                // algorithm.\n-                // The algorithm is now this:\n-                // is_niche = tag <= niche_end\n-                // discr = if is_niche {\n-                //     cast(tag + (niche_variants.start() - niche_start))\n-                // } else {\n-                //     untagged_variant\n-                // }\n-                // (the first line may instead be tag >= niche_start,\n-                // and may be a signed or unsigned comparison)\n-                // The arithmetic must be done before the cast, so we can\n-                // have the correct wrapping behavior. See issue #104519 for\n-                // the consequences of getting this wrong.\n-                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n-                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                let incr_tag = if delta == 0 {\n-                    tag\n-                } else {\n-                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n-                        types::I128 => {\n-                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n-                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n-                            fx.bcx.ins().iconcat(lsb, msb)\n-                        }\n-                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n-                    };\n-                    fx.bcx.ins().iadd(tag, delta)\n-                };\n-\n-                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n-\n-                (is_niche, cast_tag, 0)\n             } else {\n                 // The special cases don't apply, so we'll have to go with\n                 // the general algorithm."}, {"sha": "a58a61cd567fc6139120ef4d2862759777bcc0fb", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -211,7 +211,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     ) -> V {\n         let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n-        let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_poison(cast_to);\n@@ -261,21 +260,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n-                let tag_size = tag_scalar.size(bx.cx());\n-                let max_unsigned = tag_size.unsigned_int_max();\n-                let max_signed = tag_size.signed_int_max() as u128;\n-                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-                let range = tag_scalar.valid_range(bx.cx());\n-\n-                let sle = |lhs: u128, rhs: u128| -> bool {\n-                    // Signed and unsigned comparisons give the same results,\n-                    // except that in signed comparisons an integer with the\n-                    // sign bit set is less than one with the sign bit clear.\n-                    // Toggle the sign bit to do a signed comparison.\n-                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n-                };\n \n                 // We have a subrange `niche_start..=niche_end` inside `range`.\n                 // If the value of the tag is inside this subrange, it's a\n@@ -291,49 +276,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 //     untagged_variant\n                 // }\n                 // However, we will likely be able to emit simpler code.\n-\n-                // Find the least and greatest values in `range`, considered\n-                // both as signed and unsigned.\n-                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n-                    (range.start, range.end)\n-                } else {\n-                    (0, max_unsigned)\n-                };\n-                let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                    (range.start, range.end)\n-                } else {\n-                    (min_signed, max_signed)\n-                };\n-\n-                let niches_ule = niche_start <= niche_end;\n-                let niches_sle = sle(niche_start, niche_end);\n-                let cast_smaller = cast_to_size <= tag_size;\n-\n-                // In the algorithm above, we can change\n-                // cast(relative_tag) + niche_variants.start()\n-                // into\n-                // cast(tag + (niche_variants.start() - niche_start))\n-                // if either the casted type is no larger than the original\n-                // type, or if the niche values are contiguous (in either the\n-                // signed or unsigned sense).\n-                let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n-                    if !can_incr {\n-                        None\n-                    } else if niche_start == low_unsigned {\n-                        Some((IntPredicate::IntULE, niche_end))\n-                    } else if niche_end == high_unsigned {\n-                        Some((IntPredicate::IntUGE, niche_start))\n-                    } else if niche_start == low_signed {\n-                        Some((IntPredicate::IntSLE, niche_end))\n-                    } else if niche_end == high_signed {\n-                        Some((IntPredicate::IntSGE, niche_start))\n-                    } else {\n-                        None\n-                    }\n-                };\n-\n                 let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                     // Best case scenario: only one tagged variant. This will\n                     // likely become just a comparison and a jump.\n@@ -349,40 +291,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let tagged_discr =\n                         bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n                     (is_niche, tagged_discr, 0)\n-                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                    // The niche values are either the lowest or the highest in\n-                    // `range`. We can avoid the first subtraction in the\n-                    // algorithm.\n-                    // The algorithm is now this:\n-                    // is_niche = tag <= niche_end\n-                    // discr = if is_niche {\n-                    //     cast(tag + (niche_variants.start() - niche_start))\n-                    // } else {\n-                    //     untagged_variant\n-                    // }\n-                    // (the first line may instead be tag >= niche_start,\n-                    // and may be a signed or unsigned comparison)\n-                    // The arithmetic must be done before the cast, so we can\n-                    // have the correct wrapping behavior. See issue #104519 for\n-                    // the consequences of getting this wrong.\n-                    let is_niche =\n-                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n-                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                    let incr_tag = if delta == 0 {\n-                        tag\n-                    } else {\n-                        bx.add(tag, bx.cx().const_uint_big(tag_llty, delta))\n-                    };\n-\n-                    let cast_tag = if cast_smaller {\n-                        bx.intcast(incr_tag, cast_to, false)\n-                    } else if niches_ule {\n-                        bx.zext(incr_tag, cast_to)\n-                    } else {\n-                        bx.sext(incr_tag, cast_to)\n-                    };\n-\n-                    (is_niche, cast_tag, 0)\n                 } else {\n                     // The special cases don't apply, so we'll have to go with\n                     // the general algorithm."}, {"sha": "29664c854c873433be64df2e99a1d6cfb6a0881d", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -10,7 +10,7 @@ use std::path::{Path, PathBuf};\n // FIXME: The following limits should be reduced eventually.\n const ENTRY_LIMIT: usize = 885;\n const ROOT_ENTRY_LIMIT: usize = 891;\n-const ISSUES_ENTRY_LIMIT: usize = 1978;\n+const ISSUES_ENTRY_LIMIT: usize = 1977;\n \n fn check_entries(tests_path: &Path, bad: &mut bool) {\n     let mut directories: HashMap<PathBuf, usize> = HashMap::new();"}, {"sha": "36c6be19012f152ae733bfa82ce18748e6fa006d", "filename": "tests/codegen/enum-match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fcodegen%2Fenum-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fcodegen%2Fenum-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fenum-match.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -34,8 +34,11 @@ pub enum Enum1 {\n \n // CHECK: define noundef i8 @match1{{.*}}\n // CHECK-NEXT: start:\n-// CHECK-NEXT: [[DISCR:%.*]] = {{.*}}call i8 @llvm.usub.sat.i8(i8 %0, i8 1)\n-// CHECK-NEXT: switch i8 [[DISCR]], label {{.*}} [\n+// CHECK-NEXT: %1 = add i8 %0, -2\n+// CHECK-NEXT: %2 = zext i8 %1 to i64\n+// CHECK-NEXT: %3 = icmp ult i8 %1, 2\n+// CHECK-NEXT: %4 = add nuw nsw i64 %2, 1\n+// CHECK-NEXT: %_2 = select i1 %3, i64 %4, i64 0\n #[no_mangle]\n pub fn match1(e: Enum1) -> u8 {\n     use Enum1::*;"}, {"sha": "507c0988fcc10936bf880f4ed2929c5dd9eb05e6", "filename": "tests/ui/enum-discriminant/issue-104519.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fui%2Fenum-discriminant%2Fissue-104519.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fui%2Fenum-discriminant%2Fissue-104519.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum-discriminant%2Fissue-104519.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -23,14 +23,4 @@ fn some_match(result: OpenResult) -> u8 {\n fn main() {\n     let result = OpenResult::Ok(());\n     assert_eq!(some_match(result), 0);\n-\n-    let result = OpenResult::Ok(());\n-    match result {\n-        OpenResult::Ok(()) => (),\n-        _ => unreachable!(\"message a\"),\n-    }\n-    match result {\n-        OpenResult::Ok(()) => (),\n-        _ => unreachable!(\"message b\"),\n-    }\n }"}, {"sha": "8a633a916c8388fda29282d64dfd5334ed655bf5", "filename": "tests/ui/enum-discriminant/issue-61696.rs", "status": "renamed", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fui%2Fenum-discriminant%2Fissue-61696.rs", "raw_url": "https://github.com/rust-lang/rust/raw/158c30951383afb9cee7eba14d152eb7b198a910/tests%2Fui%2Fenum-discriminant%2Fissue-61696.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fenum-discriminant%2Fissue-61696.rs?ref=158c30951383afb9cee7eba14d152eb7b198a910", "patch": "@@ -55,12 +55,23 @@ pub enum E2<X> {\n     V4,\n }\n \n-fn main() {\n-    if let E1::V2 { .. } = (E1::V1 { f: true }) {\n-        unreachable!()\n+#[inline(never)]\n+fn match_e1(y: E1) -> u8 {\n+    match y {\n+        E1::V2 { .. } => 1,\n+        _ => 0,\n     }\n+}\n \n-    if let E2::V1 { .. } = E2::V3::<Infallible> {\n-        unreachable!()\n+#[inline(never)]\n+fn match_e2(y: E2<Infallible>) -> u8 {\n+    match y {\n+        E2::V1 { .. } => 1,\n+        _ => 0,\n     }\n }\n+\n+fn main() {\n+    assert_eq!(match_e1(E1::V1 { f: true }), 0);\n+    assert_eq!(match_e2(E2::V3), 0);\n+}", "previous_filename": "tests/ui/issues/issue-61696.rs"}]}