{"sha": "c296e777675860164f8e45571efd29c4c08ee7cc", "node_id": "C_kwDOAAsO6NoAKGMyOTZlNzc3Njc1ODYwMTY0ZjhlNDU1NzFlZmQyOWM0YzA4ZWU3Y2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-06T23:58:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-06T23:58:52Z"}, "message": "Auto merge of #12695 - xuhongxu96:fix-12140, r=jonas-schievink\n\nComplete type param/associated type in trait generic arg per arg index\n\n- Fix #12140\n- Also fix tidy check does not work for marks in multiline", "tree": {"sha": "981beb9dfbd08be42ccfc10824433ee721b4dd9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/981beb9dfbd08be42ccfc10824433ee721b4dd9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c296e777675860164f8e45571efd29c4c08ee7cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c296e777675860164f8e45571efd29c4c08ee7cc", "html_url": "https://github.com/rust-lang/rust/commit/c296e777675860164f8e45571efd29c4c08ee7cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c296e777675860164f8e45571efd29c4c08ee7cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c46570e694f3d4f23c66c0424f7483c3b20d58f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c46570e694f3d4f23c66c0424f7483c3b20d58f1", "html_url": "https://github.com/rust-lang/rust/commit/c46570e694f3d4f23c66c0424f7483c3b20d58f1"}, {"sha": "3248601a03233778fa6a64516a783c2a49c265b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3248601a03233778fa6a64516a783c2a49c265b7", "html_url": "https://github.com/rust-lang/rust/commit/3248601a03233778fa6a64516a783c2a49c265b7"}], "stats": {"total": 397, "additions": 347, "deletions": 50}, "files": [{"sha": "eec960aa7dd0066dc8762d37c24060fbbadacecc", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=c296e777675860164f8e45571efd29c4c08ee7cc", "patch": "@@ -47,6 +47,7 @@ pub struct LifetimeParamData {\n pub struct ConstParamData {\n     pub name: Name,\n     pub ty: Interned<TypeRef>,\n+    pub has_default: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n@@ -70,6 +71,13 @@ impl TypeOrConstParamData {\n         }\n     }\n \n+    pub fn has_default(&self) -> bool {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => x.default.is_some(),\n+            TypeOrConstParamData::ConstParamData(x) => x.has_default,\n+        }\n+    }\n+\n     pub fn type_param(&self) -> Option<&TypeParamData> {\n         match self {\n             TypeOrConstParamData::TypeParamData(x) => Some(x),\n@@ -232,7 +240,11 @@ impl GenericParams {\n                     let ty = const_param\n                         .ty()\n                         .map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n-                    let param = ConstParamData { name, ty: Interned::new(ty) };\n+                    let param = ConstParamData {\n+                        name,\n+                        ty: Interned::new(ty),\n+                        has_default: const_param.default_val().is_some(),\n+                    };\n                     self.type_or_consts.alloc(param.into());\n                 }\n             }"}, {"sha": "96424d087ef57701c8f5de8c1c0144131573960d", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=c296e777675860164f8e45571efd29c4c08ee7cc", "patch": "@@ -41,6 +41,7 @@ use hir_def::{\n     adt::{ReprKind, VariantData},\n     body::{BodyDiagnostic, SyntheticSyntax},\n     expr::{BindingAnnotation, LabelId, Pat, PatId},\n+    generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n     lang_item::LangItemTarget,\n     nameres::{self, diagnostics::DefDiagnostic},\n@@ -1707,6 +1708,26 @@ impl Trait {\n     pub fn is_unsafe(&self, db: &dyn HirDatabase) -> bool {\n         db.trait_data(self.id).is_unsafe\n     }\n+\n+    pub fn type_or_const_param_count(\n+        &self,\n+        db: &dyn HirDatabase,\n+        count_required_only: bool,\n+    ) -> usize {\n+        db.generic_params(GenericDefId::from(self.id))\n+            .type_or_consts\n+            .iter()\n+            .filter(|(_, ty)| match ty {\n+                TypeOrConstParamData::TypeParamData(ty)\n+                    if ty.provenance != TypeParamProvenance::TypeParamList =>\n+                {\n+                    false\n+                }\n+                _ => true,\n+            })\n+            .filter(|(_, ty)| !count_required_only || !ty.has_default())\n+            .count()\n+    }\n }\n \n impl HasVisibility for Trait {"}, {"sha": "0469d349519a8319af2433d1880429d3134a1b88", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 73, "deletions": 29, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=c296e777675860164f8e45571efd29c4c08ee7cc", "patch": "@@ -1,7 +1,7 @@\n //! Completion of names from the current scope in type position.\n \n use hir::{HirDisplay, ScopeDef};\n-use syntax::{ast, AstNode};\n+use syntax::{ast, AstNode, SyntaxKind};\n \n use crate::{\n     context::{PathCompletionCtx, Qualified, TypeAscriptionTarget, TypeLocation},\n@@ -120,39 +120,83 @@ pub(crate) fn complete_type_path(\n         }\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n-            acc.add_nameref_keywords_with_colon(ctx);\n-            if let TypeLocation::TypeBound = location {\n-                ctx.process_all_names(&mut |name, res| {\n-                    let add_resolution = match res {\n-                        ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n-                        ScopeDef::ModuleDef(\n-                            hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_),\n-                        ) => true,\n-                        _ => false,\n-                    };\n-                    if add_resolution {\n-                        acc.add_path_resolution(ctx, path_ctx, name, res);\n-                    }\n-                });\n-                return;\n-            }\n-            if let TypeLocation::GenericArgList(Some(arg_list)) = location {\n-                if let Some(path_seg) = arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n-                {\n-                    if path_seg.syntax().ancestors().find_map(ast::TypeBound::cast).is_some() {\n-                        if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(trait_))) =\n-                            ctx.sema.resolve_path(&path_seg.parent_path())\n+            match location {\n+                TypeLocation::TypeBound => {\n+                    acc.add_nameref_keywords_with_colon(ctx);\n+                    ctx.process_all_names(&mut |name, res| {\n+                        let add_resolution = match res {\n+                            ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n+                                mac.is_fn_like(ctx.db)\n+                            }\n+                            ScopeDef::ModuleDef(\n+                                hir::ModuleDef::Trait(_) | hir::ModuleDef::Module(_),\n+                            ) => true,\n+                            _ => false,\n+                        };\n+                        if add_resolution {\n+                            acc.add_path_resolution(ctx, path_ctx, name, res);\n+                        }\n+                    });\n+                    return;\n+                }\n+                TypeLocation::GenericArgList(Some(arg_list)) => {\n+                    let in_assoc_type_arg = ctx\n+                        .original_token\n+                        .parent_ancestors()\n+                        .any(|node| node.kind() == SyntaxKind::ASSOC_TYPE_ARG);\n+\n+                    if !in_assoc_type_arg {\n+                        if let Some(path_seg) =\n+                            arg_list.syntax().parent().and_then(ast::PathSegment::cast)\n                         {\n-                            trait_.items_with_supertraits(ctx.sema.db).into_iter().for_each(|it| {\n-                                if let hir::AssocItem::TypeAlias(alias) = it {\n-                                    cov_mark::hit!(complete_assoc_type_in_generics_list);\n-                                    acc.add_type_alias_with_eq(ctx, alias)\n+                            if path_seg\n+                                .syntax()\n+                                .ancestors()\n+                                .find_map(ast::TypeBound::cast)\n+                                .is_some()\n+                            {\n+                                if let Some(hir::PathResolution::Def(hir::ModuleDef::Trait(\n+                                    trait_,\n+                                ))) = ctx.sema.resolve_path(&path_seg.parent_path())\n+                                {\n+                                    let arg_idx = arg_list\n+                                        .generic_args()\n+                                        .filter(|arg| {\n+                                            arg.syntax().text_range().end()\n+                                                < ctx.original_token.text_range().start()\n+                                        })\n+                                        .count();\n+\n+                                    let n_required_params =\n+                                        trait_.type_or_const_param_count(ctx.sema.db, true);\n+                                    if arg_idx >= n_required_params {\n+                                        trait_\n+                                            .items_with_supertraits(ctx.sema.db)\n+                                            .into_iter()\n+                                            .for_each(|it| {\n+                                                if let hir::AssocItem::TypeAlias(alias) = it {\n+                                                    cov_mark::hit!(\n+                                                        complete_assoc_type_in_generics_list\n+                                                    );\n+                                                    acc.add_type_alias_with_eq(ctx, alias);\n+                                                }\n+                                            });\n+\n+                                        let n_params =\n+                                            trait_.type_or_const_param_count(ctx.sema.db, false);\n+                                        if arg_idx >= n_params {\n+                                            return; // only show assoc types\n+                                        }\n+                                    }\n                                 }\n-                            });\n+                            }\n                         }\n                     }\n                 }\n-            }\n+                _ => {}\n+            };\n+\n+            acc.add_nameref_keywords_with_colon(ctx);\n             ctx.process_all_names(&mut |name, def| {\n                 if scope_def_applicable(def) {\n                     acc.add_path_resolution(ctx, path_ctx, name, def);"}, {"sha": "fcd4743f74f3f1453a6981b2497a9da77d302ba4", "filename": "crates/ide-completion/src/tests/type_pos.rs", "status": "modified", "additions": 220, "deletions": 3, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Ftype_pos.rs?ref=c296e777675860164f8e45571efd29c4c08ee7cc", "patch": "@@ -377,22 +377,36 @@ trait Trait2: Trait1 {\n     type Foo;\n }\n \n+fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n+\"#,\n+        expect![[r#\"\n+            ta Foo =  (as Trait2)   type Foo\n+            ta Super =  (as Trait1) type Super\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+trait Trait1 {\n+    type Super;\n+}\n+trait Trait2<T>: Trait1 {\n+    type Foo;\n+}\n+\n fn foo<'lt, T: Trait2<$0>, const CONST_PARAM: usize>(_: T) {}\n \"#,\n         expect![[r#\"\n             ct CONST\n             cp CONST_PARAM\n             en Enum\n-            ma makro!(\u2026)            macro_rules! makro\n+            ma makro!(\u2026)   macro_rules! makro\n             md module\n             st Record\n             st Tuple\n             st Unit\n             tt Trait\n             tt Trait1\n             tt Trait2\n-            ta Foo =  (as Trait2)   type Foo\n-            ta Super =  (as Trait1) type Super\n             tp T\n             un Union\n             bt u32\n@@ -472,3 +486,206 @@ fn func(_: Enum::$0) {}\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn completes_type_parameter_or_associated_type() {\n+    check(\n+        r#\"\n+trait MyTrait<T, U> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u$0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait MyTrait<T, U> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u8, u$0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait MyTrait<T, U> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u8, u8, I$0\n+\"#,\n+        expect![[r#\"\n+            ta Item1 =  (as MyTrait) type Item1\n+            ta Item2 =  (as MyTrait) type Item2\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_type_parameter_or_associated_type_with_default_value() {\n+    check(\n+        r#\"\n+trait MyTrait<T, U = u8> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u$0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait MyTrait<T, U = u8> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u8, u$0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026)             macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            ta Item1 =  (as MyTrait) type Item1\n+            ta Item2 =  (as MyTrait) type Item2\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait MyTrait<T, U = u8> {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<u8, u8, I$0\n+\"#,\n+        expect![[r#\"\n+            ta Item1 =  (as MyTrait) type Item1\n+            ta Item2 =  (as MyTrait) type Item2\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_types_after_associated_type() {\n+    check(\n+        r#\"\n+trait MyTrait {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<Item1 = $0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+\n+    check(\n+        r#\"\n+trait MyTrait {\n+    type Item1;\n+    type Item2;\n+};\n+\n+fn f(t: impl MyTrait<Item1 = u8, Item2 = $0\n+\"#,\n+        expect![[r#\"\n+            ct CONST\n+            en Enum\n+            ma makro!(\u2026) macro_rules! makro\n+            md module\n+            st Record\n+            st Tuple\n+            st Unit\n+            tt MyTrait\n+            tt Trait\n+            un Union\n+            bt u32\n+            kw crate::\n+            kw self::\n+            kw super::\n+        \"#]],\n+    );\n+}"}, {"sha": "12be7947fe0a4de673c5f91545cb8d47d93fddeb", "filename": "crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c296e777675860164f8e45571efd29c4c08ee7cc/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=c296e777675860164f8e45571efd29c4c08ee7cc", "patch": "@@ -471,17 +471,9 @@ struct TidyMarks {\n \n impl TidyMarks {\n     fn visit(&mut self, _path: &Path, text: &str) {\n-        for line in text.lines() {\n-            if let Some(mark) = find_mark(line, \"hit\") {\n-                self.hits.insert(mark.to_string());\n-            }\n-            if let Some(mark) = find_mark(line, \"check\") {\n-                self.checks.insert(mark.to_string());\n-            }\n-            if let Some(mark) = find_mark(line, \"check_count\") {\n-                self.checks.insert(mark.to_string());\n-            }\n-        }\n+        find_marks(&mut self.hits, text, \"hit\");\n+        find_marks(&mut self.checks, text, \"check\");\n+        find_marks(&mut self.checks, text, \"check_count\");\n     }\n \n     fn finish(self) {\n@@ -506,10 +498,21 @@ fn stable_hash(text: &str) -> u64 {\n     hasher.finish()\n }\n \n-fn find_mark<'a>(text: &'a str, mark: &'static str) -> Option<&'a str> {\n-    let idx = text.find(mark)?;\n-    let text = text[idx + mark.len()..].strip_prefix(\"!(\")?;\n-    let idx = text.find(|c: char| !(c.is_alphanumeric() || c == '_'))?;\n-    let text = &text[..idx];\n-    Some(text)\n+fn find_marks(set: &mut HashSet<String>, text: &str, mark: &str) {\n+    let mut text = text;\n+    let mut prev_text = \"\";\n+    while text != prev_text {\n+        prev_text = text;\n+        if let Some(idx) = text.find(mark) {\n+            text = &text[idx + mark.len()..];\n+            if let Some(stripped_text) = text.strip_prefix(\"!(\") {\n+                text = stripped_text.trim_start();\n+                if let Some(idx2) = text.find(|c: char| !(c.is_alphanumeric() || c == '_')) {\n+                    let mark_text = &text[..idx2];\n+                    set.insert(mark_text.to_string());\n+                    text = &text[idx2..];\n+                }\n+            }\n+        }\n+    }\n }"}]}