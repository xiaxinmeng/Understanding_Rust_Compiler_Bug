{"sha": "56491314235a30c9cda06bbde4e7381bb4509814", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NDkxMzE0MjM1YTMwYzljZGEwNmJiZGU0ZTczODFiYjQ1MDk4MTQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-05T10:11:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-05T10:11:10Z"}, "message": "Rollup merge of #64030 - jethrogb:jb/sgx-sync-issues, r=alexcrichton\n\nFix unlock ordering in SGX synchronization primitives\n\nAvoid holding spinlocks during usercalls. This should avoid deadlocks in certain pathological scheduling cases.\n\ncc @mzohreva @parthsane\n\nr? @alexcrichton", "tree": {"sha": "f5396654312aebf8794fb9e8cbf2540617d068c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5396654312aebf8794fb9e8cbf2540617d068c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56491314235a30c9cda06bbde4e7381bb4509814", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdcN8+CRBK7hj4Ov3rIwAAdHIIABV0HKrBjIqOeTNx+ASFvZC2\nvIGdw0bvo/1/9kvtRYZP4wE4WzO/+s/dKJHvoIWLlxuhU+1LQ0EsHt+dqL6dgRwM\nNw9JIVTcVu0yVfbF0hMflDUK/nu/Omri/9vM8cFvMn8u4Z6KUa727TlcNRaWFGju\nS8F1rdBVD0s5uT7CKQWejN1XjULgAFgvppYbVgdDW6FSPEntOikzqqd9J9Wd2PeF\nAObMeinLpyZ5DNN2IWQNAQ9MYaLKbKNx3hKjet/72bZ7sAUFHYOmVQD9wPMtSdyZ\nO83tzOQCZah2VZDVCVwImg664KIxmDMZ1Y1ws6nIIjZ9d8xHvF6EzTfuEOO5Ims=\n=lobi\n-----END PGP SIGNATURE-----\n", "payload": "tree f5396654312aebf8794fb9e8cbf2540617d068c6\nparent 085c9e691e966022dcc35c9355e34f68f742142e\nparent 3c4d157c8419d73574587a22a8095ad32d860af5\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567678270 +0200\ncommitter GitHub <noreply@github.com> 1567678270 +0200\n\nRollup merge of #64030 - jethrogb:jb/sgx-sync-issues, r=alexcrichton\n\nFix unlock ordering in SGX synchronization primitives\n\nAvoid holding spinlocks during usercalls. This should avoid deadlocks in certain pathological scheduling cases.\n\ncc @mzohreva @parthsane\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56491314235a30c9cda06bbde4e7381bb4509814", "html_url": "https://github.com/rust-lang/rust/commit/56491314235a30c9cda06bbde4e7381bb4509814", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56491314235a30c9cda06bbde4e7381bb4509814/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "085c9e691e966022dcc35c9355e34f68f742142e", "url": "https://api.github.com/repos/rust-lang/rust/commits/085c9e691e966022dcc35c9355e34f68f742142e", "html_url": "https://github.com/rust-lang/rust/commit/085c9e691e966022dcc35c9355e34f68f742142e"}, {"sha": "3c4d157c8419d73574587a22a8095ad32d860af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d157c8419d73574587a22a8095ad32d860af5", "html_url": "https://github.com/rust-lang/rust/commit/3c4d157c8419d73574587a22a8095ad32d860af5"}], "stats": {"total": 52, "additions": 32, "deletions": 20}, "files": [{"sha": "cc1c04a83e752859343e4afcf8c6ebb281ac84c0", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=56491314235a30c9cda06bbde4e7381bb4509814", "patch": "@@ -27,8 +27,7 @@ impl Condvar {\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let guard = self.inner.lock();\n-        mutex.unlock();\n-        WaitQueue::wait(guard);\n+        WaitQueue::wait(guard, || mutex.unlock());\n         mutex.lock()\n     }\n "}, {"sha": "662da8b3f66850f1a72add0674ad5006e0c84e57", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=56491314235a30c9cda06bbde4e7381bb4509814", "patch": "@@ -22,7 +22,7 @@ impl Mutex {\n         let mut guard = self.inner.lock();\n         if *guard.lock_var() {\n             // Another thread has the lock, wait\n-            WaitQueue::wait(guard)\n+            WaitQueue::wait(guard, ||{})\n             // Another thread has passed the lock to us\n         } else {\n             // We are just now obtaining the lock\n@@ -83,7 +83,7 @@ impl ReentrantMutex {\n         match guard.lock_var().owner {\n             Some(tcs) if tcs != thread::current() => {\n                 // Another thread has the lock, wait\n-                WaitQueue::wait(guard);\n+                WaitQueue::wait(guard, ||{});\n                 // Another thread has passed the lock to us\n             },\n             _ => {"}, {"sha": "e2f94b1d928e10db38416f8c874fd88fb08c652d", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=56491314235a30c9cda06bbde4e7381bb4509814", "patch": "@@ -31,7 +31,7 @@ impl RWLock {\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock, wait\n             drop(wguard);\n-            WaitQueue::wait(rguard);\n+            WaitQueue::wait(rguard, ||{});\n             // Another thread has passed the lock to us\n         } else {\n             // No waiting writers, acquire the read lock\n@@ -62,7 +62,7 @@ impl RWLock {\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock, wait\n             drop(rguard);\n-            WaitQueue::wait(wguard);\n+            WaitQueue::wait(wguard, ||{});\n             // Another thread has passed the lock to us\n         } else {\n             // We are just now obtaining the lock\n@@ -97,6 +97,7 @@ impl RWLock {\n             if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n                 // A writer was waiting, pass the lock\n                 *wguard.lock_var_mut() = true;\n+                wguard.drop_after(rguard);\n             } else {\n                 // No writers were waiting, the lock is released\n                 rtassert!(rguard.queue_empty());\n@@ -117,21 +118,26 @@ impl RWLock {\n         rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n         wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n     ) {\n-        if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n-            // No writers waiting, release the write lock\n-            *wguard.lock_var_mut() = false;\n-            if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n-                // One or more readers were waiting, pass the lock to them\n-                if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n-                    *rguard.lock_var_mut() = Some(count)\n+        match WaitQueue::notify_one(wguard) {\n+            Err(mut wguard) => {\n+                // No writers waiting, release the write lock\n+                *wguard.lock_var_mut() = false;\n+                if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n+                    // One or more readers were waiting, pass the lock to them\n+                    if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n+                        *rguard.lock_var_mut() = Some(count)\n+                    } else {\n+                        unreachable!() // called notify_all\n+                    }\n+                    rguard.drop_after(wguard);\n                 } else {\n-                    unreachable!() // called notify_all\n+                    // No readers waiting, the lock is released\n                 }\n-            } else {\n-                // No readers waiting, the lock is released\n+            },\n+            Ok(wguard) => {\n+                // There was a thread waiting for write, just pass the lock\n+                wguard.drop_after(rguard);\n             }\n-        } else {\n-            // There was a thread waiting for write, just pass the lock\n         }\n     }\n "}, {"sha": "3cb40e509b6b2973b93d0a8c1fa0a08df3b6f8a1", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56491314235a30c9cda06bbde4e7381bb4509814/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=56491314235a30c9cda06bbde4e7381bb4509814", "patch": "@@ -98,6 +98,12 @@ impl<'a, T> WaitGuard<'a, T> {\n     pub fn notified_tcs(&self) -> NotifiedTcs {\n         self.notified_tcs\n     }\n+\n+    /// Drop this `WaitGuard`, after dropping another `guard`.\n+    pub fn drop_after<U>(self, guard: U) {\n+        drop(guard);\n+        drop(self);\n+    }\n }\n \n impl<'a, T> Deref for WaitGuard<'a, T> {\n@@ -140,7 +146,7 @@ impl WaitQueue {\n     /// until a wakeup event.\n     ///\n     /// This function does not return until this thread has been awoken.\n-    pub fn wait<T>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>) {\n+    pub fn wait<T, F: FnOnce()>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>, before_wait: F) {\n         // very unsafe: check requirements of UnsafeList::push\n         unsafe {\n             let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n@@ -149,6 +155,7 @@ impl WaitQueue {\n             }));\n             let entry = guard.queue.inner.push(&mut entry);\n             drop(guard);\n+            before_wait();\n             while !entry.lock().wake {\n                 // don't panic, this would invalidate `entry` during unwinding\n                 let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n@@ -545,7 +552,7 @@ mod tests {\n             assert!(WaitQueue::notify_one(wq2.lock()).is_ok());\n         });\n \n-        WaitQueue::wait(locked);\n+        WaitQueue::wait(locked, ||{});\n \n         t1.join().unwrap();\n     }"}]}