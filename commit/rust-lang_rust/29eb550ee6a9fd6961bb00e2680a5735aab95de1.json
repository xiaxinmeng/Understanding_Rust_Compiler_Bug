{"sha": "29eb550ee6a9fd6961bb00e2680a5735aab95de1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZWI1NTBlZTZhOWZkNjk2MWJiMDBlMjY4MGE1NzM1YWFiOTVkZTE=", "commit": {"author": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-03-25T16:53:28Z"}, "committer": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-04-24T03:02:29Z"}, "message": "Get associated consts working in match patterns.", "tree": {"sha": "05443f6ba31ac17d54592e96317bca1166230dea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05443f6ba31ac17d54592e96317bca1166230dea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29eb550ee6a9fd6961bb00e2680a5735aab95de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29eb550ee6a9fd6961bb00e2680a5735aab95de1", "html_url": "https://github.com/rust-lang/rust/commit/29eb550ee6a9fd6961bb00e2680a5735aab95de1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29eb550ee6a9fd6961bb00e2680a5735aab95de1/comments", "author": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "committer": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91ae5e31ab57de15ef2855c700ad4b012ea00234", "url": "https://api.github.com/repos/rust-lang/rust/commits/91ae5e31ab57de15ef2855c700ad4b012ea00234", "html_url": "https://github.com/rust-lang/rust/commit/91ae5e31ab57de15ef2855c700ad4b012ea00234"}], "stats": {"total": 808, "additions": 610, "deletions": 198}, "files": [{"sha": "a7950a701f8c4fce0c96045d6ca81dcfa2c24db2", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -105,6 +105,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n+            ast::PatQPath(..) |\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {"}, {"sha": "a5ea3629abc84ad8fcce386d44764463b80bbd74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -439,7 +439,7 @@ impl<'map> ast_util::IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            ast::PatIdent(..) | ast::PatEnum(..) => {\n+            ast::PatIdent(..) | ast::PatEnum(..) | ast::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n                     Some(DefAssociatedConst(did, _)) |\n@@ -762,6 +762,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n+        ast::PatQPath(..) =>\n+            cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n+                                            been rewritten\"),\n         ast::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n@@ -891,6 +894,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             }\n         }\n \n+        ast::PatQPath(_, _) => {\n+            cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n+                                            been rewritten\")\n+        }\n+\n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();"}, {"sha": "d740d24e23672d9016e8c76a9a9f8f60884733e1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1147,7 +1147,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             let tcx = typer.tcx();\n \n             match pat.node {\n-                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                ast::PatEnum(_, _) | ast::PatQPath(..) |\n+                ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a"}, {"sha": "587194bafada48acfa17742614d982f44821f933", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1299,6 +1299,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             }\n           }\n \n+          ast::PatQPath(..) => {\n+              // Lone constant: ignore\n+          }\n+\n           ast::PatIdent(_, _, Some(ref subpat)) => {\n               try!(self.cat_pattern_(cmt, &**subpat, op));\n           }"}, {"sha": "27a30f5cf253cf97da67691b72b29ec2863119cc", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -30,7 +30,7 @@ pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n \n pub fn pat_is_refutable(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatLit(_) | ast::PatRange(_, _) => true,\n+        ast::PatLit(_) | ast::PatRange(_, _) | ast::PatQPath(..) => true,\n         ast::PatEnum(_, _) |\n         ast::PatIdent(_, _, None) |\n         ast::PatStruct(..) => {\n@@ -60,7 +60,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &ast::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(_, _, None) | ast::PatEnum(..) => {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n             match dm.borrow().get(&pat.id).map(|d| d.full_def()) {\n                 Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n                 _ => false\n@@ -70,6 +70,22 @@ pub fn pat_is_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n     }\n }\n \n+// Same as above, except that partially-resolved defs cause `false` to be\n+// returned instead of a panic.\n+pub fn pat_is_resolved_const(dm: &DefMap, pat: &ast::Pat) -> bool {\n+    match pat.node {\n+        ast::PatIdent(_, _, None) | ast::PatEnum(..) | ast::PatQPath(..) => {\n+            match dm.borrow().get(&pat.id)\n+                    .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n+                                  else { None } ) {\n+                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n+                _ => false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n pub fn pat_is_binding(dm: &DefMap, pat: &ast::Pat) -> bool {\n     match pat.node {\n         ast::PatIdent(..) => {"}, {"sha": "1d5c5fb86cbd5988b783d19c69ac28f5b06ca8b0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1091,7 +1091,6 @@ impl LintPass for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&ast::PatIdent(_, ref path1, _), Some(def::DefAssociatedConst(..))) |\n             (&ast::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node, p.span);"}, {"sha": "61eab4ce9b285e0128cfb57b6311bde190ff93be", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 158, "deletions": 67, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -41,6 +41,7 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n+use self::AssocItemResolveResult::*;\n use self::NameSearchType::*;\n use self::BareIdentifierPatternResolution::*;\n use self::ParentLink::*;\n@@ -70,7 +71,7 @@ use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{Local, MethodImplItem, Name, NodeId};\n-use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n+use syntax::ast::{Pat, PatEnum, PatIdent, PatLit, PatQPath};\n use syntax::ast::{PatRange, PatStruct, Path, PrimTy};\n use syntax::ast::{TraitRef, Ty, TyBool, TyChar, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyIs, TyI8, TyI16, TyI32, TyI64, TyInt};\n@@ -331,6 +332,15 @@ enum ModulePrefixResult {\n     PrefixFound(Rc<Module>, usize)\n }\n \n+#[derive(Copy, Clone)]\n+enum AssocItemResolveResult {\n+    /// Syntax such as `<T>::item`, which can't be resolved until type\n+    /// checking.\n+    TypecheckRequired,\n+    /// We should have been able to resolve the associated item.\n+    ResolveAttempt(Option<PathResolution>),\n+}\n+\n #[derive(Copy, Clone, PartialEq)]\n enum NameSearchType {\n     /// We're doing a name search in order to resolve a `use` directive.\n@@ -2305,31 +2315,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn resolve_type(&mut self, ty: &Ty) {\n         match ty.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            TyPath(Some(ast::QSelf { position: 0, .. }), _) => {}\n-\n             TyPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(ty.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = None;\n-                for depth in 0..max_assoc_types {\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(ty.id, path, depth, TypeNS, true);\n-                    });\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(ty.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           TypeNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            // Resolve embedded types.\n+                            visit::walk_ty(self, ty);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a path in the type namespace. Walk through scopes\n                 // looking for it.\n@@ -2489,10 +2489,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n-                    if let Some(path_res) = self.resolve_path(pat_id, path, 0, ValueNS, false) {\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, None,\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            // The below shouldn't happen because all\n+                            // qualified paths should be in PatQPath.\n+                            TypecheckRequired =>\n+                                self.session.span_bug(\n+                                    path.span,\n+                                    \"resolve_possibly_assoc_item claimed\n+                                     that a path in PatEnum requires typecheck\n+                                     to resolve, but qualified paths should be\n+                                     PatQPath\"),\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n                         match path_res.base_def {\n-                            DefVariant(..) | DefStruct(..) | DefConst(..) |\n-                            DefAssociatedConst(..) => {\n+                            DefVariant(..) | DefStruct(..) | DefConst(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n@@ -2501,19 +2515,70 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     referenced in a pattern, \\\n                                                     use a `const` instead\");\n                             }\n+                            _ => {\n+                                // If anything ends up here entirely resolved,\n+                                // it's an error. If anything ends up here\n+                                // partially resolved, that's OK, because it may\n+                                // be a `T::CONST` that typeck will resolve to\n+                                // an inherent impl.\n+                                if path_res.depth == 0 {\n+                                    self.resolve_error(\n+                                        path.span,\n+                                        &format!(\"`{}` is not an enum variant, struct or const\",\n+                                                 token::get_ident(\n+                                                     path.segments.last().unwrap().identifier)));\n+                                } else {\n+                                    self.record_def(pattern.id, path_res);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        self.resolve_error(path.span,\n+                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                    }\n+                    visit::walk_path(self, path);\n+                }\n+\n+                PatQPath(ref qself, ref path) => {\n+                    // Associated constants only.\n+                    let resolution =\n+                        match self.resolve_possibly_assoc_item(pat_id, Some(qself),\n+                                                               path, ValueNS,\n+                                                               false) {\n+                            TypecheckRequired => {\n+                                // All `<T>::CONST` should end up here, and will\n+                                // require use of the trait map to resolve\n+                                // during typechecking.\n+                                let const_name = path.segments.last().unwrap()\n+                                                     .identifier.name;\n+                                let traits = self.get_traits_containing_item(const_name);\n+                                self.trait_map.insert(pattern.id, traits);\n+                                visit::walk_pat(self, pattern);\n+                                return true;\n+                            }\n+                            ResolveAttempt(resolution) => resolution,\n+                        };\n+                    if let Some(path_res) = resolution {\n+                        match path_res.base_def {\n+                            // All `<T as Trait>::CONST` should end up here, and\n+                            // have the trait already selected.\n+                            DefAssociatedConst(..) => {\n+                                self.record_def(pattern.id, path_res);\n+                            }\n                             _ => {\n                                 self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an enum variant, struct or const\",\n+                                    &format!(\"`{}` is not an associated const\",\n                                         token::get_ident(\n                                             path.segments.last().unwrap().identifier)));\n                             }\n                         }\n                     } else {\n                         self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n+                            &format!(\"unresolved associated const `{}`\",\n                                 token::get_ident(path.segments.last().unwrap().identifier)));\n                     }\n-                    visit::walk_path(self, path);\n+                    visit::walk_pat(self, pattern);\n                 }\n \n                 PatStruct(ref path, _, _) => {\n@@ -2605,6 +2670,47 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n+    /// Handles paths that may refer to associated items\n+    fn resolve_possibly_assoc_item(&mut self,\n+                                   id: NodeId,\n+                                   maybe_qself: Option<&ast::QSelf>,\n+                                   path: &Path,\n+                                   namespace: Namespace,\n+                                   check_ribs: bool)\n+                                   -> AssocItemResolveResult\n+    {\n+        match maybe_qself {\n+            Some(&ast::QSelf { position: 0, .. }) =>\n+                return TypecheckRequired,\n+            _ => {}\n+        }\n+        let max_assoc_types = if let Some(qself) = maybe_qself {\n+            // Make sure the trait is valid.\n+            let _ = self.resolve_trait_reference(id, path, 1);\n+            path.segments.len() - qself.position\n+        } else {\n+            path.segments.len()\n+        };\n+\n+        let mut resolution = self.with_no_errors(|this| {\n+            this.resolve_path(id, path, 0, namespace, check_ribs)\n+        });\n+        for depth in 1..max_assoc_types {\n+            if resolution.is_some() {\n+                break;\n+            }\n+            self.with_no_errors(|this| {\n+                resolution = this.resolve_path(id, path, depth,\n+                                               TypeNS, true);\n+            });\n+        }\n+        if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n+            // A module is not a valid type or value.\n+            resolution = None;\n+        }\n+        ResolveAttempt(resolution)\n+    }\n+\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     /// Skips `path_depth` trailing segments, which is also reflected in the\n@@ -3119,38 +3225,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Next, resolve the node.\n         match expr.node {\n-            // `<T>::a::b::c` is resolved by typeck alone.\n-            ExprPath(Some(ast::QSelf { position: 0, .. }), ref path) => {\n-                let method_name = path.segments.last().unwrap().identifier.name;\n-                let traits = self.search_for_traits_containing_method(method_name);\n-                self.trait_map.insert(expr.id, traits);\n-                visit::walk_expr(self, expr);\n-            }\n-\n             ExprPath(ref maybe_qself, ref path) => {\n-                let max_assoc_types = if let Some(ref qself) = *maybe_qself {\n-                    // Make sure the trait is valid.\n-                    let _ = self.resolve_trait_reference(expr.id, path, 1);\n-                    path.segments.len() - qself.position\n-                } else {\n-                    path.segments.len()\n-                };\n-\n-                let mut resolution = self.with_no_errors(|this| {\n-                    this.resolve_path(expr.id, path, 0, ValueNS, true)\n-                });\n-                for depth in 1..max_assoc_types {\n-                    if resolution.is_some() {\n-                        break;\n-                    }\n-                    self.with_no_errors(|this| {\n-                        resolution = this.resolve_path(expr.id, path, depth, TypeNS, true);\n-                    });\n-                }\n-                if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n-                    // A module is not a valid type or value.\n-                    resolution = None;\n-                }\n+                let resolution =\n+                    match self.resolve_possibly_assoc_item(expr.id,\n+                                                           maybe_qself.as_ref(),\n+                                                           path,\n+                                                           ValueNS,\n+                                                           true) {\n+                        // `<T>::a::b::c` is resolved by typeck alone.\n+                        TypecheckRequired => {\n+                            let method_name = path.segments.last().unwrap().identifier.name;\n+                            let traits = self.get_traits_containing_item(method_name);\n+                            self.trait_map.insert(expr.id, traits);\n+                            visit::walk_expr(self, expr);\n+                            return;\n+                        }\n+                        ResolveAttempt(resolution) => resolution,\n+                    };\n \n                 // This is a local path in the value namespace. Walk through\n                 // scopes looking for it.\n@@ -3181,7 +3272,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // so they can be completed during typeck.\n                         if path_res.depth != 0 {\n                             let method_name = path.segments.last().unwrap().identifier.name;\n-                            let traits = self.search_for_traits_containing_method(method_name);\n+                            let traits = self.get_traits_containing_item(method_name);\n                             self.trait_map.insert(expr.id, traits);\n                         }\n \n@@ -3339,14 +3430,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             ExprMethodCall(ident, _, _) => {\n                 debug!(\"(recording candidate traits for expr) recording \\\n                         traits for {}\",\n                        expr.id);\n-                let traits = self.search_for_traits_containing_method(ident.node.name);\n+                let traits = self.get_traits_containing_item(ident.node.name);\n                 self.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -3355,8 +3446,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn search_for_traits_containing_method(&mut self, name: Name) -> Vec<DefId> {\n-        debug!(\"(searching for traits containing method) looking for '{}'\",\n+    fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n+        debug!(\"(getting traits containing item) looking for '{}'\",\n                token::get_name(name));\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,"}, {"sha": "39cfac42011aba8fe8c92d786ca9353c4aa2e15f", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1044,7 +1044,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            ast::PatEnum(ref path, _) => {\n+            ast::PatEnum(ref path, _) |\n+            ast::PatQPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::VarRef));\n                 visit::walk_pat(self, p);\n             }"}, {"sha": "b93068c88c8be22cd23d941d4594580a4fab3258", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1809,7 +1809,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::PatMac(..) => {\n             bcx.sess().span_bug(pat.span, \"unexpanded macro\");\n         }\n-        ast::PatWild(_) | ast::PatLit(_) | ast::PatRange(_, _) => ()\n+        ast::PatQPath(..) | ast::PatWild(_) | ast::PatLit(_) |\n+        ast::PatRange(_, _) => ()\n     }\n     return bcx;\n }"}, {"sha": "516ff443dacb94d87514417f7a6a8ff9ad198fd3", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -3437,6 +3437,10 @@ fn create_scope_map(cx: &CrateContext,\n                 }\n             }\n \n+            ast::PatQPath(..) => {\n+                scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n+            }\n+\n             ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n "}, {"sha": "1f4d6cc2fd471b4b8e04539edcb12438dedc6c36", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -11,12 +11,14 @@\n use middle::const_eval;\n use middle::def;\n use middle::infer;\n-use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n+use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n+use middle::pat_util::pat_is_resolved_const;\n+use middle::privacy::{AllPublic, LastMod};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use check::{check_expr, check_expr_has_type, check_expr_with_expectation};\n use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n-use check::{instantiate_path, structurally_resolved_type};\n+use check::{instantiate_path, resolve_ty_and_def_ufcs, structurally_resolved_type};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n@@ -118,7 +120,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // subtyping doesn't matter here, as the value is some kind of scalar\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n-        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n+        ast::PatEnum(..) | ast::PatIdent(..) if pat_is_resolved_const(&tcx.def_map, pat) => {\n             let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n@@ -181,6 +183,37 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let subpats = subpats.as_ref().map(|v| &v[..]);\n             check_pat_enum(pcx, pat, path, subpats, expected);\n         }\n+        ast::PatQPath(ref qself, ref path) => {\n+            let self_ty = fcx.to_ty(&qself.ty);\n+            let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n+                d\n+            } else if qself.position == 0 {\n+                def::PathResolution {\n+                    // This is just a sentinel for finish_resolving_def_to_ty.\n+                    base_def: def::DefMod(ast_util::local_def(ast::CRATE_NODE_ID)),\n+                    last_private: LastMod(AllPublic),\n+                    depth: path.segments.len()\n+                }\n+            } else {\n+                tcx.sess.span_bug(pat.span,\n+                                  &format!(\"unbound path {}\", pat.repr(tcx)))\n+            };\n+            if let Some((opt_ty, segments, def)) =\n+                    resolve_ty_and_def_ufcs(fcx, path_res, Some(self_ty),\n+                                            path, pat.span, pat.id) {\n+                if check_assoc_item_is_const(pcx, def, pat.span) {\n+                    let scheme = ty::lookup_item_type(tcx, def.def_id());\n+                    let predicates = ty::lookup_predicates(tcx, def.def_id());\n+                    instantiate_path(fcx, segments,\n+                                     scheme, &predicates,\n+                                     opt_ty, def, pat.span, pat.id);\n+                    let const_ty = fcx.node_ty(pat.id);\n+                    demand::suptype(fcx, pat.span, expected, const_ty);\n+                } else {\n+                    fcx.write_error(pat.id)\n+                }\n+            }\n+        }\n         ast::PatStruct(ref path, ref fields, etc) => {\n             check_pat_struct(pcx, pat, path, fields, etc, expected);\n         }\n@@ -331,6 +364,21 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // subtyping.\n }\n \n+fn check_assoc_item_is_const(pcx: &pat_ctxt, def: def::Def, span: Span) -> bool {\n+    match def {\n+        def::DefAssociatedConst(..) => true,\n+        def::DefMethod(..) => {\n+            span_err!(pcx.fcx.ccx.tcx.sess, span, E0327,\n+                      \"associated items in match patterns must be constants\");\n+            false\n+        }\n+        _ => {\n+            pcx.fcx.ccx.tcx.sess.span_bug(span, \"non-associated item in\n+                                                 check_assoc_item_is_const\");\n+        }\n+    }\n+}\n+\n pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       span: Span, expected: Ty<'tcx>,\n                                       inner: &ast::Pat) -> bool {\n@@ -532,7 +580,24 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+    let path_res = *tcx.def_map.borrow().get(&pat.id).unwrap();\n+\n+    let (opt_ty, segments, def) = match resolve_ty_and_def_ufcs(fcx, path_res,\n+                                                                None, path,\n+                                                                pat.span, pat.id) {\n+        Some(resolution) => resolution,\n+        // Error handling done inside resolve_ty_and_def_ufcs, so if\n+        // resolution fails just return.\n+        None => {return;}\n+    };\n+\n+    // Items that were partially resolved before should have been resolved to\n+    // associated constants (i.e. not methods).\n+    if path_res.depth != 0 && !check_assoc_item_is_const(pcx, def, pat.span) {\n+        fcx.write_error(pat.id);\n+        return;\n+    }\n+\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n@@ -547,13 +612,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, &path.segments,\n+    instantiate_path(pcx.fcx, segments,\n                      path_scheme, &ctor_predicates,\n-                     None, def, pat.span, pat.id);\n+                     opt_ty, def, pat.span, pat.id);\n+\n+    // If we didn't have a fully resolved path to start with, we had an\n+    // associated const, and we should quit now, since the rest of this\n+    // function uses checks specific to structs and enums.\n+    if path_res.depth != 0 {\n+        let pat_ty = fcx.node_ty(pat.id);\n+        demand::suptype(fcx, pat.span, expected, pat_ty);\n+        return;\n+    }\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n+\n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n         ty::ty_enum(enum_def_id, expected_substs)"}, {"sha": "6ba341f62f58ec009ea67358daf7844c6bed27b7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 51, "deletions": 38, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -3230,53 +3230,20 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n-          let def = path_res.base_def;\n-          if path_res.depth == 0 {\n+          if let Some((opt_ty, segments, def)) =\n+                  resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n+                                          expr.span, expr.id) {\n               let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n                                                                             expr.span,\n                                                                             def);\n               instantiate_path(fcx,\n-                               &path.segments,\n+                               segments,\n                                scheme,\n                                &predicates,\n-                               opt_self_ty,\n+                               opt_ty,\n                                def,\n                                expr.span,\n                                id);\n-          } else {\n-              let ty_segments = path.segments.init();\n-              let base_ty_end = path.segments.len() - path_res.depth;\n-              let ty = astconv::finish_resolving_def_to_ty(fcx,\n-                                                           fcx,\n-                                                           expr.span,\n-                                                           PathParamMode::Optional,\n-                                                           &def,\n-                                                           opt_self_ty,\n-                                                           &ty_segments[..base_ty_end],\n-                                                           &ty_segments[base_ty_end..]);\n-              let method_segment = path.segments.last().unwrap();\n-              let method_name = method_segment.identifier.name;\n-              match method::resolve_ufcs(fcx, expr.span, method_name, ty, id) {\n-                  Ok((def, lp)) => {\n-                      // Write back the new resolution.\n-                      tcx.def_map.borrow_mut().insert(id, def::PathResolution {\n-                          base_def: def,\n-                          last_private: path_res.last_private.or(lp),\n-                          depth: 0\n-                      });\n-\n-                      let (scheme, predicates) =\n-                          type_scheme_and_predicates_for_def(fcx, expr.span, def);\n-                      instantiate_path(fcx, slice::ref_slice(method_segment),\n-                                       scheme, &predicates,\n-                                       Some(ty), def, expr.span, id);\n-                  }\n-                  Err(error) => {\n-                      method::report_error(fcx, expr.span, ty,\n-                                           method_name, None, error);\n-                      fcx.write_error(id);\n-                  }\n-              }\n           }\n \n           // We always require that the type provided as the value for\n@@ -3738,6 +3705,52 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     unifier();\n }\n \n+pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n+                                             path_res: def::PathResolution,\n+                                             opt_self_ty: Option<Ty<'tcx>>,\n+                                             path: &'a ast::Path,\n+                                             span: Span,\n+                                             node_id: ast::NodeId)\n+                                             -> Option<(Option<Ty<'tcx>>,\n+                                                        &'a [ast::PathSegment],\n+                                                        def::Def)>\n+{\n+    // If fully resolved already, we don't have to do anything.\n+    if path_res.depth == 0 {\n+        Some((opt_self_ty, &path.segments, path_res.base_def))\n+    } else {\n+        let mut def = path_res.base_def;\n+        let ty_segments = path.segments.init();\n+        let base_ty_end = path.segments.len() - path_res.depth;\n+        let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, span,\n+                                                     PathParamMode::Optional,\n+                                                     &mut def,\n+                                                     opt_self_ty,\n+                                                     &ty_segments[..base_ty_end],\n+                                                     &ty_segments[base_ty_end..]);\n+        let item_segment = path.segments.last().unwrap();\n+        let item_name = item_segment.identifier.name;\n+        match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n+            Ok((def, lp)) => {\n+                // Write back the new resolution.\n+                fcx.ccx.tcx.def_map.borrow_mut()\n+                       .insert(node_id, def::PathResolution {\n+                   base_def: def,\n+                   last_private: path_res.last_private.or(lp),\n+                   depth: 0\n+                });\n+                Some((Some(ty), slice::ref_slice(item_segment), def))\n+            }\n+            Err(error) => {\n+                method::report_error(fcx, span, ty,\n+                                     item_name, None, error);\n+                fcx.write_error(node_id);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n fn constrain_path_type_parameters(fcx: &FnCtxt,\n                                   expr: &ast::Expr)\n {"}, {"sha": "46cc4628e2eeb36022f7782bd7d89af67c72cee7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -180,6 +180,7 @@ register_diagnostics! {\n     E0324, // implemented a method when another trait item expected\n     E0325, // implemented an associated type when another trait item expected\n     E0326, // associated const implemented with different type from trait\n+    E0327, // referred to method instead of constant in match pattern\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0368, // binary operation `<op>=` cannot be applied to types"}, {"sha": "1e6e9a7562a7c1be287fe5e69e42ff7f49dce460", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -2522,6 +2522,8 @@ fn name_from_pat(p: &ast::Pat) -> String {\n         PatWild(PatWildMulti) => \"..\".to_string(),\n         PatIdent(_, ref p, _) => token::get_ident(p.node).to_string(),\n         PatEnum(ref p, _) => path_to_string(p),\n+        PatQPath(..) => panic!(\"tried to get argument name from PatQPath, \\\n+                                which is not allowed in function arguments\"),\n         PatStruct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", path_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|"}, {"sha": "4307abe4174530e0607cdbdf72ae3482e3103165", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -599,6 +599,12 @@ pub enum Pat_ {\n     /// \"None\" means a * pattern where we don't bind the fields to names.\n     PatEnum(Path, Option<Vec<P<Pat>>>),\n \n+    /// An associated const named using the qualified path `<T>::CONST` or\n+    /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n+    /// refered to as simply `T::CONST`, in which case they will end up as\n+    /// PatEnum, and the resolver will have to sort that out.\n+    PatQPath(QSelf, Path),\n+\n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n     PatStruct(Path, Vec<Spanned<FieldPat>>, bool),"}, {"sha": "fc4d73210ea9849fbf341b324104425ad33e7a08", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -579,7 +579,7 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n             }\n             PatMac(_) => panic!(\"attempted to analyze unexpanded pattern\"),\n             PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n-            PatEnum(_, _) => {\n+            PatEnum(_, _) | PatQPath(_, _) => {\n                 true\n             }\n         }"}, {"sha": "8898dc7e3597eb0087333f63078d5d6180bbd818", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -1134,6 +1134,10 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                 PatEnum(folder.fold_path(pth),\n                         pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n             }\n+            PatQPath(qself, pth) => {\n+                let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n+                PatQPath(qself, folder.fold_path(pth))\n+            }\n             PatStruct(pth, fields, etc) => {\n                 let pth = folder.fold_path(pth);\n                 let fs = fields.move_map(|f| {"}, {"sha": "abeee2a1c748982fe86cf1d9777f16307e00d239", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 110, "deletions": 79, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -40,8 +40,9 @@ use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n use ast::{MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n-use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatMac, PatRange, PatRegion};\n-use ast::{PatStruct, PatTup, PatVec, PatWild, PatWildMulti, PatWildSingle};\n+use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n+use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild, PatWildMulti};\n+use ast::PatWildSingle;\n use ast::{PolyTraitRef, QSelf};\n use ast::{Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n@@ -109,6 +110,15 @@ pub enum PathParsingMode {\n     LifetimeAndTypesWithColons,\n }\n \n+/// How to parse a qualified path, whether to allow trailing parameters.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum QPathParsingMode {\n+    /// No trailing parameters, e.g. `<T as Trait>::Item`\n+    NoParameters,\n+    /// Optional parameters, e.g. `<T as Trait>::item::<'a, U>`\n+    MaybeParameters,\n+}\n+\n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n #[derive(Copy, Clone, PartialEq)]\n pub enum BoundParsingMode {\n@@ -1345,36 +1355,9 @@ impl<'a> Parser<'a> {\n             try!(self.expect(&token::CloseDelim(token::Paren)));\n             TyTypeof(e)\n         } else if try!(self.eat_lt()) {\n-            // QUALIFIED PATH `<TYPE as TRAIT_REF>::item`\n-            let self_type = try!(self.parse_ty_sum());\n-\n-            let mut path = if try!(self.eat_keyword(keywords::As) ){\n-                try!(self.parse_path(LifetimeAndTypesWithoutColons))\n-            } else {\n-                ast::Path {\n-                    span: self.span,\n-                    global: false,\n-                    segments: vec![]\n-                }\n-            };\n \n-            let qself = QSelf {\n-                ty: self_type,\n-                position: path.segments.len()\n-            };\n-\n-            try!(self.expect(&token::Gt));\n-            try!(self.expect(&token::ModSep));\n-\n-            path.segments.push(ast::PathSegment {\n-                identifier: try!(self.parse_ident()),\n-                parameters: ast::PathParameters::none()\n-            });\n-\n-            if path.segments.len() == 1 {\n-                path.span.lo = self.last_span.lo;\n-            }\n-            path.span.hi = self.last_span.hi;\n+            let (qself, path) =\n+                 try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n \n             TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n@@ -1591,6 +1574,61 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    // QUALIFIED PATH `<TYPE [as TRAIT_REF]>::IDENT[::<PARAMS>]`\n+    // Assumes that the leading `<` has been parsed already.\n+    pub fn parse_qualified_path(&mut self, mode: QPathParsingMode)\n+                                -> PResult<(QSelf, ast::Path)> {\n+        let self_type = try!(self.parse_ty_sum());\n+        let mut path = if try!(self.eat_keyword(keywords::As)) {\n+            try!(self.parse_path(LifetimeAndTypesWithoutColons))\n+        } else {\n+            ast::Path {\n+                span: self.span,\n+                global: false,\n+                segments: vec![]\n+            }\n+        };\n+\n+        let qself = QSelf {\n+            ty: self_type,\n+            position: path.segments.len()\n+        };\n+\n+        try!(self.expect(&token::Gt));\n+        try!(self.expect(&token::ModSep));\n+\n+        let item_name = try!(self.parse_ident());\n+        let parameters = match mode {\n+            QPathParsingMode::NoParameters => ast::PathParameters::none(),\n+            QPathParsingMode::MaybeParameters => {\n+                if try!(self.eat(&token::ModSep)) {\n+                    try!(self.expect_lt());\n+                    // Consumed `item::<`, go look for types\n+                    let (lifetimes, types, bindings) =\n+                        try!(self.parse_generic_values_after_lt());\n+                    ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: OwnedSlice::from_vec(types),\n+                        bindings: OwnedSlice::from_vec(bindings),\n+                    })\n+                } else {\n+                    ast::PathParameters::none()\n+                }\n+            }\n+        };\n+        path.segments.push(ast::PathSegment {\n+            identifier: item_name,\n+            parameters: parameters\n+        });\n+\n+        if path.segments.len() == 1 {\n+            path.span.lo = self.last_span.lo;\n+        }\n+        path.span.hi = self.last_span.hi;\n+\n+        Ok((qself, path))\n+    }\n+\n     /// Parses a path and optional type parameter bounds, depending on the\n     /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n     /// bounds are permitted and whether `::` must precede type parameter\n@@ -2054,49 +2092,10 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 if try!(self.eat_lt()){\n-                    // QUALIFIED PATH `<TYPE as TRAIT_REF>::item::<'a, T>`\n-                    let self_type = try!(self.parse_ty_sum());\n-                    let mut path = if try!(self.eat_keyword(keywords::As) ){\n-                        try!(self.parse_path(LifetimeAndTypesWithoutColons))\n-                    } else {\n-                        ast::Path {\n-                            span: self.span,\n-                            global: false,\n-                            segments: vec![]\n-                        }\n-                    };\n-                    let qself = QSelf {\n-                        ty: self_type,\n-                        position: path.segments.len()\n-                    };\n-                    try!(self.expect(&token::Gt));\n-                    try!(self.expect(&token::ModSep));\n-\n-                    let item_name = try!(self.parse_ident());\n-                    let parameters = if try!(self.eat(&token::ModSep) ){\n-                        try!(self.expect_lt());\n-                        // Consumed `item::<`, go look for types\n-                        let (lifetimes, types, bindings) =\n-                            try!(self.parse_generic_values_after_lt());\n-                        ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n-                            lifetimes: lifetimes,\n-                            types: OwnedSlice::from_vec(types),\n-                            bindings: OwnedSlice::from_vec(bindings),\n-                        })\n-                    } else {\n-                        ast::PathParameters::none()\n-                    };\n-                    path.segments.push(ast::PathSegment {\n-                        identifier: item_name,\n-                        parameters: parameters\n-                    });\n \n-                    if path.segments.len() == 1 {\n-                        path.span.lo = self.last_span.lo;\n-                    }\n-                    path.span.hi = self.last_span.hi;\n+                    let (qself, path) =\n+                        try!(self.parse_qualified_path(QPathParsingMode::MaybeParameters));\n \n-                    let hi = self.span.hi;\n                     return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n                 }\n                 if try!(self.eat_keyword(keywords::Move) ){\n@@ -3167,16 +3166,25 @@ impl<'a> Parser<'a> {\n     fn parse_pat_range_end(&mut self) -> PResult<P<Expr>> {\n         if self.is_path_start() {\n             let lo = self.span.lo;\n-            let path = try!(self.parse_path(LifetimeAndTypesWithColons));\n+            let (qself, path) = if try!(self.eat_lt()) {\n+                // Parse a qualified path\n+                let (qself, path) =\n+                    try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                (Some(qself), path)\n+            } else {\n+                // Parse an unqualified path\n+                (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n+            };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(None, path)))\n+            Ok(self.mk_expr(lo, hi, ExprPath(qself, path)))\n         } else {\n             self.parse_literal_maybe_minus()\n         }\n     }\n \n     fn is_path_start(&self) -> bool {\n-        (self.token == token::ModSep || self.token.is_ident() || self.token.is_path())\n+        (self.token == token::Lt || self.token == token::ModSep\n+            || self.token.is_ident() || self.token.is_path())\n             && !self.token.is_keyword(keywords::True) && !self.token.is_keyword(keywords::False)\n     }\n \n@@ -3252,25 +3260,44 @@ impl<'a> Parser<'a> {\n                         pat = try!(self.parse_pat_ident(BindByValue(MutImmutable)));\n                     }\n                 } else {\n-                    // Parse as a general path\n-                    let path = try!(self.parse_path(LifetimeAndTypesWithColons));\n+                    let (qself, path) = if try!(self.eat_lt()) {\n+                        // Parse a qualified path\n+                        let (qself, path) =\n+                            try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                        (Some(qself), path)\n+                    } else {\n+                        // Parse an unqualified path\n+                        (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n+                    };\n                     match self.token {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(None, path));\n+                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path));\n                         try!(self.bump());\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);\n                       }\n                       token::OpenDelim(token::Brace) => {\n-                        // Parse struct pattern\n+                         if qself.is_some() {\n+                            let span = self.span;\n+                            self.span_err(span,\n+                                          \"unexpected `{` after qualified path\");\n+                            self.abort_if_errors();\n+                        }\n+                       // Parse struct pattern\n                         try!(self.bump());\n                         let (fields, etc) = try!(self.parse_pat_fields());\n                         try!(self.bump());\n                         pat = PatStruct(path, fields, etc);\n                       }\n                       token::OpenDelim(token::Paren) => {\n+                        if qself.is_some() {\n+                            let span = self.span;\n+                            self.span_err(span,\n+                                          \"unexpected `(` after qualified path\");\n+                            self.abort_if_errors();\n+                        }\n                         // Parse tuple struct or enum pattern\n                         if self.look_ahead(1, |t| *t == token::DotDot) {\n                             // This is a \"top constructor only\" pat\n@@ -3287,6 +3314,10 @@ impl<'a> Parser<'a> {\n                             pat = PatEnum(path, Some(args));\n                         }\n                       }\n+                      _ if qself.is_some() => {\n+                        // Parse qualified path\n+                        pat = PatQPath(qself.unwrap(), path);\n+                      }\n                       _ => {\n                         // Parse nullary enum\n                         pat = PatEnum(path, Some(vec![]));"}, {"sha": "27682bc6fec6aac45e2faacc5436ee13a323f640", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -2220,6 +2220,9 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n+            ast::PatQPath(ref qself, ref path) => {\n+                try!(self.print_qpath(path, qself, false));\n+            }\n             ast::PatStruct(ref path, ref fields, etc) => {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());"}, {"sha": "6cf791b10be67612eaa75ad146d630fafb1a5602", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -464,6 +464,10 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 }\n             }\n         }\n+        PatQPath(ref qself, ref path) => {\n+            visitor.visit_ty(&qself.ty);\n+            visitor.visit_path(path, pattern.id)\n+        }\n         PatStruct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {"}, {"sha": "1d83f901cdb62a419f98520c9ea34a8ee05bd5a6", "filename": "src/test/compile-fail/method-path-in-pattern.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-path-in-pattern.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+trait MyTrait: MarkerTrait {\n+    fn trait_bar() {}\n+}\n+\n+impl MyTrait for Foo {}\n+\n+fn main() {\n+    match 0u32 {\n+        Foo::bar => {} //~ ERROR E0327\n+    }\n+    match 0u32 {\n+        <Foo>::bar => {} //~ ERROR E0327\n+    }\n+    match 0u32 {\n+        <Foo>::trait_bar => {} //~ ERROR E0327\n+    }\n+}"}, {"sha": "f3e93537203b341c22f16faa70596417d7fe4886", "filename": "src/test/compile-fail/method-resolvable-path-in-pattern.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-resolvable-path-in-pattern.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+struct Foo;\n+\n+trait MyTrait: MarkerTrait {\n+    fn trait_bar() {}\n+}\n+\n+impl MyTrait for Foo {}\n+\n+fn main() {\n+    match 0u32 {\n+        <Foo as MyTrait>::trait_bar => {}\n+        //~^ ERROR `trait_bar` is not an associated const\n+    }\n+}"}, {"sha": "66f462df05ac9d05b04d0ad9f288448efa7c4eb3", "filename": "src/test/parse-fail/brace-after-qualified-path-in-match.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() {\n+    match x {\n+        <T as Trait>::Type{key: value} => (),\n+        //~^ ERROR unexpected `{` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "d06fd2bb4e704846f4344df39a6b61c40439774f", "filename": "src/test/parse-fail/paren-after-qualified-path-in-match.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() {\n+    match x {\n+        <T as Trait>::Type(2) => (),\n+        //~^ ERROR unexpected `(` after qualified path\n+        _ => (),\n+    }\n+}"}, {"sha": "0085f89822edf6d36d05ae96c2293c696c027aa0", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29eb550ee6a9fd6961bb00e2680a5735aab95de1/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=29eb550ee6a9fd6961bb00e2680a5735aab95de1", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::marker::MarkerTrait;\n+\n+struct Foo;\n+\n+enum Bar {\n+    Var1,\n+    Var2,\n+}\n+\n+// Use inherent and trait impls to test UFCS syntax.\n+impl Foo {\n+    const MYBAR: Bar = Bar::Var2;\n+}\n+\n+trait HasBar: MarkerTrait {\n+    const THEBAR: Bar;\n+}\n+\n+impl HasBar for Foo {\n+    const THEBAR: Bar = Bar::Var1;\n+}\n+\n+fn main() {\n+    // Inherent impl\n+    assert!(match Bar::Var2 {\n+        Foo::MYBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var2 {\n+        <Foo>::MYBAR => true,\n+        _ => false,\n+    });\n+    // Trait impl\n+    assert!(match Bar::Var1 {\n+        <Foo>::THEBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var1 {\n+        <Foo as HasBar>::THEBAR => true,\n+        _ => false,\n+    });\n+}"}]}