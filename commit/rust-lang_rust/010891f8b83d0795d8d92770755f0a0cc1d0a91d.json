{"sha": "010891f8b83d0795d8d92770755f0a0cc1d0a91d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDg5MWY4YjgzZDA3OTVkOGQ5Mjc3MDc1NWYwYTBjYzFkMGE5MWQ=", "commit": {"author": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2020-09-01T13:49:42Z"}, "committer": {"name": "Jon Gjengset", "email": "jon@thesquareplanet.com", "date": "2020-09-01T13:49:42Z"}, "message": "Merge branch 'master' into stabilize-vecdeque-make_contiguous", "tree": {"sha": "62e5619a7dbcd0f1ca3df8863803c9bce980fcad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62e5619a7dbcd0f1ca3df8863803c9bce980fcad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/010891f8b83d0795d8d92770755f0a0cc1d0a91d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYKAB0WIQRMIcpUBeYB4tqnGeM8sexUWnBjGAUCX05RegAKCRA8sexUWnBj\nGMTrAP0cUTeFqS9jHMBqJF7IozVCfj5bWTWl+/d8i8p9M8tKVgD/ZOwrm0vn5h0k\niwWQcHnfdXRE7ftU8l45mrAlPFhXAQg=\n=s/uV\n-----END PGP SIGNATURE-----", "payload": "tree 62e5619a7dbcd0f1ca3df8863803c9bce980fcad\nparent 2f96ce89d03b248c269513b011d328bff2c8dc21\nparent e88e908e66cd1e6e30d789b37bcd774951d01856\nauthor Jon Gjengset <jon@thesquareplanet.com> 1598968182 -0400\ncommitter Jon Gjengset <jon@thesquareplanet.com> 1598968182 -0400\n\nMerge branch 'master' into stabilize-vecdeque-make_contiguous\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/010891f8b83d0795d8d92770755f0a0cc1d0a91d", "html_url": "https://github.com/rust-lang/rust/commit/010891f8b83d0795d8d92770755f0a0cc1d0a91d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/010891f8b83d0795d8d92770755f0a0cc1d0a91d/comments", "author": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonhoo", "id": 176295, "node_id": "MDQ6VXNlcjE3NjI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/176295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonhoo", "html_url": "https://github.com/jonhoo", "followers_url": "https://api.github.com/users/jonhoo/followers", "following_url": "https://api.github.com/users/jonhoo/following{/other_user}", "gists_url": "https://api.github.com/users/jonhoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonhoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonhoo/subscriptions", "organizations_url": "https://api.github.com/users/jonhoo/orgs", "repos_url": "https://api.github.com/users/jonhoo/repos", "events_url": "https://api.github.com/users/jonhoo/events{/privacy}", "received_events_url": "https://api.github.com/users/jonhoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f96ce89d03b248c269513b011d328bff2c8dc21", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f96ce89d03b248c269513b011d328bff2c8dc21", "html_url": "https://github.com/rust-lang/rust/commit/2f96ce89d03b248c269513b011d328bff2c8dc21"}, {"sha": "e88e908e66cd1e6e30d789b37bcd774951d01856", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88e908e66cd1e6e30d789b37bcd774951d01856", "html_url": "https://github.com/rust-lang/rust/commit/e88e908e66cd1e6e30d789b37bcd774951d01856"}], "stats": {"total": 486536, "additions": 250855, "deletions": 235681}, "files": [{"sha": "6c6c816eec622e626458b7b3164d488670bacfe6", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -59,11 +59,6 @@ jobs:\n         uses: actions/checkout@v1\n         with:\n           fetch-depth: 2\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: configure the PR in which the error message will be posted\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n@@ -77,6 +72,11 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n@@ -163,11 +163,6 @@ jobs:\n         uses: actions/checkout@v1\n         with:\n           fetch-depth: 2\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: configure the PR in which the error message will be posted\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n@@ -181,6 +176,11 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n@@ -364,9 +364,6 @@ jobs:\n           - name: x86_64-gnu-distcheck\n             os: ubuntu-latest-xl\n             env: {}\n-          - name: x86_64-gnu-full-bootstrap\n-            os: ubuntu-latest-xl\n-            env: {}\n           - name: x86_64-gnu-llvm-8\n             env:\n               RUST_BACKTRACE: 1\n@@ -406,7 +403,7 @@ jobs:\n             os: windows-latest-xl\n           - name: x86_64-msvc-cargo\n             env:\n-              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n               VCVARS_BAT: vcvars64.bat\n               NO_DEBUG_ASSERTIONS: 1\n@@ -485,11 +482,6 @@ jobs:\n         uses: actions/checkout@v1\n         with:\n           fetch-depth: 2\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: configure the PR in which the error message will be posted\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n@@ -503,6 +495,11 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB\n@@ -575,36 +572,45 @@ jobs:\n       CACHE_DOMAIN: ci-caches-gha.rust-lang.org\n     if: \"github.event_name == 'push' && github.ref == 'refs/heads/auto' && github.repository == 'rust-lang-ci/rust'\"\n     strategy:\n+      fail-fast: false\n       matrix:\n         include:\n+          - name: aarch64-gnu\n+            os:\n+              - self-hosted\n+              - ARM64\n+              - linux\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              RUST_CONFIGURE_ARGS: \"--target=aarch64-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n+              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n             os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist\"\n-              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc\"\n+              RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n+              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n             os: macos-latest\n           - name: x86_64-apple\n             env:\n-              SCRIPT: \"./x.py test\"\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n+              SCRIPT: \"./x.py --stage 2 test\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8\n               MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n+              RUST_CI_TEMP_SKIP_CANCEL_OUTDATED: 1\n             os: macos-latest\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -615,11 +621,6 @@ jobs:\n         uses: actions/checkout@v1\n         with:\n           fetch-depth: 2\n-      - name: configure GitHub Actions to kill the build when outdated\n-        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n-        with:\n-          github_token: \"${{ secrets.github_token }}\"\n-        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try'\"\n       - name: configure the PR in which the error message will be posted\n         run: \"echo \\\"[CI_PR_NUMBER=$num]\\\"\"\n         env:\n@@ -633,6 +634,11 @@ jobs:\n       - name: decide whether to skip this job\n         run: src/ci/scripts/should-skip-this.sh\n         if: success() && !env.SKIP_JOB\n+      - name: configure GitHub Actions to kill the build when outdated\n+        uses: rust-lang/simpleinfra/github-actions/cancel-outdated-builds@master\n+        with:\n+          github_token: \"${{ secrets.github_token }}\"\n+        if: \"success() && !env.SKIP_JOB && github.ref != 'refs/heads/try' && !env.RUST_CI_TEMP_SKIP_CANCEL_OUTDATED\"\n       - name: collect CPU statistics\n         run: src/ci/scripts/collect-cpu-stats.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "8f4d3768c21e8601b31becfa0a2fda7ba75ced69", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -37,10 +37,13 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/10.0-2020-05-05\n+\tbranch = rustc/11.0-2020-08-20\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git\n [submodule \"src/tools/rust-analyzer\"]\n \tpath = src/tools/rust-analyzer\n \turl = https://github.com/rust-analyzer/rust-analyzer.git\n+[submodule \"library/backtrace\"]\n+\tpath = library/backtrace\n+\turl = https://github.com/rust-lang/backtrace-rs.git"}, {"sha": "cc7b2a677baf6e056006558527a750e823e9c4c3", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -176,8 +176,8 @@ Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n Martin Hafskjold Thoresen <martinhath@gmail.com>\n Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n-Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@gmail.com>\n-Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@users.noreply.github.com>\n+Mateusz Miku\u0142a <mati865@gmail.com> <mati865@users.noreply.github.com>\n+Mateusz Miku\u0142a <mati865@gmail.com> <matti@marinelayer.io>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew Kraai <kraai@ftbfs.org>"}, {"sha": "7be90aaf9e6fbdba1c2e9ba0624299dc1ee24138", "filename": "Cargo.lock", "status": "modified", "additions": 987, "deletions": 902, "changes": 1889, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "fde1cb5a35c2ed36bee3f5bd60332b6fcf1c4cdd", "filename": "Cargo.toml", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,8 +1,7 @@\n [workspace]\n members = [\n   \"src/bootstrap\",\n-  \"src/rustc\",\n-  \"src/librustc_codegen_llvm\",\n+  \"compiler/rustc\",\n   \"library/std\",\n   \"library/test\",\n   \"src/tools/cargotest\",\n@@ -13,6 +12,7 @@ members = [\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\",\n+  \"src/tools/tier-check\",\n   \"src/tools/build-manifest\",\n   \"src/tools/remote-test-client\",\n   \"src/tools/remote-test-server\",\n@@ -56,6 +56,18 @@ overflow-checks = false\n # per-crate configuration isn't specifiable in the environment.\n codegen-units = 10000\n \n+# These dependencies of the standard library implement symbolication for\n+# backtraces on most platforms. Their debuginfo causes both linking to be slower\n+# (more data to chew through) and binaries to be larger without really all that\n+# much benefit. This section turns them all to down to have no debuginfo which\n+# helps to improve link times a little bit.\n+[profile.release.package]\n+addr2line.debug = 0\n+adler.debug = 0\n+gimli.debug = 0\n+miniz_oxide.debug = 0\n+object.debug = 0\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository\n@@ -64,12 +76,13 @@ codegen-units = 10000\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"src/tools/cargo\" }\n \n-[patch.crates-io]\n+[patch.\"https://github.com/rust-lang/rustfmt\"]\n # Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n # that we're shipping as well (to ensure that the rustfmt in RLS and the\n # `rustfmt` executable are the same exact version).\n rustfmt-nightly = { path = \"src/tools/rustfmt\" }\n \n+[patch.crates-io]\n # See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n # here\n rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n@@ -80,5 +93,11 @@ rustc-std-workspace-core = { path = 'library/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n \n+# This crate's integration with libstd is a bit wonky, so we use a submodule\n+# instead of a crates.io dependency. Make sure everything else in the repo is\n+# also using the submodule, however, so we can avoid duplicate copies of the\n+# source code for this crate.\n+backtrace = { path = \"library/backtrace\" }\n+\n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "a7e23d8ac2caaeaedb3de1fe8b2aaabc790506f2", "filename": "README.md", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,9 +1,9 @@\n-<a href = \"https://www.rust-lang.org/\"> \n+<a href = \"https://www.rust-lang.org/\">\n <img width = \"90%\" height = \"auto\" src = \"https://img.shields.io/badge/Rust-Programming%20Language-black?style=flat&logo=rust\" alt = \"The Rust Programming Language\">\n </a>\n \n This is the main source code repository for [Rust]. It contains the compiler,\n-standard library, and documentation. \n+standard library, and documentation.\n \n [Rust]: https://www.rust-lang.org\n \n@@ -23,7 +23,7 @@ Read [\"Installation\"] from [The Book].\n section.**\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n-which manages the bootstrapping process. More information about it can be found \n+which manages the bootstrapping process. More information about it can be found\n by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n \n [gettingstarted]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n@@ -36,6 +36,7 @@ by running `./x.py --help` or reading the [rustc dev guide][rustcguidebuild].\n    * `python` 3 or 2.7\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n+   * `ninja`\n    * `curl`\n    * `git`\n    * `ssl` which comes in `libssl-dev` or `openssl-devel`\n@@ -111,7 +112,7 @@ build.\n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n    # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n    # or CMake installed and in PATH you can remove them from this list. Note\n-   # that it is important that you do **not** use the 'python2' and 'cmake'\n+   # that it is important that you do **not** use the 'python2', 'cmake' and 'ninja'\n    # packages from the 'msys2' subsystem. The build has historically been known\n    # to fail with these packages.\n    $ pacman -S git \\\n@@ -120,7 +121,8 @@ build.\n                tar \\\n                mingw-w64-x86_64-python \\\n                mingw-w64-x86_64-cmake \\\n-               mingw-w64-x86_64-gcc\n+               mingw-w64-x86_64-gcc \\\n+               mingw-w64-x86_64-ninja\n    ```\n \n 4. Navigate to Rust's source code (or clone it), then build it:\n@@ -157,17 +159,6 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n > python x.py build\n ```\n \n-### Building rustc with older host toolchains\n-It is still possible to build Rust with the older toolchain versions listed below, but only if the\n-LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN option is set to true in the config.toml file.\n-\n-* Clang 3.1\n-* Apple Clang 3.1\n-* GCC 4.8\n-* Visual Studio 2015 (Update 3)\n-\n-Toolchain versions older than what is listed above cannot be used to build rustc.\n-\n #### Specifying an ABI\n \n Each specific ABI can also be used from either environment (for example, using\n@@ -220,11 +211,17 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-| Platform / Architecture    | x86 | x86_64 |\n-|----------------------------|-----|--------|\n-| Windows (7, 8, 10, ...)    | \u2713   | \u2713      |\n-| Linux (2.6.18 or later)    | \u2713   | \u2713      |\n-| macOS (10.7 Lion or later) | \u2713   | \u2713      |\n+| Platform / Architecture                     | x86 | x86_64 |\n+|---------------------------------------------|-----|--------|\n+| Windows (7, 8, 10, ...)                     | \u2713   | \u2713      |\n+| Linux (kernel 2.6.32, glibc 2.11 or later)  | \u2713   | \u2713      |\n+| macOS (10.7 Lion or later)                  | (\\*) | \u2713      |\n+\n+(\\*): Apple dropped support for running 32-bit binaries starting from macOS 10.15 and iOS 11.\n+Due to this decision from Apple, the targets are no longer useful to our users.\n+Please read [our blog post][macx32] for more info.\n+\n+[macx32]: https://blog.rust-lang.org/2020/01/03/reducing-support-for-32-bit-apple-targets.html\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work."}, {"sha": "0f59d72bd16f29fa2cfacf86f222cab0ef0aedd8", "filename": "RELEASES.md", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,3 +1,140 @@\n+Version 1.46.0 (2020-08-27)\n+==========================\n+\n+Language\n+--------\n+- [`if`, `match`, and `loop` expressions can now be used in const functions.][72437]\n+- [Additionally you are now also able to coerce and cast to slices (`&[T]`) in\n+  const functions.][73862]\n+- [The `#[track_caller]` attribute can now be added to functions to use the\n+  function's caller's location information for panic messages.][72445]\n+- [Recursively indexing into tuples no longer needs parentheses.][71322] E.g.\n+  `x.0.0` over `(x.0).0`.\n+- [`mem::transmute` can now be used in statics and constants.][72920] **Note**\n+  You currently can't use `mem::transmute` in constant functions.\n+\n+Compiler\n+--------\n+- [You can now use the `cdylib` target on Apple iOS and tvOS platforms.][73516]\n+- [Enabled static \"Position Independent Executables\" by default\n+  for `x86_64-unknown-linux-musl`.][70740]\n+\n+Libraries\n+---------\n+- [`mem::forget` is now a `const fn`.][73887]\n+- [`String` now implements `From<char>`.][73466]\n+- [The `leading_ones`, and `trailing_ones` methods have been stabilised for all\n+  integer types.][73032]\n+- [`vec::IntoIter<T>` now implements `AsRef<[T]>`.][72583]\n+- [All non-zero integer types (`NonZeroU8`) now implement `TryFrom` for their\n+  zero-able equivalent (e.g. `TryFrom<u8>`).][72717]\n+- [`&[T]` and `&mut [T]` now implement `PartialEq<Vec<T>>`.][71660]\n+- [`(String, u16)` now implements `ToSocketAddrs`.][73007]\n+- [`vec::Drain<'_, T>` now implements `AsRef<[T]>`.][72584]\n+\n+Stabilized APIs\n+---------------\n+- [`Option::zip`]\n+- [`vec::Drain::as_slice`]\n+\n+Cargo\n+-----\n+Added a number of new environment variables that are now available when\n+compiling your crate.\n+\n+- [`CARGO_BIN_NAME` and `CARGO_CRATE_NAME`][cargo/8270] Providing the name of\n+  the specific binary being compiled and the name of the crate.\n+- [`CARGO_PKG_LICENSE`][cargo/8325] The license from the manifest of the package.\n+- [`CARGO_PKG_LICENSE_FILE`][cargo/8387] The path to the license file.\n+\n+Compatibility Notes\n+-------------------\n+- [The target configuration option `abi_blacklist` has been renamed\n+  to `unsupported_abis`.][74150] The old name will still continue to work.\n+- [Rustc will now warn if you cast a C-like enum that implements `Drop`.][72331]\n+  This was previously accepted but will become a hard error in a future release.\n+- [Rustc will fail to compile if you have a struct with\n+  `#[repr(i128)]` or `#[repr(u128)]`.][74109] This representation is currently only\n+  allowed on `enum`s.\n+- [Tokens passed to `macro_rules!` are now always captured.][73293] This helps\n+  ensure that spans have the correct information, and may cause breakage if you\n+  were relying on receiving spans with dummy information.\n+- [The InnoSetup installer for Windows is no longer available.][72569] This was\n+  a legacy installer that was replaced by a MSI installer a few years ago but\n+  was still being built.\n+- [`{f32, f64}::asinh` now returns the correct values for negative numbers.][72486]\n+- [Rustc will no longer accept overlapping trait implementations that only\n+  differ in how the lifetime was bound.][72493]\n+- [Rustc now correctly relates the lifetime of an existential associated\n+  type.][71896] This fixes some edge cases where `rustc` would erroneously allow\n+  you to pass a shorter lifetime than expected.\n+- [Rustc now dynamically links to `libz` (also called `zlib`) on Linux.][74420]\n+  The library will need to be installed for `rustc` to work, even though we\n+  expect it to be already available on most systems.\n+- [Tests annotated with `#[should_panic]` are broken on ARMv7 while running\n+  under QEMU.][74820]\n+- [Pretty printing of some tokens in procedural macros changed.][75453] The\n+  exact output returned by rustc's pretty printing is an unstable\n+  implementation detail: we recommend any macro relying on it to switch to a\n+  more robust parsing system.\n+\n+[75453]: https://github.com/rust-lang/rust/issues/75453/\n+[74820]: https://github.com/rust-lang/rust/issues/74820/\n+[74420]: https://github.com/rust-lang/rust/issues/74420/\n+[74109]: https://github.com/rust-lang/rust/pull/74109/\n+[74150]: https://github.com/rust-lang/rust/pull/74150/\n+[73862]: https://github.com/rust-lang/rust/pull/73862/\n+[73887]: https://github.com/rust-lang/rust/pull/73887/\n+[73466]: https://github.com/rust-lang/rust/pull/73466/\n+[73516]: https://github.com/rust-lang/rust/pull/73516/\n+[73293]: https://github.com/rust-lang/rust/pull/73293/\n+[73007]: https://github.com/rust-lang/rust/pull/73007/\n+[73032]: https://github.com/rust-lang/rust/pull/73032/\n+[72920]: https://github.com/rust-lang/rust/pull/72920/\n+[72569]: https://github.com/rust-lang/rust/pull/72569/\n+[72583]: https://github.com/rust-lang/rust/pull/72583/\n+[72584]: https://github.com/rust-lang/rust/pull/72584/\n+[72717]: https://github.com/rust-lang/rust/pull/72717/\n+[72437]: https://github.com/rust-lang/rust/pull/72437/\n+[72445]: https://github.com/rust-lang/rust/pull/72445/\n+[72486]: https://github.com/rust-lang/rust/pull/72486/\n+[72493]: https://github.com/rust-lang/rust/pull/72493/\n+[72331]: https://github.com/rust-lang/rust/pull/72331/\n+[71896]: https://github.com/rust-lang/rust/pull/71896/\n+[71660]: https://github.com/rust-lang/rust/pull/71660/\n+[71322]: https://github.com/rust-lang/rust/pull/71322/\n+[70740]: https://github.com/rust-lang/rust/pull/70740/\n+[cargo/8270]: https://github.com/rust-lang/cargo/pull/8270/\n+[cargo/8325]: https://github.com/rust-lang/cargo/pull/8325/\n+[cargo/8387]: https://github.com/rust-lang/cargo/pull/8387/\n+[`Option::zip`]: https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.zip\n+[`vec::Drain::as_slice`]: https://doc.rust-lang.org/stable/std/vec/struct.Drain.html#method.as_slice\n+\n+\n+Version 1.45.2 (2020-08-03)\n+==========================\n+\n+* [Fix bindings in tuple struct patterns][74954]\n+* [Fix track_caller integration with trait objects][74784]\n+\n+[74954]: https://github.com/rust-lang/rust/issues/74954\n+[74784]: https://github.com/rust-lang/rust/issues/74784\n+\n+\n+Version 1.45.1 (2020-07-30)\n+==========================\n+\n+* [Fix const propagation with references.][73613]\n+* [rustfmt accepts rustfmt_skip in cfg_attr again.][73078]\n+* [Avoid spurious implicit region bound.][74509]\n+* [Install clippy on x.py install][74457]\n+\n+[73613]: https://github.com/rust-lang/rust/pull/73613\n+[73078]: https://github.com/rust-lang/rust/issues/73078\n+[74509]: https://github.com/rust-lang/rust/pull/74509\n+[74457]: https://github.com/rust-lang/rust/pull/74457\n+\n+\n Version 1.45.0 (2020-07-16)\n ==========================\n "}, {"sha": "cf011e63e02fde772502827fc03e12b24b3e49a4", "filename": "compiler/rustc/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,21 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+edition = '2018'\n+\n+[dependencies]\n+rustc_driver = { path = \"../rustc_driver\" }\n+\n+# Make sure rustc_codegen_ssa ends up in the sysroot, because this\n+# crate is intended to be used by codegen backends, which may not be in-tree.\n+rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+\n+[dependencies.jemalloc-sys]\n+version = '0.3.0'\n+optional = true\n+features = ['unprefixed_malloc_on_supported_platforms']\n+\n+[features]\n+jemalloc = ['jemalloc-sys']\n+llvm = ['rustc_driver/llvm']"}, {"sha": "6bc5aa6382c4cd1a9bb3c43e64ab38b731f39f53", "filename": "compiler/rustc/src/main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/rustc/rustc.rs"}, {"sha": "306513f1a7eaf28742f51e8e9d94f99429ebe0fa", "filename": "compiler/rustc_apfloat/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+bitflags = \"1.2.1\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "e3d941cad7ae5810b95abeae3403c25e3c8b78d0", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_apfloat/ieee.rs"}, {"sha": "ba3adc4a135cb3a1e51b64cffe18fcc070799825", "filename": "compiler/rustc_apfloat/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_apfloat/lib.rs"}, {"sha": "4ae8edf3157eb3b8665372412489778dc5288341", "filename": "compiler/rustc_apfloat/src/ppc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fppc.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_apfloat/ppc.rs"}, {"sha": "2d8bb7d1e8e03911d0086ea58bbaf4b9a155eb54", "filename": "compiler/rustc_apfloat/tests/ieee.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_apfloat/tests/ieee.rs"}, {"sha": "5a8de71cb3490bc1fd73e6c9b912219d9ebcbdb1", "filename": "compiler/rustc_apfloat/tests/ppc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Ftests%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_apfloat%2Ftests%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Ftests%2Fppc.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_apfloat/tests/ppc.rs"}, {"sha": "41701f3255f481b70768599b7924e17f229efd89", "filename": "compiler/rustc_arena/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_arena\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "5e6a0340d12a0f35d12956b32dfc93595b5efe5b", "filename": "compiler/rustc_arena/src/lib.rs", "status": "added", "additions": 702, "deletions": 0, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,702 @@\n+//! The arena, a fast but limited type of allocator.\n+//!\n+//! Arenas are a type of allocator that destroy the objects within, all at\n+//! once, once the arena itself is destroyed. They do not support deallocation\n+//! of individual objects while the arena itself is still alive. The benefit\n+//! of an arena is very fast allocation; just a pointer bump.\n+//!\n+//! This crate implements several kinds of arena.\n+\n+#![doc(\n+    html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+    test(no_crate_inject, attr(deny(warnings)))\n+)]\n+#![feature(core_intrinsics)]\n+#![feature(dropck_eyepatch)]\n+#![feature(raw_vec_internals)]\n+#![cfg_attr(test, feature(test))]\n+#![allow(deprecated)]\n+\n+extern crate alloc;\n+\n+use rustc_data_structures::cold_path;\n+use smallvec::SmallVec;\n+\n+use std::alloc::Layout;\n+use std::cell::{Cell, RefCell};\n+use std::cmp;\n+use std::intrinsics;\n+use std::marker::{PhantomData, Send};\n+use std::mem;\n+use std::ptr;\n+use std::slice;\n+\n+use alloc::raw_vec::RawVec;\n+\n+/// An arena that can hold objects of only one type.\n+pub struct TypedArena<T> {\n+    /// A pointer to the next object to be allocated.\n+    ptr: Cell<*mut T>,\n+\n+    /// A pointer to the end of the allocated area. When this pointer is\n+    /// reached, a new chunk is allocated.\n+    end: Cell<*mut T>,\n+\n+    /// A vector of arena chunks.\n+    chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n+\n+    /// Marker indicating that dropping the arena causes its owned\n+    /// instances of `T` to be dropped.\n+    _own: PhantomData<T>,\n+}\n+\n+struct TypedArenaChunk<T> {\n+    /// The raw storage for the arena chunk.\n+    storage: RawVec<T>,\n+    /// The number of valid entries in the chunk.\n+    entries: usize,\n+}\n+\n+impl<T> TypedArenaChunk<T> {\n+    #[inline]\n+    unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n+        TypedArenaChunk { storage: RawVec::with_capacity(capacity), entries: 0 }\n+    }\n+\n+    /// Destroys this arena chunk.\n+    #[inline]\n+    unsafe fn destroy(&mut self, len: usize) {\n+        // The branch on needs_drop() is an -O1 performance optimization.\n+        // Without the branch, dropping TypedArena<u8> takes linear time.\n+        if mem::needs_drop::<T>() {\n+            let mut start = self.start();\n+            // Destroy all allocated objects.\n+            for _ in 0..len {\n+                ptr::drop_in_place(start);\n+                start = start.offset(1);\n+            }\n+        }\n+    }\n+\n+    // Returns a pointer to the first allocated object.\n+    #[inline]\n+    fn start(&self) -> *mut T {\n+        self.storage.ptr()\n+    }\n+\n+    // Returns a pointer to the end of the allocated space.\n+    #[inline]\n+    fn end(&self) -> *mut T {\n+        unsafe {\n+            if mem::size_of::<T>() == 0 {\n+                // A pointer as large as possible for zero-sized elements.\n+                !0 as *mut T\n+            } else {\n+                self.start().add(self.storage.capacity())\n+            }\n+        }\n+    }\n+}\n+\n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n+const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n+\n+impl<T> Default for TypedArena<T> {\n+    /// Creates a new `TypedArena`.\n+    fn default() -> TypedArena<T> {\n+        TypedArena {\n+            // We set both `ptr` and `end` to 0 so that the first call to\n+            // alloc() will trigger a grow().\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n+            chunks: RefCell::new(vec![]),\n+            _own: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T> TypedArena<T> {\n+    /// Allocates an object in the `TypedArena`, returning a reference to it.\n+    #[inline]\n+    pub fn alloc(&self, object: T) -> &mut T {\n+        if self.ptr == self.end {\n+            self.grow(1)\n+        }\n+\n+        unsafe {\n+            if mem::size_of::<T>() == 0 {\n+                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                let ptr = mem::align_of::<T>() as *mut T;\n+                // Don't drop the object. This `write` is equivalent to `forget`.\n+                ptr::write(ptr, object);\n+                &mut *ptr\n+            } else {\n+                let ptr = self.ptr.get();\n+                // Advance the pointer.\n+                self.ptr.set(self.ptr.get().offset(1));\n+                // Write into uninitialized memory.\n+                ptr::write(ptr, object);\n+                &mut *ptr\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn can_allocate(&self, additional: usize) -> bool {\n+        let available_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let additional_bytes = additional.checked_mul(mem::size_of::<T>()).unwrap();\n+        available_bytes >= additional_bytes\n+    }\n+\n+    /// Ensures there's enough space in the current chunk to fit `len` objects.\n+    #[inline]\n+    fn ensure_capacity(&self, additional: usize) {\n+        if !self.can_allocate(additional) {\n+            self.grow(additional);\n+            debug_assert!(self.can_allocate(additional));\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_raw_slice(&self, len: usize) -> *mut T {\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(len != 0);\n+\n+        self.ensure_capacity(len);\n+\n+        let start_ptr = self.ptr.get();\n+        self.ptr.set(start_ptr.add(len));\n+        start_ptr\n+    }\n+\n+    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n+    /// reference to it. Will panic if passed a zero-sized types.\n+    ///\n+    /// Panics:\n+    ///\n+    ///  - Zero-sized types\n+    ///  - Zero-length slices\n+    #[inline]\n+    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n+    where\n+        T: Copy,\n+    {\n+        unsafe {\n+            let len = slice.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            slice::from_raw_parts_mut(start_ptr, len)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        assert!(mem::size_of::<T>() != 0);\n+        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n+        if vec.is_empty() {\n+            return &mut [];\n+        }\n+        // Move the content to the arena by copying it and then forgetting\n+        // the content of the SmallVec\n+        unsafe {\n+            let len = vec.len();\n+            let start_ptr = self.alloc_raw_slice(len);\n+            vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+            vec.set_len(0);\n+            slice::from_raw_parts_mut(start_ptr, len)\n+        }\n+    }\n+\n+    /// Grows the arena.\n+    #[inline(never)]\n+    #[cold]\n+    fn grow(&self, additional: usize) {\n+        unsafe {\n+            // We need the element size to convert chunk sizes (ranging from\n+            // PAGE to HUGE_PAGE bytes) to element counts.\n+            let elem_size = cmp::max(1, mem::size_of::<T>());\n+            let mut chunks = self.chunks.borrow_mut();\n+            let mut new_cap;\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                last_chunk.entries = used_bytes / mem::size_of::<T>();\n+\n+                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // bytes, then this chunk will be least double the previous\n+                // chunk's size.\n+                new_cap = last_chunk.storage.capacity();\n+                if new_cap < HUGE_PAGE / elem_size {\n+                    new_cap = new_cap.checked_mul(2).unwrap();\n+                }\n+            } else {\n+                new_cap = PAGE / elem_size;\n+            }\n+            // Also ensure that this chunk can fit `additional`.\n+            new_cap = cmp::max(additional, new_cap);\n+\n+            let chunk = TypedArenaChunk::<T>::new(new_cap);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n+        }\n+    }\n+\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    pub fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                let len = chunks_borrow.len();\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..len - 1) {\n+                    chunk.destroy(chunk.entries);\n+                }\n+            }\n+        }\n+    }\n+\n+    // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n+    // chunks.\n+    fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n+        // Determine how much was filled.\n+        let start = last_chunk.start() as usize;\n+        // We obtain the value of the pointer to the first uninitialized element.\n+        let end = self.ptr.get() as usize;\n+        // We then calculate the number of elements to be dropped in the last chunk,\n+        // which is the filled area's length.\n+        let diff = if mem::size_of::<T>() == 0 {\n+            // `T` is ZST. It can't have a drop flag, so the value here doesn't matter. We get\n+            // the number of zero-sized values in the last and only chunk, just out of caution.\n+            // Recall that `end` was incremented for each allocated value.\n+            end - start\n+        } else {\n+            (end - start) / mem::size_of::<T>()\n+        };\n+        // Pass that to the `destroy` method.\n+        unsafe {\n+            last_chunk.destroy(diff);\n+        }\n+        // Reset the chunk.\n+        self.ptr.set(last_chunk.start());\n+    }\n+}\n+\n+unsafe impl<#[may_dangle] T> Drop for TypedArena<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Determine how much was filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                // Drop the contents of the last chunk.\n+                self.clear_last_chunk(&mut last_chunk);\n+                // The last chunk will be dropped. Destroy all other chunks.\n+                for chunk in chunks_borrow.iter_mut() {\n+                    chunk.destroy(chunk.entries);\n+                }\n+            }\n+            // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n+        }\n+    }\n+}\n+\n+unsafe impl<T: Send> Send for TypedArena<T> {}\n+\n+pub struct DroplessArena {\n+    /// A pointer to the next object to be allocated.\n+    ptr: Cell<*mut u8>,\n+\n+    /// A pointer to the end of the allocated area. When this pointer is\n+    /// reached, a new chunk is allocated.\n+    end: Cell<*mut u8>,\n+\n+    /// A vector of arena chunks.\n+    chunks: RefCell<Vec<TypedArenaChunk<u8>>>,\n+}\n+\n+unsafe impl Send for DroplessArena {}\n+\n+impl Default for DroplessArena {\n+    #[inline]\n+    fn default() -> DroplessArena {\n+        DroplessArena {\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n+            chunks: Default::default(),\n+        }\n+    }\n+}\n+\n+impl DroplessArena {\n+    #[inline(never)]\n+    #[cold]\n+    fn grow(&self, additional: usize) {\n+        unsafe {\n+            let mut chunks = self.chunks.borrow_mut();\n+            let mut new_cap;\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                // There is no need to update `last_chunk.entries` because that\n+                // field isn't used by `DroplessArena`.\n+\n+                // If the previous chunk's capacity is less than HUGE_PAGE\n+                // bytes, then this chunk will be least double the previous\n+                // chunk's size.\n+                new_cap = last_chunk.storage.capacity();\n+                if new_cap < HUGE_PAGE {\n+                    new_cap = new_cap.checked_mul(2).unwrap();\n+                }\n+            } else {\n+                new_cap = PAGE;\n+            }\n+            // Also ensure that this chunk can fit `additional`.\n+            new_cap = cmp::max(additional, new_cap);\n+\n+            let chunk = TypedArenaChunk::<u8>::new(new_cap);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n+        }\n+    }\n+\n+    /// Allocates a byte slice with specified layout from the current memory\n+    /// chunk. Returns `None` if there is no free space left to satisfy the\n+    /// request.\n+    #[inline]\n+    fn alloc_raw_without_grow(&self, layout: Layout) -> Option<*mut u8> {\n+        let ptr = self.ptr.get() as usize;\n+        let end = self.end.get() as usize;\n+        let align = layout.align();\n+        let bytes = layout.size();\n+        // The allocation request fits into the current chunk iff:\n+        //\n+        // let aligned = align_to(ptr, align);\n+        // ptr <= aligned && aligned + bytes <= end\n+        //\n+        // Except that we work with fixed width integers and need to be careful\n+        // about potential overflow in the calcuation. If the overflow does\n+        // happen, then we definitely don't have enough free and need to grow\n+        // the arena.\n+        let aligned = ptr.checked_add(align - 1)? & !(align - 1);\n+        let new_ptr = aligned.checked_add(bytes)?;\n+        if new_ptr <= end {\n+            self.ptr.set(new_ptr as *mut u8);\n+            Some(aligned as *mut u8)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_raw(&self, layout: Layout) -> *mut u8 {\n+        assert!(layout.size() != 0);\n+        loop {\n+            if let Some(a) = self.alloc_raw_without_grow(layout) {\n+                break a;\n+            }\n+            // No free space left. Allocate a new chunk to satisfy the request.\n+            // On failure the grow will panic or abort.\n+            self.grow(layout.size());\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let mem = self.alloc_raw(Layout::for_value::<T>(&object)) as *mut T;\n+\n+        unsafe {\n+            // Write into uninitialized memory.\n+            ptr::write(mem, object);\n+            &mut *mem\n+        }\n+    }\n+\n+    /// Allocates a slice of objects that are copied into the `DroplessArena`, returning a mutable\n+    /// reference to it. Will panic if passed a zero-sized type.\n+    ///\n+    /// Panics:\n+    ///\n+    ///  - Zero-sized types\n+    ///  - Zero-length slices\n+    #[inline]\n+    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n+    where\n+        T: Copy,\n+    {\n+        assert!(!mem::needs_drop::<T>());\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!slice.is_empty());\n+\n+        let mem = self.alloc_raw(Layout::for_value::<[T]>(slice)) as *mut T;\n+\n+        unsafe {\n+            mem.copy_from_nonoverlapping(slice.as_ptr(), slice.len());\n+            slice::from_raw_parts_mut(mem, slice.len())\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n+        &self,\n+        mut iter: I,\n+        len: usize,\n+        mem: *mut T,\n+    ) -> &mut [T] {\n+        let mut i = 0;\n+        // Use a manual loop since LLVM manages to optimize it better for\n+        // slice iterators\n+        loop {\n+            let value = iter.next();\n+            if i >= len || value.is_none() {\n+                // We only return as many items as the iterator gave us, even\n+                // though it was supposed to give us `len`\n+                return slice::from_raw_parts_mut(mem, i);\n+            }\n+            ptr::write(mem.add(i), value.unwrap());\n+            i += 1;\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let iter = iter.into_iter();\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let size_hint = iter.size_hint();\n+\n+        match size_hint {\n+            (min, Some(max)) if min == max => {\n+                // We know the exact number of elements the iterator will produce here\n+                let len = min;\n+\n+                if len == 0 {\n+                    return &mut [];\n+                }\n+\n+                let mem = self.alloc_raw(Layout::array::<T>(len).unwrap()) as *mut T;\n+                unsafe { self.write_from_iter(iter, len, mem) }\n+            }\n+            (_, _) => {\n+                cold_path(move || -> &mut [T] {\n+                    let mut vec: SmallVec<[_; 8]> = iter.collect();\n+                    if vec.is_empty() {\n+                        return &mut [];\n+                    }\n+                    // Move the content to the arena by copying it and then forgetting\n+                    // the content of the SmallVec\n+                    unsafe {\n+                        let len = vec.len();\n+                        let start_ptr =\n+                            self.alloc_raw(Layout::for_value::<[T]>(vec.as_slice())) as *mut T;\n+                        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+                        vec.set_len(0);\n+                        slice::from_raw_parts_mut(start_ptr, len)\n+                    }\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// Calls the destructor for an object when dropped.\n+struct DropType {\n+    drop_fn: unsafe fn(*mut u8),\n+    obj: *mut u8,\n+}\n+\n+unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n+    std::ptr::drop_in_place(to_drop as *mut T)\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {\n+        unsafe { (self.drop_fn)(self.obj) }\n+    }\n+}\n+\n+/// An arena which can be used to allocate any type.\n+/// Allocating in this arena is unsafe since the type system\n+/// doesn't know which types it contains. In order to\n+/// allocate safely, you must store a PhantomData<T>\n+/// alongside this arena for each type T you allocate.\n+#[derive(Default)]\n+pub struct DropArena {\n+    /// A list of destructors to run when the arena drops.\n+    /// Ordered so `destructors` gets dropped before the arena\n+    /// since its destructor can reference memory in the arena.\n+    destructors: RefCell<Vec<DropType>>,\n+    arena: DroplessArena,\n+}\n+\n+impl DropArena {\n+    #[inline]\n+    pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n+        let mem = self.arena.alloc_raw(Layout::new::<T>()) as *mut T;\n+        // Write into uninitialized memory.\n+        ptr::write(mem, object);\n+        let result = &mut *mem;\n+        // Record the destructor after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        self.destructors\n+            .borrow_mut()\n+            .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n+        result\n+    }\n+\n+    #[inline]\n+    pub unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n+        if vec.is_empty() {\n+            return &mut [];\n+        }\n+        let len = vec.len();\n+\n+        let start_ptr = self.arena.alloc_raw(Layout::array::<T>(len).unwrap()) as *mut T;\n+\n+        let mut destructors = self.destructors.borrow_mut();\n+        // Reserve space for the destructors so we can't panic while adding them\n+        destructors.reserve(len);\n+\n+        // Move the content to the arena by copying it and then forgetting\n+        // the content of the SmallVec\n+        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+        mem::forget(vec.drain(..));\n+\n+        // Record the destructors after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        for i in 0..len {\n+            destructors.push(DropType {\n+                drop_fn: drop_for_type::<T>,\n+                obj: start_ptr.offset(i as isize) as *mut u8,\n+            });\n+        }\n+\n+        slice::from_raw_parts_mut(start_ptr, len)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! arena_for_type {\n+    ([][$ty:ty]) => {\n+        $crate::TypedArena<$ty>\n+    };\n+    ([few $(, $attrs:ident)*][$ty:ty]) => {\n+        ::std::marker::PhantomData<$ty>\n+    };\n+    ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n+        $crate::arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! which_arena_for_type {\n+    ([][$arena:expr]) => {\n+        ::std::option::Option::Some($arena)\n+    };\n+    ([few$(, $attrs:ident)*][$arena:expr]) => {\n+        ::std::option::Option::None\n+    };\n+    ([$ignore:ident$(, $attrs:ident)*]$args:tt) => {\n+        $crate::which_arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! declare_arena {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+        #[derive(Default)]\n+        pub struct Arena<$tcx> {\n+            pub dropless: $crate::DroplessArena,\n+            drop: $crate::DropArena,\n+            $($name: $crate::arena_for_type!($a[$ty]),)*\n+        }\n+\n+        pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n+            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n+            fn allocate_from_iter<'a>(\n+                arena: &'a Arena<'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'a mut [Self];\n+        }\n+\n+        impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n+            #[inline]\n+            fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n+                arena.dropless.alloc(self)\n+            }\n+            #[inline]\n+            fn allocate_from_iter<'a>(\n+                arena: &'a Arena<'tcx>,\n+                iter: impl ::std::iter::IntoIterator<Item = Self>,\n+            ) -> &'a mut [Self] {\n+                arena.dropless.alloc_from_iter(iter)\n+            }\n+\n+        }\n+        $(\n+            impl<$tcx> ArenaAllocatable<$tcx, $ty> for $ty {\n+                #[inline]\n+                fn allocate_on<'a>(self, arena: &'a Arena<$tcx>) -> &'a mut Self {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc(self);\n+                    }\n+                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc(self)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc(self) },\n+                    }\n+                }\n+\n+                #[inline]\n+                fn allocate_from_iter<'a>(\n+                    arena: &'a Arena<$tcx>,\n+                    iter: impl ::std::iter::IntoIterator<Item = Self>,\n+                ) -> &'a mut [Self] {\n+                    if !::std::mem::needs_drop::<Self>() {\n+                        return arena.dropless.alloc_from_iter(iter);\n+                    }\n+                    match $crate::which_arena_for_type!($a[&arena.$name]) {\n+                        ::std::option::Option::<&$crate::TypedArena<Self>>::Some(ty_arena) => {\n+                            ty_arena.alloc_from_iter(iter)\n+                        }\n+                        ::std::option::Option::None => unsafe { arena.drop.alloc_from_iter(iter) },\n+                    }\n+                }\n+            }\n+        )*\n+\n+        impl<'tcx> Arena<'tcx> {\n+            #[inline]\n+            pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n+                value.allocate_on(self)\n+            }\n+\n+            #[inline]\n+            pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n+                if value.is_empty() {\n+                    return &mut [];\n+                }\n+                self.dropless.alloc_slice(value)\n+            }\n+\n+            pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n+                &'a self,\n+                iter: impl ::std::iter::IntoIterator<Item = T>,\n+            ) -> &'a mut [T] {\n+                T::allocate_from_iter(self, iter)\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "8e63bdf545841b727ff59e1dd41eb1430750c9d4", "filename": "compiler/rustc_arena/src/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_arena/tests.rs"}, {"sha": "13e17a807c4840cec64cd0493594c059bf536bfd", "filename": "compiler/rustc_ast/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ast\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+tracing = \"0.1\"\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_lexer = { path = \"../rustc_lexer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+bitflags = \"1.2.1\""}, {"sha": "dd407dba1f4cca03b3e19bce687b40e49a3ead68", "filename": "compiler/rustc_ast/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FREADME.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast/README.md"}, {"sha": "127a53cad2b30481776766e72d9058aade43c100", "filename": "compiler/rustc_ast/src/ast.rs", "status": "renamed", "additions": 183, "deletions": 125, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -23,7 +23,7 @@ pub use GenericArgs::*;\n pub use UnsafeSource::*;\n \n use crate::ptr::P;\n-use crate::token::{self, DelimToken};\n+use crate::token::{self, CommentKind, DelimToken};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -35,6 +35,7 @@ use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n+use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::fmt;\n use std::iter;\n@@ -52,7 +53,7 @@ mod tests;\n /// ```\n ///\n /// `'outer` is a label.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Copy, HashStable_Generic)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -65,7 +66,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -89,7 +90,7 @@ impl fmt::Display for Lifetime {\n /// along with a bunch of supporting information.\n ///\n /// E.g., `std::cmp::PartialEq`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n@@ -127,7 +128,7 @@ impl Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n ///\n /// E.g., `std`, `String` or `Box<T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -155,7 +156,7 @@ impl PathSegment {\n /// The arguments of a path segment.\n ///\n /// E.g., `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArgs {\n     /// The `<'a, A, B, C>` in `foo::bar::baz::<'a, A, B, C>`.\n     AngleBracketed(AngleBracketedArgs),\n@@ -187,7 +188,7 @@ impl GenericArgs {\n }\n \n /// Concrete argument in the sequence of generic args.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArg {\n     /// `'a` in `Foo<'a>`\n     Lifetime(Lifetime),\n@@ -208,7 +209,7 @@ impl GenericArg {\n }\n \n /// A path like `Foo<'a, T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n@@ -218,7 +219,7 @@ pub struct AngleBracketedArgs {\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n /// or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AngleBracketedArg {\n     /// Argument for a generic parameter.\n     Arg(GenericArg),\n@@ -239,7 +240,7 @@ impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n }\n \n /// A path like `Foo(A, B) -> C`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n@@ -268,7 +269,7 @@ pub use crate::node_id::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n /// A modifier on a bound, e.g., `?Sized` or `?const Trait`.\n ///\n /// Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n pub enum TraitBoundModifier {\n     /// No modifiers\n     None,\n@@ -289,7 +290,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -309,24 +310,54 @@ pub type GenericBounds = Vec<GenericBound>;\n /// Specifies the enforced ordering for generic parameters. In the future,\n /// if we wanted to relax this order, we could override `PartialEq` and\n /// `PartialOrd`, to allow the kinds to be unordered.\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy)]\n+#[derive(Hash, Clone, Copy)]\n pub enum ParamKindOrd {\n     Lifetime,\n     Type,\n-    Const,\n+    // `unordered` is only `true` if `sess.has_features().const_generics`\n+    // is active. Specifically, if it's only `min_const_generics`, it will still require\n+    // ordering consts after types.\n+    Const { unordered: bool },\n+}\n+\n+impl Ord for ParamKindOrd {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        use ParamKindOrd::*;\n+        let to_int = |v| match v {\n+            Lifetime => 0,\n+            Type | Const { unordered: true } => 1,\n+            // technically both consts should be ordered equally,\n+            // but only one is ever encountered at a time, so this is\n+            // fine.\n+            Const { unordered: false } => 2,\n+        };\n+\n+        to_int(*self).cmp(&to_int(*other))\n+    }\n+}\n+impl PartialOrd for ParamKindOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+impl PartialEq for ParamKindOrd {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.cmp(other) == Ordering::Equal\n+    }\n }\n+impl Eq for ParamKindOrd {}\n \n impl fmt::Display for ParamKindOrd {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             ParamKindOrd::Lifetime => \"lifetime\".fmt(f),\n             ParamKindOrd::Type => \"type\".fmt(f),\n-            ParamKindOrd::Const => \"const\".fmt(f),\n+            ParamKindOrd::Const { .. } => \"const\".fmt(f),\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime,\n@@ -340,7 +371,7 @@ pub enum GenericParamKind {\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -352,7 +383,7 @@ pub struct GenericParam {\n \n /// Represents lifetime, type and const parameters attached to a declaration of\n /// a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n     pub params: Vec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -375,10 +406,10 @@ impl Default for Generics {\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereClause {\n     /// `true` if we ate a `where` token: this can happen\n-    /// if we parsed no predicates (e.g. `struct Foo where {}\n+    /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to accurately pretty-print\n     /// in `nt_to_tokenstream`\n     pub has_where_token: bool,\n@@ -387,7 +418,7 @@ pub struct WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -410,7 +441,7 @@ impl WherePredicate {\n /// A type bound.\n ///\n /// E.g., `for<'c> Foo: Send + Clone + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -424,7 +455,7 @@ pub struct WhereBoundPredicate {\n /// A lifetime predicate.\n ///\n /// E.g., `'a: 'b + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n@@ -434,15 +465,15 @@ pub struct WhereRegionPredicate {\n /// An equality predicate (unsupported).\n ///\n /// E.g., `T = int`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -459,7 +490,7 @@ pub struct Crate {\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n@@ -472,7 +503,7 @@ pub enum NestedMetaItem {\n /// A spanned compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MetaItem {\n     pub path: Path,\n     pub kind: MetaItemKind,\n@@ -482,7 +513,7 @@ pub struct MetaItem {\n /// A compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -501,7 +532,7 @@ pub enum MetaItemKind {\n /// A block (`{ .. }`).\n ///\n /// E.g., `{ .. }` as in `fn foo() { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n     pub stmts: Vec<Stmt>,\n@@ -514,11 +545,12 @@ pub struct Block {\n /// A match pattern.\n ///\n /// Patterns appear in match statements and some other contexts, such as `let` and `if let`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n     pub span: Span,\n+    pub tokens: Option<TokenStream>,\n }\n \n impl Pat {\n@@ -605,7 +637,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except is_shorthand is true\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n     pub ident: Ident,\n@@ -618,27 +650,27 @@ pub struct FieldPat {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BindingMode {\n     ByRef(Mutability),\n     ByValue(Mutability),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeEnd {\n     Included(RangeSyntax),\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeSyntax {\n     /// `...`\n     DotDotDot,\n     /// `..=`\n     DotDotEq,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`).\n     Wild,\n@@ -705,8 +737,8 @@ pub enum PatKind {\n     MacCall(MacCall),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n     Mut,\n     Not,\n@@ -739,7 +771,7 @@ impl Mutability {\n /// The kind of borrow in an `AddrOf` expression,\n /// e.g., `&place` or `&raw const place`.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum BorrowKind {\n     /// A normal borrow, `&$expr` or `&mut $expr`.\n     /// The resulting type is either `&'a T` or `&'a mut T`\n@@ -751,7 +783,7 @@ pub enum BorrowKind {\n     Raw,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n     Add,\n@@ -850,7 +882,7 @@ pub type BinOp = Spanned<BinOpKind>;\n /// Unary operator.\n ///\n /// Note that `&data` is not an operator, it's an `AddrOf` expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n     Deref,\n@@ -879,7 +911,7 @@ impl UnOp {\n }\n \n /// A statement\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n@@ -913,7 +945,7 @@ impl Stmt {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n@@ -929,7 +961,7 @@ pub enum StmtKind {\n     MacCall(P<(MacCall, MacStmtStyle, AttrVec)>),\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon (e.g., `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`).\n@@ -943,7 +975,7 @@ pub enum MacStmtStyle {\n }\n \n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Local {\n     pub id: NodeId,\n     pub pat: P<Pat>,\n@@ -964,7 +996,7 @@ pub struct Local {\n ///     _ => { println!(\"no match!\") },\n /// }\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     /// Match arm pattern, e.g. `10` in `match foo { 10 => {}, _ => {} }`\n@@ -979,7 +1011,7 @@ pub struct Arm {\n }\n \n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Field {\n     pub attrs: AttrVec,\n     pub id: NodeId,\n@@ -990,13 +1022,13 @@ pub struct Field {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n     Unsafe(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1007,14 +1039,14 @@ pub enum UnsafeSource {\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AnonConst {\n     pub id: NodeId,\n     pub value: P<Expr>,\n }\n \n /// An expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n@@ -1052,6 +1084,30 @@ impl Expr {\n         }\n     }\n \n+    /// Is this expr either `N`, or `{ N }`.\n+    ///\n+    /// If this is not the case, name resolution does not resolve `N` when using\n+    /// `feature(min_const_generics)` as more complex expressions are not supported.\n+    pub fn is_potential_trivial_const_param(&self) -> bool {\n+        let this = if let ExprKind::Block(ref block, None) = self.kind {\n+            if block.stmts.len() == 1 {\n+                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n+            } else {\n+                self\n+            }\n+        } else {\n+            self\n+        };\n+\n+        if let ExprKind::Path(None, ref path) = this.kind {\n+            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n@@ -1149,15 +1205,15 @@ impl Expr {\n }\n \n /// Limit types of a range (inclusive or exclusive)\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug)]\n pub enum RangeLimits {\n     /// Inclusive at the beginning, exclusive at the end\n     HalfOpen,\n     /// Inclusive at the beginning and end\n     Closed,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1314,7 +1370,7 @@ pub enum ExprKind {\n ///  ^~~~~    ^\n ///  ty       position = 0\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n \n@@ -1326,7 +1382,7 @@ pub struct QSelf {\n }\n \n /// A capture clause used in closures and `async` blocks.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CaptureBy {\n     /// `move |x| y + x`.\n     Value,\n@@ -1336,7 +1392,7 @@ pub enum CaptureBy {\n \n /// The movability of a generator / closure literal:\n /// whether a generator contains self-references, causing it to be `!Unpin`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum Movability {\n     /// May contain self-references, `!Unpin`.\n@@ -1347,7 +1403,7 @@ pub enum Movability {\n \n /// Represents a macro invocation. The `path` indicates which macro\n /// is being invoked, and the `args` are arguments passed to it.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n     pub args: P<MacArgs>,\n@@ -1361,7 +1417,7 @@ impl MacCall {\n }\n \n /// Arguments passed to an attribute or a function-like macro.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacArgs {\n     /// No arguments - `#[attr]`.\n     Empty,\n@@ -1422,7 +1478,7 @@ impl MacArgs {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n     Bracket,\n@@ -1449,14 +1505,14 @@ impl MacDelimiter {\n }\n \n /// Represents a macro definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n     pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, Eq, PartialEq)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n@@ -1468,7 +1524,7 @@ pub enum StrStyle {\n }\n \n /// An AST literal.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     /// The original literal token as written in source code.\n     pub token: token::Lit,\n@@ -1480,7 +1536,7 @@ pub struct Lit {\n }\n \n /// Same as `Lit`, but restricted to string literals.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n     /// The original literal token as written in source code.\n     pub style: StrStyle,\n@@ -1507,7 +1563,7 @@ impl StrLit {\n }\n \n /// Type of the integer literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitIntType {\n     /// e.g. `42_i32`.\n@@ -1519,7 +1575,7 @@ pub enum LitIntType {\n }\n \n /// Type of the float literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitFloatType {\n     /// A float literal with a suffix (`1f32` or `1E10f32`).\n@@ -1531,7 +1587,7 @@ pub enum LitFloatType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),\n@@ -1603,22 +1659,23 @@ impl LitKind {\n \n // N.B., If you change this, you'll probably want to change the corresponding\n // type structure in `middle/ty.rs` as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or free function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n+    pub span: Span,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum FloatTy {\n     F32,\n     F64,\n@@ -1647,8 +1704,8 @@ impl FloatTy {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -1712,8 +1769,8 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -1776,7 +1833,7 @@ impl UintTy {\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1785,22 +1842,22 @@ pub struct AssocTyConstraint {\n }\n \n /// The kinds of an `AssocTyConstraint`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocTyConstraintKind {\n     /// E.g., `A = Bar` in `Foo<A = Bar>`.\n     Equality { ty: P<Ty> },\n     /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n     Bound { bounds: GenericBounds },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n@@ -1809,7 +1866,7 @@ pub struct BareFnTy {\n }\n \n /// The various kinds of type recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum TyKind {\n     /// A variable-length slice (`[T]`).\n     Slice(P<Ty>),\n@@ -1868,7 +1925,7 @@ impl TyKind {\n }\n \n /// Syntax used to declare a trait object.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum TraitObjectSyntax {\n     Dyn,\n     None,\n@@ -1877,14 +1934,14 @@ pub enum TraitObjectSyntax {\n /// Inline assembly operand explicit register or register class.\n ///\n /// E.g., `\"eax\"` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(Symbol),\n     RegClass(Symbol),\n }\n \n bitflags::bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+    #[derive(Encodable, Decodable, HashStable_Generic)]\n     pub struct InlineAsmOptions: u8 {\n         const PURE = 1 << 0;\n         const NOMEM = 1 << 1;\n@@ -1896,7 +1953,7 @@ bitflags::bitflags! {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum InlineAsmTemplatePiece {\n     String(String),\n     Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n@@ -1940,7 +1997,7 @@ impl InlineAsmTemplatePiece {\n /// Inline assembly operand.\n ///\n /// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum InlineAsmOperand {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -1973,7 +2030,7 @@ pub enum InlineAsmOperand {\n /// Inline assembly.\n ///\n /// E.g., `asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n@@ -1984,7 +2041,7 @@ pub struct InlineAsm {\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum LlvmAsmDialect {\n     Att,\n     Intel,\n@@ -1993,7 +2050,7 @@ pub enum LlvmAsmDialect {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `\"={eax}\"(result)` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub expr: P<Expr>,\n@@ -2004,7 +2061,7 @@ pub struct LlvmInlineAsmOutput {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `llvm_asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2019,7 +2076,7 @@ pub struct LlvmInlineAsm {\n /// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Param {\n     pub attrs: AttrVec,\n     pub ty: P<Ty>,\n@@ -2032,7 +2089,7 @@ pub struct Param {\n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n ///\n /// E.g., `&mut self` as in `fn foo(&mut self)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum SelfKind {\n     /// `self`, `mut self`\n     Value(Mutability),\n@@ -2083,6 +2140,7 @@ impl Param {\n                 id: DUMMY_NODE_ID,\n                 kind: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n                 span,\n+                tokens: None,\n             }),\n             span,\n             ty,\n@@ -2110,7 +2168,7 @@ impl Param {\n ///\n /// Please note that it's different from `FnHeader` structure\n /// which contains metadata about function safety, asyncness, constness and ABI.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Param>,\n     pub output: FnRetTy,\n@@ -2132,20 +2190,20 @@ impl FnDecl {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum IsAuto {\n     Yes,\n     No,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Unsafe {\n     Yes(Span),\n     No,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug)]\n pub enum Async {\n     Yes { span: Span, closure_id: NodeId, return_impl_trait_id: NodeId },\n     No,\n@@ -2165,7 +2223,7 @@ impl Async {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Const {\n     Yes(Span),\n@@ -2174,13 +2232,13 @@ pub enum Const {\n \n /// Item defaultness.\n /// For details see the [RFC #2532](https://github.com/rust-lang/rfcs/pull/2532).\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum Defaultness {\n     Default(Span),\n     Final,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -2197,7 +2255,7 @@ impl fmt::Debug for ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FnRetTy {\n     /// Returns type is not specified.\n     ///\n@@ -2220,7 +2278,7 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2234,7 +2292,7 @@ pub struct Mod {\n /// Foreign module declaration.\n ///\n /// E.g., `extern { .. }` or `extern C { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ForeignMod {\n     pub abi: Option<StrLit>,\n     pub items: Vec<P<ForeignItem>>,\n@@ -2243,17 +2301,17 @@ pub struct ForeignMod {\n /// Global inline assembly.\n ///\n /// Also known as \"module-level assembly\" or \"file-scoped assembly\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n /// Enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Variant {\n     /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n@@ -2275,7 +2333,7 @@ pub struct Variant {\n }\n \n /// Part of `use` item to the right of its prefix.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     ///\n@@ -2290,7 +2348,7 @@ pub enum UseTreeKind {\n \n /// A tree of paths sharing common prefixes.\n /// Used in `use` items both at top-level and inside of braces in import groups.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct UseTree {\n     pub prefix: Path,\n     pub kind: UseTreeKind,\n@@ -2312,7 +2370,7 @@ impl UseTree {\n /// Distinguishes between `Attribute`s that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum AttrStyle {\n     Outer,\n     Inner,\n@@ -2325,19 +2383,19 @@ rustc_index::newtype_index! {\n     }\n }\n \n-impl rustc_serialize::Encodable for AttrId {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl rustc_serialize::Decodable for AttrId {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AttrId, D::Error> {\n+impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n+    fn decode(d: &mut D) -> Result<AttrId, D::Error> {\n         d.read_nil().map(|_| crate::attr::mk_attr_id())\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n@@ -2347,7 +2405,7 @@ pub struct AttrItem {\n pub type AttrVec = ThinVec<Attribute>;\n \n /// Metadata associated with an item.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n     pub id: AttrId,\n@@ -2357,15 +2415,15 @@ pub struct Attribute {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n     Normal(AttrItem),\n \n     /// A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).\n     /// Doc attributes (e.g. `#[doc=\"...\"]`) are represented with the `Normal`\n     /// variant (which is much less compact and thus more expensive).\n-    DocComment(Symbol),\n+    DocComment(CommentKind, Symbol),\n }\n \n /// `TraitRef`s appear in impls.\n@@ -2374,13 +2432,13 @@ pub enum AttrKind {\n /// that the `ref_id` is for. The `impl_id` maps to the \"self type\" of this impl.\n /// If this impl is an `ItemKind::Impl`, the `impl_id` is redundant (it could be the\n /// same as the impl's `NodeId`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: Vec<GenericParam>,\n@@ -2401,7 +2459,7 @@ impl PolyTraitRef {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CrateSugar {\n     /// Source is `pub(crate)`.\n     PubCrate,\n@@ -2412,7 +2470,7 @@ pub enum CrateSugar {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -2429,7 +2487,7 @@ impl VisibilityKind {\n /// Field of a struct.\n ///\n /// E.g., `bar: usize` as in `struct Foo { bar: usize }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructField {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2442,7 +2500,7 @@ pub struct StructField {\n }\n \n /// Fields and constructor ids of enum variants and structs.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n@@ -2477,7 +2535,7 @@ impl VariantData {\n }\n \n /// An item definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2514,7 +2572,7 @@ impl<K: Into<ItemKind>> Item<K> {\n }\n \n /// `extern` qualifier on a function item or function type.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {\n     None,\n     Implicit,\n@@ -2531,7 +2589,7 @@ impl Extern {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafe,\n     pub asyncness: Async,\n@@ -2561,7 +2619,7 @@ impl Default for FnHeader {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n     ///\n@@ -2700,7 +2758,7 @@ pub type AssocItem = Item<AssocItemKind>;\n /// In an implementation, all items must be provided.\n /// The `Option`s below denote the bodies, where `Some(_)`\n /// means \"provided\" and conversely `None` means \"required\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocItemKind {\n     /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n     /// If `def` is parsed, then the constant is provided, and otherwise required.\n@@ -2748,7 +2806,7 @@ impl TryFrom<ItemKind> for AssocItemKind {\n }\n \n /// An item in `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ForeignItemKind {\n     /// A foreign static item (`static FOO: u8`).\n     Static(P<Ty>, Mutability, Option<P<Expr>>),", "previous_filename": "src/librustc_ast/ast.rs"}, {"sha": "8ba55bf037b12bd15f1fdd1aeaeba8225442e215", "filename": "compiler/rustc_ast/src/ast/tests.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,11 @@\n+use super::*;\n+\n+// Are ASTs encodable?\n+#[test]\n+fn check_asts_encodable() {\n+    fn assert_encodable<\n+        T: for<'a> rustc_serialize::Encodable<rustc_serialize::json::Encoder<'a>>,\n+    >() {\n+    }\n+    assert_encodable::<Crate>();\n+}"}, {"sha": "edcbce3e2cfd34cc2bd77563427b97bbab27db50", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "added", "additions": 684, "deletions": 0, "changes": 684, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,684 @@\n+//! Functions dealing with attributes and meta items.\n+\n+use crate::ast;\n+use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n+use crate::ast::{Expr, GenericParam, Item, Lit, LitKind, Local, Stmt, StmtKind};\n+use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{Path, PathSegment};\n+use crate::mut_visit::visit_clobber;\n+use crate::ptr::P;\n+use crate::token::{self, CommentKind, Token};\n+use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n+\n+use rustc_index::bit_set::GrowableBitSet;\n+use rustc_span::source_map::{BytePos, Spanned};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::Span;\n+\n+use std::iter;\n+use std::ops::DerefMut;\n+\n+pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n+\n+impl MarkedAttrs {\n+    // We have no idea how many attributes there will be, so just\n+    // initiate the vectors with 0 bits. We'll grow them as necessary.\n+    pub fn new() -> Self {\n+        MarkedAttrs(GrowableBitSet::new_empty())\n+    }\n+\n+    pub fn mark(&mut self, attr: &Attribute) {\n+        self.0.insert(attr.id);\n+    }\n+\n+    pub fn is_marked(&self, attr: &Attribute) -> bool {\n+        self.0.contains(attr.id)\n+    }\n+}\n+\n+pub fn is_known_lint_tool(m_item: Ident) -> bool {\n+    [sym::clippy, sym::rustc].contains(&m_item.name)\n+}\n+\n+impl NestedMetaItem {\n+    /// Returns the `MetaItem` if `self` is a `NestedMetaItem::MetaItem`.\n+    pub fn meta_item(&self) -> Option<&MetaItem> {\n+        match *self {\n+            NestedMetaItem::MetaItem(ref item) => Some(item),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns the `Lit` if `self` is a `NestedMetaItem::Literal`s.\n+    pub fn literal(&self) -> Option<&Lit> {\n+        match *self {\n+            NestedMetaItem::Literal(ref lit) => Some(lit),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Returns `true` if this list item is a MetaItem with a name of `name`.\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n+    }\n+\n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        self.meta_item().and_then(|meta_item| meta_item.ident())\n+    }\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(Ident::invalid()).name\n+    }\n+\n+    /// Gets the string value if `self` is a `MetaItem` and the `MetaItem` is a\n+    /// `MetaItemKind::NameValue` variant containing a string, otherwise `None`.\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        self.meta_item().and_then(|meta_item| meta_item.value_str())\n+    }\n+\n+    /// Returns a name and single literal value tuple of the `MetaItem`.\n+    pub fn name_value_literal(&self) -> Option<(Symbol, &Lit)> {\n+        self.meta_item().and_then(|meta_item| {\n+            meta_item.meta_item_list().and_then(|meta_item_list| {\n+                if meta_item_list.len() == 1 {\n+                    if let Some(ident) = meta_item.ident() {\n+                        if let Some(lit) = meta_item_list[0].literal() {\n+                            return Some((ident.name, lit));\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+        })\n+    }\n+\n+    /// Gets a list of inner meta items from a list `MetaItem` type.\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        self.meta_item().and_then(|meta_item| meta_item.meta_item_list())\n+    }\n+\n+    /// Returns `true` if the variant is `MetaItem`.\n+    pub fn is_meta_item(&self) -> bool {\n+        self.meta_item().is_some()\n+    }\n+\n+    /// Returns `true` if the variant is `Literal`.\n+    pub fn is_literal(&self) -> bool {\n+        self.literal().is_some()\n+    }\n+\n+    /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n+    pub fn is_word(&self) -> bool {\n+        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+    }\n+\n+    /// Returns `true` if `self` is a `MetaItem` and the meta item is a `ValueString`.\n+    pub fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n+\n+    /// Returns `true` if `self` is a `MetaItem` and the meta item is a list.\n+    pub fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n+}\n+\n+impl Attribute {\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item.path == name,\n+            AttrKind::DocComment(..) => false,\n+        }\n+    }\n+\n+    /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => {\n+                if item.path.segments.len() == 1 {\n+                    Some(item.path.segments[0].ident)\n+                } else {\n+                    None\n+                }\n+            }\n+            AttrKind::DocComment(..) => None,\n+        }\n+    }\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(Ident::invalid()).name\n+    }\n+\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item.meta(self.span).and_then(|meta| meta.value_str()),\n+            AttrKind::DocComment(..) => None,\n+        }\n+    }\n+\n+    pub fn meta_item_list(&self) -> Option<Vec<NestedMetaItem>> {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => match item.meta(self.span) {\n+                Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n+                _ => None,\n+            },\n+            AttrKind::DocComment(..) => None,\n+        }\n+    }\n+\n+    pub fn is_word(&self) -> bool {\n+        if let AttrKind::Normal(item) = &self.kind {\n+            matches!(item.args, MacArgs::Empty)\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n+\n+    /// Indicates if the attribute is a `ValueString`.\n+    pub fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n+}\n+\n+impl MetaItem {\n+    /// For a single-segment meta item, returns its name; otherwise, returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 { Some(self.path.segments[0].ident) } else { None }\n+    }\n+    pub fn name_or_empty(&self) -> Symbol {\n+        self.ident().unwrap_or(Ident::invalid()).name\n+    }\n+\n+    // Example:\n+    //     #[attribute(name = \"value\")]\n+    //                 ^^^^^^^^^^^^^^\n+    pub fn name_value_literal(&self) -> Option<&Lit> {\n+        match &self.kind {\n+            MetaItemKind::NameValue(v) => Some(v),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn value_str(&self) -> Option<Symbol> {\n+        match self.kind {\n+            MetaItemKind::NameValue(ref v) => match v.kind {\n+                LitKind::Str(ref s, _) => Some(*s),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n+        match self.kind {\n+            MetaItemKind::List(ref l) => Some(&l[..]),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn is_word(&self) -> bool {\n+        match self.kind {\n+            MetaItemKind::Word => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn has_name(&self, name: Symbol) -> bool {\n+        self.path == name\n+    }\n+\n+    pub fn is_value_str(&self) -> bool {\n+        self.value_str().is_some()\n+    }\n+\n+    pub fn is_meta_item_list(&self) -> bool {\n+        self.meta_item_list().is_some()\n+    }\n+}\n+\n+impl AttrItem {\n+    pub fn span(&self) -> Span {\n+        self.args.span().map_or(self.path.span, |args_span| self.path.span.to(args_span))\n+    }\n+\n+    pub fn meta(&self, span: Span) -> Option<MetaItem> {\n+        Some(MetaItem {\n+            path: self.path.clone(),\n+            kind: MetaItemKind::from_mac_args(&self.args)?,\n+            span,\n+        })\n+    }\n+}\n+\n+impl Attribute {\n+    pub fn is_doc_comment(&self) -> bool {\n+        match self.kind {\n+            AttrKind::Normal(_) => false,\n+            AttrKind::DocComment(..) => true,\n+        }\n+    }\n+\n+    pub fn doc_str(&self) -> Option<Symbol> {\n+        match self.kind {\n+            AttrKind::DocComment(.., data) => Some(data),\n+            AttrKind::Normal(ref item) if item.path == sym::doc => {\n+                item.meta(self.span).and_then(|meta| meta.value_str())\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn get_normal_item(&self) -> &AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n+    }\n+\n+    pub fn unwrap_normal_item(self) -> AttrItem {\n+        match self.kind {\n+            AttrKind::Normal(item) => item,\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n+        }\n+    }\n+\n+    /// Extracts the MetaItem from inside this Attribute.\n+    pub fn meta(&self) -> Option<MetaItem> {\n+        match self.kind {\n+            AttrKind::Normal(ref item) => item.meta(self.span),\n+            AttrKind::DocComment(..) => None,\n+        }\n+    }\n+}\n+\n+/* Constructors */\n+\n+pub fn mk_name_value_item_str(ident: Ident, str: Symbol, str_span: Span) -> MetaItem {\n+    let lit_kind = LitKind::Str(str, ast::StrStyle::Cooked);\n+    mk_name_value_item(ident, lit_kind, str_span)\n+}\n+\n+pub fn mk_name_value_item(ident: Ident, lit_kind: LitKind, lit_span: Span) -> MetaItem {\n+    let lit = Lit::from_lit_kind(lit_kind, lit_span);\n+    let span = ident.span.to(lit_span);\n+    MetaItem { path: Path::from_ident(ident), span, kind: MetaItemKind::NameValue(lit) }\n+}\n+\n+pub fn mk_list_item(ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::List(items) }\n+}\n+\n+pub fn mk_word_item(ident: Ident) -> MetaItem {\n+    MetaItem { path: Path::from_ident(ident), span: ident.span, kind: MetaItemKind::Word }\n+}\n+\n+pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n+    NestedMetaItem::MetaItem(mk_word_item(ident))\n+}\n+\n+crate fn mk_attr_id() -> AttrId {\n+    use std::sync::atomic::AtomicU32;\n+    use std::sync::atomic::Ordering;\n+\n+    static NEXT_ATTR_ID: AtomicU32 = AtomicU32::new(0);\n+\n+    let id = NEXT_ATTR_ID.fetch_add(1, Ordering::SeqCst);\n+    assert!(id != u32::MAX);\n+    AttrId::from_u32(id)\n+}\n+\n+pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n+    mk_attr_from_item(style, AttrItem { path, args }, span)\n+}\n+\n+pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n+    Attribute { kind: AttrKind::Normal(item), id: mk_attr_id(), style, span }\n+}\n+\n+/// Returns an inner attribute with the given value and span.\n+pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n+    mk_attr(AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n+}\n+\n+/// Returns an outer attribute with the given value and span.\n+pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n+    mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n+}\n+\n+pub fn mk_doc_comment(\n+    comment_kind: CommentKind,\n+    style: AttrStyle,\n+    data: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n+}\n+\n+pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n+    items.iter().any(|item| item.has_name(name))\n+}\n+\n+impl MetaItem {\n+    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+        let mut idents = vec![];\n+        let mut last_pos = BytePos(0 as u32);\n+        for (i, segment) in self.path.segments.iter().enumerate() {\n+            let is_first = i == 0;\n+            if !is_first {\n+                let mod_sep_span =\n+                    Span::new(last_pos, segment.ident.span.lo(), segment.ident.span.ctxt());\n+                idents.push(TokenTree::token(token::ModSep, mod_sep_span).into());\n+            }\n+            idents.push(TokenTree::Token(Token::from_ast_ident(segment.ident)).into());\n+            last_pos = segment.ident.span.hi();\n+        }\n+        idents.extend(self.kind.token_trees_and_joints(self.span));\n+        idents\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n+    where\n+        I: Iterator<Item = TokenTree>,\n+    {\n+        // FIXME: Share code with `parse_path`.\n+        let path = match tokens.next().map(TokenTree::uninterpolate) {\n+            Some(TokenTree::Token(Token {\n+                kind: kind @ (token::Ident(..) | token::ModSep),\n+                span,\n+            })) => 'arm: {\n+                let mut segments = if let token::Ident(name, _) = kind {\n+                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. })) = tokens.peek()\n+                    {\n+                        tokens.next();\n+                        vec![PathSegment::from_ident(Ident::new(name, span))]\n+                    } else {\n+                        break 'arm Path::from_ident(Ident::new(name, span));\n+                    }\n+                } else {\n+                    vec![PathSegment::path_root(span)]\n+                };\n+                loop {\n+                    if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span })) =\n+                        tokens.next().map(TokenTree::uninterpolate)\n+                    {\n+                        segments.push(PathSegment::from_ident(Ident::new(name, span)));\n+                    } else {\n+                        return None;\n+                    }\n+                    if let Some(TokenTree::Token(Token { kind: token::ModSep, .. })) = tokens.peek()\n+                    {\n+                        tokens.next();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n+                Path { span, segments }\n+            }\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n+                token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n+                token::Nonterminal::NtPath(ref path) => path.clone(),\n+                _ => return None,\n+            },\n+            _ => return None,\n+        };\n+        let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi());\n+        let kind = MetaItemKind::from_tokens(tokens)?;\n+        let hi = match kind {\n+            MetaItemKind::NameValue(ref lit) => lit.span.hi(),\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(path.span.hi()),\n+            _ => path.span.hi(),\n+        };\n+        let span = path.span.with_hi(hi);\n+        Some(MetaItem { path, kind, span })\n+    }\n+}\n+\n+impl MetaItemKind {\n+    pub fn mac_args(&self, span: Span) -> MacArgs {\n+        match self {\n+            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::NameValue(lit) => MacArgs::Eq(span, lit.token_tree().into()),\n+            MetaItemKind::List(list) => {\n+                let mut tts = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tts.push(TokenTree::token(token::Comma, span).into());\n+                    }\n+                    tts.extend(item.token_trees_and_joints())\n+                }\n+                MacArgs::Delimited(\n+                    DelimSpan::from_single(span),\n+                    MacDelimiter::Parenthesis,\n+                    TokenStream::new(tts),\n+                )\n+            }\n+        }\n+    }\n+\n+    fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n+        match *self {\n+            MetaItemKind::Word => vec![],\n+            MetaItemKind::NameValue(ref lit) => {\n+                vec![TokenTree::token(token::Eq, span).into(), lit.token_tree().into()]\n+            }\n+            MetaItemKind::List(ref list) => {\n+                let mut tokens = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tokens.push(TokenTree::token(token::Comma, span).into());\n+                    }\n+                    tokens.extend(item.token_trees_and_joints())\n+                }\n+                vec![\n+                    TokenTree::Delimited(\n+                        DelimSpan::from_single(span),\n+                        token::Paren,\n+                        TokenStream::new(tokens),\n+                    )\n+                    .into(),\n+                ]\n+            }\n+        }\n+    }\n+\n+    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+        let mut tokens = tokens.into_trees().peekable();\n+        let mut result = Vec::new();\n+        while let Some(..) = tokens.peek() {\n+            let item = NestedMetaItem::from_tokens(&mut tokens)?;\n+            result.push(item);\n+            match tokens.next() {\n+                None | Some(TokenTree::Token(Token { kind: token::Comma, .. })) => {}\n+                _ => return None,\n+            }\n+        }\n+        Some(MetaItemKind::List(result))\n+    }\n+\n+    fn name_value_from_tokens(\n+        tokens: &mut impl Iterator<Item = TokenTree>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.next() {\n+            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+                MetaItemKind::name_value_from_tokens(&mut inner_tokens.trees())\n+            }\n+            Some(TokenTree::Token(token)) => {\n+                Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+        match args {\n+            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) => {\n+                MetaItemKind::list_from_tokens(tokens.clone())\n+            }\n+            MacArgs::Delimited(..) => None,\n+            MacArgs::Eq(_, tokens) => {\n+                assert!(tokens.len() == 1);\n+                MetaItemKind::name_value_from_tokens(&mut tokens.trees())\n+            }\n+            MacArgs::Empty => Some(MetaItemKind::Word),\n+        }\n+    }\n+\n+    fn from_tokens(\n+        tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.peek() {\n+            Some(TokenTree::Delimited(_, token::Paren, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n+                tokens.next();\n+                MetaItemKind::list_from_tokens(inner_tokens)\n+            }\n+            Some(TokenTree::Delimited(..)) => None,\n+            Some(TokenTree::Token(Token { kind: token::Eq, .. })) => {\n+                tokens.next();\n+                MetaItemKind::name_value_from_tokens(tokens)\n+            }\n+            _ => Some(MetaItemKind::Word),\n+        }\n+    }\n+}\n+\n+impl NestedMetaItem {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            NestedMetaItem::MetaItem(ref item) => item.span,\n+            NestedMetaItem::Literal(ref lit) => lit.span,\n+        }\n+    }\n+\n+    fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n+        match *self {\n+            NestedMetaItem::MetaItem(ref item) => item.token_trees_and_joints(),\n+            NestedMetaItem::Literal(ref lit) => vec![lit.token_tree().into()],\n+        }\n+    }\n+\n+    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<NestedMetaItem>\n+    where\n+        I: Iterator<Item = TokenTree>,\n+    {\n+        match tokens.peek() {\n+            Some(TokenTree::Token(token)) => {\n+                if let Ok(lit) = Lit::from_token(token) {\n+                    tokens.next();\n+                    return Some(NestedMetaItem::Literal(lit));\n+                }\n+            }\n+            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n+                tokens.next();\n+                return NestedMetaItem::from_tokens(&mut inner_tokens.into_trees().peekable());\n+            }\n+            _ => {}\n+        }\n+        MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n+    }\n+}\n+\n+pub trait HasAttrs: Sized {\n+    fn attrs(&self) -> &[Attribute];\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+}\n+\n+impl<T: HasAttrs> HasAttrs for Spanned<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.node.attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.node.visit_attrs(f);\n+    }\n+}\n+\n+impl HasAttrs for Vec<Attribute> {\n+    fn attrs(&self) -> &[Attribute] {\n+        self\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        f(self)\n+    }\n+}\n+\n+impl HasAttrs for AttrVec {\n+    fn attrs(&self) -> &[Attribute] {\n+        self\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        visit_clobber(self, |this| {\n+            let mut vec = this.into();\n+            f(&mut vec);\n+            vec.into()\n+        });\n+    }\n+}\n+\n+impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        (**self).attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        (**self).visit_attrs(f);\n+    }\n+}\n+\n+impl HasAttrs for StmtKind {\n+    fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtKind::Local(ref local) => local.attrs(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n+            StmtKind::Empty | StmtKind::Item(..) => &[],\n+            StmtKind::MacCall(ref mac) => {\n+                let (_, _, ref attrs) = **mac;\n+                attrs.attrs()\n+            }\n+        }\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            StmtKind::Local(local) => local.visit_attrs(f),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n+            StmtKind::Empty | StmtKind::Item(..) => {}\n+            StmtKind::MacCall(mac) => {\n+                let (_mac, _style, attrs) = mac.deref_mut();\n+                attrs.visit_attrs(f);\n+            }\n+        }\n+    }\n+}\n+\n+impl HasAttrs for Stmt {\n+    fn attrs(&self) -> &[ast::Attribute] {\n+        self.kind.attrs()\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.kind.visit_attrs(f);\n+    }\n+}\n+\n+macro_rules! derive_has_attrs {\n+    ($($ty:path),*) => { $(\n+        impl HasAttrs for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &self.attrs\n+            }\n+\n+            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                self.attrs.visit_attrs(f);\n+            }\n+        }\n+    )* }\n+}\n+\n+derive_has_attrs! {\n+    Item, Expr, Local, ast::AssocItem, ast::ForeignItem, ast::StructField, ast::Arm,\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Param, GenericParam\n+}"}, {"sha": "bd7d85167140dfe4e28a712edf85a4d17dfbf8dc", "filename": "compiler/rustc_ast/src/crate_disambiguator.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fcrate_disambiguator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fcrate_disambiguator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fcrate_disambiguator.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -9,7 +9,7 @@ use std::fmt;\n /// Hash value constructed out of all the `-C metadata` arguments passed to the\n /// compiler. Together with the crate-name forms a unique global identifier for\n /// the crate.\n-#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, Encodable, Decodable)]\n pub struct CrateDisambiguator(Fingerprint);\n \n impl CrateDisambiguator {", "previous_filename": "src/librustc_ast/crate_disambiguator.rs"}, {"sha": "290f6006de0790f25cac9f7618e061f54a92e1a7", "filename": "compiler/rustc_ast/src/entry.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fentry.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,7 @@\n+pub enum EntryPointType {\n+    None,\n+    MainNamed,\n+    MainAttr,\n+    Start,\n+    OtherMain, // Not an entry point, but some other function named main\n+}"}, {"sha": "cd27f958e4641868450fbd841313b0b006bc3176", "filename": "compiler/rustc_ast/src/expand/allocator.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,53 @@\n+use rustc_span::symbol::{sym, Symbol};\n+\n+#[derive(Clone, Copy)]\n+pub enum AllocatorKind {\n+    Global,\n+    Default,\n+}\n+\n+impl AllocatorKind {\n+    pub fn fn_name(&self, base: Symbol) -> String {\n+        match *self {\n+            AllocatorKind::Global => format!(\"__rg_{}\", base),\n+            AllocatorKind::Default => format!(\"__rdl_{}\", base),\n+        }\n+    }\n+}\n+\n+pub enum AllocatorTy {\n+    Layout,\n+    Ptr,\n+    ResultPtr,\n+    Unit,\n+    Usize,\n+}\n+\n+pub struct AllocatorMethod {\n+    pub name: Symbol,\n+    pub inputs: &'static [AllocatorTy],\n+    pub output: AllocatorTy,\n+}\n+\n+pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n+    AllocatorMethod {\n+        name: sym::alloc,\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: sym::dealloc,\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n+        output: AllocatorTy::Unit,\n+    },\n+    AllocatorMethod {\n+        name: sym::realloc,\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: sym::alloc_zeroed,\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+];"}, {"sha": "eebfc38bdf4ec56b510cd71f35c1e33a99cfabd2", "filename": "compiler/rustc_ast/src/expand/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,3 @@\n+//! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n+\n+pub mod allocator;"}, {"sha": "b556c1a446b7b3c85416b333ee82aeb21750ed52", "filename": "compiler/rustc_ast/src/lib.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,69 @@\n+//! The Rust parser and macro expander.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n+#![feature(bool_to_option)]\n+#![feature(box_syntax)]\n+#![feature(const_fn)] // For the `transmute` in `P::new`\n+#![feature(const_panic)]\n+#![feature(const_fn_transmute)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(label_break_value)]\n+#![feature(nll)]\n+#![feature(or_patterns)]\n+#![feature(try_trait)]\n+#![feature(unicode_internals)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate rustc_macros;\n+\n+#[macro_export]\n+macro_rules! unwrap_or {\n+    ($opt:expr, $default:expr) => {\n+        match $opt {\n+            Some(x) => x,\n+            None => $default,\n+        }\n+    };\n+}\n+\n+pub mod util {\n+    pub mod classify;\n+    pub mod comments;\n+    pub mod lev_distance;\n+    pub mod literal;\n+    pub mod parser;\n+}\n+\n+pub mod ast;\n+pub mod attr;\n+pub mod crate_disambiguator;\n+pub mod entry;\n+pub mod expand;\n+pub mod mut_visit;\n+pub mod node_id;\n+pub mod ptr;\n+pub mod token;\n+pub mod tokenstream;\n+pub mod visit;\n+\n+pub use self::ast::*;\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n+/// Requirements for a `StableHashingContext` to be used in this crate.\n+/// This is a hack to allow using the `HashStable_Generic` derive macro\n+/// instead of implementing everything in librustc_middle.\n+pub trait HashStableContext: rustc_span::HashStableContext {\n+    fn hash_attr(&mut self, _: &ast::Attribute, hasher: &mut StableHasher);\n+}\n+\n+impl<AstCtx: crate::HashStableContext> HashStable<AstCtx> for ast::Attribute {\n+    fn hash_stable(&self, hcx: &mut AstCtx, hasher: &mut StableHasher) {\n+        hcx.hash_attr(self, hasher)\n+    }\n+}"}, {"sha": "965571aaa548ee7e0f8e168b581d44e58498733b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -363,9 +363,10 @@ pub fn visit_bounds<T: MutVisitor>(bounds: &mut GenericBounds, vis: &mut T) {\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl }: &mut FnSig, vis: &mut T) {\n+pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl, span }: &mut FnSig, vis: &mut T) {\n     vis.visit_fn_header(header);\n     vis.visit_fn_decl(decl);\n+    vis.visit_span(span);\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n@@ -582,7 +583,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n         }\n-        AttrKind::DocComment(_) => {}\n+        AttrKind::DocComment(..) => {}\n     }\n     vis.visit_span(span);\n }\n@@ -1053,7 +1054,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n }\n \n pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n-    let Pat { id, kind, span } = pat.deref_mut();\n+    let Pat { id, kind, span, tokens: _ } = pat.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         PatKind::Wild | PatKind::Rest => {}", "previous_filename": "src/librustc_ast/mut_visit.rs"}, {"sha": "1035e945538f5b10136b7b4547f8728ed9c6a646", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,34 @@\n+use rustc_span::ExpnId;\n+use std::fmt;\n+\n+rustc_index::newtype_index! {\n+    pub struct NodeId {\n+        DEBUG_FORMAT = \"NodeId({})\"\n+    }\n+}\n+\n+rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeId);\n+\n+/// `NodeId` used to represent the root of the crate.\n+pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);\n+\n+/// When parsing and doing expansions, we initially give all AST nodes this AST\n+/// node value. Then later, in the renumber pass, we renumber them to have\n+/// small, positive ids.\n+pub const DUMMY_NODE_ID: NodeId = NodeId::MAX;\n+\n+impl NodeId {\n+    pub fn placeholder_from_expn_id(expn_id: ExpnId) -> Self {\n+        NodeId::from_u32(expn_id.as_u32())\n+    }\n+\n+    pub fn placeholder_to_expn_id(self) -> ExpnId {\n+        ExpnId::from_u32(self.as_u32())\n+    }\n+}\n+\n+impl fmt::Display for NodeId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.as_u32(), f)\n+    }\n+}"}, {"sha": "e4a3cccb7ead1c9c30efed20cb687f30759fac55", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -114,14 +114,14 @@ impl<T> fmt::Pointer for P<T> {\n     }\n }\n \n-impl<T: 'static + Decodable> Decodable for P<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n+impl<D: Decoder, T: 'static + Decodable<D>> Decodable<D> for P<T> {\n+    fn decode(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n     }\n }\n \n-impl<T: Encodable> Encodable for P<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n@@ -197,14 +197,14 @@ impl<'a, T> IntoIterator for &'a P<[T]> {\n     }\n }\n \n-impl<T: Encodable> Encodable for P<[T]> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<[T]> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&**self, s)\n     }\n }\n \n-impl<T: Decodable> Decodable for P<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for P<[T]> {\n+    fn decode(d: &mut D) -> Result<P<[T]>, D::Error> {\n         Ok(P::from_vec(Decodable::decode(d)?))\n     }\n }", "previous_filename": "src/librustc_ast/ptr.rs"}, {"sha": "4a8bf6b4f19b604bc815c12cc869db8cce47d3a9", "filename": "compiler/rustc_ast/src/token.rs", "status": "renamed", "additions": 106, "deletions": 67, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -11,13 +11,21 @@ use crate::tokenstream::TokenTree;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n+use rustc_span::hygiene::ExpnKind;\n+use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, Span, DUMMY_SP};\n+use rustc_span::{self, FileName, RealFileName, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n+pub enum CommentKind {\n+    Line,\n+    Block,\n+}\n+\n+#[derive(Clone, PartialEq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum BinOpToken {\n     Plus,\n@@ -33,7 +41,7 @@ pub enum BinOpToken {\n }\n \n /// A delimiter token.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum DelimToken {\n     /// A round parenthesis (i.e., `(` or `)`).\n@@ -56,7 +64,7 @@ impl DelimToken {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n     Byte,\n@@ -71,7 +79,7 @@ pub enum LitKind {\n }\n \n /// A literal token.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     pub kind: LitKind,\n     pub symbol: Symbol,\n@@ -182,7 +190,7 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n     Eq,\n@@ -238,9 +246,10 @@ pub enum TokenKind {\n \n     Interpolated(Lrc<Nonterminal>),\n \n-    // Can be expanded into several tokens.\n-    /// A doc comment.\n-    DocComment(Symbol),\n+    /// A doc comment token.\n+    /// `Symbol` is the doc comment's data excluding its \"quotes\" (`///`, `/**`, etc)\n+    /// similarly to symbols in string literal tokens.\n+    DocComment(CommentKind, ast::AttrStyle, Symbol),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -260,7 +269,7 @@ pub enum TokenKind {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n     pub span: Span,\n@@ -673,62 +682,6 @@ impl Token {\n \n         Some(Token::new(kind, self.span.to(joint.span)))\n     }\n-\n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n-        if mem::discriminant(&self.kind) != mem::discriminant(&other.kind) {\n-            return false;\n-        }\n-        match (&self.kind, &other.kind) {\n-            (&Eq, &Eq)\n-            | (&Lt, &Lt)\n-            | (&Le, &Le)\n-            | (&EqEq, &EqEq)\n-            | (&Ne, &Ne)\n-            | (&Ge, &Ge)\n-            | (&Gt, &Gt)\n-            | (&AndAnd, &AndAnd)\n-            | (&OrOr, &OrOr)\n-            | (&Not, &Not)\n-            | (&Tilde, &Tilde)\n-            | (&At, &At)\n-            | (&Dot, &Dot)\n-            | (&DotDot, &DotDot)\n-            | (&DotDotDot, &DotDotDot)\n-            | (&DotDotEq, &DotDotEq)\n-            | (&Comma, &Comma)\n-            | (&Semi, &Semi)\n-            | (&Colon, &Colon)\n-            | (&ModSep, &ModSep)\n-            | (&RArrow, &RArrow)\n-            | (&LArrow, &LArrow)\n-            | (&FatArrow, &FatArrow)\n-            | (&Pound, &Pound)\n-            | (&Dollar, &Dollar)\n-            | (&Question, &Question)\n-            | (&Whitespace, &Whitespace)\n-            | (&Comment, &Comment)\n-            | (&Eof, &Eof) => true,\n-\n-            (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n-\n-            (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n-\n-            (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n-\n-            (&Literal(a), &Literal(b)) => a == b,\n-\n-            (&Lifetime(a), &Lifetime(b)) => a == b,\n-            (&Ident(a, b), &Ident(c, d)) => {\n-                b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n-            }\n-\n-            (&Interpolated(..), &Interpolated(..)) => false,\n-\n-            _ => panic!(\"forgot to add a token?\"),\n-        }\n-    }\n }\n \n impl PartialEq<TokenKind> for Token {\n@@ -737,7 +690,7 @@ impl PartialEq<TokenKind> for Token {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Encodable, Decodable)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(P<ast::Item>),\n@@ -760,6 +713,67 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n+pub enum NonterminalKind {\n+    Item,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Expr,\n+    Ty,\n+    Ident,\n+    Lifetime,\n+    Literal,\n+    Meta,\n+    Path,\n+    Vis,\n+    TT,\n+}\n+\n+impl NonterminalKind {\n+    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+        Some(match symbol {\n+            sym::item => NonterminalKind::Item,\n+            sym::block => NonterminalKind::Block,\n+            sym::stmt => NonterminalKind::Stmt,\n+            sym::pat => NonterminalKind::Pat,\n+            sym::expr => NonterminalKind::Expr,\n+            sym::ty => NonterminalKind::Ty,\n+            sym::ident => NonterminalKind::Ident,\n+            sym::lifetime => NonterminalKind::Lifetime,\n+            sym::literal => NonterminalKind::Literal,\n+            sym::meta => NonterminalKind::Meta,\n+            sym::path => NonterminalKind::Path,\n+            sym::vis => NonterminalKind::Vis,\n+            sym::tt => NonterminalKind::TT,\n+            _ => return None,\n+        })\n+    }\n+    fn symbol(self) -> Symbol {\n+        match self {\n+            NonterminalKind::Item => sym::item,\n+            NonterminalKind::Block => sym::block,\n+            NonterminalKind::Stmt => sym::stmt,\n+            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Expr => sym::expr,\n+            NonterminalKind::Ty => sym::ty,\n+            NonterminalKind::Ident => sym::ident,\n+            NonterminalKind::Lifetime => sym::lifetime,\n+            NonterminalKind::Literal => sym::literal,\n+            NonterminalKind::Meta => sym::meta,\n+            NonterminalKind::Path => sym::path,\n+            NonterminalKind::Vis => sym::vis,\n+            NonterminalKind::TT => sym::tt,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NonterminalKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.symbol())\n+    }\n+}\n+\n impl Nonterminal {\n     fn span(&self) -> Span {\n         match self {\n@@ -796,6 +810,31 @@ impl Nonterminal {\n         }\n         false\n     }\n+\n+    // See issue #74616 for details\n+    pub fn ident_name_compatibility_hack(\n+        &self,\n+        orig_span: Span,\n+        source_map: &SourceMap,\n+    ) -> Option<(Ident, bool)> {\n+        if let NtIdent(ident, is_raw) = self {\n+            if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n+                let filename = source_map.span_to_filename(orig_span);\n+                if let FileName::Real(RealFileName::Named(path)) = filename {\n+                    if (path.ends_with(\"time-macros-impl/src/lib.rs\")\n+                        && macro_name == sym::impl_macros)\n+                        || (path.ends_with(\"js-sys/src/lib.rs\") && macro_name == sym::arrays)\n+                    {\n+                        let snippet = source_map.span_to_snippet(orig_span);\n+                        if snippet.as_deref() == Ok(\"$name\") {\n+                            return Some((*ident, *is_raw));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n }\n \n impl PartialEq for Nonterminal {", "previous_filename": "src/librustc_ast/token.rs"}, {"sha": "151acddae840e567c171362311ce6813f6603c5b", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,433 @@\n+//! # Token Streams\n+//!\n+//! `TokenStream`s represent syntactic objects before they are converted into ASTs.\n+//! A `TokenStream` is, roughly speaking, a sequence (eg stream) of `TokenTree`s,\n+//! which are themselves a single `Token` or a `Delimited` subsequence of tokens.\n+//!\n+//! ## Ownership\n+//!\n+//! `TokenStream`s are persistent data structures constructed as ropes with reference\n+//! counted-children. In general, this means that calling an operation on a `TokenStream`\n+//! (such as `slice`) produces an entirely new `TokenStream` from the borrowed reference to\n+//! the original. This essentially coerces `TokenStream`s into 'views' of their subparts,\n+//! and a borrowed `TokenStream` is sufficient to build an owned `TokenStream` without taking\n+//! ownership of the original.\n+\n+use crate::token::{self, DelimToken, Token, TokenKind};\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_macros::HashStable_Generic;\n+use rustc_span::{Span, DUMMY_SP};\n+use smallvec::{smallvec, SmallVec};\n+\n+use std::{iter, mem};\n+\n+/// When the main rust parser encounters a syntax-extension invocation, it\n+/// parses the arguments to the invocation as a token-tree. This is a very\n+/// loose structure, such that all sorts of different AST-fragments can\n+/// be passed to syntax extensions using a uniform type.\n+///\n+/// If the syntax extension is an MBE macro, it will attempt to match its\n+/// LHS token tree against the provided token tree, and if it finds a\n+/// match, will transcribe the RHS token tree, splicing in any captured\n+/// `macro_parser::matched_nonterminals` into the `SubstNt`s it finds.\n+///\n+/// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n+/// Nothing special happens to misnamed or misplaced `SubstNt`s.\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n+pub enum TokenTree {\n+    /// A single token\n+    Token(Token),\n+    /// A delimited sequence of token trees\n+    Delimited(DelimSpan, DelimToken, TokenStream),\n+}\n+\n+// Ensure all fields of `TokenTree` is `Send` and `Sync`.\n+#[cfg(parallel_compiler)]\n+fn _dummy()\n+where\n+    Token: Send + Sync,\n+    DelimSpan: Send + Sync,\n+    DelimToken: Send + Sync,\n+    TokenStream: Send + Sync,\n+{\n+}\n+\n+impl TokenTree {\n+    /// Checks if this TokenTree is equal to the other, regardless of span information.\n+    pub fn eq_unspanned(&self, other: &TokenTree) -> bool {\n+        match (self, other) {\n+            (TokenTree::Token(token), TokenTree::Token(token2)) => token.kind == token2.kind,\n+            (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n+                delim == delim2 && tts.eq_unspanned(&tts2)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    /// Retrieves the TokenTree's span.\n+    pub fn span(&self) -> Span {\n+        match self {\n+            TokenTree::Token(token) => token.span,\n+            TokenTree::Delimited(sp, ..) => sp.entire(),\n+        }\n+    }\n+\n+    /// Modify the `TokenTree`'s span in-place.\n+    pub fn set_span(&mut self, span: Span) {\n+        match self {\n+            TokenTree::Token(token) => token.span = span,\n+            TokenTree::Delimited(dspan, ..) => *dspan = DelimSpan::from_single(span),\n+        }\n+    }\n+\n+    pub fn joint(self) -> TokenStream {\n+        TokenStream::new(vec![(self, Joint)])\n+    }\n+\n+    pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n+        TokenTree::Token(Token::new(kind, span))\n+    }\n+\n+    /// Returns the opening delimiter as a token tree.\n+    pub fn open_tt(span: DelimSpan, delim: DelimToken) -> TokenTree {\n+        TokenTree::token(token::OpenDelim(delim), span.open)\n+    }\n+\n+    /// Returns the closing delimiter as a token tree.\n+    pub fn close_tt(span: DelimSpan, delim: DelimToken) -> TokenTree {\n+        TokenTree::token(token::CloseDelim(delim), span.close)\n+    }\n+\n+    pub fn uninterpolate(self) -> TokenTree {\n+        match self {\n+            TokenTree::Token(token) => TokenTree::Token(token.uninterpolate().into_owned()),\n+            tt => tt,\n+        }\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for TokenStream\n+where\n+    CTX: crate::HashStableContext,\n+{\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        for sub_tt in self.trees() {\n+            sub_tt.hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+/// A `TokenStream` is an abstract sequence of tokens, organized into `TokenTree`s.\n+///\n+/// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n+/// instead of a representation of the abstract syntax tree.\n+/// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n+#[derive(Clone, Debug, Default, Encodable, Decodable)]\n+pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n+\n+pub type TreeAndJoint = (TokenTree, IsJoint);\n+\n+// `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+rustc_data_structures::static_assert_size!(TokenStream, 8);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n+pub enum IsJoint {\n+    Joint,\n+    NonJoint,\n+}\n+\n+use IsJoint::*;\n+\n+impl TokenStream {\n+    /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n+    /// separating the two arguments with a comma for diagnostic suggestions.\n+    pub fn add_comma(&self) -> Option<(TokenStream, Span)> {\n+        // Used to suggest if a user writes `foo!(a b);`\n+        let mut suggestion = None;\n+        let mut iter = self.0.iter().enumerate().peekable();\n+        while let Some((pos, ts)) = iter.next() {\n+            if let Some((_, next)) = iter.peek() {\n+                let sp = match (&ts, &next) {\n+                    (_, (TokenTree::Token(Token { kind: token::Comma, .. }), _)) => continue,\n+                    (\n+                        (TokenTree::Token(token_left), NonJoint),\n+                        (TokenTree::Token(token_right), _),\n+                    ) if ((token_left.is_ident() && !token_left.is_reserved_ident())\n+                        || token_left.is_lit())\n+                        && ((token_right.is_ident() && !token_right.is_reserved_ident())\n+                            || token_right.is_lit()) =>\n+                    {\n+                        token_left.span\n+                    }\n+                    ((TokenTree::Delimited(sp, ..), NonJoint), _) => sp.entire(),\n+                    _ => continue,\n+                };\n+                let sp = sp.shrink_to_hi();\n+                let comma = (TokenTree::token(token::Comma, sp), NonJoint);\n+                suggestion = Some((pos, comma, sp));\n+            }\n+        }\n+        if let Some((pos, comma, sp)) = suggestion {\n+            let mut new_stream = vec![];\n+            let parts = self.0.split_at(pos + 1);\n+            new_stream.extend_from_slice(parts.0);\n+            new_stream.push(comma);\n+            new_stream.extend_from_slice(parts.1);\n+            return Some((TokenStream::new(new_stream), sp));\n+        }\n+        None\n+    }\n+}\n+\n+impl From<TokenTree> for TokenStream {\n+    fn from(tree: TokenTree) -> TokenStream {\n+        TokenStream::new(vec![(tree, NonJoint)])\n+    }\n+}\n+\n+impl From<TokenTree> for TreeAndJoint {\n+    fn from(tree: TokenTree) -> TreeAndJoint {\n+        (tree, NonJoint)\n+    }\n+}\n+\n+impl iter::FromIterator<TokenTree> for TokenStream {\n+    fn from_iter<I: IntoIterator<Item = TokenTree>>(iter: I) -> Self {\n+        TokenStream::new(iter.into_iter().map(Into::into).collect::<Vec<TreeAndJoint>>())\n+    }\n+}\n+\n+impl Eq for TokenStream {}\n+\n+impl PartialEq<TokenStream> for TokenStream {\n+    fn eq(&self, other: &TokenStream) -> bool {\n+        self.trees().eq(other.trees())\n+    }\n+}\n+\n+impl TokenStream {\n+    pub fn new(streams: Vec<TreeAndJoint>) -> TokenStream {\n+        TokenStream(Lrc::new(streams))\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    pub fn span(&self) -> Option<Span> {\n+        match &**self.0 {\n+            [] => None,\n+            [(tt, _)] => Some(tt.span()),\n+            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n+        }\n+    }\n+\n+    pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n+        match streams.len() {\n+            0 => TokenStream::default(),\n+            1 => streams.pop().unwrap(),\n+            _ => {\n+                // We are going to extend the first stream in `streams` with\n+                // the elements from the subsequent streams. This requires\n+                // using `make_mut()` on the first stream, and in practice this\n+                // doesn't cause cloning 99.9% of the time.\n+                //\n+                // One very common use case is when `streams` has two elements,\n+                // where the first stream has any number of elements within\n+                // (often 1, but sometimes many more) and the second stream has\n+                // a single element within.\n+\n+                // Determine how much the first stream will be extended.\n+                // Needed to avoid quadratic blow up from on-the-fly\n+                // reallocations (#57735).\n+                let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n+\n+                // Get the first stream. If it's `None`, create an empty\n+                // stream.\n+                let mut iter = streams.drain(..);\n+                let mut first_stream_lrc = iter.next().unwrap().0;\n+\n+                // Append the elements to the first stream, after reserving\n+                // space for them.\n+                let first_vec_mut = Lrc::make_mut(&mut first_stream_lrc);\n+                first_vec_mut.reserve(num_appends);\n+                for stream in iter {\n+                    first_vec_mut.extend(stream.0.iter().cloned());\n+                }\n+\n+                // Create the final `TokenStream`.\n+                TokenStream(first_stream_lrc)\n+            }\n+        }\n+    }\n+\n+    pub fn trees(&self) -> Cursor {\n+        self.clone().into_trees()\n+    }\n+\n+    pub fn into_trees(self) -> Cursor {\n+        Cursor::new(self)\n+    }\n+\n+    /// Compares two `TokenStream`s, checking equality without regarding span information.\n+    pub fn eq_unspanned(&self, other: &TokenStream) -> bool {\n+        let mut t1 = self.trees();\n+        let mut t2 = other.trees();\n+        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+            if !t1.eq_unspanned(&t2) {\n+                return false;\n+            }\n+        }\n+        t1.next().is_none() && t2.next().is_none()\n+    }\n+\n+    pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n+        TokenStream(Lrc::new(\n+            self.0\n+                .iter()\n+                .enumerate()\n+                .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n+                .collect(),\n+        ))\n+    }\n+\n+    pub fn map<F: FnMut(TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n+        TokenStream(Lrc::new(\n+            self.0.iter().map(|(tree, is_joint)| (f(tree.clone()), *is_joint)).collect(),\n+        ))\n+    }\n+}\n+\n+// 99.5%+ of the time we have 1 or 2 elements in this vector.\n+#[derive(Clone)]\n+pub struct TokenStreamBuilder(SmallVec<[TokenStream; 2]>);\n+\n+impl TokenStreamBuilder {\n+    pub fn new() -> TokenStreamBuilder {\n+        TokenStreamBuilder(SmallVec::new())\n+    }\n+\n+    pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n+        let mut stream = stream.into();\n+\n+        // If `self` is not empty and the last tree within the last stream is a\n+        // token tree marked with `Joint`...\n+        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut() {\n+            if let Some((TokenTree::Token(last_token), Joint)) = last_stream_lrc.last() {\n+                // ...and `stream` is not empty and the first tree within it is\n+                // a token tree...\n+                let TokenStream(ref mut stream_lrc) = stream;\n+                if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n+                    // ...and the two tokens can be glued together...\n+                    if let Some(glued_tok) = last_token.glue(&token) {\n+                        // ...then do so, by overwriting the last token\n+                        // tree in `self` and removing the first token tree\n+                        // from `stream`. This requires using `make_mut()`\n+                        // on the last stream in `self` and on `stream`,\n+                        // and in practice this doesn't cause cloning 99.9%\n+                        // of the time.\n+\n+                        // Overwrite the last token tree with the merged\n+                        // token.\n+                        let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n+                        *last_vec_mut.last_mut().unwrap() =\n+                            (TokenTree::Token(glued_tok), *is_joint);\n+\n+                        // Remove the first token tree from `stream`. (This\n+                        // is almost always the only tree in `stream`.)\n+                        let stream_vec_mut = Lrc::make_mut(stream_lrc);\n+                        stream_vec_mut.remove(0);\n+\n+                        // Don't push `stream` if it's empty -- that could\n+                        // block subsequent token gluing, by getting\n+                        // between two token trees that should be glued\n+                        // together.\n+                        if !stream.is_empty() {\n+                            self.0.push(stream);\n+                        }\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+        self.0.push(stream);\n+    }\n+\n+    pub fn build(self) -> TokenStream {\n+        TokenStream::from_streams(self.0)\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct Cursor {\n+    pub stream: TokenStream,\n+    index: usize,\n+}\n+\n+impl Iterator for Cursor {\n+    type Item = TokenTree;\n+\n+    fn next(&mut self) -> Option<TokenTree> {\n+        self.next_with_joint().map(|(tree, _)| tree)\n+    }\n+}\n+\n+impl Cursor {\n+    fn new(stream: TokenStream) -> Self {\n+        Cursor { stream, index: 0 }\n+    }\n+\n+    pub fn next_with_joint(&mut self) -> Option<TreeAndJoint> {\n+        if self.index < self.stream.len() {\n+            self.index += 1;\n+            Some(self.stream.0[self.index - 1].clone())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn append(&mut self, new_stream: TokenStream) {\n+        if new_stream.is_empty() {\n+            return;\n+        }\n+        let index = self.index;\n+        let stream = mem::take(&mut self.stream);\n+        *self = TokenStream::from_streams(smallvec![stream, new_stream]).into_trees();\n+        self.index = index;\n+    }\n+\n+    pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n+        self.stream.0[self.index..].get(n).map(|(tree, _)| tree.clone())\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n+pub struct DelimSpan {\n+    pub open: Span,\n+    pub close: Span,\n+}\n+\n+impl DelimSpan {\n+    pub fn from_single(sp: Span) -> Self {\n+        DelimSpan { open: sp, close: sp }\n+    }\n+\n+    pub fn from_pair(open: Span, close: Span) -> Self {\n+        DelimSpan { open, close }\n+    }\n+\n+    pub fn dummy() -> Self {\n+        Self::from_single(DUMMY_SP)\n+    }\n+\n+    pub fn entire(self) -> Span {\n+        self.open.with_hi(self.close.hi())\n+    }\n+}"}, {"sha": "60422a2e573925033b2418f6b3b6cb8d7e59981f", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast/util/classify.rs"}, {"sha": "e97c8cc4562f63d17182c28c56dc1375c577d912", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,222 @@\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{BytePos, CharPos, FileName, Pos, Symbol};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum CommentStyle {\n+    /// No code on either side of each line of the comment\n+    Isolated,\n+    /// Code exists to the left of the comment\n+    Trailing,\n+    /// Code before /* foo */ and after the comment\n+    Mixed,\n+    /// Just a manual blank line \"\\n\\n\", for layout\n+    BlankLine,\n+}\n+\n+#[derive(Clone)]\n+pub struct Comment {\n+    pub style: CommentStyle,\n+    pub lines: Vec<String>,\n+    pub pos: BytePos,\n+}\n+\n+/// Makes a doc string more presentable to users.\n+/// Used by rustdoc and perhaps other tools, but not by rustc.\n+pub fn beautify_doc_string(data: Symbol) -> String {\n+    /// remove whitespace-only lines from the start/end of lines\n+    fn vertical_trim(lines: Vec<String>) -> Vec<String> {\n+        let mut i = 0;\n+        let mut j = lines.len();\n+        // first line of all-stars should be omitted\n+        if !lines.is_empty() && lines[0].chars().all(|c| c == '*') {\n+            i += 1;\n+        }\n+\n+        while i < j && lines[i].trim().is_empty() {\n+            i += 1;\n+        }\n+        // like the first, a last line of all stars should be omitted\n+        if j > i && lines[j - 1].chars().skip(1).all(|c| c == '*') {\n+            j -= 1;\n+        }\n+\n+        while j > i && lines[j - 1].trim().is_empty() {\n+            j -= 1;\n+        }\n+\n+        lines[i..j].to_vec()\n+    }\n+\n+    /// remove a \"[ \\t]*\\*\" block from each line, if possible\n+    fn horizontal_trim(lines: Vec<String>) -> Vec<String> {\n+        let mut i = usize::MAX;\n+        let mut can_trim = true;\n+        let mut first = true;\n+\n+        for line in &lines {\n+            for (j, c) in line.chars().enumerate() {\n+                if j > i || !\"* \\t\".contains(c) {\n+                    can_trim = false;\n+                    break;\n+                }\n+                if c == '*' {\n+                    if first {\n+                        i = j;\n+                        first = false;\n+                    } else if i != j {\n+                        can_trim = false;\n+                    }\n+                    break;\n+                }\n+            }\n+            if i >= line.len() {\n+                can_trim = false;\n+            }\n+            if !can_trim {\n+                break;\n+            }\n+        }\n+\n+        if can_trim {\n+            lines.iter().map(|line| (&line[i + 1..line.len()]).to_string()).collect()\n+        } else {\n+            lines\n+        }\n+    }\n+\n+    let data = data.as_str();\n+    if data.contains('\\n') {\n+        let lines = data.lines().map(|s| s.to_string()).collect::<Vec<String>>();\n+        let lines = vertical_trim(lines);\n+        let lines = horizontal_trim(lines);\n+        lines.join(\"\\n\")\n+    } else {\n+        data.to_string()\n+    }\n+}\n+\n+/// Returns `None` if the first `col` chars of `s` contain a non-whitespace char.\n+/// Otherwise returns `Some(k)` where `k` is first char offset after that leading\n+/// whitespace. Note that `k` may be outside bounds of `s`.\n+fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n+    let mut idx = 0;\n+    for (i, ch) in s.char_indices().take(col.to_usize()) {\n+        if !ch.is_whitespace() {\n+            return None;\n+        }\n+        idx = i + ch.len_utf8();\n+    }\n+    Some(idx)\n+}\n+\n+fn trim_whitespace_prefix(s: &str, col: CharPos) -> &str {\n+    let len = s.len();\n+    match all_whitespace(&s, col) {\n+        Some(col) => {\n+            if col < len {\n+                &s[col..]\n+            } else {\n+                \"\"\n+            }\n+        }\n+        None => s,\n+    }\n+}\n+\n+fn split_block_comment_into_lines(text: &str, col: CharPos) -> Vec<String> {\n+    let mut res: Vec<String> = vec![];\n+    let mut lines = text.lines();\n+    // just push the first line\n+    res.extend(lines.next().map(|it| it.to_string()));\n+    // for other lines, strip common whitespace prefix\n+    for line in lines {\n+        res.push(trim_whitespace_prefix(line, col).to_string())\n+    }\n+    res\n+}\n+\n+// it appears this function is called only from pprust... that's\n+// probably not a good thing.\n+pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comment> {\n+    let sm = SourceMap::new(sm.path_mapping().clone());\n+    let source_file = sm.new_source_file(path, src);\n+    let text = (*source_file.src.as_ref().unwrap()).clone();\n+\n+    let text: &str = text.as_str();\n+    let start_bpos = source_file.start_pos;\n+    let mut pos = 0;\n+    let mut comments: Vec<Comment> = Vec::new();\n+    let mut code_to_the_left = false;\n+\n+    if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {\n+        comments.push(Comment {\n+            style: CommentStyle::Isolated,\n+            lines: vec![text[..shebang_len].to_string()],\n+            pos: start_bpos,\n+        });\n+        pos += shebang_len;\n+    }\n+\n+    for token in rustc_lexer::tokenize(&text[pos..]) {\n+        let token_text = &text[pos..pos + token.len];\n+        match token.kind {\n+            rustc_lexer::TokenKind::Whitespace => {\n+                if let Some(mut idx) = token_text.find('\\n') {\n+                    code_to_the_left = false;\n+                    while let Some(next_newline) = &token_text[idx + 1..].find('\\n') {\n+                        idx = idx + 1 + next_newline;\n+                        comments.push(Comment {\n+                            style: CommentStyle::BlankLine,\n+                            lines: vec![],\n+                            pos: start_bpos + BytePos((pos + idx) as u32),\n+                        });\n+                    }\n+                }\n+            }\n+            rustc_lexer::TokenKind::BlockComment { doc_style, .. } => {\n+                if doc_style.is_none() {\n+                    let code_to_the_right = match text[pos + token.len..].chars().next() {\n+                        Some('\\r' | '\\n') => false,\n+                        _ => true,\n+                    };\n+                    let style = match (code_to_the_left, code_to_the_right) {\n+                        (_, true) => CommentStyle::Mixed,\n+                        (false, false) => CommentStyle::Isolated,\n+                        (true, false) => CommentStyle::Trailing,\n+                    };\n+\n+                    // Count the number of chars since the start of the line by rescanning.\n+                    let pos_in_file = start_bpos + BytePos(pos as u32);\n+                    let line_begin_in_file = source_file.line_begin_pos(pos_in_file);\n+                    let line_begin_pos = (line_begin_in_file - start_bpos).to_usize();\n+                    let col = CharPos(text[line_begin_pos..pos].chars().count());\n+\n+                    let lines = split_block_comment_into_lines(token_text, col);\n+                    comments.push(Comment { style, lines, pos: pos_in_file })\n+                }\n+            }\n+            rustc_lexer::TokenKind::LineComment { doc_style } => {\n+                if doc_style.is_none() {\n+                    comments.push(Comment {\n+                        style: if code_to_the_left {\n+                            CommentStyle::Trailing\n+                        } else {\n+                            CommentStyle::Isolated\n+                        },\n+                        lines: vec![token_text.to_string()],\n+                        pos: start_bpos + BytePos(pos as u32),\n+                    })\n+                }\n+            }\n+            _ => {\n+                code_to_the_left = true;\n+            }\n+        }\n+        pos += token.len;\n+    }\n+\n+    comments\n+}"}, {"sha": "e19198f863ba830cc5ab9b1a9f83c7dd1feb2be4", "filename": "compiler/rustc_ast/src/util/comments/tests.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,43 @@\n+use super::*;\n+use rustc_span::with_default_session_globals;\n+\n+#[test]\n+fn test_block_doc_comment_1() {\n+    with_default_session_globals(|| {\n+        let comment = \"\\n * Test \\n **  Test\\n *   Test\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n+    })\n+}\n+\n+#[test]\n+fn test_block_doc_comment_2() {\n+    with_default_session_globals(|| {\n+        let comment = \"\\n * Test\\n *  Test\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        assert_eq!(stripped, \" Test\\n  Test\");\n+    })\n+}\n+\n+#[test]\n+fn test_block_doc_comment_3() {\n+    with_default_session_globals(|| {\n+        let comment = \"\\n let a: *i32;\\n *a = 5;\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n+        assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n+    })\n+}\n+\n+#[test]\n+fn test_line_doc_comment() {\n+    with_default_session_globals(|| {\n+        let stripped = beautify_doc_string(Symbol::intern(\" test\"));\n+        assert_eq!(stripped, \" test\");\n+        let stripped = beautify_doc_string(Symbol::intern(\"! test\"));\n+        assert_eq!(stripped, \"! test\");\n+        let stripped = beautify_doc_string(Symbol::intern(\"test\"));\n+        assert_eq!(stripped, \"test\");\n+        let stripped = beautify_doc_string(Symbol::intern(\"!test\"));\n+        assert_eq!(stripped, \"!test\");\n+    })\n+}"}, {"sha": "d4e0e3ba051c95c214f2561ce94757583d6a3787", "filename": "compiler/rustc_ast/src/util/lev_distance.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast/util/lev_distance.rs"}, {"sha": "7ebedbcb76a3695d519018e313bd7d1f254d7f16", "filename": "compiler/rustc_ast/src/util/lev_distance/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,59 @@\n+use super::*;\n+\n+#[test]\n+fn test_lev_distance() {\n+    use std::char::{from_u32, MAX};\n+    // Test bytelength agnosticity\n+    for c in (0..MAX as u32).filter_map(|i| from_u32(i)).map(|i| i.to_string()) {\n+        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(lev_distance(a, b), 1);\n+    assert_eq!(lev_distance(b, a), 1);\n+    assert_eq!(lev_distance(a, c), 2);\n+    assert_eq!(lev_distance(c, a), 2);\n+    assert_eq!(lev_distance(b, c), 1);\n+    assert_eq!(lev_distance(c, b), 1);\n+}\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use rustc_span::with_default_session_globals;\n+    with_default_session_globals(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), Symbol::intern(\"1111111111\"), None),\n+            None\n+        );\n+\n+        let input = vec![Symbol::intern(\"aAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), Symbol::intern(\"AAAA\"), None),\n+            Some(Symbol::intern(\"aAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        // Returns None because `lev_distance > max_dist / 3`\n+        assert_eq!(find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), None), None);\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), Symbol::intern(\"aaaa\"), Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), Symbol::intern(\"a_variable_longer_name\"), None),\n+            Some(Symbol::intern(\"a_longer_variable_name\"))\n+        );\n+    })\n+}"}, {"sha": "597e5b437fcb15c983912b200c3c7afc4e9d40d8", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -10,8 +10,8 @@ use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n use std::ascii;\n+use tracing::debug;\n \n pub enum LitError {\n     NotLiteral,", "previous_filename": "src/librustc_ast/util/literal.rs"}, {"sha": "2ee94965756a5e0d72fc8bbe084b628f1c49f799", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -222,7 +222,6 @@ impl AssocOp {\n             Greater | // `{ 42 } > 3`\n             GreaterEqual | // `{ 42 } >= 3`\n             AssignOp(_) | // `{ 42 } +=`\n-            LAnd | // `{ 42 } &&foo`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n             // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.", "previous_filename": "src/librustc_ast/util/parser.rs"}, {"sha": "b65a88cb90e88501721432cced016e00185e3cef", "filename": "compiler/rustc_ast/src/visit.rs", "status": "added", "additions": 913, "deletions": 0, "changes": 913, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,913 @@\n+//! AST walker. Each overridden visit method has full control over what\n+//! happens with its node, it can do its own traversal of the node's children,\n+//! call `visit::walk_*` to apply the default traversal algorithm, or prevent\n+//! deeper traversal by doing nothing.\n+//!\n+//! Note: it is an important invariant that the default visitor walks the body\n+//! of a function in \"execution order\" (more concretely, reverse post-order\n+//! with respect to the CFG implied by the AST), meaning that if AST node A may\n+//! execute before AST node B, then A is visited first. The borrow checker in\n+//! particular relies on this property.\n+//!\n+//! Note: walking an AST before macro expansion is probably a bad idea. For\n+//! instance, a walker looking for item names in a module will miss all of\n+//! those that are created by the expansion of a macro.\n+\n+use crate::ast::*;\n+use crate::token::Token;\n+use crate::tokenstream::{TokenStream, TokenTree};\n+\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum AssocCtxt {\n+    Trait,\n+    Impl,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum FnCtxt {\n+    Free,\n+    Foreign,\n+    Assoc(AssocCtxt),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum FnKind<'a> {\n+    /// E.g., `fn foo()`, `fn foo(&self)`, or `extern \"Abi\" fn foo()`.\n+    Fn(FnCtxt, Ident, &'a FnSig, &'a Visibility, Option<&'a Block>),\n+\n+    /// E.g., `|x, y| body`.\n+    Closure(&'a FnDecl, &'a Expr),\n+}\n+\n+impl<'a> FnKind<'a> {\n+    pub fn header(&self) -> Option<&'a FnHeader> {\n+        match *self {\n+            FnKind::Fn(_, _, sig, _, _) => Some(&sig.header),\n+            FnKind::Closure(_, _) => None,\n+        }\n+    }\n+\n+    pub fn ident(&self) -> Option<&Ident> {\n+        match self {\n+            FnKind::Fn(_, ident, ..) => Some(ident),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn decl(&self) -> &'a FnDecl {\n+        match self {\n+            FnKind::Fn(_, _, sig, _, _) => &sig.decl,\n+            FnKind::Closure(decl, _) => decl,\n+        }\n+    }\n+\n+    pub fn ctxt(&self) -> Option<FnCtxt> {\n+        match self {\n+            FnKind::Fn(ctxt, ..) => Some(*ctxt),\n+            FnKind::Closure(..) => None,\n+        }\n+    }\n+}\n+\n+/// Each method of the `Visitor` trait is a hook to be potentially\n+/// overridden. Each method's default implementation recursively visits\n+/// the substructure of the input via the corresponding `walk` method;\n+/// e.g., the `visit_mod` method by default calls `visit::walk_mod`.\n+///\n+/// If you want to ensure that your code handles every variant\n+/// explicitly, you need to override each method. (And you also need\n+/// to monitor future changes to `Visitor` in case a new method with a\n+/// new default implementation gets introduced.)\n+pub trait Visitor<'ast>: Sized {\n+    fn visit_name(&mut self, _span: Span, _name: Symbol) {\n+        // Nothing to do.\n+    }\n+    fn visit_ident(&mut self, ident: Ident) {\n+        walk_ident(self, ident);\n+    }\n+    fn visit_mod(&mut self, m: &'ast Mod, _s: Span, _attrs: &[Attribute], _n: NodeId) {\n+        walk_mod(self, m);\n+    }\n+    fn visit_foreign_item(&mut self, i: &'ast ForeignItem) {\n+        walk_foreign_item(self, i)\n+    }\n+    fn visit_global_asm(&mut self, ga: &'ast GlobalAsm) {\n+        walk_global_asm(self, ga)\n+    }\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        walk_item(self, i)\n+    }\n+    fn visit_local(&mut self, l: &'ast Local) {\n+        walk_local(self, l)\n+    }\n+    fn visit_block(&mut self, b: &'ast Block) {\n+        walk_block(self, b)\n+    }\n+    fn visit_stmt(&mut self, s: &'ast Stmt) {\n+        walk_stmt(self, s)\n+    }\n+    fn visit_param(&mut self, param: &'ast Param) {\n+        walk_param(self, param)\n+    }\n+    fn visit_arm(&mut self, a: &'ast Arm) {\n+        walk_arm(self, a)\n+    }\n+    fn visit_pat(&mut self, p: &'ast Pat) {\n+        walk_pat(self, p)\n+    }\n+    fn visit_anon_const(&mut self, c: &'ast AnonConst) {\n+        walk_anon_const(self, c)\n+    }\n+    fn visit_expr(&mut self, ex: &'ast Expr) {\n+        walk_expr(self, ex)\n+    }\n+    fn visit_expr_post(&mut self, _ex: &'ast Expr) {}\n+    fn visit_ty(&mut self, t: &'ast Ty) {\n+        walk_ty(self, t)\n+    }\n+    fn visit_generic_param(&mut self, param: &'ast GenericParam) {\n+        walk_generic_param(self, param)\n+    }\n+    fn visit_generics(&mut self, g: &'ast Generics) {\n+        walk_generics(self, g)\n+    }\n+    fn visit_where_predicate(&mut self, p: &'ast WherePredicate) {\n+        walk_where_predicate(self, p)\n+    }\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, s: Span, _: NodeId) {\n+        walk_fn(self, fk, s)\n+    }\n+    fn visit_assoc_item(&mut self, i: &'ast AssocItem, ctxt: AssocCtxt) {\n+        walk_assoc_item(self, i, ctxt)\n+    }\n+    fn visit_trait_ref(&mut self, t: &'ast TraitRef) {\n+        walk_trait_ref(self, t)\n+    }\n+    fn visit_param_bound(&mut self, bounds: &'ast GenericBound) {\n+        walk_param_bound(self, bounds)\n+    }\n+    fn visit_poly_trait_ref(&mut self, t: &'ast PolyTraitRef, m: &'ast TraitBoundModifier) {\n+        walk_poly_trait_ref(self, t, m)\n+    }\n+    fn visit_variant_data(&mut self, s: &'ast VariantData) {\n+        walk_struct_def(self, s)\n+    }\n+    fn visit_struct_field(&mut self, s: &'ast StructField) {\n+        walk_struct_field(self, s)\n+    }\n+    fn visit_enum_def(\n+        &mut self,\n+        enum_definition: &'ast EnumDef,\n+        generics: &'ast Generics,\n+        item_id: NodeId,\n+        _: Span,\n+    ) {\n+        walk_enum_def(self, enum_definition, generics, item_id)\n+    }\n+    fn visit_variant(&mut self, v: &'ast Variant) {\n+        walk_variant(self, v)\n+    }\n+    fn visit_label(&mut self, label: &'ast Label) {\n+        walk_label(self, label)\n+    }\n+    fn visit_lifetime(&mut self, lifetime: &'ast Lifetime) {\n+        walk_lifetime(self, lifetime)\n+    }\n+    fn visit_mac(&mut self, _mac: &'ast MacCall) {\n+        panic!(\"visit_mac disabled by default\");\n+        // N.B., see note about macros above.\n+        // if you really want a visitor that\n+        // works on macros, use this\n+        // definition in your trait impl:\n+        // visit::walk_mac(self, _mac)\n+    }\n+    fn visit_mac_def(&mut self, _mac: &'ast MacroDef, _id: NodeId) {\n+        // Nothing to do\n+    }\n+    fn visit_path(&mut self, path: &'ast Path, _id: NodeId) {\n+        walk_path(self, path)\n+    }\n+    fn visit_use_tree(&mut self, use_tree: &'ast UseTree, id: NodeId, _nested: bool) {\n+        walk_use_tree(self, use_tree, id)\n+    }\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'ast PathSegment) {\n+        walk_path_segment(self, path_span, path_segment)\n+    }\n+    fn visit_generic_args(&mut self, path_span: Span, generic_args: &'ast GenericArgs) {\n+        walk_generic_args(self, path_span, generic_args)\n+    }\n+    fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n+        match generic_arg {\n+            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n+            GenericArg::Type(ty) => self.visit_ty(ty),\n+            GenericArg::Const(ct) => self.visit_anon_const(ct),\n+        }\n+    }\n+    fn visit_assoc_ty_constraint(&mut self, constraint: &'ast AssocTyConstraint) {\n+        walk_assoc_ty_constraint(self, constraint)\n+    }\n+    fn visit_attribute(&mut self, attr: &'ast Attribute) {\n+        walk_attribute(self, attr)\n+    }\n+    fn visit_tt(&mut self, tt: TokenTree) {\n+        walk_tt(self, tt)\n+    }\n+    fn visit_tts(&mut self, tts: TokenStream) {\n+        walk_tts(self, tts)\n+    }\n+    fn visit_token(&mut self, _t: Token) {}\n+    // FIXME: add `visit_interpolated` and `walk_interpolated`\n+    fn visit_vis(&mut self, vis: &'ast Visibility) {\n+        walk_vis(self, vis)\n+    }\n+    fn visit_fn_ret_ty(&mut self, ret_ty: &'ast FnRetTy) {\n+        walk_fn_ret_ty(self, ret_ty)\n+    }\n+    fn visit_fn_header(&mut self, _header: &'ast FnHeader) {\n+        // Nothing to do\n+    }\n+    fn visit_field(&mut self, f: &'ast Field) {\n+        walk_field(self, f)\n+    }\n+    fn visit_field_pattern(&mut self, fp: &'ast FieldPat) {\n+        walk_field_pattern(self, fp)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! walk_list {\n+    ($visitor: expr, $method: ident, $list: expr) => {\n+        for elem in $list {\n+            $visitor.$method(elem)\n+        }\n+    };\n+    ($visitor: expr, $method: ident, $list: expr, $($extra_args: expr),*) => {\n+        for elem in $list {\n+            $visitor.$method(elem, $($extra_args,)*)\n+        }\n+    }\n+}\n+\n+pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.span, ident.name);\n+}\n+\n+pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n+    visitor.visit_mod(&krate.module, krate.span, &krate.attrs, CRATE_NODE_ID);\n+    walk_list!(visitor, visit_attribute, &krate.attrs);\n+}\n+\n+pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n+    walk_list!(visitor, visit_item, &module.items);\n+}\n+\n+pub fn walk_local<'a, V: Visitor<'a>>(visitor: &mut V, local: &'a Local) {\n+    for attr in local.attrs.iter() {\n+        visitor.visit_attribute(attr);\n+    }\n+    visitor.visit_pat(&local.pat);\n+    walk_list!(visitor, visit_ty, &local.ty);\n+    walk_list!(visitor, visit_expr, &local.init);\n+}\n+\n+pub fn walk_label<'a, V: Visitor<'a>>(visitor: &mut V, label: &'a Label) {\n+    visitor.visit_ident(label.ident);\n+}\n+\n+pub fn walk_lifetime<'a, V: Visitor<'a>>(visitor: &mut V, lifetime: &'a Lifetime) {\n+    visitor.visit_ident(lifetime.ident);\n+}\n+\n+pub fn walk_poly_trait_ref<'a, V>(\n+    visitor: &mut V,\n+    trait_ref: &'a PolyTraitRef,\n+    _: &TraitBoundModifier,\n+) where\n+    V: Visitor<'a>,\n+{\n+    walk_list!(visitor, visit_generic_param, &trait_ref.bound_generic_params);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n+pub fn walk_trait_ref<'a, V: Visitor<'a>>(visitor: &mut V, trait_ref: &'a TraitRef) {\n+    visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n+}\n+\n+pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n+    visitor.visit_vis(&item.vis);\n+    visitor.visit_ident(item.ident);\n+    match item.kind {\n+        ItemKind::ExternCrate(orig_name) => {\n+            if let Some(orig_name) = orig_name {\n+                visitor.visit_name(item.span, orig_name);\n+            }\n+        }\n+        ItemKind::Use(ref use_tree) => visitor.visit_use_tree(use_tree, item.id, false),\n+        ItemKind::Static(ref typ, _, ref expr) | ItemKind::Const(_, ref typ, ref expr) => {\n+            visitor.visit_ty(typ);\n+            walk_list!(visitor, visit_expr, expr);\n+        }\n+        ItemKind::Fn(_, ref sig, ref generics, ref body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n+            visitor.visit_fn(kind, item.span, item.id)\n+        }\n+        ItemKind::Mod(ref module) => visitor.visit_mod(module, item.span, &item.attrs, item.id),\n+        ItemKind::ForeignMod(ref foreign_module) => {\n+            walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n+        }\n+        ItemKind::GlobalAsm(ref ga) => visitor.visit_global_asm(ga),\n+        ItemKind::TyAlias(_, ref generics, ref bounds, ref ty) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, ty);\n+        }\n+        ItemKind::Enum(ref enum_definition, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_enum_def(enum_definition, generics, item.id, item.span)\n+        }\n+        ItemKind::Impl {\n+            unsafety: _,\n+            polarity: _,\n+            defaultness: _,\n+            constness: _,\n+            ref generics,\n+            ref of_trait,\n+            ref self_ty,\n+            ref items,\n+        } => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_trait_ref, of_trait);\n+            visitor.visit_ty(self_ty);\n+            walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Impl);\n+        }\n+        ItemKind::Struct(ref struct_definition, ref generics)\n+        | ItemKind::Union(ref struct_definition, ref generics) => {\n+            visitor.visit_generics(generics);\n+            visitor.visit_variant_data(struct_definition);\n+        }\n+        ItemKind::Trait(.., ref generics, ref bounds, ref items) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_assoc_item, items, AssocCtxt::Trait);\n+        }\n+        ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+        ItemKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n+    }\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n+}\n+\n+pub fn walk_enum_def<'a, V: Visitor<'a>>(\n+    visitor: &mut V,\n+    enum_definition: &'a EnumDef,\n+    _: &'a Generics,\n+    _: NodeId,\n+) {\n+    walk_list!(visitor, visit_variant, &enum_definition.variants);\n+}\n+\n+pub fn walk_variant<'a, V: Visitor<'a>>(visitor: &mut V, variant: &'a Variant)\n+where\n+    V: Visitor<'a>,\n+{\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_vis(&variant.vis);\n+    visitor.visit_variant_data(&variant.data);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n+}\n+\n+pub fn walk_field<'a, V: Visitor<'a>>(visitor: &mut V, f: &'a Field) {\n+    visitor.visit_expr(&f.expr);\n+    visitor.visit_ident(f.ident);\n+    walk_list!(visitor, visit_attribute, f.attrs.iter());\n+}\n+\n+pub fn walk_field_pattern<'a, V: Visitor<'a>>(visitor: &mut V, fp: &'a FieldPat) {\n+    visitor.visit_ident(fp.ident);\n+    visitor.visit_pat(&fp.pat);\n+    walk_list!(visitor, visit_attribute, fp.attrs.iter());\n+}\n+\n+pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n+    match typ.kind {\n+        TyKind::Slice(ref ty) | TyKind::Paren(ref ty) => visitor.visit_ty(ty),\n+        TyKind::Ptr(ref mutable_type) => visitor.visit_ty(&mutable_type.ty),\n+        TyKind::Rptr(ref opt_lifetime, ref mutable_type) => {\n+            walk_list!(visitor, visit_lifetime, opt_lifetime);\n+            visitor.visit_ty(&mutable_type.ty)\n+        }\n+        TyKind::Tup(ref tuple_element_types) => {\n+            walk_list!(visitor, visit_ty, tuple_element_types);\n+        }\n+        TyKind::BareFn(ref function_declaration) => {\n+            walk_list!(visitor, visit_generic_param, &function_declaration.generic_params);\n+            walk_fn_decl(visitor, &function_declaration.decl);\n+        }\n+        TyKind::Path(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, typ.id);\n+        }\n+        TyKind::Array(ref ty, ref length) => {\n+            visitor.visit_ty(ty);\n+            visitor.visit_anon_const(length)\n+        }\n+        TyKind::TraitObject(ref bounds, ..) | TyKind::ImplTrait(_, ref bounds) => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+        TyKind::Typeof(ref expression) => visitor.visit_anon_const(expression),\n+        TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err => {}\n+        TyKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        TyKind::Never | TyKind::CVarArgs => {}\n+    }\n+}\n+\n+pub fn walk_path<'a, V: Visitor<'a>>(visitor: &mut V, path: &'a Path) {\n+    for segment in &path.segments {\n+        visitor.visit_path_segment(path.span, segment);\n+    }\n+}\n+\n+pub fn walk_use_tree<'a, V: Visitor<'a>>(visitor: &mut V, use_tree: &'a UseTree, id: NodeId) {\n+    visitor.visit_path(&use_tree.prefix, id);\n+    match use_tree.kind {\n+        UseTreeKind::Simple(rename, ..) => {\n+            // The extra IDs are handled during HIR lowering.\n+            if let Some(rename) = rename {\n+                visitor.visit_ident(rename);\n+            }\n+        }\n+        UseTreeKind::Glob => {}\n+        UseTreeKind::Nested(ref use_trees) => {\n+            for &(ref nested_tree, nested_id) in use_trees {\n+                visitor.visit_use_tree(nested_tree, nested_id, true);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn walk_path_segment<'a, V: Visitor<'a>>(\n+    visitor: &mut V,\n+    path_span: Span,\n+    segment: &'a PathSegment,\n+) {\n+    visitor.visit_ident(segment.ident);\n+    if let Some(ref args) = segment.args {\n+        visitor.visit_generic_args(path_span, args);\n+    }\n+}\n+\n+pub fn walk_generic_args<'a, V>(visitor: &mut V, _path_span: Span, generic_args: &'a GenericArgs)\n+where\n+    V: Visitor<'a>,\n+{\n+    match *generic_args {\n+        GenericArgs::AngleBracketed(ref data) => {\n+            for arg in &data.args {\n+                match arg {\n+                    AngleBracketedArg::Arg(a) => visitor.visit_generic_arg(a),\n+                    AngleBracketedArg::Constraint(c) => visitor.visit_assoc_ty_constraint(c),\n+                }\n+            }\n+        }\n+        GenericArgs::Parenthesized(ref data) => {\n+            walk_list!(visitor, visit_ty, &data.inputs);\n+            walk_fn_ret_ty(visitor, &data.output);\n+        }\n+    }\n+}\n+\n+pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n+    visitor: &mut V,\n+    constraint: &'a AssocTyConstraint,\n+) {\n+    visitor.visit_ident(constraint.ident);\n+    match constraint.kind {\n+        AssocTyConstraintKind::Equality { ref ty } => {\n+            visitor.visit_ty(ty);\n+        }\n+        AssocTyConstraintKind::Bound { ref bounds } => {\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+    }\n+}\n+\n+pub fn walk_pat<'a, V: Visitor<'a>>(visitor: &mut V, pattern: &'a Pat) {\n+    match pattern.kind {\n+        PatKind::TupleStruct(ref path, ref elems) => {\n+            visitor.visit_path(path, pattern.id);\n+            walk_list!(visitor, visit_pat, elems);\n+        }\n+        PatKind::Path(ref opt_qself, ref path) => {\n+            if let Some(ref qself) = *opt_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, pattern.id)\n+        }\n+        PatKind::Struct(ref path, ref fields, _) => {\n+            visitor.visit_path(path, pattern.id);\n+            walk_list!(visitor, visit_field_pattern, fields);\n+        }\n+        PatKind::Box(ref subpattern)\n+        | PatKind::Ref(ref subpattern, _)\n+        | PatKind::Paren(ref subpattern) => visitor.visit_pat(subpattern),\n+        PatKind::Ident(_, ident, ref optional_subpattern) => {\n+            visitor.visit_ident(ident);\n+            walk_list!(visitor, visit_pat, optional_subpattern);\n+        }\n+        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n+        PatKind::Range(ref lower_bound, ref upper_bound, _) => {\n+            walk_list!(visitor, visit_expr, lower_bound);\n+            walk_list!(visitor, visit_expr, upper_bound);\n+        }\n+        PatKind::Wild | PatKind::Rest => {}\n+        PatKind::Tuple(ref elems) | PatKind::Slice(ref elems) | PatKind::Or(ref elems) => {\n+            walk_list!(visitor, visit_pat, elems);\n+        }\n+        PatKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+    }\n+}\n+\n+pub fn walk_foreign_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a ForeignItem) {\n+    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    visitor.visit_vis(vis);\n+    visitor.visit_ident(ident);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match kind {\n+        ForeignItemKind::Static(ty, _, expr) => {\n+            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_expr, expr);\n+        }\n+        ForeignItemKind::Fn(_, sig, generics, body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(FnCtxt::Foreign, ident, sig, vis, body.as_deref());\n+            visitor.visit_fn(kind, span, id);\n+        }\n+        ForeignItemKind::TyAlias(_, generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, ty);\n+        }\n+        ForeignItemKind::MacCall(mac) => {\n+            visitor.visit_mac(mac);\n+        }\n+    }\n+}\n+\n+pub fn walk_global_asm<'a, V: Visitor<'a>>(_: &mut V, _: &'a GlobalAsm) {\n+    // Empty!\n+}\n+\n+pub fn walk_param_bound<'a, V: Visitor<'a>>(visitor: &mut V, bound: &'a GenericBound) {\n+    match *bound {\n+        GenericBound::Trait(ref typ, ref modifier) => visitor.visit_poly_trait_ref(typ, modifier),\n+        GenericBound::Outlives(ref lifetime) => visitor.visit_lifetime(lifetime),\n+    }\n+}\n+\n+pub fn walk_generic_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a GenericParam) {\n+    visitor.visit_ident(param.ident);\n+    walk_list!(visitor, visit_attribute, param.attrs.iter());\n+    walk_list!(visitor, visit_param_bound, &param.bounds);\n+    match param.kind {\n+        GenericParamKind::Lifetime => (),\n+        GenericParamKind::Type { ref default } => walk_list!(visitor, visit_ty, default),\n+        GenericParamKind::Const { ref ty, .. } => visitor.visit_ty(ty),\n+    }\n+}\n+\n+pub fn walk_generics<'a, V: Visitor<'a>>(visitor: &mut V, generics: &'a Generics) {\n+    walk_list!(visitor, visit_generic_param, &generics.params);\n+    walk_list!(visitor, visit_where_predicate, &generics.where_clause.predicates);\n+}\n+\n+pub fn walk_where_predicate<'a, V: Visitor<'a>>(visitor: &mut V, predicate: &'a WherePredicate) {\n+    match *predicate {\n+        WherePredicate::BoundPredicate(WhereBoundPredicate {\n+            ref bounded_ty,\n+            ref bounds,\n+            ref bound_generic_params,\n+            ..\n+        }) => {\n+            visitor.visit_ty(bounded_ty);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_generic_param, bound_generic_params);\n+        }\n+        WherePredicate::RegionPredicate(WhereRegionPredicate {\n+            ref lifetime, ref bounds, ..\n+        }) => {\n+            visitor.visit_lifetime(lifetime);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+        }\n+        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+            visitor.visit_ty(lhs_ty);\n+            visitor.visit_ty(rhs_ty);\n+        }\n+    }\n+}\n+\n+pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FnRetTy) {\n+    if let FnRetTy::Ty(ref output_ty) = *ret_ty {\n+        visitor.visit_ty(output_ty)\n+    }\n+}\n+\n+pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n+    for param in &function_declaration.inputs {\n+        visitor.visit_param(param);\n+    }\n+    visitor.visit_fn_ret_ty(&function_declaration.output);\n+}\n+\n+pub fn walk_fn<'a, V: Visitor<'a>>(visitor: &mut V, kind: FnKind<'a>, _span: Span) {\n+    match kind {\n+        FnKind::Fn(_, _, sig, _, body) => {\n+            visitor.visit_fn_header(&sig.header);\n+            walk_fn_decl(visitor, &sig.decl);\n+            walk_list!(visitor, visit_block, body);\n+        }\n+        FnKind::Closure(decl, body) => {\n+            walk_fn_decl(visitor, decl);\n+            visitor.visit_expr(body);\n+        }\n+    }\n+}\n+\n+pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem, ctxt: AssocCtxt) {\n+    let Item { id, span, ident, ref vis, ref attrs, ref kind, tokens: _ } = *item;\n+    visitor.visit_vis(vis);\n+    visitor.visit_ident(ident);\n+    walk_list!(visitor, visit_attribute, attrs);\n+    match kind {\n+        AssocItemKind::Const(_, ty, expr) => {\n+            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_expr, expr);\n+        }\n+        AssocItemKind::Fn(_, sig, generics, body) => {\n+            visitor.visit_generics(generics);\n+            let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, body.as_deref());\n+            visitor.visit_fn(kind, span, id);\n+        }\n+        AssocItemKind::TyAlias(_, generics, bounds, ty) => {\n+            visitor.visit_generics(generics);\n+            walk_list!(visitor, visit_param_bound, bounds);\n+            walk_list!(visitor, visit_ty, ty);\n+        }\n+        AssocItemKind::MacCall(mac) => {\n+            visitor.visit_mac(mac);\n+        }\n+    }\n+}\n+\n+pub fn walk_struct_def<'a, V: Visitor<'a>>(visitor: &mut V, struct_definition: &'a VariantData) {\n+    walk_list!(visitor, visit_struct_field, struct_definition.fields());\n+}\n+\n+pub fn walk_struct_field<'a, V: Visitor<'a>>(visitor: &mut V, struct_field: &'a StructField) {\n+    visitor.visit_vis(&struct_field.vis);\n+    if let Some(ident) = struct_field.ident {\n+        visitor.visit_ident(ident);\n+    }\n+    visitor.visit_ty(&struct_field.ty);\n+    walk_list!(visitor, visit_attribute, &struct_field.attrs);\n+}\n+\n+pub fn walk_block<'a, V: Visitor<'a>>(visitor: &mut V, block: &'a Block) {\n+    walk_list!(visitor, visit_stmt, &block.stmts);\n+}\n+\n+pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n+    match statement.kind {\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_item(item),\n+        StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => visitor.visit_expr(expr),\n+        StmtKind::Empty => {}\n+        StmtKind::MacCall(ref mac) => {\n+            let (ref mac, _, ref attrs) = **mac;\n+            visitor.visit_mac(mac);\n+            for attr in attrs.iter() {\n+                visitor.visit_attribute(attr);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn walk_mac<'a, V: Visitor<'a>>(visitor: &mut V, mac: &'a MacCall) {\n+    visitor.visit_path(&mac.path, DUMMY_NODE_ID);\n+}\n+\n+pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonConst) {\n+    visitor.visit_expr(&constant.value);\n+}\n+\n+pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n+    walk_list!(visitor, visit_attribute, expression.attrs.iter());\n+\n+    match expression.kind {\n+        ExprKind::Box(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::Array(ref subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Repeat(ref element, ref count) => {\n+            visitor.visit_expr(element);\n+            visitor.visit_anon_const(count)\n+        }\n+        ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n+            visitor.visit_path(path, expression.id);\n+            walk_list!(visitor, visit_field, fields);\n+            walk_list!(visitor, visit_expr, optional_base);\n+        }\n+        ExprKind::Tup(ref subexpressions) => {\n+            walk_list!(visitor, visit_expr, subexpressions);\n+        }\n+        ExprKind::Call(ref callee_expression, ref arguments) => {\n+            visitor.visit_expr(callee_expression);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::MethodCall(ref segment, ref arguments, _span) => {\n+            visitor.visit_path_segment(expression.span, segment);\n+            walk_list!(visitor, visit_expr, arguments);\n+        }\n+        ExprKind::Binary(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression)\n+        }\n+        ExprKind::AddrOf(_, _, ref subexpression) | ExprKind::Unary(_, ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n+        ExprKind::Cast(ref subexpression, ref typ) | ExprKind::Type(ref subexpression, ref typ) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ty(typ)\n+        }\n+        ExprKind::Let(ref pat, ref scrutinee) => {\n+            visitor.visit_pat(pat);\n+            visitor.visit_expr(scrutinee);\n+        }\n+        ExprKind::If(ref head_expression, ref if_block, ref optional_else) => {\n+            visitor.visit_expr(head_expression);\n+            visitor.visit_block(if_block);\n+            walk_list!(visitor, visit_expr, optional_else);\n+        }\n+        ExprKind::While(ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::ForLoop(ref pattern, ref subexpression, ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_pat(pattern);\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Loop(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Match(ref subexpression, ref arms) => {\n+            visitor.visit_expr(subexpression);\n+            walk_list!(visitor, visit_arm, arms);\n+        }\n+        ExprKind::Closure(_, _, _, ref decl, ref body, _decl_span) => {\n+            visitor.visit_fn(FnKind::Closure(decl, body), expression.span, expression.id)\n+        }\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n+        ExprKind::Async(_, _, ref body) => {\n+            visitor.visit_block(body);\n+        }\n+        ExprKind::Await(ref expr) => visitor.visit_expr(expr),\n+        ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            visitor.visit_expr(lhs);\n+            visitor.visit_expr(rhs);\n+        }\n+        ExprKind::AssignOp(_, ref left_expression, ref right_expression) => {\n+            visitor.visit_expr(left_expression);\n+            visitor.visit_expr(right_expression);\n+        }\n+        ExprKind::Field(ref subexpression, ident) => {\n+            visitor.visit_expr(subexpression);\n+            visitor.visit_ident(ident);\n+        }\n+        ExprKind::Index(ref main_expression, ref index_expression) => {\n+            visitor.visit_expr(main_expression);\n+            visitor.visit_expr(index_expression)\n+        }\n+        ExprKind::Range(ref start, ref end, _) => {\n+            walk_list!(visitor, visit_expr, start);\n+            walk_list!(visitor, visit_expr, end);\n+        }\n+        ExprKind::Path(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(&qself.ty);\n+            }\n+            visitor.visit_path(path, expression.id)\n+        }\n+        ExprKind::Break(ref opt_label, ref opt_expr) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprKind::Continue(ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+        }\n+        ExprKind::Ret(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::MacCall(ref mac) => visitor.visit_mac(mac),\n+        ExprKind::Paren(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::InlineAsm(ref ia) => {\n+            for (op, _) in &ia.operands {\n+                match op {\n+                    InlineAsmOperand::In { expr, .. }\n+                    | InlineAsmOperand::InOut { expr, .. }\n+                    | InlineAsmOperand::Const { expr, .. }\n+                    | InlineAsmOperand::Sym { expr, .. } => visitor.visit_expr(expr),\n+                    InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            visitor.visit_expr(expr);\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        visitor.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            visitor.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        ExprKind::LlvmInlineAsm(ref ia) => {\n+            for &(_, ref input) in &ia.inputs {\n+                visitor.visit_expr(input)\n+            }\n+            for output in &ia.outputs {\n+                visitor.visit_expr(&output.expr)\n+            }\n+        }\n+        ExprKind::Yield(ref optional_expression) => {\n+            walk_list!(visitor, visit_expr, optional_expression);\n+        }\n+        ExprKind::Try(ref subexpression) => visitor.visit_expr(subexpression),\n+        ExprKind::TryBlock(ref body) => visitor.visit_block(body),\n+        ExprKind::Lit(_) | ExprKind::Err => {}\n+    }\n+\n+    visitor.visit_expr_post(expression)\n+}\n+\n+pub fn walk_param<'a, V: Visitor<'a>>(visitor: &mut V, param: &'a Param) {\n+    walk_list!(visitor, visit_attribute, param.attrs.iter());\n+    visitor.visit_pat(&param.pat);\n+    visitor.visit_ty(&param.ty);\n+}\n+\n+pub fn walk_arm<'a, V: Visitor<'a>>(visitor: &mut V, arm: &'a Arm) {\n+    visitor.visit_pat(&arm.pat);\n+    walk_list!(visitor, visit_expr, &arm.guard);\n+    visitor.visit_expr(&arm.body);\n+    walk_list!(visitor, visit_attribute, &arm.attrs);\n+}\n+\n+pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n+    if let VisibilityKind::Restricted { ref path, id } = vis.node {\n+        visitor.visit_path(path, id);\n+    }\n+}\n+\n+pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n+    match attr.kind {\n+        AttrKind::Normal(ref item) => walk_mac_args(visitor, &item.args),\n+        AttrKind::DocComment(..) => {}\n+    }\n+}\n+\n+pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+    match args {\n+        MacArgs::Empty => {}\n+        MacArgs::Delimited(_dspan, _delim, tokens) => visitor.visit_tts(tokens.clone()),\n+        MacArgs::Eq(_eq_span, tokens) => visitor.visit_tts(tokens.clone()),\n+    }\n+}\n+\n+pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {\n+    match tt {\n+        TokenTree::Token(token) => visitor.visit_token(token),\n+        TokenTree::Delimited(_, _, tts) => visitor.visit_tts(tts),\n+    }\n+}\n+\n+pub fn walk_tts<'a, V: Visitor<'a>>(visitor: &mut V, tts: TokenStream) {\n+    for tt in tts.trees() {\n+        visitor.visit_tt(tt);\n+    }\n+}"}, {"sha": "177a9066edf5da9b5bbdc3eb79b9e3a11e27275f", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ast_lowering\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc_arena = { path = \"../rustc_arena\" }\n+tracing = \"0.1\"\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "df452825bba5589a07224120ef76d4ccdebeb1ed", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "added", "additions": 1789, "deletions": 0, "changes": 1789, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1789 @@\n+use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n+\n+use rustc_ast::attr;\n+use rustc_ast::ptr::P as AstP;\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_span::hygiene::ForLoopLoc;\n+use rustc_span::source_map::{respan, DesugaringKind, Span, Spanned};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_target::asm;\n+use std::collections::hash_map::Entry;\n+use std::fmt::Write;\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> &'hir [hir::Expr<'hir>] {\n+        self.arena.alloc_from_iter(exprs.iter().map(|x| self.lower_expr_mut(x)))\n+    }\n+\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.lower_expr_mut(e))\n+    }\n+\n+    pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n+        ensure_sufficient_stack(|| {\n+            let kind = match e.kind {\n+                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n+                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::Repeat(ref expr, ref count) => {\n+                    let expr = self.lower_expr(expr);\n+                    let count = self.lower_anon_const(count);\n+                    hir::ExprKind::Repeat(expr, count)\n+                }\n+                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(ref f, ref args) => {\n+                    let f = self.lower_expr(f);\n+                    hir::ExprKind::Call(f, self.lower_exprs(args))\n+                }\n+                ExprKind::MethodCall(ref seg, ref args, span) => {\n+                    let hir_seg = self.arena.alloc(self.lower_path_segment(\n+                        e.span,\n+                        seg,\n+                        ParamMode::Optional,\n+                        0,\n+                        ParenthesizedGenericArgs::Err,\n+                        ImplTraitContext::disallowed(),\n+                        None,\n+                    ));\n+                    let args = self.lower_exprs(args);\n+                    hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args, span)\n+                }\n+                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                    let binop = self.lower_binop(binop);\n+                    let lhs = self.lower_expr(lhs);\n+                    let rhs = self.lower_expr(rhs);\n+                    hir::ExprKind::Binary(binop, lhs, rhs)\n+                }\n+                ExprKind::Unary(op, ref ohs) => {\n+                    let op = self.lower_unop(op);\n+                    let ohs = self.lower_expr(ohs);\n+                    hir::ExprKind::Unary(op, ohs)\n+                }\n+                ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.kind.clone())),\n+                ExprKind::Cast(ref expr, ref ty) => {\n+                    let expr = self.lower_expr(expr);\n+                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                    hir::ExprKind::Cast(expr, ty)\n+                }\n+                ExprKind::Type(ref expr, ref ty) => {\n+                    let expr = self.lower_expr(expr);\n+                    let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                    hir::ExprKind::Type(expr, ty)\n+                }\n+                ExprKind::AddrOf(k, m, ref ohs) => {\n+                    let ohs = self.lower_expr(ohs);\n+                    hir::ExprKind::AddrOf(k, m, ohs)\n+                }\n+                ExprKind::Let(ref pat, ref scrutinee) => {\n+                    self.lower_expr_let(e.span, pat, scrutinee)\n+                }\n+                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                    self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n+                }\n+                ExprKind::While(ref cond, ref body, opt_label) => self\n+                    .with_loop_scope(e.id, |this| {\n+                        this.lower_expr_while_in_loop_scope(e.span, cond, body, opt_label)\n+                    }),\n+                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    hir::ExprKind::Loop(\n+                        this.lower_block(body, false),\n+                        opt_label,\n+                        hir::LoopSource::Loop,\n+                    )\n+                }),\n+                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                    self.lower_expr(expr),\n+                    self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n+                    hir::MatchSource::Normal,\n+                ),\n+                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n+                    .make_async_expr(\n+                        capture_clause,\n+                        closure_node_id,\n+                        None,\n+                        block.span,\n+                        hir::AsyncGeneratorKind::Block,\n+                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                    ),\n+                ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n+                ExprKind::Closure(\n+                    capture_clause,\n+                    asyncness,\n+                    movability,\n+                    ref decl,\n+                    ref body,\n+                    fn_decl_span,\n+                ) => {\n+                    if let Async::Yes { closure_id, .. } = asyncness {\n+                        self.lower_expr_async_closure(\n+                            capture_clause,\n+                            closure_id,\n+                            decl,\n+                            body,\n+                            fn_decl_span,\n+                        )\n+                    } else {\n+                        self.lower_expr_closure(\n+                            capture_clause,\n+                            movability,\n+                            decl,\n+                            body,\n+                            fn_decl_span,\n+                        )\n+                    }\n+                }\n+                ExprKind::Block(ref blk, opt_label) => {\n+                    hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n+                }\n+                ExprKind::Assign(ref el, ref er, span) => {\n+                    hir::ExprKind::Assign(self.lower_expr(el), self.lower_expr(er), span)\n+                }\n+                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(op),\n+                    self.lower_expr(el),\n+                    self.lower_expr(er),\n+                ),\n+                ExprKind::Field(ref el, ident) => hir::ExprKind::Field(self.lower_expr(el), ident),\n+                ExprKind::Index(ref el, ref er) => {\n+                    hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n+                }\n+                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                    self.lower_expr_range_closed(e.span, e1, e2)\n+                }\n+                ExprKind::Range(ref e1, ref e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                }\n+                ExprKind::Path(ref qself, ref path) => {\n+                    let qpath = self.lower_qpath(\n+                        e.id,\n+                        qself,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    hir::ExprKind::Path(qpath)\n+                }\n+                ExprKind::Break(opt_label, ref opt_expr) => {\n+                    let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                }\n+                ExprKind::Continue(opt_label) => {\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                }\n+                ExprKind::Ret(ref e) => {\n+                    let e = e.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Ret(e)\n+                }\n+                ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n+                ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n+                ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n+                    let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n+                    hir::ExprKind::Struct(\n+                        self.arena.alloc(self.lower_qpath(\n+                            e.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        )),\n+                        self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n+                        maybe_expr,\n+                    )\n+                }\n+                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Err => hir::ExprKind::Err,\n+                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+                ExprKind::Paren(ref ex) => {\n+                    let mut ex = self.lower_expr_mut(ex);\n+                    // Include parens in span, but only if it is a super-span.\n+                    if e.span.contains(ex.span) {\n+                        ex.span = e.span;\n+                    }\n+                    // Merge attributes into the inner expression.\n+                    let mut attrs = e.attrs.clone();\n+                    attrs.extend::<Vec<_>>(ex.attrs.into());\n+                    ex.attrs = attrs;\n+                    return ex;\n+                }\n+\n+                // Desugar `ExprForLoop`\n+                // from: `[opt_ident]: for <pat> in <head> <body>`\n+                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                }\n+                ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n+            };\n+\n+            hir::Expr {\n+                hir_id: self.lower_node_id(e.id),\n+                kind,\n+                span: e.span,\n+                attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n+            }\n+        })\n+    }\n+\n+    fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {\n+        match u {\n+            UnOp::Deref => hir::UnOp::UnDeref,\n+            UnOp::Not => hir::UnOp::UnNot,\n+            UnOp::Neg => hir::UnOp::UnNeg,\n+        }\n+    }\n+\n+    fn lower_binop(&mut self, b: BinOp) -> hir::BinOp {\n+        Spanned {\n+            node: match b.node {\n+                BinOpKind::Add => hir::BinOpKind::Add,\n+                BinOpKind::Sub => hir::BinOpKind::Sub,\n+                BinOpKind::Mul => hir::BinOpKind::Mul,\n+                BinOpKind::Div => hir::BinOpKind::Div,\n+                BinOpKind::Rem => hir::BinOpKind::Rem,\n+                BinOpKind::And => hir::BinOpKind::And,\n+                BinOpKind::Or => hir::BinOpKind::Or,\n+                BinOpKind::BitXor => hir::BinOpKind::BitXor,\n+                BinOpKind::BitAnd => hir::BinOpKind::BitAnd,\n+                BinOpKind::BitOr => hir::BinOpKind::BitOr,\n+                BinOpKind::Shl => hir::BinOpKind::Shl,\n+                BinOpKind::Shr => hir::BinOpKind::Shr,\n+                BinOpKind::Eq => hir::BinOpKind::Eq,\n+                BinOpKind::Lt => hir::BinOpKind::Lt,\n+                BinOpKind::Le => hir::BinOpKind::Le,\n+                BinOpKind::Ne => hir::BinOpKind::Ne,\n+                BinOpKind::Ge => hir::BinOpKind::Ge,\n+                BinOpKind::Gt => hir::BinOpKind::Gt,\n+            },\n+            span: b.span,\n+        }\n+    }\n+\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n+    /// ```rust\n+    /// match scrutinee { pats => true, _ => false }\n+    /// ```\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind<'hir> {\n+        // If we got here, the `let` expression is not allowed.\n+\n+        if self.sess.opts.unstable_features.is_nightly_build() {\n+            self.sess\n+                .struct_span_err(span, \"`let` expressions are not supported here\")\n+                .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                .emit();\n+        } else {\n+            self.sess\n+                .struct_span_err(span, \"expected expression, found statement (`let`)\")\n+                .note(\"variable declaration using `let` is a statement\")\n+                .emit();\n+        }\n+\n+        // For better recovery, we emit:\n+        // ```\n+        // match scrutinee { pat => true, _ => false }\n+        // ```\n+        // While this doesn't fully match the user's intent, it has key advantages:\n+        // 1. We can avoid using `abort_if_errors`.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n+        // 4. The return type of the block is `bool` which seems like what the user wanted.\n+        let scrutinee = self.lower_expr(scrutinee);\n+        let then_arm = {\n+            let pat = self.lower_pat(pat);\n+            let expr = self.expr_bool(span, true);\n+            self.arm(pat, expr)\n+        };\n+        let else_arm = {\n+            let pat = self.pat_wild(span);\n+            let expr = self.expr_bool(span, false);\n+            self.arm(pat, expr)\n+        };\n+        hir::ExprKind::Match(\n+            scrutinee,\n+            arena_vec![self; then_arm, else_arm],\n+            hir::MatchSource::Normal,\n+        )\n+    }\n+\n+    fn lower_expr_if(\n+        &mut self,\n+        span: Span,\n+        cond: &Expr,\n+        then: &Block,\n+        else_opt: Option<&Expr>,\n+    ) -> hir::ExprKind<'hir> {\n+        // FIXME(#53667): handle lowering of && and parens.\n+\n+        // `_ => else_block` where `else_block` is `{}` if there's `None`:\n+        let else_pat = self.pat_wild(span);\n+        let (else_expr, contains_else_clause) = match else_opt {\n+            None => (self.expr_block_empty(span), false),\n+            Some(els) => (self.lower_expr(els), true),\n+        };\n+        let else_arm = self.arm(else_pat, else_expr);\n+\n+        // Handle then + scrutinee:\n+        let then_expr = self.lower_block_expr(then);\n+        let (then_pat, scrutinee, desugar) = match cond.kind {\n+            // `<pat> => <then>`:\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n+                let scrutinee = self.lower_expr(scrutinee);\n+                let pat = self.lower_pat(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n+            }\n+            // `true => <then>`:\n+            _ => {\n+                // Lower condition:\n+                let cond = self.lower_expr(cond);\n+                let span_block =\n+                    self.mark_span_with_reason(DesugaringKind::CondTemporary, cond.span, None);\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                // to preserve drop semantics since `if cond { ... }` does not\n+                // let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n+                let pat = self.pat_bool(span, true);\n+                (pat, cond, hir::MatchSource::IfDesugar { contains_else_clause })\n+            }\n+        };\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n+\n+        hir::ExprKind::Match(scrutinee, arena_vec![self; then_arm, else_arm], desugar)\n+    }\n+\n+    fn lower_expr_while_in_loop_scope(\n+        &mut self,\n+        span: Span,\n+        cond: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>,\n+    ) -> hir::ExprKind<'hir> {\n+        // FIXME(#53667): handle lowering of && and parens.\n+\n+        // Note that the block AND the condition are evaluated in the loop scope.\n+        // This is done to allow `break` from inside the condition of the loop.\n+\n+        // `_ => break`:\n+        let else_arm = {\n+            let else_pat = self.pat_wild(span);\n+            let else_expr = self.expr_break(span, ThinVec::new());\n+            self.arm(else_pat, else_expr)\n+        };\n+\n+        // Handle then + scrutinee:\n+        let then_expr = self.lower_block_expr(body);\n+        let (then_pat, scrutinee, desugar, source) = match cond.kind {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n+                // to:\n+                //\n+                //   [opt_ident]: loop {\n+                //     match <sub_expr> {\n+                //       <pat> => <body>,\n+                //       _ => break\n+                //     }\n+                //   }\n+                let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                let pat = self.lower_pat(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n+            }\n+            _ => {\n+                // We desugar: `'label: while $cond $body` into:\n+                //\n+                // ```\n+                // 'label: loop {\n+                //     match drop-temps { $cond } {\n+                //         true => $body,\n+                //         _ => break,\n+                //     }\n+                // }\n+                // ```\n+\n+                // Lower condition:\n+                let cond = self.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                let span_block =\n+                    self.mark_span_with_reason(DesugaringKind::CondTemporary, cond.span, None);\n+                // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                // to preserve drop semantics since `while cond { ... }` does not\n+                // let temporaries live outside of `cond`.\n+                let cond = self.expr_drop_temps(span_block, cond, ThinVec::new());\n+                // `true => <then>`:\n+                let pat = self.pat_bool(span, true);\n+                (pat, cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n+            }\n+        };\n+        let then_arm = self.arm(then_pat, self.arena.alloc(then_expr));\n+\n+        // `match <scrutinee> { ... }`\n+        let match_expr =\n+            self.expr_match(span, scrutinee, arena_vec![self; then_arm, else_arm], desugar);\n+\n+        // `[opt_ident]: loop { ... }`\n+        hir::ExprKind::Loop(self.block_expr(self.arena.alloc(match_expr)), opt_label, source)\n+    }\n+\n+    /// Desugar `try { <stmts>; <expr> }` into `{ <stmts>; ::std::ops::Try::from_ok(<expr>) }`,\n+    /// `try { <stmts>; }` into `{ <stmts>; ::std::ops::Try::from_ok(()) }`\n+    /// and save the block id to use it as a break target for desugaring of the `?` operator.\n+    fn lower_expr_try_block(&mut self, body: &Block) -> hir::ExprKind<'hir> {\n+        self.with_catch_scope(body.id, |this| {\n+            let mut block = this.lower_block_noalloc(body, true);\n+\n+            let try_span = this.mark_span_with_reason(\n+                DesugaringKind::TryBlock,\n+                body.span,\n+                this.allow_try_trait.clone(),\n+            );\n+\n+            // Final expression of the block (if present) or `()` with span at the end of block\n+            let tail_expr = block\n+                .expr\n+                .take()\n+                .unwrap_or_else(|| this.expr_unit(this.sess.source_map().end_point(try_span)));\n+\n+            let ok_wrapped_span =\n+                this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, None);\n+\n+            // `::std::ops::Try::from_ok($tail_expr)`\n+            block.expr = Some(this.wrap_in_try_constructor(\n+                hir::LangItem::TryFromOk,\n+                try_span,\n+                tail_expr,\n+                ok_wrapped_span,\n+            ));\n+\n+            hir::ExprKind::Block(this.arena.alloc(block), None)\n+        })\n+    }\n+\n+    fn wrap_in_try_constructor(\n+        &mut self,\n+        lang_item: hir::LangItem,\n+        method_span: Span,\n+        expr: &'hir hir::Expr<'hir>,\n+        overall_span: Span,\n+    ) -> &'hir hir::Expr<'hir> {\n+        let constructor =\n+            self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, ThinVec::new()));\n+        self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n+    }\n+\n+    fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n+        hir::Arm {\n+            hir_id: self.next_id(),\n+            attrs: self.lower_attrs(&arm.attrs),\n+            pat: self.lower_pat(&arm.pat),\n+            guard: match arm.guard {\n+                Some(ref x) => Some(hir::Guard::If(self.lower_expr(x))),\n+                _ => None,\n+            },\n+            body: self.lower_expr(&arm.body),\n+            span: arm.span,\n+        }\n+    }\n+\n+    /// Lower an `async` construct to a generator that is then wrapped so it implements `Future`.\n+    ///\n+    /// This results in:\n+    ///\n+    /// ```text\n+    /// std::future::from_generator(static move? |_task_context| -> <ret_ty> {\n+    ///     <body>\n+    /// })\n+    /// ```\n+    pub(super) fn make_async_expr(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_node_id: NodeId,\n+        ret_ty: Option<AstP<Ty>>,\n+        span: Span,\n+        async_gen_kind: hir::AsyncGeneratorKind,\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n+    ) -> hir::ExprKind<'hir> {\n+        let output = match ret_ty {\n+            Some(ty) => hir::FnRetTy::Return(self.lower_ty(&ty, ImplTraitContext::disallowed())),\n+            None => hir::FnRetTy::DefaultReturn(span),\n+        };\n+\n+        // Resume argument type. We let the compiler infer this to simplify the lowering. It is\n+        // fully constrained by `future::from_generator`.\n+        let input_ty = hir::Ty { hir_id: self.next_id(), kind: hir::TyKind::Infer, span };\n+\n+        // The closure/generator `FnDecl` takes a single (resume) argument of type `input_ty`.\n+        let decl = self.arena.alloc(hir::FnDecl {\n+            inputs: arena_vec![self; input_ty],\n+            output,\n+            c_variadic: false,\n+            implicit_self: hir::ImplicitSelfKind::None,\n+        });\n+\n+        // Lower the argument pattern/ident. The ident is used again in the `.await` lowering.\n+        let (pat, task_context_hid) = self.pat_ident_binding_mode(\n+            span,\n+            Ident::with_dummy_span(sym::_task_context),\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let param = hir::Param { attrs: &[], hir_id: self.next_id(), pat, ty_span: span, span };\n+        let params = arena_vec![self; param];\n+\n+        let body_id = self.lower_body(move |this| {\n+            this.generator_kind = Some(hir::GeneratorKind::Async(async_gen_kind));\n+\n+            let old_ctx = this.task_context;\n+            this.task_context = Some(task_context_hid);\n+            let res = body(this);\n+            this.task_context = old_ctx;\n+            (params, res)\n+        });\n+\n+        // `static |_task_context| -> <ret_ty> { body }`:\n+        let generator_kind = hir::ExprKind::Closure(\n+            capture_clause,\n+            decl,\n+            body_id,\n+            span,\n+            Some(hir::Movability::Static),\n+        );\n+        let generator = hir::Expr {\n+            hir_id: self.lower_node_id(closure_node_id),\n+            kind: generator_kind,\n+            span,\n+            attrs: ThinVec::new(),\n+        };\n+\n+        // `future::from_generator`:\n+        let unstable_span =\n+            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n+        let gen_future =\n+            self.expr_lang_item_path(unstable_span, hir::LangItem::FromGenerator, ThinVec::new());\n+\n+        // `future::from_generator(generator)`:\n+        hir::ExprKind::Call(self.arena.alloc(gen_future), arena_vec![self; generator])\n+    }\n+\n+    /// Desugar `<expr>.await` into:\n+    /// ```rust\n+    /// match <expr> {\n+    ///     mut pinned => loop {\n+    ///         match unsafe { ::std::future::Future::poll(\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned),\n+    ///             ::std::future::get_context(task_context),\n+    ///         ) } {\n+    ///             ::std::task::Poll::Ready(result) => break result,\n+    ///             ::std::task::Poll::Pending => {}\n+    ///         }\n+    ///         task_context = yield ();\n+    ///     }\n+    /// }\n+    /// ```\n+    fn lower_expr_await(&mut self, await_span: Span, expr: &Expr) -> hir::ExprKind<'hir> {\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async(_)) => {}\n+            Some(hir::GeneratorKind::Gen) | None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+            }\n+        }\n+        let span = self.mark_span_with_reason(DesugaringKind::Await, await_span, None);\n+        let gen_future_span = self.mark_span_with_reason(\n+            DesugaringKind::Await,\n+            await_span,\n+            self.allow_gen_future.clone(),\n+        );\n+        let expr = self.lower_expr(expr);\n+\n+        let pinned_ident = Ident::with_dummy_span(sym::pinned);\n+        let (pinned_pat, pinned_pat_hid) =\n+            self.pat_ident_binding_mode(span, pinned_ident, hir::BindingAnnotation::Mutable);\n+\n+        let task_context_ident = Ident::with_dummy_span(sym::_task_context);\n+\n+        // unsafe {\n+        //     ::std::future::Future::poll(\n+        //         ::std::pin::Pin::new_unchecked(&mut pinned),\n+        //         ::std::future::get_context(task_context),\n+        //     )\n+        // }\n+        let poll_expr = {\n+            let pinned = self.expr_ident(span, pinned_ident, pinned_pat_hid);\n+            let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let task_context = if let Some(task_context_hid) = self.task_context {\n+                self.expr_ident_mut(span, task_context_ident, task_context_hid)\n+            } else {\n+                // Use of `await` outside of an async context, we cannot use `task_context` here.\n+                self.expr_err(span)\n+            };\n+            let new_unchecked = self.expr_call_lang_item_fn_mut(\n+                span,\n+                hir::LangItem::PinNewUnchecked,\n+                arena_vec![self; ref_mut_pinned],\n+            );\n+            let get_context = self.expr_call_lang_item_fn_mut(\n+                gen_future_span,\n+                hir::LangItem::GetContext,\n+                arena_vec![self; task_context],\n+            );\n+            let call = self.expr_call_lang_item_fn(\n+                span,\n+                hir::LangItem::FuturePoll,\n+                arena_vec![self; new_unchecked, get_context],\n+            );\n+            self.arena.alloc(self.expr_unsafe(call))\n+        };\n+\n+        // `::std::task::Poll::Ready(result) => break result`\n+        let loop_node_id = self.resolver.next_node_id();\n+        let loop_hir_id = self.lower_node_id(loop_node_id);\n+        let ready_arm = {\n+            let x_ident = Ident::with_dummy_span(sym::result);\n+            let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n+            let x_expr = self.expr_ident(span, x_ident, x_pat_hid);\n+            let ready_field = self.single_pat_field(span, x_pat);\n+            let ready_pat = self.pat_lang_item_variant(span, hir::LangItem::PollReady, ready_field);\n+            let break_x = self.with_loop_scope(loop_node_id, move |this| {\n+                let expr_break =\n+                    hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n+                this.arena.alloc(this.expr(await_span, expr_break, ThinVec::new()))\n+            });\n+            self.arm(ready_pat, break_x)\n+        };\n+\n+        // `::std::task::Poll::Pending => {}`\n+        let pending_arm = {\n+            let pending_pat = self.pat_lang_item_variant(span, hir::LangItem::PollPending, &[]);\n+            let empty_block = self.expr_block_empty(span);\n+            self.arm(pending_pat, empty_block)\n+        };\n+\n+        let inner_match_stmt = {\n+            let match_expr = self.expr_match(\n+                span,\n+                poll_expr,\n+                arena_vec![self; ready_arm, pending_arm],\n+                hir::MatchSource::AwaitDesugar,\n+            );\n+            self.stmt_expr(span, match_expr)\n+        };\n+\n+        // task_context = yield ();\n+        let yield_stmt = {\n+            let unit = self.expr_unit(span);\n+            let yield_expr = self.expr(\n+                span,\n+                hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr.hir_id) }),\n+                ThinVec::new(),\n+            );\n+            let yield_expr = self.arena.alloc(yield_expr);\n+\n+            if let Some(task_context_hid) = self.task_context {\n+                let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, span), AttrVec::new());\n+                self.stmt_expr(span, assign)\n+            } else {\n+                // Use of `await` outside of an async context. Return `yield_expr` so that we can\n+                // proceed with type checking.\n+                self.stmt(span, hir::StmtKind::Semi(yield_expr))\n+            }\n+        };\n+\n+        let loop_block = self.block_all(span, arena_vec![self; inner_match_stmt, yield_stmt], None);\n+\n+        // loop { .. }\n+        let loop_expr = self.arena.alloc(hir::Expr {\n+            hir_id: loop_hir_id,\n+            kind: hir::ExprKind::Loop(loop_block, None, hir::LoopSource::Loop),\n+            span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        // mut pinned => loop { ... }\n+        let pinned_arm = self.arm(pinned_pat, loop_expr);\n+\n+        // match <expr> {\n+        //     mut pinned => loop { .. }\n+        // }\n+        hir::ExprKind::Match(expr, arena_vec![self; pinned_arm], hir::MatchSource::AwaitDesugar)\n+    }\n+\n+    fn lower_expr_closure(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        movability: Movability,\n+        decl: &FnDecl,\n+        body: &Expr,\n+        fn_decl_span: Span,\n+    ) -> hir::ExprKind<'hir> {\n+        // Lower outside new scope to preserve `is_in_loop_condition`.\n+        let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+\n+        self.with_new_scopes(move |this| {\n+            let prev = this.current_item;\n+            this.current_item = Some(fn_decl_span);\n+            let mut generator_kind = None;\n+            let body_id = this.lower_fn_body(decl, |this| {\n+                let e = this.lower_expr_mut(body);\n+                generator_kind = this.generator_kind;\n+                e\n+            });\n+            let generator_option =\n+                this.generator_movability_for_fn(&decl, fn_decl_span, generator_kind, movability);\n+            this.current_item = prev;\n+            hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, generator_option)\n+        })\n+    }\n+\n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::Movability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) => {\n+                if decl.inputs.len() > 1 {\n+                    struct_span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n+                    )\n+                    .emit();\n+                }\n+                Some(movability)\n+            }\n+            Some(hir::GeneratorKind::Async(_)) => {\n+                panic!(\"non-`async` closure body turned `async` during lowering\");\n+            }\n+            None => {\n+                if movability == Movability::Static {\n+                    struct_span_err!(self.sess, fn_decl_span, E0697, \"closures cannot be static\")\n+                        .emit();\n+                }\n+                None\n+            }\n+        }\n+    }\n+\n+    fn lower_expr_async_closure(\n+        &mut self,\n+        capture_clause: CaptureBy,\n+        closure_id: NodeId,\n+        decl: &FnDecl,\n+        body: &Expr,\n+        fn_decl_span: Span,\n+    ) -> hir::ExprKind<'hir> {\n+        let outer_decl =\n+            FnDecl { inputs: decl.inputs.clone(), output: FnRetTy::Default(fn_decl_span) };\n+        // We need to lower the declaration outside the new scope, because we\n+        // have to conserve the state of being inside a loop condition for the\n+        // closure argument types.\n+        let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+\n+        self.with_new_scopes(move |this| {\n+            // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n+            if capture_clause == CaptureBy::Ref && !decl.inputs.is_empty() {\n+                struct_span_err!(\n+                    this.sess,\n+                    fn_decl_span,\n+                    E0708,\n+                    \"`async` non-`move` closures with parameters are not currently supported\",\n+                )\n+                .help(\n+                    \"consider using `let` statements to manually capture \\\n+                    variables by reference before entering an `async move` closure\",\n+                )\n+                .emit();\n+            }\n+\n+            // Transform `async |x: u8| -> X { ... }` into\n+            // `|x: u8| future_from_generator(|| -> X { ... })`.\n+            let body_id = this.lower_fn_body(&outer_decl, |this| {\n+                let async_ret_ty =\n+                    if let FnRetTy::Ty(ty) = &decl.output { Some(ty.clone()) } else { None };\n+                let async_body = this.make_async_expr(\n+                    capture_clause,\n+                    closure_id,\n+                    async_ret_ty,\n+                    body.span,\n+                    hir::AsyncGeneratorKind::Closure,\n+                    |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n+                );\n+                this.expr(fn_decl_span, async_body, ThinVec::new())\n+            });\n+            hir::ExprKind::Closure(capture_clause, fn_decl, body_id, fn_decl_span, None)\n+        })\n+    }\n+\n+    /// Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n+    fn lower_expr_range_closed(&mut self, span: Span, e1: &Expr, e2: &Expr) -> hir::ExprKind<'hir> {\n+        let e1 = self.lower_expr_mut(e1);\n+        let e2 = self.lower_expr_mut(e2);\n+        let fn_path = hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, span);\n+        let fn_expr =\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n+    }\n+\n+    fn lower_expr_range(\n+        &mut self,\n+        span: Span,\n+        e1: Option<&Expr>,\n+        e2: Option<&Expr>,\n+        lims: RangeLimits,\n+    ) -> hir::ExprKind<'hir> {\n+        use rustc_ast::RangeLimits::*;\n+\n+        let lang_item = match (e1, e2, lims) {\n+            (None, None, HalfOpen) => hir::LangItem::RangeFull,\n+            (Some(..), None, HalfOpen) => hir::LangItem::RangeFrom,\n+            (None, Some(..), HalfOpen) => hir::LangItem::RangeTo,\n+            (Some(..), Some(..), HalfOpen) => hir::LangItem::Range,\n+            (None, Some(..), Closed) => hir::LangItem::RangeToInclusive,\n+            (Some(..), Some(..), Closed) => unreachable!(),\n+            (_, None, Closed) => {\n+                self.diagnostic().span_fatal(span, \"inclusive range with no end\").raise()\n+            }\n+        };\n+\n+        let fields = self.arena.alloc_from_iter(\n+            e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e))).map(|(s, e)| {\n+                let expr = self.lower_expr(&e);\n+                let ident = Ident::new(Symbol::intern(s), e.span);\n+                self.field(ident, expr, e.span)\n+            }),\n+        );\n+\n+        hir::ExprKind::Struct(self.arena.alloc(hir::QPath::LangItem(lang_item, span)), fields, None)\n+    }\n+\n+    fn lower_loop_destination(&mut self, destination: Option<(NodeId, Label)>) -> hir::Destination {\n+        let target_id = match destination {\n+            Some((id, _)) => {\n+                if let Some(loop_id) = self.resolver.get_label_res(id) {\n+                    Ok(self.lower_node_id(loop_id))\n+                } else {\n+                    Err(hir::LoopIdError::UnresolvedLabel)\n+                }\n+            }\n+            None => self\n+                .loop_scopes\n+                .last()\n+                .cloned()\n+                .map(|id| Ok(self.lower_node_id(id)))\n+                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope)),\n+        };\n+        hir::Destination { label: destination.map(|(_, label)| label), target_id }\n+    }\n+\n+    fn lower_jump_destination(&mut self, id: NodeId, opt_label: Option<Label>) -> hir::Destination {\n+        if self.is_in_loop_condition && opt_label.is_none() {\n+            hir::Destination {\n+                label: None,\n+                target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition),\n+            }\n+        } else {\n+            self.lower_loop_destination(opt_label.map(|label| (id, label)))\n+        }\n+    }\n+\n+    fn with_catch_scope<T>(&mut self, catch_id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        let len = self.catch_scopes.len();\n+        self.catch_scopes.push(catch_id);\n+\n+        let result = f(self);\n+        assert_eq!(\n+            len + 1,\n+            self.catch_scopes.len(),\n+            \"catch scopes should be added and removed in stack order\"\n+        );\n+\n+        self.catch_scopes.pop().unwrap();\n+\n+        result\n+    }\n+\n+    fn with_loop_scope<T>(&mut self, loop_id: NodeId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        // We're no longer in the base loop's condition; we're in another loop.\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = false;\n+\n+        let len = self.loop_scopes.len();\n+        self.loop_scopes.push(loop_id);\n+\n+        let result = f(self);\n+        assert_eq!(\n+            len + 1,\n+            self.loop_scopes.len(),\n+            \"loop scopes should be added and removed in stack order\"\n+        );\n+\n+        self.loop_scopes.pop().unwrap();\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn with_loop_condition_scope<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n+        let was_in_loop_condition = self.is_in_loop_condition;\n+        self.is_in_loop_condition = true;\n+\n+        let result = f(self);\n+\n+        self.is_in_loop_condition = was_in_loop_condition;\n+\n+        result\n+    }\n+\n+    fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n+        if self.sess.asm_arch.is_none() {\n+            struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n+        }\n+        if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n+            && !matches!(\n+                self.sess.asm_arch,\n+                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n+            )\n+        {\n+            self.sess\n+                .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n+                .emit();\n+        }\n+\n+        // Lower operands to HIR, filter_map skips any operands with invalid\n+        // register classes.\n+        let sess = self.sess;\n+        let operands: Vec<_> = asm\n+            .operands\n+            .iter()\n+            .filter_map(|(op, op_sp)| {\n+                let lower_reg = |reg| {\n+                    Some(match reg {\n+                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+                            asm::InlineAsmReg::parse(\n+                                sess.asm_arch?,\n+                                |feature| sess.target_features.contains(&Symbol::intern(feature)),\n+                                &sess.target.target,\n+                                s,\n+                            )\n+                            .map_err(|e| {\n+                                let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                            })\n+                            .ok()?,\n+                        ),\n+                        InlineAsmRegOrRegClass::RegClass(s) => {\n+                            asm::InlineAsmRegOrRegClass::RegClass(\n+                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n+                                    .map_err(|e| {\n+                                        let msg = format!(\n+                                            \"invalid register class `{}`: {}\",\n+                                            s.as_str(),\n+                                            e\n+                                        );\n+                                        sess.struct_span_err(*op_sp, &msg).emit();\n+                                    })\n+                                    .ok()?,\n+                            )\n+                        }\n+                    })\n+                };\n+\n+                // lower_reg is executed last because we need to lower all\n+                // sub-expressions even if we throw them away later.\n+                let op = match *op {\n+                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        expr: self.lower_expr_mut(expr),\n+                        reg: lower_reg(reg)?,\n+                    },\n+                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        late,\n+                        expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                        reg: lower_reg(reg)?,\n+                    },\n+                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n+                        hir::InlineAsmOperand::InOut {\n+                            late,\n+                            expr: self.lower_expr_mut(expr),\n+                            reg: lower_reg(reg)?,\n+                        }\n+                    }\n+                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                        hir::InlineAsmOperand::SplitInOut {\n+                            late,\n+                            in_expr: self.lower_expr_mut(in_expr),\n+                            out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n+                            reg: lower_reg(reg)?,\n+                        }\n+                    }\n+                    InlineAsmOperand::Const { ref expr } => {\n+                        hir::InlineAsmOperand::Const { expr: self.lower_expr_mut(expr) }\n+                    }\n+                    InlineAsmOperand::Sym { ref expr } => {\n+                        hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n+                    }\n+                };\n+                Some(op)\n+            })\n+            .collect();\n+\n+        // Stop if there were any errors when lowering the register classes\n+        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n+            return hir::ExprKind::Err;\n+        }\n+\n+        // Validate template modifiers against the register classes for the operands\n+        let asm_arch = sess.asm_arch.unwrap();\n+        for p in &asm.template {\n+            if let InlineAsmTemplatePiece::Placeholder {\n+                operand_idx,\n+                modifier: Some(modifier),\n+                span: placeholder_span,\n+            } = *p\n+            {\n+                let op_sp = asm.operands[operand_idx].1;\n+                match &operands[operand_idx] {\n+                    hir::InlineAsmOperand::In { reg, .. }\n+                    | hir::InlineAsmOperand::Out { reg, .. }\n+                    | hir::InlineAsmOperand::InOut { reg, .. }\n+                    | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n+                        let class = reg.reg_class();\n+                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if !valid_modifiers.contains(&modifier) {\n+                            let mut err = sess.struct_span_err(\n+                                placeholder_span,\n+                                \"invalid asm template modifier for this register class\",\n+                            );\n+                            err.span_label(placeholder_span, \"template modifier\");\n+                            err.span_label(op_sp, \"argument\");\n+                            if !valid_modifiers.is_empty() {\n+                                let mut mods = format!(\"`{}`\", valid_modifiers[0]);\n+                                for m in &valid_modifiers[1..] {\n+                                    let _ = write!(mods, \", `{}`\", m);\n+                                }\n+                                err.note(&format!(\n+                                    \"the `{}` register class supports \\\n+                                     the following template modifiers: {}\",\n+                                    class.name(),\n+                                    mods\n+                                ));\n+                            } else {\n+                                err.note(&format!(\n+                                    \"the `{}` register class does not support template modifiers\",\n+                                    class.name()\n+                                ));\n+                            }\n+                            err.emit();\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::Const { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `const` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                    hir::InlineAsmOperand::Sym { .. } => {\n+                        let mut err = sess.struct_span_err(\n+                            placeholder_span,\n+                            \"asm template modifiers are not allowed for `sym` arguments\",\n+                        );\n+                        err.span_label(placeholder_span, \"template modifier\");\n+                        err.span_label(op_sp, \"argument\");\n+                        err.emit();\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut used_input_regs = FxHashMap::default();\n+        let mut used_output_regs = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            let op_sp = asm.operands[idx].1;\n+            if let Some(reg) = op.reg() {\n+                // Validate register classes against currently enabled target\n+                // features. We check that at least one type is available for\n+                // the current target.\n+                let reg_class = reg.reg_class();\n+                let mut required_features = vec![];\n+                for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                    if let Some(feature) = feature {\n+                        if self.sess.target_features.contains(&Symbol::intern(feature)) {\n+                            required_features.clear();\n+                            break;\n+                        } else {\n+                            required_features.push(feature);\n+                        }\n+                    } else {\n+                        required_features.clear();\n+                        break;\n+                    }\n+                }\n+                required_features.sort();\n+                required_features.dedup();\n+                match &required_features[..] {\n+                    [] => {}\n+                    [feature] => {\n+                        let msg = format!(\n+                            \"register class `{}` requires the `{}` target feature\",\n+                            reg_class.name(),\n+                            feature\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                    features => {\n+                        let msg = format!(\n+                            \"register class `{}` requires at least one target feature: {}\",\n+                            reg_class.name(),\n+                            features.join(\", \")\n+                        );\n+                        sess.struct_span_err(op_sp, &msg).emit();\n+                    }\n+                }\n+\n+                // Check for conflicts between explicit register operands.\n+                if let asm::InlineAsmRegOrRegClass::Reg(reg) = reg {\n+                    let (input, output) = match op {\n+                        hir::InlineAsmOperand::In { .. } => (true, false),\n+                        // Late output do not conflict with inputs, but normal outputs do\n+                        hir::InlineAsmOperand::Out { late, .. } => (!late, true),\n+                        hir::InlineAsmOperand::InOut { .. }\n+                        | hir::InlineAsmOperand::SplitInOut { .. } => (true, true),\n+                        hir::InlineAsmOperand::Const { .. } | hir::InlineAsmOperand::Sym { .. } => {\n+                            unreachable!()\n+                        }\n+                    };\n+\n+                    // Flag to output the error only once per operand\n+                    let mut skip = false;\n+                    reg.overlapping_regs(|r| {\n+                        let mut check = |used_regs: &mut FxHashMap<asm::InlineAsmReg, usize>,\n+                                         input| {\n+                            match used_regs.entry(r) {\n+                                Entry::Occupied(o) => {\n+                                    if !skip {\n+                                        skip = true;\n+\n+                                        let idx2 = *o.get();\n+                                        let op2 = &operands[idx2];\n+                                        let op_sp2 = asm.operands[idx2].1;\n+                                        let reg2 = match op2.reg() {\n+                                            Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                            _ => unreachable!(),\n+                                        };\n+\n+                                        let msg = format!(\n+                                            \"register `{}` conflicts with register `{}`\",\n+                                            reg.name(),\n+                                            reg2.name()\n+                                        );\n+                                        let mut err = sess.struct_span_err(op_sp, &msg);\n+                                        err.span_label(\n+                                            op_sp,\n+                                            &format!(\"register `{}`\", reg.name()),\n+                                        );\n+                                        err.span_label(\n+                                            op_sp2,\n+                                            &format!(\"register `{}`\", reg2.name()),\n+                                        );\n+\n+                                        match (op, op2) {\n+                                            (\n+                                                hir::InlineAsmOperand::In { .. },\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                            )\n+                                            | (\n+                                                hir::InlineAsmOperand::Out { late, .. },\n+                                                hir::InlineAsmOperand::In { .. },\n+                                            ) => {\n+                                                assert!(!*late);\n+                                                let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                                let msg = \"use `lateout` instead of \\\n+                                                     `out` to avoid conflict\";\n+                                                err.span_help(out_op_sp, msg);\n+                                            }\n+                                            _ => {}\n+                                        }\n+\n+                                        err.emit();\n+                                    }\n+                                }\n+                                Entry::Vacant(v) => {\n+                                    v.insert(idx);\n+                                }\n+                            }\n+                        };\n+                        if input {\n+                            check(&mut used_input_regs, true);\n+                        }\n+                        if output {\n+                            check(&mut used_output_regs, false);\n+                        }\n+                    });\n+                }\n+            }\n+        }\n+\n+        let operands = self.arena.alloc_from_iter(operands);\n+        let template = self.arena.alloc_from_iter(asm.template.iter().cloned());\n+        let line_spans = self.arena.alloc_slice(&asm.line_spans[..]);\n+        let hir_asm = hir::InlineAsm { template, operands, options: asm.options, line_spans };\n+        hir::ExprKind::InlineAsm(self.arena.alloc(hir_asm))\n+    }\n+\n+    fn lower_expr_llvm_asm(&mut self, asm: &LlvmInlineAsm) -> hir::ExprKind<'hir> {\n+        let inner = hir::LlvmInlineAsmInner {\n+            inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n+            outputs: asm\n+                .outputs\n+                .iter()\n+                .map(|out| hir::LlvmInlineAsmOutput {\n+                    constraint: out.constraint,\n+                    is_rw: out.is_rw,\n+                    is_indirect: out.is_indirect,\n+                    span: out.expr.span,\n+                })\n+                .collect(),\n+            asm: asm.asm,\n+            asm_str_style: asm.asm_str_style,\n+            clobbers: asm.clobbers.clone(),\n+            volatile: asm.volatile,\n+            alignstack: asm.alignstack,\n+            dialect: asm.dialect,\n+        };\n+        let hir_asm = hir::LlvmInlineAsm {\n+            inner,\n+            inputs_exprs: self.arena.alloc_from_iter(\n+                asm.inputs.iter().map(|&(_, ref input)| self.lower_expr_mut(input)),\n+            ),\n+            outputs_exprs: self\n+                .arena\n+                .alloc_from_iter(asm.outputs.iter().map(|out| self.lower_expr_mut(&out.expr))),\n+        };\n+        hir::ExprKind::LlvmInlineAsm(self.arena.alloc(hir_asm))\n+    }\n+\n+    fn lower_field(&mut self, f: &Field) -> hir::Field<'hir> {\n+        hir::Field {\n+            hir_id: self.next_id(),\n+            ident: f.ident,\n+            expr: self.lower_expr(&f.expr),\n+            span: f.span,\n+            is_shorthand: f.is_shorthand,\n+        }\n+    }\n+\n+    fn lower_expr_yield(&mut self, span: Span, opt_expr: Option<&Expr>) -> hir::ExprKind<'hir> {\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Gen) => {}\n+            Some(hir::GeneratorKind::Async(_)) => {\n+                struct_span_err!(\n+                    self.sess,\n+                    span,\n+                    E0727,\n+                    \"`async` generators are not yet supported\"\n+                )\n+                .emit();\n+            }\n+            None => self.generator_kind = Some(hir::GeneratorKind::Gen),\n+        }\n+\n+        let expr =\n+            opt_expr.as_ref().map(|x| self.lower_expr(x)).unwrap_or_else(|| self.expr_unit(span));\n+\n+        hir::ExprKind::Yield(expr, hir::YieldSource::Yield)\n+    }\n+\n+    /// Desugar `ExprForLoop` from: `[opt_ident]: for <pat> in <head> <body>` into:\n+    /// ```rust\n+    /// {\n+    ///     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+    ///         mut iter => {\n+    ///             [opt_ident]: loop {\n+    ///                 let mut __next;\n+    ///                 match ::std::iter::Iterator::next(&mut iter) {\n+    ///                     ::std::option::Option::Some(val) => __next = val,\n+    ///                     ::std::option::Option::None => break\n+    ///                 };\n+    ///                 let <pat> = __next;\n+    ///                 StmtKind::Expr(<body>);\n+    ///             }\n+    ///         }\n+    ///     };\n+    ///     result\n+    /// }\n+    /// ```\n+    fn lower_expr_for(\n+        &mut self,\n+        e: &Expr,\n+        pat: &Pat,\n+        head: &Expr,\n+        body: &Block,\n+        opt_label: Option<Label>,\n+    ) -> hir::Expr<'hir> {\n+        let orig_head_span = head.span;\n+        // expand <head>\n+        let mut head = self.lower_expr_mut(head);\n+        let desugared_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::Head),\n+            orig_head_span,\n+            None,\n+        );\n+        head.span = desugared_span;\n+\n+        let iter = Ident::with_dummy_span(sym::iter);\n+\n+        let next_ident = Ident::with_dummy_span(sym::__next);\n+        let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n+            desugared_span,\n+            next_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n+\n+        // `::std::option::Option::Some(val) => __next = val`\n+        let pat_arm = {\n+            let val_ident = Ident::with_dummy_span(sym::val);\n+            let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n+            let val_expr = self.expr_ident(pat.span, val_ident, val_pat_hid);\n+            let next_expr = self.expr_ident(pat.span, next_ident, next_pat_hid);\n+            let assign = self.arena.alloc(self.expr(\n+                pat.span,\n+                hir::ExprKind::Assign(next_expr, val_expr, pat.span),\n+                ThinVec::new(),\n+            ));\n+            let some_pat = self.pat_some(pat.span, val_pat);\n+            self.arm(some_pat, assign)\n+        };\n+\n+        // `::std::option::Option::None => break`\n+        let break_arm = {\n+            let break_expr =\n+                self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n+            let pat = self.pat_none(e.span);\n+            self.arm(pat, break_expr)\n+        };\n+\n+        // `mut iter`\n+        let (iter_pat, iter_pat_nid) =\n+            self.pat_ident_binding_mode(desugared_span, iter, hir::BindingAnnotation::Mutable);\n+\n+        // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+        let match_expr = {\n+            let iter = self.expr_ident(desugared_span, iter, iter_pat_nid);\n+            let ref_mut_iter = self.expr_mut_addr_of(desugared_span, iter);\n+            let next_expr = self.expr_call_lang_item_fn(\n+                desugared_span,\n+                hir::LangItem::IteratorNext,\n+                arena_vec![self; ref_mut_iter],\n+            );\n+            let arms = arena_vec![self; pat_arm, break_arm];\n+\n+            self.expr_match(desugared_span, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+        };\n+        let match_stmt = self.stmt_expr(desugared_span, match_expr);\n+\n+        let next_expr = self.expr_ident(desugared_span, next_ident, next_pat_hid);\n+\n+        // `let mut __next`\n+        let next_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            desugared_span,\n+            None,\n+            next_pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n+\n+        // `let <pat> = __next`\n+        let pat = self.lower_pat(pat);\n+        let pat_let = self.stmt_let_pat(\n+            ThinVec::new(),\n+            desugared_span,\n+            Some(next_expr),\n+            pat,\n+            hir::LocalSource::ForLoopDesugar,\n+        );\n+\n+        let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n+        let body_expr = self.expr_block(body_block, ThinVec::new());\n+        let body_stmt = self.stmt_expr(body.span, body_expr);\n+\n+        let loop_block = self.block_all(\n+            e.span,\n+            arena_vec![self; next_let, match_stmt, pat_let, body_stmt],\n+            None,\n+        );\n+\n+        // `[opt_ident]: loop { ... }`\n+        let kind = hir::ExprKind::Loop(loop_block, opt_label, hir::LoopSource::ForLoop);\n+        let loop_expr = self.arena.alloc(hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            kind,\n+            span: e.span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        // `mut iter => { ... }`\n+        let iter_arm = self.arm(iter_pat, loop_expr);\n+\n+        let into_iter_span = self.mark_span_with_reason(\n+            DesugaringKind::ForLoop(ForLoopLoc::IntoIter),\n+            orig_head_span,\n+            None,\n+        );\n+\n+        // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+        let into_iter_expr = {\n+            self.expr_call_lang_item_fn(\n+                into_iter_span,\n+                hir::LangItem::IntoIterIntoIter,\n+                arena_vec![self; head],\n+            )\n+        };\n+\n+        let match_expr = self.arena.alloc(self.expr_match(\n+            desugared_span,\n+            into_iter_expr,\n+            arena_vec![self; iter_arm],\n+            hir::MatchSource::ForLoopDesugar,\n+        ));\n+\n+        // This is effectively `{ let _result = ...; _result }`.\n+        // The construct was introduced in #21984 and is necessary to make sure that\n+        // temporaries in the `head` expression are dropped and do not leak to the\n+        // surrounding scope of the `match` since the `match` is not a terminating scope.\n+        //\n+        // Also, add the attributes to the outer returned expr node.\n+        self.expr_drop_temps_mut(desugared_span, match_expr, e.attrs.clone())\n+    }\n+\n+    /// Desugar `ExprKind::Try` from: `<expr>?` into:\n+    /// ```rust\n+    /// match Try::into_result(<expr>) {\n+    ///     Ok(val) => #[allow(unreachable_code)] val,\n+    ///     Err(err) => #[allow(unreachable_code)]\n+    ///                 // If there is an enclosing `try {...}`:\n+    ///                 break 'catch_target Try::from_error(From::from(err)),\n+    ///                 // Otherwise:\n+    ///                 return Try::from_error(From::from(err)),\n+    /// }\n+    /// ```\n+    fn lower_expr_try(&mut self, span: Span, sub_expr: &Expr) -> hir::ExprKind<'hir> {\n+        let unstable_span = self.mark_span_with_reason(\n+            DesugaringKind::QuestionMark,\n+            span,\n+            self.allow_try_trait.clone(),\n+        );\n+        let try_span = self.sess.source_map().end_point(span);\n+        let try_span = self.mark_span_with_reason(\n+            DesugaringKind::QuestionMark,\n+            try_span,\n+            self.allow_try_trait.clone(),\n+        );\n+\n+        // `Try::into_result(<expr>)`\n+        let scrutinee = {\n+            // expand <expr>\n+            let sub_expr = self.lower_expr_mut(sub_expr);\n+\n+            self.expr_call_lang_item_fn(\n+                unstable_span,\n+                hir::LangItem::TryIntoResult,\n+                arena_vec![self; sub_expr],\n+            )\n+        };\n+\n+        // `#[allow(unreachable_code)]`\n+        let attr = {\n+            // `allow(unreachable_code)`\n+            let allow = {\n+                let allow_ident = Ident::new(sym::allow, span);\n+                let uc_ident = Ident::new(sym::unreachable_code, span);\n+                let uc_nested = attr::mk_nested_word_item(uc_ident);\n+                attr::mk_list_item(allow_ident, vec![uc_nested])\n+            };\n+            attr::mk_attr_outer(allow)\n+        };\n+        let attrs = vec![attr];\n+\n+        // `Ok(val) => #[allow(unreachable_code)] val,`\n+        let ok_arm = {\n+            let val_ident = Ident::with_dummy_span(sym::val);\n+            let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n+            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n+                span,\n+                val_ident,\n+                val_pat_nid,\n+                ThinVec::from(attrs.clone()),\n+            ));\n+            let ok_pat = self.pat_ok(span, val_pat);\n+            self.arm(ok_pat, val_expr)\n+        };\n+\n+        // `Err(err) => #[allow(unreachable_code)]\n+        //              return Try::from_error(From::from(err)),`\n+        let err_arm = {\n+            let err_ident = Ident::with_dummy_span(sym::err);\n+            let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n+            let from_expr = {\n+                let err_expr = self.expr_ident_mut(try_span, err_ident, err_local_nid);\n+                self.expr_call_lang_item_fn(\n+                    try_span,\n+                    hir::LangItem::FromFrom,\n+                    arena_vec![self; err_expr],\n+                )\n+            };\n+            let from_err_expr = self.wrap_in_try_constructor(\n+                hir::LangItem::TryFromError,\n+                unstable_span,\n+                from_expr,\n+                try_span,\n+            );\n+            let thin_attrs = ThinVec::from(attrs);\n+            let catch_scope = self.catch_scopes.last().copied();\n+            let ret_expr = if let Some(catch_node) = catch_scope {\n+                let target_id = Ok(self.lower_node_id(catch_node));\n+                self.arena.alloc(self.expr(\n+                    try_span,\n+                    hir::ExprKind::Break(\n+                        hir::Destination { label: None, target_id },\n+                        Some(from_err_expr),\n+                    ),\n+                    thin_attrs,\n+                ))\n+            } else {\n+                self.arena.alloc(self.expr(\n+                    try_span,\n+                    hir::ExprKind::Ret(Some(from_err_expr)),\n+                    thin_attrs,\n+                ))\n+            };\n+\n+            let err_pat = self.pat_err(try_span, err_local);\n+            self.arm(err_pat, ret_expr)\n+        };\n+\n+        hir::ExprKind::Match(\n+            scrutinee,\n+            arena_vec![self; err_arm, ok_arm],\n+            hir::MatchSource::TryDesugar,\n+        )\n+    }\n+\n+    // =========================================================================\n+    // Helper methods for building HIR.\n+    // =========================================================================\n+\n+    /// Constructs a `true` or `false` literal expression.\n+    pub(super) fn expr_bool(&mut self, span: Span, val: bool) -> &'hir hir::Expr<'hir> {\n+        let lit = Spanned { span, node: LitKind::Bool(val) };\n+        self.arena.alloc(self.expr(span, hir::ExprKind::Lit(lit), ThinVec::new()))\n+    }\n+\n+    /// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.\n+    ///\n+    /// In terms of drop order, it has the same effect as wrapping `expr` in\n+    /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n+    ///\n+    /// The drop order can be important in e.g. `if expr { .. }`.\n+    pub(super) fn expr_drop_temps(\n+        &mut self,\n+        span: Span,\n+        expr: &'hir hir::Expr<'hir>,\n+        attrs: AttrVec,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+    }\n+\n+    pub(super) fn expr_drop_temps_mut(\n+        &mut self,\n+        span: Span,\n+        expr: &'hir hir::Expr<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n+    }\n+\n+    fn expr_match(\n+        &mut self,\n+        span: Span,\n+        arg: &'hir hir::Expr<'hir>,\n+        arms: &'hir [hir::Arm<'hir>],\n+        source: hir::MatchSource,\n+    ) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source), ThinVec::new())\n+    }\n+\n+    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n+        let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n+        self.arena.alloc(self.expr(span, expr_break, attrs))\n+    }\n+\n+    fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n+        self.expr(\n+            span,\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n+            ThinVec::new(),\n+        )\n+    }\n+\n+    fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), ThinVec::new()))\n+    }\n+\n+    fn expr_call_mut(\n+        &mut self,\n+        span: Span,\n+        e: &'hir hir::Expr<'hir>,\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n+    }\n+\n+    fn expr_call(\n+        &mut self,\n+        span: Span,\n+        e: &'hir hir::Expr<'hir>,\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_call_mut(span, e, args))\n+    }\n+\n+    fn expr_call_lang_item_fn_mut(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> hir::Expr<'hir> {\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, ThinVec::new()));\n+        self.expr_call_mut(span, path, args)\n+    }\n+\n+    fn expr_call_lang_item_fn(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        args: &'hir [hir::Expr<'hir>],\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_call_lang_item_fn_mut(span, lang_item, args))\n+    }\n+\n+    fn expr_lang_item_path(\n+        &mut self,\n+        span: Span,\n+        lang_item: hir::LangItem,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Path(hir::QPath::LangItem(lang_item, span)), attrs)\n+    }\n+\n+    pub(super) fn expr_ident(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+    ) -> &'hir hir::Expr<'hir> {\n+        self.arena.alloc(self.expr_ident_mut(sp, ident, binding))\n+    }\n+\n+    pub(super) fn expr_ident_mut(\n+        &mut self,\n+        sp: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+    ) -> hir::Expr<'hir> {\n+        self.expr_ident_with_attrs(sp, ident, binding, ThinVec::new())\n+    }\n+\n+    fn expr_ident_with_attrs(\n+        &mut self,\n+        span: Span,\n+        ident: Ident,\n+        binding: hir::HirId,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n+        let expr_path = hir::ExprKind::Path(hir::QPath::Resolved(\n+            None,\n+            self.arena.alloc(hir::Path {\n+                span,\n+                res: Res::Local(binding),\n+                segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+            }),\n+        ));\n+\n+        self.expr(span, expr_path, attrs)\n+    }\n+\n+    fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n+        let hir_id = self.next_id();\n+        let span = expr.span;\n+        self.expr(\n+            span,\n+            hir::ExprKind::Block(\n+                self.arena.alloc(hir::Block {\n+                    stmts: &[],\n+                    expr: Some(expr),\n+                    hir_id,\n+                    rules: hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::CompilerGenerated),\n+                    span,\n+                    targeted_by_break: false,\n+                }),\n+                None,\n+            ),\n+            ThinVec::new(),\n+        )\n+    }\n+\n+    fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n+        let blk = self.block_all(span, &[], None);\n+        let expr = self.expr_block(blk, ThinVec::new());\n+        self.arena.alloc(expr)\n+    }\n+\n+    pub(super) fn expr_block(\n+        &mut self,\n+        b: &'hir hir::Block<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n+        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n+    }\n+\n+    pub(super) fn expr(\n+        &mut self,\n+        span: Span,\n+        kind: hir::ExprKind<'hir>,\n+        attrs: AttrVec,\n+    ) -> hir::Expr<'hir> {\n+        hir::Expr { hir_id: self.next_id(), kind, span, attrs }\n+    }\n+\n+    fn field(&mut self, ident: Ident, expr: &'hir hir::Expr<'hir>, span: Span) -> hir::Field<'hir> {\n+        hir::Field { hir_id: self.next_id(), ident, span, expr, is_shorthand: false }\n+    }\n+\n+    fn arm(&mut self, pat: &'hir hir::Pat<'hir>, expr: &'hir hir::Expr<'hir>) -> hir::Arm<'hir> {\n+        hir::Arm {\n+            hir_id: self.next_id(),\n+            attrs: &[],\n+            pat,\n+            guard: None,\n+            span: expr.span,\n+            body: expr,\n+        }\n+    }\n+}"}, {"sha": "f3309afec7d6b01ecd9f4fb600ed04290985d5f3", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "added", "additions": 1458, "deletions": 0, "changes": 1458, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1458 @@\n+use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n+use super::{ImplTraitContext, ImplTraitPosition};\n+use crate::Arena;\n+\n+use rustc_ast::node_id::NodeMap;\n+use rustc_ast::ptr::P;\n+use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n+use rustc_ast::*;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_span::source_map::{respan, DesugaringKind};\n+use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Span;\n+use rustc_target::spec::abi;\n+\n+use smallvec::{smallvec, SmallVec};\n+use std::collections::BTreeSet;\n+use tracing::debug;\n+\n+pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n+    pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,\n+}\n+\n+impl ItemLowerer<'_, '_, '_> {\n+    fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n+        let old = self.lctx.is_in_trait_impl;\n+        self.lctx.is_in_trait_impl = if let &None = impl_ref { false } else { true };\n+        f(self);\n+        self.lctx.is_in_trait_impl = old;\n+    }\n+}\n+\n+impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n+    fn visit_mod(&mut self, m: &'a Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n+        let hir_id = self.lctx.lower_node_id(n);\n+\n+        self.lctx.modules.insert(\n+            hir_id,\n+            hir::ModuleItems {\n+                items: BTreeSet::new(),\n+                trait_items: BTreeSet::new(),\n+                impl_items: BTreeSet::new(),\n+            },\n+        );\n+\n+        let old = self.lctx.current_module;\n+        self.lctx.current_module = hir_id;\n+        visit::walk_mod(self, m);\n+        self.lctx.current_module = old;\n+    }\n+\n+    fn visit_item(&mut self, item: &'a Item) {\n+        let mut item_hir_id = None;\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            lctx.without_in_scope_lifetime_defs(|lctx| {\n+                if let Some(hir_item) = lctx.lower_item(item) {\n+                    item_hir_id = Some(hir_item.hir_id);\n+                    lctx.insert_item(hir_item);\n+                }\n+            })\n+        });\n+\n+        if let Some(hir_id) = item_hir_id {\n+            self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n+                let this = &mut ItemLowerer { lctx: this };\n+                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n+                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n+                } else {\n+                    visit::walk_item(this, item);\n+                }\n+            });\n+        }\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'a>, sp: Span, _: NodeId) {\n+        match fk {\n+            FnKind::Fn(FnCtxt::Foreign, _, sig, _, _) => {\n+                self.visit_fn_header(&sig.header);\n+                visit::walk_fn_decl(self, &sig.decl);\n+                // Don't visit the foreign function body even if it has one, since lowering the\n+                // body would have no meaning and will have already been caught as a parse error.\n+            }\n+            _ => visit::walk_fn(self, fk, sp),\n+        }\n+    }\n+\n+    fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| match ctxt {\n+            AssocCtxt::Trait => {\n+                let hir_item = lctx.lower_trait_item(item);\n+                let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+                lctx.trait_items.insert(id, hir_item);\n+                lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+            }\n+            AssocCtxt::Impl => {\n+                let hir_item = lctx.lower_impl_item(item);\n+                let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+                lctx.impl_items.insert(id, hir_item);\n+                lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+            }\n+        });\n+\n+        visit::walk_assoc_item(self, item, ctxt);\n+    }\n+}\n+\n+impl<'hir> LoweringContext<'_, 'hir> {\n+    // Same as the method above, but accepts `hir::GenericParam`s\n+    // instead of `ast::GenericParam`s.\n+    // This should only be used with generics that have already had their\n+    // in-band lifetimes added. In practice, this means that this function is\n+    // only used when lowering a child item of a trait or impl.\n+    fn with_parent_item_lifetime_defs<T>(\n+        &mut self,\n+        parent_hir_id: hir::HirId,\n+        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+    ) -> T {\n+        let old_len = self.in_scope_lifetimes.len();\n+\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n+            hir::ItemKind::Impl { ref generics, .. }\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => &generics.params[..],\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n+            _ => None,\n+        });\n+        self.in_scope_lifetimes.extend(lt_def_names);\n+\n+        let res = f(self);\n+\n+        self.in_scope_lifetimes.truncate(old_len);\n+        res\n+    }\n+\n+    // Clears (and restores) the `in_scope_lifetimes` field. Used when\n+    // visiting nested items, which never inherit in-scope lifetimes\n+    // from their surrounding environment.\n+    fn without_in_scope_lifetime_defs<T>(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_, '_>) -> T,\n+    ) -> T {\n+        let old_in_scope_lifetimes = std::mem::replace(&mut self.in_scope_lifetimes, vec![]);\n+\n+        // this vector is only used when walking over impl headers,\n+        // input types, and the like, and should not be non-empty in\n+        // between items\n+        assert!(self.lifetimes_to_define.is_empty());\n+\n+        let res = f(self);\n+\n+        assert!(self.in_scope_lifetimes.is_empty());\n+        self.in_scope_lifetimes = old_in_scope_lifetimes;\n+\n+        res\n+    }\n+\n+    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod<'hir> {\n+        hir::Mod {\n+            inner: m.inner,\n+            item_ids: self\n+                .arena\n+                .alloc_from_iter(m.items.iter().flat_map(|x| self.lower_item_id(x))),\n+        }\n+    }\n+\n+    pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n+        let node_ids = match i.kind {\n+            ItemKind::Use(ref use_tree) => {\n+                let mut vec = smallvec![i.id];\n+                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n+                vec\n+            }\n+            ItemKind::MacroDef(..) => SmallVec::new(),\n+            ItemKind::Fn(..) | ItemKind::Impl { of_trait: None, .. } => smallvec![i.id],\n+            _ => smallvec![i.id],\n+        };\n+\n+        node_ids\n+            .into_iter()\n+            .map(|node_id| hir::ItemId { id: self.allocate_hir_id_counter(node_id) })\n+            .collect()\n+    }\n+\n+    fn lower_item_id_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        base_id: NodeId,\n+        vec: &mut SmallVec<[NodeId; 1]>,\n+    ) {\n+        match tree.kind {\n+            UseTreeKind::Nested(ref nested_vec) => {\n+                for &(ref nested, id) in nested_vec {\n+                    vec.push(id);\n+                    self.lower_item_id_use_tree(nested, id, vec);\n+                }\n+            }\n+            UseTreeKind::Glob => {}\n+            UseTreeKind::Simple(_, id1, id2) => {\n+                for (_, &id) in\n+                    self.expect_full_res_from_use(base_id).skip(1).zip([id1, id2].iter())\n+                {\n+                    vec.push(id);\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n+        let mut ident = i.ident;\n+        let mut vis = self.lower_visibility(&i.vis, None);\n+        let attrs = self.lower_attrs(&i.attrs);\n+\n+        if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n+            if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n+                let hir_id = self.lower_node_id(i.id);\n+                let body = P(self.lower_mac_args(body));\n+                self.exported_macros.push(hir::MacroDef {\n+                    ident,\n+                    vis,\n+                    attrs,\n+                    hir_id,\n+                    span: i.span,\n+                    ast: MacroDef { body, macro_rules },\n+                });\n+            } else {\n+                self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n+            }\n+            return None;\n+        }\n+\n+        let kind = self.lower_item_kind(i.span, i.id, &mut ident, attrs, &mut vis, &i.kind);\n+\n+        Some(hir::Item { hir_id: self.lower_node_id(i.id), ident, attrs, kind, vis, span: i.span })\n+    }\n+\n+    fn lower_item_kind(\n+        &mut self,\n+        span: Span,\n+        id: NodeId,\n+        ident: &mut Ident,\n+        attrs: &'hir [Attribute],\n+        vis: &mut hir::Visibility<'hir>,\n+        i: &ItemKind,\n+    ) -> hir::ItemKind<'hir> {\n+        match *i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n+            ItemKind::Use(ref use_tree) => {\n+                // Start with an empty prefix.\n+                let prefix = Path { segments: vec![], span: use_tree.span };\n+\n+                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n+            }\n+            ItemKind::Static(ref t, m, ref e) => {\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Static(ty, m, body_id)\n+            }\n+            ItemKind::Const(_, ref t, ref e) => {\n+                let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n+                hir::ItemKind::Const(ty, body_id)\n+            }\n+            ItemKind::Fn(\n+                _,\n+                FnSig { ref decl, header, span: fn_sig_span },\n+                ref generics,\n+                ref body,\n+            ) => {\n+                let fn_def_id = self.resolver.local_def_id(id);\n+                self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n+\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let asyncness = header.asyncness;\n+                    let body_id =\n+                        this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n+\n+                    let (generics, decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| {\n+                            let ret_id = asyncness.opt_return_id();\n+                            this.lower_fn_decl(\n+                                &decl,\n+                                Some((fn_def_id.to_def_id(), idty)),\n+                                true,\n+                                ret_id,\n+                            )\n+                        },\n+                    );\n+                    let sig = hir::FnSig {\n+                        decl,\n+                        header: this.lower_fn_header(header),\n+                        span: fn_sig_span,\n+                    };\n+                    hir::ItemKind::Fn(sig, generics, body_id)\n+                })\n+            }\n+            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n+            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::TyAlias(_, ref gen, _, Some(ref ty)) => {\n+                // We lower\n+                //\n+                // type Foo = impl Trait\n+                //\n+                // to\n+                //\n+                // type Foo = Foo1\n+                // opaque type Foo1: Trait\n+                let ty = self.lower_ty(\n+                    ty,\n+                    ImplTraitContext::OtherOpaqueTy {\n+                        capturable_lifetimes: &mut FxHashSet::default(),\n+                        origin: hir::OpaqueTyOrigin::Misc,\n+                    },\n+                );\n+                let generics = self.lower_generics(gen, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n+            ItemKind::TyAlias(_, ref generics, _, None) => {\n+                let ty = self.arena.alloc(self.ty(span, hir::TyKind::Err));\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                hir::ItemKind::TyAlias(ty, generics)\n+            }\n+            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n+                hir::EnumDef {\n+                    variants: self.arena.alloc_from_iter(\n+                        enum_definition.variants.iter().map(|x| self.lower_variant(x)),\n+                    ),\n+                },\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::Struct(ref struct_def, ref generics) => {\n+                let struct_def = self.lower_variant_data(struct_def);\n+                hir::ItemKind::Struct(\n+                    struct_def,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Union(ref vdata, ref generics) => {\n+                let vdata = self.lower_variant_data(vdata);\n+                hir::ItemKind::Union(\n+                    vdata,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                constness,\n+                generics: ref ast_generics,\n+                of_trait: ref trait_ref,\n+                self_ty: ref ty,\n+                items: ref impl_items,\n+            } => {\n+                let def_id = self.resolver.local_def_id(id);\n+\n+                // Lower the \"impl header\" first. This ordering is important\n+                // for in-band lifetimes! Consider `'a` here:\n+                //\n+                //     impl Foo<'a> for u32 {\n+                //         fn method(&'a self) { .. }\n+                //     }\n+                //\n+                // Because we start by lowering the `Foo<'a> for u32`\n+                // part, we will add `'a` to the list of generics on\n+                // the impl. When we then encounter it later in the\n+                // method, it will not be considered an in-band\n+                // lifetime to be added, but rather a reference to a\n+                // parent lifetime.\n+                let lowered_trait_impl_id = self.lower_node_id(id);\n+                let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n+                    ast_generics,\n+                    def_id,\n+                    AnonymousLifetimeMode::CreateParameter,\n+                    |this, _| {\n+                        let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n+                            this.lower_trait_ref(trait_ref, ImplTraitContext::disallowed())\n+                        });\n+\n+                        if let Some(ref trait_ref) = trait_ref {\n+                            if let Res::Def(DefKind::Trait, def_id) = trait_ref.path.res {\n+                                this.trait_impls\n+                                    .entry(def_id)\n+                                    .or_default()\n+                                    .push(lowered_trait_impl_id);\n+                            }\n+                        }\n+\n+                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::disallowed());\n+\n+                        (trait_ref, lowered_ty)\n+                    },\n+                );\n+\n+                let new_impl_items =\n+                    self.with_in_scope_lifetime_defs(&ast_generics.params, |this| {\n+                        this.arena.alloc_from_iter(\n+                            impl_items.iter().map(|item| this.lower_impl_item_ref(item)),\n+                        )\n+                    });\n+\n+                // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n+                // to not cause an assertion failure inside the `lower_defaultness` function.\n+                let has_val = true;\n+                let (defaultness, defaultness_span) = self.lower_defaultness(defaultness, has_val);\n+                hir::ItemKind::Impl {\n+                    unsafety: self.lower_unsafety(unsafety),\n+                    polarity,\n+                    defaultness,\n+                    defaultness_span,\n+                    constness: self.lower_constness(constness),\n+                    generics,\n+                    of_trait: trait_ref,\n+                    self_ty: lowered_ty,\n+                    items: new_impl_items,\n+                }\n+            }\n+            ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n+                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n+                let items = self\n+                    .arena\n+                    .alloc_from_iter(items.iter().map(|item| self.lower_trait_item_ref(item)));\n+                hir::ItemKind::Trait(\n+                    is_auto,\n+                    self.lower_unsafety(unsafety),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    bounds,\n+                    items,\n+                )\n+            }\n+            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::MacroDef(..) | ItemKind::MacCall(..) => {\n+                panic!(\"`TyMac` should have been expanded by now\")\n+            }\n+        }\n+    }\n+\n+    fn lower_const_item(\n+        &mut self,\n+        ty: &Ty,\n+        span: Span,\n+        body: Option<&Expr>,\n+    ) -> (&'hir hir::Ty<'hir>, hir::BodyId) {\n+        let mut capturable_lifetimes;\n+        let itctx = if self.sess.features_untracked().impl_trait_in_bindings {\n+            capturable_lifetimes = FxHashSet::default();\n+            ImplTraitContext::OtherOpaqueTy {\n+                capturable_lifetimes: &mut capturable_lifetimes,\n+                origin: hir::OpaqueTyOrigin::Misc,\n+            }\n+        } else {\n+            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+        };\n+        let ty = self.lower_ty(ty, itctx);\n+        (ty, self.lower_const_body(span, body))\n+    }\n+\n+    fn lower_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        prefix: &Path,\n+        id: NodeId,\n+        vis: &mut hir::Visibility<'hir>,\n+        ident: &mut Ident,\n+        attrs: &'hir [Attribute],\n+    ) -> hir::ItemKind<'hir> {\n+        debug!(\"lower_use_tree(tree={:?})\", tree);\n+        debug!(\"lower_use_tree: vis = {:?}\", vis);\n+\n+        let path = &tree.prefix;\n+        let segments = prefix.segments.iter().chain(path.segments.iter()).cloned().collect();\n+\n+        match tree.kind {\n+            UseTreeKind::Simple(rename, id1, id2) => {\n+                *ident = tree.ident();\n+\n+                // First, apply the prefix to the path.\n+                let mut path = Path { segments, span: path.span };\n+\n+                // Correctly resolve `self` imports.\n+                if path.segments.len() > 1\n+                    && path.segments.last().unwrap().ident.name == kw::SelfLower\n+                {\n+                    let _ = path.segments.pop();\n+                    if rename.is_none() {\n+                        *ident = path.segments.last().unwrap().ident;\n+                    }\n+                }\n+\n+                let mut resolutions = self.expect_full_res_from_use(id);\n+                // We want to return *something* from this function, so hold onto the first item\n+                // for later.\n+                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n+\n+                // Here, we are looping over namespaces, if they exist for the definition\n+                // being imported. We only handle type and value namespaces because we\n+                // won't be dealing with macros in the rest of the compiler.\n+                // Essentially a single `use` which imports two names is desugared into\n+                // two imports.\n+                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                    let ident = *ident;\n+                    let mut path = path.clone();\n+                    for seg in &mut path.segments {\n+                        seg.id = self.resolver.next_node_id();\n+                    }\n+                    let span = path.span;\n+\n+                    self.with_hir_id_owner(new_node_id, |this| {\n+                        let new_id = this.lower_node_id(new_node_id);\n+                        let res = this.lower_res(res);\n+                        let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n+                        let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n+                        let vis = this.rebuild_vis(&vis);\n+\n+                        this.insert_item(hir::Item {\n+                            hir_id: new_id,\n+                            ident,\n+                            attrs,\n+                            kind,\n+                            vis,\n+                            span,\n+                        });\n+                    });\n+                }\n+\n+                let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None);\n+                hir::ItemKind::Use(path, hir::UseKind::Single)\n+            }\n+            UseTreeKind::Glob => {\n+                let path =\n+                    self.lower_path(id, &Path { segments, span: path.span }, ParamMode::Explicit);\n+                hir::ItemKind::Use(path, hir::UseKind::Glob)\n+            }\n+            UseTreeKind::Nested(ref trees) => {\n+                // Nested imports are desugared into simple imports.\n+                // So, if we start with\n+                //\n+                // ```\n+                // pub(x) use foo::{a, b};\n+                // ```\n+                //\n+                // we will create three items:\n+                //\n+                // ```\n+                // pub(x) use foo::a;\n+                // pub(x) use foo::b;\n+                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n+                // ```\n+                //\n+                // The first two are produced by recursively invoking\n+                // `lower_use_tree` (and indeed there may be things\n+                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // wind up being directly added to\n+                // `self.items`. However, the structure of this\n+                // function also requires us to return one item, and\n+                // for that we return the `{}` import (called the\n+                // `ListStem`).\n+\n+                let prefix = Path { segments, span: prefix.span.to(path.span) };\n+\n+                // Add all the nested `PathListItem`s to the HIR.\n+                for &(ref use_tree, id) in trees {\n+                    let new_hir_id = self.lower_node_id(id);\n+\n+                    let mut prefix = prefix.clone();\n+\n+                    // Give the segments new node-ids since they are being cloned.\n+                    for seg in &mut prefix.segments {\n+                        seg.id = self.resolver.next_node_id();\n+                    }\n+\n+                    // Each `use` import is an item and thus are owners of the\n+                    // names in the path. Up to this point the nested import is\n+                    // the current owner, since we want each desugared import to\n+                    // own its own names, we have to adjust the owner before\n+                    // lowering the rest of the import.\n+                    self.with_hir_id_owner(id, |this| {\n+                        let mut vis = this.rebuild_vis(&vis);\n+                        let mut ident = *ident;\n+\n+                        let kind =\n+                            this.lower_use_tree(use_tree, &prefix, id, &mut vis, &mut ident, attrs);\n+\n+                        this.insert_item(hir::Item {\n+                            hir_id: new_hir_id,\n+                            ident,\n+                            attrs,\n+                            kind,\n+                            vis,\n+                            span: use_tree.span,\n+                        });\n+                    });\n+                }\n+\n+                // Subtle and a bit hacky: we lower the privacy level\n+                // of the list stem to \"private\" most of the time, but\n+                // not for \"restricted\" paths. The key thing is that\n+                // we don't want it to stay as `pub` (with no caveats)\n+                // because that affects rustdoc and also the lints\n+                // about `pub` items. But we can't *always* make it\n+                // private -- particularly not for restricted paths --\n+                // because it contains node-ids that would then be\n+                // unused, failing the check that HirIds are \"densely\n+                // assigned\".\n+                match vis.node {\n+                    hir::VisibilityKind::Public\n+                    | hir::VisibilityKind::Crate(_)\n+                    | hir::VisibilityKind::Inherited => {\n+                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n+                    }\n+                    hir::VisibilityKind::Restricted { .. } => {\n+                        // Do nothing here, as described in the comment on the match.\n+                    }\n+                }\n+\n+                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n+                let res = self.lower_res(res);\n+                let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit, None);\n+                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n+            }\n+        }\n+    }\n+\n+    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n+    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n+    /// `NodeId`s. (See, e.g., #56128.)\n+    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> &'hir hir::Path<'hir> {\n+        debug!(\"rebuild_use_path(path = {:?})\", path);\n+        let segments =\n+            self.arena.alloc_from_iter(path.segments.iter().map(|seg| hir::PathSegment {\n+                ident: seg.ident,\n+                hir_id: seg.hir_id.map(|_| self.next_id()),\n+                res: seg.res,\n+                args: None,\n+                infer_args: seg.infer_args,\n+            }));\n+        self.arena.alloc(hir::Path { span: path.span, res: path.res, segments })\n+    }\n+\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility<'hir>) -> hir::Visibility<'hir> {\n+        let vis_kind = match vis.node {\n+            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n+                hir::VisibilityKind::Restricted {\n+                    path: self.rebuild_use_path(path),\n+                    hir_id: self.next_id(),\n+                }\n+            }\n+        };\n+        respan(vis.span, vis_kind)\n+    }\n+\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n+        let def_id = self.resolver.local_def_id(i.id);\n+        hir::ForeignItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            kind: match i.kind {\n+                ForeignItemKind::Fn(_, ref sig, ref generics, _) => {\n+                    let fdec = &sig.decl;\n+                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n+                        generics,\n+                        def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, _| {\n+                            (\n+                                // Disallow `impl Trait` in foreign items.\n+                                this.lower_fn_decl(fdec, None, false, None),\n+                                this.lower_fn_params_to_names(fdec),\n+                            )\n+                        },\n+                    );\n+\n+                    hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n+                }\n+                ForeignItemKind::Static(ref t, m, _) => {\n+                    let ty = self.lower_ty(t, ImplTraitContext::disallowed());\n+                    hir::ForeignItemKind::Static(ty, m)\n+                }\n+                ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n+                ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n+            },\n+            vis: self.lower_visibility(&i.vis, None),\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod<'hir> {\n+        hir::ForeignMod {\n+            abi: fm.abi.map_or(abi::Abi::C, |abi| self.lower_abi(abi)),\n+            items: self.arena.alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item(x))),\n+        }\n+    }\n+\n+    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> &'hir hir::GlobalAsm {\n+        self.arena.alloc(hir::GlobalAsm { asm: ga.asm })\n+    }\n+\n+    fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n+        hir::Variant {\n+            attrs: self.lower_attrs(&v.attrs),\n+            data: self.lower_variant_data(&v.data),\n+            disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            id: self.lower_node_id(v.id),\n+            ident: v.ident,\n+            span: v.span,\n+        }\n+    }\n+\n+    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData<'hir> {\n+        match *vdata {\n+            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+                self.arena\n+                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n+                recovered,\n+            ),\n+            VariantData::Tuple(ref fields, id) => hir::VariantData::Tuple(\n+                self.arena\n+                    .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_struct_field(f))),\n+                self.lower_node_id(id),\n+            ),\n+            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+        }\n+    }\n+\n+    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField<'hir> {\n+        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n+            let t = self.lower_path_ty(\n+                &f.ty,\n+                qself,\n+                path,\n+                ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n+                ImplTraitContext::disallowed(),\n+            );\n+            self.arena.alloc(t)\n+        } else {\n+            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n+        };\n+        hir::StructField {\n+            span: f.span,\n+            hir_id: self.lower_node_id(f.id),\n+            ident: match f.ident {\n+                Some(ident) => ident,\n+                // FIXME(jseyfried): positional field hygiene.\n+                None => Ident::new(sym::integer(index), f.span),\n+            },\n+            vis: self.lower_visibility(&f.vis, None),\n+            ty,\n+            attrs: self.lower_attrs(&f.attrs),\n+        }\n+    }\n+\n+    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n+        let trait_item_def_id = self.resolver.local_def_id(i.id);\n+\n+        let (generics, kind) = match i.kind {\n+            AssocItemKind::Const(_, ref ty, ref default) => {\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n+                (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body))\n+            }\n+            AssocItemKind::Fn(_, ref sig, ref generics, None) => {\n+                let names = self.lower_fn_params_to_names(&sig.decl);\n+                let (generics, sig) =\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n+            }\n+            AssocItemKind::Fn(_, ref sig, ref generics, Some(ref body)) => {\n+                let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n+                let (generics, sig) =\n+                    self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)))\n+            }\n+            AssocItemKind::TyAlias(_, ref generics, ref bounds, ref default) => {\n+                let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                let kind = hir::TraitItemKind::Type(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+                    ty,\n+                );\n+\n+                (generics, kind)\n+            }\n+            AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n+        };\n+\n+        hir::TraitItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            kind,\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n+        let (kind, has_default) = match &i.kind {\n+            AssocItemKind::Const(_, _, default) => (hir::AssocItemKind::Const, default.is_some()),\n+            AssocItemKind::TyAlias(_, _, _, default) => {\n+                (hir::AssocItemKind::Type, default.is_some())\n+            }\n+            AssocItemKind::Fn(_, sig, _, default) => {\n+                (hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }, default.is_some())\n+            }\n+            AssocItemKind::MacCall(..) => unimplemented!(),\n+        };\n+        let id = hir::TraitItemId { hir_id: self.lower_node_id(i.id) };\n+        let defaultness = hir::Defaultness::Default { has_value: has_default };\n+        hir::TraitItemRef { id, ident: i.ident, span: i.span, defaultness, kind }\n+    }\n+\n+    /// Construct `ExprKind::Err` for the given `span`.\n+    crate fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n+    }\n+\n+    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n+        let impl_item_def_id = self.resolver.local_def_id(i.id);\n+\n+        let (generics, kind) = match &i.kind {\n+            AssocItemKind::Const(_, ty, expr) => {\n+                let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                (\n+                    hir::Generics::empty(),\n+                    hir::ImplItemKind::Const(ty, self.lower_const_body(i.span, expr.as_deref())),\n+                )\n+            }\n+            AssocItemKind::Fn(_, sig, generics, body) => {\n+                self.current_item = Some(i.span);\n+                let asyncness = sig.header.asyncness;\n+                let body_id =\n+                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    asyncness.opt_return_id(),\n+                );\n+\n+                (generics, hir::ImplItemKind::Fn(sig, body_id))\n+            }\n+            AssocItemKind::TyAlias(_, generics, _, ty) => {\n+                let generics = self.lower_generics(generics, ImplTraitContext::disallowed());\n+                let kind = match ty {\n+                    None => {\n+                        let ty = self.arena.alloc(self.ty(i.span, hir::TyKind::Err));\n+                        hir::ImplItemKind::TyAlias(ty)\n+                    }\n+                    Some(ty) => {\n+                        let ty = self.lower_ty(\n+                            ty,\n+                            ImplTraitContext::OtherOpaqueTy {\n+                                capturable_lifetimes: &mut FxHashSet::default(),\n+                                origin: hir::OpaqueTyOrigin::Misc,\n+                            },\n+                        );\n+                        hir::ImplItemKind::TyAlias(ty)\n+                    }\n+                };\n+                (generics, kind)\n+            }\n+            AssocItemKind::MacCall(..) => panic!(\"`TyMac` should have been expanded by now\"),\n+        };\n+\n+        // Since `default impl` is not yet implemented, this is always true in impls.\n+        let has_value = true;\n+        let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        hir::ImplItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            vis: self.lower_visibility(&i.vis, None),\n+            defaultness,\n+            kind,\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef<'hir> {\n+        // Since `default impl` is not yet implemented, this is always true in impls.\n+        let has_value = true;\n+        let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n+            ident: i.ident,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis, Some(i.id)),\n+            defaultness,\n+            kind: match &i.kind {\n+                AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+                AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+                AssocItemKind::Fn(_, sig, ..) => {\n+                    hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n+                }\n+                AssocItemKind::MacCall(..) => unimplemented!(),\n+            },\n+        }\n+    }\n+\n+    /// If an `explicit_owner` is given, this method allocates the `HirId` in\n+    /// the address space of that item instead of the item currently being\n+    /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n+    /// lower a `Visibility` value although we haven't lowered the owning\n+    /// `ImplItem` in question yet.\n+    fn lower_visibility(\n+        &mut self,\n+        v: &Visibility,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::Visibility<'hir> {\n+        let node = match v.node {\n+            VisibilityKind::Public => hir::VisibilityKind::Public,\n+            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            VisibilityKind::Restricted { ref path, id } => {\n+                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n+                let lowered_id = if let Some(owner) = explicit_owner {\n+                    self.lower_node_id_with_owner(id, owner)\n+                } else {\n+                    self.lower_node_id(id)\n+                };\n+                let res = self.expect_full_res(id);\n+                let res = self.lower_res(res);\n+                hir::VisibilityKind::Restricted {\n+                    path: self.lower_path_extra(res, path, ParamMode::Explicit, explicit_owner),\n+                    hir_id: lowered_id,\n+                }\n+            }\n+            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+        };\n+        respan(v.span, node)\n+    }\n+\n+    fn lower_defaultness(\n+        &self,\n+        d: Defaultness,\n+        has_value: bool,\n+    ) -> (hir::Defaultness, Option<Span>) {\n+        match d {\n+            Defaultness::Default(sp) => (hir::Defaultness::Default { has_value }, Some(sp)),\n+            Defaultness::Final => {\n+                assert!(has_value);\n+                (hir::Defaultness::Final, None)\n+            }\n+        }\n+    }\n+\n+    fn record_body(\n+        &mut self,\n+        params: &'hir [hir::Param<'hir>],\n+        value: hir::Expr<'hir>,\n+    ) -> hir::BodyId {\n+        let body = hir::Body { generator_kind: self.generator_kind, params, value };\n+        let id = body.id();\n+        self.bodies.insert(id, body);\n+        id\n+    }\n+\n+    pub(super) fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut Self) -> (&'hir [hir::Param<'hir>], hir::Expr<'hir>),\n+    ) -> hir::BodyId {\n+        let prev_gen_kind = self.generator_kind.take();\n+        let task_context = self.task_context.take();\n+        let (parameters, result) = f(self);\n+        let body_id = self.record_body(parameters, result);\n+        self.task_context = task_context;\n+        self.generator_kind = prev_gen_kind;\n+        body_id\n+    }\n+\n+    fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n+        hir::Param {\n+            attrs: self.lower_attrs(&param.attrs),\n+            hir_id: self.lower_node_id(param.id),\n+            pat: self.lower_pat(&param.pat),\n+            ty_span: param.ty.span,\n+            span: param.span,\n+        }\n+    }\n+\n+    pub(super) fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| {\n+            (\n+                this.arena.alloc_from_iter(decl.inputs.iter().map(|x| this.lower_param(x))),\n+                body(this),\n+            )\n+        })\n+    }\n+\n+    fn lower_fn_body_block(\n+        &mut self,\n+        span: Span,\n+        decl: &FnDecl,\n+        body: Option<&Block>,\n+    ) -> hir::BodyId {\n+        self.lower_fn_body(decl, |this| this.lower_block_expr_opt(span, body))\n+    }\n+\n+    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n+        match block {\n+            Some(block) => self.lower_block_expr(block),\n+            None => self.expr_err(span),\n+        }\n+    }\n+\n+    pub(super) fn lower_const_body(&mut self, span: Span, expr: Option<&Expr>) -> hir::BodyId {\n+        self.lower_body(|this| {\n+            (\n+                &[],\n+                match expr {\n+                    Some(expr) => this.lower_expr_mut(expr),\n+                    None => this.expr_err(span),\n+                },\n+            )\n+        })\n+    }\n+\n+    fn lower_maybe_async_body(\n+        &mut self,\n+        span: Span,\n+        decl: &FnDecl,\n+        asyncness: Async,\n+        body: Option<&Block>,\n+    ) -> hir::BodyId {\n+        let closure_id = match asyncness {\n+            Async::Yes { closure_id, .. } => closure_id,\n+            Async::No => return self.lower_fn_body_block(span, decl, body),\n+        };\n+\n+        self.lower_body(|this| {\n+            let mut parameters: Vec<hir::Param<'_>> = Vec::new();\n+            let mut statements: Vec<hir::Stmt<'_>> = Vec::new();\n+\n+            // Async function parameters are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            // from:\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //         <body>\n+            //     }\n+            //\n+            // into:\n+            //\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //         drop-temps { <body> } // see comments later in fn for details\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            //\n+            // Note that the body is embedded in `drop-temps`; an\n+            // equivalent desugaring would be `return { <body>\n+            // };`. The key point is that we wish to drop all the\n+            // let-bound variables and temporaries created in the body\n+            // (and its tail expression!) before we drop the\n+            // parameters (c.f. rust-lang/rust#64512).\n+            for (index, parameter) in decl.inputs.iter().enumerate() {\n+                let parameter = this.lower_param(parameter);\n+                let span = parameter.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n+                let (ident, is_simple_parameter) = match parameter.pat.kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) => {\n+                        (ident, true)\n+                    }\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    }\n+                };\n+\n+                let desugared_span = this.mark_span_with_reason(DesugaringKind::Async, span, None);\n+\n+                // Construct a parameter representing `__argN: <ty>` to replace the parameter of the\n+                // async function.\n+                //\n+                // If this is the simple case, this parameter will end up being the same as the\n+                // original parameter, but with a different pattern id.\n+                let mut stmt_attrs = AttrVec::new();\n+                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n+                let new_parameter = hir::Param {\n+                    attrs: parameter.attrs,\n+                    hir_id: parameter.hir_id,\n+                    pat: new_parameter_pat,\n+                    ty_span: parameter.ty_span,\n+                    span: parameter.span,\n+                };\n+\n+                if is_simple_parameter {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    let expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n+                    let stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(expr),\n+                        parameter.pat,\n+                        hir::LocalSource::AsyncFn,\n+                    );\n+                    statements.push(stmt);\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the parameter into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n+                        desugared_span,\n+                        ident,\n+                        hir::BindingAnnotation::Mutable,\n+                    );\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n+                    let move_stmt = this.stmt_let_pat(\n+                        AttrVec::new(),\n+                        desugared_span,\n+                        Some(move_expr),\n+                        move_pat,\n+                        hir::LocalSource::AsyncFn,\n+                    );\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // parameter's pattern so that `HirId`s are densely assigned.\n+                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n+                    let pattern_stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(pattern_expr),\n+                        parameter.pat,\n+                        hir::LocalSource::AsyncFn,\n+                    );\n+\n+                    statements.push(move_stmt);\n+                    statements.push(pattern_stmt);\n+                };\n+\n+                parameters.push(new_parameter);\n+            }\n+\n+            let body_span = body.map_or(span, |b| b.span);\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value,\n+                closure_id,\n+                None,\n+                body_span,\n+                hir::AsyncGeneratorKind::Fn,\n+                |this| {\n+                    // Create a block from the user's function body:\n+                    let user_body = this.lower_block_expr_opt(body_span, body);\n+\n+                    // Transform into `drop-temps { <user-body> }`, an expression:\n+                    let desugared_span =\n+                        this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        this.arena.alloc(user_body),\n+                        AttrVec::new(),\n+                    );\n+\n+                    // As noted above, create the final block like\n+                    //\n+                    // ```\n+                    // {\n+                    //   let $param_pattern = $raw_param;\n+                    //   ...\n+                    //   drop-temps { <user-body> }\n+                    // }\n+                    // ```\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        this.arena.alloc_from_iter(statements),\n+                        Some(user_body),\n+                    );\n+\n+                    this.expr_block(body, AttrVec::new())\n+                },\n+            );\n+\n+            (\n+                this.arena.alloc_from_iter(parameters),\n+                this.expr(body_span, async_expr, AttrVec::new()),\n+            )\n+        })\n+    }\n+\n+    fn lower_method_sig(\n+        &mut self,\n+        generics: &Generics,\n+        sig: &FnSig,\n+        fn_def_id: LocalDefId,\n+        impl_trait_return_allow: bool,\n+        is_async: Option<NodeId>,\n+    ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n+        let header = self.lower_fn_header(sig.header);\n+        let (generics, decl) = self.add_in_band_defs(\n+            generics,\n+            fn_def_id,\n+            AnonymousLifetimeMode::PassThrough,\n+            |this, idty| {\n+                this.lower_fn_decl(\n+                    &sig.decl,\n+                    Some((fn_def_id.to_def_id(), idty)),\n+                    impl_trait_return_allow,\n+                    is_async,\n+                )\n+            },\n+        );\n+        (generics, hir::FnSig { header, decl, span: sig.span })\n+    }\n+\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+        hir::FnHeader {\n+            unsafety: self.lower_unsafety(h.unsafety),\n+            asyncness: self.lower_asyncness(h.asyncness),\n+            constness: self.lower_constness(h.constness),\n+            abi: self.lower_extern(h.ext),\n+        }\n+    }\n+\n+    pub(super) fn lower_abi(&mut self, abi: StrLit) -> abi::Abi {\n+        abi::lookup(&abi.symbol_unescaped.as_str()).unwrap_or_else(|| {\n+            self.error_on_invalid_abi(abi);\n+            abi::Abi::Rust\n+        })\n+    }\n+\n+    pub(super) fn lower_extern(&mut self, ext: Extern) -> abi::Abi {\n+        match ext {\n+            Extern::None => abi::Abi::Rust,\n+            Extern::Implicit => abi::Abi::C,\n+            Extern::Explicit(abi) => self.lower_abi(abi),\n+        }\n+    }\n+\n+    fn error_on_invalid_abi(&self, abi: StrLit) {\n+        struct_span_err!(self.sess, abi.span, E0703, \"invalid ABI: found `{}`\", abi.symbol)\n+            .span_label(abi.span, \"invalid ABI\")\n+            .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+            .emit();\n+    }\n+\n+    fn lower_asyncness(&mut self, a: Async) -> hir::IsAsync {\n+        match a {\n+            Async::Yes { .. } => hir::IsAsync::Async,\n+            Async::No => hir::IsAsync::NotAsync,\n+        }\n+    }\n+\n+    fn lower_constness(&mut self, c: Const) -> hir::Constness {\n+        match c {\n+            Const::Yes(_) => hir::Constness::Const,\n+            Const::No => hir::Constness::NotConst,\n+        }\n+    }\n+\n+    pub(super) fn lower_unsafety(&mut self, u: Unsafe) -> hir::Unsafety {\n+        match u {\n+            Unsafe::Yes(_) => hir::Unsafety::Unsafe,\n+            Unsafe::No => hir::Unsafety::Normal,\n+        }\n+    }\n+\n+    pub(super) fn lower_generics_mut(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> GenericsCtor<'hir> {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        // FIXME: this could probably be done with less rightward drift. It also looks like two\n+        // control paths where `report_error` is called are the only paths that advance to after the\n+        // match statement, so the error reporting could probably just be moved there.\n+        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n+        for pred in &generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(\n+                                bound_pred.bounded_ty.span,\n+                                \"`?Trait` bounds are only permitted at the \\\n+                                 point where a type parameter is declared\",\n+                            );\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.kind {\n+                            TyKind::Path(None, ref path)\n+                                if path.segments.len() == 1\n+                                    && bound_pred.bound_generic_params.is_empty() =>\n+                            {\n+                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self\n+                                    .resolver\n+                                    .get_partial_res(bound_pred.bounded_ty.id)\n+                                    .map(|d| d.base_res())\n+                                {\n+                                    if let Some(def_id) = def_id.as_local() {\n+                                        for param in &generics.params {\n+                                            if let GenericParamKind::Type { .. } = param.kind {\n+                                                if def_id == self.resolver.local_def_id(param.id) {\n+                                                    add_bounds\n+                                                        .entry(param.id)\n+                                                        .or_default()\n+                                                        .push(bound.clone());\n+                                                    continue 'next_bound;\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        GenericsCtor {\n+            params: self.lower_generic_params_mut(&generics.params, &add_bounds, itctx).collect(),\n+            where_clause: self.lower_where_clause(&generics.where_clause),\n+            span: generics.span,\n+        }\n+    }\n+\n+    pub(super) fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::Generics<'hir> {\n+        let generics_ctor = self.lower_generics_mut(generics, itctx);\n+        generics_ctor.into_generics(self.arena)\n+    }\n+\n+    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n+            hir::WhereClause {\n+                predicates: this.arena.alloc_from_iter(\n+                    wc.predicates.iter().map(|predicate| this.lower_where_predicate(predicate)),\n+                ),\n+                span: wc.span,\n+            }\n+        })\n+    }\n+\n+    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n+        match *pred {\n+            WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                ref bound_generic_params,\n+                ref bounded_ty,\n+                ref bounds,\n+                span,\n+            }) => {\n+                self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n+                    hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                        bound_generic_params: this.lower_generic_params(\n+                            bound_generic_params,\n+                            &NodeMap::default(),\n+                            ImplTraitContext::disallowed(),\n+                        ),\n+                        bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n+                        bounds: this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| {\n+                            match *bound {\n+                                // Ignore `?Trait` bounds.\n+                                // They were copied into type parameters already.\n+                                GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                _ => Some(\n+                                    this.lower_param_bound(bound, ImplTraitContext::disallowed()),\n+                                ),\n+                            }\n+                        })),\n+                        span,\n+                    })\n+                })\n+            }\n+            WherePredicate::RegionPredicate(WhereRegionPredicate {\n+                ref lifetime,\n+                ref bounds,\n+                span,\n+            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                span,\n+                lifetime: self.lower_lifetime(lifetime),\n+                bounds: self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            }),\n+            WherePredicate::EqPredicate(WhereEqPredicate { id, ref lhs_ty, ref rhs_ty, span }) => {\n+                hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                    hir_id: self.lower_node_id(id),\n+                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n+                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n+                    span,\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// Helper struct for delayed construction of Generics.\n+pub(super) struct GenericsCtor<'hir> {\n+    pub(super) params: SmallVec<[hir::GenericParam<'hir>; 4]>,\n+    where_clause: hir::WhereClause<'hir>,\n+    span: Span,\n+}\n+\n+impl<'hir> GenericsCtor<'hir> {\n+    pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> hir::Generics<'hir> {\n+        hir::Generics {\n+            params: arena.alloc_from_iter(self.params),\n+            where_clause: self.where_clause,\n+            span: self.span,\n+        }\n+    }\n+}"}, {"sha": "586355fe6136e9a62fb1000e5de12d2c70549941", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "added", "additions": 2737, "deletions": 0, "changes": 2737, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "cb7b7c0eb6116fa9a157c021fc450b534686e463", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,300 @@\n+use super::{ImplTraitContext, LoweringContext, ParamMode};\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::*;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{source_map::Spanned, Span};\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        ensure_sufficient_stack(|| {\n+            let node = match p.kind {\n+                PatKind::Wild => hir::PatKind::Wild,\n+                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n+                    node\n+                }\n+                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n+                PatKind::TupleStruct(ref path, ref pats) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n+                }\n+                PatKind::Or(ref pats) => hir::PatKind::Or(\n+                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                ),\n+                PatKind::Path(ref qself, ref path) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        qself,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    hir::PatKind::Path(qpath)\n+                }\n+                PatKind::Struct(ref path, ref fields, etc) => {\n+                    let qpath = self.lower_qpath(\n+                        p.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+\n+                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat: self.lower_pat(&f.pat),\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n+                    }));\n+                    hir::PatKind::Struct(qpath, fs, etc)\n+                }\n+                PatKind::Tuple(ref pats) => {\n+                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                    hir::PatKind::Tuple(pats, ddpos)\n+                }\n+                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n+                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n+                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                    hir::PatKind::Range(\n+                        e1.as_deref().map(|e| self.lower_expr(e)),\n+                        e2.as_deref().map(|e| self.lower_expr(e)),\n+                        self.lower_range_end(end, e2.is_some()),\n+                    )\n+                }\n+                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n+                PatKind::Rest => {\n+                    // If we reach here the `..` pattern is not semantically allowed.\n+                    self.ban_illegal_rest_pat(p.span)\n+                }\n+                // FIXME: consider not using recursion to lower this.\n+                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n+                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n+            };\n+\n+            self.pat_with_node_id_of(p, node)\n+        })\n+    }\n+\n+    fn lower_pat_tuple(\n+        &mut self,\n+        pats: &[P<Pat>],\n+        ctx: &str,\n+    ) -> (&'hir [&'hir hir::Pat<'hir>], Option<usize>) {\n+        let mut elems = Vec::with_capacity(pats.len());\n+        let mut rest = None;\n+\n+        let mut iter = pats.iter().enumerate();\n+        for (idx, pat) in iter.by_ref() {\n+            // Interpret the first `..` pattern as a sub-tuple pattern.\n+            // Note that unlike for slice patterns,\n+            // where `xs @ ..` is a legal sub-slice pattern,\n+            // it is not a legal sub-tuple pattern.\n+            match pat.kind {\n+                // Found a sub-tuple rest pattern\n+                PatKind::Rest => {\n+                    rest = Some((idx, pat.span));\n+                    break;\n+                }\n+                // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n+                // This is not allowed as a sub-tuple pattern\n+                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    let sp = pat.span;\n+                    self.diagnostic()\n+                        .struct_span_err(\n+                            sp,\n+                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n+                        )\n+                        .span_label(sp, \"this is only allowed in slice patterns\")\n+                        .help(\"remove this and bind each tuple field independently\")\n+                        .span_suggestion_verbose(\n+                            sp,\n+                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n+                            \"..\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                }\n+                _ => {}\n+            }\n+\n+            // It was not a sub-tuple pattern so lower it normally.\n+            elems.push(self.lower_pat(pat));\n+        }\n+\n+        for (_, pat) in iter {\n+            // There was a previous sub-tuple pattern; make sure we don't allow more...\n+            if pat.is_rest() {\n+                // ...but there was one again, so error.\n+                self.ban_extra_rest_pat(pat.span, rest.unwrap().1, ctx);\n+            } else {\n+                elems.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        (self.arena.alloc_from_iter(elems), rest.map(|(ddpos, _)| ddpos))\n+    }\n+\n+    /// Lower a slice pattern of form `[pat_0, ..., pat_n]` into\n+    /// `hir::PatKind::Slice(before, slice, after)`.\n+    ///\n+    /// When encountering `($binding_mode $ident @)? ..` (`slice`),\n+    /// this is interpreted as a sub-slice pattern semantically.\n+    /// Patterns that follow, which are not like `slice` -- or an error occurs, are in `after`.\n+    fn lower_pat_slice(&mut self, pats: &[P<Pat>]) -> hir::PatKind<'hir> {\n+        let mut before = Vec::new();\n+        let mut after = Vec::new();\n+        let mut slice = None;\n+        let mut prev_rest_span = None;\n+\n+        // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n+        let lower_rest_sub = |this: &mut Self, pat, bm, ident, sub| {\n+            let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n+            let node = this.lower_pat_ident(pat, bm, ident, lower_sub);\n+            this.pat_with_node_id_of(pat, node)\n+        };\n+\n+        let mut iter = pats.iter();\n+        // Lower all the patterns until the first occurrence of a sub-slice pattern.\n+        for pat in iter.by_ref() {\n+            match pat.kind {\n+                // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n+                PatKind::Rest => {\n+                    prev_rest_span = Some(pat.span);\n+                    slice = Some(self.pat_wild_with_node_id_of(pat));\n+                    break;\n+                }\n+                // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n+                // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    prev_rest_span = Some(sub.span);\n+                    slice = Some(lower_rest_sub(self, pat, bm, ident, sub));\n+                    break;\n+                }\n+                // It was not a subslice pattern so lower it normally.\n+                _ => before.push(self.lower_pat(pat)),\n+            }\n+        }\n+\n+        // Lower all the patterns after the first sub-slice pattern.\n+        for pat in iter {\n+            // There was a previous subslice pattern; make sure we don't allow more.\n+            let rest_span = match pat.kind {\n+                PatKind::Rest => Some(pat.span),\n+                PatKind::Ident(ref bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    // #69103: Lower into `binding @ _` as above to avoid ICEs.\n+                    after.push(lower_rest_sub(self, pat, bm, ident, sub));\n+                    Some(sub.span)\n+                }\n+                _ => None,\n+            };\n+            if let Some(rest_span) = rest_span {\n+                // We have e.g., `[a, .., b, ..]`. That's no good, error!\n+                self.ban_extra_rest_pat(rest_span, prev_rest_span.unwrap(), \"slice\");\n+            } else {\n+                // Lower the pattern normally.\n+                after.push(self.lower_pat(pat));\n+            }\n+        }\n+\n+        hir::PatKind::Slice(\n+            self.arena.alloc_from_iter(before),\n+            slice,\n+            self.arena.alloc_from_iter(after),\n+        )\n+    }\n+\n+    fn lower_pat_ident(\n+        &mut self,\n+        p: &Pat,\n+        binding_mode: &BindingMode,\n+        ident: Ident,\n+        lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n+    ) -> hir::PatKind<'hir> {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+            // `None` can occur in body-less function signatures\n+            res @ (None | Some(Res::Local(_))) => {\n+                let canonical_id = match res {\n+                    Some(Res::Local(id)) => id,\n+                    _ => p.id,\n+                };\n+\n+                hir::PatKind::Binding(\n+                    self.lower_binding_mode(binding_mode),\n+                    self.lower_node_id(canonical_id),\n+                    ident,\n+                    lower_sub(self),\n+                )\n+            }\n+            Some(res) => hir::PatKind::Path(hir::QPath::Resolved(\n+                None,\n+                self.arena.alloc(hir::Path {\n+                    span: ident.span,\n+                    res: self.lower_res(res),\n+                    segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n+                }),\n+            )),\n+        }\n+    }\n+\n+    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n+        match *b {\n+            BindingMode::ByValue(Mutability::Not) => hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Not) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mut) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mut) => hir::BindingAnnotation::RefMut,\n+        }\n+    }\n+\n+    fn pat_wild_with_node_id_of(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+        self.pat_with_node_id_of(p, hir::PatKind::Wild)\n+    }\n+\n+    /// Construct a `Pat` with the `HirId` of `p.id` lowered.\n+    fn pat_with_node_id_of(&mut self, p: &Pat, kind: hir::PatKind<'hir>) -> &'hir hir::Pat<'hir> {\n+        self.arena.alloc(hir::Pat { hir_id: self.lower_node_id(p.id), kind, span: p.span })\n+    }\n+\n+    /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n+    fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+        self.diagnostic()\n+            .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n+            .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))\n+            .span_label(prev_sp, \"previously used here\")\n+            .emit();\n+    }\n+\n+    /// Used to ban the `..` pattern in places it shouldn't be semantically.\n+    fn ban_illegal_rest_pat(&self, sp: Span) -> hir::PatKind<'hir> {\n+        self.diagnostic()\n+            .struct_span_err(sp, \"`..` patterns are not allowed here\")\n+            .note(\"only allowed in tuple, tuple struct, and slice patterns\")\n+            .emit();\n+\n+        // We're not in a list context so `..` can be reasonably treated\n+        // as `_` because it should always be valid and roughly matches the\n+        // intent of `..` (notice that the rest of a single slot is that slot).\n+        hir::PatKind::Wild\n+    }\n+\n+    fn lower_range_end(&mut self, e: &RangeEnd, has_end: bool) -> hir::RangeEnd {\n+        match *e {\n+            RangeEnd::Excluded if has_end => hir::RangeEnd::Excluded,\n+            // No end; so `X..` behaves like `RangeFrom`.\n+            RangeEnd::Excluded | RangeEnd::Included(_) => hir::RangeEnd::Included,\n+        }\n+    }\n+}"}, {"sha": "cf68dfb9ae1a143f07b288806236696fceede8cc", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,433 @@\n+use super::{AnonymousLifetimeMode, ImplTraitContext, LoweringContext, ParamMode};\n+use super::{GenericArgsCtor, ParenthesizedGenericArgs};\n+\n+use rustc_ast::{self as ast, *};\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, PartialRes, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::GenericArg;\n+use rustc_session::lint::builtin::ELIDED_LIFETIMES_IN_PATHS;\n+use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::symbol::Ident;\n+use rustc_span::Span;\n+\n+use smallvec::smallvec;\n+use tracing::debug;\n+\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    crate fn lower_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: &Option<QSelf>,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::QPath<'hir> {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx.reborrow()));\n+\n+        let partial_res =\n+            self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+\n+        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let path = self.arena.alloc(hir::Path {\n+            res: self.lower_res(partial_res.base_res()),\n+            segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n+                |(i, segment)| {\n+                    let param_mode = match (qself_position, param_mode) {\n+                        (Some(j), ParamMode::Optional) if i < j => {\n+                            // This segment is part of the trait path in a\n+                            // qualified path - one of `a`, `b` or `Trait`\n+                            // in `<X as a::b::Trait>::T::U::method`.\n+                            ParamMode::Explicit\n+                        }\n+                        _ => param_mode,\n+                    };\n+\n+                    // Figure out if this is a type/trait segment,\n+                    // which may need lifetime elision performed.\n+                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n+                        krate: def_id.krate,\n+                        index: this.resolver.def_key(def_id).parent.expect(\"missing parent\"),\n+                    };\n+                    let type_def_id = match partial_res.base_res() {\n+                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n+                            Some(parent_def_id(self, def_id))\n+                        }\n+                        Res::Def(DefKind::Struct, def_id)\n+                        | Res::Def(DefKind::Union, def_id)\n+                        | Res::Def(DefKind::Enum, def_id)\n+                        | Res::Def(DefKind::TyAlias, def_id)\n+                        | Res::Def(DefKind::Trait, def_id)\n+                            if i + 1 == proj_start =>\n+                        {\n+                            Some(def_id)\n+                        }\n+                        _ => None,\n+                    };\n+                    let parenthesized_generic_args = match partial_res.base_res() {\n+                        // `a::b::Trait(Args)`\n+                        Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // `a::b::Trait(Args)::TraitItem`\n+                        Res::Def(DefKind::AssocFn, _)\n+                        | Res::Def(DefKind::AssocConst, _)\n+                        | Res::Def(DefKind::AssocTy, _)\n+                            if i + 2 == proj_start =>\n+                        {\n+                            ParenthesizedGenericArgs::Ok\n+                        }\n+                        // Avoid duplicated errors.\n+                        Res::Err => ParenthesizedGenericArgs::Ok,\n+                        // An error\n+                        _ => ParenthesizedGenericArgs::Err,\n+                    };\n+\n+                    let num_lifetimes = type_def_id.map_or(0, |def_id| {\n+                        if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n+                            return n;\n+                        }\n+                        assert!(!def_id.is_local());\n+                        let n = self.resolver.item_generics_num_lifetimes(def_id, self.sess);\n+                        self.type_def_lifetime_params.insert(def_id, n);\n+                        n\n+                    });\n+                    self.lower_path_segment(\n+                        p.span,\n+                        segment,\n+                        param_mode,\n+                        num_lifetimes,\n+                        parenthesized_generic_args,\n+                        itctx.reborrow(),\n+                        None,\n+                    )\n+                },\n+            )),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if partial_res.unresolved_segments() == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g., `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g., `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            let new_id = self.next_id();\n+            self.arena.alloc(self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path)))\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g., for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = self.arena.alloc(self.lower_path_segment(\n+                p.span,\n+                segment,\n+                param_mode,\n+                0,\n+                ParenthesizedGenericArgs::Err,\n+                itctx.reborrow(),\n+                None,\n+            ));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            let new_id = self.next_id();\n+            ty = self.arena.alloc(self.ty_path(new_id, p.span, qpath));\n+        }\n+\n+        // We should've returned in the for loop above.\n+\n+        self.sess.diagnostic().span_bug(\n+            p.span,\n+            &format!(\n+                \"lower_qpath: no final extension segment in {}..{}\",\n+                proj_start,\n+                p.segments.len()\n+            ),\n+        );\n+    }\n+\n+    crate fn lower_path_extra(\n+        &mut self,\n+        res: Res,\n+        p: &Path,\n+        param_mode: ParamMode,\n+        explicit_owner: Option<NodeId>,\n+    ) -> &'hir hir::Path<'hir> {\n+        self.arena.alloc(hir::Path {\n+            res,\n+            segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n+                self.lower_path_segment(\n+                    p.span,\n+                    segment,\n+                    param_mode,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    explicit_owner,\n+                )\n+            })),\n+            span: p.span,\n+        })\n+    }\n+\n+    crate fn lower_path(\n+        &mut self,\n+        id: NodeId,\n+        p: &Path,\n+        param_mode: ParamMode,\n+    ) -> &'hir hir::Path<'hir> {\n+        let res = self.expect_full_res(id);\n+        let res = self.lower_res(res);\n+        self.lower_path_extra(res, p, param_mode, None)\n+    }\n+\n+    crate fn lower_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        segment: &PathSegment,\n+        param_mode: ParamMode,\n+        expected_lifetimes: usize,\n+        parenthesized_generic_args: ParenthesizedGenericArgs,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::PathSegment<'hir> {\n+        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n+            let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n+            match **generic_args {\n+                GenericArgs::AngleBracketed(ref data) => {\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n+                }\n+                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Err => {\n+                        let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n+                        err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n+                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n+                            // Do not suggest going from `Trait()` to `Trait<>`\n+                            if !data.inputs.is_empty() {\n+                                if let Some(split) = snippet.find('(') {\n+                                    let trait_name = &snippet[0..split];\n+                                    let args = &snippet[split + 1..snippet.len() - 1];\n+                                    err.span_suggestion(\n+                                        data.span,\n+                                        \"use angle brackets instead\",\n+                                        format!(\"{}<{}>\", trait_name, args),\n+                                        Applicability::MaybeIncorrect,\n+                                    );\n+                                }\n+                            }\n+                        };\n+                        err.emit();\n+                        (\n+                            self.lower_angle_bracketed_parameter_data(\n+                                &data.as_angle_bracketed_args(),\n+                                param_mode,\n+                                itctx,\n+                            )\n+                            .0,\n+                            false,\n+                        )\n+                    }\n+                },\n+            }\n+        } else {\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n+        };\n+\n+        let has_lifetimes = generic_args.args.iter().any(|arg| match arg {\n+            GenericArg::Lifetime(_) => true,\n+            _ => false,\n+        });\n+        let first_generic_span = generic_args\n+            .args\n+            .iter()\n+            .map(|a| a.span())\n+            .chain(generic_args.bindings.iter().map(|b| b.span))\n+            .next();\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            generic_args.args = self\n+                .elided_path_lifetimes(\n+                    first_generic_span.map(|s| s.shrink_to_lo()).unwrap_or(segment.ident.span),\n+                    expected_lifetimes,\n+                )\n+                .map(GenericArg::Lifetime)\n+                .chain(generic_args.args.into_iter())\n+                .collect();\n+            if expected_lifetimes > 0 && param_mode == ParamMode::Explicit {\n+                let anon_lt_suggestion = vec![\"'_\"; expected_lifetimes].join(\", \");\n+                let no_non_lt_args = generic_args.args.len() == expected_lifetimes;\n+                let no_bindings = generic_args.bindings.is_empty();\n+                let (incl_angl_brckt, insertion_sp, suggestion) = if no_non_lt_args && no_bindings {\n+                    // If there are no (non-implicit) generic args or associated type\n+                    // bindings, our suggestion includes the angle brackets.\n+                    (true, path_span.shrink_to_hi(), format!(\"<{}>\", anon_lt_suggestion))\n+                } else {\n+                    // Otherwise (sorry, this is kind of gross) we need to infer the\n+                    // place to splice in the `'_, ` from the generics that do exist.\n+                    let first_generic_span = first_generic_span\n+                        .expect(\"already checked that non-lifetime args or bindings exist\");\n+                    (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n+                };\n+                match self.anonymous_lifetime_mode {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        rustc_session::lint::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess,\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            incl_angl_brckt,\n+                            insertion_sp,\n+                            suggestion,\n+                        );\n+                        err.emit();\n+                    }\n+                    AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n+                        self.resolver.lint_buffer().buffer_lint_with_diagnostic(\n+                            ELIDED_LIFETIMES_IN_PATHS,\n+                            CRATE_NODE_ID,\n+                            path_span,\n+                            \"hidden lifetime parameters in types are deprecated\",\n+                            BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                                expected_lifetimes,\n+                                path_span,\n+                                incl_angl_brckt,\n+                                insertion_sp,\n+                                suggestion,\n+                            ),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        let res = self.expect_full_res(segment.id);\n+        let id = if let Some(owner) = explicit_owner {\n+            self.lower_node_id_with_owner(segment.id, owner)\n+        } else {\n+            self.lower_node_id(segment.id)\n+        };\n+        debug!(\n+            \"lower_path_segment: ident={:?} original-id={:?} new-id={:?}\",\n+            segment.ident, segment.id, id,\n+        );\n+\n+        hir::PathSegment {\n+            ident: segment.ident,\n+            hir_id: Some(id),\n+            res: Some(self.lower_res(res)),\n+            infer_args,\n+            args: if generic_args.is_empty() {\n+                None\n+            } else {\n+                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n+            },\n+        }\n+    }\n+\n+    fn lower_angle_bracketed_parameter_data(\n+        &mut self,\n+        data: &AngleBracketedArgs,\n+        param_mode: ParamMode,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        let has_non_lt_args = data.args.iter().any(|arg| match arg {\n+            AngleBracketedArg::Arg(ast::GenericArg::Lifetime(_))\n+            | AngleBracketedArg::Constraint(_) => false,\n+            AngleBracketedArg::Arg(ast::GenericArg::Type(_) | ast::GenericArg::Const(_)) => true,\n+        });\n+        let args = data\n+            .args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                AngleBracketedArg::Arg(arg) => Some(self.lower_generic_arg(arg, itctx.reborrow())),\n+                AngleBracketedArg::Constraint(_) => None,\n+            })\n+            .collect();\n+        let bindings = self.arena.alloc_from_iter(data.args.iter().filter_map(|arg| match arg {\n+            AngleBracketedArg::Constraint(c) => {\n+                Some(self.lower_assoc_ty_constraint(c, itctx.reborrow()))\n+            }\n+            AngleBracketedArg::Arg(_) => None,\n+        }));\n+        let ctor = GenericArgsCtor { args, bindings, parenthesized: false };\n+        (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n+    }\n+\n+    fn lower_parenthesized_parameter_data(\n+        &mut self,\n+        data: &ParenthesizedArgs,\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n+        // Switch to `PassThrough` mode for anonymous lifetimes; this\n+        // means that we permit things like `&Ref<T>`, where `Ref` has\n+        // a hidden lifetime parameter. This is needed for backwards\n+        // compatibility, even in contexts like an impl header where\n+        // we generally don't permit such things (see #51008).\n+        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n+            let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n+            let inputs = this.arena.alloc_from_iter(\n+                inputs.iter().map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed())),\n+            );\n+            let output_ty = match output {\n+                FnRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n+            };\n+            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let binding = this.output_ty_binding(output_ty.span, output_ty);\n+            (\n+                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                false,\n+            )\n+        })\n+    }\n+\n+    /// An associated type binding `Output = $ty`.\n+    crate fn output_ty_binding(\n+        &mut self,\n+        span: Span,\n+        ty: &'hir hir::Ty<'hir>,\n+    ) -> hir::TypeBinding<'hir> {\n+        let ident = Ident::with_dummy_span(hir::FN_OUTPUT_NAME);\n+        let kind = hir::TypeBindingKind::Equality { ty };\n+        hir::TypeBinding { hir_id: self.next_id(), span, ident, kind }\n+    }\n+}"}, {"sha": "7cf3e752c9256821de082632a3cd4df7f33b9358", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ast_passes\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[dependencies]\n+itertools = \"0.8\"\n+tracing = \"0.1\"\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_attr = { path = \"../rustc_attr\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_parse = { path = \"../rustc_parse\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_ast = { path = \"../rustc_ast\" }"}, {"sha": "a01dd8c939cf6a7460f59510c2877686fc568161", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "renamed", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -7,12 +7,10 @@\n // or type checking or some other kind of complex analysis.\n \n use itertools::{Either, Itertools};\n-use rustc_ast::ast::*;\n-use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n+use rustc_ast::*;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{error_code, pluralize, struct_span_err, Applicability};\n@@ -775,8 +773,14 @@ fn validate_generic_param_order<'a>(\n         err.span_suggestion(\n             span,\n             &format!(\n-                \"reorder the parameters: lifetimes, then types{}\",\n-                if sess.features_untracked().const_generics { \", then consts\" } else { \"\" },\n+                \"reorder the parameters: lifetimes{}\",\n+                if sess.features_untracked().const_generics {\n+                    \", then consts and types\"\n+                } else if sess.features_untracked().min_const_generics {\n+                    \", then types, then consts\"\n+                } else {\n+                    \", then types\"\n+                },\n             ),\n             ordered_params.clone(),\n             Applicability::MachineApplicable,\n@@ -891,11 +895,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::no_mangle) {\n+        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -1027,7 +1031,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(Mod { inline, .. }) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !attr::contains_name(&item.attrs, sym::path) {\n+                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n@@ -1152,7 +1156,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n                     GenericParamKind::Const { ref ty, kw_span: _ } => {\n                         let ty = pprust::ty_to_string(ty);\n-                        (ParamKindOrd::Const, Some(format!(\"const {}: {}\", param.ident, ty)))\n+                        let unordered = self.session.features_untracked().const_generics;\n+                        (\n+                            ParamKindOrd::Const { unordered },\n+                            Some(format!(\"const {}: {}\", param.ident, ty)),\n+                        )\n                     }\n                 };\n                 (kind, Some(&*param.bounds), param.ident.span, ident)", "previous_filename": "src/librustc_ast_passes/ast_validation.rs"}, {"sha": "0ee8ef55e61bff6010fe7a974e46b9c58100478e", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "renamed", "additions": 51, "deletions": 46, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,40 +1,45 @@\n-use rustc_ast::ast::{self, AssocTyConstraint, AssocTyConstraintKind, NodeId};\n-use rustc_ast::ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n-use rustc_ast::attr;\n+use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_errors::{struct_span_err, Handler};\n+use rustc_ast::{AssocTyConstraint, AssocTyConstraintKind, NodeId};\n+use rustc_ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n+use rustc_errors::struct_span_err;\n use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Features, GateIssue, UnstableFeatures};\n-use rustc_session::parse::{feature_err, feature_err_issue, ParseSess};\n+use rustc_feature::{Features, GateIssue};\n+use rustc_session::parse::{feature_err, feature_err_issue};\n+use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n+use tracing::debug;\n \n macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n-        let (cx, has_feature, span, name, explain) = (&*$cx, $has_feature, $span, $name, $explain);\n-        let has_feature: bool = has_feature(&$cx.features);\n+    ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (visitor, has_feature, span, name, explain) =\n+            (&*$visitor, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(cx.parse_sess, name, span, GateIssue::Language, explain).emit();\n+            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n+                .emit();\n         }\n     }};\n }\n \n macro_rules! gate_feature_post {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!($cx, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n+    ($visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n }\n \n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    PostExpansionVisitor { parse_sess, features }.visit_attribute(attr)\n+pub fn check_attribute(attr: &ast::Attribute, sess: &Session, features: &Features) {\n+    PostExpansionVisitor { sess, features }.visit_attribute(attr)\n }\n \n struct PostExpansionVisitor<'a> {\n-    parse_sess: &'a ParseSess,\n+    sess: &'a Session,\n+\n+    // `sess` contains a `Features`, but this might not be that one.\n     features: &'a Features,\n }\n \n@@ -138,6 +143,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                 );\n             }\n             abi => self\n+                .sess\n                 .parse_sess\n                 .span_diagnostic\n                 .delay_span_bug(span, &format!(\"unrecognized ABI not caught in lowering: {}\", abi)),\n@@ -167,7 +173,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n         if !discriminant_spans.is_empty() && has_fields {\n             let mut err = feature_err(\n-                self.parse_sess,\n+                &self.sess.parse_sess,\n                 sym::arbitrary_enum_discriminant,\n                 discriminant_spans.clone(),\n                 \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n@@ -240,10 +246,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_fn!(self, has_feature, attr.span, name, descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n-        if attr.check_name(sym::doc) {\n+        if self.sess.check_name(attr, sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n-                    $(if nested_meta.check_name(sym::$name) {\n+                    $(if nested_meta.has_name(sym::$name) {\n                         let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n                         gate_feature_post!(self, $feature, attr.span, msg);\n                     })*\n@@ -266,7 +272,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.parse_sess.source_map().guess_head_span(sp),\n+                self.sess.parse_sess.source_map().guess_head_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }\n@@ -281,15 +287,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                if self.sess.contains_name(&i.attrs[..], sym::plugin_registrar) {\n                     gate_feature_post!(\n                         &self,\n                         plugin_registrar,\n                         i.span,\n                         \"compiler plugins are experimental and possibly buggy\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::start) {\n+                if self.sess.contains_name(&i.attrs[..], sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -299,7 +305,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                          over time\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::main) {\n+                if self.sess.contains_name(&i.attrs[..], sym::main) {\n                     gate_feature_post!(\n                         &self,\n                         main,\n@@ -312,9 +318,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                for attr in self.sess.filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n-                        if item.check_name(sym::simd) {\n+                        if item.has_name(sym::simd) {\n                             gate_feature_post!(\n                                 &self,\n                                 repr_simd,\n@@ -391,7 +397,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm = match link_name {\n                     Some(val) => val.as_str().starts_with(\"llvm.\"),\n                     _ => false,\n@@ -450,7 +456,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Type(..) => {\n                 // To avoid noise about type ascription in common syntax errors, only emit if it\n                 // is the *only* error.\n-                if self.parse_sess.span_diagnostic.err_count() == 0 {\n+                if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n                     gate_feature_post!(\n                         &self,\n                         type_ascription,\n@@ -526,12 +532,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n         if let GenericParamKind::Const { .. } = param.kind {\n-            gate_feature_post!(\n+            gate_feature_fn!(\n                 &self,\n-                const_generics,\n+                |x: &Features| x.const_generics || x.min_const_generics,\n                 param.ident.span,\n+                sym::min_const_generics,\n                 \"const generics are unstable\"\n-            )\n+            );\n         }\n         visit::walk_generic_param(self, param)\n     }\n@@ -599,23 +606,21 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n }\n \n-pub fn check_crate(\n-    krate: &ast::Crate,\n-    parse_sess: &ParseSess,\n-    features: &Features,\n-    unstable: UnstableFeatures,\n-) {\n-    maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n-    let mut visitor = PostExpansionVisitor { parse_sess, features };\n+pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n+    maybe_stage_features(sess, krate);\n+    let mut visitor = PostExpansionVisitor { sess, features: &sess.features_untracked() };\n \n-    let spans = parse_sess.gated_spans.spans.borrow();\n+    let spans = sess.parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n-            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n-                gate_feature_post!(&visitor, $gate, *span, $msg);\n+            if let Some(spans) = spans.get(&sym::$gate) {\n+                for span in spans {\n+                    gate_feature_post!(&visitor, $gate, *span, $msg);\n+                }\n             }\n         };\n     }\n+    gate_all!(if_let_guard, \"`if let` guard is not implemented\");\n     gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure, \"async closures are unstable\");\n     gate_all!(generators, \"yield syntax is experimental\");\n@@ -651,18 +656,18 @@ pub fn check_crate(\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n-    if parse_sess.span_diagnostic.err_count() == 0 {\n+    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n         gate_all!(type_ascription, \"type ascription is experimental\");\n     }\n \n     visit::walk_crate(&mut visitor, krate);\n }\n \n-fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n-    if !unstable.is_nightly_build() {\n-        for attr in krate.attrs.iter().filter(|attr| attr.check_name(sym::feature)) {\n+fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n+    if !sess.opts.unstable_features.is_nightly_build() {\n+        for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n             struct_span_err!(\n-                span_handler,\n+                sess.parse_sess.span_diagnostic,\n                 attr.span,\n                 E0554,\n                 \"`#![feature]` may not be used on the {} release channel\",", "previous_filename": "src/librustc_ast_passes/feature_gate.rs"}, {"sha": "bfe304419801d5f2c7833170ceb6eaa5012ce23b", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast_passes/lib.rs"}, {"sha": "706dca2b7f45558c9eb5261c87ee358a8203e886", "filename": "compiler/rustc_ast_passes/src/node_count.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fnode_count.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,7 +1,7 @@\n // Simply gives a rough count of the number of nodes in an AST.\n \n-use rustc_ast::ast::*;\n use rustc_ast::visit::*;\n+use rustc_ast::*;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n ", "previous_filename": "src/librustc_ast_passes/node_count.rs"}, {"sha": "053aba862227188ae24e172135da505ef630fe28", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -5,7 +5,7 @@\n \n use std::str::FromStr;\n \n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n ", "previous_filename": "src/librustc_ast_passes/show_span.rs"}, {"sha": "f447bc7f4efba2ef652a8fc85a8cf81a8a5656e2", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ast_pretty\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+tracing = \"0.1\"\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_target = { path = \"../rustc_target\" }"}, {"sha": "dce856df9c66abeb4087f173ce29b64ea929f0e9", "filename": "compiler/rustc_ast_pretty/src/helpers.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fhelpers.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast_pretty/helpers.rs"}, {"sha": "9adc6c604e8abe8cb4a6fcdf5b7ce08c0064d3a7", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_ast_pretty/lib.rs"}, {"sha": "ca7f127ced60d4c5111e24ee4ce8b3b2ea7f719b", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -132,10 +132,10 @@\n //! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n-use log::debug;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::fmt;\n+use tracing::debug;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]", "previous_filename": "src/librustc_ast_pretty/pp.rs"}, {"sha": "cb48deb58863e4cc459c937dab1479ed814862df", "filename": "compiler/rustc_ast_pretty/src/pprust.rs", "status": "renamed", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,17 +1,18 @@\n use crate::pp::Breaks::{Consistent, Inconsistent};\n use crate::pp::{self, Breaks};\n \n-use rustc_ast::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::ast::{Attribute, GenericArg, MacArgs};\n-use rustc_ast::ast::{GenericBound, SelfKind, TraitBoundModifier};\n-use rustc_ast::ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n-use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::util::classify;\n+use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n-use rustc_ast::util::{classify, comments};\n+use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n+use rustc_ast::{GenericArg, MacArgs};\n+use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n@@ -50,27 +51,27 @@ impl PpAnn for NoAnn {}\n \n pub struct Comments<'a> {\n     sm: &'a SourceMap,\n-    comments: Vec<comments::Comment>,\n+    comments: Vec<Comment>,\n     current: usize,\n }\n \n impl<'a> Comments<'a> {\n     pub fn new(sm: &'a SourceMap, filename: FileName, input: String) -> Comments<'a> {\n-        let comments = comments::gather_comments(sm, filename, input);\n+        let comments = gather_comments(sm, filename, input);\n         Comments { sm, comments, current: 0 }\n     }\n \n-    pub fn next(&self) -> Option<comments::Comment> {\n+    pub fn next(&self) -> Option<Comment> {\n         self.comments.get(self.current).cloned()\n     }\n \n     pub fn trailing_comment(\n         &mut self,\n         span: rustc_span::Span,\n         next_pos: Option<BytePos>,\n-    ) -> Option<comments::Comment> {\n+    ) -> Option<Comment> {\n         if let Some(cmnt) = self.next() {\n-            if cmnt.style != comments::Trailing {\n+            if cmnt.style != CommentStyle::Trailing {\n                 return None;\n             }\n             let span_line = self.sm.lookup_char_pos(span.hi());\n@@ -152,8 +153,8 @@ pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n     if let TokenTree::Token(token) = prev {\n-        if let token::DocComment(s) = token.kind {\n-            return !s.as_str().starts_with(\"//\");\n+        if let token::DocComment(comment_kind, ..) = token.kind {\n+            return comment_kind != CommentKind::Line;\n         }\n     }\n     match tt {\n@@ -194,6 +195,19 @@ fn binop_to_string(op: BinOpToken) -> &'static str {\n     }\n }\n \n+fn doc_comment_to_string(\n+    comment_kind: CommentKind,\n+    attr_style: ast::AttrStyle,\n+    data: Symbol,\n+) -> String {\n+    match (comment_kind, attr_style) {\n+        (CommentKind::Line, ast::AttrStyle::Outer) => format!(\"///{}\", data),\n+        (CommentKind::Line, ast::AttrStyle::Inner) => format!(\"//!{}\", data),\n+        (CommentKind::Block, ast::AttrStyle::Outer) => format!(\"/**{}*/\", data),\n+        (CommentKind::Block, ast::AttrStyle::Inner) => format!(\"/*!{}*/\", data),\n+    }\n+}\n+\n pub fn literal_to_string(lit: token::Lit) -> String {\n     let token::Lit { kind, symbol, suffix } = lit;\n     let mut out = match kind {\n@@ -271,7 +285,9 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Lifetime(s) => s.to_string(),\n \n         /* Other */\n-        token::DocComment(s) => s.to_string(),\n+        token::DocComment(comment_kind, attr_style, data) => {\n+            doc_comment_to_string(comment_kind, attr_style, data)\n+        }\n         token::Eof => \"<eof>\".to_string(),\n         token::Whitespace => \" \".to_string(),\n         token::Comment => \"/* */\".to_string(),\n@@ -447,10 +463,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn print_comment(&mut self, cmnt: &comments::Comment) {\n+    fn print_comment(&mut self, cmnt: &Comment) {\n         match cmnt.style {\n-            comments::Mixed => {\n-                self.zerobreak();\n+            CommentStyle::Mixed => {\n+                if !self.is_beginning_of_line() {\n+                    self.zerobreak();\n+                }\n                 if let Some((last, lines)) = cmnt.lines.split_last() {\n                     self.ibox(0);\n \n@@ -466,7 +484,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 }\n                 self.zerobreak()\n             }\n-            comments::Isolated => {\n+            CommentStyle::Isolated => {\n                 self.hardbreak_if_not_bol();\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n@@ -477,7 +495,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.hardbreak();\n                 }\n             }\n-            comments::Trailing => {\n+            CommentStyle::Trailing => {\n                 if !self.is_beginning_of_line() {\n                     self.word(\" \");\n                 }\n@@ -495,7 +513,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.end();\n                 }\n             }\n-            comments::BlankLine => {\n+            CommentStyle::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let twice = match self.last_token() {\n                     pp::Token::String(s) => \";\" == s,\n@@ -514,7 +532,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn next_comment(&mut self) -> Option<comments::Comment> {\n+    fn next_comment(&mut self) -> Option<Comment> {\n         self.comments().as_mut().and_then(|c| c.next())\n     }\n \n@@ -597,8 +615,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_attr_item(&item, attr.span);\n                 self.word(\"]\");\n             }\n-            ast::AttrKind::DocComment(comment) => {\n-                self.word(comment.to_string());\n+            ast::AttrKind::DocComment(comment_kind, data) => {\n+                self.word(doc_comment_to_string(comment_kind, attr.style, data));\n                 self.hardbreak()\n             }\n         }\n@@ -884,7 +902,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[Attribute]) {\n+    crate fn print_foreign_mod(&mut self, nmod: &ast::ForeignMod, attrs: &[ast::Attribute]) {\n         self.print_inner_attributes(attrs);\n         for item in &nmod.items {\n             self.print_foreign_item(item);\n@@ -1648,7 +1666,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>], attrs: &[Attribute]) {\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>], attrs: &[ast::Attribute]) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n         self.print_inner_attributes_inline(attrs);\n@@ -1661,7 +1679,7 @@ impl<'a> State<'a> {\n         &mut self,\n         element: &ast::Expr,\n         count: &ast::AnonConst,\n-        attrs: &[Attribute],\n+        attrs: &[ast::Attribute],\n     ) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n@@ -1678,7 +1696,7 @@ impl<'a> State<'a> {\n         path: &ast::Path,\n         fields: &[ast::Field],\n         wth: &Option<P<ast::Expr>>,\n-        attrs: &[Attribute],\n+        attrs: &[ast::Attribute],\n     ) {\n         self.print_path(path, true, 0);\n         self.s.word(\"{\");\n@@ -1718,7 +1736,7 @@ impl<'a> State<'a> {\n         self.s.word(\"}\");\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>], attrs: &[Attribute]) {\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>], attrs: &[ast::Attribute]) {\n         self.popen();\n         self.print_inner_attributes_inline(attrs);\n         self.commasep_exprs(Inconsistent, &exprs[..]);", "previous_filename": "src/librustc_ast_pretty/pprust.rs"}, {"sha": "fdbf3feb900ef2d7c917f9bf3b02cd86605631bb", "filename": "compiler/rustc_ast_pretty/src/pprust/tests.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,60 @@\n+use super::*;\n+\n+use rustc_ast as ast;\n+use rustc_span::source_map::respan;\n+use rustc_span::symbol::Ident;\n+use rustc_span::with_default_session_globals;\n+\n+fn fun_to_string(\n+    decl: &ast::FnDecl,\n+    header: ast::FnHeader,\n+    name: Ident,\n+    generics: &ast::Generics,\n+) -> String {\n+    to_string(|s| {\n+        s.head(\"\");\n+        s.print_fn(decl, header, Some(name), generics);\n+        s.end(); // Close the head box.\n+        s.end(); // Close the outer box.\n+    })\n+}\n+\n+fn variant_to_string(var: &ast::Variant) -> String {\n+    to_string(|s| s.print_variant(var))\n+}\n+\n+#[test]\n+fn test_fun_to_string() {\n+    with_default_session_globals(|| {\n+        let abba_ident = Ident::from_str(\"abba\");\n+\n+        let decl =\n+            ast::FnDecl { inputs: Vec::new(), output: ast::FnRetTy::Default(rustc_span::DUMMY_SP) };\n+        let generics = ast::Generics::default();\n+        assert_eq!(\n+            fun_to_string(&decl, ast::FnHeader::default(), abba_ident, &generics),\n+            \"fn abba()\"\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_variant_to_string() {\n+    with_default_session_globals(|| {\n+        let ident = Ident::from_str(\"principal_skinner\");\n+\n+        let var = ast::Variant {\n+            ident,\n+            vis: respan(rustc_span::DUMMY_SP, ast::VisibilityKind::Inherited),\n+            attrs: Vec::new(),\n+            id: ast::DUMMY_NODE_ID,\n+            data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n+            disr_expr: None,\n+            span: rustc_span::DUMMY_SP,\n+            is_placeholder: false,\n+        };\n+\n+        let varstr = variant_to_string(&var);\n+        assert_eq!(varstr, \"principal_skinner\");\n+    })\n+}"}, {"sha": "5f941a0a650f8857bfd99851b9c8eb3b0e1d2504", "filename": "compiler/rustc_attr/Cargo.toml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,21 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_attr\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_lexer = { path = \"../rustc_lexer\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n+version_check = \"0.9\""}, {"sha": "b8929fe08891305eb65e8ffa828164311b298c3a", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "added", "additions": 1041, "deletions": 0, "changes": 1041, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1041 @@\n+//! Parsing and validation of builtin attributes\n+\n+use rustc_ast::{self as ast, Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::{struct_span_err, Applicability};\n+use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n+use rustc_macros::HashStable_Generic;\n+use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::Session;\n+use rustc_span::hygiene::Transparency;\n+use rustc_span::{symbol::sym, symbol::Symbol, Span};\n+use std::num::NonZeroU32;\n+use version_check::Version;\n+\n+pub fn is_builtin_attr(attr: &Attribute) -> bool {\n+    attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n+}\n+\n+enum AttrError {\n+    MultipleItem(String),\n+    UnknownMetaItem(String, &'static [&'static str]),\n+    MissingSince,\n+    NonIdentFeature,\n+    MissingFeature,\n+    MultipleStabilityLevels,\n+    UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n+}\n+\n+fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n+    let diag = &sess.span_diagnostic;\n+    match error {\n+        AttrError::MultipleItem(item) => {\n+            struct_span_err!(diag, span, E0538, \"multiple '{}' items\", item).emit();\n+        }\n+        AttrError::UnknownMetaItem(item, expected) => {\n+            let expected = expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n+            struct_span_err!(diag, span, E0541, \"unknown meta item '{}'\", item)\n+                .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n+                .emit();\n+        }\n+        AttrError::MissingSince => {\n+            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+        }\n+        AttrError::NonIdentFeature => {\n+            struct_span_err!(diag, span, E0546, \"'feature' is not an identifier\").emit();\n+        }\n+        AttrError::MissingFeature => {\n+            struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n+        }\n+        AttrError::MultipleStabilityLevels => {\n+            struct_span_err!(diag, span, E0544, \"multiple stability levels\").emit();\n+        }\n+        AttrError::UnsupportedLiteral(msg, is_bytestr) => {\n+            let mut err = struct_span_err!(diag, span, E0565, \"{}\", msg);\n+            if is_bytestr {\n+                if let Ok(lint_str) = sess.source_map().span_to_snippet(span) {\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider removing the prefix\",\n+                        lint_str[1..].to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Encodable, Decodable)]\n+pub enum InlineAttr {\n+    None,\n+    Hint,\n+    Always,\n+    Never,\n+}\n+\n+#[derive(Clone, Encodable, Decodable)]\n+pub enum OptimizeAttr {\n+    None,\n+    Speed,\n+    Size,\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum UnwindAttr {\n+    Allowed,\n+    Aborts,\n+}\n+\n+/// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n+pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+    attrs.iter().fold(None, |ia, attr| {\n+        if sess.check_name(attr, sym::unwind) {\n+            if let Some(meta) = attr.meta() {\n+                if let MetaItemKind::List(items) = meta.kind {\n+                    if items.len() == 1 {\n+                        if items[0].has_name(sym::allowed) {\n+                            return Some(UnwindAttr::Allowed);\n+                        } else if items[0].has_name(sym::aborts) {\n+                            return Some(UnwindAttr::Aborts);\n+                        }\n+                    }\n+\n+                    struct_span_err!(\n+                        sess.diagnostic(),\n+                        attr.span,\n+                        E0633,\n+                        \"malformed `unwind` attribute input\"\n+                    )\n+                    .span_label(attr.span, \"invalid argument\")\n+                    .span_suggestions(\n+                        attr.span,\n+                        \"the allowed arguments are `allowed` and `aborts`\",\n+                        (vec![\"allowed\", \"aborts\"])\n+                            .into_iter()\n+                            .map(|s| format!(\"#[unwind({})]\", s)),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+                }\n+            }\n+        }\n+\n+        ia\n+    })\n+}\n+\n+/// Represents the following attributes:\n+///\n+/// - `#[stable]`\n+/// - `#[unstable]`\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(HashStable_Generic)]\n+pub struct Stability {\n+    pub level: StabilityLevel,\n+    pub feature: Symbol,\n+}\n+\n+/// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(HashStable_Generic)]\n+pub struct ConstStability {\n+    pub level: StabilityLevel,\n+    pub feature: Symbol,\n+    /// whether the function has a `#[rustc_promotable]` attribute\n+    pub promotable: bool,\n+    /// whether the function has a `#[rustc_allow_const_fn_ptr]` attribute\n+    pub allow_const_fn_ptr: bool,\n+}\n+\n+/// The available stability levels.\n+#[derive(Encodable, Decodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n+#[derive(HashStable_Generic)]\n+pub enum StabilityLevel {\n+    // Reason for the current stability level and the relevant rust-lang issue\n+    Unstable { reason: Option<Symbol>, issue: Option<NonZeroU32>, is_soft: bool },\n+    Stable { since: Symbol },\n+}\n+\n+impl StabilityLevel {\n+    pub fn is_unstable(&self) -> bool {\n+        if let StabilityLevel::Unstable { .. } = *self { true } else { false }\n+    }\n+    pub fn is_stable(&self) -> bool {\n+        if let StabilityLevel::Stable { .. } = *self { true } else { false }\n+    }\n+}\n+\n+/// Collects stability info from all stability attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    item_sp: Span,\n+) -> (Option<Stability>, Option<ConstStability>) {\n+    find_stability_generic(sess, attrs.iter(), item_sp)\n+}\n+\n+fn find_stability_generic<'a, I>(\n+    sess: &Session,\n+    attrs_iter: I,\n+    item_sp: Span,\n+) -> (Option<Stability>, Option<ConstStability>)\n+where\n+    I: Iterator<Item = &'a Attribute>,\n+{\n+    use StabilityLevel::*;\n+\n+    let mut stab: Option<Stability> = None;\n+    let mut const_stab: Option<ConstStability> = None;\n+    let mut promotable = false;\n+    let mut allow_const_fn_ptr = false;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n+\n+    'outer: for attr in attrs_iter {\n+        if ![\n+            sym::rustc_const_unstable,\n+            sym::rustc_const_stable,\n+            sym::unstable,\n+            sym::stable,\n+            sym::rustc_promotable,\n+            sym::rustc_allow_const_fn_ptr,\n+        ]\n+        .iter()\n+        .any(|&s| attr.has_name(s))\n+        {\n+            continue; // not a stability level\n+        }\n+\n+        sess.mark_attr_used(attr);\n+\n+        let meta = attr.meta();\n+\n+        if attr.has_name(sym::rustc_promotable) {\n+            promotable = true;\n+        }\n+        if attr.has_name(sym::rustc_allow_const_fn_ptr) {\n+            allow_const_fn_ptr = true;\n+        }\n+        // attributes with data\n+        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n+            let meta = meta.as_ref().unwrap();\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                if item.is_some() {\n+                    handle_errors(\n+                        &sess.parse_sess,\n+                        meta.span,\n+                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+                    );\n+                    return false;\n+                }\n+                if let Some(v) = meta.value_str() {\n+                    *item = Some(v);\n+                    true\n+                } else {\n+                    struct_span_err!(diagnostic, meta.span, E0539, \"incorrect meta item\").emit();\n+                    false\n+                }\n+            };\n+\n+            let meta_name = meta.name_or_empty();\n+            match meta_name {\n+                sym::rustc_const_unstable | sym::unstable => {\n+                    if meta_name == sym::unstable && stab.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n+                        break;\n+                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n+                        break;\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut reason = None;\n+                    let mut issue = None;\n+                    let mut issue_num = None;\n+                    let mut is_soft = false;\n+                    for meta in metas {\n+                        if let Some(mi) = meta.meta_item() {\n+                            match mi.name_or_empty() {\n+                                sym::feature => {\n+                                    if !get(mi, &mut feature) {\n+                                        continue 'outer;\n+                                    }\n+                                }\n+                                sym::reason => {\n+                                    if !get(mi, &mut reason) {\n+                                        continue 'outer;\n+                                    }\n+                                }\n+                                sym::issue => {\n+                                    if !get(mi, &mut issue) {\n+                                        continue 'outer;\n+                                    }\n+\n+                                    // These unwraps are safe because `get` ensures the meta item\n+                                    // is a name/value pair string literal.\n+                                    issue_num = match &*issue.unwrap().as_str() {\n+                                        \"none\" => None,\n+                                        issue => {\n+                                            let emit_diag = |msg: &str| {\n+                                                struct_span_err!(\n+                                                    diagnostic,\n+                                                    mi.span,\n+                                                    E0545,\n+                                                    \"`issue` must be a non-zero numeric string \\\n+                                                    or \\\"none\\\"\",\n+                                                )\n+                                                .span_label(\n+                                                    mi.name_value_literal().unwrap().span,\n+                                                    msg,\n+                                                )\n+                                                .emit();\n+                                            };\n+                                            match issue.parse() {\n+                                                Ok(num) if num == 0 => {\n+                                                    emit_diag(\n+                                                        \"`issue` must not be \\\"0\\\", \\\n+                                                        use \\\"none\\\" instead\",\n+                                                    );\n+                                                    continue 'outer;\n+                                                }\n+                                                Ok(num) => NonZeroU32::new(num),\n+                                                Err(err) => {\n+                                                    emit_diag(&err.to_string());\n+                                                    continue 'outer;\n+                                                }\n+                                            }\n+                                        }\n+                                    };\n+                                }\n+                                sym::soft => {\n+                                    if !mi.is_word() {\n+                                        let msg = \"`soft` should not have any arguments\";\n+                                        sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n+                                    }\n+                                    is_soft = true;\n+                                }\n+                                _ => {\n+                                    handle_errors(\n+                                        &sess.parse_sess,\n+                                        meta.span(),\n+                                        AttrError::UnknownMetaItem(\n+                                            pprust::path_to_string(&mi.path),\n+                                            &[\"feature\", \"reason\", \"issue\", \"soft\"],\n+                                        ),\n+                                    );\n+                                    continue 'outer;\n+                                }\n+                            }\n+                        } else {\n+                            handle_errors(\n+                                &sess.parse_sess,\n+                                meta.span(),\n+                                AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                            );\n+                            continue 'outer;\n+                        }\n+                    }\n+\n+                    match (feature, reason, issue) {\n+                        (Some(feature), reason, Some(_)) => {\n+                            if !rustc_lexer::is_ident(&feature.as_str()) {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    attr.span,\n+                                    AttrError::NonIdentFeature,\n+                                );\n+                                continue;\n+                            }\n+                            let level = Unstable { reason, issue: issue_num, is_soft };\n+                            if sym::unstable == meta_name {\n+                                stab = Some(Stability { level, feature });\n+                            } else {\n+                                const_stab = Some(ConstStability {\n+                                    level,\n+                                    feature,\n+                                    promotable: false,\n+                                    allow_const_fn_ptr: false,\n+                                });\n+                            }\n+                        }\n+                        (None, _, _) => {\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+                            continue;\n+                        }\n+                        _ => {\n+                            struct_span_err!(diagnostic, attr.span, E0547, \"missing 'issue'\")\n+                                .emit();\n+                            continue;\n+                        }\n+                    }\n+                }\n+                sym::rustc_const_stable | sym::stable => {\n+                    if meta_name == sym::stable && stab.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n+                        break;\n+                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n+                        break;\n+                    }\n+\n+                    let mut feature = None;\n+                    let mut since = None;\n+                    for meta in metas {\n+                        match meta {\n+                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n+                                sym::feature => {\n+                                    if !get(mi, &mut feature) {\n+                                        continue 'outer;\n+                                    }\n+                                }\n+                                sym::since => {\n+                                    if !get(mi, &mut since) {\n+                                        continue 'outer;\n+                                    }\n+                                }\n+                                _ => {\n+                                    handle_errors(\n+                                        &sess.parse_sess,\n+                                        meta.span(),\n+                                        AttrError::UnknownMetaItem(\n+                                            pprust::path_to_string(&mi.path),\n+                                            &[\"since\", \"note\"],\n+                                        ),\n+                                    );\n+                                    continue 'outer;\n+                                }\n+                            },\n+                            NestedMetaItem::Literal(lit) => {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    lit.span,\n+                                    AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                                );\n+                                continue 'outer;\n+                            }\n+                        }\n+                    }\n+\n+                    match (feature, since) {\n+                        (Some(feature), Some(since)) => {\n+                            let level = Stable { since };\n+                            if sym::stable == meta_name {\n+                                stab = Some(Stability { level, feature });\n+                            } else {\n+                                const_stab = Some(ConstStability {\n+                                    level,\n+                                    feature,\n+                                    promotable: false,\n+                                    allow_const_fn_ptr: false,\n+                                });\n+                            }\n+                        }\n+                        (None, _) => {\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+                            continue;\n+                        }\n+                        _ => {\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+                            continue;\n+                        }\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    // Merge the const-unstable info into the stability info\n+    if promotable || allow_const_fn_ptr {\n+        if let Some(ref mut stab) = const_stab {\n+            stab.promotable = promotable;\n+            stab.allow_const_fn_ptr = allow_const_fn_ptr;\n+        } else {\n+            struct_span_err!(\n+                diagnostic,\n+                item_sp,\n+                E0717,\n+                \"rustc_promotable and rustc_allow_const_fn_ptr attributes \\\n+                      must be paired with either a rustc_const_unstable or a rustc_const_stable \\\n+                      attribute\"\n+            )\n+            .emit();\n+        }\n+    }\n+\n+    (stab, const_stab)\n+}\n+\n+pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n+    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n+}\n+\n+/// Tests if a cfg-pattern matches the cfg set\n+pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n+    eval_condition(cfg, sess, features, &mut |cfg| {\n+        try_gate_cfg(cfg, sess, features);\n+        let error = |span, msg| {\n+            sess.span_diagnostic.span_err(span, msg);\n+            true\n+        };\n+        if cfg.path.segments.len() != 1 {\n+            return error(cfg.path.span, \"`cfg` predicate key must be an identifier\");\n+        }\n+        match &cfg.kind {\n+            MetaItemKind::List(..) => {\n+                error(cfg.span, \"unexpected parentheses after `cfg` predicate key\")\n+            }\n+            MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n+                handle_errors(\n+                    sess,\n+                    lit.span,\n+                    AttrError::UnsupportedLiteral(\n+                        \"literal in `cfg` predicate value must be a string\",\n+                        lit.kind.is_bytestr(),\n+                    ),\n+                );\n+                true\n+            }\n+            MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n+                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+                sess.config.contains(&(ident.name, cfg.value_str()))\n+            }\n+        }\n+    })\n+}\n+\n+fn try_gate_cfg(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) {\n+    let gate = find_gated_cfg(|sym| cfg.has_name(sym));\n+    if let (Some(feats), Some(gated_cfg)) = (features, gate) {\n+        gate_cfg(&gated_cfg, cfg.span, sess, feats);\n+    }\n+}\n+\n+fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &Features) {\n+    let (cfg, feature, has_feature) = gated_cfg;\n+    if !has_feature(features) && !cfg_span.allows_unstable(*feature) {\n+        let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n+        feature_err(sess, *feature, cfg_span, &explain).emit();\n+    }\n+}\n+\n+/// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n+/// evaluate individual items.\n+pub fn eval_condition(\n+    cfg: &ast::MetaItem,\n+    sess: &ParseSess,\n+    features: Option<&Features>,\n+    eval: &mut impl FnMut(&ast::MetaItem) -> bool,\n+) -> bool {\n+    match cfg.kind {\n+        ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n+            try_gate_cfg(cfg, sess, features);\n+            let (min_version, span) = match &mis[..] {\n+                [NestedMetaItem::Literal(Lit { kind: LitKind::Str(sym, ..), span, .. })] => {\n+                    (sym, span)\n+                }\n+                [NestedMetaItem::Literal(Lit { span, .. })\n+                | NestedMetaItem::MetaItem(MetaItem { span, .. })] => {\n+                    sess.span_diagnostic\n+                        .struct_span_err(*span, \"expected a version literal\")\n+                        .emit();\n+                    return false;\n+                }\n+                [..] => {\n+                    sess.span_diagnostic\n+                        .struct_span_err(cfg.span, \"expected single version literal\")\n+                        .emit();\n+                    return false;\n+                }\n+            };\n+            let min_version = match Version::parse(&min_version.as_str()) {\n+                Some(ver) => ver,\n+                None => {\n+                    sess.span_diagnostic.struct_span_err(*span, \"invalid version literal\").emit();\n+                    return false;\n+                }\n+            };\n+            let channel = env!(\"CFG_RELEASE_CHANNEL\");\n+            let nightly = channel == \"nightly\" || channel == \"dev\";\n+            let rustc_version = Version::parse(env!(\"CFG_RELEASE\")).unwrap();\n+\n+            // See https://github.com/rust-lang/rust/issues/64796#issuecomment-625474439 for details\n+            if nightly { rustc_version > min_version } else { rustc_version >= min_version }\n+        }\n+        ast::MetaItemKind::List(ref mis) => {\n+            for mi in mis.iter() {\n+                if !mi.is_meta_item() {\n+                    handle_errors(\n+                        sess,\n+                        mi.span(),\n+                        AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n+                    );\n+                    return false;\n+                }\n+            }\n+\n+            // The unwraps below may look dangerous, but we've already asserted\n+            // that they won't fail with the loop above.\n+            match cfg.name_or_empty() {\n+                sym::any => mis\n+                    .iter()\n+                    .any(|mi| eval_condition(mi.meta_item().unwrap(), sess, features, eval)),\n+                sym::all => mis\n+                    .iter()\n+                    .all(|mi| eval_condition(mi.meta_item().unwrap(), sess, features, eval)),\n+                sym::not => {\n+                    if mis.len() != 1 {\n+                        struct_span_err!(\n+                            sess.span_diagnostic,\n+                            cfg.span,\n+                            E0536,\n+                            \"expected 1 cfg-pattern\"\n+                        )\n+                        .emit();\n+                        return false;\n+                    }\n+\n+                    !eval_condition(mis[0].meta_item().unwrap(), sess, features, eval)\n+                }\n+                _ => {\n+                    struct_span_err!(\n+                        sess.span_diagnostic,\n+                        cfg.span,\n+                        E0537,\n+                        \"invalid predicate `{}`\",\n+                        pprust::path_to_string(&cfg.path)\n+                    )\n+                    .emit();\n+                    false\n+                }\n+            }\n+        }\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => eval(cfg),\n+    }\n+}\n+\n+#[derive(Encodable, Decodable, Clone, HashStable_Generic)]\n+pub struct Deprecation {\n+    pub since: Option<Symbol>,\n+    /// The note to issue a reason.\n+    pub note: Option<Symbol>,\n+    /// A text snippet used to completely replace any use of the deprecated item in an expression.\n+    ///\n+    /// This is currently unstable.\n+    pub suggestion: Option<Symbol>,\n+\n+    /// Whether to treat the since attribute as being a Rust version identifier\n+    /// (rather than an opaque string).\n+    pub is_since_rustc_version: bool,\n+}\n+\n+/// Finds the deprecation attribute. `None` if none exists.\n+pub fn find_deprecation(sess: &Session, attrs: &[Attribute], item_sp: Span) -> Option<Deprecation> {\n+    find_deprecation_generic(sess, attrs.iter(), item_sp)\n+}\n+\n+fn find_deprecation_generic<'a, I>(\n+    sess: &Session,\n+    attrs_iter: I,\n+    item_sp: Span,\n+) -> Option<Deprecation>\n+where\n+    I: Iterator<Item = &'a Attribute>,\n+{\n+    let mut depr: Option<Deprecation> = None;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n+\n+    'outer: for attr in attrs_iter {\n+        if !(sess.check_name(attr, sym::deprecated) || sess.check_name(attr, sym::rustc_deprecated))\n+        {\n+            continue;\n+        }\n+\n+        if depr.is_some() {\n+            struct_span_err!(diagnostic, item_sp, E0550, \"multiple deprecated attributes\").emit();\n+            break;\n+        }\n+\n+        let meta = match attr.meta() {\n+            Some(meta) => meta,\n+            None => continue,\n+        };\n+        let mut since = None;\n+        let mut note = None;\n+        let mut suggestion = None;\n+        match &meta.kind {\n+            MetaItemKind::Word => {}\n+            MetaItemKind::NameValue(..) => note = meta.value_str(),\n+            MetaItemKind::List(list) => {\n+                let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+                    if item.is_some() {\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            meta.span,\n+                            AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+                        );\n+                        return false;\n+                    }\n+                    if let Some(v) = meta.value_str() {\n+                        *item = Some(v);\n+                        true\n+                    } else {\n+                        if let Some(lit) = meta.name_value_literal() {\n+                            handle_errors(\n+                                &sess.parse_sess,\n+                                lit.span,\n+                                AttrError::UnsupportedLiteral(\n+                                    \"literal in `deprecated` \\\n+                                    value must be a string\",\n+                                    lit.kind.is_bytestr(),\n+                                ),\n+                            );\n+                        } else {\n+                            struct_span_err!(diagnostic, meta.span, E0551, \"incorrect meta item\")\n+                                .emit();\n+                        }\n+\n+                        false\n+                    }\n+                };\n+\n+                for meta in list {\n+                    match meta {\n+                        NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n+                            sym::since => {\n+                                if !get(mi, &mut since) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::note if sess.check_name(attr, sym::deprecated) => {\n+                                if !get(mi, &mut note) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::reason if sess.check_name(attr, sym::rustc_deprecated) => {\n+                                if !get(mi, &mut note) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            sym::suggestion if sess.check_name(attr, sym::rustc_deprecated) => {\n+                                if !get(mi, &mut suggestion) {\n+                                    continue 'outer;\n+                                }\n+                            }\n+                            _ => {\n+                                handle_errors(\n+                                    &sess.parse_sess,\n+                                    meta.span(),\n+                                    AttrError::UnknownMetaItem(\n+                                        pprust::path_to_string(&mi.path),\n+                                        if sess.check_name(attr, sym::deprecated) {\n+                                            &[\"since\", \"note\"]\n+                                        } else {\n+                                            &[\"since\", \"reason\", \"suggestion\"]\n+                                        },\n+                                    ),\n+                                );\n+                                continue 'outer;\n+                            }\n+                        },\n+                        NestedMetaItem::Literal(lit) => {\n+                            handle_errors(\n+                                &sess.parse_sess,\n+                                lit.span,\n+                                AttrError::UnsupportedLiteral(\n+                                    \"item in `deprecated` must be a key/value pair\",\n+                                    false,\n+                                ),\n+                            );\n+                            continue 'outer;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if suggestion.is_some() && sess.check_name(attr, sym::deprecated) {\n+            unreachable!(\"only allowed on rustc_deprecated\")\n+        }\n+\n+        if sess.check_name(attr, sym::rustc_deprecated) {\n+            if since.is_none() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+                continue;\n+            }\n+\n+            if note.is_none() {\n+                struct_span_err!(diagnostic, attr.span, E0543, \"missing 'reason'\").emit();\n+                continue;\n+            }\n+        }\n+\n+        sess.mark_attr_used(&attr);\n+\n+        let is_since_rustc_version = sess.check_name(attr, sym::rustc_deprecated);\n+        depr = Some(Deprecation { since, note, suggestion, is_since_rustc_version });\n+    }\n+\n+    depr\n+}\n+\n+#[derive(PartialEq, Debug, Encodable, Decodable, Copy, Clone)]\n+pub enum ReprAttr {\n+    ReprInt(IntType),\n+    ReprC,\n+    ReprPacked(u32),\n+    ReprSimd,\n+    ReprTransparent,\n+    ReprAlign(u32),\n+    ReprNoNiche,\n+}\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n+pub enum IntType {\n+    SignedInt(ast::IntTy),\n+    UnsignedInt(ast::UintTy),\n+}\n+\n+impl IntType {\n+    #[inline]\n+    pub fn is_signed(self) -> bool {\n+        use IntType::*;\n+\n+        match self {\n+            SignedInt(..) => true,\n+            UnsignedInt(..) => false,\n+        }\n+    }\n+}\n+\n+/// Parse #[repr(...)] forms.\n+///\n+/// Valid repr contents: any of the primitive integral type names (see\n+/// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n+/// the same discriminant size that the corresponding C enum would or C\n+/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n+/// concerns to the only non-ZST field.\n+pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n+    use ReprAttr::*;\n+\n+    let mut acc = Vec::new();\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n+    if attr.has_name(sym::repr) {\n+        if let Some(items) = attr.meta_item_list() {\n+            sess.mark_attr_used(attr);\n+            for item in items {\n+                if !item.is_meta_item() {\n+                    handle_errors(\n+                        &sess.parse_sess,\n+                        item.span(),\n+                        AttrError::UnsupportedLiteral(\n+                            \"meta item in `repr` must be an identifier\",\n+                            false,\n+                        ),\n+                    );\n+                    continue;\n+                }\n+\n+                let mut recognised = false;\n+                if item.is_word() {\n+                    let hint = match item.name_or_empty() {\n+                        sym::C => Some(ReprC),\n+                        sym::packed => Some(ReprPacked(1)),\n+                        sym::simd => Some(ReprSimd),\n+                        sym::transparent => Some(ReprTransparent),\n+                        sym::no_niche => Some(ReprNoNiche),\n+                        name => int_type_of_word(name).map(ReprInt),\n+                    };\n+\n+                    if let Some(h) = hint {\n+                        recognised = true;\n+                        acc.push(h);\n+                    }\n+                } else if let Some((name, value)) = item.name_value_literal() {\n+                    let parse_alignment = |node: &ast::LitKind| -> Result<u32, &'static str> {\n+                        if let ast::LitKind::Int(literal, ast::LitIntType::Unsuffixed) = node {\n+                            if literal.is_power_of_two() {\n+                                // rustc_middle::ty::layout::Align restricts align to <= 2^29\n+                                if *literal <= 1 << 29 {\n+                                    Ok(*literal as u32)\n+                                } else {\n+                                    Err(\"larger than 2^29\")\n+                                }\n+                            } else {\n+                                Err(\"not a power of two\")\n+                            }\n+                        } else {\n+                            Err(\"not an unsuffixed integer\")\n+                        }\n+                    };\n+\n+                    let mut literal_error = None;\n+                    if name == sym::align {\n+                        recognised = true;\n+                        match parse_alignment(&value.kind) {\n+                            Ok(literal) => acc.push(ReprAlign(literal)),\n+                            Err(message) => literal_error = Some(message),\n+                        };\n+                    } else if name == sym::packed {\n+                        recognised = true;\n+                        match parse_alignment(&value.kind) {\n+                            Ok(literal) => acc.push(ReprPacked(literal)),\n+                            Err(message) => literal_error = Some(message),\n+                        };\n+                    }\n+                    if let Some(literal_error) = literal_error {\n+                        struct_span_err!(\n+                            diagnostic,\n+                            item.span(),\n+                            E0589,\n+                            \"invalid `repr(align)` attribute: {}\",\n+                            literal_error\n+                        )\n+                        .emit();\n+                    }\n+                } else {\n+                    if let Some(meta_item) = item.meta_item() {\n+                        if meta_item.has_name(sym::align) {\n+                            if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n+                                recognised = true;\n+                                let mut err = struct_span_err!(\n+                                    diagnostic,\n+                                    item.span(),\n+                                    E0693,\n+                                    \"incorrect `repr(align)` attribute format\"\n+                                );\n+                                match value.kind {\n+                                    ast::LitKind::Int(int, ast::LitIntType::Unsuffixed) => {\n+                                        err.span_suggestion(\n+                                            item.span(),\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", int),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                    }\n+                                    ast::LitKind::Str(s, _) => {\n+                                        err.span_suggestion(\n+                                            item.span(),\n+                                            \"use parentheses instead\",\n+                                            format!(\"align({})\", s),\n+                                            Applicability::MachineApplicable,\n+                                        );\n+                                    }\n+                                    _ => {}\n+                                }\n+                                err.emit();\n+                            }\n+                        }\n+                    }\n+                }\n+                if !recognised {\n+                    // Not a word we recognize\n+                    struct_span_err!(\n+                        diagnostic,\n+                        item.span(),\n+                        E0552,\n+                        \"unrecognized representation hint\"\n+                    )\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+    acc\n+}\n+\n+fn int_type_of_word(s: Symbol) -> Option<IntType> {\n+    use IntType::*;\n+\n+    match s {\n+        sym::i8 => Some(SignedInt(ast::IntTy::I8)),\n+        sym::u8 => Some(UnsignedInt(ast::UintTy::U8)),\n+        sym::i16 => Some(SignedInt(ast::IntTy::I16)),\n+        sym::u16 => Some(UnsignedInt(ast::UintTy::U16)),\n+        sym::i32 => Some(SignedInt(ast::IntTy::I32)),\n+        sym::u32 => Some(UnsignedInt(ast::UintTy::U32)),\n+        sym::i64 => Some(SignedInt(ast::IntTy::I64)),\n+        sym::u64 => Some(UnsignedInt(ast::UintTy::U64)),\n+        sym::i128 => Some(SignedInt(ast::IntTy::I128)),\n+        sym::u128 => Some(UnsignedInt(ast::UintTy::U128)),\n+        sym::isize => Some(SignedInt(ast::IntTy::Isize)),\n+        sym::usize => Some(UnsignedInt(ast::UintTy::Usize)),\n+        _ => None,\n+    }\n+}\n+\n+pub enum TransparencyError {\n+    UnknownTransparency(Symbol, Span),\n+    MultipleTransparencyAttrs(Span, Span),\n+}\n+\n+pub fn find_transparency(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    macro_rules: bool,\n+) -> (Transparency, Option<TransparencyError>) {\n+    let mut transparency = None;\n+    let mut error = None;\n+    for attr in attrs {\n+        if sess.check_name(attr, sym::rustc_macro_transparency) {\n+            if let Some((_, old_span)) = transparency {\n+                error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n+                break;\n+            } else if let Some(value) = attr.value_str() {\n+                transparency = Some((\n+                    match value {\n+                        sym::transparent => Transparency::Transparent,\n+                        sym::semitransparent => Transparency::SemiTransparent,\n+                        sym::opaque => Transparency::Opaque,\n+                        _ => {\n+                            error = Some(TransparencyError::UnknownTransparency(value, attr.span));\n+                            continue;\n+                        }\n+                    },\n+                    attr.span,\n+                ));\n+            }\n+        }\n+    }\n+    let fallback = if macro_rules { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    (transparency.map_or(fallback, |t| t.0), error)\n+}\n+\n+pub fn allow_internal_unstable<'a>(\n+    sess: &'a Session,\n+    attrs: &[Attribute],\n+) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+    let attr = sess.find_by_name(attrs, sym::allow_internal_unstable)?;\n+    let list = attr.meta_item_list().or_else(|| {\n+        sess.diagnostic()\n+            .span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n+        None\n+    })?;\n+    Some(list.into_iter().filter_map(move |it| {\n+        let name = it.ident().map(|ident| ident.name);\n+        if name.is_none() {\n+            sess.diagnostic()\n+                .span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n+        }\n+        name\n+    }))\n+}"}, {"sha": "149a950f7d417ca3977f15c5bacd141ab5863176", "filename": "compiler/rustc_attr/src/lib.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,21 @@\n+//! Functions and types dealing with attributes and meta items.\n+//!\n+//! FIXME(Centril): For now being, much of the logic is still in `rustc_ast::attr`.\n+//! The goal is to move the definition of `MetaItem` and things that don't need to be in `syntax`\n+//! to this crate.\n+\n+#![feature(or_patterns)]\n+\n+#[macro_use]\n+extern crate rustc_macros;\n+\n+mod builtin;\n+\n+pub use builtin::*;\n+pub use IntType::*;\n+pub use ReprAttr::*;\n+pub use StabilityLevel::*;\n+\n+pub use rustc_ast::attr::*;\n+\n+pub(crate) use rustc_ast::HashStableContext;"}, {"sha": "c397a85412627cfac93de16e9dfa9f7f54dfc9c5", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_builtin_macros\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc_parse_format = { path = \"../rustc_parse_format\" }\n+tracing = \"0.1\"\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n+rustc_attr = { path = \"../rustc_attr\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_parse = { path = \"../rustc_parse\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_session = { path = \"../rustc_session\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_expand = { path = \"../rustc_expand\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "5dafd6b77ab1e704ca1b56d2aefc3bcf0f3308fa", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,632 @@\n+use rustc_ast as ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_expand::base::{self, *};\n+use rustc_parse::parser::Parser;\n+use rustc_parse_format as parse;\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{InnerSpan, Span};\n+\n+struct AsmArgs {\n+    templates: Vec<P<ast::Expr>>,\n+    operands: Vec<(ast::InlineAsmOperand, Span)>,\n+    named_args: FxHashMap<Symbol, usize>,\n+    reg_args: FxHashSet<usize>,\n+    options: ast::InlineAsmOptions,\n+    options_spans: Vec<Span>,\n+}\n+\n+fn parse_args<'a>(\n+    ecx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Result<AsmArgs, DiagnosticBuilder<'a>> {\n+    let mut p = ecx.new_parser_from_tts(tts);\n+\n+    if p.token == token::Eof {\n+        return Err(ecx.struct_span_err(sp, \"requires at least a template string argument\"));\n+    }\n+\n+    // Detect use of the legacy llvm_asm! syntax (which used to be called asm!)\n+    if p.look_ahead(1, |t| *t == token::Colon || *t == token::ModSep) {\n+        let mut err =\n+            ecx.struct_span_err(sp, \"the legacy LLVM-style asm! syntax is no longer supported\");\n+        err.note(\"consider migrating to the new asm! syntax specified in RFC 2873\");\n+        err.note(\"alternatively, switch to llvm_asm! to keep your code working as it is\");\n+\n+        // Find the span of the \"asm!\" so that we can offer an automatic suggestion\n+        let asm_span = sp.from_inner(InnerSpan::new(0, 4));\n+        if let Ok(s) = ecx.source_map().span_to_snippet(asm_span) {\n+            if s == \"asm!\" {\n+                err.span_suggestion(\n+                    asm_span,\n+                    \"replace with\",\n+                    \"llvm_asm!\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        return Err(err);\n+    }\n+\n+    let first_template = p.parse_expr()?;\n+    let mut args = AsmArgs {\n+        templates: vec![first_template],\n+        operands: vec![],\n+        named_args: FxHashMap::default(),\n+        reg_args: FxHashSet::default(),\n+        options: ast::InlineAsmOptions::empty(),\n+        options_spans: vec![],\n+    };\n+\n+    let mut allow_templates = true;\n+    while p.token != token::Eof {\n+        if !p.eat(&token::Comma) {\n+            if allow_templates {\n+                // After a template string, we always expect *only* a comma...\n+                let mut err = ecx.struct_span_err(p.token.span, \"expected token: `,`\");\n+                err.span_label(p.token.span, \"expected `,`\");\n+                p.maybe_annotate_with_ascription(&mut err, false);\n+                return Err(err);\n+            } else {\n+                // ...after that delegate to `expect` to also include the other expected tokens.\n+                return Err(p.expect(&token::Comma).err().unwrap());\n+            }\n+        }\n+        if p.token == token::Eof {\n+            break;\n+        } // accept trailing commas\n+\n+        // Parse options\n+        if p.eat(&token::Ident(sym::options, false)) {\n+            parse_options(&mut p, &mut args)?;\n+            allow_templates = false;\n+            continue;\n+        }\n+\n+        let span_start = p.token.span;\n+\n+        // Parse operand names\n+        let name = if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n+            let (ident, _) = p.token.ident().unwrap();\n+            p.bump();\n+            p.expect(&token::Eq)?;\n+            allow_templates = false;\n+            Some(ident.name)\n+        } else {\n+            None\n+        };\n+\n+        let mut explicit_reg = false;\n+        let op = if p.eat(&token::Ident(kw::In, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::In { reg, expr }\n+        } else if p.eat(&token::Ident(sym::out, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: false }\n+        } else if p.eat(&token::Ident(sym::lateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+            ast::InlineAsmOperand::Out { reg, expr, late: true }\n+        } else if p.eat(&token::Ident(sym::inout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: false }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: false }\n+            }\n+        } else if p.eat(&token::Ident(sym::inlateout, false)) {\n+            let reg = parse_reg(&mut p, &mut explicit_reg)?;\n+            let expr = p.parse_expr()?;\n+            if p.eat(&token::FatArrow) {\n+                let out_expr =\n+                    if p.eat_keyword(kw::Underscore) { None } else { Some(p.parse_expr()?) };\n+                ast::InlineAsmOperand::SplitInOut { reg, in_expr: expr, out_expr, late: true }\n+            } else {\n+                ast::InlineAsmOperand::InOut { reg, expr, late: true }\n+            }\n+        } else if p.eat(&token::Ident(kw::Const, false)) {\n+            let expr = p.parse_expr()?;\n+            ast::InlineAsmOperand::Const { expr }\n+        } else if p.eat(&token::Ident(sym::sym, false)) {\n+            let expr = p.parse_expr()?;\n+            match expr.kind {\n+                ast::ExprKind::Path(..) => {}\n+                _ => {\n+                    let err = ecx\n+                        .struct_span_err(expr.span, \"argument to `sym` must be a path expression\");\n+                    return Err(err);\n+                }\n+            }\n+            ast::InlineAsmOperand::Sym { expr }\n+        } else if allow_templates {\n+            let template = p.parse_expr()?;\n+            // If it can't possibly expand to a string, provide diagnostics here to include other\n+            // things it could have been.\n+            match template.kind {\n+                ast::ExprKind::Lit(ast::Lit { kind: ast::LitKind::Str(..), .. }) => {}\n+                ast::ExprKind::MacCall(..) => {}\n+                _ => {\n+                    let errstr = \"expected operand, options, or additional template string\";\n+                    let mut err = ecx.struct_span_err(template.span, errstr);\n+                    err.span_label(template.span, errstr);\n+                    return Err(err);\n+                }\n+            }\n+            args.templates.push(template);\n+            continue;\n+        } else {\n+            return Err(p.expect_one_of(&[], &[]).unwrap_err());\n+        };\n+\n+        allow_templates = false;\n+        let span = span_start.to(p.prev_token.span);\n+        let slot = args.operands.len();\n+        args.operands.push((op, span));\n+\n+        // Validate the order of named, positional & explicit register operands and options. We do\n+        // this at the end once we have the full span of the argument available.\n+        if !args.options_spans.is_empty() {\n+            ecx.struct_span_err(span, \"arguments are not allowed after options\")\n+                .span_labels(args.options_spans.clone(), \"previous options\")\n+                .span_label(span, \"argument\")\n+                .emit();\n+        }\n+        if explicit_reg {\n+            if name.is_some() {\n+                ecx.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+            }\n+            args.reg_args.insert(slot);\n+        } else if let Some(name) = name {\n+            if let Some(&prev) = args.named_args.get(&name) {\n+                ecx.struct_span_err(span, &format!(\"duplicate argument named `{}`\", name))\n+                    .span_label(args.operands[prev].1, \"previously here\")\n+                    .span_label(span, \"duplicate argument\")\n+                    .emit();\n+                continue;\n+            }\n+            if !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"named arguments cannot follow explicit register arguments\",\n+                );\n+                err.span_label(span, \"named argument\");\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+            args.named_args.insert(name, slot);\n+        } else {\n+            if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n+                let mut err = ecx.struct_span_err(\n+                    span,\n+                    \"positional arguments cannot follow named arguments \\\n+                     or explicit register arguments\",\n+                );\n+                err.span_label(span, \"positional argument\");\n+                for pos in args.named_args.values() {\n+                    err.span_label(args.operands[*pos].1, \"named argument\");\n+                }\n+                for pos in &args.reg_args {\n+                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    if args.options.contains(ast::InlineAsmOptions::NOMEM)\n+        && args.options.contains(ast::InlineAsmOptions::READONLY)\n+    {\n+        let spans = args.options_spans.clone();\n+        ecx.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE)\n+        && args.options.contains(ast::InlineAsmOptions::NORETURN)\n+    {\n+        let spans = args.options_spans.clone();\n+        ecx.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n+            .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE)\n+        && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n+    {\n+        let spans = args.options_spans.clone();\n+        ecx.struct_span_err(\n+            spans,\n+            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n+        )\n+        .emit();\n+    }\n+\n+    let mut have_real_output = false;\n+    let mut outputs_sp = vec![];\n+    for (op, op_sp) in &args.operands {\n+        match op {\n+            ast::InlineAsmOperand::Out { expr, .. }\n+            | ast::InlineAsmOperand::SplitInOut { out_expr: expr, .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output |= expr.is_some();\n+            }\n+            ast::InlineAsmOperand::InOut { .. } => {\n+                outputs_sp.push(*op_sp);\n+                have_real_output = true;\n+            }\n+            _ => {}\n+        }\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n+        ecx.struct_span_err(\n+            args.options_spans.clone(),\n+            \"asm with `pure` option must have at least one output\",\n+        )\n+        .emit();\n+    }\n+    if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n+        let err = ecx\n+            .struct_span_err(outputs_sp, \"asm outputs are not allowed with the `noreturn` option\");\n+\n+        // Bail out now since this is likely to confuse MIR\n+        return Err(err);\n+    }\n+\n+    Ok(args)\n+}\n+\n+/// Report a duplicate option error.\n+///\n+/// This function must be called immediately after the option token is parsed.\n+/// Otherwise, the suggestion will be incorrect.\n+fn err_duplicate_option<'a>(p: &mut Parser<'a>, symbol: Symbol, span: Span) {\n+    let mut err = p\n+        .sess\n+        .span_diagnostic\n+        .struct_span_err(span, &format!(\"the `{}` option was already provided\", symbol));\n+    err.span_label(span, \"this option was already provided\");\n+\n+    // Tool-only output\n+    let mut full_span = span;\n+    if p.token.kind == token::Comma {\n+        full_span = full_span.to(p.token.span);\n+    }\n+    err.tool_only_span_suggestion(\n+        full_span,\n+        \"remove this option\",\n+        String::new(),\n+        Applicability::MachineApplicable,\n+    );\n+\n+    err.emit();\n+}\n+\n+/// Try to set the provided option in the provided `AsmArgs`.\n+/// If it is already set, report a duplicate option error.\n+///\n+/// This function must be called immediately after the option token is parsed.\n+/// Otherwise, the error will not point to the correct spot.\n+fn try_set_option<'a>(\n+    p: &mut Parser<'a>,\n+    args: &mut AsmArgs,\n+    symbol: Symbol,\n+    option: ast::InlineAsmOptions,\n+) {\n+    if !args.options.contains(option) {\n+        args.options |= option;\n+    } else {\n+        err_duplicate_option(p, symbol, p.prev_token.span);\n+    }\n+}\n+\n+fn parse_options<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> Result<(), DiagnosticBuilder<'a>> {\n+    let span_start = p.prev_token.span;\n+\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+\n+    while !p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+        if p.eat(&token::Ident(sym::pure, false)) {\n+            try_set_option(p, args, sym::pure, ast::InlineAsmOptions::PURE);\n+        } else if p.eat(&token::Ident(sym::nomem, false)) {\n+            try_set_option(p, args, sym::nomem, ast::InlineAsmOptions::NOMEM);\n+        } else if p.eat(&token::Ident(sym::readonly, false)) {\n+            try_set_option(p, args, sym::readonly, ast::InlineAsmOptions::READONLY);\n+        } else if p.eat(&token::Ident(sym::preserves_flags, false)) {\n+            try_set_option(p, args, sym::preserves_flags, ast::InlineAsmOptions::PRESERVES_FLAGS);\n+        } else if p.eat(&token::Ident(sym::noreturn, false)) {\n+            try_set_option(p, args, sym::noreturn, ast::InlineAsmOptions::NORETURN);\n+        } else if p.eat(&token::Ident(sym::nostack, false)) {\n+            try_set_option(p, args, sym::nostack, ast::InlineAsmOptions::NOSTACK);\n+        } else {\n+            p.expect(&token::Ident(sym::att_syntax, false))?;\n+            try_set_option(p, args, sym::att_syntax, ast::InlineAsmOptions::ATT_SYNTAX);\n+        }\n+\n+        // Allow trailing commas\n+        if p.eat(&token::CloseDelim(token::DelimToken::Paren)) {\n+            break;\n+        }\n+        p.expect(&token::Comma)?;\n+    }\n+\n+    let new_span = span_start.to(p.prev_token.span);\n+    args.options_spans.push(new_span);\n+\n+    Ok(())\n+}\n+\n+fn parse_reg<'a>(\n+    p: &mut Parser<'a>,\n+    explicit_reg: &mut bool,\n+) -> Result<ast::InlineAsmRegOrRegClass, DiagnosticBuilder<'a>> {\n+    p.expect(&token::OpenDelim(token::DelimToken::Paren))?;\n+    let result = match p.token.kind {\n+        token::Ident(name, false) => ast::InlineAsmRegOrRegClass::RegClass(name),\n+        token::Literal(token::Lit { kind: token::LitKind::Str, symbol, suffix: _ }) => {\n+            *explicit_reg = true;\n+            ast::InlineAsmRegOrRegClass::Reg(symbol)\n+        }\n+        _ => {\n+            return Err(\n+                p.struct_span_err(p.token.span, \"expected register class or explicit register\")\n+            );\n+        }\n+    };\n+    p.bump();\n+    p.expect(&token::CloseDelim(token::DelimToken::Paren))?;\n+    Ok(result)\n+}\n+\n+fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, sp: Span, args: AsmArgs) -> P<ast::Expr> {\n+    let mut template = vec![];\n+    // Register operands are implicitly used since they are not allowed to be\n+    // referenced in the template string.\n+    let mut used = vec![false; args.operands.len()];\n+    for pos in &args.reg_args {\n+        used[*pos] = true;\n+    }\n+    let named_pos: FxHashMap<usize, Symbol> =\n+        args.named_args.iter().map(|(&sym, &idx)| (idx, sym)).collect();\n+    let mut line_spans = Vec::with_capacity(args.templates.len());\n+    let mut curarg = 0;\n+\n+    for template_expr in args.templates.into_iter() {\n+        if !template.is_empty() {\n+            template.push(ast::InlineAsmTemplatePiece::String(\"\\n\".to_string()));\n+        }\n+\n+        let msg = \"asm template must be a string literal\";\n+        let template_sp = template_expr.span;\n+        let (template_str, template_style, template_span) =\n+            match expr_to_spanned_string(ecx, template_expr, msg) {\n+                Ok(template_part) => template_part,\n+                Err(err) => {\n+                    if let Some(mut err) = err {\n+                        err.emit();\n+                    }\n+                    return DummyResult::raw_expr(sp, true);\n+                }\n+            };\n+\n+        let str_style = match template_style {\n+            ast::StrStyle::Cooked => None,\n+            ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        };\n+\n+        let template_str = &template_str.as_str();\n+        let template_snippet = ecx.source_map().span_to_snippet(template_sp).ok();\n+        let mut parser = parse::Parser::new(\n+            template_str,\n+            str_style,\n+            template_snippet,\n+            false,\n+            parse::ParseMode::InlineAsm,\n+        );\n+        parser.curarg = curarg;\n+\n+        let mut unverified_pieces = Vec::new();\n+        while let Some(piece) = parser.next() {\n+            if !parser.errors.is_empty() {\n+                break;\n+            } else {\n+                unverified_pieces.push(piece);\n+            }\n+        }\n+\n+        if !parser.errors.is_empty() {\n+            let err = parser.errors.remove(0);\n+            let err_sp = template_span.from_inner(err.span);\n+            let msg = &format!(\"invalid asm template string: {}\", err.description);\n+            let mut e = ecx.struct_span_err(err_sp, msg);\n+            e.span_label(err_sp, err.label + \" in asm template string\");\n+            if let Some(note) = err.note {\n+                e.note(&note);\n+            }\n+            if let Some((label, span)) = err.secondary_label {\n+                let err_sp = template_span.from_inner(span);\n+                e.span_label(err_sp, label);\n+            }\n+            e.emit();\n+            return DummyResult::raw_expr(sp, true);\n+        }\n+\n+        curarg = parser.curarg;\n+\n+        let mut arg_spans = parser.arg_places.iter().map(|span| template_span.from_inner(*span));\n+        for piece in unverified_pieces {\n+            match piece {\n+                parse::Piece::String(s) => {\n+                    template.push(ast::InlineAsmTemplatePiece::String(s.to_string()))\n+                }\n+                parse::Piece::NextArgument(arg) => {\n+                    let span = arg_spans.next().unwrap_or(template_sp);\n+\n+                    let operand_idx = match arg.position {\n+                        parse::ArgumentIs(idx) | parse::ArgumentImplicitlyIs(idx) => {\n+                            if idx >= args.operands.len()\n+                                || named_pos.contains_key(&idx)\n+                                || args.reg_args.contains(&idx)\n+                            {\n+                                let msg = format!(\"invalid reference to argument at index {}\", idx);\n+                                let mut err = ecx.struct_span_err(span, &msg);\n+                                err.span_label(span, \"from here\");\n+\n+                                let positional_args = args.operands.len()\n+                                    - args.named_args.len()\n+                                    - args.reg_args.len();\n+                                let positional = if positional_args != args.operands.len() {\n+                                    \"positional \"\n+                                } else {\n+                                    \"\"\n+                                };\n+                                let msg = match positional_args {\n+                                    0 => format!(\"no {}arguments were given\", positional),\n+                                    1 => format!(\"there is 1 {}argument\", positional),\n+                                    x => format!(\"there are {} {}arguments\", x, positional),\n+                                };\n+                                err.note(&msg);\n+\n+                                if named_pos.contains_key(&idx) {\n+                                    err.span_label(args.operands[idx].1, \"named argument\");\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"named arguments cannot be referenced by position\",\n+                                    );\n+                                } else if args.reg_args.contains(&idx) {\n+                                    err.span_label(\n+                                        args.operands[idx].1,\n+                                        \"explicit register argument\",\n+                                    );\n+                                    err.span_note(\n+                                        args.operands[idx].1,\n+                                        \"explicit register arguments cannot be used in the asm template\",\n+                                    );\n+                                }\n+                                err.emit();\n+                                None\n+                            } else {\n+                                Some(idx)\n+                            }\n+                        }\n+                        parse::ArgumentNamed(name) => match args.named_args.get(&name) {\n+                            Some(&idx) => Some(idx),\n+                            None => {\n+                                let msg = format!(\"there is no argument named `{}`\", name);\n+                                ecx.struct_span_err(span, &msg[..]).emit();\n+                                None\n+                            }\n+                        },\n+                    };\n+\n+                    let mut chars = arg.format.ty.chars();\n+                    let mut modifier = chars.next();\n+                    if chars.next().is_some() {\n+                        let span = arg\n+                            .format\n+                            .ty_span\n+                            .map(|sp| template_sp.from_inner(sp))\n+                            .unwrap_or(template_sp);\n+                        ecx.struct_span_err(\n+                            span,\n+                            \"asm template modifier must be a single character\",\n+                        )\n+                        .emit();\n+                        modifier = None;\n+                    }\n+\n+                    if let Some(operand_idx) = operand_idx {\n+                        used[operand_idx] = true;\n+                        template.push(ast::InlineAsmTemplatePiece::Placeholder {\n+                            operand_idx,\n+                            modifier,\n+                            span,\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+\n+        if parser.line_spans.is_empty() {\n+            let template_num_lines = 1 + template_str.matches('\\n').count();\n+            line_spans.extend(std::iter::repeat(template_sp).take(template_num_lines));\n+        } else {\n+            line_spans.extend(parser.line_spans.iter().map(|span| template_span.from_inner(*span)));\n+        };\n+    }\n+\n+    let mut unused_operands = vec![];\n+    let mut help_str = String::new();\n+    for (idx, used) in used.into_iter().enumerate() {\n+        if !used {\n+            let msg = if let Some(sym) = named_pos.get(&idx) {\n+                help_str.push_str(&format!(\" {{{}}}\", sym));\n+                \"named argument never used\"\n+            } else {\n+                help_str.push_str(&format!(\" {{{}}}\", idx));\n+                \"argument never used\"\n+            };\n+            unused_operands.push((args.operands[idx].1, msg));\n+        }\n+    }\n+    match unused_operands.len() {\n+        0 => {}\n+        1 => {\n+            let (sp, msg) = unused_operands.into_iter().next().unwrap();\n+            let mut err = ecx.struct_span_err(sp, msg);\n+            err.span_label(sp, msg);\n+            err.help(&format!(\n+                \"if this argument is intentionally unused, \\\n+                 consider using it in an asm comment: `\\\"/*{} */\\\"`\",\n+                help_str\n+            ));\n+            err.emit();\n+        }\n+        _ => {\n+            let mut err = ecx.struct_span_err(\n+                unused_operands.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n+                \"multiple unused asm arguments\",\n+            );\n+            for (sp, msg) in unused_operands {\n+                err.span_label(sp, msg);\n+            }\n+            err.help(&format!(\n+                \"if these arguments are intentionally unused, \\\n+                 consider using them in an asm comment: `\\\"/*{} */\\\"`\",\n+                help_str\n+            ));\n+            err.emit();\n+        }\n+    }\n+\n+    let inline_asm =\n+        ast::InlineAsm { template, operands: args.operands, options: args.options, line_spans };\n+    P(ast::Expr {\n+        id: ast::DUMMY_NODE_ID,\n+        kind: ast::ExprKind::InlineAsm(P(inline_asm)),\n+        span: sp,\n+        attrs: ast::AttrVec::new(),\n+        tokens: None,\n+    })\n+}\n+\n+pub fn expand_asm<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(ecx, sp, tts) {\n+        Ok(args) => MacEager::expr(expand_preparsed_asm(ecx, sp, args)),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}"}, {"sha": "25181715540735bf393cae660c6aaa20fcf9394e", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,9 +1,9 @@\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n-use rustc_ast::ast::{self, *};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n use rustc_parse::parser::Parser;", "previous_filename": "src/librustc_builtin_macros/assert.rs"}, {"sha": "4c00162b556b8cb8231580f52eee5352edf682b3", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,7 +2,7 @@\n //! a literal `true` or `false` based on whether the given cfg matches the\n //! current compilation environment.\n \n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_attr as attr;\n@@ -19,7 +19,7 @@ pub fn expand_cfg(\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {\n-            let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n+            let matches_cfg = attr::cfg_matches(&cfg, &cx.sess.parse_sess, cx.ecfg.features);\n             MacEager::expr(cx.expr_bool(sp, matches_cfg))\n         }\n         Err(mut err) => {", "previous_filename": "src/librustc_builtin_macros/cfg.rs"}, {"sha": "75f4b077640d42e17772dd3467a7fa74d201962b", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n@@ -37,7 +37,12 @@ impl MultiItemModifier for Expander {\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(ecx.parse_sess, attr, sym::cfg_accessible, template);\n+        validate_attr::check_builtin_attribute(\n+            &ecx.sess.parse_sess,\n+            attr,\n+            sym::cfg_accessible,\n+            template,\n+        );\n \n         let path = match validate_input(ecx, meta_item) {\n             Some(path) => path,", "previous_filename": "src/librustc_builtin_macros/cfg_accessible.rs"}, {"sha": "34e2accc61541bee4928b98f2b1dc7edb7a61d74", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,8 +1,8 @@\n //! Attributes injected into the crate root from command line using `-Z crate-attr`.\n \n-use rustc_ast::ast::{self, AttrItem, AttrStyle};\n use rustc_ast::attr::mk_attr;\n use rustc_ast::token;\n+use rustc_ast::{self as ast, AttrItem, AttrStyle};\n use rustc_session::parse::ParseSess;\n use rustc_span::FileName;\n ", "previous_filename": "src/librustc_builtin_macros/cmdline_attrs.rs"}, {"sha": "f5955604e5fb2b0d8229aa2d5b4079e3ea19a5f6", "filename": "compiler/rustc_builtin_macros/src/compile_error.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcompile_error.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/compile_error.rs"}, {"sha": "e5077d93674a19be6ff1c0c1ea774a69e243d26f", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_expand::base::{self, DummyResult};\n use rustc_span::symbol::Symbol;", "previous_filename": "src/librustc_builtin_macros/concat.rs"}, {"sha": "8223cdda072314b8b555bbf72dc667d153814c8f", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};", "previous_filename": "src/librustc_builtin_macros/concat_idents.rs"}, {"sha": "12ef166b8b0512ddab9ae9069b0c6e0fad5d40e6", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,29 @@\n+use crate::deriving::generic::ty::*;\n+use crate::deriving::generic::*;\n+use crate::deriving::path_std;\n+\n+use rustc_ast::MetaItem;\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::Span;\n+\n+pub fn expand_deriving_copy(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    mitem: &MetaItem,\n+    item: &Annotatable,\n+    push: &mut dyn FnMut(Annotatable),\n+) {\n+    let trait_def = TraitDef {\n+        span,\n+        attributes: Vec::new(),\n+        path: path_std!(marker::Copy),\n+        additional_bounds: Vec::new(),\n+        generics: Bounds::empty(),\n+        is_unsafe: false,\n+        supports_unions: true,\n+        methods: Vec::new(),\n+        associated_types: Vec::new(),\n+    };\n+\n+    trait_def.expand(cx, mitem, item, push);\n+}"}, {"sha": "957c8035399a2da862309d05c41ed00ae89a9730", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast::{self, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/clone.rs"}, {"sha": "79f35ad5819f1c2919969f74cd39a361672b1d2f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast::{self, Expr, GenericArg, MetaItem};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, GenericArg, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/cmp/eq.rs"}, {"sha": "c1473e2409332b1b95bfa477b8538a93ca05ab97", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast::{self, Expr, MetaItem};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs"}, {"sha": "8e9f15743cc34ea0053d9d6104f8cd0c81d20a07", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n \n-use rustc_ast::ast::{BinOpKind, Expr, MetaItem};\n use rustc_ast::ptr::P;\n+use rustc_ast::{BinOpKind, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/cmp/partial_eq.rs"}, {"sha": "21174ca4c8bf9e370e9650129c6448e3e7380bf9", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -4,8 +4,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std, pathvec_std};\n \n-use rustc_ast::ast::{self, BinOpKind, Expr, MetaItem};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, BinOpKind, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs"}, {"sha": "120e859f2b1a434bec10a4f4ef2ac6df4855e750", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,9 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n-use rustc_ast::ast;\n-use rustc_ast::ast::{Expr, MetaItem};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};", "previous_filename": "src/librustc_builtin_macros/deriving/debug.rs"}, {"sha": "df69f6c90d813e0acfbdd877f3e48ce9ab6fea12", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -4,9 +4,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::ast;\n-use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/decodable.rs"}, {"sha": "980be3a005039915ba0892103029d79c96a66a86", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,86 @@\n+use crate::deriving::generic::ty::*;\n+use crate::deriving::generic::*;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{Expr, MetaItem};\n+use rustc_errors::struct_span_err;\n+use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::Span;\n+\n+pub fn expand_deriving_default(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    mitem: &MetaItem,\n+    item: &Annotatable,\n+    push: &mut dyn FnMut(Annotatable),\n+) {\n+    let inline = cx.meta_word(span, sym::inline);\n+    let attrs = vec![cx.attribute(inline)];\n+    let trait_def = TraitDef {\n+        span,\n+        attributes: Vec::new(),\n+        path: Path::new(vec![kw::Default, sym::Default]),\n+        additional_bounds: Vec::new(),\n+        generics: Bounds::empty(),\n+        is_unsafe: false,\n+        supports_unions: false,\n+        methods: vec![MethodDef {\n+            name: kw::Default,\n+            generics: Bounds::empty(),\n+            explicit_self: None,\n+            args: Vec::new(),\n+            ret_ty: Self_,\n+            attributes: attrs,\n+            is_unsafe: false,\n+            unify_fieldless_variants: false,\n+            combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                default_substructure(a, b, c)\n+            })),\n+        }],\n+        associated_types: Vec::new(),\n+    };\n+    trait_def.expand(cx, mitem, item, push)\n+}\n+\n+fn default_substructure(\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substr: &Substructure<'_>,\n+) -> P<Expr> {\n+    // Note that `kw::Default` is \"default\" and `sym::Default` is \"Default\"!\n+    let default_ident = cx.std_path(&[kw::Default, sym::Default, kw::Default]);\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+\n+    match *substr.fields {\n+        StaticStruct(_, ref summary) => match *summary {\n+            Unnamed(ref fields, is_tuple) => {\n+                if !is_tuple {\n+                    cx.expr_ident(trait_span, substr.type_ident)\n+                } else {\n+                    let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n+                    cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n+                }\n+            }\n+            Named(ref fields) => {\n+                let default_fields = fields\n+                    .iter()\n+                    .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))\n+                    .collect();\n+                cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n+            }\n+        },\n+        StaticEnum(..) => {\n+            struct_span_err!(\n+                &cx.sess.parse_sess.span_diagnostic,\n+                trait_span,\n+                E0665,\n+                \"`Default` cannot be derived for enums, only structs\"\n+            )\n+            .emit();\n+            // let compilation continue\n+            DummyResult::raw_expr(trait_span, true)\n+        }\n+        _ => cx.span_bug(trait_span, \"method in `derive(Default)`\"),\n+    }\n+}"}, {"sha": "62aa1cbfbf2656162573c12245a09c430fef495a", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -89,8 +89,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::pathvec_std;\n \n-use rustc_ast::ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n+use rustc_ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/encodable.rs"}, {"sha": "849e8b136e12db756fa49df97920d2c04ade09aa", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "added", "additions": 1757, "deletions": 0, "changes": 1757, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1757 @@\n+//! Some code that abstracts away much of the boilerplate of writing\n+//! `derive` instances for traits. Among other things it manages getting\n+//! access to the fields of the 4 different sorts of structs and enum\n+//! variants, as well as creating the method and impl ast instances.\n+//!\n+//! Supported features (fairly exhaustive):\n+//!\n+//! - Methods taking any number of parameters of any type, and returning\n+//!   any type, other than vectors, bottom and closures.\n+//! - Generating `impl`s for types with type parameters and lifetimes\n+//!   (e.g., `Option<T>`), the parameters are automatically given the\n+//!   current trait as a bound. (This includes separate type parameters\n+//!   and lifetimes for methods.)\n+//! - Additional bounds on the type parameters (`TraitDef.additional_bounds`)\n+//!\n+//! The most important thing for implementors is the `Substructure` and\n+//! `SubstructureFields` objects. The latter groups 5 possibilities of the\n+//! arguments:\n+//!\n+//! - `Struct`, when `Self` is a struct (including tuple structs, e.g\n+//!   `struct T(i32, char)`).\n+//! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n+//!   same variant of the enum (e.g., `Some(1)`, `Some(3)` and `Some(4)`)\n+//! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n+//!   are not the same variant (e.g., `None`, `Some(1)` and `None`).\n+//! - `StaticEnum` and `StaticStruct` for static methods, where the type\n+//!   being derived upon is either an enum or struct respectively. (Any\n+//!   argument with type Self is just grouped among the non-self\n+//!   arguments.)\n+//!\n+//! In the first two cases, the values from the corresponding fields in\n+//! all the arguments are grouped together. For `EnumNonMatchingCollapsed`\n+//! this isn't possible (different variants have different fields), so the\n+//! fields are inaccessible. (Previous versions of the deriving infrastructure\n+//! had a way to expand into code that could access them, at the cost of\n+//! generating exponential amounts of code; see issue #15375). There are no\n+//! fields with values in the static cases, so these are treated entirely\n+//! differently.\n+//!\n+//! The non-static cases have `Option<ident>` in several places associated\n+//! with field `expr`s. This represents the name of the field it is\n+//! associated with. It is only not `None` when the associated field has\n+//! an identifier in the source code. For example, the `x`s in the\n+//! following snippet\n+//!\n+//! ```rust\n+//! # #![allow(dead_code)]\n+//! struct A { x : i32 }\n+//!\n+//! struct B(i32);\n+//!\n+//! enum C {\n+//!     C0(i32),\n+//!     C1 { x: i32 }\n+//! }\n+//! ```\n+//!\n+//! The `i32`s in `B` and `C0` don't have an identifier, so the\n+//! `Option<ident>`s would be `None` for them.\n+//!\n+//! In the static cases, the structure is summarized, either into the just\n+//! spans of the fields or a list of spans and the field idents (for tuple\n+//! structs and record structs, respectively), or a list of these, for\n+//! enums (one for each variant). For empty struct and empty enum\n+//! variants, it is represented as a count of 0.\n+//!\n+//! # \"`cs`\" functions\n+//!\n+//! The `cs_...` functions (\"combine substructure) are designed to\n+//! make life easier by providing some pre-made recipes for common\n+//! threads; mostly calling the function being derived on all the\n+//! arguments and then combining them back together in some way (or\n+//! letting the user chose that). They are not meant to be the only\n+//! way to handle the structures that this code creates.\n+//!\n+//! # Examples\n+//!\n+//! The following simplified `PartialEq` is used for in-code examples:\n+//!\n+//! ```rust\n+//! trait PartialEq {\n+//!     fn eq(&self, other: &Self) -> bool;\n+//! }\n+//! impl PartialEq for i32 {\n+//!     fn eq(&self, other: &i32) -> bool {\n+//!         *self == *other\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Some examples of the values of `SubstructureFields` follow, using the\n+//! above `PartialEq`, `A`, `B` and `C`.\n+//!\n+//! ## Structs\n+//!\n+//! When generating the `expr` for the `A` impl, the `SubstructureFields` is\n+//!\n+//! ```{.text}\n+//! Struct(vec![FieldInfo {\n+//!            span: <span of x>\n+//!            name: Some(<ident of x>),\n+//!            self_: <expr for &self.x>,\n+//!            other: vec![<expr for &other.x]\n+//!          }])\n+//! ```\n+//!\n+//! For the `B` impl, called with `B(a)` and `B(b)`,\n+//!\n+//! ```{.text}\n+//! Struct(vec![FieldInfo {\n+//!           span: <span of `i32`>,\n+//!           name: None,\n+//!           self_: <expr for &a>\n+//!           other: vec![<expr for &b>]\n+//!          }])\n+//! ```\n+//!\n+//! ## Enums\n+//!\n+//! When generating the `expr` for a call with `self == C0(a)` and `other\n+//! == C0(b)`, the SubstructureFields is\n+//!\n+//! ```{.text}\n+//! EnumMatching(0, <ast::Variant for C0>,\n+//!              vec![FieldInfo {\n+//!                 span: <span of i32>\n+//!                 name: None,\n+//!                 self_: <expr for &a>,\n+//!                 other: vec![<expr for &b>]\n+//!               }])\n+//! ```\n+//!\n+//! For `C1 {x}` and `C1 {x}`,\n+//!\n+//! ```{.text}\n+//! EnumMatching(1, <ast::Variant for C1>,\n+//!              vec![FieldInfo {\n+//!                 span: <span of x>\n+//!                 name: Some(<ident of x>),\n+//!                 self_: <expr for &self.x>,\n+//!                 other: vec![<expr for &other.x>]\n+//!                }])\n+//! ```\n+//!\n+//! For `C0(a)` and `C1 {x}` ,\n+//!\n+//! ```{.text}\n+//! EnumNonMatchingCollapsed(\n+//!     vec![<ident of self>, <ident of __arg_1>],\n+//!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n+//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n+//! ```\n+//!\n+//! It is the same for when the arguments are flipped to `C1 {x}` and\n+//! `C0(a)`; the only difference is what the values of the identifiers\n+//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! be in the generated code.\n+//!\n+//! `EnumNonMatchingCollapsed` deliberately provides far less information\n+//! than is generally available for a given pair of variants; see #15375\n+//! for discussion.\n+//!\n+//! ## Static\n+//!\n+//! A static method on the types above would result in,\n+//!\n+//! ```{.text}\n+//! StaticStruct(<ast::VariantData of A>, Named(vec![(<ident of x>, <span of x>)]))\n+//!\n+//! StaticStruct(<ast::VariantData of B>, Unnamed(vec![<span of x>]))\n+//!\n+//! StaticEnum(<ast::EnumDef of C>,\n+//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of i32>])),\n+//!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n+//! ```\n+\n+pub use StaticFields::*;\n+pub use SubstructureFields::*;\n+\n+use std::cell::RefCell;\n+use std::iter;\n+use std::vec;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, BinOpKind, EnumDef, Expr, Generics, PatKind};\n+use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n+use rustc_attr as attr;\n+use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_expand::base::{Annotatable, ExtCtxt};\n+use rustc_span::source_map::respan;\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::Span;\n+\n+use ty::{Bounds, Path, Ptr, PtrTy, Self_, Ty};\n+\n+use crate::deriving;\n+\n+pub mod ty;\n+\n+pub struct TraitDef<'a> {\n+    /// The span for the current #[derive(Foo)] header.\n+    pub span: Span,\n+\n+    pub attributes: Vec<ast::Attribute>,\n+\n+    /// Path of the trait, including any type parameters\n+    pub path: Path,\n+\n+    /// Additional bounds required of any type parameters of the type,\n+    /// other than the current trait\n+    pub additional_bounds: Vec<Ty>,\n+\n+    /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n+    pub generics: Bounds,\n+\n+    /// Is it an `unsafe` trait?\n+    pub is_unsafe: bool,\n+\n+    /// Can this trait be derived for unions?\n+    pub supports_unions: bool,\n+\n+    pub methods: Vec<MethodDef<'a>>,\n+\n+    pub associated_types: Vec<(Ident, Ty)>,\n+}\n+\n+pub struct MethodDef<'a> {\n+    /// name of the method\n+    pub name: Symbol,\n+    /// List of generics, e.g., `R: rand::Rng`\n+    pub generics: Bounds,\n+\n+    /// Whether there is a self argument (outer Option) i.e., whether\n+    /// this is a static function, and whether it is a pointer (inner\n+    /// Option)\n+    pub explicit_self: Option<Option<PtrTy>>,\n+\n+    /// Arguments other than the self argument\n+    pub args: Vec<(Ty, Symbol)>,\n+\n+    /// Returns type\n+    pub ret_ty: Ty,\n+\n+    pub attributes: Vec<ast::Attribute>,\n+\n+    // Is it an `unsafe fn`?\n+    pub is_unsafe: bool,\n+\n+    /// Can we combine fieldless variants for enums into a single match arm?\n+    pub unify_fieldless_variants: bool,\n+\n+    pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n+}\n+\n+/// All the data about the data structure/method being derived upon.\n+pub struct Substructure<'a> {\n+    /// ident of self\n+    pub type_ident: Ident,\n+    /// ident of the method\n+    pub method_ident: Ident,\n+    /// dereferenced access to any `Self_` or `Ptr(Self_, _)` arguments\n+    pub self_args: &'a [P<Expr>],\n+    /// verbatim access to any other arguments\n+    pub nonself_args: &'a [P<Expr>],\n+    pub fields: &'a SubstructureFields<'a>,\n+}\n+\n+/// Summary of the relevant parts of a struct/enum field.\n+pub struct FieldInfo<'a> {\n+    pub span: Span,\n+    /// None for tuple structs/normal enum variants, Some for normal\n+    /// structs/struct enum variants.\n+    pub name: Option<Ident>,\n+    /// The expression corresponding to this field of `self`\n+    /// (specifically, a reference to it).\n+    pub self_: P<Expr>,\n+    /// The expressions corresponding to references to this field in\n+    /// the other `Self` arguments.\n+    pub other: Vec<P<Expr>>,\n+    /// The attributes on the field\n+    pub attrs: &'a [ast::Attribute],\n+}\n+\n+/// Fields for a static method\n+pub enum StaticFields {\n+    /// Tuple and unit structs/enum variants like this.\n+    Unnamed(Vec<Span>, bool /*is tuple*/),\n+    /// Normal structs/struct variants.\n+    Named(Vec<(Ident, Span)>),\n+}\n+\n+/// A summary of the possible sets of fields.\n+pub enum SubstructureFields<'a> {\n+    Struct(&'a ast::VariantData, Vec<FieldInfo<'a>>),\n+    /// Matching variants of the enum: variant index, variant count, ast::Variant,\n+    /// fields: the field name is only non-`None` in the case of a struct\n+    /// variant.\n+    EnumMatching(usize, usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n+\n+    /// Non-matching variants of the enum, but with all state hidden from\n+    /// the consequent code. The first component holds `Ident`s for all of\n+    /// the `Self` arguments; the second component is a slice of all of the\n+    /// variants for the enum itself, and the third component is a list of\n+    /// `Ident`s bound to the variant index values for each of the actual\n+    /// input `Self` arguments.\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [ast::Variant], &'a [Ident]),\n+\n+    /// A static method where `Self` is a struct.\n+    StaticStruct(&'a ast::VariantData, StaticFields),\n+    /// A static method where `Self` is an enum.\n+    StaticEnum(&'a ast::EnumDef, Vec<(Ident, Span, StaticFields)>),\n+}\n+\n+/// Combine the values of all the fields together. The last argument is\n+/// all the fields of all the structures.\n+pub type CombineSubstructureFunc<'a> =\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> P<Expr> + 'a>;\n+\n+/// Deal with non-matching enum variants. The tuple is a list of\n+/// identifiers (one for each `Self` argument, which could be any of the\n+/// variants since they have been collapsed together) and the identifiers\n+/// holding the variant index value for each of the `Self` arguments. The\n+/// last argument is all the non-`Self` args of the method being derived.\n+pub type EnumNonMatchCollapsedFunc<'a> =\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, (&[Ident], &[Ident]), &[P<Expr>]) -> P<Expr> + 'a>;\n+\n+pub fn combine_substructure(\n+    f: CombineSubstructureFunc<'_>,\n+) -> RefCell<CombineSubstructureFunc<'_>> {\n+    RefCell::new(f)\n+}\n+\n+/// This method helps to extract all the type parameters referenced from a\n+/// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n+/// is not global and starts with `T`, or a `TyQPath`.\n+fn find_type_parameters(\n+    ty: &ast::Ty,\n+    ty_param_names: &[Symbol],\n+    cx: &ExtCtxt<'_>,\n+) -> Vec<P<ast::Ty>> {\n+    use rustc_ast::visit;\n+\n+    struct Visitor<'a, 'b> {\n+        cx: &'a ExtCtxt<'b>,\n+        ty_param_names: &'a [Symbol],\n+        types: Vec<P<ast::Ty>>,\n+    }\n+\n+    impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n+        fn visit_ty(&mut self, ty: &'a ast::Ty) {\n+            if let ast::TyKind::Path(_, ref path) = ty.kind {\n+                if let Some(segment) = path.segments.first() {\n+                    if self.ty_param_names.contains(&segment.ident.name) {\n+                        self.types.push(P(ty.clone()));\n+                    }\n+                }\n+            }\n+\n+            visit::walk_ty(self, ty)\n+        }\n+\n+        fn visit_mac(&mut self, mac: &ast::MacCall) {\n+            self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n+        }\n+    }\n+\n+    let mut visitor = Visitor { cx, ty_param_names, types: Vec::new() };\n+    visit::Visitor::visit_ty(&mut visitor, ty);\n+\n+    visitor.types\n+}\n+\n+impl<'a> TraitDef<'a> {\n+    pub fn expand(\n+        self,\n+        cx: &mut ExtCtxt<'_>,\n+        mitem: &ast::MetaItem,\n+        item: &'a Annotatable,\n+        push: &mut dyn FnMut(Annotatable),\n+    ) {\n+        self.expand_ext(cx, mitem, item, push, false);\n+    }\n+\n+    pub fn expand_ext(\n+        self,\n+        cx: &mut ExtCtxt<'_>,\n+        mitem: &ast::MetaItem,\n+        item: &'a Annotatable,\n+        push: &mut dyn FnMut(Annotatable),\n+        from_scratch: bool,\n+    ) {\n+        match *item {\n+            Annotatable::Item(ref item) => {\n+                let is_packed = item.attrs.iter().any(|attr| {\n+                    for r in attr::find_repr_attrs(&cx.sess, attr) {\n+                        if let attr::ReprPacked(_) = r {\n+                            return true;\n+                        }\n+                    }\n+                    false\n+                });\n+                let has_no_type_params = match item.kind {\n+                    ast::ItemKind::Struct(_, ref generics)\n+                    | ast::ItemKind::Enum(_, ref generics)\n+                    | ast::ItemKind::Union(_, ref generics) => {\n+                        !generics.params.iter().any(|param| match param.kind {\n+                            ast::GenericParamKind::Type { .. } => true,\n+                            _ => false,\n+                        })\n+                    }\n+                    _ => {\n+                        // Non-ADT derive is an error, but it should have been\n+                        // set earlier; see\n+                        // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n+                        // librustc_expand/base.rs:Annotatable::derive_allowed()\n+                        return;\n+                    }\n+                };\n+                let container_id = cx.current_expansion.id.expn_data().parent;\n+                let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n+                let use_temporaries = is_packed && always_copy;\n+\n+                let newitem = match item.kind {\n+                    ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n+                        cx,\n+                        &struct_def,\n+                        item.ident,\n+                        generics,\n+                        from_scratch,\n+                        use_temporaries,\n+                    ),\n+                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                        // We ignore `use_temporaries` here, because\n+                        // `repr(packed)` enums cause an error later on.\n+                        //\n+                        // This can only cause further compilation errors\n+                        // downstream in blatantly illegal code, so it\n+                        // is fine.\n+                        self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n+                    }\n+                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                        if self.supports_unions {\n+                            self.expand_struct_def(\n+                                cx,\n+                                &struct_def,\n+                                item.ident,\n+                                generics,\n+                                from_scratch,\n+                                use_temporaries,\n+                            )\n+                        } else {\n+                            cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n+                            return;\n+                        }\n+                    }\n+                    _ => unreachable!(),\n+                };\n+                // Keep the lint attributes of the previous item to control how the\n+                // generated implementations are linted\n+                let mut attrs = newitem.attrs.clone();\n+                attrs.extend(\n+                    item.attrs\n+                        .iter()\n+                        .filter(|a| {\n+                            [\n+                                sym::allow,\n+                                sym::warn,\n+                                sym::deny,\n+                                sym::forbid,\n+                                sym::stable,\n+                                sym::unstable,\n+                            ]\n+                            .contains(&a.name_or_empty())\n+                        })\n+                        .cloned(),\n+                );\n+                push(Annotatable::Item(P(ast::Item { attrs, ..(*newitem).clone() })))\n+            }\n+            _ => {\n+                // Non-Item derive is an error, but it should have been\n+                // set earlier; see\n+                // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n+                // librustc_expand/base.rs:Annotatable::derive_allowed()\n+            }\n+        }\n+    }\n+\n+    /// Given that we are deriving a trait `DerivedTrait` for a type like:\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// struct Struct<'a, ..., 'z, A, B: DeclaredTrait, C, ..., Z> where C: WhereTrait {\n+    ///     a: A,\n+    ///     b: B::Item,\n+    ///     b1: <B as DeclaredTrait>::Item,\n+    ///     c1: <C as WhereTrait>::Item,\n+    ///     c2: Option<<C as WhereTrait>::Item>,\n+    ///     ...\n+    /// }\n+    /// ```\n+    ///\n+    /// create an impl like:\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// impl<'a, ..., 'z, A, B: DeclaredTrait, C, ... Z> where\n+    ///     C:                       WhereTrait,\n+    ///     A: DerivedTrait + B1 + ... + BN,\n+    ///     B: DerivedTrait + B1 + ... + BN,\n+    ///     C: DerivedTrait + B1 + ... + BN,\n+    ///     B::Item:                 DerivedTrait + B1 + ... + BN,\n+    ///     <C as WhereTrait>::Item: DerivedTrait + B1 + ... + BN,\n+    ///     ...\n+    /// {\n+    ///     ...\n+    /// }\n+    /// ```\n+    ///\n+    /// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n+    /// therefore does not get bound by the derived trait.\n+    fn create_derived_impl(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        type_ident: Ident,\n+        generics: &Generics,\n+        field_tys: Vec<P<ast::Ty>>,\n+        methods: Vec<P<ast::AssocItem>>,\n+    ) -> P<ast::Item> {\n+        let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n+\n+        // Transform associated types from `deriving::ty::Ty` into `ast::AssocItem`\n+        let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n+            P(ast::AssocItem {\n+                id: ast::DUMMY_NODE_ID,\n+                span: self.span,\n+                ident,\n+                vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                attrs: Vec::new(),\n+                kind: ast::AssocItemKind::TyAlias(\n+                    ast::Defaultness::Final,\n+                    Generics::default(),\n+                    Vec::new(),\n+                    Some(type_def.to_ty(cx, self.span, type_ident, generics)),\n+                ),\n+                tokens: None,\n+            })\n+        });\n+\n+        let Generics { mut params, mut where_clause, span } =\n+            self.generics.to_generics(cx, self.span, type_ident, generics);\n+\n+        // Create the generic parameters\n+        params.extend(generics.params.iter().map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => param.clone(),\n+            GenericParamKind::Type { .. } => {\n+                // I don't think this can be moved out of the loop, since\n+                // a GenericBound requires an ast id\n+                let bounds: Vec<_> =\n+                    // extra restrictions on the generics parameters to the\n+                    // type being derived upon\n+                    self.additional_bounds.iter().map(|p| {\n+                        cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n+                    }).chain(\n+                        // require the current trait\n+                        iter::once(cx.trait_bound(trait_path.clone()))\n+                    ).chain(\n+                        // also add in any bounds from the declaration\n+                        param.bounds.iter().cloned()\n+                    ).collect();\n+\n+                cx.typaram(self.span, param.ident, vec![], bounds, None)\n+            }\n+            GenericParamKind::Const { .. } => param.clone(),\n+        }));\n+\n+        // and similarly for where clauses\n+        where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n+            match *clause {\n+                ast::WherePredicate::BoundPredicate(ref wb) => {\n+                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                        span: self.span,\n+                        bound_generic_params: wb.bound_generic_params.clone(),\n+                        bounded_ty: wb.bounded_ty.clone(),\n+                        bounds: wb.bounds.to_vec(),\n+                    })\n+                }\n+                ast::WherePredicate::RegionPredicate(ref rb) => {\n+                    ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n+                        span: self.span,\n+                        lifetime: rb.lifetime,\n+                        bounds: rb.bounds.to_vec(),\n+                    })\n+                }\n+                ast::WherePredicate::EqPredicate(ref we) => {\n+                    ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: self.span,\n+                        lhs_ty: we.lhs_ty.clone(),\n+                        rhs_ty: we.rhs_ty.clone(),\n+                    })\n+                }\n+            }\n+        }));\n+\n+        {\n+            // Extra scope required here so ty_params goes out of scope before params is moved\n+\n+            let mut ty_params = params\n+                .iter()\n+                .filter_map(|param| match param.kind {\n+                    ast::GenericParamKind::Type { .. } => Some(param),\n+                    _ => None,\n+                })\n+                .peekable();\n+\n+            if ty_params.peek().is_some() {\n+                let ty_param_names: Vec<Symbol> =\n+                    ty_params.map(|ty_param| ty_param.ident.name).collect();\n+\n+                for field_ty in field_tys {\n+                    let tys = find_type_parameters(&field_ty, &ty_param_names, cx);\n+\n+                    for ty in tys {\n+                        // if we have already handled this type, skip it\n+                        if let ast::TyKind::Path(_, ref p) = ty.kind {\n+                            if p.segments.len() == 1\n+                                && ty_param_names.contains(&p.segments[0].ident.name)\n+                            {\n+                                continue;\n+                            };\n+                        }\n+                        let mut bounds: Vec<_> = self\n+                            .additional_bounds\n+                            .iter()\n+                            .map(|p| cx.trait_bound(p.to_path(cx, self.span, type_ident, generics)))\n+                            .collect();\n+\n+                        // require the current trait\n+                        bounds.push(cx.trait_bound(trait_path.clone()));\n+\n+                        let predicate = ast::WhereBoundPredicate {\n+                            span: self.span,\n+                            bound_generic_params: Vec::new(),\n+                            bounded_ty: ty,\n+                            bounds,\n+                        };\n+\n+                        let predicate = ast::WherePredicate::BoundPredicate(predicate);\n+                        where_clause.predicates.push(predicate);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let trait_generics = Generics { params, where_clause, span };\n+\n+        // Create the reference to the trait.\n+        let trait_ref = cx.trait_ref(trait_path);\n+\n+        let self_params: Vec<_> = generics\n+            .params\n+            .iter()\n+            .map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    GenericArg::Lifetime(cx.lifetime(self.span, param.ident))\n+                }\n+                GenericParamKind::Type { .. } => {\n+                    GenericArg::Type(cx.ty_ident(self.span, param.ident))\n+                }\n+                GenericParamKind::Const { .. } => {\n+                    GenericArg::Const(cx.const_ident(self.span, param.ident))\n+                }\n+            })\n+            .collect();\n+\n+        // Create the type of `self`.\n+        let path = cx.path_all(self.span, false, vec![type_ident], self_params);\n+        let self_type = cx.ty_path(path);\n+\n+        let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n+        // Just mark it now since we know that it'll end up used downstream\n+        cx.sess.mark_attr_used(&attr);\n+        let opt_trait_ref = Some(trait_ref);\n+        let unused_qual = {\n+            let word = rustc_ast::attr::mk_nested_word_item(Ident::new(\n+                sym::unused_qualifications,\n+                self.span,\n+            ));\n+            let list = rustc_ast::attr::mk_list_item(Ident::new(sym::allow, self.span), vec![word]);\n+            cx.attribute(list)\n+        };\n+\n+        let mut a = vec![attr, unused_qual];\n+        a.extend(self.attributes.iter().cloned());\n+\n+        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(self.span) } else { ast::Unsafe::No };\n+\n+        cx.item(\n+            self.span,\n+            Ident::invalid(),\n+            a,\n+            ast::ItemKind::Impl {\n+                unsafety,\n+                polarity: ast::ImplPolarity::Positive,\n+                defaultness: ast::Defaultness::Final,\n+                constness: ast::Const::No,\n+                generics: trait_generics,\n+                of_trait: opt_trait_ref,\n+                self_ty: self_type,\n+                items: methods.into_iter().chain(associated_types).collect(),\n+            },\n+        )\n+    }\n+\n+    fn expand_struct_def(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        struct_def: &'a VariantData,\n+        type_ident: Ident,\n+        generics: &Generics,\n+        from_scratch: bool,\n+        use_temporaries: bool,\n+    ) -> P<ast::Item> {\n+        let field_tys: Vec<P<ast::Ty>> =\n+            struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n+\n+        let methods = self\n+            .methods\n+            .iter()\n+            .map(|method_def| {\n+                let (explicit_self, self_args, nonself_args, tys) =\n+                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+\n+                let body = if from_scratch || method_def.is_static() {\n+                    method_def.expand_static_struct_method_body(\n+                        cx,\n+                        self,\n+                        struct_def,\n+                        type_ident,\n+                        &self_args[..],\n+                        &nonself_args[..],\n+                    )\n+                } else {\n+                    method_def.expand_struct_method_body(\n+                        cx,\n+                        self,\n+                        struct_def,\n+                        type_ident,\n+                        &self_args[..],\n+                        &nonself_args[..],\n+                        use_temporaries,\n+                    )\n+                };\n+\n+                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+            })\n+            .collect();\n+\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+    }\n+\n+    fn expand_enum_def(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        enum_def: &'a EnumDef,\n+        type_ident: Ident,\n+        generics: &Generics,\n+        from_scratch: bool,\n+    ) -> P<ast::Item> {\n+        let mut field_tys = Vec::new();\n+\n+        for variant in &enum_def.variants {\n+            field_tys.extend(variant.data.fields().iter().map(|field| field.ty.clone()));\n+        }\n+\n+        let methods = self\n+            .methods\n+            .iter()\n+            .map(|method_def| {\n+                let (explicit_self, self_args, nonself_args, tys) =\n+                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+\n+                let body = if from_scratch || method_def.is_static() {\n+                    method_def.expand_static_enum_method_body(\n+                        cx,\n+                        self,\n+                        enum_def,\n+                        type_ident,\n+                        &self_args[..],\n+                        &nonself_args[..],\n+                    )\n+                } else {\n+                    method_def.expand_enum_method_body(\n+                        cx,\n+                        self,\n+                        enum_def,\n+                        type_ident,\n+                        self_args,\n+                        &nonself_args[..],\n+                    )\n+                };\n+\n+                method_def.create_method(cx, self, type_ident, generics, explicit_self, tys, body)\n+            })\n+            .collect();\n+\n+        self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n+    }\n+}\n+\n+impl<'a> MethodDef<'a> {\n+    fn call_substructure_method(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        type_ident: Ident,\n+        self_args: &[P<Expr>],\n+        nonself_args: &[P<Expr>],\n+        fields: &SubstructureFields<'_>,\n+    ) -> P<Expr> {\n+        let substructure = Substructure {\n+            type_ident,\n+            method_ident: Ident::new(self.name, trait_.span),\n+            self_args,\n+            nonself_args,\n+            fields,\n+        };\n+        let mut f = self.combine_substructure.borrow_mut();\n+        let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n+        f(cx, trait_.span, &substructure)\n+    }\n+\n+    fn get_ret_ty(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        generics: &Generics,\n+        type_ident: Ident,\n+    ) -> P<ast::Ty> {\n+        self.ret_ty.to_ty(cx, trait_.span, type_ident, generics)\n+    }\n+\n+    fn is_static(&self) -> bool {\n+        self.explicit_self.is_none()\n+    }\n+\n+    fn split_self_nonself_args(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        type_ident: Ident,\n+        generics: &Generics,\n+    ) -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        let mut self_args = Vec::new();\n+        let mut nonself_args = Vec::new();\n+        let mut arg_tys = Vec::new();\n+        let mut nonstatic = false;\n+\n+        let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_.span, self_ptr);\n+\n+            self_args.push(self_expr);\n+            nonstatic = true;\n+\n+            explicit_self\n+        });\n+\n+        for (ty, name) in self.args.iter() {\n+            let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n+            let ident = Ident::new(*name, trait_.span);\n+            arg_tys.push((ident, ast_ty));\n+\n+            let arg_expr = cx.expr_ident(trait_.span, ident);\n+\n+            match *ty {\n+                // for static methods, just treat any Self\n+                // arguments as a normal arg\n+                Self_ if nonstatic => {\n+                    self_args.push(arg_expr);\n+                }\n+                Ptr(ref ty, _) if (if let Self_ = **ty { true } else { false }) && nonstatic => {\n+                    self_args.push(cx.expr_deref(trait_.span, arg_expr))\n+                }\n+                _ => {\n+                    nonself_args.push(arg_expr);\n+                }\n+            }\n+        }\n+\n+        (ast_explicit_self, self_args, nonself_args, arg_tys)\n+    }\n+\n+    fn create_method(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        type_ident: Ident,\n+        generics: &Generics,\n+        explicit_self: Option<ast::ExplicitSelf>,\n+        arg_types: Vec<(Ident, P<ast::Ty>)>,\n+        body: P<Expr>,\n+    ) -> P<ast::AssocItem> {\n+        // Create the generics that aren't for `Self`.\n+        let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n+\n+        let args = {\n+            let self_args = explicit_self.map(|explicit_self| {\n+                let ident = Ident::with_dummy_span(kw::SelfLower).with_span_pos(trait_.span);\n+                ast::Param::from_self(ast::AttrVec::default(), explicit_self, ident)\n+            });\n+            let nonself_args =\n+                arg_types.into_iter().map(|(name, ty)| cx.param(trait_.span, name, ty));\n+            self_args.into_iter().chain(nonself_args).collect()\n+        };\n+\n+        let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n+\n+        let method_ident = Ident::new(self.name, trait_.span);\n+        let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n+        let body_block = cx.block_expr(body);\n+\n+        let unsafety = if self.is_unsafe { ast::Unsafe::Yes(trait_.span) } else { ast::Unsafe::No };\n+\n+        let trait_lo_sp = trait_.span.shrink_to_lo();\n+\n+        let sig = ast::FnSig {\n+            header: ast::FnHeader { unsafety, ext: ast::Extern::None, ..ast::FnHeader::default() },\n+            decl: fn_decl,\n+            span: trait_.span,\n+        };\n+        let def = ast::Defaultness::Final;\n+\n+        // Create the method.\n+        P(ast::AssocItem {\n+            id: ast::DUMMY_NODE_ID,\n+            attrs: self.attributes.clone(),\n+            span: trait_.span,\n+            vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n+            ident: method_ident,\n+            kind: ast::AssocItemKind::Fn(def, sig, fn_generics, Some(body_block)),\n+            tokens: None,\n+        })\n+    }\n+\n+    /// ```\n+    /// #[derive(PartialEq)]\n+    /// # struct Dummy;\n+    /// struct A { x: i32, y: i32 }\n+    ///\n+    /// // equivalent to:\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, other: &A) -> bool {\n+    ///         match *self {\n+    ///             A {x: ref __self_0_0, y: ref __self_0_1} => {\n+    ///                 match *other {\n+    ///                     A {x: ref __self_1_0, y: ref __self_1_1} => {\n+    ///                         __self_0_0.eq(__self_1_0) && __self_0_1.eq(__self_1_1)\n+    ///                     }\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    ///\n+    /// // or if A is repr(packed) - note fields are matched by-value\n+    /// // instead of by-reference.\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, other: &A) -> bool {\n+    ///         match *self {\n+    ///             A {x: __self_0_0, y: __self_0_1} => {\n+    ///                 match other {\n+    ///                     A {x: __self_1_0, y: __self_1_1} => {\n+    ///                         __self_0_0.eq(&__self_1_0) && __self_0_1.eq(&__self_1_1)\n+    ///                     }\n+    ///                 }\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    fn expand_struct_method_body<'b>(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'b>,\n+        struct_def: &'b VariantData,\n+        type_ident: Ident,\n+        self_args: &[P<Expr>],\n+        nonself_args: &[P<Expr>],\n+        use_temporaries: bool,\n+    ) -> P<Expr> {\n+        let mut raw_fields = Vec::new(); // Vec<[fields of self],\n+        // [fields of next Self arg], [etc]>\n+        let mut patterns = Vec::new();\n+        for i in 0..self_args.len() {\n+            let struct_path = cx.path(trait_.span, vec![type_ident]);\n+            let (pat, ident_expr) = trait_.create_struct_pattern(\n+                cx,\n+                struct_path,\n+                struct_def,\n+                &format!(\"__self_{}\", i),\n+                ast::Mutability::Not,\n+                use_temporaries,\n+            );\n+            patterns.push(pat);\n+            raw_fields.push(ident_expr);\n+        }\n+\n+        // transpose raw_fields\n+        let fields = if !raw_fields.is_empty() {\n+            let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n+            let first_field = raw_fields.next().unwrap();\n+            let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n+            first_field\n+                .map(|(span, opt_id, field, attrs)| FieldInfo {\n+                    span,\n+                    name: opt_id,\n+                    self_: field,\n+                    other: other_fields\n+                        .iter_mut()\n+                        .map(|l| {\n+                            let (.., ex, _) = l.next().unwrap();\n+                            ex\n+                        })\n+                        .collect(),\n+                    attrs,\n+                })\n+                .collect()\n+        } else {\n+            cx.span_bug(trait_.span, \"no `self` parameter for method in generic `derive`\")\n+        };\n+\n+        // body of the inner most destructuring match\n+        let mut body = self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            self_args,\n+            nonself_args,\n+            &Struct(struct_def, fields),\n+        );\n+\n+        // make a series of nested matches, to destructure the\n+        // structs. This is actually right-to-left, but it shouldn't\n+        // matter.\n+        for (arg_expr, pat) in self_args.iter().zip(patterns) {\n+            body = cx.expr_match(\n+                trait_.span,\n+                arg_expr.clone(),\n+                vec![cx.arm(trait_.span, pat.clone(), body)],\n+            )\n+        }\n+\n+        body\n+    }\n+\n+    fn expand_static_struct_method_body(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        struct_def: &VariantData,\n+        type_ident: Ident,\n+        self_args: &[P<Expr>],\n+        nonself_args: &[P<Expr>],\n+    ) -> P<Expr> {\n+        let summary = trait_.summarise_struct(cx, struct_def);\n+\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            self_args,\n+            nonself_args,\n+            &StaticStruct(struct_def, summary),\n+        )\n+    }\n+\n+    /// ```\n+    /// #[derive(PartialEq)]\n+    /// # struct Dummy;\n+    /// enum A {\n+    ///     A1,\n+    ///     A2(i32)\n+    /// }\n+    ///\n+    /// // is equivalent to\n+    ///\n+    /// impl PartialEq for A {\n+    ///     fn eq(&self, other: &A) -> ::bool {\n+    ///         match (&*self, &*other) {\n+    ///             (&A1, &A1) => true,\n+    ///             (&A2(ref self_0),\n+    ///              &A2(ref __arg_1_0)) => (*self_0).eq(&(*__arg_1_0)),\n+    ///             _ => {\n+    ///                 let __self_vi = match *self { A1(..) => 0, A2(..) => 1 };\n+    ///                 let __arg_1_vi = match *other { A1(..) => 0, A2(..) => 1 };\n+    ///                 false\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// (Of course `__self_vi` and `__arg_1_vi` are unused for\n+    /// `PartialEq`, and those subcomputations will hopefully be removed\n+    /// as their results are unused. The point of `__self_vi` and\n+    /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n+    fn expand_enum_method_body<'b>(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'b>,\n+        enum_def: &'b EnumDef,\n+        type_ident: Ident,\n+        self_args: Vec<P<Expr>>,\n+        nonself_args: &[P<Expr>],\n+    ) -> P<Expr> {\n+        self.build_enum_match_tuple(cx, trait_, enum_def, type_ident, self_args, nonself_args)\n+    }\n+\n+    /// Creates a match for a tuple of all `self_args`, where either all\n+    /// variants match, or it falls into a catch-all for when one variant\n+    /// does not match.\n+\n+    /// There are N + 1 cases because is a case for each of the N\n+    /// variants where all of the variants match, and one catch-all for\n+    /// when one does not match.\n+\n+    /// As an optimization we generate code which checks whether all variants\n+    /// match first which makes llvm see that C-like enums can be compiled into\n+    /// a simple equality check (for PartialEq).\n+\n+    /// The catch-all handler is provided access the variant index values\n+    /// for each of the self-args, carried in precomputed variables.\n+\n+    /// ```{.text}\n+    /// let __self0_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&self) };\n+    /// let __self1_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg1) };\n+    /// let __self2_vi = unsafe {\n+    ///     std::intrinsics::discriminant_value(&arg2) };\n+    ///\n+    /// if __self0_vi == __self1_vi && __self0_vi == __self2_vi && ... {\n+    ///     match (...) {\n+    ///         (Variant1, Variant1, ...) => Body1\n+    ///         (Variant2, Variant2, ...) => Body2,\n+    ///         ...\n+    ///         _ => ::core::intrinsics::unreachable()\n+    ///     }\n+    /// }\n+    /// else {\n+    ///     ... // catch-all remainder can inspect above variant index values.\n+    /// }\n+    /// ```\n+    fn build_enum_match_tuple<'b>(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'b>,\n+        enum_def: &'b EnumDef,\n+        type_ident: Ident,\n+        mut self_args: Vec<P<Expr>>,\n+        nonself_args: &[P<Expr>],\n+    ) -> P<Expr> {\n+        let sp = trait_.span;\n+        let variants = &enum_def.variants;\n+\n+        let self_arg_names = iter::once(\"__self\".to_string())\n+            .chain(\n+                self_args\n+                    .iter()\n+                    .enumerate()\n+                    .skip(1)\n+                    .map(|(arg_count, _self_arg)| format!(\"__arg_{}\", arg_count)),\n+            )\n+            .collect::<Vec<String>>();\n+\n+        let self_arg_idents = self_arg_names\n+            .iter()\n+            .map(|name| Ident::from_str_and_span(name, sp))\n+            .collect::<Vec<Ident>>();\n+\n+        // The `vi_idents` will be bound, solely in the catch-all, to\n+        // a series of let statements mapping each self_arg to an int\n+        // value corresponding to its discriminant.\n+        let vi_idents = self_arg_names\n+            .iter()\n+            .map(|name| {\n+                let vi_suffix = format!(\"{}_vi\", &name[..]);\n+                Ident::from_str_and_span(&vi_suffix, trait_.span)\n+            })\n+            .collect::<Vec<Ident>>();\n+\n+        // Builds, via callback to call_substructure_method, the\n+        // delegated expression that handles the catch-all case,\n+        // using `__variants_tuple` to drive logic if necessary.\n+        let catch_all_substructure =\n+            EnumNonMatchingCollapsed(self_arg_idents, &variants[..], &vi_idents[..]);\n+\n+        let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n+\n+        // These arms are of the form:\n+        // (Variant1, Variant1, ...) => Body1\n+        // (Variant2, Variant2, ...) => Body2\n+        // ...\n+        // where each tuple has length = self_args.len()\n+        let mut match_arms: Vec<ast::Arm> = variants\n+            .iter()\n+            .enumerate()\n+            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n+            .map(|(index, variant)| {\n+                let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n+                    let (p, idents) = trait_.create_enum_variant_pattern(\n+                        cx,\n+                        type_ident,\n+                        variant,\n+                        self_arg_name,\n+                        ast::Mutability::Not,\n+                    );\n+                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Not)), idents)\n+                };\n+\n+                // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n+                // (see \"Final wrinkle\" note below for why.)\n+                let mut subpats = Vec::with_capacity(self_arg_names.len());\n+                let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n+                let first_self_pat_idents = {\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n+                    subpats.push(p);\n+                    idents\n+                };\n+                for self_arg_name in &self_arg_names[1..] {\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_name[..]);\n+                    subpats.push(p);\n+                    self_pats_idents.push(idents);\n+                }\n+\n+                // Here is the pat = `(&VariantK, &VariantK, ...)`\n+                let single_pat = cx.pat_tuple(sp, subpats);\n+\n+                // For the BodyK, we need to delegate to our caller,\n+                // passing it an EnumMatching to indicate which case\n+                // we are in.\n+\n+                // All of the Self args have the same variant in these\n+                // cases.  So we transpose the info in self_pats_idents\n+                // to gather the getter expressions together, in the\n+                // form that EnumMatching expects.\n+\n+                // The transposition is driven by walking across the\n+                // arg fields of the variant for the first self pat.\n+                let field_tuples = first_self_pat_idents\n+                    .into_iter()\n+                    .enumerate()\n+                    // For each arg field of self, pull out its getter expr ...\n+                    .map(|(field_index, (sp, opt_ident, self_getter_expr, attrs))| {\n+                        // ... but FieldInfo also wants getter expr\n+                        // for matching other arguments of Self type;\n+                        // so walk across the *other* self_pats_idents\n+                        // and pull out getter for same field in each\n+                        // of them (using `field_index` tracked above).\n+                        // That is the heart of the transposition.\n+                        let others = self_pats_idents\n+                            .iter()\n+                            .map(|fields| {\n+                                let (_, _opt_ident, ref other_getter_expr, _) = fields[field_index];\n+\n+                                // All Self args have same variant, so\n+                                // opt_idents are the same.  (Assert\n+                                // here to make it self-evident that\n+                                // it is okay to ignore `_opt_ident`.)\n+                                assert!(opt_ident == _opt_ident);\n+\n+                                other_getter_expr.clone()\n+                            })\n+                            .collect::<Vec<P<Expr>>>();\n+\n+                        FieldInfo {\n+                            span: sp,\n+                            name: opt_ident,\n+                            self_: self_getter_expr,\n+                            other: others,\n+                            attrs,\n+                        }\n+                    })\n+                    .collect::<Vec<FieldInfo<'_>>>();\n+\n+                // Now, for some given VariantK, we have built up\n+                // expressions for referencing every field of every\n+                // Self arg, assuming all are instances of VariantK.\n+                // Build up code associated with such a case.\n+                let substructure = EnumMatching(index, variants.len(), variant, field_tuples);\n+                let arm_expr = self.call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    &self_args[..],\n+                    nonself_args,\n+                    &substructure,\n+                );\n+\n+                cx.arm(sp, single_pat, arm_expr)\n+            })\n+            .collect();\n+\n+        let default = match first_fieldless {\n+            Some(v) if self.unify_fieldless_variants => {\n+                // We need a default case that handles the fieldless variants.\n+                // The index and actual variant aren't meaningful in this case,\n+                // so just use whatever\n+                let substructure = EnumMatching(0, variants.len(), v, Vec::new());\n+                Some(self.call_substructure_method(\n+                    cx,\n+                    trait_,\n+                    type_ident,\n+                    &self_args[..],\n+                    nonself_args,\n+                    &substructure,\n+                ))\n+            }\n+            _ if variants.len() > 1 && self_args.len() > 1 => {\n+                // Since we know that all the arguments will match if we reach\n+                // the match expression we add the unreachable intrinsics as the\n+                // result of the catch all which should help llvm in optimizing it\n+                Some(deriving::call_intrinsic(cx, sp, sym::unreachable, vec![]))\n+            }\n+            _ => None,\n+        };\n+        if let Some(arm) = default {\n+            match_arms.push(cx.arm(sp, cx.pat_wild(sp), arm));\n+        }\n+\n+        // We will usually need the catch-all after matching the\n+        // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n+        // enum.  But:\n+        //\n+        // * when there is only one Self arg, the arms above suffice\n+        // (and the deriving we call back into may not be prepared to\n+        // handle EnumNonMatchCollapsed), and,\n+        //\n+        // * when the enum has only one variant, the single arm that\n+        // is already present always suffices.\n+        //\n+        // * In either of the two cases above, if we *did* add a\n+        //   catch-all `_` match, it would trigger the\n+        //   unreachable-pattern error.\n+        //\n+        if variants.len() > 1 && self_args.len() > 1 {\n+            // Build a series of let statements mapping each self_arg\n+            // to its discriminant value.\n+            //\n+            // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n+            // with three Self args, builds three statements:\n+            //\n+            // ```\n+            // let __self0_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&self) };\n+            // let __self1_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg1) };\n+            // let __self2_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&arg2) };\n+            // ```\n+            let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n+\n+            // We also build an expression which checks whether all discriminants are equal\n+            // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n+            let mut discriminant_test = cx.expr_bool(sp, true);\n+\n+            let mut first_ident = None;\n+            for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n+                let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n+                let variant_value =\n+                    deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n+                index_let_stmts.push(let_stmt);\n+\n+                match first_ident {\n+                    Some(first) => {\n+                        let first_expr = cx.expr_ident(sp, first);\n+                        let id = cx.expr_ident(sp, ident);\n+                        let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n+                        discriminant_test =\n+                            cx.expr_binary(sp, BinOpKind::And, discriminant_test, test)\n+                    }\n+                    None => {\n+                        first_ident = Some(ident);\n+                    }\n+                }\n+            }\n+\n+            let arm_expr = self.call_substructure_method(\n+                cx,\n+                trait_,\n+                type_ident,\n+                &self_args[..],\n+                nonself_args,\n+                &catch_all_substructure,\n+            );\n+\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired places, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n+\n+            // Lastly we create an expression which branches on all discriminants being equal\n+            //  if discriminant_test {\n+            //      match (...) {\n+            //          (Variant1, Variant1, ...) => Body1\n+            //          (Variant2, Variant2, ...) => Body2,\n+            //          ...\n+            //          _ => ::core::intrinsics::unreachable()\n+            //      }\n+            //  }\n+            //  else {\n+            //      <delegated expression referring to __self0_vi, et al.>\n+            //  }\n+            let all_match = cx.expr_match(sp, match_arg, match_arms);\n+            let arm_expr = cx.expr_if(sp, discriminant_test, all_match, Some(arm_expr));\n+            index_let_stmts.push(cx.stmt_expr(arm_expr));\n+            cx.expr_block(cx.block(sp, index_let_stmts))\n+        } else if variants.is_empty() {\n+            // As an additional wrinkle, For a zero-variant enum A,\n+            // currently the compiler\n+            // will accept `fn (a: &Self) { match   *a   { } }`\n+            // but rejects `fn (a: &Self) { match (&*a,) { } }`\n+            // as well as  `fn (a: &Self) { match ( *a,) { } }`\n+            //\n+            // This means that the strategy of building up a tuple of\n+            // all Self arguments fails when Self is a zero variant\n+            // enum: rustc rejects the expanded program, even though\n+            // the actual code tends to be impossible to execute (at\n+            // least safely), according to the type system.\n+            //\n+            // The most expedient fix for this is to just let the\n+            // code fall through to the catch-all.  But even this is\n+            // error-prone, since the catch-all as defined above would\n+            // generate code like this:\n+            //\n+            //     _ => { let __self0 = match *self { };\n+            //            let __self1 = match *__arg_0 { };\n+            //            <catch-all-expr> }\n+            //\n+            // Which is yields bindings for variables which type\n+            // inference cannot resolve to unique types.\n+            //\n+            // One option to the above might be to add explicit type\n+            // annotations.  But the *only* reason to go down that path\n+            // would be to try to make the expanded output consistent\n+            // with the case when the number of enum variants >= 1.\n+            //\n+            // That just isn't worth it.  In fact, trying to generate\n+            // sensible code for *any* deriving on a zero-variant enum\n+            // does not make sense.  But at the same time, for now, we\n+            // do not want to cause a compile failure just because the\n+            // user happened to attach a deriving to their\n+            // zero-variant enum.\n+            //\n+            // Instead, just generate a failing expression for the\n+            // zero variant case, skipping matches and also skipping\n+            // delegating back to the end user code entirely.\n+            //\n+            // (See also #4499 and #12609; note that some of the\n+            // discussions there influence what choice we make here;\n+            // e.g., if we feature-gate `match x { ... }` when x refers\n+            // to an uninhabited type (e.g., a zero-variant enum or a\n+            // type holding such an enum), but do not feature-gate\n+            // zero-variant enums themselves, then attempting to\n+            // derive Debug on such a type could here generate code\n+            // that needs the feature gate enabled.)\n+\n+            deriving::call_intrinsic(cx, sp, sym::unreachable, vec![])\n+        } else {\n+            // Final wrinkle: the self_args are expressions that deref\n+            // down to desired places, but we cannot actually deref\n+            // them when they are fed as r-values into a tuple\n+            // expression; here add a layer of borrowing, turning\n+            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+            self_args.map_in_place(|self_arg| cx.expr_addr_of(sp, self_arg));\n+            let match_arg = cx.expr(sp, ast::ExprKind::Tup(self_args));\n+            cx.expr_match(sp, match_arg, match_arms)\n+        }\n+    }\n+\n+    fn expand_static_enum_method_body(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        trait_: &TraitDef<'_>,\n+        enum_def: &EnumDef,\n+        type_ident: Ident,\n+        self_args: &[P<Expr>],\n+        nonself_args: &[P<Expr>],\n+    ) -> P<Expr> {\n+        let summary = enum_def\n+            .variants\n+            .iter()\n+            .map(|v| {\n+                let sp = v.span.with_ctxt(trait_.span.ctxt());\n+                let summary = trait_.summarise_struct(cx, &v.data);\n+                (v.ident, sp, summary)\n+            })\n+            .collect();\n+        self.call_substructure_method(\n+            cx,\n+            trait_,\n+            type_ident,\n+            self_args,\n+            nonself_args,\n+            &StaticEnum(enum_def, summary),\n+        )\n+    }\n+}\n+\n+// general helper methods.\n+impl<'a> TraitDef<'a> {\n+    fn summarise_struct(&self, cx: &mut ExtCtxt<'_>, struct_def: &VariantData) -> StaticFields {\n+        let mut named_idents = Vec::new();\n+        let mut just_spans = Vec::new();\n+        for field in struct_def.fields() {\n+            let sp = field.span.with_ctxt(self.span.ctxt());\n+            match field.ident {\n+                Some(ident) => named_idents.push((ident, sp)),\n+                _ => just_spans.push(sp),\n+            }\n+        }\n+\n+        let is_tuple = if let ast::VariantData::Tuple(..) = struct_def { true } else { false };\n+        match (just_spans.is_empty(), named_idents.is_empty()) {\n+            (false, false) => cx.span_bug(\n+                self.span,\n+                \"a struct with named and unnamed \\\n+                                          fields in generic `derive`\",\n+            ),\n+            // named fields\n+            (_, false) => Named(named_idents),\n+            // unnamed fields\n+            (false, _) => Unnamed(just_spans, is_tuple),\n+            // empty\n+            _ => Named(Vec::new()),\n+        }\n+    }\n+\n+    fn create_subpatterns(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        field_paths: Vec<Ident>,\n+        mutbl: ast::Mutability,\n+        use_temporaries: bool,\n+    ) -> Vec<P<ast::Pat>> {\n+        field_paths\n+            .iter()\n+            .map(|path| {\n+                let binding_mode = if use_temporaries {\n+                    ast::BindingMode::ByValue(ast::Mutability::Not)\n+                } else {\n+                    ast::BindingMode::ByRef(mutbl)\n+                };\n+                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n+            })\n+            .collect()\n+    }\n+\n+    fn create_struct_pattern(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        struct_path: ast::Path,\n+        struct_def: &'a VariantData,\n+        prefix: &str,\n+        mutbl: ast::Mutability,\n+        use_temporaries: bool,\n+    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n+        let mut paths = Vec::new();\n+        let mut ident_exprs = Vec::new();\n+        for (i, struct_field) in struct_def.fields().iter().enumerate() {\n+            let sp = struct_field.span.with_ctxt(self.span.ctxt());\n+            let ident = Ident::from_str_and_span(&format!(\"{}_{}\", prefix, i), self.span);\n+            paths.push(ident.with_span_pos(sp));\n+            let val = cx.expr_path(cx.path_ident(sp, ident));\n+            let val = if use_temporaries { val } else { cx.expr_deref(sp, val) };\n+            let val = cx.expr(sp, ast::ExprKind::Paren(val));\n+\n+            ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n+        }\n+\n+        let subpats = self.create_subpatterns(cx, paths, mutbl, use_temporaries);\n+        let pattern = match *struct_def {\n+            VariantData::Struct(..) => {\n+                let field_pats = subpats\n+                    .into_iter()\n+                    .zip(&ident_exprs)\n+                    .map(|(pat, &(sp, ident, ..))| {\n+                        if ident.is_none() {\n+                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n+                        }\n+                        ast::FieldPat {\n+                            ident: ident.unwrap(),\n+                            is_shorthand: false,\n+                            attrs: ast::AttrVec::new(),\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: pat.span.with_ctxt(self.span.ctxt()),\n+                            pat,\n+                            is_placeholder: false,\n+                        }\n+                    })\n+                    .collect();\n+                cx.pat_struct(self.span, struct_path, field_pats)\n+            }\n+            VariantData::Tuple(..) => cx.pat_tuple_struct(self.span, struct_path, subpats),\n+            VariantData::Unit(..) => cx.pat_path(self.span, struct_path),\n+        };\n+\n+        (pattern, ident_exprs)\n+    }\n+\n+    fn create_enum_variant_pattern(\n+        &self,\n+        cx: &mut ExtCtxt<'_>,\n+        enum_ident: Ident,\n+        variant: &'a ast::Variant,\n+        prefix: &str,\n+        mutbl: ast::Mutability,\n+    ) -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n+        let sp = variant.span.with_ctxt(self.span.ctxt());\n+        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n+        let use_temporaries = false; // enums can't be repr(packed)\n+        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl, use_temporaries)\n+    }\n+}\n+\n+// helpful premade recipes\n+\n+pub fn cs_fold_fields<'a, F>(\n+    use_foldl: bool,\n+    mut f: F,\n+    base: P<Expr>,\n+    cx: &mut ExtCtxt<'_>,\n+    all_fields: &[FieldInfo<'a>],\n+) -> P<Expr>\n+where\n+    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+{\n+    if use_foldl {\n+        all_fields\n+            .iter()\n+            .fold(base, |old, field| f(cx, field.span, old, field.self_.clone(), &field.other))\n+    } else {\n+        all_fields\n+            .iter()\n+            .rev()\n+            .fold(base, |old, field| f(cx, field.span, old, field.self_.clone(), &field.other))\n+    }\n+}\n+\n+pub fn cs_fold_enumnonmatch(\n+    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substructure: &Substructure<'_>,\n+) -> P<Expr> {\n+    match *substructure.fields {\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n+            enum_nonmatch_f(cx, trait_span, (&all_args[..], tuple), substructure.nonself_args)\n+        }\n+        _ => cx.span_bug(trait_span, \"cs_fold_enumnonmatch expected an EnumNonMatchingCollapsed\"),\n+    }\n+}\n+\n+pub fn cs_fold_static(cx: &mut ExtCtxt<'_>, trait_span: Span) -> P<Expr> {\n+    cx.span_bug(trait_span, \"static function in `derive`\")\n+}\n+\n+/// Fold the fields. `use_foldl` controls whether this is done\n+/// left-to-right (`true`) or right-to-left (`false`).\n+pub fn cs_fold<F>(\n+    use_foldl: bool,\n+    f: F,\n+    base: P<Expr>,\n+    enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substructure: &Substructure<'_>,\n+) -> P<Expr>\n+where\n+    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+{\n+    match *substructure.fields {\n+        EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n+        }\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => cs_fold_static(cx, trait_span),\n+    }\n+}\n+\n+/// Function to fold over fields, with three cases, to generate more efficient and concise code.\n+/// When the `substructure` has grouped fields, there are two cases:\n+/// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`).\n+/// One or more fields: call the base case function on the first value (which depends on\n+/// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n+/// fields.\n+/// When the `substructure` is a `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n+/// is returned. Statics may not be folded over.\n+/// See `cs_op` in `partial_ord.rs` for a model example.\n+pub fn cs_fold1<F, B>(\n+    use_foldl: bool,\n+    f: F,\n+    mut b: B,\n+    enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+    cx: &mut ExtCtxt<'_>,\n+    trait_span: Span,\n+    substructure: &Substructure<'_>,\n+) -> P<Expr>\n+where\n+    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+    B: FnMut(&mut ExtCtxt<'_>, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>,\n+{\n+    match *substructure.fields {\n+        EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n+            let (base, all_fields) = match (all_fields.is_empty(), use_foldl) {\n+                (false, true) => {\n+                    let field = &all_fields[0];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[1..])\n+                }\n+                (false, false) => {\n+                    let idx = all_fields.len() - 1;\n+                    let field = &all_fields[idx];\n+                    let args = (field.span, field.self_.clone(), &field.other[..]);\n+                    (b(cx, Some(args)), &all_fields[..idx])\n+                }\n+                (true, _) => (b(cx, None), &all_fields[..]),\n+            };\n+\n+            cs_fold_fields(use_foldl, f, base, cx, all_fields)\n+        }\n+        EnumNonMatchingCollapsed(..) => {\n+            cs_fold_enumnonmatch(enum_nonmatch_f, cx, trait_span, substructure)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => cs_fold_static(cx, trait_span),\n+    }\n+}\n+\n+/// Returns `true` if the type has no value fields\n+/// (for an enum, no variant has any fields)\n+pub fn is_type_without_fields(item: &Annotatable) -> bool {\n+    if let Annotatable::Item(ref item) = *item {\n+        match item.kind {\n+            ast::ItemKind::Enum(ref enum_def, _) => {\n+                enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n+            }\n+            ast::ItemKind::Struct(ref variant_data, _) => variant_data.fields().is_empty(),\n+            _ => false,\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "6b7d0e1f204b5f0a9712db0f32bc9efa547725ac", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,280 @@\n+//! A mini version of ast::Ty, which is easier to use, and features an explicit `Self` type to use\n+//! when specifying impls to be derived.\n+\n+pub use PtrTy::*;\n+pub use Ty::*;\n+\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Expr, GenericArg, GenericParamKind, Generics, SelfKind};\n+use rustc_expand::base::ExtCtxt;\n+use rustc_span::source_map::{respan, DUMMY_SP};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::Span;\n+\n+/// The types of pointers\n+#[derive(Clone)]\n+pub enum PtrTy {\n+    /// &'lifetime mut\n+    Borrowed(Option<Ident>, ast::Mutability),\n+    /// *mut\n+    #[allow(dead_code)]\n+    Raw(ast::Mutability),\n+}\n+\n+/// A path, e.g., `::std::option::Option::<i32>` (global). Has support\n+/// for type parameters and a lifetime.\n+#[derive(Clone)]\n+pub struct Path {\n+    path: Vec<Symbol>,\n+    lifetime: Option<Ident>,\n+    params: Vec<Box<Ty>>,\n+    kind: PathKind,\n+}\n+\n+#[derive(Clone)]\n+pub enum PathKind {\n+    Local,\n+    Global,\n+    Std,\n+}\n+\n+impl Path {\n+    pub fn new(path: Vec<Symbol>) -> Path {\n+        Path::new_(path, None, Vec::new(), PathKind::Std)\n+    }\n+    pub fn new_local(path: Symbol) -> Path {\n+        Path::new_(vec![path], None, Vec::new(), PathKind::Local)\n+    }\n+    pub fn new_(\n+        path: Vec<Symbol>,\n+        lifetime: Option<Ident>,\n+        params: Vec<Box<Ty>>,\n+        kind: PathKind,\n+    ) -> Path {\n+        Path { path, lifetime, params, kind }\n+    }\n+\n+    pub fn to_ty(\n+        &self,\n+        cx: &ExtCtxt<'_>,\n+        span: Span,\n+        self_ty: Ident,\n+        self_generics: &Generics,\n+    ) -> P<ast::Ty> {\n+        cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n+    }\n+    pub fn to_path(\n+        &self,\n+        cx: &ExtCtxt<'_>,\n+        span: Span,\n+        self_ty: Ident,\n+        self_generics: &Generics,\n+    ) -> ast::Path {\n+        let mut idents = self.path.iter().map(|s| Ident::new(*s, span)).collect();\n+        let lt = mk_lifetimes(cx, span, &self.lifetime);\n+        let tys: Vec<P<ast::Ty>> =\n+            self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n+        let params = lt\n+            .into_iter()\n+            .map(GenericArg::Lifetime)\n+            .chain(tys.into_iter().map(GenericArg::Type))\n+            .collect();\n+\n+        match self.kind {\n+            PathKind::Global => cx.path_all(span, true, idents, params),\n+            PathKind::Local => cx.path_all(span, false, idents, params),\n+            PathKind::Std => {\n+                let def_site = cx.with_def_site_ctxt(DUMMY_SP);\n+                idents.insert(0, Ident::new(kw::DollarCrate, def_site));\n+                cx.path_all(span, false, idents, params)\n+            }\n+        }\n+    }\n+}\n+\n+/// A type. Supports pointers, Self, and literals.\n+#[derive(Clone)]\n+pub enum Ty {\n+    Self_,\n+    /// &/Box/ Ty\n+    Ptr(Box<Ty>, PtrTy),\n+    /// `mod::mod::Type<[lifetime], [Params...]>`, including a plain type\n+    /// parameter, and things like `i32`\n+    Literal(Path),\n+    /// includes unit\n+    Tuple(Vec<Ty>),\n+}\n+\n+pub fn borrowed_ptrty() -> PtrTy {\n+    Borrowed(None, ast::Mutability::Not)\n+}\n+pub fn borrowed(ty: Box<Ty>) -> Ty {\n+    Ptr(ty, borrowed_ptrty())\n+}\n+\n+pub fn borrowed_explicit_self() -> Option<Option<PtrTy>> {\n+    Some(Some(borrowed_ptrty()))\n+}\n+\n+pub fn borrowed_self() -> Ty {\n+    borrowed(Box::new(Self_))\n+}\n+\n+pub fn nil_ty() -> Ty {\n+    Tuple(Vec::new())\n+}\n+\n+fn mk_lifetime(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Option<ast::Lifetime> {\n+    lt.map(|ident| cx.lifetime(span, ident))\n+}\n+\n+fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<Ident>) -> Vec<ast::Lifetime> {\n+    mk_lifetime(cx, span, lt).into_iter().collect()\n+}\n+\n+impl Ty {\n+    pub fn to_ty(\n+        &self,\n+        cx: &ExtCtxt<'_>,\n+        span: Span,\n+        self_ty: Ident,\n+        self_generics: &Generics,\n+    ) -> P<ast::Ty> {\n+        match *self {\n+            Ptr(ref ty, ref ptr) => {\n+                let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n+                match *ptr {\n+                    Borrowed(ref lt, mutbl) => {\n+                        let lt = mk_lifetime(cx, span, lt);\n+                        cx.ty_rptr(span, raw_ty, lt, mutbl)\n+                    }\n+                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl),\n+                }\n+            }\n+            Literal(ref p) => p.to_ty(cx, span, self_ty, self_generics),\n+            Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n+            Tuple(ref fields) => {\n+                let ty = ast::TyKind::Tup(\n+                    fields.iter().map(|f| f.to_ty(cx, span, self_ty, self_generics)).collect(),\n+                );\n+                cx.ty(span, ty)\n+            }\n+        }\n+    }\n+\n+    pub fn to_path(\n+        &self,\n+        cx: &ExtCtxt<'_>,\n+        span: Span,\n+        self_ty: Ident,\n+        generics: &Generics,\n+    ) -> ast::Path {\n+        match *self {\n+            Self_ => {\n+                let params: Vec<_> = generics\n+                    .params\n+                    .iter()\n+                    .map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            GenericArg::Lifetime(ast::Lifetime { id: param.id, ident: param.ident })\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            GenericArg::Type(cx.ty_ident(span, param.ident))\n+                        }\n+                        GenericParamKind::Const { .. } => {\n+                            GenericArg::Const(cx.const_ident(span, param.ident))\n+                        }\n+                    })\n+                    .collect();\n+\n+                cx.path_all(span, false, vec![self_ty], params)\n+            }\n+            Literal(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),\n+            Tuple(..) => cx.span_bug(span, \"tuple in a path in generic `derive`\"),\n+        }\n+    }\n+}\n+\n+fn mk_ty_param(\n+    cx: &ExtCtxt<'_>,\n+    span: Span,\n+    name: Symbol,\n+    attrs: &[ast::Attribute],\n+    bounds: &[Path],\n+    self_ident: Ident,\n+    self_generics: &Generics,\n+) -> ast::GenericParam {\n+    let bounds = bounds\n+        .iter()\n+        .map(|b| {\n+            let path = b.to_path(cx, span, self_ident, self_generics);\n+            cx.trait_bound(path)\n+        })\n+        .collect();\n+    cx.typaram(span, Ident::new(name, span), attrs.to_owned(), bounds, None)\n+}\n+\n+fn mk_generics(params: Vec<ast::GenericParam>, span: Span) -> Generics {\n+    Generics {\n+        params,\n+        where_clause: ast::WhereClause { has_where_token: false, predicates: Vec::new(), span },\n+        span,\n+    }\n+}\n+\n+/// Bounds on type parameters.\n+#[derive(Clone)]\n+pub struct Bounds {\n+    pub bounds: Vec<(Symbol, Vec<Path>)>,\n+}\n+\n+impl Bounds {\n+    pub fn empty() -> Bounds {\n+        Bounds { bounds: Vec::new() }\n+    }\n+    pub fn to_generics(\n+        &self,\n+        cx: &ExtCtxt<'_>,\n+        span: Span,\n+        self_ty: Ident,\n+        self_generics: &Generics,\n+    ) -> Generics {\n+        let generic_params = self\n+            .bounds\n+            .iter()\n+            .map(|t| {\n+                let (name, ref bounds) = *t;\n+                mk_ty_param(cx, span, name, &[], &bounds, self_ty, self_generics)\n+            })\n+            .collect();\n+\n+        mk_generics(generic_params, span)\n+    }\n+}\n+\n+pub fn get_explicit_self(\n+    cx: &ExtCtxt<'_>,\n+    span: Span,\n+    self_ptr: &Option<PtrTy>,\n+) -> (P<Expr>, ast::ExplicitSelf) {\n+    // this constructs a fresh `self` path\n+    let self_path = cx.expr_self(span);\n+    match *self_ptr {\n+        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Not))),\n+        Some(ref ptr) => {\n+            let self_ty = respan(\n+                span,\n+                match *ptr {\n+                    Borrowed(ref lt, mutbl) => {\n+                        let lt = lt.map(|s| cx.lifetime(span, s));\n+                        SelfKind::Region(lt, mutbl)\n+                    }\n+                    Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\"),\n+                },\n+            );\n+            let self_expr = cx.expr_deref(span, self_path);\n+            (self_expr, self_ty)\n+        }\n+    }\n+}"}, {"sha": "868f863b990212d927d9a8aad398d38f48b361c2", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,8 +2,8 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{self, path_std, pathvec_std};\n \n-use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n+use rustc_ast::{Expr, MetaItem, Mutability};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;", "previous_filename": "src/librustc_builtin_macros/deriving/hash.rs"}, {"sha": "7e3fd131d4417c49ae7994976c56d0cb3b615732", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,173 @@\n+//! The compiler code necessary to implement the `#[derive]` extensions.\n+\n+use rustc_ast as ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::{ItemKind, MetaItem};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::Span;\n+\n+macro path_local($x:ident) {\n+    generic::ty::Path::new_local(sym::$x)\n+}\n+\n+macro pathvec_std($($rest:ident)::+) {{\n+    vec![ $( sym::$rest ),+ ]\n+}}\n+\n+macro path_std($($x:tt)*) {\n+    generic::ty::Path::new( pathvec_std!( $($x)* ) )\n+}\n+\n+pub mod bounds;\n+pub mod clone;\n+pub mod debug;\n+pub mod decodable;\n+pub mod default;\n+pub mod encodable;\n+pub mod hash;\n+\n+#[path = \"cmp/eq.rs\"]\n+pub mod eq;\n+#[path = \"cmp/ord.rs\"]\n+pub mod ord;\n+#[path = \"cmp/partial_eq.rs\"]\n+pub mod partial_eq;\n+#[path = \"cmp/partial_ord.rs\"]\n+pub mod partial_ord;\n+\n+pub mod generic;\n+\n+crate struct BuiltinDerive(\n+    crate fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n+);\n+\n+impl MultiItemModifier for BuiltinDerive {\n+    fn expand(\n+        &self,\n+        ecx: &mut ExtCtxt<'_>,\n+        span: Span,\n+        meta_item: &MetaItem,\n+        item: Annotatable,\n+    ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n+        // FIXME: Built-in derives often forget to give spans contexts,\n+        // so we are doing it here in a centralized way.\n+        let span = ecx.with_def_site_ctxt(span);\n+        let mut items = Vec::new();\n+        (self.0)(ecx, span, meta_item, &item, &mut |a| items.push(a));\n+        ExpandResult::Ready(items)\n+    }\n+}\n+\n+/// Constructs an expression that calls an intrinsic\n+fn call_intrinsic(\n+    cx: &ExtCtxt<'_>,\n+    span: Span,\n+    intrinsic: Symbol,\n+    args: Vec<P<ast::Expr>>,\n+) -> P<ast::Expr> {\n+    let span = cx.with_def_site_ctxt(span);\n+    let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n+    let call = cx.expr_call_global(span, path, args);\n+\n+    cx.expr_block(P(ast::Block {\n+        stmts: vec![cx.stmt_expr(call)],\n+        id: ast::DUMMY_NODE_ID,\n+        rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n+        span,\n+    }))\n+}\n+\n+// Injects `impl<...> Structural for ItemType<...> { }`. In particular,\n+// does *not* add `where T: Structural` for parameters `T` in `...`.\n+// (That's the main reason we cannot use TraitDef here.)\n+fn inject_impl_of_structural_trait(\n+    cx: &mut ExtCtxt<'_>,\n+    span: Span,\n+    item: &Annotatable,\n+    structural_path: generic::ty::Path,\n+    push: &mut dyn FnMut(Annotatable),\n+) {\n+    let item = match *item {\n+        Annotatable::Item(ref item) => item,\n+        _ => {\n+            // Non-Item derive is an error, but it should have been\n+            // set earlier; see\n+            // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n+            // librustc_expand/base.rs:Annotatable::derive_allowed()\n+            return;\n+        }\n+    };\n+\n+    let generics = match item.kind {\n+        ItemKind::Struct(_, ref generics) | ItemKind::Enum(_, ref generics) => generics,\n+        // Do not inject `impl Structural for Union`. (`PartialEq` does not\n+        // support unions, so we will see error downstream.)\n+        ItemKind::Union(..) => return,\n+        _ => unreachable!(),\n+    };\n+\n+    // Create generics param list for where clauses and impl headers\n+    let mut generics = generics.clone();\n+\n+    // Create the type of `self`.\n+    //\n+    // in addition, remove defaults from type params (impls cannot have them).\n+    let self_params: Vec<_> = generics\n+        .params\n+        .iter_mut()\n+        .map(|param| match &mut param.kind {\n+            ast::GenericParamKind::Lifetime => {\n+                ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n+            }\n+            ast::GenericParamKind::Type { default } => {\n+                *default = None;\n+                ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+            }\n+            ast::GenericParamKind::Const { ty: _, kw_span: _ } => {\n+                ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+            }\n+        })\n+        .collect();\n+\n+    let type_ident = item.ident;\n+\n+    let trait_ref = cx.trait_ref(structural_path.to_path(cx, span, type_ident, &generics));\n+    let self_type = cx.ty_path(cx.path_all(span, false, vec![type_ident], self_params));\n+\n+    // It would be nice to also encode constraint `where Self: Eq` (by adding it\n+    // onto `generics` cloned above). Unfortunately, that strategy runs afoul of\n+    // rust-lang/rust#48214. So we perform that additional check in the compiler\n+    // itself, instead of encoding it here.\n+\n+    // Keep the lint and stability attributes of the original item, to control\n+    // how the generated implementation is linted.\n+    let mut attrs = Vec::new();\n+    attrs.extend(\n+        item.attrs\n+            .iter()\n+            .filter(|a| {\n+                [sym::allow, sym::warn, sym::deny, sym::forbid, sym::stable, sym::unstable]\n+                    .contains(&a.name_or_empty())\n+            })\n+            .cloned(),\n+    );\n+\n+    let newitem = cx.item(\n+        span,\n+        Ident::invalid(),\n+        attrs,\n+        ItemKind::Impl {\n+            unsafety: ast::Unsafe::No,\n+            polarity: ast::ImplPolarity::Positive,\n+            defaultness: ast::Defaultness::Final,\n+            constness: ast::Const::No,\n+            generics,\n+            of_trait: Some(trait_ref),\n+            self_ty: self_type,\n+            items: Vec::new(),\n+        },\n+    );\n+\n+    push(Annotatable::Item(newitem));\n+}"}, {"sha": "6de12acfb94294d834c5fcf5be8ccb7f4175f065", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -3,8 +3,8 @@\n // interface.\n //\n \n-use rustc_ast::ast::{self, GenericArg};\n use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::{self as ast, GenericArg};\n use rustc_expand::base::{self, *};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -23,7 +23,7 @@ pub fn expand_option_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n     let e = match value {\n         None => {\n             let lt = cx.lifetime(sp, Ident::new(kw::StaticLifetime, sp));\n@@ -81,7 +81,7 @@ pub fn expand_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&*var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n             cx.span_err(sp, &msg.as_str());", "previous_filename": "src/librustc_builtin_macros/env.rs"}, {"sha": "48506148ed9a7b2d02ad4ca1ddab4cf36d7f4d7e", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "renamed", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,7 +1,7 @@\n use ArgumentType::*;\n use Position::*;\n \n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n@@ -135,7 +135,26 @@ fn parse_args<'a>(\n         return Err(ecx.struct_span_err(sp, \"requires at least a format string argument\"));\n     }\n \n-    let fmtstr = p.parse_expr()?;\n+    let first_token = &p.token;\n+    let fmtstr = match first_token.kind {\n+        token::TokenKind::Literal(token::Lit {\n+            kind: token::LitKind::Str | token::LitKind::StrRaw(_),\n+            ..\n+        }) => {\n+            // If the first token is a string literal, then a format expression\n+            // is constructed from it.\n+            //\n+            // This allows us to properly handle cases when the first comma\n+            // after the format string is mistakenly replaced with any operator,\n+            // which cause the expression parser to eat too much tokens.\n+            p.parse_literal_maybe_minus()?\n+        }\n+        _ => {\n+            // Otherwise, we fall back to the expression parser.\n+            p.parse_expr()?\n+        }\n+    };\n+\n     let mut first = true;\n     let mut named = false;\n \n@@ -149,7 +168,7 @@ fn parse_args<'a>(\n                 return Err(err);\n             } else {\n                 // ...after that delegate to `expect` to also include the other expected tokens.\n-                return Err(p.expect(&token::Comma).err().unwrap());\n+                let _ = p.expect(&token::Comma)?;\n             }\n         }\n         first = false;\n@@ -359,24 +378,18 @@ impl<'a, 'b> Context<'a, 'b> {\n             // for `println!(\"{7:7$}\", 1);`\n             refs.sort();\n             refs.dedup();\n-            let (arg_list, mut sp) = if refs.len() == 1 {\n-                let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n-                (\n-                    format!(\"argument {}\", refs[0]),\n-                    if spans.is_empty() {\n-                        MultiSpan::from_span(self.fmtsp)\n-                    } else {\n-                        MultiSpan::from_spans(spans)\n-                    },\n-                )\n+            let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n+            let sp = if self.arg_spans.is_empty() || spans.is_empty() {\n+                MultiSpan::from_span(self.fmtsp)\n+            } else {\n+                MultiSpan::from_spans(spans)\n+            };\n+            let arg_list = if refs.len() == 1 {\n+                format!(\"argument {}\", refs[0])\n             } else {\n-                let pos = MultiSpan::from_spans(spans.into_iter().map(|s| *s.unwrap()).collect());\n                 let reg = refs.pop().unwrap();\n-                (format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg,), pos)\n+                format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg)\n             };\n-            if self.arg_spans.is_empty() {\n-                sp = MultiSpan::from_span(self.fmtsp);\n-            }\n \n             e = self.ecx.struct_span_err(\n                 sp,\n@@ -1067,10 +1080,9 @@ pub fn expand_preparsed_format_args(\n         let args_unused = errs_len;\n \n         let mut diag = {\n-            if errs_len == 1 {\n-                let (sp, msg) = errs.into_iter().next().unwrap();\n-                let mut diag = cx.ecx.struct_span_err(sp, msg);\n-                diag.span_label(sp, msg);\n+            if let [(sp, msg)] = &errs[..] {\n+                let mut diag = cx.ecx.struct_span_err(*sp, *msg);\n+                diag.span_label(*sp, *msg);\n                 diag\n             } else {\n                 let mut diag = cx.ecx.struct_span_err(", "previous_filename": "src/librustc_builtin_macros/format.rs"}, {"sha": "85cf4c42e9435e60ffffb059373ff8ea36de4858", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/format_foreign.rs"}, {"sha": "33c54c9cee001dde83c2ba4b001ab1b4ed105f5b", "filename": "compiler/rustc_builtin_macros/src/format_foreign/printf/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/format_foreign/printf/tests.rs"}, {"sha": "ed8fe81dfcdd8fd98b1085ed0a5480c9270067c0", "filename": "compiler/rustc_builtin_macros/src/format_foreign/shell/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign%2Fshell%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/format_foreign/shell/tests.rs"}, {"sha": "8478fcfbf09a6725f68f647a6c79dd226aebbc6d", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,11 +1,11 @@\n use crate::util::check_builtin_macro_attribute;\n \n-use rustc_ast::ast::{self, Attribute, Expr, FnHeader, FnSig, Generics, Param};\n-use rustc_ast::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_ast::expand::allocator::{\n     AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n };\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, Attribute, Expr, FnHeader, FnSig, Generics, Param};\n+use rustc_ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafe};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -19,7 +19,7 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let not_static = |item: Annotatable| {\n-        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n         vec![item]\n     };\n     let item = match item {\n@@ -67,7 +67,7 @@ impl AllocFnFactory<'_, '_> {\n         let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n         let decl = self.cx.fn_decl(abi_args, ast::FnRetTy::Ty(output_ty));\n         let header = FnHeader { unsafety: Unsafe::Yes(self.span), ..FnHeader::default() };\n-        let sig = FnSig { decl, header };\n+        let sig = FnSig { decl, header, span: self.span };\n         let block = Some(self.cx.block_expr(output_expr));\n         let kind = ItemKind::Fn(ast::Defaultness::Final, sig, Generics::default(), block);\n         let item = self.cx.item(", "previous_filename": "src/librustc_builtin_macros/global_allocator.rs"}, {"sha": "2465f33622e847c903e92da0d9c9ed2e28887444", "filename": "compiler/rustc_builtin_macros/src/global_asm.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_asm.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -8,7 +8,7 @@\n //! LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n //! therefore apply.\n \n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;", "previous_filename": "src/librustc_builtin_macros/global_asm.rs"}, {"sha": "87be6d1743a2a4a736f7888d77929eae7ffa1c18", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,113 @@\n+//! This crate contains implementations of built-in macros and other code generating facilities\n+//! injecting code into the crate before it is lowered to HIR.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(crate_visibility_modifier)]\n+#![feature(decl_macro)]\n+#![feature(nll)]\n+#![feature(or_patterns)]\n+#![feature(proc_macro_internals)]\n+#![feature(proc_macro_quote)]\n+\n+extern crate proc_macro;\n+\n+use crate::deriving::*;\n+\n+use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtension, SyntaxExtensionKind};\n+use rustc_expand::proc_macro::BangProcMacro;\n+use rustc_span::edition::Edition;\n+use rustc_span::symbol::{sym, Ident};\n+\n+mod asm;\n+mod assert;\n+mod cfg;\n+mod cfg_accessible;\n+mod compile_error;\n+mod concat;\n+mod concat_idents;\n+mod deriving;\n+mod env;\n+mod format;\n+mod format_foreign;\n+mod global_allocator;\n+mod global_asm;\n+mod llvm_asm;\n+mod log_syntax;\n+mod source_util;\n+mod test;\n+mod trace_macros;\n+mod util;\n+\n+pub mod cmdline_attrs;\n+pub mod proc_macro_harness;\n+pub mod standard_library_imports;\n+pub mod test_harness;\n+\n+pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand, edition: Edition) {\n+    let mut register = |name, kind| {\n+        resolver.register_builtin_macro(\n+            Ident::with_dummy_span(name),\n+            SyntaxExtension { is_builtin: true, ..SyntaxExtension::default(kind, edition) },\n+        )\n+    };\n+    macro register_bang($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)));)*\n+    }\n+    macro register_attr($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyAttr(Box::new($f)));)*\n+    }\n+    macro register_derive($($name:ident: $f:expr,)*) {\n+        $(register(sym::$name, SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($f))));)*\n+    }\n+\n+    register_bang! {\n+        asm: asm::expand_asm,\n+        assert: assert::expand_assert,\n+        cfg: cfg::expand_cfg,\n+        column: source_util::expand_column,\n+        compile_error: compile_error::expand_compile_error,\n+        concat_idents: concat_idents::expand_concat_idents,\n+        concat: concat::expand_concat,\n+        env: env::expand_env,\n+        file: source_util::expand_file,\n+        format_args_nl: format::expand_format_args_nl,\n+        format_args: format::expand_format_args,\n+        global_asm: global_asm::expand_global_asm,\n+        include_bytes: source_util::expand_include_bytes,\n+        include_str: source_util::expand_include_str,\n+        include: source_util::expand_include,\n+        line: source_util::expand_line,\n+        llvm_asm: llvm_asm::expand_llvm_asm,\n+        log_syntax: log_syntax::expand_log_syntax,\n+        module_path: source_util::expand_mod,\n+        option_env: env::expand_option_env,\n+        stringify: source_util::expand_stringify,\n+        trace_macros: trace_macros::expand_trace_macros,\n+    }\n+\n+    register_attr! {\n+        bench: test::expand_bench,\n+        cfg_accessible: cfg_accessible::Expander,\n+        global_allocator: global_allocator::expand,\n+        test: test::expand_test,\n+        test_case: test::expand_test_case,\n+    }\n+\n+    register_derive! {\n+        Clone: clone::expand_deriving_clone,\n+        Copy: bounds::expand_deriving_copy,\n+        Debug: debug::expand_deriving_debug,\n+        Default: default::expand_deriving_default,\n+        Eq: eq::expand_deriving_eq,\n+        Hash: hash::expand_deriving_hash,\n+        Ord: ord::expand_deriving_ord,\n+        PartialEq: partial_eq::expand_deriving_partial_eq,\n+        PartialOrd: partial_ord::expand_deriving_partial_ord,\n+        RustcDecodable: decodable::expand_deriving_rustc_decodable,\n+        RustcEncodable: encodable::expand_deriving_rustc_encodable,\n+    }\n+\n+    let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n+    register(sym::quote, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })));\n+}"}, {"sha": "db73fdbe24ff580b5b199711fc11c3663e56f9dc", "filename": "compiler/rustc_builtin_macros/src/llvm_asm.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fllvm_asm.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -2,10 +2,11 @@\n //\n use State::*;\n \n-use rustc_ast::ast::{self, LlvmAsmDialect};\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{self, TokenStream};\n+use rustc_ast::LlvmAsmDialect;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, PResult};\n use rustc_expand::base::*;\n use rustc_parse::parser::Parser;\n@@ -110,7 +111,7 @@ fn parse_inline_asm<'a>(\n                     // If we already have a string with instructions,\n                     // ending up in Asm state again is an error.\n                     return Err(struct_span_err!(\n-                        cx.parse_sess.span_diagnostic,\n+                        cx.sess.parse_sess.span_diagnostic,\n                         sp,\n                         E0660,\n                         \"malformed inline assembly\"\n@@ -171,7 +172,7 @@ fn parse_inline_asm<'a>(\n                         Some('+') => Some(Symbol::intern(&format!(\"={}\", ch.as_str()))),\n                         _ => {\n                             struct_span_err!(\n-                                cx.parse_sess.span_diagnostic,\n+                                cx.sess.parse_sess.span_diagnostic,\n                                 span,\n                                 E0661,\n                                 \"output operand constraint lacks '=' or '+'\"\n@@ -201,15 +202,15 @@ fn parse_inline_asm<'a>(\n \n                     if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n                     } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0663,\n                             \"input operand constraint contains '+'\"\n@@ -236,7 +237,7 @@ fn parse_inline_asm<'a>(\n                         cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0664,\n                             \"clobber should not be surrounded by braces\"", "previous_filename": "src/librustc_builtin_macros/llvm_asm.rs"}, {"sha": "ede34a7612589c531e051481460d82db3d740184", "filename": "compiler/rustc_builtin_macros/src/log_syntax.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flog_syntax.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/log_syntax.rs"}, {"sha": "0c6769906f3399d33bf76613c050eae1cd16e3f8", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "renamed", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,14 +1,13 @@\n use std::mem;\n \n-use rustc_ast::ast::{self, NodeId};\n use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{self as ast, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::AstPass;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -42,6 +41,7 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n+    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -51,7 +51,7 @@ struct CollectProcMacros<'a> {\n }\n \n pub fn inject(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     mut krate: ast::Crate,\n     is_proc_macro_crate: bool,\n@@ -64,6 +64,7 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n+        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -143,7 +144,7 @@ impl<'a> CollectProcMacros<'a> {\n \n         let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n-            if !attr.check_name(sym::attributes) {\n+            if !attr.has_name(sym::attributes) {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n             }\n             attr.meta_item_list()\n@@ -244,7 +245,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -263,7 +264,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if is_proc_macro_attr(&attr) {\n+            if self.sess.is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();\n@@ -331,11 +332,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if attr.check_name(sym::proc_macro_derive) {\n+        if self.sess.check_name(attr, sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if attr.check_name(sym::proc_macro_attribute) {\n+        } else if self.sess.check_name(attr, sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if attr.check_name(sym::proc_macro) {\n+        } else if self.sess.check_name(attr, sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n ", "previous_filename": "src/librustc_builtin_macros/proc_macro_harness.rs"}, {"sha": "70753208af310bc47b2fac09526434d71c7cf29b", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;", "previous_filename": "src/librustc_builtin_macros/source_util.rs"}, {"sha": "e801b5c7b0c62b4881cd1dfff12d21ec52e7d15c", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,8 +1,8 @@\n+use rustc_ast as ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::{ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -11,16 +11,16 @@ use rustc_span::DUMMY_SP;\n pub fn inject(\n     mut krate: ast::Crate,\n     resolver: &mut dyn ResolverExpand,\n-    sess: &ParseSess,\n+    sess: &Session,\n     alt_std_name: Option<Symbol>,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = sess.edition >= Edition::Edition2018;\n+    let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n-    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n-        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n+        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]", "previous_filename": "src/librustc_builtin_macros/standard_library_imports.rs"}, {"sha": "8e56e80bba20451d8da7eb41945fbeefde0a0f1a", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,471 @@\n+/// The expansion from a test function to the appropriate test struct for libtest\n+/// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n+use crate::util::check_builtin_macro_attribute;\n+\n+use rustc_ast as ast;\n+use rustc_ast::attr;\n+use rustc_ast_pretty::pprust;\n+use rustc_expand::base::*;\n+use rustc_session::Session;\n+use rustc_span::source_map::respan;\n+use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::Span;\n+\n+use std::iter;\n+\n+// #[test_case] is used by custom test authors to mark tests\n+// When building for test, it needs to make the item public and gensym the name\n+// Otherwise, we'll omit the item. This behavior means that any item annotated\n+// with #[test_case] is never addressable.\n+//\n+// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+// logic will pick up on.\n+pub fn expand_test_case(\n+    ecx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    meta_item: &ast::MetaItem,\n+    anno_item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n+    if !ecx.ecfg.should_test {\n+        return vec![];\n+    }\n+\n+    let sp = ecx.with_def_site_ctxt(attr_sp);\n+    let mut item = anno_item.expect_item();\n+    item = item.map(|mut item| {\n+        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+        item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n+        item.attrs.push(ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker)));\n+        item\n+    });\n+\n+    return vec![Annotatable::Item(item)];\n+}\n+\n+pub fn expand_test(\n+    cx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::test);\n+    expand_test_or_bench(cx, attr_sp, item, false)\n+}\n+\n+pub fn expand_bench(\n+    cx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::bench);\n+    expand_test_or_bench(cx, attr_sp, item, true)\n+}\n+\n+pub fn expand_test_or_bench(\n+    cx: &mut ExtCtxt<'_>,\n+    attr_sp: Span,\n+    item: Annotatable,\n+    is_bench: bool,\n+) -> Vec<Annotatable> {\n+    // If we're not in test configuration, remove the annotated item\n+    if !cx.ecfg.should_test {\n+        return vec![];\n+    }\n+\n+    let item = match item {\n+        Annotatable::Item(i) => i,\n+        other => {\n+            cx.struct_span_err(\n+                other.span(),\n+                \"`#[test]` attribute is only allowed on non associated functions\",\n+            )\n+            .emit();\n+            return vec![other];\n+        }\n+    };\n+\n+    if let ast::ItemKind::MacCall(_) = item.kind {\n+        cx.sess.parse_sess.span_diagnostic.span_warn(\n+            item.span,\n+            \"`#[test]` attribute should not be used on macros. Use `#[cfg(test)]` instead.\",\n+        );\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    // has_*_signature will report any errors in the type so compilation\n+    // will fail. We shouldn't try to expand in this case because the errors\n+    // would be spurious.\n+    if (!is_bench && !has_test_signature(cx, &item))\n+        || (is_bench && !has_bench_signature(cx, &item))\n+    {\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n+\n+    let test_id = Ident::new(sym::test, attr_sp);\n+\n+    // creates test::$name\n+    let test_path = |name| cx.path(sp, vec![test_id, Ident::from_str_and_span(name, sp)]);\n+\n+    // creates test::ShouldPanic::$name\n+    let should_panic_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"ShouldPanic\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n+\n+    // creates test::TestType::$name\n+    let test_type_path = |name| {\n+        cx.path(\n+            sp,\n+            vec![\n+                test_id,\n+                Ident::from_str_and_span(\"TestType\", sp),\n+                Ident::from_str_and_span(name, sp),\n+            ],\n+        )\n+    };\n+\n+    // creates $name: $expr\n+    let field = |name, expr| cx.field_imm(sp, Ident::from_str_and_span(name, sp), expr);\n+\n+    let test_fn = if is_bench {\n+        // A simple ident for a lambda\n+        let b = Ident::from_str_and_span(\"b\", attr_sp);\n+\n+        cx.expr_call(\n+            sp,\n+            cx.expr_path(test_path(\"StaticBenchFn\")),\n+            vec![\n+                // |b| self::test::assert_test_result(\n+                cx.lambda1(\n+                    sp,\n+                    cx.expr_call(\n+                        sp,\n+                        cx.expr_path(test_path(\"assert_test_result\")),\n+                        vec![\n+                            // super::$test_fn(b)\n+                            cx.expr_call(\n+                                sp,\n+                                cx.expr_path(cx.path(sp, vec![item.ident])),\n+                                vec![cx.expr_ident(sp, b)],\n+                            ),\n+                        ],\n+                    ),\n+                    b,\n+                ), // )\n+            ],\n+        )\n+    } else {\n+        cx.expr_call(\n+            sp,\n+            cx.expr_path(test_path(\"StaticTestFn\")),\n+            vec![\n+                // || {\n+                cx.lambda0(\n+                    sp,\n+                    // test::assert_test_result(\n+                    cx.expr_call(\n+                        sp,\n+                        cx.expr_path(test_path(\"assert_test_result\")),\n+                        vec![\n+                            // $test_fn()\n+                            cx.expr_call(sp, cx.expr_path(cx.path(sp, vec![item.ident])), vec![]), // )\n+                        ],\n+                    ), // }\n+                ), // )\n+            ],\n+        )\n+    };\n+\n+    let mut test_const = cx.item(\n+        sp,\n+        Ident::new(item.ident.name, sp),\n+        vec![\n+            // #[cfg(test)]\n+            cx.attribute(attr::mk_list_item(\n+                Ident::new(sym::cfg, attr_sp),\n+                vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n+            )),\n+            // #[rustc_test_marker]\n+            cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n+        ],\n+        // const $ident: test::TestDescAndFn =\n+        ast::ItemKind::Const(\n+            ast::Defaultness::Final,\n+            cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n+            // test::TestDescAndFn {\n+            Some(\n+                cx.expr_struct(\n+                    sp,\n+                    test_path(\"TestDescAndFn\"),\n+                    vec![\n+                        // desc: test::TestDesc {\n+                        field(\n+                            \"desc\",\n+                            cx.expr_struct(\n+                                sp,\n+                                test_path(\"TestDesc\"),\n+                                vec![\n+                                    // name: \"path::to::test\"\n+                                    field(\n+                                        \"name\",\n+                                        cx.expr_call(\n+                                            sp,\n+                                            cx.expr_path(test_path(\"StaticTestName\")),\n+                                            vec![cx.expr_str(\n+                                                sp,\n+                                                Symbol::intern(&item_path(\n+                                                    // skip the name of the root module\n+                                                    &cx.current_expansion.module.mod_path[1..],\n+                                                    &item.ident,\n+                                                )),\n+                                            )],\n+                                        ),\n+                                    ),\n+                                    // ignore: true | false\n+                                    field(\n+                                        \"ignore\",\n+                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n+                                    ),\n+                                    // allow_fail: true | false\n+                                    field(\n+                                        \"allow_fail\",\n+                                        cx.expr_bool(sp, should_fail(&cx.sess, &item)),\n+                                    ),\n+                                    // should_panic: ...\n+                                    field(\n+                                        \"should_panic\",\n+                                        match should_panic(cx, &item) {\n+                                            // test::ShouldPanic::No\n+                                            ShouldPanic::No => {\n+                                                cx.expr_path(should_panic_path(\"No\"))\n+                                            }\n+                                            // test::ShouldPanic::Yes\n+                                            ShouldPanic::Yes(None) => {\n+                                                cx.expr_path(should_panic_path(\"Yes\"))\n+                                            }\n+                                            // test::ShouldPanic::YesWithMessage(\"...\")\n+                                            ShouldPanic::Yes(Some(sym)) => cx.expr_call(\n+                                                sp,\n+                                                cx.expr_path(should_panic_path(\"YesWithMessage\")),\n+                                                vec![cx.expr_str(sp, sym)],\n+                                            ),\n+                                        },\n+                                    ),\n+                                    // test_type: ...\n+                                    field(\n+                                        \"test_type\",\n+                                        match test_type(cx) {\n+                                            // test::TestType::UnitTest\n+                                            TestType::UnitTest => {\n+                                                cx.expr_path(test_type_path(\"UnitTest\"))\n+                                            }\n+                                            // test::TestType::IntegrationTest\n+                                            TestType::IntegrationTest => {\n+                                                cx.expr_path(test_type_path(\"IntegrationTest\"))\n+                                            }\n+                                            // test::TestPath::Unknown\n+                                            TestType::Unknown => {\n+                                                cx.expr_path(test_type_path(\"Unknown\"))\n+                                            }\n+                                        },\n+                                    ),\n+                                    // },\n+                                ],\n+                            ),\n+                        ),\n+                        // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n+                        field(\"testfn\", test_fn), // }\n+                    ],\n+                ), // }\n+            ),\n+        ),\n+    );\n+    test_const = test_const.map(|mut tc| {\n+        tc.vis.node = ast::VisibilityKind::Public;\n+        tc\n+    });\n+\n+    // extern crate test\n+    let test_extern = cx.item(sp, test_id, vec![], ast::ItemKind::ExternCrate(None));\n+\n+    tracing::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n+\n+    vec![\n+        // Access to libtest under a hygienic name\n+        Annotatable::Item(test_extern),\n+        // The generated test case\n+        Annotatable::Item(test_const),\n+        // The original item\n+        Annotatable::Item(item),\n+    ]\n+}\n+\n+fn item_path(mod_path: &[Ident], item_ident: &Ident) -> String {\n+    mod_path\n+        .iter()\n+        .chain(iter::once(item_ident))\n+        .map(|x| x.to_string())\n+        .collect::<Vec<String>>()\n+        .join(\"::\")\n+}\n+\n+enum ShouldPanic {\n+    No,\n+    Yes(Option<Symbol>),\n+}\n+\n+fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::ignore)\n+}\n+\n+fn should_fail(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::allow_fail)\n+}\n+\n+fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n+    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n+        Some(attr) => {\n+            let sd = &cx.sess.parse_sess.span_diagnostic;\n+\n+            match attr.meta_item_list() {\n+                // Handle #[should_panic(expected = \"foo\")]\n+                Some(list) => {\n+                    let msg = list\n+                        .iter()\n+                        .find(|mi| mi.has_name(sym::expected))\n+                        .and_then(|mi| mi.meta_item())\n+                        .and_then(|mi| mi.value_str());\n+                    if list.len() != 1 || msg.is_none() {\n+                        sd.struct_span_warn(\n+                            attr.span,\n+                            \"argument must be of the form: \\\n+                             `expected = \\\"error message\\\"`\",\n+                        )\n+                        .note(\n+                            \"errors in this attribute were erroneously \\\n+                                allowed and will become a hard error in a \\\n+                                future release.\",\n+                        )\n+                        .emit();\n+                        ShouldPanic::Yes(None)\n+                    } else {\n+                        ShouldPanic::Yes(msg)\n+                    }\n+                }\n+                // Handle #[should_panic] and #[should_panic = \"expected\"]\n+                None => ShouldPanic::Yes(attr.value_str()),\n+            }\n+        }\n+        None => ShouldPanic::No,\n+    }\n+}\n+\n+enum TestType {\n+    UnitTest,\n+    IntegrationTest,\n+    Unknown,\n+}\n+\n+/// Attempts to determine the type of test.\n+/// Since doctests are created without macro expanding, only possible variants here\n+/// are `UnitTest`, `IntegrationTest` or `Unknown`.\n+fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n+    // Root path from context contains the topmost sources directory of the crate.\n+    // I.e., for `project` with sources in `src` and tests in `tests` folders\n+    // (no matter how many nested folders lie inside),\n+    // there will be two different root paths: `/project/src` and `/project/tests`.\n+    let crate_path = cx.root_path.as_path();\n+\n+    if crate_path.ends_with(\"src\") {\n+        // `/src` folder contains unit-tests.\n+        TestType::UnitTest\n+    } else if crate_path.ends_with(\"tests\") {\n+        // `/tests` folder contains integration tests.\n+        TestType::IntegrationTest\n+    } else {\n+        // Crate layout doesn't match expected one, test type is unknown.\n+        TestType::Unknown\n+    }\n+}\n+\n+fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n+    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let sd = &cx.sess.parse_sess.span_diagnostic;\n+    if let ast::ItemKind::Fn(_, ref sig, ref generics, _) = i.kind {\n+        if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n+            sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n+                .span_label(span, \"`unsafe` because of this\")\n+                .emit();\n+            return false;\n+        }\n+        if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n+            sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n+                .span_label(span, \"`async` because of this\")\n+                .emit();\n+            return false;\n+        }\n+\n+        // If the termination trait is active, the compiler will check that the output\n+        // type implements the `Termination` trait as `libtest` enforces that.\n+        let has_output = match sig.decl.output {\n+            ast::FnRetTy::Default(..) => false,\n+            ast::FnRetTy::Ty(ref t) if t.kind.is_unit() => false,\n+            _ => true,\n+        };\n+\n+        if !sig.decl.inputs.is_empty() {\n+            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+            return false;\n+        }\n+\n+        match (has_output, has_should_panic_attr) {\n+            (true, true) => {\n+                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n+                false\n+            }\n+            (true, false) => {\n+                if !generics.params.is_empty() {\n+                    sd.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+                    false\n+                } else {\n+                    true\n+                }\n+            }\n+            (false, _) => true,\n+        }\n+    } else {\n+        sd.span_err(i.span, \"only functions may be used as tests\");\n+        false\n+    }\n+}\n+\n+fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n+    let has_sig = if let ast::ItemKind::Fn(_, ref sig, _, _) = i.kind {\n+        // N.B., inadequate check, but we're running\n+        // well before resolve, can't get too deep.\n+        sig.decl.inputs.len() == 1\n+    } else {\n+        false\n+    };\n+\n+    if !has_sig {\n+        cx.sess.parse_sess.span_diagnostic.span_err(\n+            i.span,\n+            \"functions used as benches must have \\\n+            signature `fn(&mut Bencher) -> impl Termination`\",\n+        );\n+    }\n+\n+    has_sig\n+}"}, {"sha": "0ea60665d67552bb92346ef402b565a0a016eff5", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "renamed", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -1,21 +1,21 @@\n // Code that generates a test runner to run all the tests in a crate\n \n-use log::debug;\n-use rustc_ast::ast;\n+use rustc_ast as ast;\n use rustc_ast::attr;\n-use rustc_ast::entry::{self, EntryPointType};\n+use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::{AstPass, SyntaxContext, Transparency};\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::PanicStrategy;\n use smallvec::{smallvec, SmallVec};\n+use tracing::debug;\n \n use std::{iter, mem};\n \n@@ -35,41 +35,35 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn inject(\n-    sess: &ParseSess,\n-    resolver: &mut dyn ResolverExpand,\n-    should_test: bool,\n-    krate: &mut ast::Crate,\n-    span_diagnostic: &rustc_errors::Handler,\n-    features: &Features,\n-    panic_strategy: PanicStrategy,\n-    platform_panic_strategy: PanicStrategy,\n-    enable_panic_abort_tests: bool,\n-) {\n+pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n+    let span_diagnostic = sess.diagnostic();\n+    let panic_strategy = sess.panic_strategy();\n+    let platform_panic_strategy = sess.target.target.options.panic_strategy;\n+\n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(span_diagnostic, &krate);\n+    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n \n-    if should_test {\n-        let panic_strategy = match (panic_strategy, enable_panic_abort_tests) {\n+    if sess.opts.test {\n+        let panic_strategy = match (panic_strategy, sess.opts.debugging_opts.panic_abort_tests) {\n             (PanicStrategy::Abort, true) => PanicStrategy::Abort,\n-            (PanicStrategy::Abort, false) if panic_strategy == platform_panic_strategy => {\n-                // Silently allow compiling with panic=abort on these platforms,\n-                // but with old behavior (abort if a test fails).\n-                PanicStrategy::Unwind\n-            }\n             (PanicStrategy::Abort, false) => {\n-                span_diagnostic.err(\n-                    \"building tests with panic=abort is not supported \\\n-                                     without `-Zpanic_abort_tests`\",\n-                );\n+                if panic_strategy == platform_panic_strategy {\n+                    // Silently allow compiling with panic=abort on these platforms,\n+                    // but with old behavior (abort if a test fails).\n+                } else {\n+                    span_diagnostic.err(\n+                        \"building tests with panic=abort is not supported \\\n+                                         without `-Zpanic_abort_tests`\",\n+                    );\n+                }\n                 PanicStrategy::Unwind\n             }\n             (PanicStrategy::Unwind, _) => PanicStrategy::Unwind,\n@@ -79,7 +73,7 @@ pub fn inject(\n             resolver,\n             reexport_test_harness_main,\n             krate,\n-            features,\n+            &sess.features_untracked(),\n             panic_strategy,\n             test_runner,\n         )\n@@ -101,7 +95,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if is_test_case(&item) {\n+        if is_test_case(&self.cx.ext_cx.sess, &item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident };\n@@ -143,15 +137,39 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n }\n \n+// Beware, this is duplicated in librustc_passes/entry.rs (with\n+// `rustc_hir::Item`), so make sure to keep them in sync.\n+fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+    match item.kind {\n+        ast::ItemKind::Fn(..) => {\n+            if sess.contains_name(&item.attrs, sym::start) {\n+                EntryPointType::Start\n+            } else if sess.contains_name(&item.attrs, sym::main) {\n+                EntryPointType::MainAttr\n+            } else if item.ident.name == sym::main {\n+                if depth == 1 {\n+                    // This is a top-level function so can be 'main'\n+                    EntryPointType::MainNamed\n+                } else {\n+                    EntryPointType::OtherMain\n+                }\n+            } else {\n+                EntryPointType::None\n+            }\n+        }\n+        _ => EntryPointType::None,\n+    }\n+}\n /// A folder used to remove any entry points (like fn main) because the harness\n /// generator will provide its own\n-struct EntryPointCleaner {\n+struct EntryPointCleaner<'a> {\n     // Current depth in the ast\n+    sess: &'a Session,\n     depth: usize,\n     def_site: Span,\n }\n \n-impl MutVisitor for EntryPointCleaner {\n+impl<'a> MutVisitor for EntryPointCleaner<'a> {\n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         self.depth += 1;\n         let item = noop_flat_map_item(i, self).expect_one(\"noop did something\");\n@@ -160,7 +178,7 @@ impl MutVisitor for EntryPointCleaner {\n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry::entry_point_type(&item, self.depth) {\n+        let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::MainAttr | EntryPointType::Start => item\n                 .map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n@@ -170,7 +188,10 @@ impl MutVisitor for EntryPointCleaner {\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n                     let attrs = attrs\n                         .into_iter()\n-                        .filter(|attr| !attr.check_name(sym::main) && !attr.check_name(sym::start))\n+                        .filter(|attr| {\n+                            !self.sess.check_name(attr, sym::main)\n+                                && !self.sess.check_name(attr, sym::start)\n+                        })\n                         .chain(iter::once(allow_dead_code))\n                         .collect();\n \n@@ -189,7 +210,7 @@ impl MutVisitor for EntryPointCleaner {\n \n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     reexport_test_harness_main: Option<Symbol>,\n     krate: &mut ast::Crate,\n@@ -211,7 +232,7 @@ fn generate_test_harness(\n     let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n \n     // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    let mut cleaner = EntryPointCleaner { sess, depth: 0, def_site };\n     cleaner.visit_crate(krate);\n \n     let cx = TestCtxt {\n@@ -297,7 +318,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     };\n \n     let decl = ecx.fn_decl(vec![], ast::FnRetTy::Ty(main_ret_ty));\n-    let sig = ast::FnSig { decl, header: ast::FnHeader::default() };\n+    let sig = ast::FnSig { decl, header: ast::FnHeader::default(), span: sp };\n     let def = ast::Defaultness::Final;\n     let main = ast::ItemKind::Fn(def, sig, ast::Generics::default(), Some(main_body));\n \n@@ -339,12 +360,16 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn is_test_case(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::rustc_test_marker)\n+fn is_test_case(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n-    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(\n+    sess: &Session,\n+    sd: &rustc_errors::Handler,\n+    krate: &ast::Crate,\n+) -> Option<ast::Path> {\n+    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {", "previous_filename": "src/librustc_builtin_macros/test_harness.rs"}, {"sha": "c17f2afe4949e83a43c5ada7cc5862942d8cf083", "filename": "compiler/rustc_builtin_macros/src/trace_macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_builtin_macros/trace_macros.rs"}, {"sha": "01ea80c4c8a0639220f1bd3c18e5fffc781d5f5c", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,12 @@\n+use rustc_ast::MetaItem;\n+use rustc_expand::base::ExtCtxt;\n+use rustc_feature::AttributeTemplate;\n+use rustc_parse::validate_attr;\n+use rustc_span::Symbol;\n+\n+pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n+    // All the built-in macro attributes are \"words\" at the moment.\n+    let template = AttributeTemplate { word: true, ..Default::default() };\n+    let attr = ecx.attribute(meta_item.clone());\n+    validate_attr::check_builtin_attribute(&ecx.sess.parse_sess, &attr, name, template);\n+}"}, {"sha": "38f552558c83949f9f135147e8f4cedb8faa17a8", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,34 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_codegen_llvm\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+test = false\n+doctest = false\n+\n+[dependencies]\n+bitflags = \"1.0\"\n+libc = \"0.2\"\n+measureme = \"0.7.1\"\n+snap = \"1\"\n+tracing = \"0.1\"\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc-demangle = \"0.1\"\n+rustc_attr = { path = \"../rustc_attr\" }\n+rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_feature = { path = \"../rustc_feature\" }\n+rustc_fs_util = { path = \"../rustc_fs_util\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_incremental = { path = \"../rustc_incremental\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_llvm = { path = \"../../src/librustc_llvm\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_target = { path = \"../rustc_target\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_span = { path = \"../rustc_span\" }"}, {"sha": "afec60d017ee626eba22f99e93047f8d25ac891d", "filename": "compiler/rustc_codegen_llvm/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FREADME.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/README.md"}, {"sha": "7857ccb613bf8abd7fe212b11576986f80e49c7d", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/abi.rs"}, {"sha": "bc1d9e1818c2f63d975787f921d8f2b71789a3b3", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/allocator.rs"}, {"sha": "a468d09c2d93d57e2e1a7ba9434833db66286c68", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "added", "additions": 836, "deletions": 0, "changes": 836, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,836 @@\n+use crate::builder::Builder;\n+use crate::context::CodegenCx;\n+use crate::llvm;\n+use crate::type_::Type;\n+use crate::type_of::LayoutLlvmExt;\n+use crate::value::Value;\n+\n+use rustc_ast::LlvmAsmDialect;\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_codegen_ssa::mir::operand::OperandValue;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir as hir;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_span::{Pos, Span};\n+use rustc_target::abi::*;\n+use rustc_target::asm::*;\n+\n+use libc::{c_char, c_uint};\n+use tracing::debug;\n+\n+impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn codegen_llvm_inline_asm(\n+        &mut self,\n+        ia: &hir::LlvmInlineAsmInner,\n+        outputs: Vec<PlaceRef<'tcx, &'ll Value>>,\n+        mut inputs: Vec<&'ll Value>,\n+        span: Span,\n+    ) -> bool {\n+        let mut ext_constraints = vec![];\n+        let mut output_types = vec![];\n+\n+        // Prepare the output operands\n+        let mut indirect_outputs = vec![];\n+        for (i, (out, &place)) in ia.outputs.iter().zip(&outputs).enumerate() {\n+            if out.is_rw {\n+                let operand = self.load_operand(place);\n+                if let OperandValue::Immediate(_) = operand.val {\n+                    inputs.push(operand.immediate());\n+                }\n+                ext_constraints.push(i.to_string());\n+            }\n+            if out.is_indirect {\n+                let operand = self.load_operand(place);\n+                if let OperandValue::Immediate(_) = operand.val {\n+                    indirect_outputs.push(operand.immediate());\n+                }\n+            } else {\n+                output_types.push(place.layout.llvm_type(self.cx));\n+            }\n+        }\n+        if !indirect_outputs.is_empty() {\n+            indirect_outputs.extend_from_slice(&inputs);\n+            inputs = indirect_outputs;\n+        }\n+\n+        let clobbers = ia.clobbers.iter().map(|s| format!(\"~{{{}}}\", &s));\n+\n+        // Default per-arch clobbers\n+        // Basically what clang does\n+        let arch_clobbers = match &self.sess().target.target.arch[..] {\n+            \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n+            \"mips\" | \"mips64\" => vec![\"~{$1}\"],\n+            _ => Vec::new(),\n+        };\n+\n+        let all_constraints = ia\n+            .outputs\n+            .iter()\n+            .map(|out| out.constraint.to_string())\n+            .chain(ia.inputs.iter().map(|s| s.to_string()))\n+            .chain(ext_constraints)\n+            .chain(clobbers)\n+            .chain(arch_clobbers.iter().map(|s| (*s).to_string()))\n+            .collect::<Vec<String>>()\n+            .join(\",\");\n+\n+        debug!(\"Asm Constraints: {}\", &all_constraints);\n+\n+        // Depending on how many outputs we have, the return type is different\n+        let num_outputs = output_types.len();\n+        let output_type = match num_outputs {\n+            0 => self.type_void(),\n+            1 => output_types[0],\n+            _ => self.type_struct(&output_types, false),\n+        };\n+\n+        let asm = ia.asm.as_str();\n+        let r = inline_asm_call(\n+            self,\n+            &asm,\n+            &all_constraints,\n+            &inputs,\n+            output_type,\n+            ia.volatile,\n+            ia.alignstack,\n+            ia.dialect,\n+            &[span],\n+        );\n+        if r.is_none() {\n+            return false;\n+        }\n+        let r = r.unwrap();\n+\n+        // Again, based on how many outputs we have\n+        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n+        for (i, (_, &place)) in outputs.enumerate() {\n+            let v = if num_outputs == 1 { r } else { self.extract_value(r, i as u64) };\n+            OperandValue::Immediate(v).store(self, place);\n+        }\n+\n+        true\n+    }\n+\n+    fn codegen_inline_asm(\n+        &mut self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[InlineAsmOperandRef<'tcx, Self>],\n+        options: InlineAsmOptions,\n+        line_spans: &[Span],\n+    ) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+\n+        // Collect the types of output operands\n+        let mut constraints = vec![];\n+        let mut output_types = vec![];\n+        let mut op_idx = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let mut layout = None;\n+                    let ty = if let Some(ref place) = place {\n+                        layout = Some(&place.layout);\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else {\n+                        // If the output is discarded, we don't really care what\n+                        // type is used. We're just using this to tell LLVM to\n+                        // reserve the register.\n+                        dummy_output_type(self.cx, reg.reg_class())\n+                    };\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg, layout)));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let layout = if let Some(ref out_place) = out_place {\n+                        &out_place.layout\n+                    } else {\n+                        // LLVM required tied operands to have the same type,\n+                        // so we just use the type of the input.\n+                        &in_value.layout\n+                    };\n+                    let ty = llvm_fixup_output_type(self.cx, reg.reg_class(), layout);\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg, Some(layout))));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Collect input operands\n+        let mut inputs = vec![];\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    let llval =\n+                        llvm_fixup_input(self, value.immediate(), reg.reg_class(), &value.layout);\n+                    inputs.push(llval);\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(reg_to_llvm(reg, Some(&value.layout)));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late: _, in_value, out_place: _ } => {\n+                    let value = llvm_fixup_input(\n+                        self,\n+                        in_value.immediate(),\n+                        reg.reg_class(),\n+                        &in_value.layout,\n+                    );\n+                    inputs.push(value);\n+                    constraints.push(format!(\"{}\", op_idx[&idx]));\n+                }\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    inputs.push(self.cx.get_fn(instance));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    inputs.push(self.cx.get_static(def_id));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Build the template string\n+        let mut template_str = String::new();\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => {\n+                    if s.contains('$') {\n+                        for c in s.chars() {\n+                            if c == '$' {\n+                                template_str.push_str(\"$$\");\n+                            } else {\n+                                template_str.push(c);\n+                            }\n+                        }\n+                    } else {\n+                        template_str.push_str(s)\n+                    }\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    match operands[operand_idx] {\n+                        InlineAsmOperandRef::In { reg, .. }\n+                        | InlineAsmOperandRef::Out { reg, .. }\n+                        | InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_llvm(asm_arch, reg.reg_class(), modifier);\n+                            if let Some(modifier) = modifier {\n+                                template_str.push_str(&format!(\n+                                    \"${{{}:{}}}\",\n+                                    op_idx[&operand_idx], modifier\n+                                ));\n+                            } else {\n+                                template_str.push_str(&format!(\"${{{}}}\", op_idx[&operand_idx]));\n+                            }\n+                        }\n+                        InlineAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the template\n+                            template_str.push_str(string);\n+                        }\n+                        InlineAsmOperandRef::SymFn { .. }\n+                        | InlineAsmOperandRef::SymStatic { .. } => {\n+                            // Only emit the raw symbol name\n+                            template_str.push_str(&format!(\"${{{}:c}}\", op_idx[&operand_idx]));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            match asm_arch {\n+                InlineAsmArch::AArch64 | InlineAsmArch::Arm => {\n+                    constraints.push(\"~{cc}\".to_string());\n+                }\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    constraints.extend_from_slice(&[\n+                        \"~{dirflag}\".to_string(),\n+                        \"~{fpsr}\".to_string(),\n+                        \"~{flags}\".to_string(),\n+                    ]);\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+                InlineAsmArch::Nvptx64 => {}\n+                InlineAsmArch::Hexagon => {}\n+            }\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            // This is actually ignored by LLVM, but it's probably best to keep\n+            // it just in case. LLVM instead uses the ReadOnly/ReadNone\n+            // attributes on the call instruction to optimize.\n+            constraints.push(\"~{memory}\".to_string());\n+        }\n+        let volatile = !options.contains(InlineAsmOptions::PURE);\n+        let alignstack = !options.contains(InlineAsmOptions::NOSTACK);\n+        let output_type = match &output_types[..] {\n+            [] => self.type_void(),\n+            [ty] => ty,\n+            tys => self.type_struct(&tys, false),\n+        };\n+        let dialect = match asm_arch {\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64\n+                if !options.contains(InlineAsmOptions::ATT_SYNTAX) =>\n+            {\n+                LlvmAsmDialect::Intel\n+            }\n+            _ => LlvmAsmDialect::Att,\n+        };\n+        let result = inline_asm_call(\n+            self,\n+            &template_str,\n+            &constraints.join(\",\"),\n+            &inputs,\n+            output_type,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            line_spans,\n+        )\n+        .unwrap_or_else(|| span_bug!(line_spans[0], \"LLVM asm constraint validation failed\"));\n+\n+        if options.contains(InlineAsmOptions::PURE) {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::ReadNone.apply_callsite(llvm::AttributePlace::Function, result);\n+            } else if options.contains(InlineAsmOptions::READONLY) {\n+                llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n+            }\n+        } else {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::InaccessibleMemOnly\n+                    .apply_callsite(llvm::AttributePlace::Function, result);\n+            } else {\n+                // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n+            }\n+        }\n+\n+        // Write results to outputs\n+        for (idx, op) in operands.iter().enumerate() {\n+            if let InlineAsmOperandRef::Out { reg, place: Some(place), .. }\n+            | InlineAsmOperandRef::InOut { reg, out_place: Some(place), .. } = *op\n+            {\n+                let value = if output_types.len() == 1 {\n+                    result\n+                } else {\n+                    self.extract_value(result, op_idx[&idx] as u64)\n+                };\n+                let value = llvm_fixup_output(self, value, reg.reg_class(), &place.layout);\n+                OperandValue::Immediate(value).store(self, place);\n+            }\n+        }\n+    }\n+}\n+\n+impl AsmMethods for CodegenCx<'ll, 'tcx> {\n+    fn codegen_global_asm(&self, ga: &hir::GlobalAsm) {\n+        let asm = ga.asm.as_str();\n+        unsafe {\n+            llvm::LLVMRustAppendModuleInlineAsm(self.llmod, asm.as_ptr().cast(), asm.len());\n+        }\n+    }\n+}\n+\n+fn inline_asm_call(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    asm: &str,\n+    cons: &str,\n+    inputs: &[&'ll Value],\n+    output: &'ll llvm::Type,\n+    volatile: bool,\n+    alignstack: bool,\n+    dia: LlvmAsmDialect,\n+    line_spans: &[Span],\n+) -> Option<&'ll Value> {\n+    let volatile = if volatile { llvm::True } else { llvm::False };\n+    let alignstack = if alignstack { llvm::True } else { llvm::False };\n+\n+    let argtys = inputs\n+        .iter()\n+        .map(|v| {\n+            debug!(\"Asm Input Type: {:?}\", *v);\n+            bx.cx.val_ty(*v)\n+        })\n+        .collect::<Vec<_>>();\n+\n+    debug!(\"Asm Output Type: {:?}\", output);\n+    let fty = bx.cx.type_func(&argtys[..], output);\n+    unsafe {\n+        // Ask LLVM to verify that the constraints are well-formed.\n+        let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons.as_ptr().cast(), cons.len());\n+        debug!(\"constraint verification result: {:?}\", constraints_ok);\n+        if constraints_ok {\n+            let v = llvm::LLVMRustInlineAsm(\n+                fty,\n+                asm.as_ptr().cast(),\n+                asm.len(),\n+                cons.as_ptr().cast(),\n+                cons.len(),\n+                volatile,\n+                alignstack,\n+                llvm::AsmDialect::from_generic(dia),\n+            );\n+            let call = bx.call(v, inputs, None);\n+\n+            // Store mark in a metadata node so we can map LLVM errors\n+            // back to source locations.  See #17552.\n+            let key = \"srcloc\";\n+            let kind = llvm::LLVMGetMDKindIDInContext(\n+                bx.llcx,\n+                key.as_ptr() as *const c_char,\n+                key.len() as c_uint,\n+            );\n+\n+            // srcloc contains one integer for each line of assembly code.\n+            // Unfortunately this isn't enough to encode a full span so instead\n+            // we just encode the start position of each line.\n+            // FIXME: Figure out a way to pass the entire line spans.\n+            let mut srcloc = vec![];\n+            if dia == LlvmAsmDialect::Intel && line_spans.len() > 1 {\n+                // LLVM inserts an extra line to add the \".intel_syntax\", so add\n+                // a dummy srcloc entry for it.\n+                //\n+                // Don't do this if we only have 1 line span since that may be\n+                // due to the asm template string coming from a macro. LLVM will\n+                // default to the first srcloc for lines that don't have an\n+                // associated srcloc.\n+                srcloc.push(bx.const_i32(0));\n+            }\n+            srcloc.extend(line_spans.iter().map(|span| bx.const_i32(span.lo().to_u32() as i32)));\n+            let md = llvm::LLVMMDNodeInContext(bx.llcx, srcloc.as_ptr(), srcloc.len() as u32);\n+            llvm::LLVMSetMetadata(call, kind, md);\n+\n+            Some(call)\n+        } else {\n+            // LLVM has detected an issue with our constraints, bail out\n+            None\n+        }\n+    }\n+}\n+\n+/// If the register is an xmm/ymm/zmm register then return its index.\n+fn xmm_reg_index(reg: InlineAsmReg) -> Option<u32> {\n+    match reg {\n+        InlineAsmReg::X86(reg)\n+            if reg as u32 >= X86InlineAsmReg::xmm0 as u32\n+                && reg as u32 <= X86InlineAsmReg::xmm15 as u32 =>\n+        {\n+            Some(reg as u32 - X86InlineAsmReg::xmm0 as u32)\n+        }\n+        InlineAsmReg::X86(reg)\n+            if reg as u32 >= X86InlineAsmReg::ymm0 as u32\n+                && reg as u32 <= X86InlineAsmReg::ymm15 as u32 =>\n+        {\n+            Some(reg as u32 - X86InlineAsmReg::ymm0 as u32)\n+        }\n+        InlineAsmReg::X86(reg)\n+            if reg as u32 >= X86InlineAsmReg::zmm0 as u32\n+                && reg as u32 <= X86InlineAsmReg::zmm31 as u32 =>\n+        {\n+            Some(reg as u32 - X86InlineAsmReg::zmm0 as u32)\n+        }\n+        _ => None,\n+    }\n+}\n+\n+/// If the register is an AArch64 vector register then return its index.\n+fn a64_vreg_index(reg: InlineAsmReg) -> Option<u32> {\n+    match reg {\n+        InlineAsmReg::AArch64(reg)\n+            if reg as u32 >= AArch64InlineAsmReg::v0 as u32\n+                && reg as u32 <= AArch64InlineAsmReg::v31 as u32 =>\n+        {\n+            Some(reg as u32 - AArch64InlineAsmReg::v0 as u32)\n+        }\n+        _ => None,\n+    }\n+}\n+\n+/// Converts a register class to an LLVM constraint code.\n+fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>) -> String {\n+    match reg {\n+        // For vector registers LLVM wants the register name to match the type size.\n+        InlineAsmRegOrRegClass::Reg(reg) => {\n+            if let Some(idx) = xmm_reg_index(reg) {\n+                let class = if let Some(layout) = layout {\n+                    match layout.size.bytes() {\n+                        64 => 'z',\n+                        32 => 'y',\n+                        _ => 'x',\n+                    }\n+                } else {\n+                    // We use f32 as the type for discarded outputs\n+                    'x'\n+                };\n+                format!(\"{{{}mm{}}}\", class, idx)\n+            } else if let Some(idx) = a64_vreg_index(reg) {\n+                let class = if let Some(layout) = layout {\n+                    match layout.size.bytes() {\n+                        16 => 'q',\n+                        8 => 'd',\n+                        4 => 's',\n+                        2 => 'h',\n+                        1 => 'd', // We fixup i8 to i8x8\n+                        _ => unreachable!(),\n+                    }\n+                } else {\n+                    // We use i64x2 as the type for discarded outputs\n+                    'q'\n+                };\n+                format!(\"{{{}{}}}\", class, idx)\n+            } else if reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n+                // LLVM doesn't recognize x30\n+                \"{lr}\".to_string()\n+            } else {\n+                format!(\"{{{}}}\", reg.name())\n+            }\n+        }\n+        InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => \"l\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => \"t\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n+        }\n+        .to_string(),\n+    }\n+}\n+\n+/// Converts a modifier into LLVM's equivalent modifier.\n+fn modifier_to_llvm(\n+    arch: InlineAsmArch,\n+    reg: InlineAsmRegClass,\n+    modifier: Option<char>,\n+) -> Option<char> {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n+        }\n+        InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::Nvptx(_) => None,\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n+            None if arch == InlineAsmArch::X86_64 => Some('q'),\n+            None => Some('k'),\n+            Some('l') => Some('b'),\n+            Some('h') => Some('h'),\n+            Some('x') => Some('w'),\n+            Some('e') => Some('k'),\n+            Some('r') => Some('q'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => None,\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+    }\n+}\n+\n+/// Type to use for outputs that are discarded. It doesn't really matter what\n+/// the type is, as long as it is valid for the constraint code.\n+fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll Type {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => cx.type_i32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => cx.type_f32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => cx.type_f64(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => cx.type_i32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => cx.type_i8(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+    }\n+}\n+\n+/// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n+/// the equivalent integer type.\n+fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: &Scalar) -> &'ll Type {\n+    match scalar.value {\n+        Primitive::Int(Integer::I8, _) => cx.type_i8(),\n+        Primitive::Int(Integer::I16, _) => cx.type_i16(),\n+        Primitive::Int(Integer::I32, _) => cx.type_i32(),\n+        Primitive::Int(Integer::I64, _) => cx.type_i64(),\n+        Primitive::F32 => cx.type_f32(),\n+        Primitive::F64 => cx.type_f64(),\n+        Primitive::Pointer => cx.type_isize(),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Fix up an input value to work around LLVM bugs.\n+fn llvm_fixup_input(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                let vec_ty = bx.cx.type_vector(bx.cx.type_i8(), 8);\n+                bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n+            let count = 16 / layout.size.bytes();\n+            let vec_ty = bx.cx.type_vector(elem_ty, count);\n+            if let Primitive::Pointer = s.value {\n+                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            }\n+            bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count);\n+            let indices: Vec<_> = (0..count * 2).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            bx.bitcast(value, bx.cx.type_i64())\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => bx.bitcast(value, bx.cx.type_vector(bx.cx.type_f64(), 8)),\n+        (\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_f32())\n+            } else {\n+                value\n+            }\n+        }\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::dreg_low16,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I64, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_f64())\n+            } else {\n+                value\n+            }\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Fix up an output value to work around LLVM bugs.\n+fn llvm_fixup_output(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                bx.extract_element(value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            value = bx.extract_element(value, bx.const_i32(0));\n+            if let Primitive::Pointer = s.value {\n+                value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n+            }\n+            value\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count * 2);\n+            let indices: Vec<_> = (0..*count).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            bx.bitcast(value, bx.cx.type_f64())\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => bx.bitcast(value, layout.llvm_type(bx.cx)),\n+        (\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_i32())\n+            } else {\n+                value\n+            }\n+        }\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::dreg_low16,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I64, _) = s.value {\n+                bx.bitcast(value, bx.cx.type_i64())\n+            } else {\n+                value\n+            }\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Output type to use for llvm_fixup_output.\n+fn llvm_fixup_output_type(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Type {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                cx.type_vector(cx.type_i8(), 8)\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(cx, s);\n+            let count = 16 / layout.size.bytes();\n+            cx.type_vector(elem_ty, count)\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(cx, element);\n+            cx.type_vector(elem_ty, count * 2)\n+        }\n+        (InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd), Abi::Scalar(s))\n+            if s.value == Primitive::F64 =>\n+        {\n+            cx.type_i64()\n+        }\n+        (\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg | X86InlineAsmRegClass::zmm_reg),\n+            Abi::Vector { .. },\n+        ) if layout.size.bytes() == 64 => cx.type_vector(cx.type_f64(), 8),\n+        (\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg | ArmInlineAsmRegClass::sreg_low16),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I32, _) = s.value {\n+                cx.type_f32()\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        (\n+            InlineAsmRegClass::Arm(\n+                ArmInlineAsmRegClass::dreg\n+                | ArmInlineAsmRegClass::dreg_low8\n+                | ArmInlineAsmRegClass::dreg_low16,\n+            ),\n+            Abi::Scalar(s),\n+        ) => {\n+            if let Primitive::Int(Integer::I64, _) = s.value {\n+                cx.type_f64()\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        _ => layout.llvm_type(cx),\n+    }\n+}"}, {"sha": "227a87ff8199495c2b8a9549c2bd44a1b827c777", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/attributes.rs"}, {"sha": "a115a1e95163e64a9e27626aeae08a0f4e8f0173", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/back/archive.rs"}, {"sha": "7c710a1cb3d15017dec692edd7007d71436057da", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -4,7 +4,6 @@ use crate::back::write::{\n use crate::llvm::archive_ro::ArchiveRO;\n use crate::llvm::{self, False, True};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n-use log::{debug, info};\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n use rustc_codegen_ssa::back::write::{CodegenContext, FatLTOInput, ModuleConfig};\n@@ -18,6 +17,7 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::exported_symbols::SymbolExportLevel;\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, CrateType, Lto};\n+use tracing::{debug, info};\n \n use std::ffi::{CStr, CString};\n use std::fs::File;", "previous_filename": "src/librustc_codegen_llvm/back/lto.rs"}, {"sha": "2741f7d848e79043f676ded67df63ee404578dc9", "filename": "compiler/rustc_codegen_llvm/src/back/profiling.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fprofiling.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/back/profiling.rs"}, {"sha": "6f386c1287ca08a4d697425ee8377c8841ffba18", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "added", "additions": 1035, "deletions": 0, "changes": 1035, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1035 @@\n+use crate::attributes;\n+use crate::back::lto::ThinBuffer;\n+use crate::back::profiling::{\n+    selfprofile_after_pass_callback, selfprofile_before_pass_callback, LlvmSelfProfiler,\n+};\n+use crate::base;\n+use crate::common;\n+use crate::consts;\n+use crate::llvm::{self, DiagnosticInfo, PassManager, SMDiagnostic};\n+use crate::llvm_util;\n+use crate::type_::Type;\n+use crate::LlvmCodegenBackend;\n+use crate::ModuleLlvm;\n+use rustc_codegen_ssa::back::write::{BitcodeSection, CodegenContext, EmitObj, ModuleConfig};\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_errors::{FatalError, Handler, Level};\n+use rustc_fs_util::{link_or_copy, path_to_c_string};\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_middle::bug;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::{self, Lto, OutputType, Passes, SanitizerSet, SwitchWithOptPath};\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use rustc_span::InnerSpan;\n+use rustc_target::spec::{CodeModel, RelocModel};\n+use tracing::debug;\n+\n+use libc::{c_char, c_int, c_uint, c_void, size_t};\n+use std::ffi::CString;\n+use std::fs;\n+use std::io::{self, Write};\n+use std::path::{Path, PathBuf};\n+use std::slice;\n+use std::str;\n+use std::sync::Arc;\n+\n+pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n+    match llvm::last_error() {\n+        Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n+        None => handler.fatal(&msg),\n+    }\n+}\n+\n+pub fn write_output_file(\n+    handler: &rustc_errors::Handler,\n+    target: &'ll llvm::TargetMachine,\n+    pm: &llvm::PassManager<'ll>,\n+    m: &'ll llvm::Module,\n+    output: &Path,\n+    file_type: llvm::FileType,\n+) -> Result<(), FatalError> {\n+    unsafe {\n+        let output_c = path_to_c_string(output);\n+        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n+        result.into_result().map_err(|()| {\n+            let msg = format!(\"could not write output to {}\", output.display());\n+            llvm_err(handler, &msg)\n+        })\n+    }\n+}\n+\n+pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm::TargetMachine {\n+    target_machine_factory(sess, config::OptLevel::No)()\n+        .unwrap_or_else(|err| llvm_err(sess.diagnostic(), &err).raise())\n+}\n+\n+pub fn create_target_machine(tcx: TyCtxt<'_>) -> &'static mut llvm::TargetMachine {\n+    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE))()\n+        .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n+}\n+\n+pub fn to_llvm_opt_settings(\n+    cfg: config::OptLevel,\n+) -> (llvm::CodeGenOptLevel, llvm::CodeGenOptSize) {\n+    use self::config::OptLevel::*;\n+    match cfg {\n+        No => (llvm::CodeGenOptLevel::None, llvm::CodeGenOptSizeNone),\n+        Less => (llvm::CodeGenOptLevel::Less, llvm::CodeGenOptSizeNone),\n+        Default => (llvm::CodeGenOptLevel::Default, llvm::CodeGenOptSizeNone),\n+        Aggressive => (llvm::CodeGenOptLevel::Aggressive, llvm::CodeGenOptSizeNone),\n+        Size => (llvm::CodeGenOptLevel::Default, llvm::CodeGenOptSizeDefault),\n+        SizeMin => (llvm::CodeGenOptLevel::Default, llvm::CodeGenOptSizeAggressive),\n+    }\n+}\n+\n+fn to_pass_builder_opt_level(cfg: config::OptLevel) -> llvm::PassBuilderOptLevel {\n+    use config::OptLevel::*;\n+    match cfg {\n+        No => llvm::PassBuilderOptLevel::O0,\n+        Less => llvm::PassBuilderOptLevel::O1,\n+        Default => llvm::PassBuilderOptLevel::O2,\n+        Aggressive => llvm::PassBuilderOptLevel::O3,\n+        Size => llvm::PassBuilderOptLevel::Os,\n+        SizeMin => llvm::PassBuilderOptLevel::Oz,\n+    }\n+}\n+\n+fn to_llvm_relocation_model(relocation_model: RelocModel) -> llvm::RelocModel {\n+    match relocation_model {\n+        RelocModel::Static => llvm::RelocModel::Static,\n+        RelocModel::Pic => llvm::RelocModel::PIC,\n+        RelocModel::DynamicNoPic => llvm::RelocModel::DynamicNoPic,\n+        RelocModel::Ropi => llvm::RelocModel::ROPI,\n+        RelocModel::Rwpi => llvm::RelocModel::RWPI,\n+        RelocModel::RopiRwpi => llvm::RelocModel::ROPI_RWPI,\n+    }\n+}\n+\n+fn to_llvm_code_model(code_model: Option<CodeModel>) -> llvm::CodeModel {\n+    match code_model {\n+        Some(CodeModel::Tiny) => llvm::CodeModel::Tiny,\n+        Some(CodeModel::Small) => llvm::CodeModel::Small,\n+        Some(CodeModel::Kernel) => llvm::CodeModel::Kernel,\n+        Some(CodeModel::Medium) => llvm::CodeModel::Medium,\n+        Some(CodeModel::Large) => llvm::CodeModel::Large,\n+        None => llvm::CodeModel::None,\n+    }\n+}\n+\n+pub fn target_machine_factory(\n+    sess: &Session,\n+    optlvl: config::OptLevel,\n+) -> Arc<dyn Fn() -> Result<&'static mut llvm::TargetMachine, String> + Send + Sync> {\n+    let reloc_model = to_llvm_relocation_model(sess.relocation_model());\n+\n+    let (opt_level, _) = to_llvm_opt_settings(optlvl);\n+    let use_softfp = sess.opts.cg.soft_float;\n+\n+    let ffunction_sections = sess.target.target.options.function_sections;\n+    let fdata_sections = ffunction_sections;\n+\n+    let code_model = to_llvm_code_model(sess.code_model());\n+\n+    let features = attributes::llvm_target_features(sess).collect::<Vec<_>>();\n+    let mut singlethread = sess.target.target.options.singlethread;\n+\n+    // On the wasm target once the `atomics` feature is enabled that means that\n+    // we're no longer single-threaded, or otherwise we don't want LLVM to\n+    // lower atomic operations to single-threaded operations.\n+    if singlethread\n+        && sess.target.target.llvm_target.contains(\"wasm32\")\n+        && sess.target_features.contains(&sym::atomics)\n+    {\n+        singlethread = false;\n+    }\n+\n+    let triple = SmallCStr::new(&sess.target.target.llvm_target);\n+    let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n+    let features = features.join(\",\");\n+    let features = CString::new(features).unwrap();\n+    let abi = SmallCStr::new(&sess.target.target.options.llvm_abiname);\n+    let trap_unreachable = sess.target.target.options.trap_unreachable;\n+    let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n+\n+    let asm_comments = sess.asm_comments();\n+    let relax_elf_relocations = sess.target.target.options.relax_elf_relocations;\n+\n+    let use_init_array = !sess\n+        .opts\n+        .debugging_opts\n+        .use_ctors_section\n+        .unwrap_or(sess.target.target.options.use_ctors_section);\n+\n+    Arc::new(move || {\n+        let tm = unsafe {\n+            llvm::LLVMRustCreateTargetMachine(\n+                triple.as_ptr(),\n+                cpu.as_ptr(),\n+                features.as_ptr(),\n+                abi.as_ptr(),\n+                code_model,\n+                reloc_model,\n+                opt_level,\n+                use_softfp,\n+                ffunction_sections,\n+                fdata_sections,\n+                trap_unreachable,\n+                singlethread,\n+                asm_comments,\n+                emit_stack_size_section,\n+                relax_elf_relocations,\n+                use_init_array,\n+            )\n+        };\n+\n+        tm.ok_or_else(|| {\n+            format!(\"Could not create LLVM TargetMachine for triple: {}\", triple.to_str().unwrap())\n+        })\n+    })\n+}\n+\n+pub(crate) fn save_temp_bitcode(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    name: &str,\n+) {\n+    if !cgcx.save_temps {\n+        return;\n+    }\n+    unsafe {\n+        let ext = format!(\"{}.bc\", name);\n+        let cgu = Some(&module.name[..]);\n+        let path = cgcx.output_filenames.temp_path_ext(&ext, cgu);\n+        let cstr = path_to_c_string(&path);\n+        let llmod = module.module_llvm.llmod();\n+        llvm::LLVMWriteBitcodeToFile(llmod, cstr.as_ptr());\n+    }\n+}\n+\n+pub struct DiagnosticHandlers<'a> {\n+    data: *mut (&'a CodegenContext<LlvmCodegenBackend>, &'a Handler),\n+    llcx: &'a llvm::Context,\n+}\n+\n+impl<'a> DiagnosticHandlers<'a> {\n+    pub fn new(\n+        cgcx: &'a CodegenContext<LlvmCodegenBackend>,\n+        handler: &'a Handler,\n+        llcx: &'a llvm::Context,\n+    ) -> Self {\n+        let data = Box::into_raw(Box::new((cgcx, handler)));\n+        unsafe {\n+            llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, data.cast());\n+            llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, data.cast());\n+        }\n+        DiagnosticHandlers { data, llcx }\n+    }\n+}\n+\n+impl<'a> Drop for DiagnosticHandlers<'a> {\n+    fn drop(&mut self) {\n+        use std::ptr::null_mut;\n+        unsafe {\n+            llvm::LLVMRustSetInlineAsmDiagnosticHandler(self.llcx, inline_asm_handler, null_mut());\n+            llvm::LLVMContextSetDiagnosticHandler(self.llcx, diagnostic_handler, null_mut());\n+            drop(Box::from_raw(self.data));\n+        }\n+    }\n+}\n+\n+fn report_inline_asm(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    msg: String,\n+    level: llvm::DiagnosticLevel,\n+    mut cookie: c_uint,\n+    source: Option<(String, Vec<InnerSpan>)>,\n+) {\n+    // In LTO build we may get srcloc values from other crates which are invalid\n+    // since they use a different source map. To be safe we just suppress these\n+    // in LTO builds.\n+    if matches!(cgcx.lto, Lto::Fat | Lto::Thin) {\n+        cookie = 0;\n+    }\n+    let level = match level {\n+        llvm::DiagnosticLevel::Error => Level::Error,\n+        llvm::DiagnosticLevel::Warning => Level::Warning,\n+        llvm::DiagnosticLevel::Note | llvm::DiagnosticLevel::Remark => Level::Note,\n+    };\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg, level, source);\n+}\n+\n+unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic, user: *const c_void, cookie: c_uint) {\n+    if user.is_null() {\n+        return;\n+    }\n+    let (cgcx, _) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n+\n+    // Recover the post-substitution assembly code from LLVM for better\n+    // diagnostics.\n+    let mut have_source = false;\n+    let mut buffer = String::new();\n+    let mut level = llvm::DiagnosticLevel::Error;\n+    let mut loc = 0;\n+    let mut ranges = [0; 8];\n+    let mut num_ranges = ranges.len() / 2;\n+    let msg = llvm::build_string(|msg| {\n+        buffer = llvm::build_string(|buffer| {\n+            have_source = llvm::LLVMRustUnpackSMDiagnostic(\n+                diag,\n+                msg,\n+                buffer,\n+                &mut level,\n+                &mut loc,\n+                ranges.as_mut_ptr(),\n+                &mut num_ranges,\n+            );\n+        })\n+        .expect(\"non-UTF8 inline asm\");\n+    })\n+    .expect(\"non-UTF8 SMDiagnostic\");\n+\n+    let source = have_source.then(|| {\n+        let mut spans = vec![InnerSpan::new(loc as usize, loc as usize)];\n+        for i in 0..num_ranges {\n+            spans.push(InnerSpan::new(ranges[i * 2] as usize, ranges[i * 2 + 1] as usize));\n+        }\n+        (buffer, spans)\n+    });\n+\n+    report_inline_asm(cgcx, msg, level, cookie, source);\n+}\n+\n+unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void) {\n+    if user.is_null() {\n+        return;\n+    }\n+    let (cgcx, diag_handler) = *(user as *const (&CodegenContext<LlvmCodegenBackend>, &Handler));\n+\n+    match llvm::diagnostic::Diagnostic::unpack(info) {\n+        llvm::diagnostic::InlineAsm(inline) => {\n+            report_inline_asm(\n+                cgcx,\n+                llvm::twine_to_string(inline.message),\n+                inline.level,\n+                inline.cookie,\n+                None,\n+            );\n+        }\n+\n+        llvm::diagnostic::Optimization(opt) => {\n+            let enabled = match cgcx.remark {\n+                Passes::All => true,\n+                Passes::Some(ref v) => v.iter().any(|s| *s == opt.pass_name),\n+            };\n+\n+            if enabled {\n+                diag_handler.note_without_error(&format!(\n+                    \"optimization {} for {} at {}:{}:{}: {}\",\n+                    opt.kind.describe(),\n+                    opt.pass_name,\n+                    opt.filename,\n+                    opt.line,\n+                    opt.column,\n+                    opt.message\n+                ));\n+            }\n+        }\n+        llvm::diagnostic::PGO(diagnostic_ref) | llvm::diagnostic::Linker(diagnostic_ref) => {\n+            let msg = llvm::build_string(|s| {\n+                llvm::LLVMRustWriteDiagnosticInfoToString(diagnostic_ref, s)\n+            })\n+            .expect(\"non-UTF8 diagnostic\");\n+            diag_handler.warn(&msg);\n+        }\n+        llvm::diagnostic::UnknownDiagnostic(..) => {}\n+    }\n+}\n+\n+fn get_pgo_gen_path(config: &ModuleConfig) -> Option<CString> {\n+    match config.pgo_gen {\n+        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n+            let path = if let Some(dir_path) = opt_dir_path {\n+                dir_path.join(\"default_%m.profraw\")\n+            } else {\n+                PathBuf::from(\"default_%m.profraw\")\n+            };\n+\n+            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n+        }\n+        SwitchWithOptPath::Disabled => None,\n+    }\n+}\n+\n+fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n+    config\n+        .pgo_use\n+        .as_ref()\n+        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n+}\n+\n+pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n+    // We only support the new pass manager starting with LLVM 9.\n+    if llvm_util::get_major_version() < 9 {\n+        return false;\n+    }\n+\n+    // The new pass manager is disabled by default.\n+    config.new_llvm_pass_manager\n+}\n+\n+pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+    opt_level: config::OptLevel,\n+    opt_stage: llvm::OptStage,\n+) {\n+    let unroll_loops =\n+        opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n+    let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n+    let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n+    let sanitizer_options = if !is_lto {\n+        Some(llvm::SanitizerOptions {\n+            sanitize_address: config.sanitizer.contains(SanitizerSet::ADDRESS),\n+            sanitize_address_recover: config.sanitizer_recover.contains(SanitizerSet::ADDRESS),\n+            sanitize_memory: config.sanitizer.contains(SanitizerSet::MEMORY),\n+            sanitize_memory_recover: config.sanitizer_recover.contains(SanitizerSet::MEMORY),\n+            sanitize_memory_track_origins: config.sanitizer_memory_track_origins as c_int,\n+            sanitize_thread: config.sanitizer.contains(SanitizerSet::THREAD),\n+        })\n+    } else {\n+        None\n+    };\n+\n+    let llvm_selfprofiler = if cgcx.prof.llvm_recording_enabled() {\n+        let mut llvm_profiler = LlvmSelfProfiler::new(cgcx.prof.get_self_profiler().unwrap());\n+        &mut llvm_profiler as *mut _ as *mut c_void\n+    } else {\n+        std::ptr::null_mut()\n+    };\n+\n+    // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n+    // We would have to add upstream support for this first, before we can support\n+    // config.inline_threshold and our more aggressive default thresholds.\n+    // FIXME: NewPM uses an different and more explicit way to textually represent\n+    // pass pipelines. It would probably make sense to expose this, but it would\n+    // require a different format than the current -C passes.\n+    llvm::LLVMRustOptimizeWithNewPassManager(\n+        module.module_llvm.llmod(),\n+        &*module.module_llvm.tm,\n+        to_pass_builder_opt_level(opt_level),\n+        opt_stage,\n+        config.no_prepopulate_passes,\n+        config.verify_llvm_ir,\n+        using_thin_buffers,\n+        config.merge_functions,\n+        unroll_loops,\n+        config.vectorize_slp,\n+        config.vectorize_loop,\n+        config.no_builtins,\n+        config.emit_lifetime_markers,\n+        sanitizer_options.as_ref(),\n+        pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        llvm_selfprofiler,\n+        selfprofile_before_pass_callback,\n+        selfprofile_after_pass_callback,\n+    );\n+}\n+\n+// Unsafe due to LLVM calls.\n+pub(crate) unsafe fn optimize(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+) -> Result<(), FatalError> {\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n+\n+    let llmod = module.module_llvm.llmod();\n+    let llcx = &*module.module_llvm.llcx;\n+    let tm = &*module.module_llvm.tm;\n+    let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n+\n+    let module_name = module.name.clone();\n+    let module_name = Some(&module_name[..]);\n+\n+    if config.emit_no_opt_bc {\n+        let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n+        let out = path_to_c_string(&out);\n+        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n+    }\n+\n+    if let Some(opt_level) = config.opt_level {\n+        if should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = match cgcx.lto {\n+                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+                _ => llvm::OptStage::PreLinkNoLTO,\n+            };\n+            optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n+            return Ok(());\n+        }\n+\n+        if cgcx.prof.llvm_recording_enabled() {\n+            diag_handler\n+                .warn(\"`-Z self-profile-events = llvm` requires `-Z new-llvm-pass-manager`\");\n+        }\n+\n+        // Create the two optimizing pass managers. These mirror what clang\n+        // does, and are by populated by LLVM's default PassManagerBuilder.\n+        // Each manager has a different set of passes, but they also share\n+        // some common passes.\n+        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n+        let mpm = llvm::LLVMCreatePassManager();\n+\n+        {\n+            let find_pass = |pass_name: &str| {\n+                let pass_name = SmallCStr::new(pass_name);\n+                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n+            };\n+\n+            if config.verify_llvm_ir {\n+                // Verification should run as the very first pass.\n+                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n+            }\n+\n+            let mut extra_passes = Vec::new();\n+            let mut have_name_anon_globals_pass = false;\n+\n+            for pass_name in &config.passes {\n+                if pass_name == \"lint\" {\n+                    // Linting should also be performed early, directly on the generated IR.\n+                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n+                    continue;\n+                }\n+\n+                if let Some(pass) = find_pass(pass_name) {\n+                    extra_passes.push(pass);\n+                } else {\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n+                }\n+\n+                if pass_name == \"name-anon-globals\" {\n+                    have_name_anon_globals_pass = true;\n+                }\n+            }\n+\n+            add_sanitizer_passes(config, &mut extra_passes);\n+\n+            // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n+            // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n+            // we'll get errors in LLVM.\n+            let using_thin_buffers = config.bitcode_needed();\n+            if !config.no_prepopulate_passes {\n+                llvm::LLVMAddAnalysisPasses(tm, fpm);\n+                llvm::LLVMAddAnalysisPasses(tm, mpm);\n+                let opt_level = to_llvm_opt_settings(opt_level).0;\n+                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n+                    || cgcx.lto == Lto::ThinLocal\n+                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n+                with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n+                    llvm::LLVMRustAddLastExtensionPasses(\n+                        b,\n+                        extra_passes.as_ptr(),\n+                        extra_passes.len() as size_t,\n+                    );\n+                    llvm::LLVMPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n+                    llvm::LLVMPassManagerBuilderPopulateModulePassManager(b, mpm);\n+                });\n+\n+                have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n+                if using_thin_buffers && !prepare_for_thin_lto {\n+                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n+                    have_name_anon_globals_pass = true;\n+                }\n+            } else {\n+                // If we don't use the standard pipeline, directly populate the MPM\n+                // with the extra passes.\n+                for pass in extra_passes {\n+                    llvm::LLVMRustAddPass(mpm, pass);\n+                }\n+            }\n+\n+            if using_thin_buffers && !have_name_anon_globals_pass {\n+                // As described above, this will probably cause an error in LLVM\n+                if config.no_prepopulate_passes {\n+                    diag_handler.err(\n+                        \"The current compilation is going to use thin LTO buffers \\\n+                                      without running LLVM's NameAnonGlobals pass. \\\n+                                      This will likely cause errors in LLVM. Consider adding \\\n+                                      -C passes=name-anon-globals to the compiler command line.\",\n+                    );\n+                } else {\n+                    bug!(\n+                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n+                          This will likely cause errors in LLVM and should never happen.\"\n+                    );\n+                }\n+            }\n+        }\n+\n+        diag_handler.abort_if_errors();\n+\n+        // Finally, run the actual optimization passes\n+        {\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_function_passes\",\n+                &module.name[..],\n+            );\n+            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n+        }\n+        {\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_module_passes\",\n+                &module.name[..],\n+            );\n+            llvm::LLVMRunPassManager(mpm, llmod);\n+        }\n+\n+        // Deallocate managers that we're now done with\n+        llvm::LLVMDisposePassManager(fpm);\n+        llvm::LLVMDisposePassManager(mpm);\n+    }\n+    Ok(())\n+}\n+\n+unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n+    if config.sanitizer.contains(SanitizerSet::ADDRESS) {\n+        let recover = config.sanitizer_recover.contains(SanitizerSet::ADDRESS);\n+        passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n+        passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n+    }\n+    if config.sanitizer.contains(SanitizerSet::MEMORY) {\n+        let track_origins = config.sanitizer_memory_track_origins as c_int;\n+        let recover = config.sanitizer_recover.contains(SanitizerSet::MEMORY);\n+        passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n+    }\n+    if config.sanitizer.contains(SanitizerSet::THREAD) {\n+        passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n+    }\n+}\n+\n+pub(crate) unsafe fn codegen(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    diag_handler: &Handler,\n+    module: ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+) -> Result<CompiledModule, FatalError> {\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n+    {\n+        let llmod = module.module_llvm.llmod();\n+        let llcx = &*module.module_llvm.llcx;\n+        let tm = &*module.module_llvm.tm;\n+        let module_name = module.name.clone();\n+        let module_name = Some(&module_name[..]);\n+        let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n+\n+        if cgcx.msvc_imps_needed {\n+            create_msvc_imps(cgcx, llcx, llmod);\n+        }\n+\n+        // A codegen-specific pass manager is used to generate object\n+        // files for an LLVM module.\n+        //\n+        // Apparently each of these pass managers is a one-shot kind of\n+        // thing, so we create a new one for each type of output. The\n+        // pass manager passed to the closure should be ensured to not\n+        // escape the closure itself, and the manager should only be\n+        // used once.\n+        unsafe fn with_codegen<'ll, F, R>(\n+            tm: &'ll llvm::TargetMachine,\n+            llmod: &'ll llvm::Module,\n+            no_builtins: bool,\n+            f: F,\n+        ) -> R\n+        where\n+            F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n+        {\n+            let cpm = llvm::LLVMCreatePassManager();\n+            llvm::LLVMAddAnalysisPasses(tm, cpm);\n+            llvm::LLVMRustAddLibraryInfo(cpm, llmod, no_builtins);\n+            f(cpm)\n+        }\n+\n+        // Two things to note:\n+        // - If object files are just LLVM bitcode we write bitcode, copy it to\n+        //   the .o file, and delete the bitcode if it wasn't otherwise\n+        //   requested.\n+        // - If we don't have the integrated assembler then we need to emit\n+        //   asm from LLVM and use `gcc` to create the object file.\n+\n+        let bc_out = cgcx.output_filenames.temp_path(OutputType::Bitcode, module_name);\n+        let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n+\n+        if config.bitcode_needed() {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_make_bitcode\", &module.name[..]);\n+            let thin = ThinBuffer::new(llmod);\n+            let data = thin.data();\n+\n+            if config.emit_bc || config.emit_obj == EmitObj::Bitcode {\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_emit_bitcode\",\n+                    &module.name[..],\n+                );\n+                if let Err(e) = fs::write(&bc_out, data) {\n+                    let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n+                    diag_handler.err(&msg);\n+                }\n+            }\n+\n+            if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Full) {\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_embed_bitcode\",\n+                    &module.name[..],\n+                );\n+                embed_bitcode(cgcx, llcx, llmod, &config.bc_cmdline, data);\n+            }\n+        }\n+\n+        if config.emit_ir {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_emit_ir\", &module.name[..]);\n+            let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n+            let out_c = path_to_c_string(&out);\n+\n+            extern \"C\" fn demangle_callback(\n+                input_ptr: *const c_char,\n+                input_len: size_t,\n+                output_ptr: *mut c_char,\n+                output_len: size_t,\n+            ) -> size_t {\n+                let input =\n+                    unsafe { slice::from_raw_parts(input_ptr as *const u8, input_len as usize) };\n+\n+                let input = match str::from_utf8(input) {\n+                    Ok(s) => s,\n+                    Err(_) => return 0,\n+                };\n+\n+                let output = unsafe {\n+                    slice::from_raw_parts_mut(output_ptr as *mut u8, output_len as usize)\n+                };\n+                let mut cursor = io::Cursor::new(output);\n+\n+                let demangled = match rustc_demangle::try_demangle(input) {\n+                    Ok(d) => d,\n+                    Err(_) => return 0,\n+                };\n+\n+                if write!(cursor, \"{:#}\", demangled).is_err() {\n+                    // Possible only if provided buffer is not big enough\n+                    return 0;\n+                }\n+\n+                cursor.position() as size_t\n+            }\n+\n+            let result = llvm::LLVMRustPrintModule(llmod, out_c.as_ptr(), demangle_callback);\n+            result.into_result().map_err(|()| {\n+                let msg = format!(\"failed to write LLVM IR to {}\", out.display());\n+                llvm_err(diag_handler, &msg)\n+            })?;\n+        }\n+\n+        if config.emit_asm {\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n+            let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+\n+            // We can't use the same module for asm and object code output,\n+            // because that triggers various errors like invalid IR or broken\n+            // binaries. So we must clone the module to produce the asm output\n+            // if we are also producing object code.\n+            let llmod = if let EmitObj::ObjectCode(_) = config.emit_obj {\n+                llvm::LLVMCloneModule(llmod)\n+            } else {\n+                llmod\n+            };\n+            with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n+            })?;\n+        }\n+\n+        match config.emit_obj {\n+            EmitObj::ObjectCode(_) => {\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n+                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                    write_output_file(\n+                        diag_handler,\n+                        tm,\n+                        cpm,\n+                        llmod,\n+                        &obj_out,\n+                        llvm::FileType::ObjectFile,\n+                    )\n+                })?;\n+            }\n+\n+            EmitObj::Bitcode => {\n+                debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n+                if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n+                    diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+                }\n+\n+                if !config.emit_bc {\n+                    debug!(\"removing_bitcode {:?}\", bc_out);\n+                    if let Err(e) = fs::remove_file(&bc_out) {\n+                        diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+                    }\n+                }\n+            }\n+\n+            EmitObj::None => {}\n+        }\n+\n+        drop(handlers);\n+    }\n+\n+    Ok(module.into_compiled_module(\n+        config.emit_obj != EmitObj::None,\n+        config.emit_bc,\n+        &cgcx.output_filenames,\n+    ))\n+}\n+\n+/// Embed the bitcode of an LLVM module in the LLVM module itself.\n+///\n+/// This is done primarily for iOS where it appears to be standard to compile C\n+/// code at least with `-fembed-bitcode` which creates two sections in the\n+/// executable:\n+///\n+/// * __LLVM,__bitcode\n+/// * __LLVM,__cmdline\n+///\n+/// It appears *both* of these sections are necessary to get the linker to\n+/// recognize what's going on. A suitable cmdline value is taken from the\n+/// target spec.\n+///\n+/// Furthermore debug/O1 builds don't actually embed bitcode but rather just\n+/// embed an empty section.\n+///\n+/// Basically all of this is us attempting to follow in the footsteps of clang\n+/// on iOS. See #35968 for lots more info.\n+unsafe fn embed_bitcode(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    llcx: &llvm::Context,\n+    llmod: &llvm::Module,\n+    cmdline: &str,\n+    bitcode: &[u8],\n+) {\n+    let llconst = common::bytes_in_context(llcx, bitcode);\n+    let llglobal = llvm::LLVMAddGlobal(\n+        llmod,\n+        common::val_ty(llconst),\n+        \"rustc.embedded.module\\0\".as_ptr().cast(),\n+    );\n+    llvm::LLVMSetInitializer(llglobal, llconst);\n+\n+    let is_apple = cgcx.opts.target_triple.triple().contains(\"-ios\")\n+        || cgcx.opts.target_triple.triple().contains(\"-darwin\")\n+        || cgcx.opts.target_triple.triple().contains(\"-tvos\");\n+\n+    let section = if is_apple { \"__LLVM,__bitcode\\0\" } else { \".llvmbc\\0\" };\n+    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n+    llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n+    llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n+\n+    let llconst = common::bytes_in_context(llcx, cmdline.as_bytes());\n+    let llglobal = llvm::LLVMAddGlobal(\n+        llmod,\n+        common::val_ty(llconst),\n+        \"rustc.embedded.cmdline\\0\".as_ptr().cast(),\n+    );\n+    llvm::LLVMSetInitializer(llglobal, llconst);\n+    let section = if is_apple { \"__LLVM,__cmdline\\0\" } else { \".llvmcmd\\0\" };\n+    llvm::LLVMSetSection(llglobal, section.as_ptr().cast());\n+    llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n+\n+    // We're adding custom sections to the output object file, but we definitely\n+    // do not want these custom sections to make their way into the final linked\n+    // executable. The purpose of these custom sections is for tooling\n+    // surrounding object files to work with the LLVM IR, if necessary. For\n+    // example rustc's own LTO will look for LLVM IR inside of the object file\n+    // in these sections by default.\n+    //\n+    // To handle this is a bit different depending on the object file format\n+    // used by the backend, broken down into a few different categories:\n+    //\n+    // * Mach-O - this is for macOS. Inspecting the source code for the native\n+    //   linker here shows that the `.llvmbc` and `.llvmcmd` sections are\n+    //   automatically skipped by the linker. In that case there's nothing extra\n+    //   that we need to do here.\n+    //\n+    // * Wasm - the native LLD linker is hard-coded to skip `.llvmbc` and\n+    //   `.llvmcmd` sections, so there's nothing extra we need to do.\n+    //\n+    // * COFF - if we don't do anything the linker will by default copy all\n+    //   these sections to the output artifact, not what we want! To subvert\n+    //   this we want to flag the sections we inserted here as\n+    //   `IMAGE_SCN_LNK_REMOVE`. Unfortunately though LLVM has no native way to\n+    //   do this. Thankfully though we can do this with some inline assembly,\n+    //   which is easy enough to add via module-level global inline asm.\n+    //\n+    // * ELF - this is very similar to COFF above. One difference is that these\n+    //   sections are removed from the output linked artifact when\n+    //   `--gc-sections` is passed, which we pass by default. If that flag isn't\n+    //   passed though then these sections will show up in the final output.\n+    //   Additionally the flag that we need to set here is `SHF_EXCLUDE`.\n+    if is_apple\n+        || cgcx.opts.target_triple.triple().starts_with(\"wasm\")\n+        || cgcx.opts.target_triple.triple().starts_with(\"asmjs\")\n+    {\n+        // nothing to do here\n+    } else if cgcx.opts.target_triple.triple().contains(\"windows\")\n+        || cgcx.opts.target_triple.triple().contains(\"uefi\")\n+    {\n+        let asm = \"\n+            .section .llvmbc,\\\"n\\\"\n+            .section .llvmcmd,\\\"n\\\"\n+        \";\n+        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+    } else {\n+        let asm = \"\n+            .section .llvmbc,\\\"e\\\"\n+            .section .llvmcmd,\\\"e\\\"\n+        \";\n+        llvm::LLVMRustAppendModuleInlineAsm(llmod, asm.as_ptr().cast(), asm.len());\n+    }\n+}\n+\n+pub unsafe fn with_llvm_pmb(\n+    llmod: &llvm::Module,\n+    config: &ModuleConfig,\n+    opt_level: llvm::CodeGenOptLevel,\n+    prepare_for_thin_lto: bool,\n+    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n+) {\n+    use std::ptr;\n+\n+    // Create the PassManagerBuilder for LLVM. We configure it with\n+    // reasonable defaults and prepare it to actually populate the pass\n+    // manager.\n+    let builder = llvm::LLVMPassManagerBuilderCreate();\n+    let opt_size =\n+        config.opt_size.map(|x| to_llvm_opt_settings(x).1).unwrap_or(llvm::CodeGenOptSizeNone);\n+    let inline_threshold = config.inline_threshold;\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n+\n+    llvm::LLVMRustConfigurePassManagerBuilder(\n+        builder,\n+        opt_level,\n+        config.merge_functions,\n+        config.vectorize_slp,\n+        config.vectorize_loop,\n+        prepare_for_thin_lto,\n+        pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n+        pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n+    );\n+\n+    llvm::LLVMPassManagerBuilderSetSizeLevel(builder, opt_size as u32);\n+\n+    if opt_size != llvm::CodeGenOptSizeNone {\n+        llvm::LLVMPassManagerBuilderSetDisableUnrollLoops(builder, 1);\n+    }\n+\n+    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n+\n+    // Here we match what clang does (kinda). For O0 we only inline\n+    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n+    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n+    // thresholds copied from clang.\n+    match (opt_level, opt_size, inline_threshold) {\n+        (.., Some(t)) => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, t as u32);\n+        }\n+        (llvm::CodeGenOptLevel::Aggressive, ..) => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n+        }\n+        (_, llvm::CodeGenOptSizeDefault, _) => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n+        }\n+        (_, llvm::CodeGenOptSizeAggressive, _) => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n+        }\n+        (llvm::CodeGenOptLevel::None, ..) => {\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n+        }\n+        (llvm::CodeGenOptLevel::Less, ..) => {\n+            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n+        }\n+        (llvm::CodeGenOptLevel::Default, ..) => {\n+            llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n+        }\n+    }\n+\n+    f(builder);\n+    llvm::LLVMPassManagerBuilderDispose(builder);\n+}\n+\n+// Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n+// This is required to satisfy `dllimport` references to static data in .rlibs\n+// when using MSVC linker.  We do this only for data, as linker can fix up\n+// code references on its own.\n+// See #26591, #27438\n+fn create_msvc_imps(\n+    cgcx: &CodegenContext<LlvmCodegenBackend>,\n+    llcx: &llvm::Context,\n+    llmod: &llvm::Module,\n+) {\n+    if !cgcx.msvc_imps_needed {\n+        return;\n+    }\n+    // The x86 ABI seems to require that leading underscores are added to symbol\n+    // names, so we need an extra underscore on x86. There's also a leading\n+    // '\\x01' here which disables LLVM's symbol mangling (e.g., no extra\n+    // underscores added in front).\n+    let prefix = if cgcx.target_arch == \"x86\" { \"\\x01__imp__\" } else { \"\\x01__imp_\" };\n+\n+    unsafe {\n+        let i8p_ty = Type::i8p_llcx(llcx);\n+        let globals = base::iter_globals(llmod)\n+            .filter(|&val| {\n+                llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage\n+                    && llvm::LLVMIsDeclaration(val) == 0\n+            })\n+            .filter_map(|val| {\n+                // Exclude some symbols that we know are not Rust symbols.\n+                let name = llvm::get_value_name(val);\n+                if ignored(name) { None } else { Some((val, name)) }\n+            })\n+            .map(move |(val, name)| {\n+                let mut imp_name = prefix.as_bytes().to_vec();\n+                imp_name.extend(name);\n+                let imp_name = CString::new(imp_name).unwrap();\n+                (imp_name, val)\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for (imp_name, val) in globals {\n+            let imp = llvm::LLVMAddGlobal(llmod, i8p_ty, imp_name.as_ptr().cast());\n+            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n+            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n+        }\n+    }\n+\n+    // Use this function to exclude certain symbols from `__imp` generation.\n+    fn ignored(symbol_name: &[u8]) -> bool {\n+        // These are symbols generated by LLVM's profiling instrumentation\n+        symbol_name.starts_with(b\"__llvm_profile_\")\n+    }\n+}"}, {"sha": "6a1b373ef071145332252ee5f64fd71737bd6719", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,205 @@\n+//! Codegen the completed AST to the LLVM IR.\n+//!\n+//! Some functions here, such as codegen_block and codegen_expr, return a value --\n+//! the result of the codegen to LLVM -- while others, such as codegen_fn\n+//! and mono_item, are called only for the side effect of adding a\n+//! particular definition to the LLVM IR output we're producing.\n+//!\n+//! Hopefully useful general knowledge about codegen:\n+//!\n+//! * There's no way to find out the `Ty` type of a Value. Doing so\n+//!   would be \"trying to get the eggs out of an omelette\" (credit:\n+//!   pcwalton). You can, instead, find out its `llvm::Type` by calling `val_ty`,\n+//!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n+//!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n+\n+use super::ModuleLlvm;\n+\n+use crate::attributes;\n+use crate::builder::Builder;\n+use crate::common;\n+use crate::context::CodegenCx;\n+use crate::llvm;\n+use crate::metadata;\n+use crate::value::Value;\n+\n+use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n+use rustc_codegen_ssa::mono_item::MonoItemExt;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_middle::dep_graph;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc_middle::middle::cstore::EncodedMetadata;\n+use rustc_middle::middle::exported_symbols;\n+use rustc_middle::mir::mono::{Linkage, Visibility};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::{DebugInfo, SanitizerSet};\n+use rustc_span::symbol::Symbol;\n+\n+use std::ffi::CString;\n+use std::time::Instant;\n+\n+pub fn write_compressed_metadata<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    metadata: &EncodedMetadata,\n+    llvm_module: &mut ModuleLlvm,\n+) {\n+    use snap::write::FrameEncoder;\n+    use std::io::Write;\n+\n+    let (metadata_llcx, metadata_llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n+    let mut compressed = tcx.metadata_encoding_version();\n+    FrameEncoder::new(&mut compressed).write_all(&metadata.raw_data).unwrap();\n+\n+    let llmeta = common::bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = common::struct_in_context(metadata_llcx, &[llmeta], false);\n+    let name = exported_symbols::metadata_symbol_name(tcx);\n+    let buf = CString::new(name).unwrap();\n+    let llglobal =\n+        unsafe { llvm::LLVMAddGlobal(metadata_llmod, common::val_ty(llconst), buf.as_ptr()) };\n+    unsafe {\n+        llvm::LLVMSetInitializer(llglobal, llconst);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n+        let name = SmallCStr::new(section_name);\n+        llvm::LLVMSetSection(llglobal, name.as_ptr());\n+\n+        // Also generate a .section directive to force no\n+        // flags, at least for ELF outputs, so that the\n+        // metadata doesn't get loaded into memory.\n+        let directive = format!(\".section {}\", section_name);\n+        llvm::LLVMSetModuleInlineAsm2(metadata_llmod, directive.as_ptr().cast(), directive.len())\n+    }\n+}\n+\n+pub struct ValueIter<'ll> {\n+    cur: Option<&'ll Value>,\n+    step: unsafe extern \"C\" fn(&'ll Value) -> Option<&'ll Value>,\n+}\n+\n+impl Iterator for ValueIter<'ll> {\n+    type Item = &'ll Value;\n+\n+    fn next(&mut self) -> Option<&'ll Value> {\n+        let old = self.cur;\n+        if let Some(old) = old {\n+            self.cur = unsafe { (self.step)(old) };\n+        }\n+        old\n+    }\n+}\n+\n+pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n+    unsafe { ValueIter { cur: llvm::LLVMGetFirstGlobal(llmod), step: llvm::LLVMGetNextGlobal } }\n+}\n+\n+pub fn compile_codegen_unit(\n+    tcx: TyCtxt<'tcx>,\n+    cgu_name: Symbol,\n+) -> (ModuleCodegen<ModuleLlvm>, u64) {\n+    let prof_timer = tcx.prof.generic_activity_with_arg(\"codegen_module\", cgu_name.to_string());\n+    let start_time = Instant::now();\n+\n+    let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n+    let (module, _) =\n+        tcx.dep_graph.with_task(dep_node, tcx, cgu_name, module_codegen, dep_graph::hash_result);\n+    let time_to_codegen = start_time.elapsed();\n+    drop(prof_timer);\n+\n+    // We assume that the cost to run LLVM on a CGU is proportional to\n+    // the time we needed for codegenning it.\n+    let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n+\n+    fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n+        let cgu = tcx.codegen_unit(cgu_name);\n+        // Instantiate monomorphizations without filling out definitions yet...\n+        let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n+        {\n+            let cx = CodegenCx::new(tcx, cgu, &llvm_module);\n+            let mono_items = cx.codegen_unit.items_in_deterministic_order(cx.tcx);\n+            for &(mono_item, (linkage, visibility)) in &mono_items {\n+                mono_item.predefine::<Builder<'_, '_, '_>>(&cx, linkage, visibility);\n+            }\n+\n+            // ... and now that we have everything pre-defined, fill out those definitions.\n+            for &(mono_item, _) in &mono_items {\n+                mono_item.define::<Builder<'_, '_, '_>>(&cx);\n+            }\n+\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            if let Some(entry) = maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx) {\n+                attributes::sanitize(&cx, SanitizerSet::empty(), entry);\n+            }\n+\n+            // Run replace-all-uses-with for statics that need it\n+            for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, cx.val_ty(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n+            }\n+\n+            // Finalize code coverage by injecting the coverage map. Note, the coverage map will\n+            // also be added to the `llvm.used` variable, created next.\n+            if cx.sess().opts.debugging_opts.instrument_coverage {\n+                cx.coverageinfo_finalize();\n+            }\n+\n+            // Create the llvm.used variable\n+            // This variable has type [N x i8*] and is stored in the llvm.metadata section\n+            if !cx.used_statics().borrow().is_empty() {\n+                cx.create_used_variable()\n+            }\n+\n+            // Finalize debuginfo\n+            if cx.sess().opts.debuginfo != DebugInfo::None {\n+                cx.debuginfo_finalize();\n+            }\n+        }\n+\n+        ModuleCodegen {\n+            name: cgu_name.to_string(),\n+            module_llvm: llvm_module,\n+            kind: ModuleKind::Regular,\n+        }\n+    }\n+\n+    (module, cost)\n+}\n+\n+pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {\n+    let sect = match attrs.link_section {\n+        Some(name) => name,\n+        None => return,\n+    };\n+    unsafe {\n+        let buf = SmallCStr::new(&sect.as_str());\n+        llvm::LLVMSetSection(llval, buf.as_ptr());\n+    }\n+}\n+\n+pub fn linkage_to_llvm(linkage: Linkage) -> llvm::Linkage {\n+    match linkage {\n+        Linkage::External => llvm::Linkage::ExternalLinkage,\n+        Linkage::AvailableExternally => llvm::Linkage::AvailableExternallyLinkage,\n+        Linkage::LinkOnceAny => llvm::Linkage::LinkOnceAnyLinkage,\n+        Linkage::LinkOnceODR => llvm::Linkage::LinkOnceODRLinkage,\n+        Linkage::WeakAny => llvm::Linkage::WeakAnyLinkage,\n+        Linkage::WeakODR => llvm::Linkage::WeakODRLinkage,\n+        Linkage::Appending => llvm::Linkage::AppendingLinkage,\n+        Linkage::Internal => llvm::Linkage::InternalLinkage,\n+        Linkage::Private => llvm::Linkage::PrivateLinkage,\n+        Linkage::ExternalWeak => llvm::Linkage::ExternalWeakLinkage,\n+        Linkage::Common => llvm::Linkage::CommonLinkage,\n+    }\n+}\n+\n+pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n+    match linkage {\n+        Visibility::Default => llvm::Visibility::Default,\n+        Visibility::Hidden => llvm::Visibility::Hidden,\n+        Visibility::Protected => llvm::Visibility::Protected,\n+    }\n+}"}, {"sha": "89c3e21632ead841c7ac4063061e7fdc37e13312", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "added", "additions": 1433, "deletions": 0, "changes": 1433, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,1433 @@\n+use crate::common::Funclet;\n+use crate::context::CodegenCx;\n+use crate::llvm::{self, BasicBlock, False};\n+use crate::llvm::{AtomicOrdering, AtomicRmwBinOp, SynchronizationScope};\n+use crate::type_::Type;\n+use crate::type_of::LayoutLlvmExt;\n+use crate::value::Value;\n+use libc::{c_char, c_uint};\n+use rustc_codegen_ssa::common::{IntPredicate, RealPredicate, TypeKind};\n+use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_codegen_ssa::MemFlags;\n+use rustc_data_structures::const_cstr;\n+use rustc_data_structures::small_c_str::SmallCStr;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::sym;\n+use rustc_target::abi::{self, Align, Size};\n+use rustc_target::spec::{HasTargetSpec, Target};\n+use std::borrow::Cow;\n+use std::ffi::CStr;\n+use std::iter::TrustedLen;\n+use std::ops::{Deref, Range};\n+use std::ptr;\n+use tracing::debug;\n+\n+// All Builders must have an llfn associated with them\n+#[must_use]\n+pub struct Builder<'a, 'll, 'tcx> {\n+    pub llbuilder: &'ll mut llvm::Builder<'ll>,\n+    pub cx: &'a CodegenCx<'ll, 'tcx>,\n+}\n+\n+impl Drop for Builder<'a, 'll, 'tcx> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMDisposeBuilder(&mut *(self.llbuilder as *mut _));\n+        }\n+    }\n+}\n+\n+// FIXME(eddyb) use a checked constructor when they become `const fn`.\n+const EMPTY_C_STR: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"\\0\") };\n+\n+/// Empty string, to be used where LLVM expects an instruction name, indicating\n+/// that the instruction is to be left unnamed (i.e. numbered, in textual IR).\n+// FIXME(eddyb) pass `&CStr` directly to FFI once it's a thin pointer.\n+const UNNAMED: *const c_char = EMPTY_C_STR.as_ptr();\n+\n+impl BackendTypes for Builder<'_, 'll, 'tcx> {\n+    type Value = <CodegenCx<'ll, 'tcx> as BackendTypes>::Value;\n+    type Function = <CodegenCx<'ll, 'tcx> as BackendTypes>::Function;\n+    type BasicBlock = <CodegenCx<'ll, 'tcx> as BackendTypes>::BasicBlock;\n+    type Type = <CodegenCx<'ll, 'tcx> as BackendTypes>::Type;\n+    type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;\n+\n+    type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n+    type DIVariable = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIVariable;\n+}\n+\n+impl abi::HasDataLayout for Builder<'_, '_, '_> {\n+    fn data_layout(&self) -> &abi::TargetDataLayout {\n+        self.cx.data_layout()\n+    }\n+}\n+\n+impl ty::layout::HasTyCtxt<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.cx.tcx\n+    }\n+}\n+\n+impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.cx.param_env()\n+    }\n+}\n+\n+impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.cx.target_spec()\n+    }\n+}\n+\n+impl abi::LayoutOf for Builder<'_, '_, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n+        self.cx.layout_of(ty)\n+    }\n+}\n+\n+impl Deref for Builder<'_, 'll, 'tcx> {\n+    type Target = CodegenCx<'ll, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.cx\n+    }\n+}\n+\n+impl HasCodegen<'tcx> for Builder<'_, 'll, 'tcx> {\n+    type CodegenCx = CodegenCx<'ll, 'tcx>;\n+}\n+\n+macro_rules! builder_methods_for_value_instructions {\n+    ($($name:ident($($arg:ident),*) => $llvm_capi:ident),+ $(,)?) => {\n+        $(fn $name(&mut self, $($arg: &'ll Value),*) -> &'ll Value {\n+            unsafe {\n+                llvm::$llvm_capi(self.llbuilder, $($arg,)* UNNAMED)\n+            }\n+        })+\n+    }\n+}\n+\n+impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n+        let mut bx = Builder::with_cx(cx);\n+        let llbb = unsafe {\n+            let name = SmallCStr::new(name);\n+            llvm::LLVMAppendBasicBlockInContext(cx.llcx, llfn, name.as_ptr())\n+        };\n+        bx.position_at_end(llbb);\n+        bx\n+    }\n+\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+        // Create a fresh builder from the crate context.\n+        let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };\n+        Builder { llbuilder, cx }\n+    }\n+\n+    fn build_sibling_block(&self, name: &str) -> Self {\n+        Builder::new_block(self.cx, self.llfn(), name)\n+    }\n+\n+    fn llbb(&self) -> &'ll BasicBlock {\n+        unsafe { llvm::LLVMGetInsertBlock(self.llbuilder) }\n+    }\n+\n+    fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    fn ret_void(&mut self) {\n+        unsafe {\n+            llvm::LLVMBuildRetVoid(self.llbuilder);\n+        }\n+    }\n+\n+    fn ret(&mut self, v: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMBuildRet(self.llbuilder, v);\n+        }\n+    }\n+\n+    fn br(&mut self, dest: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMBuildBr(self.llbuilder, dest);\n+        }\n+    }\n+\n+    fn cond_br(\n+        &mut self,\n+        cond: &'ll Value,\n+        then_llbb: &'ll BasicBlock,\n+        else_llbb: &'ll BasicBlock,\n+    ) {\n+        unsafe {\n+            llvm::LLVMBuildCondBr(self.llbuilder, cond, then_llbb, else_llbb);\n+        }\n+    }\n+\n+    fn switch(\n+        &mut self,\n+        v: &'ll Value,\n+        else_llbb: &'ll BasicBlock,\n+        cases: impl ExactSizeIterator<Item = (u128, &'ll BasicBlock)> + TrustedLen,\n+    ) {\n+        let switch =\n+            unsafe { llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, cases.len() as c_uint) };\n+        for (on_val, dest) in cases {\n+            let on_val = self.const_uint_big(self.val_ty(v), on_val);\n+            unsafe { llvm::LLVMAddCase(switch, on_val, dest) }\n+        }\n+    }\n+\n+    fn invoke(\n+        &mut self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        then: &'ll BasicBlock,\n+        catch: &'ll BasicBlock,\n+        funclet: Option<&Funclet<'ll>>,\n+    ) -> &'ll Value {\n+        debug!(\"invoke {:?} with args ({:?})\", llfn, args);\n+\n+        let args = self.check_call(\"invoke\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildInvoke(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr(),\n+                args.len() as c_uint,\n+                then,\n+                catch,\n+                bundle,\n+                UNNAMED,\n+            )\n+        }\n+    }\n+\n+    fn unreachable(&mut self) {\n+        unsafe {\n+            llvm::LLVMBuildUnreachable(self.llbuilder);\n+        }\n+    }\n+\n+    builder_methods_for_value_instructions! {\n+        add(a, b) => LLVMBuildAdd,\n+        fadd(a, b) => LLVMBuildFAdd,\n+        sub(a, b) => LLVMBuildSub,\n+        fsub(a, b) => LLVMBuildFSub,\n+        mul(a, b) => LLVMBuildMul,\n+        fmul(a, b) => LLVMBuildFMul,\n+        udiv(a, b) => LLVMBuildUDiv,\n+        exactudiv(a, b) => LLVMBuildExactUDiv,\n+        sdiv(a, b) => LLVMBuildSDiv,\n+        exactsdiv(a, b) => LLVMBuildExactSDiv,\n+        fdiv(a, b) => LLVMBuildFDiv,\n+        urem(a, b) => LLVMBuildURem,\n+        srem(a, b) => LLVMBuildSRem,\n+        frem(a, b) => LLVMBuildFRem,\n+        shl(a, b) => LLVMBuildShl,\n+        lshr(a, b) => LLVMBuildLShr,\n+        ashr(a, b) => LLVMBuildAShr,\n+        and(a, b) => LLVMBuildAnd,\n+        or(a, b) => LLVMBuildOr,\n+        xor(a, b) => LLVMBuildXor,\n+        neg(x) => LLVMBuildNeg,\n+        fneg(x) => LLVMBuildFNeg,\n+        not(x) => LLVMBuildNot,\n+        unchecked_sadd(x, y) => LLVMBuildNSWAdd,\n+        unchecked_uadd(x, y) => LLVMBuildNUWAdd,\n+        unchecked_ssub(x, y) => LLVMBuildNSWSub,\n+        unchecked_usub(x, y) => LLVMBuildNUWSub,\n+        unchecked_smul(x, y) => LLVMBuildNSWMul,\n+        unchecked_umul(x, y) => LLVMBuildNUWMul,\n+    }\n+\n+    fn fadd_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMBuildFAdd(self.llbuilder, lhs, rhs, UNNAMED);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+\n+    fn fsub_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMBuildFSub(self.llbuilder, lhs, rhs, UNNAMED);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+\n+    fn fmul_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMBuildFMul(self.llbuilder, lhs, rhs, UNNAMED);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+\n+    fn fdiv_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMBuildFDiv(self.llbuilder, lhs, rhs, UNNAMED);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+\n+    fn frem_fast(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMBuildFRem(self.llbuilder, lhs, rhs, UNNAMED);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+\n+    fn checked_binop(\n+        &mut self,\n+        oop: OverflowOp,\n+        ty: Ty<'_>,\n+        lhs: Self::Value,\n+        rhs: Self::Value,\n+    ) -> (Self::Value, Self::Value) {\n+        use rustc_ast::IntTy::*;\n+        use rustc_ast::UintTy::*;\n+        use rustc_middle::ty::{Int, Uint};\n+\n+        let new_kind = match ty.kind {\n+            Int(t @ Isize) => Int(t.normalize(self.tcx.sess.target.ptr_width)),\n+            Uint(t @ Usize) => Uint(t.normalize(self.tcx.sess.target.ptr_width)),\n+            ref t @ (Uint(_) | Int(_)) => t.clone(),\n+            _ => panic!(\"tried to get overflow intrinsic for op applied to non-int type\"),\n+        };\n+\n+        let name = match oop {\n+            OverflowOp::Add => match new_kind {\n+                Int(I8) => \"llvm.sadd.with.overflow.i8\",\n+                Int(I16) => \"llvm.sadd.with.overflow.i16\",\n+                Int(I32) => \"llvm.sadd.with.overflow.i32\",\n+                Int(I64) => \"llvm.sadd.with.overflow.i64\",\n+                Int(I128) => \"llvm.sadd.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.uadd.with.overflow.i8\",\n+                Uint(U16) => \"llvm.uadd.with.overflow.i16\",\n+                Uint(U32) => \"llvm.uadd.with.overflow.i32\",\n+                Uint(U64) => \"llvm.uadd.with.overflow.i64\",\n+                Uint(U128) => \"llvm.uadd.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Sub => match new_kind {\n+                Int(I8) => \"llvm.ssub.with.overflow.i8\",\n+                Int(I16) => \"llvm.ssub.with.overflow.i16\",\n+                Int(I32) => \"llvm.ssub.with.overflow.i32\",\n+                Int(I64) => \"llvm.ssub.with.overflow.i64\",\n+                Int(I128) => \"llvm.ssub.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.usub.with.overflow.i8\",\n+                Uint(U16) => \"llvm.usub.with.overflow.i16\",\n+                Uint(U32) => \"llvm.usub.with.overflow.i32\",\n+                Uint(U64) => \"llvm.usub.with.overflow.i64\",\n+                Uint(U128) => \"llvm.usub.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+            OverflowOp::Mul => match new_kind {\n+                Int(I8) => \"llvm.smul.with.overflow.i8\",\n+                Int(I16) => \"llvm.smul.with.overflow.i16\",\n+                Int(I32) => \"llvm.smul.with.overflow.i32\",\n+                Int(I64) => \"llvm.smul.with.overflow.i64\",\n+                Int(I128) => \"llvm.smul.with.overflow.i128\",\n+\n+                Uint(U8) => \"llvm.umul.with.overflow.i8\",\n+                Uint(U16) => \"llvm.umul.with.overflow.i16\",\n+                Uint(U32) => \"llvm.umul.with.overflow.i32\",\n+                Uint(U64) => \"llvm.umul.with.overflow.i64\",\n+                Uint(U128) => \"llvm.umul.with.overflow.i128\",\n+\n+                _ => unreachable!(),\n+            },\n+        };\n+\n+        let intrinsic = self.get_intrinsic(&name);\n+        let res = self.call(intrinsic, &[lhs, rhs], None);\n+        (self.extract_value(res, 0), self.extract_value(res, 1))\n+    }\n+\n+    fn from_immediate(&mut self, val: Self::Value) -> Self::Value {\n+        if self.cx().val_ty(val) == self.cx().type_i1() {\n+            self.zext(val, self.cx().type_i8())\n+        } else {\n+            val\n+        }\n+    }\n+    fn to_immediate_scalar(&mut self, val: Self::Value, scalar: &abi::Scalar) -> Self::Value {\n+        if scalar.is_bool() {\n+            return self.trunc(val, self.cx().type_i1());\n+        }\n+        val\n+    }\n+\n+    fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n+        let mut bx = Builder::with_cx(self.cx);\n+        bx.position_at_start(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn()) });\n+        bx.dynamic_alloca(ty, align)\n+    }\n+\n+    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n+        unsafe {\n+            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n+            llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n+            alloca\n+        }\n+    }\n+\n+    fn array_alloca(&mut self, ty: &'ll Type, len: &'ll Value, align: Align) -> &'ll Value {\n+        unsafe {\n+            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n+            llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n+            alloca\n+        }\n+    }\n+\n+    fn load(&mut self, ptr: &'ll Value, align: Align) -> &'ll Value {\n+        unsafe {\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            llvm::LLVMSetAlignment(load, align.bytes() as c_uint);\n+            load\n+        }\n+    }\n+\n+    fn volatile_load(&mut self, ptr: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let load = llvm::LLVMBuildLoad(self.llbuilder, ptr, UNNAMED);\n+            llvm::LLVMSetVolatile(load, llvm::True);\n+            load\n+        }\n+    }\n+\n+    fn atomic_load(\n+        &mut self,\n+        ptr: &'ll Value,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        size: Size,\n+    ) -> &'ll Value {\n+        unsafe {\n+            let load = llvm::LLVMRustBuildAtomicLoad(\n+                self.llbuilder,\n+                ptr,\n+                UNNAMED,\n+                AtomicOrdering::from_generic(order),\n+            );\n+            // LLVM requires the alignment of atomic loads to be at least the size of the type.\n+            llvm::LLVMSetAlignment(load, size.bytes() as c_uint);\n+            load\n+        }\n+    }\n+\n+    fn load_operand(&mut self, place: PlaceRef<'tcx, &'ll Value>) -> OperandRef<'tcx, &'ll Value> {\n+        debug!(\"PlaceRef::load: {:?}\", place);\n+\n+        assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n+\n+        if place.layout.is_zst() {\n+            return OperandRef::new_zst(self, place.layout);\n+        }\n+\n+        fn scalar_load_metadata<'a, 'll, 'tcx>(\n+            bx: &mut Builder<'a, 'll, 'tcx>,\n+            load: &'ll Value,\n+            scalar: &abi::Scalar,\n+        ) {\n+            let vr = scalar.valid_range.clone();\n+            match scalar.value {\n+                abi::Int(..) => {\n+                    let range = scalar.valid_range_exclusive(bx);\n+                    if range.start != range.end {\n+                        bx.range_metadata(load, range);\n+                    }\n+                }\n+                abi::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n+                    bx.nonnull_metadata(load);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let val = if let Some(llextra) = place.llextra {\n+            OperandValue::Ref(place.llval, Some(llextra), place.align)\n+        } else if place.layout.is_llvm_immediate() {\n+            let mut const_llval = None;\n+            unsafe {\n+                if let Some(global) = llvm::LLVMIsAGlobalVariable(place.llval) {\n+                    if llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                        const_llval = llvm::LLVMGetInitializer(global);\n+                    }\n+                }\n+            }\n+            let llval = const_llval.unwrap_or_else(|| {\n+                let load = self.load(place.llval, place.align);\n+                if let abi::Abi::Scalar(ref scalar) = place.layout.abi {\n+                    scalar_load_metadata(self, load, scalar);\n+                }\n+                load\n+            });\n+            OperandValue::Immediate(self.to_immediate(llval, place.layout))\n+        } else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n+            let b_offset = a.value.size(self).align_to(b.value.align(self).abi);\n+\n+            let mut load = |i, scalar: &abi::Scalar, align| {\n+                let llptr = self.struct_gep(place.llval, i as u64);\n+                let load = self.load(llptr, align);\n+                scalar_load_metadata(self, load, scalar);\n+                self.to_immediate_scalar(load, scalar)\n+            };\n+\n+            OperandValue::Pair(\n+                load(0, a, place.align),\n+                load(1, b, place.align.restrict_for_offset(b_offset)),\n+            )\n+        } else {\n+            OperandValue::Ref(place.llval, None, place.align)\n+        };\n+\n+        OperandRef { val, layout: place.layout }\n+    }\n+\n+    fn write_operand_repeatedly(\n+        mut self,\n+        cg_elem: OperandRef<'tcx, &'ll Value>,\n+        count: u64,\n+        dest: PlaceRef<'tcx, &'ll Value>,\n+    ) -> Self {\n+        let zero = self.const_usize(0);\n+        let count = self.const_usize(count);\n+        let start = dest.project_index(&mut self, zero).llval;\n+        let end = dest.project_index(&mut self, count).llval;\n+\n+        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n+        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n+        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+\n+        self.br(header_bx.llbb());\n+        let current = header_bx.phi(self.val_ty(start), &[start], &[self.llbb()]);\n+\n+        let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n+        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+\n+        let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n+        cg_elem\n+            .val\n+            .store(&mut body_bx, PlaceRef::new_sized_aligned(current, cg_elem.layout, align));\n+\n+        let next = body_bx.inbounds_gep(current, &[self.const_usize(1)]);\n+        body_bx.br(header_bx.llbb());\n+        header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n+\n+        next_bx\n+    }\n+\n+    fn range_metadata(&mut self, load: &'ll Value, range: Range<u128>) {\n+        if self.sess().target.target.arch == \"amdgpu\" {\n+            // amdgpu/LLVM does something weird and thinks a i64 value is\n+            // split into a v2i32, halving the bitwidth LLVM expects,\n+            // tripping an assertion. So, for now, just disable this\n+            // optimization.\n+            return;\n+        }\n+\n+        unsafe {\n+            let llty = self.cx.val_ty(load);\n+            let v = [\n+                self.cx.const_uint_big(llty, range.start),\n+                self.cx.const_uint_big(llty, range.end),\n+            ];\n+\n+            llvm::LLVMSetMetadata(\n+                load,\n+                llvm::MD_range as c_uint,\n+                llvm::LLVMMDNodeInContext(self.cx.llcx, v.as_ptr(), v.len() as c_uint),\n+            );\n+        }\n+    }\n+\n+    fn nonnull_metadata(&mut self, load: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMSetMetadata(\n+                load,\n+                llvm::MD_nonnull as c_uint,\n+                llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0),\n+            );\n+        }\n+    }\n+\n+    fn store(&mut self, val: &'ll Value, ptr: &'ll Value, align: Align) -> &'ll Value {\n+        self.store_with_flags(val, ptr, align, MemFlags::empty())\n+    }\n+\n+    fn store_with_flags(\n+        &mut self,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n+        align: Align,\n+        flags: MemFlags,\n+    ) -> &'ll Value {\n+        debug!(\"Store {:?} -> {:?} ({:?})\", val, ptr, flags);\n+        let ptr = self.check_store(val, ptr);\n+        unsafe {\n+            let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+            let align =\n+                if flags.contains(MemFlags::UNALIGNED) { 1 } else { align.bytes() as c_uint };\n+            llvm::LLVMSetAlignment(store, align);\n+            if flags.contains(MemFlags::VOLATILE) {\n+                llvm::LLVMSetVolatile(store, llvm::True);\n+            }\n+            if flags.contains(MemFlags::NONTEMPORAL) {\n+                // According to LLVM [1] building a nontemporal store must\n+                // *always* point to a metadata value of the integer 1.\n+                //\n+                // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n+                let one = self.cx.const_i32(1);\n+                let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n+                llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n+            }\n+            store\n+        }\n+    }\n+\n+    fn atomic_store(\n+        &mut self,\n+        val: &'ll Value,\n+        ptr: &'ll Value,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        size: Size,\n+    ) {\n+        debug!(\"Store {:?} -> {:?}\", val, ptr);\n+        let ptr = self.check_store(val, ptr);\n+        unsafe {\n+            let store = llvm::LLVMRustBuildAtomicStore(\n+                self.llbuilder,\n+                val,\n+                ptr,\n+                AtomicOrdering::from_generic(order),\n+            );\n+            // LLVM requires the alignment of atomic stores to be at least the size of the type.\n+            llvm::LLVMSetAlignment(store, size.bytes() as c_uint);\n+        }\n+    }\n+\n+    fn gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMBuildGEP(\n+                self.llbuilder,\n+                ptr,\n+                indices.as_ptr(),\n+                indices.len() as c_uint,\n+                UNNAMED,\n+            )\n+        }\n+    }\n+\n+    fn inbounds_gep(&mut self, ptr: &'ll Value, indices: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMBuildInBoundsGEP(\n+                self.llbuilder,\n+                ptr,\n+                indices.as_ptr(),\n+                indices.len() as c_uint,\n+                UNNAMED,\n+            )\n+        }\n+    }\n+\n+    fn struct_gep(&mut self, ptr: &'ll Value, idx: u64) -> &'ll Value {\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe { llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, UNNAMED) }\n+    }\n+\n+    /* Casts */\n+    fn trunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildTrunc(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn sext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildSExt(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn fptoui_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+        // WebAssembly has saturating floating point to integer casts if the\n+        // `nontrapping-fptoint` target feature is activated. We'll use those if\n+        // they are available.\n+        if self.sess().target.target.arch == \"wasm32\"\n+            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+        {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.saturate.unsigned.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return Some(self.call(intrinsic, &[val], None));\n+            }\n+        }\n+        None\n+    }\n+\n+    fn fptosi_sat(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> Option<&'ll Value> {\n+        // WebAssembly has saturating floating point to integer casts if the\n+        // `nontrapping-fptoint` target feature is activated. We'll use those if\n+        // they are available.\n+        if self.sess().target.target.arch == \"wasm32\"\n+            && self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+        {\n+            let src_ty = self.cx.val_ty(val);\n+            let float_width = self.cx.float_width(src_ty);\n+            let int_width = self.cx.int_width(dest_ty);\n+            let name = match (int_width, float_width) {\n+                (32, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f32\"),\n+                (32, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i32.f64\"),\n+                (64, 32) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f32\"),\n+                (64, 64) => Some(\"llvm.wasm.trunc.saturate.signed.i64.f64\"),\n+                _ => None,\n+            };\n+            if let Some(name) = name {\n+                let intrinsic = self.get_intrinsic(name);\n+                return Some(self.call(intrinsic, &[val], None));\n+            }\n+        }\n+        None\n+    }\n+\n+    fn fptosui_may_trap(&self, val: &'ll Value, dest_ty: &'ll Type) -> bool {\n+        // Most of the time we'll be generating the `fptosi` or `fptoui`\n+        // instruction for floating-point-to-integer conversions. These\n+        // instructions by definition in LLVM do not trap. For the WebAssembly\n+        // target, however, we'll lower in some cases to intrinsic calls instead\n+        // which may trap. If we detect that this is a situation where we'll be\n+        // using the intrinsics then we report that the call map trap, which\n+        // callers might need to handle.\n+        if !self.wasm_and_missing_nontrapping_fptoint() {\n+            return false;\n+        }\n+        let src_ty = self.cx.val_ty(val);\n+        let float_width = self.cx.float_width(src_ty);\n+        let int_width = self.cx.int_width(dest_ty);\n+        match (int_width, float_width) {\n+            (32, 32) | (32, 64) | (64, 32) | (64, 64) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn fptoui(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        // When we can, use the native wasm intrinsics which have tighter\n+        // codegen. Note that this has a semantic difference in that the\n+        // intrinsic can trap whereas `fptoui` never traps. That difference,\n+        // however, is handled by `fptosui_may_trap` above.\n+        //\n+        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n+        // must be used instead.\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n+            }\n+        }\n+        unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        if self.wasm_and_missing_nontrapping_fptoint() {\n+            let src_ty = self.cx.val_ty(val);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n+            }\n+        }\n+        unsafe { llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn uitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildUIToFP(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn sitofp(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildSIToFP(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn fptrunc(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildFPTrunc(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn fpext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildFPExt(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn ptrtoint(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildPtrToInt(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn inttoptr(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildIntToPtr(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn bitcast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildBitCast(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn intcast(&mut self, val: &'ll Value, dest_ty: &'ll Type, is_signed: bool) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty, is_signed) }\n+    }\n+\n+    fn pointercast(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildPointerCast(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    /* Comparisons */\n+    fn icmp(&mut self, op: IntPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        let op = llvm::IntPredicate::from_generic(op);\n+        unsafe { llvm::LLVMBuildICmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED) }\n+    }\n+\n+    fn fcmp(&mut self, op: RealPredicate, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildFCmp(self.llbuilder, op as c_uint, lhs, rhs, UNNAMED) }\n+    }\n+\n+    /* Miscellaneous instructions */\n+    fn memcpy(\n+        &mut self,\n+        dst: &'ll Value,\n+        dst_align: Align,\n+        src: &'ll Value,\n+        src_align: Align,\n+        size: &'ll Value,\n+        flags: MemFlags,\n+    ) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.type_i8p());\n+        let src = self.pointercast(src, self.type_i8p());\n+        unsafe {\n+            llvm::LLVMRustBuildMemCpy(\n+                self.llbuilder,\n+                dst,\n+                dst_align.bytes() as c_uint,\n+                src,\n+                src_align.bytes() as c_uint,\n+                size,\n+                is_volatile,\n+            );\n+        }\n+    }\n+\n+    fn memmove(\n+        &mut self,\n+        dst: &'ll Value,\n+        dst_align: Align,\n+        src: &'ll Value,\n+        src_align: Align,\n+        size: &'ll Value,\n+        flags: MemFlags,\n+    ) {\n+        if flags.contains(MemFlags::NONTEMPORAL) {\n+            // HACK(nox): This is inefficient but there is no nontemporal memmove.\n+            let val = self.load(src, src_align);\n+            let ptr = self.pointercast(dst, self.type_ptr_to(self.val_ty(val)));\n+            self.store_with_flags(val, ptr, dst_align, flags);\n+            return;\n+        }\n+        let size = self.intcast(size, self.type_isize(), false);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let dst = self.pointercast(dst, self.type_i8p());\n+        let src = self.pointercast(src, self.type_i8p());\n+        unsafe {\n+            llvm::LLVMRustBuildMemMove(\n+                self.llbuilder,\n+                dst,\n+                dst_align.bytes() as c_uint,\n+                src,\n+                src_align.bytes() as c_uint,\n+                size,\n+                is_volatile,\n+            );\n+        }\n+    }\n+\n+    fn memset(\n+        &mut self,\n+        ptr: &'ll Value,\n+        fill_byte: &'ll Value,\n+        size: &'ll Value,\n+        align: Align,\n+        flags: MemFlags,\n+    ) {\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n+        let ptr = self.pointercast(ptr, self.type_i8p());\n+        unsafe {\n+            llvm::LLVMRustBuildMemSet(\n+                self.llbuilder,\n+                ptr,\n+                align.bytes() as c_uint,\n+                fill_byte,\n+                size,\n+                is_volatile,\n+            );\n+        }\n+    }\n+\n+    fn select(\n+        &mut self,\n+        cond: &'ll Value,\n+        then_val: &'ll Value,\n+        else_val: &'ll Value,\n+    ) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildSelect(self.llbuilder, cond, then_val, else_val, UNNAMED) }\n+    }\n+\n+    #[allow(dead_code)]\n+    fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n+    }\n+\n+    fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, UNNAMED) }\n+    }\n+\n+    fn vector_splat(&mut self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let elt_ty = self.cx.val_ty(elt);\n+            let undef = llvm::LLVMGetUndef(self.type_vector(elt_ty, num_elts as u64));\n+            let vec = self.insert_element(undef, elt, self.cx.const_i32(0));\n+            let vec_i32_ty = self.type_vector(self.type_i32(), num_elts as u64);\n+            self.shuffle_vector(vec, undef, self.const_null(vec_i32_ty))\n+        }\n+    }\n+\n+    fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe { llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, UNNAMED) }\n+    }\n+\n+    fn insert_value(&mut self, agg_val: &'ll Value, elt: &'ll Value, idx: u64) -> &'ll Value {\n+        assert_eq!(idx as c_uint as u64, idx);\n+        unsafe { llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint, UNNAMED) }\n+    }\n+\n+    fn landing_pad(\n+        &mut self,\n+        ty: &'ll Type,\n+        pers_fn: &'ll Value,\n+        num_clauses: usize,\n+    ) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMBuildLandingPad(self.llbuilder, ty, pers_fn, num_clauses as c_uint, UNNAMED)\n+        }\n+    }\n+\n+    fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMSetCleanup(landing_pad, llvm::True);\n+        }\n+    }\n+\n+    fn resume(&mut self, exn: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildResume(self.llbuilder, exn) }\n+    }\n+\n+    fn cleanup_pad(&mut self, parent: Option<&'ll Value>, args: &[&'ll Value]) -> Funclet<'ll> {\n+        let name = const_cstr!(\"cleanuppad\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCleanupPad(\n+                self.llbuilder,\n+                parent,\n+                args.len() as c_uint,\n+                args.as_ptr(),\n+                name.as_ptr(),\n+            )\n+        };\n+        Funclet::new(ret.expect(\"LLVM does not have support for cleanuppad\"))\n+    }\n+\n+    fn cleanup_ret(\n+        &mut self,\n+        funclet: &Funclet<'ll>,\n+        unwind: Option<&'ll BasicBlock>,\n+    ) -> &'ll Value {\n+        let ret =\n+            unsafe { llvm::LLVMRustBuildCleanupRet(self.llbuilder, funclet.cleanuppad(), unwind) };\n+        ret.expect(\"LLVM does not have support for cleanupret\")\n+    }\n+\n+    fn catch_pad(&mut self, parent: &'ll Value, args: &[&'ll Value]) -> Funclet<'ll> {\n+        let name = const_cstr!(\"catchpad\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchPad(\n+                self.llbuilder,\n+                parent,\n+                args.len() as c_uint,\n+                args.as_ptr(),\n+                name.as_ptr(),\n+            )\n+        };\n+        Funclet::new(ret.expect(\"LLVM does not have support for catchpad\"))\n+    }\n+\n+    fn catch_switch(\n+        &mut self,\n+        parent: Option<&'ll Value>,\n+        unwind: Option<&'ll BasicBlock>,\n+        num_handlers: usize,\n+    ) -> &'ll Value {\n+        let name = const_cstr!(\"catchswitch\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchSwitch(\n+                self.llbuilder,\n+                parent,\n+                unwind,\n+                num_handlers as c_uint,\n+                name.as_ptr(),\n+            )\n+        };\n+        ret.expect(\"LLVM does not have support for catchswitch\")\n+    }\n+\n+    fn add_handler(&mut self, catch_switch: &'ll Value, handler: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMRustAddHandler(catch_switch, handler);\n+        }\n+    }\n+\n+    fn set_personality_fn(&mut self, personality: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMSetPersonalityFn(self.llfn(), personality);\n+        }\n+    }\n+\n+    // Atomic Operations\n+    fn atomic_cmpxchg(\n+        &mut self,\n+        dst: &'ll Value,\n+        cmp: &'ll Value,\n+        src: &'ll Value,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        failure_order: rustc_codegen_ssa::common::AtomicOrdering,\n+        weak: bool,\n+    ) -> &'ll Value {\n+        let weak = if weak { llvm::True } else { llvm::False };\n+        unsafe {\n+            llvm::LLVMRustBuildAtomicCmpXchg(\n+                self.llbuilder,\n+                dst,\n+                cmp,\n+                src,\n+                AtomicOrdering::from_generic(order),\n+                AtomicOrdering::from_generic(failure_order),\n+                weak,\n+            )\n+        }\n+    }\n+    fn atomic_rmw(\n+        &mut self,\n+        op: rustc_codegen_ssa::common::AtomicRmwBinOp,\n+        dst: &'ll Value,\n+        src: &'ll Value,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+    ) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMBuildAtomicRMW(\n+                self.llbuilder,\n+                AtomicRmwBinOp::from_generic(op),\n+                dst,\n+                src,\n+                AtomicOrdering::from_generic(order),\n+                False,\n+            )\n+        }\n+    }\n+\n+    fn atomic_fence(\n+        &mut self,\n+        order: rustc_codegen_ssa::common::AtomicOrdering,\n+        scope: rustc_codegen_ssa::common::SynchronizationScope,\n+    ) {\n+        unsafe {\n+            llvm::LLVMRustBuildAtomicFence(\n+                self.llbuilder,\n+                AtomicOrdering::from_generic(order),\n+                SynchronizationScope::from_generic(scope),\n+            );\n+        }\n+    }\n+\n+    fn set_invariant_load(&mut self, load: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMSetMetadata(\n+                load,\n+                llvm::MD_invariant_load as c_uint,\n+                llvm::LLVMMDNodeInContext(self.cx.llcx, ptr::null(), 0),\n+            );\n+        }\n+    }\n+\n+    fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start.p0i8\", ptr, size);\n+    }\n+\n+    fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n+    }\n+\n+    fn instrprof_increment(\n+        &mut self,\n+        fn_name: &'ll Value,\n+        hash: &'ll Value,\n+        num_counters: &'ll Value,\n+        index: &'ll Value,\n+    ) {\n+        debug!(\n+            \"instrprof_increment() with args ({:?}, {:?}, {:?}, {:?})\",\n+            fn_name, hash, num_counters, index\n+        );\n+\n+        let llfn = unsafe { llvm::LLVMRustGetInstrProfIncrementIntrinsic(self.cx().llmod) };\n+        let args = &[fn_name, hash, num_counters, index];\n+        let args = self.check_call(\"call\", llfn, args);\n+\n+        unsafe {\n+            let _ = llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                None,\n+            );\n+        }\n+    }\n+\n+    fn call(\n+        &mut self,\n+        llfn: &'ll Value,\n+        args: &[&'ll Value],\n+        funclet: Option<&Funclet<'ll>>,\n+    ) -> &'ll Value {\n+        debug!(\"call {:?} with args ({:?})\", llfn, args);\n+\n+        let args = self.check_call(\"call\", llfn, args);\n+        let bundle = funclet.map(|funclet| funclet.bundle());\n+        let bundle = bundle.as_ref().map(|b| &*b.raw);\n+\n+        unsafe {\n+            llvm::LLVMRustBuildCall(\n+                self.llbuilder,\n+                llfn,\n+                args.as_ptr() as *const &llvm::Value,\n+                args.len() as c_uint,\n+                bundle,\n+            )\n+        }\n+    }\n+\n+    fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, UNNAMED) }\n+    }\n+\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n+        self.cx\n+    }\n+\n+    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n+        llvm::LLVMDeleteBasicBlock(bb);\n+    }\n+\n+    fn do_not_inline(&mut self, llret: &'ll Value) {\n+        llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n+    }\n+}\n+\n+impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n+    fn get_static(&mut self, def_id: DefId) -> &'ll Value {\n+        // Forward to the `get_static` method of `CodegenCx`\n+        self.cx().get_static(def_id)\n+    }\n+}\n+\n+impl Builder<'a, 'll, 'tcx> {\n+    pub fn llfn(&self) -> &'ll Value {\n+        unsafe { llvm::LLVMGetBasicBlockParent(self.llbb()) }\n+    }\n+\n+    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn insert_element(\n+        &mut self,\n+        vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, UNNAMED) }\n+    }\n+\n+    pub fn shuffle_vector(\n+        &mut self,\n+        v1: &'ll Value,\n+        v2: &'ll Value,\n+        mask: &'ll Value,\n+    ) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, UNNAMED) }\n+    }\n+\n+    pub fn vector_reduce_fadd(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src) }\n+    }\n+    pub fn vector_reduce_fmul(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src) }\n+    }\n+    pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false)\n+        }\n+    }\n+    pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false)\n+        }\n+    }\n+    pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr =\n+                llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        unsafe {\n+            let instr =\n+                llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n+    }\n+    pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n+    }\n+\n+    pub fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMAddClause(landing_pad, clause);\n+        }\n+    }\n+\n+    pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n+        let ret =\n+            unsafe { llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind) };\n+        ret.expect(\"LLVM does not have support for catchret\")\n+    }\n+\n+    fn check_store(&mut self, val: &'ll Value, ptr: &'ll Value) -> &'ll Value {\n+        let dest_ptr_ty = self.cx.val_ty(ptr);\n+        let stored_ty = self.cx.val_ty(val);\n+        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n+\n+        assert_eq!(self.cx.type_kind(dest_ptr_ty), TypeKind::Pointer);\n+\n+        if dest_ptr_ty == stored_ptr_ty {\n+            ptr\n+        } else {\n+            debug!(\n+                \"type mismatch in store. \\\n+                    Expected {:?}, got {:?}; inserting bitcast\",\n+                dest_ptr_ty, stored_ptr_ty\n+            );\n+            self.bitcast(ptr, stored_ptr_ty)\n+        }\n+    }\n+\n+    fn check_call<'b>(\n+        &mut self,\n+        typ: &str,\n+        llfn: &'ll Value,\n+        args: &'b [&'ll Value],\n+    ) -> Cow<'b, [&'ll Value]> {\n+        let mut fn_ty = self.cx.val_ty(llfn);\n+        // Strip off pointers\n+        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n+            fn_ty = self.cx.element_type(fn_ty);\n+        }\n+\n+        assert!(\n+            self.cx.type_kind(fn_ty) == TypeKind::Function,\n+            \"builder::{} not passed a function, but {:?}\",\n+            typ,\n+            fn_ty\n+        );\n+\n+        let param_tys = self.cx.func_params_types(fn_ty);\n+\n+        let all_args_match = param_tys\n+            .iter()\n+            .zip(args.iter().map(|&v| self.val_ty(v)))\n+            .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n+\n+        if all_args_match {\n+            return Cow::Borrowed(args);\n+        }\n+\n+        let casted_args: Vec<_> = param_tys\n+            .into_iter()\n+            .zip(args.iter())\n+            .enumerate()\n+            .map(|(i, (expected_ty, &actual_val))| {\n+                let actual_ty = self.val_ty(actual_val);\n+                if expected_ty != actual_ty {\n+                    debug!(\n+                        \"type mismatch in function call of {:?}. \\\n+                            Expected {:?} for param {}, got {:?}; injecting bitcast\",\n+                        llfn, expected_ty, i, actual_ty\n+                    );\n+                    self.bitcast(actual_val, expected_ty)\n+                } else {\n+                    actual_val\n+                }\n+            })\n+            .collect();\n+\n+        Cow::Owned(casted_args)\n+    }\n+\n+    pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n+    }\n+\n+    fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n+        let size = size.bytes();\n+        if size == 0 {\n+            return;\n+        }\n+\n+        if !self.cx().sess().emit_lifetime_markers() {\n+            return;\n+        }\n+\n+        let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n+\n+        let ptr = self.pointercast(ptr, self.cx.type_i8p());\n+        self.call(lifetime_intrinsic, &[self.cx.const_u64(size), ptr], None);\n+    }\n+\n+    pub(crate) fn phi(\n+        &mut self,\n+        ty: &'ll Type,\n+        vals: &[&'ll Value],\n+        bbs: &[&'ll BasicBlock],\n+    ) -> &'ll Value {\n+        assert_eq!(vals.len(), bbs.len());\n+        let phi = unsafe { llvm::LLVMBuildPhi(self.llbuilder, ty, UNNAMED) };\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, vals.as_ptr(), bbs.as_ptr(), vals.len() as c_uint);\n+            phi\n+        }\n+    }\n+\n+    fn add_incoming_to_phi(&mut self, phi: &'ll Value, val: &'ll Value, bb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMAddIncoming(phi, &val, &bb, 1 as c_uint);\n+        }\n+    }\n+\n+    fn wasm_and_missing_nontrapping_fptoint(&self) -> bool {\n+        self.sess().target.target.arch == \"wasm32\"\n+            && !self.sess().target_features.contains(&sym::nontrapping_dash_fptoint)\n+    }\n+}"}, {"sha": "4afd906fce7e960676d2c0f7304ea81f7e60a25b", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -9,8 +9,8 @@ use crate::attributes;\n use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n-use log::debug;\n use rustc_codegen_ssa::traits::*;\n+use tracing::debug;\n \n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n@@ -172,7 +172,12 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n             }\n         }\n \n-        if cx.use_dll_storage_attrs && tcx.is_dllimport_foreign_item(instance_def_id) {\n+        // MinGW: For backward compatibility we rely on the linker to decide whether it\n+        // should use dllimport for functions.\n+        if cx.use_dll_storage_attrs\n+            && tcx.is_dllimport_foreign_item(instance_def_id)\n+            && tcx.sess.target.target.target_env != \"gnu\"\n+        {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }", "previous_filename": "src/librustc_codegen_llvm/callee.rs"}, {"sha": "0b1cf03fa7e42742bbf59caeed84d6b80c1f1733", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,341 @@\n+#![allow(non_camel_case_types, non_snake_case)]\n+\n+//! Code that is useful in various codegen modules.\n+\n+use crate::consts::{self, const_alloc_to_llvm};\n+pub use crate::context::CodegenCx;\n+use crate::llvm::{self, BasicBlock, Bool, ConstantInt, False, OperandBundleDef, True};\n+use crate::type_::Type;\n+use crate::type_of::LayoutLlvmExt;\n+use crate::value::Value;\n+\n+use rustc_ast::Mutability;\n+use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_middle::bug;\n+use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n+use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_span::symbol::Symbol;\n+use rustc_target::abi::{self, AddressSpace, HasDataLayout, LayoutOf, Pointer, Size};\n+\n+use libc::{c_char, c_uint};\n+use tracing::debug;\n+\n+/*\n+* A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n+*\n+* An \"extern\" is an LLVM symbol we wind up emitting an undefined external\n+* reference to. This means \"we don't have the thing in this compilation unit,\n+* please make sure you link it in at runtime\". This could be a reference to\n+* C code found in a C library, or rust code found in a rust crate.\n+*\n+* Most \"externs\" are implicitly declared (automatically) as a result of a\n+* user declaring an extern _module_ dependency; this causes the rust driver\n+* to locate an extern crate, scan its compilation metadata, and emit extern\n+* declarations for any symbols used by the declaring crate.\n+*\n+* A \"foreign\" is an extern that references C (or other non-rust ABI) code.\n+* There is no metadata to scan for extern references so in these cases either\n+* a header-digester like bindgen, or manual function prototypes, have to\n+* serve as declarators. So these are usually given explicitly as prototype\n+* declarations, in rust code, with ABI attributes on them noting which ABI to\n+* link via.\n+*\n+* An \"upcall\" is a foreign call generated by the compiler (not corresponding\n+* to any user-written call in the code) into the runtime library, to perform\n+* some helper task such as bringing a task to life, allocating memory, etc.\n+*\n+*/\n+\n+/// A structure representing an active landing pad for the duration of a basic\n+/// block.\n+///\n+/// Each `Block` may contain an instance of this, indicating whether the block\n+/// is part of a landing pad or not. This is used to make decision about whether\n+/// to emit `invoke` instructions (e.g., in a landing pad we don't continue to\n+/// use `invoke`) and also about various function call metadata.\n+///\n+/// For GNU exceptions (`landingpad` + `resume` instructions) this structure is\n+/// just a bunch of `None` instances (not too interesting), but for MSVC\n+/// exceptions (`cleanuppad` + `cleanupret` instructions) this contains data.\n+/// When inside of a landing pad, each function call in LLVM IR needs to be\n+/// annotated with which landing pad it's a part of. This is accomplished via\n+/// the `OperandBundleDef` value created for MSVC landing pads.\n+pub struct Funclet<'ll> {\n+    cleanuppad: &'ll Value,\n+    operand: OperandBundleDef<'ll>,\n+}\n+\n+impl Funclet<'ll> {\n+    pub fn new(cleanuppad: &'ll Value) -> Self {\n+        Funclet { cleanuppad, operand: OperandBundleDef::new(\"funclet\", &[cleanuppad]) }\n+    }\n+\n+    pub fn cleanuppad(&self) -> &'ll Value {\n+        self.cleanuppad\n+    }\n+\n+    pub fn bundle(&self) -> &OperandBundleDef<'ll> {\n+        &self.operand\n+    }\n+}\n+\n+impl BackendTypes for CodegenCx<'ll, 'tcx> {\n+    type Value = &'ll Value;\n+    type Function = &'ll Value;\n+\n+    type BasicBlock = &'ll BasicBlock;\n+    type Type = &'ll Type;\n+    type Funclet = Funclet<'ll>;\n+\n+    type DIScope = &'ll llvm::debuginfo::DIScope;\n+    type DIVariable = &'ll llvm::debuginfo::DIVariable;\n+}\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    pub fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe { llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint) }\n+    }\n+\n+    pub fn const_vector(&self, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe { llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint) }\n+    }\n+\n+    pub fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n+        bytes_in_context(self.llcx, bytes)\n+    }\n+\n+    fn const_cstr(&self, s: Symbol, null_terminated: bool) -> &'ll Value {\n+        unsafe {\n+            if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n+                return llval;\n+            }\n+\n+            let s_str = s.as_str();\n+            let sc = llvm::LLVMConstStringInContext(\n+                self.llcx,\n+                s_str.as_ptr() as *const c_char,\n+                s_str.len() as c_uint,\n+                !null_terminated as Bool,\n+            );\n+            let sym = self.generate_local_symbol_name(\"str\");\n+            let g = self.define_global(&sym[..], self.val_ty(sc)).unwrap_or_else(|| {\n+                bug!(\"symbol `{}` is already defined\", sym);\n+            });\n+            llvm::LLVMSetInitializer(g, sc);\n+            llvm::LLVMSetGlobalConstant(g, True);\n+            llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n+\n+            self.const_cstr_cache.borrow_mut().insert(s, g);\n+            g\n+        }\n+    }\n+\n+    pub fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {\n+        unsafe {\n+            assert_eq!(idx as c_uint as u64, idx);\n+            let us = &[idx as c_uint];\n+            let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+\n+            debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\", v, idx, r);\n+\n+            r\n+        }\n+    }\n+}\n+\n+impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn const_null(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMConstNull(t) }\n+    }\n+\n+    fn const_undef(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMGetUndef(t) }\n+    }\n+\n+    fn const_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n+        unsafe { llvm::LLVMConstInt(t, i as u64, True) }\n+    }\n+\n+    fn const_uint(&self, t: &'ll Type, i: u64) -> &'ll Value {\n+        unsafe { llvm::LLVMConstInt(t, i, False) }\n+    }\n+\n+    fn const_uint_big(&self, t: &'ll Type, u: u128) -> &'ll Value {\n+        unsafe {\n+            let words = [u as u64, (u >> 64) as u64];\n+            llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n+        }\n+    }\n+\n+    fn const_bool(&self, val: bool) -> &'ll Value {\n+        self.const_uint(self.type_i1(), val as u64)\n+    }\n+\n+    fn const_i32(&self, i: i32) -> &'ll Value {\n+        self.const_int(self.type_i32(), i as i64)\n+    }\n+\n+    fn const_u32(&self, i: u32) -> &'ll Value {\n+        self.const_uint(self.type_i32(), i as u64)\n+    }\n+\n+    fn const_u64(&self, i: u64) -> &'ll Value {\n+        self.const_uint(self.type_i64(), i)\n+    }\n+\n+    fn const_usize(&self, i: u64) -> &'ll Value {\n+        let bit_size = self.data_layout().pointer_size.bits();\n+        if bit_size < 64 {\n+            // make sure it doesn't overflow\n+            assert!(i < (1 << bit_size));\n+        }\n+\n+        self.const_uint(self.isize_ty, i)\n+    }\n+\n+    fn const_u8(&self, i: u8) -> &'ll Value {\n+        self.const_uint(self.type_i8(), i as u64)\n+    }\n+\n+    fn const_real(&self, t: &'ll Type, val: f64) -> &'ll Value {\n+        unsafe { llvm::LLVMConstReal(t, val) }\n+    }\n+\n+    fn const_str(&self, s: Symbol) -> (&'ll Value, &'ll Value) {\n+        let len = s.as_str().len();\n+        let cs = consts::ptrcast(\n+            self.const_cstr(s, false),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).llvm_type(self)),\n+        );\n+        (cs, self.const_usize(len as u64))\n+    }\n+\n+    fn const_struct(&self, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n+        struct_in_context(self.llcx, elts, packed)\n+    }\n+\n+    fn const_to_opt_uint(&self, v: &'ll Value) -> Option<u64> {\n+        try_as_const_integral(v).map(|v| unsafe { llvm::LLVMConstIntGetZExtValue(v) })\n+    }\n+\n+    fn const_to_opt_u128(&self, v: &'ll Value, sign_ext: bool) -> Option<u128> {\n+        try_as_const_integral(v).and_then(|v| unsafe {\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext, &mut hi, &mut lo);\n+            success.then_some(hi_lo_to_u128(lo, hi))\n+        })\n+    }\n+\n+    fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n+        let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n+        match cv {\n+            Scalar::Raw { size: 0, .. } => {\n+                assert_eq!(0, layout.value.size(self).bytes());\n+                self.const_undef(self.type_ix(0))\n+            }\n+            Scalar::Raw { data, size } => {\n+                assert_eq!(size as u64, layout.value.size(self).bytes());\n+                let llval = self.const_uint_big(self.type_ix(bitsize), data);\n+                if layout.value == Pointer {\n+                    unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+                } else {\n+                    self.const_bitcast(llval, llty)\n+                }\n+            }\n+            Scalar::Ptr(ptr) => {\n+                let (base_addr, base_addr_space) = match self.tcx.global_alloc(ptr.alloc_id) {\n+                    GlobalAlloc::Memory(alloc) => {\n+                        let init = const_alloc_to_llvm(self, alloc);\n+                        let value = match alloc.mutability {\n+                            Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n+                            _ => self.static_addr_of(init, alloc.align, None),\n+                        };\n+                        if !self.sess().fewer_names() {\n+                            llvm::set_value_name(value, format!(\"{:?}\", ptr.alloc_id).as_bytes());\n+                        }\n+                        (value, AddressSpace::DATA)\n+                    }\n+                    GlobalAlloc::Function(fn_instance) => (\n+                        self.get_fn_addr(fn_instance.polymorphize(self.tcx)),\n+                        self.data_layout().instruction_address_space,\n+                    ),\n+                    GlobalAlloc::Static(def_id) => {\n+                        assert!(self.tcx.is_static(def_id));\n+                        assert!(!self.tcx.is_thread_local_static(def_id));\n+                        (self.get_static(def_id), AddressSpace::DATA)\n+                    }\n+                };\n+                let llval = unsafe {\n+                    llvm::LLVMConstInBoundsGEP(\n+                        self.const_bitcast(base_addr, self.type_i8p_ext(base_addr_space)),\n+                        &self.const_usize(ptr.offset.bytes()),\n+                        1,\n+                    )\n+                };\n+                if layout.value != Pointer {\n+                    unsafe { llvm::LLVMConstPtrToInt(llval, llty) }\n+                } else {\n+                    self.const_bitcast(llval, llty)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn from_const_alloc(\n+        &self,\n+        layout: TyAndLayout<'tcx>,\n+        alloc: &Allocation,\n+        offset: Size,\n+    ) -> PlaceRef<'tcx, &'ll Value> {\n+        assert_eq!(alloc.align, layout.align.abi);\n+        let llty = self.type_ptr_to(layout.llvm_type(self));\n+        let llval = if layout.size == Size::ZERO {\n+            let llval = self.const_usize(alloc.align.bytes());\n+            unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n+        } else {\n+            let init = const_alloc_to_llvm(self, alloc);\n+            let base_addr = self.static_addr_of(init, alloc.align, None);\n+\n+            let llval = unsafe {\n+                llvm::LLVMConstInBoundsGEP(\n+                    self.const_bitcast(base_addr, self.type_i8p()),\n+                    &self.const_usize(offset.bytes()),\n+                    1,\n+                )\n+            };\n+            self.const_bitcast(llval, llty)\n+        };\n+        PlaceRef::new_sized(llval, layout)\n+    }\n+\n+    fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        consts::ptrcast(val, ty)\n+    }\n+}\n+\n+pub fn val_ty(v: &Value) -> &Type {\n+    unsafe { llvm::LLVMTypeOf(v) }\n+}\n+\n+pub fn bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+    unsafe {\n+        let ptr = bytes.as_ptr() as *const c_char;\n+        llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True)\n+    }\n+}\n+\n+pub fn struct_in_context(llcx: &'a llvm::Context, elts: &[&'a Value], packed: bool) -> &'a Value {\n+    unsafe {\n+        llvm::LLVMConstStructInContext(llcx, elts.as_ptr(), elts.len() as c_uint, packed as Bool)\n+    }\n+}\n+\n+#[inline]\n+fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n+    ((hi as u128) << 64) | (lo as u128)\n+}\n+\n+fn try_as_const_integral(v: &Value) -> Option<&ConstantInt> {\n+    unsafe { llvm::LLVMIsAConstantInt(v) }\n+}"}, {"sha": "86a5ec592543a3572f3e8739563b245230dc967f", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "patch": "@@ -0,0 +1,512 @@\n+use crate::base;\n+use crate::common::CodegenCx;\n+use crate::debuginfo;\n+use crate::llvm::{self, True};\n+use crate::type_::Type;\n+use crate::type_of::LayoutLlvmExt;\n+use crate::value::Value;\n+use libc::c_uint;\n+use rustc_codegen_ssa::traits::*;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Node;\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::interpret::{\n+    read_target_uint, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer,\n+};\n+use rustc_middle::mir::mono::MonoItem;\n+use rustc_middle::ty::{self, Instance, Ty};\n+use rustc_middle::{bug, span_bug};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use tracing::debug;\n+\n+use std::ffi::CStr;\n+\n+pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll Value {\n+    let mut llvals = Vec::with_capacity(alloc.relocations().len() + 1);\n+    let dl = cx.data_layout();\n+    let pointer_size = dl.pointer_size.bytes() as usize;\n+\n+    let mut next_offset = 0;\n+    for &(offset, ((), alloc_id)) in alloc.relocations().iter() {\n+        let offset = offset.bytes();\n+        assert_eq!(offset as usize as u64, offset);\n+        let offset = offset as usize;\n+        if offset > next_offset {\n+            // This `inspect` is okay since we have checked that it is not within a relocation, it\n+            // is within the bounds of the allocation, and it doesn't affect interpreter execution\n+            // (we inspect the result after interpreter execution). Any undef byte is replaced with\n+            // some arbitrary byte value.\n+            //\n+            // FIXME: relay undef bytes to codegen as undef const bytes\n+            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n+            llvals.push(cx.const_bytes(bytes));\n+        }\n+        let ptr_offset = read_target_uint(\n+            dl.endian,\n+            // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n+            // affect interpreter execution (we inspect the result after interpreter execution),\n+            // and we properly interpret the relocation as a relocation pointer offset.\n+            alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n+        )\n+        .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n+            as u64;\n+\n+        let address_space = match cx.tcx.global_alloc(alloc_id) {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) => AddressSpace::DATA,\n+        };\n+\n+        llvals.push(cx.scalar_to_backend(\n+            Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n+            &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n+            cx.type_i8p_ext(address_space),\n+        ));\n+        next_offset = offset + pointer_size;\n+    }\n+    if alloc.len() >= next_offset {\n+        let range = next_offset..alloc.len();\n+        // This `inspect` is okay since we have check that it is after all relocations, it is\n+        // within the bounds of the allocation, and it doesn't affect interpreter execution (we\n+        // inspect the result after interpreter execution). Any undef byte is replaced with some\n+        // arbitrary byte value.\n+        //\n+        // FIXME: relay undef bytes to codegen as undef const bytes\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n+        llvals.push(cx.const_bytes(bytes));\n+    }\n+\n+    cx.const_struct(&llvals, true)\n+}\n+\n+pub fn codegen_static_initializer(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    def_id: DefId,\n+) -> Result<(&'ll Value, &'tcx Allocation), ErrorHandled> {\n+    let alloc = match cx.tcx.const_eval_poly(def_id)? {\n+        ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => alloc,\n+        val => bug!(\"static const eval returned {:#?}\", val),\n+    };\n+    Ok((const_alloc_to_llvm(cx, alloc), alloc))\n+}\n+\n+fn set_global_alignment(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller.  Rust doesn't support this yet.\n+    if let Some(min) = cx.sess().target.target.options.min_global_align {\n+        match Align::from_bits(min) {\n+            Ok(min) => align = align.max(min),\n+            Err(err) => {\n+                cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+            }\n+        }\n+    }\n+    unsafe {\n+        llvm::LLVMSetAlignment(gv, align.bytes() as u32);\n+    }\n+}\n+\n+fn check_and_apply_linkage(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    attrs: &CodegenFnAttrs,\n+    ty: Ty<'tcx>,\n+    sym: &str,\n+    span: Span,\n+) -> &'ll Value {\n+    let llty = cx.layout_of(ty).llvm_type(cx);\n+    if let Some(linkage) = attrs.linkage {\n+        debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n+\n+        // If this is a static with a linkage specified, then we need to handle\n+        // it a little specially. The typesystem prevents things like &T and\n+        // extern \"C\" fn() from being non-null, so we can't just declare a\n+        // static and call it a day. Some linkages (like weak) will make it such\n+        // that the static actually has a null value.\n+        let llty2 = if let ty::RawPtr(ref mt) = ty.kind {\n+            cx.layout_of(mt.ty).llvm_type(cx)\n+        } else {\n+            cx.sess().span_fatal(\n+                span,\n+                \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n+            )\n+        };\n+        unsafe {\n+            // Declare a symbol `foo` with the desired linkage.\n+            let g1 = cx.declare_global(&sym, llty2);\n+            llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n+\n+            // Declare an internal global `extern_with_linkage_foo` which\n+            // is initialized with the address of `foo`.  If `foo` is\n+            // discarded during linking (for example, if `foo` has weak\n+            // linkage and there are no definitions), then\n+            // `extern_with_linkage_foo` will instead be initialized to\n+            // zero.\n+            let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+            real_name.push_str(&sym);\n+            let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n+                cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n+            });\n+            llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n+            llvm::LLVMSetInitializer(g2, g1);\n+            g2\n+        }\n+    } else {\n+        // Generate an external declaration.\n+        // FIXME(nagisa): investigate whether it can be changed into define_global\n+        cx.declare_global(&sym, llty)\n+    }\n+}\n+\n+pub fn ptrcast(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    unsafe { llvm::LLVMConstPointerCast(val, ty) }\n+}\n+\n+impl CodegenCx<'ll, 'tcx> {\n+    crate fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMConstBitCast(val, ty) }\n+    }\n+\n+    crate fn static_addr_of_mut(\n+        &self,\n+        cv: &'ll Value,\n+        align: Align,\n+        kind: Option<&str>,\n+    ) -> &'ll Value {\n+        unsafe {\n+            let gv = match kind {\n+                Some(kind) if !self.tcx.sess.fewer_names() => {\n+                    let name = self.generate_local_symbol_name(kind);\n+                    let gv = self.define_global(&name[..], self.val_ty(cv)).unwrap_or_else(|| {\n+                        bug!(\"symbol `{}` is already defined\", name);\n+                    });\n+                    llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n+                    gv\n+                }\n+                _ => self.define_private_global(self.val_ty(cv)),\n+            };\n+            llvm::LLVMSetInitializer(gv, cv);\n+            set_global_alignment(&self, gv, align);\n+            llvm::SetUnnamedAddress(gv, llvm::UnnamedAddr::Global);\n+            gv\n+        }\n+    }\n+\n+    crate fn get_static(&self, def_id: DefId) -> &'ll Value {\n+        let instance = Instance::mono(self.tcx, def_id);\n+        if let Some(&g) = self.instances.borrow().get(&instance) {\n+            return g;\n+        }\n+\n+        let defined_in_current_codegen_unit =\n+            self.codegen_unit.items().contains_key(&MonoItem::Static(def_id));\n+        assert!(\n+            !defined_in_current_codegen_unit,\n+            \"consts::get_static() should always hit the cache for \\\n+                 statics defined in the same CGU, but did not for `{:?}`\",\n+            def_id\n+        );\n+\n+        let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n+        let sym = self.tcx.symbol_name(instance).name;\n+\n+        debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+\n+        let g = if let Some(def_id) = def_id.as_local() {\n+            let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+            let llty = self.layout_of(ty).llvm_type(self);\n+            // FIXME: refactor this to work without accessing the HIR\n+            let (g, attrs) = match self.tcx.hir().get(id) {\n+                Node::Item(&hir::Item { attrs, span, kind: hir::ItemKind::Static(..), .. }) => {\n+                    if let Some(g) = self.get_declared_value(sym) {\n+                        if self.val_ty(g) != self.type_ptr_to(llty) {\n+                            span_bug!(span, \"Conflicting types for static\");\n+                        }\n+                    }\n+\n+                    let g = self.declare_global(sym, llty);\n+\n+                    if !self.tcx.is_reachable_non_generic(def_id) {\n+                        unsafe {\n+                            llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n+                        }\n+                    }\n+\n+                    (g, attrs)\n+                }\n+\n+                Node::ForeignItem(&hir::ForeignItem {\n+                    ref attrs,\n+                    span,\n+                    kind: hir::ForeignItemKind::Static(..),\n+                    ..\n+                }) => {\n+                    let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n+                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, span), &**attrs)\n+                }\n+\n+                item => bug!(\"get_static: expected static, found {:?}\", item),\n+            };\n+\n+            debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+\n+            for attr in attrs {\n+                if self.tcx.sess.check_name(attr, sym::thread_local) {\n+                    llvm::set_thread_local_mode(g, self.tls_model);\n+                }\n+            }\n+\n+            g\n+        } else {\n+            // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n+            debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n+\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n+            let span = self.tcx.def_span(def_id);\n+            let g = check_and_apply_linkage(&self, &attrs, ty, sym, span);\n+\n+            // Thread-local statics in some other crate need to *always* be linked\n+            // against in a thread-local fashion, so we need to be sure to apply the\n+            // thread-local attribute locally if it was present remotely. If we\n+            // don't do this then linker errors can be generated where the linker\n+            // complains that one object files has a thread local version of the\n+            // symbol and another one doesn't.\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+            }\n+\n+            let needs_dll_storage_attr = self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n+                // ThinLTO can't handle this workaround in all cases, so we don't\n+                // emit the attrs. Instead we make them unnecessary by disallowing\n+                // dynamic linking when linker plugin based LTO is enabled.\n+                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled();\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.target.options.is_like_windows\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unsafe {\n+                        llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+                    }\n+                }\n+            }\n+            g\n+        };\n+\n+        if self.use_dll_storage_attrs && self.tcx.is_dllimport_foreign_item(def_id) {\n+            // For foreign (native) libs we know the exact storage type to use.\n+            unsafe {\n+                llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n+            }\n+        }\n+\n+        self.instances.borrow_mut().insert(instance, g);\n+        g\n+    }\n+}\n+\n+impl StaticMethods for CodegenCx<'ll, 'tcx> {\n+    fn static_addr_of(&self, cv: &'ll Value, align: Align, kind: Option<&str>) -> &'ll Value {\n+        if let Some(&gv) = self.const_globals.borrow().get(&cv) {\n+            unsafe {\n+                // Upgrade the alignment in cases where the same constant is used with different\n+                // alignment requirements\n+                let llalign = align.bytes() as u32;\n+                if llalign > llvm::LLVMGetAlignment(gv) {\n+                    llvm::LLVMSetAlignment(gv, llalign);\n+                }\n+            }\n+            return gv;\n+        }\n+        let gv = self.static_addr_of_mut(cv, align, kind);\n+        unsafe {\n+            llvm::LLVMSetGlobalConstant(gv, True);\n+        }\n+        self.const_globals.borrow_mut().insert(cv, gv);\n+        gv\n+    }\n+\n+    fn codegen_static(&self, def_id: DefId, is_mutable: bool) {\n+        unsafe {\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n+\n+            let (v, alloc) = match codegen_static_initializer(&self, def_id) {\n+                Ok(v) => v,\n+                // Error has already been reported\n+                Err(_) => return,\n+            };\n+\n+            let g = self.get_static(def_id);\n+\n+            // boolean SSA values are i1, but they have to be stored in i8 slots,\n+            // otherwise some LLVM optimization passes don't work as expected\n+            let mut val_llty = self.val_ty(v);\n+            let v = if val_llty == self.type_i1() {\n+                val_llty = self.type_i8();\n+                llvm::LLVMConstZExt(v, val_llty)\n+            } else {\n+                v\n+            };\n+\n+            let instance = Instance::mono(self.tcx, def_id);\n+            let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n+            let llty = self.layout_of(ty).llvm_type(self);\n+            let g = if val_llty == llty {\n+                g\n+            } else {\n+                // If we created the global with the wrong type,\n+                // correct the type.\n+                let name = llvm::get_value_name(g).to_vec();\n+                llvm::set_value_name(g, b\"\");\n+\n+                let linkage = llvm::LLVMRustGetLinkage(g);\n+                let visibility = llvm::LLVMRustGetVisibility(g);\n+\n+                let new_g = llvm::LLVMRustGetOrInsertGlobal(\n+                    self.llmod,\n+                    name.as_ptr().cast(),\n+                    name.len(),\n+                    val_llty,\n+                );\n+\n+                llvm::LLVMRustSetLinkage(new_g, linkage);\n+                llvm::LLVMRustSetVisibility(new_g, visibility);\n+\n+                // To avoid breaking any invariants, we leave around the old\n+                // global for the moment; we'll replace all references to it\n+                // with the new global later. (See base::codegen_backend.)\n+                self.statics_to_rauw.borrow_mut().push((g, new_g));\n+                new_g\n+            };\n+            set_global_alignment(&self, g, self.align_of(ty));\n+            llvm::LLVMSetInitializer(g, v);\n+\n+            // As an optimization, all shared statics which do not have interior\n+            // mutability are placed into read-only memory.\n+            if !is_mutable {\n+                if self.type_is_freeze(ty) {\n+                    llvm::LLVMSetGlobalConstant(g, llvm::True);\n+                }\n+            }\n+\n+            debuginfo::create_global_var_metadata(&self, def_id, g);\n+\n+            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+                llvm::set_thread_local_mode(g, self.tls_model);\n+\n+                // Do not allow LLVM to change the alignment of a TLS on macOS.\n+                //\n+                // By default a global's alignment can be freely increased.\n+                // This allows LLVM to generate more performant instructions\n+                // e.g., using load-aligned into a SIMD register.\n+                //\n+                // However, on macOS 10.10 or below, the dynamic linker does not\n+                // respect any alignment given on the TLS (radar 24221680).\n+                // This will violate the alignment assumption, and causing segfault at runtime.\n+                //\n+                // This bug is very easy to trigger. In `println!` and `panic!`,\n+                // the `LOCAL_STDOUT`/`LOCAL_STDERR` handles are stored in a TLS,\n+                // which the values would be `mem::replace`d on initialization.\n+                // The implementation of `mem::replace` will use SIMD\n+                // whenever the size is 32 bytes or higher. LLVM notices SIMD is used\n+                // and tries to align `LOCAL_STDOUT`/`LOCAL_STDERR` to a 32-byte boundary,\n+                // which macOS's dyld disregarded and causing crashes\n+                // (see issues #51794, #51758, #50867, #48866 and #44056).\n+                //\n+                // To workaround the bug, we trick LLVM into not increasing\n+                // the global's alignment by explicitly assigning a section to it\n+                // (equivalent to automatically generating a `#[link_section]` attribute).\n+                // See the comment in the `GlobalValue::canIncreaseAlignment()` function\n+                // of `lib/IR/Globals.cpp` for why this works.\n+                //\n+                // When the alignment is not increased, the optimized `mem::replace`\n+                // will use load-unaligned instructions instead, and thus avoiding the crash.\n+                //\n+                // We could remove this hack whenever we decide to drop macOS 10.10 support.\n+                if self.tcx.sess.target.target.options.is_like_osx {\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state\n+                    // (not as part of the interpreter execution).\n+                    //\n+                    // FIXME: This check requires that the (arbitrary) value of undefined bytes\n+                    // happens to be zero. Instead, we should only check the value of defined bytes\n+                    // and set all undefined bytes to zero if this allocation is headed for the\n+                    // BSS.\n+                    let all_bytes_are_zero = alloc.relocations().is_empty()\n+                        && alloc\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n+                            .iter()\n+                            .all(|&byte| byte == 0);\n+\n+                    let sect_name = if all_bytes_are_zero {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_bss\\0\")\n+                    } else {\n+                        CStr::from_bytes_with_nul_unchecked(b\"__DATA,__thread_data\\0\")\n+                    };\n+                    llvm::LLVMSetSection(g, sect_name.as_ptr());\n+                }\n+            }\n+\n+            // Wasm statics with custom link sections get special treatment as they\n+            // go into custom sections of the wasm executable.\n+            if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n+                if let Some(section) = attrs.link_section {\n+                    let section = llvm::LLVMMDStringInContext(\n+                        self.llcx,\n+                        section.as_str().as_ptr().cast(),\n+                        section.as_str().len() as c_uint,\n+                    );\n+                    assert!(alloc.relocations().is_empty());\n+\n+                    // The `inspect` method is okay here because we checked relocations, and\n+                    // because we are doing this access to inspect the final interpreter state (not\n+                    // as part of the interpreter execution).\n+                    let bytes =\n+                        alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len());\n+                    let alloc = llvm::LLVMMDStringInContext(\n+                        self.llcx,\n+                        bytes.as_ptr().cast(),\n+                        bytes.len() as c_uint,\n+                    );\n+                    let data = [section, alloc];\n+                    let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);\n+                    llvm::LLVMAddNamedMetadataOperand(\n+                        self.llmod,\n+                        \"wasm.custom_sections\\0\".as_ptr().cast(),\n+                        meta,\n+                    );\n+                }\n+            } else {\n+                base::set_link_section(g, &attrs);\n+            }\n+\n+            if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n+                self.add_used_global(g);\n+            }\n+        }\n+    }\n+\n+    /// Add a global value to a list to be stored in the `llvm.used` variable, an array of i8*.\n+    fn add_used_global(&self, global: &'ll Value) {\n+        let cast = unsafe { llvm::LLVMConstPointerCast(global, self.type_i8p()) };\n+        self.used_statics.borrow_mut().push(cast);\n+    }\n+}"}, {"sha": "1c51a9df5d884eeb4256a45dccf5282f922eb071", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "ec6c177614d4e54ae536e7d4564bb3c4940b06b1", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "2bd37bf9c4f9ca1d299643b0bf04f3b55cf95b33", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "7f47b61de3f928277d0741f535c53961f3ad682a", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs"}, {"sha": "b3a8fa2988785da9ed8f028f46fcab63ebda7c0e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/doc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fdoc.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/doc.rs"}, {"sha": "29edd66049cdcf1acebfa5fa50da949dabdab749", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs"}, {"sha": "9d92d53775cc7b1cb05d65794ed6ad6bdb933cb4", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "added", "additions": 2585, "deletions": 0, "changes": 2585, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "b414426af8c655614a79ae8f95c6aeb9a44975d6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "d1a55335c44e7e62705feae9fe23b6f0906f37f6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/namespace.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fnamespace.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/namespace.rs"}, {"sha": "66ae9d72c3e5195fb1d10b462fd1cdfe6f965154", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/source_loc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fsource_loc.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/source_loc.rs"}, {"sha": "ee188e69be11fd7f30f8838de9cbd99eae622fb3", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/debuginfo/utils.rs"}, {"sha": "ec42bd4a039e6d4478d615838b2d7b6d3a385625", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/declare.rs"}, {"sha": "951b9928cc99d9779c0fe6b5ec09d7d69d9bec72", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "added", "additions": 2241, "deletions": 0, "changes": 2241, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "67d4b2642c058d3cfe26ea411a7bbfd29a4c6cbf", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/lib.rs"}, {"sha": "64db4f7462df81d860c559c94550bcbaa012a688", "filename": "compiler/rustc_codegen_llvm/src/llvm/archive_ro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Farchive_ro.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs"}, {"sha": "47f5c94e70c532fae1269884cc0c69529f0abe26", "filename": "compiler/rustc_codegen_llvm/src/llvm/diagnostic.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/llvm/diagnostic.rs"}, {"sha": "32822eba930c6022556ec3024e42f777dca36844", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "added", "additions": 2365, "deletions": 0, "changes": 2365, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "c09e3659f80a20053b6819df530bee4d783b78f8", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/llvm/mod.rs"}, {"sha": "f0b50459837e93d3bb8793ad0800e64144e69f29", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/llvm_util.rs"}, {"sha": "9036428c04b8acd0bce5240c56378bc483cd3932", "filename": "compiler/rustc_codegen_llvm/src/metadata.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmetadata.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "992e83d08fcae77e2384506fbebf91b910a078e8", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "3b53b4fe77be71250e411433a530bb035ff3d80f", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/type_.rs"}, {"sha": "a02601eb43eb807295793ec6548098a05b674700", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "54efa05aee81e315ea619eebb3b2bc827603f15d", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/va_arg.rs"}, {"sha": "1338a229566c82ac10c8dba9add79910cc8f07ce", "filename": "compiler/rustc_codegen_llvm/src/value.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fvalue.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_llvm/value.rs"}, {"sha": "e5df0f60941a8ca0091a76b43700e1ba7f0bae8a", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "7b770187b75aedd977e26a325b1f7f8d463bb7e9", "filename": "compiler/rustc_codegen_ssa/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FREADME.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/README.md"}, {"sha": "f83b4b2b0c025adb24d3c9c76fb45b42ae1a9020", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/archive.rs"}, {"sha": "0208bb73abdbe1e5d3c07e0c53ec190e73b8366e", "filename": "compiler/rustc_codegen_ssa/src/back/command.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fcommand.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/command.rs"}, {"sha": "270c8250e19812f11702c427a6b1401e1bca44a4", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "renamed", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/link.rs"}, {"sha": "0ddf8bd316fcd4255a6d676b74f6ff0bdac5331e", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "renamed", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/linker.rs"}, {"sha": "0d7f4447696f28fa7215f5ff4d4304d572a2072c", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/lto.rs"}, {"sha": "20ca503d43f45b9dcdc05a2edbe7a11c2bf6d6a3", "filename": "compiler/rustc_codegen_ssa/src/back/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/mod.rs"}, {"sha": "005d2efdd3b26ab95bff7995c2c7a5f5778eb61d", "filename": "compiler/rustc_codegen_ssa/src/back/rpath.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/rpath.rs"}, {"sha": "35836ae719b9c426a13e9476c3270f2015433f0d", "filename": "compiler/rustc_codegen_ssa/src/back/rpath/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Frpath%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/rpath/tests.rs"}, {"sha": "51cc1ada432dc7bf9b47c29bf4086db92a5544be", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "renamed", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/back/symbol_export.rs"}, {"sha": "7d69bb983dd744c2f5a9bf51226c98076930866f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "added", "additions": 1859, "deletions": 0, "changes": 1859, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "e0b649d91c79e43e99cb393cf835942ccd7e8fc6", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "added", "additions": 930, "deletions": 0, "changes": 930, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "e04ed531bbff282912f14f7ad59116103d77be4c", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "a266d179a421b6a520c84704efcca52a0ac11fca", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "814e43c5fa5e978ed85805633df533bc9ff388ee", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "569fd3f1a516d00198685a0f074417df8b80eca1", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "d1a0cf78d6a2efdae2902abc19a32c78015fcf55", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/debuginfo/mod.rs"}, {"sha": "fb8f5a6298911f23584790e9cf62b39db5ec189d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs"}, {"sha": "5b086bc43ff353ffa0ca75570d0397d2de7f660a", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/glue.rs"}, {"sha": "73e33369175874fe83d3d4b7e48849d9ec5be056", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "bcc19c6a44bd829ffff227b9c606938cb26da6b5", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/meth.rs"}, {"sha": "2e386c1e5946bf141e409900e7eaba4a88338c19", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/mir/analyze.rs"}, {"sha": "6eb80157239ea240d31ff5c97192fccab0228954", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "added", "additions": 1416, "deletions": 0, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "4943e279c7e050836959ed02dd975b138f804bba", "filename": "compiler/rustc_codegen_ssa/src/mir/constant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fconstant.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/mir/constant.rs"}, {"sha": "a2ad27b925c3472de89a43b9b2e074572842b51a", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "d8a530d98faa7df9f0228b1b11a10af891e030c1", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/mir/debuginfo.rs"}, {"sha": "26e6c3547026850b4e25c0a4ce38f728958f26ae", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "bbd004be87521c6fce3b21bd71be7465fce8f0de", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "added", "additions": 465, "deletions": 0, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "05656774f0e9556cfefeee295ad905e548e30976", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "added", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "1994c45707cedbe2570dac989d0a76e863818e37", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "renamed", "additions": 137, "deletions": 36, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/mir/rvalue.rs"}, {"sha": "6f74ba77d4c1670dea1921909f81d18cef250a9e", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/mir/statement.rs"}, {"sha": "607b5459673f3b5499f8f4be093cc9d4a5ff8b77", "filename": "compiler/rustc_codegen_ssa/src/mono_item.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmono_item.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "dd8495850bd5458e88a78f8a53e0ea04f16b2a8d", "filename": "compiler/rustc_codegen_ssa/src/traits/abi.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/abi.rs"}, {"sha": "69931935c496383087f24f7dfa17c2080622bbb0", "filename": "compiler/rustc_codegen_ssa/src/traits/asm.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fasm.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "3522ea0115334bba1ca196a42f9398470f98d437", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/backend.rs"}, {"sha": "5142922260a5722c8bb645f24d5956449b6e12c5", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "6b58dea794bcbca7099085b56c6d5ee99af59cb7", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/consts.rs"}, {"sha": "b74e4e459016fb30ff42ed2096e69e3e56e59a48", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "1ee0f489ffc104ef2daefa3ec07834790190744e", "filename": "compiler/rustc_codegen_ssa/src/traits/debuginfo.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdebuginfo.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/debuginfo.rs"}, {"sha": "690aacd20566b627d8ed5ec7eb1f24b0f4802e31", "filename": "compiler/rustc_codegen_ssa/src/traits/declare.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fdeclare.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/declare.rs"}, {"sha": "9d48e233de6558f251629bdf04641277ebfd61ff", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "fc57a9a80b26142529040ce0ab19ff7d2f541ce8", "filename": "compiler/rustc_codegen_ssa/src/traits/misc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/misc.rs"}, {"sha": "0ac519dd0b17cb9e2b7a5891c96c44142d5c243e", "filename": "compiler/rustc_codegen_ssa/src/traits/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/mod.rs"}, {"sha": "817fc02d166a35ba9dff5e61e3087e9628d59c3b", "filename": "compiler/rustc_codegen_ssa/src/traits/statics.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fstatics.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/statics.rs"}, {"sha": "726d948cfd40cf483be1e705af99a8412f59abd4", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/type_.rs"}, {"sha": "27d52e9b9c53e8ab524f192c7bee41b70ea77601", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_codegen_ssa/traits/write.rs"}, {"sha": "464f8c984dde8b90dfa21a0ca31d7a5f3ccb67be", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "eeb1b309257d4c90ace1860e468ca1a970b30001", "filename": "compiler/rustc_data_structures/src/atomic_ref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fatomic_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fatomic_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fatomic_ref.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/atomic_ref.rs"}, {"sha": "3c7bea27124096f35fd2cda702e5cb7ccc930b96", "filename": "compiler/rustc_data_structures/src/base_n.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/base_n.rs"}, {"sha": "b68ef1eb7f4c4da88d381afdd2ba2f86c9dfaff2", "filename": "compiler/rustc_data_structures/src/base_n/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbase_n%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/base_n/tests.rs"}, {"sha": "ede5757a479de273216921e6ec9e04ee8b8b8ce9", "filename": "compiler/rustc_data_structures/src/binary_search_util/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/binary_search_util/mod.rs"}, {"sha": "d74febb5c0fc4a13e2530de71982520e3a944fcf", "filename": "compiler/rustc_data_structures/src/binary_search_util/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbinary_search_util%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/binary_search_util/tests.rs"}, {"sha": "eb6f4e8213ec711dac0b945cc5c2f751c9511451", "filename": "compiler/rustc_data_structures/src/box_region.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fbox_region.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/box_region.rs"}, {"sha": "26b90ebfd5f117076cd4a99d4f1c772e0e1a8e5d", "filename": "compiler/rustc_data_structures/src/captures.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fcaptures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fcaptures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fcaptures.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/captures.rs"}, {"sha": "1ebcb87818ecf3b53b0e4911caaccda2cac30575", "filename": "compiler/rustc_data_structures/src/const_cstr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fconst_cstr.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/const_cstr.rs"}, {"sha": "f8d631ce01e78139b7dd6c11abc9229a51b76813", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "9383be474fd5a6224094a66f676875ec367681d5", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/flock.rs"}, {"sha": "2daf5b0414172ed1cf415438a8a6df31e2e1be8b", "filename": "compiler/rustc_data_structures/src/frozen.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/frozen.rs"}, {"sha": "bbeb193dba32b4c8970d8bc18160d4d2dd5563c7", "filename": "compiler/rustc_data_structures/src/fx.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffx.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/fx.rs"}, {"sha": "438a0d0c6ff970deb4e1a6a0086f7c7f884619f4", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/dominators/mod.rs"}, {"sha": "1160df5186b367d21b87f67756a23ef44d1bbb48", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/dominators/tests.rs"}, {"sha": "1aa7ac024d94e239d2acd5275dadd2515585e6e0", "filename": "compiler/rustc_data_structures/src/graph/implementation/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/implementation/mod.rs"}, {"sha": "e4e4d0d44babaa231055d95c5702d94ca9bf2429", "filename": "compiler/rustc_data_structures/src/graph/implementation/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fimplementation%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/implementation/tests.rs"}, {"sha": "64ff6130ddffb0e9679e18f7c26bc62f88ea5345", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/iterate/mod.rs"}, {"sha": "0e038e88b221dfed3f8d3b6aabbdb0b272d9ab96", "filename": "compiler/rustc_data_structures/src/graph/iterate/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/iterate/tests.rs"}, {"sha": "e0903e4324124784fa3b0eecd63e1f9879346702", "filename": "compiler/rustc_data_structures/src/graph/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/mod.rs"}, {"sha": "c259fe56c1509e913374dfe94b0025c5d715982c", "filename": "compiler/rustc_data_structures/src/graph/reference.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Freference.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/reference.rs"}, {"sha": "2db8e466e1144fb76ff7d3cbd863cecdc1561cfa", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/scc/mod.rs"}, {"sha": "1d5f46ebab1994176509cae2ce3516d9311b3044", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/scc/tests.rs"}, {"sha": "7f4ef906b361e478108b233204aae1436b17ecba", "filename": "compiler/rustc_data_structures/src/graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/tests.rs"}, {"sha": "064467174cae22f9b91812d6b9304e1d29a2d35d", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/vec_graph/mod.rs"}, {"sha": "c8f979267170f8227377130b9b5309e73b0b21b2", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/graph/vec_graph/tests.rs"}, {"sha": "a811c88839d704e5eac6bbbcc2d4f1ed42f867c6", "filename": "compiler/rustc_data_structures/src/jobserver.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/jobserver.rs"}, {"sha": "78b7e08ceedeffb88b74477a439933e5685ed112", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "67fbe3058cdb981170ce653c9d22c0695f8f753c", "filename": "compiler/rustc_data_structures/src/macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmacros.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/macros.rs"}, {"sha": "5dd9fc6e8bc085be2046c623be1a44ecfa53d3fd", "filename": "compiler/rustc_data_structures/src/map_in_place.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmap_in_place.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/map_in_place.rs"}, {"sha": "3a268e4b4f43224a5f60a8fbeee19feaaaa1c608", "filename": "compiler/rustc_data_structures/src/obligation_forest/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fgraphviz.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/obligation_forest/graphviz.rs"}, {"sha": "7cf5202d919f8269ee500813568cb12e77627d9b", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/obligation_forest/mod.rs"}, {"sha": "01652465eea2cc7a554134354ab6b29b0fdd7d82", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/obligation_forest/tests.rs"}, {"sha": "dff72d1e43251989d52b6bec53c8588f7f4df47b", "filename": "compiler/rustc_data_structures/src/owning_ref/LICENSE", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2FLICENSE?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/owning_ref/LICENSE"}, {"sha": "ad4b79de2361dfa3f4bd674f157efdb5e6e05fb1", "filename": "compiler/rustc_data_structures/src/owning_ref/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/owning_ref/mod.rs"}, {"sha": "7b8179e90bd0729f3609cc9d039cf65866c27882", "filename": "compiler/rustc_data_structures/src/owning_ref/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowning_ref%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/owning_ref/tests.rs"}, {"sha": "07d16c6483ec797cbec35e747dda60f9d277c343", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/profiling.rs"}, {"sha": "440ccb05d86e4a577d5b0619b089ac487fe6a753", "filename": "compiler/rustc_data_structures/src/ptr_key.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fptr_key.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/ptr_key.rs"}, {"sha": "485719c5175643532a5d7618e17ca614f1ba1e4b", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sharded.rs"}, {"sha": "beb28dd072058fd4a74d0c5d28d71b3196f9b91f", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sip128.rs"}, {"sha": "80b7fc74756108eb21c0ee00498ae94a394226da", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sip128/tests.rs"}, {"sha": "4a089398ce61e23e98ea6c78a84d6fe5438eaa59", "filename": "compiler/rustc_data_structures/src/small_c_str.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/small_c_str.rs"}, {"sha": "47277604b2b71e8a5da91d85cb8b2c11e550c3e1", "filename": "compiler/rustc_data_structures/src/small_c_str/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsmall_c_str%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/small_c_str/tests.rs"}, {"sha": "b4cc85293f7c19b84d27b612d0b09f56a25f7cd6", "filename": "compiler/rustc_data_structures/src/snapshot_map/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Fmod.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/snapshot_map/mod.rs"}, {"sha": "72ca53c2be9ed2fe2750444de3f037aee806bd9f", "filename": "compiler/rustc_data_structures/src/snapshot_map/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsnapshot_map%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/snapshot_map/tests.rs"}, {"sha": "856eb73e6297a79ac5cc48051fb241080baab0c9", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "renamed", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sorted_map.rs"}, {"sha": "2bb421a47efa689632dcc42dc445a584c0a8f845", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sorted_map/index_map.rs"}, {"sha": "7d91e1fdcef6a3f1db929218752e9a8cfa316416", "filename": "compiler/rustc_data_structures/src/sorted_map/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sorted_map/tests.rs"}, {"sha": "c1c79b174f415e93d4637ca0f684f54856a6871f", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/stable_hasher.rs"}, {"sha": "670452d0d8c5aeaf0ab37a6751697940975c0ab9", "filename": "compiler/rustc_data_structures/src/stable_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_map.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/stable_map.rs"}, {"sha": "c7ca74f5fbd9d1243f1895b392451b6b4757fbd9", "filename": "compiler/rustc_data_structures/src/stable_set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstable_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_set.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/stable_set.rs"}, {"sha": "a4964b7aa0cc8c95f72f9f90807beb89da952d98", "filename": "compiler/rustc_data_structures/src/stack.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstack.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/stack.rs"}, {"sha": "02103de2e8df913d15a8ca458cce1b3e4d7d39c8", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/svh.rs"}, {"sha": "d22f3adfb016dbac9f309039757d0df57614fe7b", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/sync.rs"}, {"sha": "e3839d193651d8c03e29cf409440cf91a3c8937b", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "d39d146db318f230f11e8ff1ae909c14e2e47175", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "63f64beae5a07089e24bebecb2b35f8d882361e2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "0d9b3e3ca25c0a744e131615d47b60d6b76f4174", "filename": "compiler/rustc_data_structures/src/temp_dir.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftemp_dir.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "4d673fd5cf98307ddc40b1e96779a6cbabb5e819", "filename": "compiler/rustc_data_structures/src/thin_vec.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fthin_vec.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/thin_vec.rs"}, {"sha": "e94a0c6eb5943d8012fc5c0e1a5ae3bc19d695a7", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/tiny_list.rs"}, {"sha": "a8ae2bc87278985f634ada857d67069880a07ef1", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/tiny_list/tests.rs"}, {"sha": "fe60a99dde07205f2b88c1d5a35c9c5df1d15292", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "renamed", "additions": 10, "deletions": 88, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/transitive_relation.rs"}, {"sha": "ca90ba176ae1a771b3e047c1d3bbedeec005c340", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/transitive_relation/tests.rs"}, {"sha": "1cf030d852e9fc8153388b6897a55da453bccf02", "filename": "compiler/rustc_data_structures/src/vec_linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/vec_linked_list.rs"}, {"sha": "0c848eb144d79bb8297838c7a9c7df7ad514925a", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_data_structures/work_queue.rs"}, {"sha": "76e8592254cd3e50b842bf995e4c5468a1094fd3", "filename": "compiler/rustc_driver/Cargo.toml", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "37dc7f6ba5fe4b06d1654ee4e686ecb7ce60e577", "filename": "compiler/rustc_driver/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FREADME.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_driver/README.md"}, {"sha": "5686819c61b402441490e510ce66f40b5333f9a7", "filename": "compiler/rustc_driver/src/args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_driver/args.rs"}, {"sha": "0d8332a20aea457ab1bad6955fbcd5dbaa837d2b", "filename": "compiler/rustc_driver/src/lib.rs", "status": "added", "additions": 1274, "deletions": 0, "changes": 1274, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "b0fbf1e03f5afd25cbd7eea466646d825c005bd8", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "b4c9cd9456523873f8935e3faf7c1bfc3bc46b74", "filename": "compiler/rustc_error_codes/Cargo.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2FCargo.toml?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d"}, {"sha": "4e5e77f80c28a1208c4f0121777816cd98cbf24f", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes.rs"}, {"sha": "90756780d15024d6d2d6415929f84153f12c7fda", "filename": "compiler/rustc_error_codes/src/error_codes/E0001.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0001.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0001.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0001.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0001.md"}, {"sha": "5cb59da10e00bc0074f0d134c8fabb625c3b0c95", "filename": "compiler/rustc_error_codes/src/error_codes/E0002.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0002.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0002.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0002.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0002.md"}, {"sha": "b79ef5fd8cb73685c80a74661f6c818114b50fe0", "filename": "compiler/rustc_error_codes/src/error_codes/E0004.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0004.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0004.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0004.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0004.md"}, {"sha": "e2e7db5082d168e2e6821dcb845fe57cd658f88d", "filename": "compiler/rustc_error_codes/src/error_codes/E0005.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0005.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0005.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0005.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0005.md"}, {"sha": "2be7870d5aeee8eff87cb77aff14dc42179779c1", "filename": "compiler/rustc_error_codes/src/error_codes/E0007.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0007.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0007.md"}, {"sha": "aaabba0434993e6dda9c58e82d3c2d00468f4a21", "filename": "compiler/rustc_error_codes/src/error_codes/E0009.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0009.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0009.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0009.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0009.md"}, {"sha": "71c790e102f93df46a69bcd5fe8c295f9051a945", "filename": "compiler/rustc_error_codes/src/error_codes/E0010.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0010.md"}, {"sha": "8de177590ece8c7a0fdb6fef686654d09e949fa4", "filename": "compiler/rustc_error_codes/src/error_codes/E0013.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0013.md"}, {"sha": "2c69957e9f6425be986c319523a4d5572f7075d3", "filename": "compiler/rustc_error_codes/src/error_codes/E0014.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0014.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0014.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0014.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0014.md"}, {"sha": "021a0219d13e2b60b8e79b49f3fb37132dc6789b", "filename": "compiler/rustc_error_codes/src/error_codes/E0015.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0015.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0015.md"}, {"sha": "7832468a539d315c71cab09ebc1e936258fe616b", "filename": "compiler/rustc_error_codes/src/error_codes/E0019.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0019.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0019.md"}, {"sha": "c1d85705da3a94b02c60b61bc124480f0ac921f1", "filename": "compiler/rustc_error_codes/src/error_codes/E0023.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0023.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0023.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0023.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0023.md"}, {"sha": "a85dc8c1978b2145cfb7ce8ba34bf6d6437f4251", "filename": "compiler/rustc_error_codes/src/error_codes/E0025.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0025.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0025.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0025.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0025.md"}, {"sha": "72c575aabb64380dfdbda2fb233906a789fa6114", "filename": "compiler/rustc_error_codes/src/error_codes/E0026.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0026.md"}, {"sha": "a8b1340ca0c780c7aa83e63c502d3d1b8bf70f66", "filename": "compiler/rustc_error_codes/src/error_codes/E0027.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0027.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0027.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0027.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0027.md"}, {"sha": "d12d85b9b4c993e80acf14e9ce72ba16111c93aa", "filename": "compiler/rustc_error_codes/src/error_codes/E0029.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0029.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0029.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0029.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0029.md"}, {"sha": "67d496da5e4eb771f8a2d17eba905ca20492a5db", "filename": "compiler/rustc_error_codes/src/error_codes/E0030.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0030.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0030.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0030.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0030.md"}, {"sha": "735a2d1f3fe85cbe9216790c44587fc7fd365412", "filename": "compiler/rustc_error_codes/src/error_codes/E0033.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0033.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0033.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0033.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0033.md"}, {"sha": "2a21f3441c660fd5dfd039c431b9542b5296b744", "filename": "compiler/rustc_error_codes/src/error_codes/E0034.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0034.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0034.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0034.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0034.md"}, {"sha": "b2cc2a2273af25514dcbf5d3749f9a446646d2bf", "filename": "compiler/rustc_error_codes/src/error_codes/E0038.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0038.md"}, {"sha": "1373f8340d8f6ddbc6497c76ccebaee6273e49ae", "filename": "compiler/rustc_error_codes/src/error_codes/E0040.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0040.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0040.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0040.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0040.md"}, {"sha": "635ff95329013a00b5789ec2c0fdc4f3bee9aab7", "filename": "compiler/rustc_error_codes/src/error_codes/E0044.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0044.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0044.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0044.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0044.md"}, {"sha": "143c693bf7c0778e4a35651300aa13b9ab869d46", "filename": "compiler/rustc_error_codes/src/error_codes/E0045.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0045.md"}, {"sha": "d8f95330c364bd032ee07613cb5d7180b1fc6a1d", "filename": "compiler/rustc_error_codes/src/error_codes/E0046.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0046.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0046.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0046.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0046.md"}, {"sha": "a2034a3428b2d6986586c7fa9edad672d1db41d3", "filename": "compiler/rustc_error_codes/src/error_codes/E0049.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0049.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0049.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0049.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0049.md"}, {"sha": "7b84c48007399b7035460ac9e442aa9ebb38c08c", "filename": "compiler/rustc_error_codes/src/error_codes/E0050.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0050.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0050.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0050.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0050.md"}, {"sha": "cb2a8638a29c538ff3771deeef800cb8772989ea", "filename": "compiler/rustc_error_codes/src/error_codes/E0053.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0053.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0053.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0053.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0053.md"}, {"sha": "c3eb375fbcc9a07e066a7af1ce3803346d81611c", "filename": "compiler/rustc_error_codes/src/error_codes/E0054.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0054.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0054.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0054.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0054.md"}, {"sha": "223ba4000298614bf3bb6498f3a2531d7dcc22f6", "filename": "compiler/rustc_error_codes/src/error_codes/E0055.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0055.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0055.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0055.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0055.md"}, {"sha": "bb5e4b48d2debee167ef664ff0381a1f5a52270d", "filename": "compiler/rustc_error_codes/src/error_codes/E0057.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0057.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0057.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0057.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0057.md"}, {"sha": "b22edead25e7b26bc6dfe466001d0150c3081f2f", "filename": "compiler/rustc_error_codes/src/error_codes/E0059.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0059.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0059.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0059.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0059.md"}, {"sha": "e6906d72367d8faa346ff943faa9ff69e5f2c18b", "filename": "compiler/rustc_error_codes/src/error_codes/E0060.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0060.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0060.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0060.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0060.md"}, {"sha": "143251c13b069dd7bec12b8a5eb2fa6828b0eeea", "filename": "compiler/rustc_error_codes/src/error_codes/E0061.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0061.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0061.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0061.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0061.md"}, {"sha": "64fc027b885b632b4c06debbd9c4f2a2269759b1", "filename": "compiler/rustc_error_codes/src/error_codes/E0062.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0062.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0062.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0062.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0062.md"}, {"sha": "0e611deac426fa6d081957d1530ae8149a4c3cd1", "filename": "compiler/rustc_error_codes/src/error_codes/E0063.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0063.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0063.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0063.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0063.md"}, {"sha": "11041bb53ee5527c7d154401c79b36709ee94d1b", "filename": "compiler/rustc_error_codes/src/error_codes/E0067.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0067.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0067.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0067.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0067.md"}, {"sha": "7367a5c0922ea9eae793ce6df00aa69de9519108", "filename": "compiler/rustc_error_codes/src/error_codes/E0069.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0069.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0069.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0069.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0069.md"}, {"sha": "97522af3da867573aea68c34f40112e3949e61db", "filename": "compiler/rustc_error_codes/src/error_codes/E0070.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0070.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0070.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0070.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0070.md"}, {"sha": "bc2c03a0220826f81558b003a18cbd71a891f04e", "filename": "compiler/rustc_error_codes/src/error_codes/E0071.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0071.md", "raw_url": "https://github.com/rust-lang/rust/raw/010891f8b83d0795d8d92770755f0a0cc1d0a91d/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0071.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0071.md?ref=010891f8b83d0795d8d92770755f0a0cc1d0a91d", "previous_filename": "src/librustc_error_codes/error_codes/E0071.md"}]}