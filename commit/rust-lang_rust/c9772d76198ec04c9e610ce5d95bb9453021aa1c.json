{"sha": "c9772d76198ec04c9e610ce5d95bb9453021aa1c", "node_id": "C_kwDOAAsO6NoAKGM5NzcyZDc2MTk4ZWMwNGM5ZTYxMGNlNWQ5NWJiOTQ1MzAyMWFhMWM", "commit": {"author": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-13T15:35:00Z"}, "committer": {"name": "R\u00e9my Rakic", "email": "remy.rakic+github@gmail.com", "date": "2022-06-28T20:09:29Z"}, "message": "const alloc interning: only check for references for arrays/slices\n\nChecking the size/alignment of an mplace may be costly, so we only do it\non the types where the walk we want to avoid could be expensive: the larger types\nlike arrays and slices, rather than on all aggregates being interned.", "tree": {"sha": "12848e293c4031dbaa28bb40569dbd26934183f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12848e293c4031dbaa28bb40569dbd26934183f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9772d76198ec04c9e610ce5d95bb9453021aa1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9772d76198ec04c9e610ce5d95bb9453021aa1c", "html_url": "https://github.com/rust-lang/rust/commit/c9772d76198ec04c9e610ce5d95bb9453021aa1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9772d76198ec04c9e610ce5d95bb9453021aa1c/comments", "author": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lqd", "id": 247183, "node_id": "MDQ6VXNlcjI0NzE4Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/247183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lqd", "html_url": "https://github.com/lqd", "followers_url": "https://api.github.com/users/lqd/followers", "following_url": "https://api.github.com/users/lqd/following{/other_user}", "gists_url": "https://api.github.com/users/lqd/gists{/gist_id}", "starred_url": "https://api.github.com/users/lqd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lqd/subscriptions", "organizations_url": "https://api.github.com/users/lqd/orgs", "repos_url": "https://api.github.com/users/lqd/repos", "events_url": "https://api.github.com/users/lqd/events{/privacy}", "received_events_url": "https://api.github.com/users/lqd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18cbc19de2947008651649bd559f44a5db540d18", "url": "https://api.github.com/repos/rust-lang/rust/commits/18cbc19de2947008651649bd559f44a5db540d18", "html_url": "https://github.com/rust-lang/rust/commit/18cbc19de2947008651649bd559f44a5db540d18"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "2655568090c8ecaf64a00dfe8b6d4aeef036b151", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c9772d76198ec04c9e610ce5d95bb9453021aa1c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9772d76198ec04c9e610ce5d95bb9453021aa1c/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=c9772d76198ec04c9e610ce5d95bb9453021aa1c", "patch": "@@ -179,21 +179,25 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                 return Ok(false);\n             }\n \n-            // Now, check whether this alloc contains reference types (as relocations).\n-\n-            // FIXME(lqd): checking the size and alignment could be expensive here, only do the\n-            // following for the potentially bigger aggregates like arrays and slices.\n-            let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n-                // We do the walk if we can't determine the size of the mplace: we may be dealing\n-                // with extern types here in the future.\n-                return Ok(true);\n-            };\n+            // Now, check whether this allocation contains reference types (as relocations).\n+            //\n+            // Note, this check may sometimes not be cheap, so we only do it when the walk we'd like\n+            // to avoid could be expensive: on the potentially larger types, arrays and slices,\n+            // rather than on all aggregates unconditionally.\n+            if matches!(mplace.layout.ty.kind(), ty::Array(..) | ty::Slice(..)) {\n+                let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n+                    // We do the walk if we can't determine the size of the mplace: we may be\n+                    // dealing with extern types here in the future.\n+                    return Ok(true);\n+                };\n \n-            // If there are no refs or relocations in this allocation, we can avoid the interning\n-            // walk.\n-            if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)?\n-                && !alloc.has_relocations() {\n-                return Ok(false);\n+                // If there are no refs or relocations in this allocation, we can avoid the\n+                // interning walk.\n+                if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? {\n+                    if !alloc.has_relocations() {\n+                        return Ok(false);\n+                    }\n+                }\n             }\n \n             // In the general case, we do the walk."}]}