{"sha": "93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNDk5YjFlYWY3NGE1OGZmN2RlM2FjOTI0MGFmYzQ3OTZlZjU3Yzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-13T23:44:05Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T01:29:13Z"}, "message": "libtest: Remove all uses of `~str` from `libtest`.", "tree": {"sha": "835d9bb3d3ad7e937ca7eaa60475f78f40894f11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/835d9bb3d3ad7e937ca7eaa60475f78f40894f11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "html_url": "https://github.com/rust-lang/rust/commit/93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1440e0983916312009590947aeb07d80ea348f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1440e0983916312009590947aeb07d80ea348f7b", "html_url": "https://github.com/rust-lang/rust/commit/1440e0983916312009590947aeb07d80ea348f7b"}], "stats": {"total": 237, "additions": 138, "deletions": 99}, "files": [{"sha": "32bd66c2004311bd673749c07f297bd2ae63dc1e", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -152,7 +152,8 @@ pub fn parse_config(args: Vec<~str> ) -> Config {\n             \"(none)\" != opt_str2(matches.opt_str(\"adb-test-dir\")) &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")),\n+        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")\n+                                           .map(|x| x.to_strbuf())),\n         verbose: matches.opt_present(\"verbose\")\n     }\n }\n@@ -235,7 +236,10 @@ pub fn run_tests(config: &Config) {\n \n pub fn test_opts(config: &Config) -> test::TestOpts {\n     test::TestOpts {\n-        filter: config.filter.clone(),\n+        filter: match config.filter {\n+            None => None,\n+            Some(ref filter) => Some(filter.to_strbuf()),\n+        },\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.clone(),\n         run_tests: true,\n@@ -314,7 +318,9 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n         format!(\"{}/{}\", dir.unwrap_or(\"\"), filename.unwrap_or(\"\"))\n     }\n \n-    test::DynTestName(format!(\"[{}] {}\", config.mode, shorten(testfile)))\n+    test::DynTestName(format_strbuf!(\"[{}] {}\",\n+                                     config.mode,\n+                                     shorten(testfile)))\n }\n \n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {"}, {"sha": "0d532d7cec13c41cdf6976faa56e67c82c879da0", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -327,7 +327,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::Item {\n         pub fn main() {\n             #![main]\n             use std::slice::Vector;\n-            test::test_main_static(::std::os::args().as_slice(), TESTS);\n+            test::test_main_static_x(::std::os::args().as_slice(), TESTS);\n         }\n     )).unwrap();\n "}, {"sha": "e43e7d69a2d006df146e66594032773f7fa95452", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -176,10 +176,6 @@ pub fn test(input: &str, libs: HashSet<Path>, mut test_args: Vec<StrBuf>) -> int\n     let mut collector = Collector::new(input.to_strbuf(), libs, true, true);\n     find_testable_code(input_str.as_slice(), &mut collector);\n     test_args.unshift(\"rustdoctest\".to_strbuf());\n-    testing::test_main(test_args.move_iter()\n-                                .map(|x| x.to_str())\n-                                .collect::<Vec<_>>()\n-                                .as_slice(),\n-                       collector.tests);\n+    testing::test_main(test_args.as_slice(), collector.tests);\n     0\n }"}, {"sha": "9e63848b90eab0d9d2f821e630229e1654513402", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -92,10 +92,7 @@ pub fn run(input: &str,\n \n     test_args.unshift(\"rustdoctest\".to_strbuf());\n \n-    testing::test_main(test_args.move_iter()\n-                                .map(|x| x.to_str())\n-                                .collect::<Vec<_>>()\n-                                .as_slice(),\n+    testing::test_main(test_args.as_slice(),\n                        collector.tests.move_iter().collect());\n     0\n }\n@@ -235,9 +232,9 @@ impl Collector {\n     pub fn add_test(&mut self, test: StrBuf, should_fail: bool, no_run: bool, should_ignore: bool) {\n         let name = if self.use_headers {\n             let s = self.current_header.as_ref().map(|s| s.as_slice()).unwrap_or(\"\");\n-            format!(\"{}_{}\", s, self.cnt)\n+            format_strbuf!(\"{}_{}\", s, self.cnt)\n         } else {\n-            format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n+            format_strbuf!(\"{}_{}\", self.names.connect(\"::\"), self.cnt)\n         };\n         self.cnt += 1;\n         let libs = self.libs.clone();"}, {"sha": "ba8b8f776d97cbdc8bd35346953523683dc0c4ea", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 116, "deletions": 79, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -70,7 +70,7 @@ pub mod test {\n              MetricChange, Improvement, Regression, LikelyNoise,\n              StaticTestFn, StaticTestName, DynTestName, DynTestFn,\n              run_test, test_main, test_main_static, filter_tests,\n-             parse_opts, StaticBenchFn};\n+             parse_opts, StaticBenchFn, test_main_static_x};\n }\n \n pub mod stats;\n@@ -83,7 +83,7 @@ pub mod stats;\n #[deriving(Clone)]\n pub enum TestName {\n     StaticTestName(&'static str),\n-    DynTestName(~str)\n+    DynTestName(StrBuf)\n }\n impl fmt::Show for TestName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -98,20 +98,20 @@ impl fmt::Show for TestName {\n enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n \n impl TestDesc {\n-    fn padded_name(&self, column_count: uint, align: NamePadding) -> ~str {\n+    fn padded_name(&self, column_count: uint, align: NamePadding) -> StrBuf {\n         use std::num::Saturating;\n         let mut name = StrBuf::from_str(self.name.to_str());\n         let fill = column_count.saturating_sub(name.len());\n         let mut pad = StrBuf::from_owned_str(\" \".repeat(fill));\n         match align {\n-            PadNone => name.into_owned(),\n+            PadNone => name,\n             PadOnLeft => {\n                 pad.push_str(name.as_slice());\n-                pad.into_owned()\n+                pad\n             }\n             PadOnRight => {\n                 name.push_str(pad.as_slice());\n-                name.into_owned()\n+                name\n             }\n         }\n     }\n@@ -187,7 +187,7 @@ impl Metric {\n }\n \n #[deriving(Eq)]\n-pub struct MetricMap(TreeMap<~str,Metric>);\n+pub struct MetricMap(TreeMap<StrBuf,Metric>);\n \n impl Clone for MetricMap {\n     fn clone(&self) -> MetricMap {\n@@ -206,11 +206,11 @@ pub enum MetricChange {\n     Regression(f64)\n }\n \n-pub type MetricDiff = TreeMap<~str,MetricChange>;\n+pub type MetricDiff = TreeMap<StrBuf,MetricChange>;\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs.\n-pub fn test_main(args: &[~str], tests: Vec<TestDescAndFn> ) {\n+pub fn test_main(args: &[StrBuf], tests: Vec<TestDescAndFn> ) {\n     let opts =\n         match parse_opts(args) {\n             Some(Ok(o)) => o,\n@@ -231,7 +231,7 @@ pub fn test_main(args: &[~str], tests: Vec<TestDescAndFn> ) {\n // a ~[TestDescAndFn] is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a ~[]\n // rather than a &[].\n-pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n+pub fn test_main_static(args: &[StrBuf], tests: &[TestDescAndFn]) {\n     let owned_tests = tests.iter().map(|t| {\n         match t.testfn {\n             StaticTestFn(f) =>\n@@ -248,8 +248,16 @@ pub fn test_main_static(args: &[~str], tests: &[TestDescAndFn]) {\n     test_main(args, owned_tests)\n }\n \n+pub fn test_main_static_x(args: &[~str], tests: &[TestDescAndFn]) {\n+    test_main_static(args.iter()\n+                         .map(|x| x.to_strbuf())\n+                         .collect::<Vec<_>>()\n+                         .as_slice(),\n+                     tests)\n+}\n+\n pub struct TestOpts {\n-    pub filter: Option<~str>,\n+    pub filter: Option<StrBuf>,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n     pub run_benchmarks: bool,\n@@ -280,7 +288,7 @@ impl TestOpts {\n }\n \n /// Result of parsing the options.\n-pub type OptRes = Result<TestOpts, ~str>;\n+pub type OptRes = Result<TestOpts, StrBuf>;\n \n fn optgroups() -> Vec<getopts::OptGroup> {\n     vec!(getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n@@ -337,20 +345,30 @@ Test Attributes:\n }\n \n // Parses command line arguments into test options\n-pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n+pub fn parse_opts(args: &[StrBuf]) -> Option<OptRes> {\n     let args_ = args.tail();\n     let matches =\n-        match getopts::getopts(args_, optgroups().as_slice()) {\n+        match getopts::getopts(args_.iter()\n+                                    .map(|x| x.to_owned())\n+                                    .collect::<Vec<_>>()\n+                                    .as_slice(),\n+                               optgroups().as_slice()) {\n           Ok(m) => m,\n-          Err(f) => return Some(Err(f.to_err_msg()))\n+          Err(f) => return Some(Err(f.to_err_msg().to_strbuf()))\n         };\n \n-    if matches.opt_present(\"h\") { usage(args[0], \"h\"); return None; }\n-    if matches.opt_present(\"help\") { usage(args[0], \"help\"); return None; }\n+    if matches.opt_present(\"h\") {\n+        usage(args[0].as_slice(), \"h\");\n+        return None;\n+    }\n+    if matches.opt_present(\"help\") {\n+        usage(args[0].as_slice(), \"help\");\n+        return None;\n+    }\n \n     let filter =\n         if matches.free.len() > 0 {\n-            Some((*matches.free.get(0)).clone())\n+            Some((*matches.free.get(0)).to_strbuf())\n         } else {\n             None\n         };\n@@ -374,7 +392,7 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     let save_metrics = save_metrics.map(|s| Path::new(s));\n \n     let test_shard = matches.opt_str(\"test-shard\");\n-    let test_shard = opt_shard(test_shard);\n+    let test_shard = opt_shard(test_shard.map(|x| x.to_strbuf()));\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n     if !nocapture {\n@@ -397,11 +415,11 @@ pub fn parse_opts(args: &[~str]) -> Option<OptRes> {\n     Some(Ok(test_opts))\n }\n \n-pub fn opt_shard(maybestr: Option<~str>) -> Option<(uint,uint)> {\n+pub fn opt_shard(maybestr: Option<StrBuf>) -> Option<(uint,uint)> {\n     match maybestr {\n         None => None,\n         Some(s) => {\n-            let mut it = s.split('.');\n+            let mut it = s.as_slice().split('.');\n             match (it.next().and_then(from_str), it.next().and_then(from_str), it.next()) {\n                 (Some(a), Some(b), None) => Some((a, b)),\n                 _ => None,\n@@ -567,9 +585,9 @@ impl<T: Writer> ConsoleTestState<T> {\n             None => Ok(()),\n             Some(ref mut o) => {\n                 let s = format!(\"{} {}\\n\", match *result {\n-                        TrOk => \"ok\".to_owned(),\n-                        TrFailed => \"failed\".to_owned(),\n-                        TrIgnored => \"ignored\".to_owned(),\n+                        TrOk => \"ok\".to_strbuf(),\n+                        TrFailed => \"failed\".to_strbuf(),\n+                        TrIgnored => \"ignored\".to_strbuf(),\n                         TrMetrics(ref mm) => fmt_metrics(mm),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.to_str());\n@@ -696,25 +714,25 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n }\n \n-pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n+pub fn fmt_metrics(mm: &MetricMap) -> StrBuf {\n     let MetricMap(ref mm) = *mm;\n-    let v : Vec<~str> = mm.iter()\n-        .map(|(k,v)| format!(\"{}: {} (+/- {})\",\n+    let v : Vec<StrBuf> = mm.iter()\n+        .map(|(k,v)| format_strbuf!(\"{}: {} (+/- {})\",\n                           *k,\n                           v.value as f64,\n                           v.noise as f64))\n         .collect();\n-    v.connect(\", \")\n+    v.connect(\", \").to_strbuf()\n }\n \n-pub fn fmt_bench_samples(bs: &BenchSamples) -> ~str {\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> StrBuf {\n     if bs.mb_s != 0 {\n-        format!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n+        format_strbuf!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n              bs.mb_s)\n     } else {\n-        format!(\"{:>9} ns/iter (+/- {})\",\n+        format_strbuf!(\"{:>9} ns/iter (+/- {})\",\n              bs.ns_iter_summ.median as uint,\n              (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n     }\n@@ -738,8 +756,10 @@ pub fn run_tests_console(opts: &TestOpts,\n                         let tname = test.name.to_str();\n                         let MetricMap(mm) = mm;\n                         for (k,v) in mm.iter() {\n-                            st.metrics.insert_metric(tname + \".\" + *k,\n-                                                     v.value, v.noise);\n+                            st.metrics\n+                              .insert_metric(tname + \".\" + k.as_slice(),\n+                                             v.value,\n+                                             v.noise);\n                         }\n                         st.measured += 1\n                     }\n@@ -924,7 +944,7 @@ pub fn filter_tests(\n     } else {\n         let filter_str = match opts.filter {\n           Some(ref f) => (*f).clone(),\n-          None => \"\".to_owned()\n+          None => \"\".to_strbuf()\n         };\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n@@ -936,7 +956,9 @@ pub fn filter_tests(\n             }\n         }\n \n-        filtered.move_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n+        filtered.move_iter()\n+                .filter_map(|x| filter_fn(x, filter_str.as_slice()))\n+                .collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -995,8 +1017,8 @@ pub fn run_test(opts: &TestOpts,\n             let stdout = ChanWriter::new(tx.clone());\n             let stderr = ChanWriter::new(tx);\n             let mut task = TaskBuilder::new().named(match desc.name {\n-                DynTestName(ref name) => name.clone().into_maybe_owned(),\n-                StaticTestName(name) => name.into_maybe_owned(),\n+                DynTestName(ref name) => name.clone().to_owned(),\n+                StaticTestName(name) => name.to_owned(),\n             });\n             if nocapture {\n                 drop((stdout, stderr));\n@@ -1091,7 +1113,14 @@ impl MetricMap {\n     pub fn save(&self, p: &Path) -> io::IoResult<()> {\n         let mut file = try!(File::create(p));\n         let MetricMap(ref map) = *self;\n-        map.to_json().to_pretty_writer(&mut file)\n+\n+        // FIXME(pcwalton): Yuck.\n+        let mut new_map = TreeMap::new();\n+        for (ref key, ref value) in map.iter() {\n+            new_map.insert(key.to_owned(), (*value).clone());\n+        }\n+\n+        new_map.to_json().to_pretty_writer(&mut file)\n     }\n \n     /// Compare against another MetricMap. Optionally compare all\n@@ -1170,7 +1199,7 @@ impl MetricMap {\n             noise: noise\n         };\n         let MetricMap(ref mut map) = *self;\n-        map.insert(name.to_owned(), m);\n+        map.insert(name.to_strbuf(), m);\n     }\n \n     /// Attempt to \"ratchet\" an external metric file. This involves loading\n@@ -1416,17 +1445,19 @@ mod tests {\n \n     #[test]\n     fn first_free_arg_should_be_a_filter() {\n-        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned());\n+        let args = vec!(\"progname\".to_strbuf(), \"filter\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in first_free_arg_should_be_a_filter\")\n         };\n-        assert!(\"filter\" == opts.filter.clone().unwrap());\n+        assert!(\"filter\" == opts.filter.clone().unwrap().as_slice());\n     }\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec!(\"progname\".to_owned(), \"filter\".to_owned(), \"--ignored\".to_owned());\n+        let args = vec!(\"progname\".to_strbuf(),\n+                        \"filter\".to_strbuf(),\n+                        \"--ignored\".to_strbuf());\n         let opts = match parse_opts(args.as_slice()) {\n             Some(Ok(o)) => o,\n             _ => fail!(\"Malformed arg in parse_ignored_flag\")\n@@ -1463,7 +1494,8 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered.get(0).desc.name.to_str(), \"1\".to_owned());\n+        assert_eq!(filtered.get(0).desc.name.to_str().to_strbuf(),\n+                   \"1\".to_strbuf());\n         assert!(filtered.get(0).desc.ignore == false);\n     }\n \n@@ -1473,12 +1505,15 @@ mod tests {\n         opts.run_tests = true;\n \n         let names =\n-            vec!(\"sha1::test\".to_owned(), \"int::test_to_str\".to_owned(), \"int::test_pow\".to_owned(),\n-             \"test::do_not_run_ignored_tests\".to_owned(),\n-             \"test::ignored_tests_result_in_ignored\".to_owned(),\n-             \"test::first_free_arg_should_be_a_filter\".to_owned(),\n-             \"test::parse_ignored_flag\".to_owned(), \"test::filter_for_ignored_option\".to_owned(),\n-             \"test::sort_tests\".to_owned());\n+            vec!(\"sha1::test\".to_strbuf(),\n+                 \"int::test_to_str\".to_strbuf(),\n+                 \"int::test_pow\".to_strbuf(),\n+                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n+                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n+                 \"test::parse_ignored_flag\".to_strbuf(),\n+                 \"test::filter_for_ignored_option\".to_strbuf(),\n+                 \"test::sort_tests\".to_strbuf());\n         let tests =\n         {\n             fn testfn() { }\n@@ -1499,16 +1534,18 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            vec!(\"int::test_pow\".to_owned(), \"int::test_to_str\".to_owned(), \"sha1::test\".to_owned(),\n-              \"test::do_not_run_ignored_tests\".to_owned(),\n-              \"test::filter_for_ignored_option\".to_owned(),\n-              \"test::first_free_arg_should_be_a_filter\".to_owned(),\n-              \"test::ignored_tests_result_in_ignored\".to_owned(),\n-              \"test::parse_ignored_flag\".to_owned(),\n-              \"test::sort_tests\".to_owned());\n+            vec!(\"int::test_pow\".to_strbuf(),\n+                 \"int::test_to_str\".to_strbuf(),\n+                 \"sha1::test\".to_strbuf(),\n+                 \"test::do_not_run_ignored_tests\".to_strbuf(),\n+                 \"test::filter_for_ignored_option\".to_strbuf(),\n+                 \"test::first_free_arg_should_be_a_filter\".to_strbuf(),\n+                 \"test::ignored_tests_result_in_ignored\".to_strbuf(),\n+                 \"test::parse_ignored_flag\".to_strbuf(),\n+                 \"test::sort_tests\".to_strbuf());\n \n         for (a, b) in expected.iter().zip(filtered.iter()) {\n-            assert!(*a == b.desc.name.to_str());\n+            assert!(*a == b.desc.name.to_str().to_strbuf());\n         }\n     }\n \n@@ -1536,31 +1573,31 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&\"in-both-noise\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-first-noise\".to_owned()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&\"in-second-noise\".to_owned()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-noise\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"in-first-noise\".to_strbuf()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.find(&\"in-second-noise\".to_strbuf()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_owned()).unwrap()),\n+        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_strbuf()).unwrap()),\n                    LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n@@ -1585,29 +1622,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&\"runtime\".to_owned()).unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.find(&\"runtime\".to_strbuf()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&\"runtime\".to_owned()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"throughput\".to_owned()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"runtime\".to_strbuf()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.find(&\"throughput\".to_strbuf()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&\"runtime\".to_owned()).unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&\"throughput\".to_owned()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.find(&\"runtime\".to_strbuf()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.find(&\"throughput\".to_strbuf()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "bf40a2d601fcca67d75aaeeead94ffc270b0ef2e", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93499b1eaf74a58ff7de3ac9240afc4796ef57c8/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "patch": "@@ -1028,17 +1028,20 @@ mod tests {\n     #[test]\n     fn test_boxplot_nonpositive() {\n         #[allow(deprecated_owned_vector)]\n-        fn t(s: &Summary<f64>, expected: ~str) {\n+        fn t(s: &Summary<f64>, expected: StrBuf) {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n+            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_strbuf();\n             assert_eq!(out, expected);\n         }\n \n-        t(&Summary::new([-2.0, -1.0]), \"-2 |[------******#*****---]| -1\".to_owned());\n-        t(&Summary::new([0.0, 2.0]), \"0 |[-------*****#*******---]| 2\".to_owned());\n-        t(&Summary::new([-2.0, 0.0]), \"-2 |[------******#******---]| 0\".to_owned());\n+        t(&Summary::new([-2.0, -1.0]),\n+                        \"-2 |[------******#*****---]| -1\".to_strbuf());\n+        t(&Summary::new([0.0, 2.0]),\n+                        \"0 |[-------*****#*******---]| 2\".to_strbuf());\n+        t(&Summary::new([-2.0, 0.0]),\n+                        \"-2 |[------******#******---]| 0\".to_strbuf());\n \n     }\n     #[test]"}]}