{"sha": "3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZDZjYTA1MWNlNWQyZjcxODJkZjY4ZWVjY2ViZmIwYjgzMDUyNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-02T09:44:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-02T09:44:03Z"}, "message": "Auto merge of #6716 - magurotuna:refactor-transmute-mod, r=flip1995\n\nRefactor: arrange transmute lints\n\nThis PR arranges `transmute` lints so that they can be accessed more easily.\nBasically, I followed the instruction described in #6680 as to how to do the refactoring.\n\n- `declare_clippy_lint!` and `impl LintPass` is placed in `transmute/mod.rs`\n- Uitlity functions is placed in `transmute/utils.rs`\n- Each lint function about `transmute` is moved into its own module, like `transmute/useless_transmute.rs`\n\nFor ease of review, I refactored step by step, keeping each commit small. For instance, all I did in\n2451781 was to move  `useless_transmute` into its own module.\n\n---\n\nchangelog: Refactor `transmute.rs` file into `transmute` module.", "tree": {"sha": "deb4a97a65f39e1fe8f59947b6d156eb35eb03db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deb4a97a65f39e1fe8f59947b6d156eb35eb03db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "html_url": "https://github.com/rust-lang/rust/commit/3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e50afa43d0ed32fad86514e2cfcc72d20d38448a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e50afa43d0ed32fad86514e2cfcc72d20d38448a", "html_url": "https://github.com/rust-lang/rust/commit/e50afa43d0ed32fad86514e2cfcc72d20d38448a"}, {"sha": "bf000985f50af1e506709ea5d735a35fac13925c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf000985f50af1e506709ea5d735a35fac13925c", "html_url": "https://github.com/rust-lang/rust/commit/bf000985f50af1e506709ea5d735a35fac13925c"}], "stats": {"total": 1825, "additions": 1062, "deletions": 763}, "files": [{"sha": "dc938ed02383dc0513ddbd2ab87a2171723c5cdc", "filename": "clippy_lints/src/transmute.rs", "status": "removed", "additions": 0, "deletions": 763, "changes": 763, "blob_url": "https://github.com/rust-lang/rust/blob/e50afa43d0ed32fad86514e2cfcc72d20d38448a/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50afa43d0ed32fad86514e2cfcc72d20d38448a/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=e50afa43d0ed32fad86514e2cfcc72d20d38448a", "patch": "@@ -1,763 +0,0 @@\n-use crate::utils::{\n-    in_constant, is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, sugg,\n-};\n-use if_chain::if_chain;\n-use rustc_ast as ast;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Mutability, QPath, TyKind, UnOp};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, cast::CastKind, Ty};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::DUMMY_SP;\n-use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n-use std::borrow::Cow;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes that can't ever be correct on any\n-    /// architecture.\n-    ///\n-    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n-    ///\n-    /// **Known problems:** When accessing C, users might want to store pointer\n-    /// sized objects in `extradata` arguments to save an allocation.\n-    ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// let ptr: *const T = core::intrinsics::transmute('x')\n-    /// ```\n-    pub WRONG_TRANSMUTE,\n-    correctness,\n-    \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n-}\n-\n-// FIXME: Move this to `complexity` again, after #5343 is fixed\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes to the original type of the object\n-    /// and transmutes that could be a cast.\n-    ///\n-    /// **Why is this bad?** Readability. The code tricks people into thinking that\n-    /// something complex is going on.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n-    /// ```\n-    pub USELESS_TRANSMUTE,\n-    nursery,\n-    \"transmutes that have the same to and from types or could be a cast/coercion\"\n-}\n-\n-// FIXME: Merge this lint with USELESS_TRANSMUTE once that is out of the nursery.\n-declare_clippy_lint! {\n-    /// **What it does:**Checks for transmutes that could be a pointer cast.\n-    ///\n-    /// **Why is this bad?** Readability. The code tricks people into thinking that\n-    /// something complex is going on.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// # let p: *const [i32] = &[];\n-    /// unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// # let p: *const [i32] = &[];\n-    /// p as *const [u16];\n-    /// ```\n-    pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-    complexity,\n-    \"transmutes that could be a pointer cast\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n-    ///\n-    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n-    /// pointer to that type.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// core::intrinsics::transmute(t) // where the result type is the same as\n-    ///                                // `*t` or `&t`'s\n-    /// ```\n-    pub CROSSPOINTER_TRANSMUTE,\n-    complexity,\n-    \"transmutes that have to or from types that are a pointer to the other\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a pointer to a reference.\n-    ///\n-    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n-    ///\n-    /// **Known problems:**\n-    /// - `mem::transmute` in statics and constants is stable from Rust 1.46.0,\n-    /// while dereferencing raw pointer is not stable yet.\n-    /// If you need to do this in those places,\n-    /// you would have to use `transmute` instead.\n-    ///\n-    /// **Example:**\n-    /// ```rust,ignore\n-    /// unsafe {\n-    ///     let _: &T = std::mem::transmute(p); // where p: *const T\n-    /// }\n-    ///\n-    /// // can be written:\n-    /// let _: &T = &*p;\n-    /// ```\n-    pub TRANSMUTE_PTR_TO_REF,\n-    complexity,\n-    \"transmutes from a pointer to a reference type\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a `char`.\n-    ///\n-    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n-    ///\n-    /// **Known problems:**\n-    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n-    /// as it needs to validate the input.\n-    /// If you are certain that the input is always a valid Unicode scalar value,\n-    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n-    /// but has a semantically meaningful name.\n-    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n-    ///\n-    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n-    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = 1_u32;\n-    /// unsafe {\n-    ///     let _: char = std::mem::transmute(x); // where x: u32\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _ = std::char::from_u32(x).unwrap();\n-    /// ```\n-    pub TRANSMUTE_INT_TO_CHAR,\n-    complexity,\n-    \"transmutes from an integer to a `char`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n-    ///\n-    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n-    ///\n-    /// **Known problems:**\n-    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n-    /// as it needs to validate the input.\n-    /// If you are certain that the input is always a valid UTF-8,\n-    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n-    /// but has a semantically meaningful name.\n-    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n-    ///\n-    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n-    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let b: &[u8] = &[1_u8, 2_u8];\n-    /// unsafe {\n-    ///     let _: &str = std::mem::transmute(b); // where b: &[u8]\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _ = std::str::from_utf8(b).unwrap();\n-    /// ```\n-    pub TRANSMUTE_BYTES_TO_STR,\n-    complexity,\n-    \"transmutes from a `&[u8]` to a `&str`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n-    ///\n-    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let x = 1_u8;\n-    /// unsafe {\n-    ///     let _: bool = std::mem::transmute(x); // where x: u8\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: bool = x != 0;\n-    /// ```\n-    pub TRANSMUTE_INT_TO_BOOL,\n-    complexity,\n-    \"transmutes from an integer to a `bool`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from an integer to a float.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n-    /// and safe.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// unsafe {\n-    ///     let _: f32 = std::mem::transmute(1_u32); // where x: u32\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: f32 = f32::from_bits(1_u32);\n-    /// ```\n-    pub TRANSMUTE_INT_TO_FLOAT,\n-    complexity,\n-    \"transmutes from an integer to a float\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a float to an integer.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `to_bits` is intuitive\n-    /// and safe.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// unsafe {\n-    ///     let _: u32 = std::mem::transmute(1f32);\n-    /// }\n-    ///\n-    /// // should be:\n-    /// let _: u32 = 1f32.to_bits();\n-    /// ```\n-    pub TRANSMUTE_FLOAT_TO_INT,\n-    complexity,\n-    \"transmutes from a float to an integer\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n-    /// from a reference to a reference.\n-    ///\n-    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n-    /// written as casts.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let ptr = &1u32 as *const u32;\n-    /// unsafe {\n-    ///     // pointer-to-pointer transmute\n-    ///     let _: *const f32 = std::mem::transmute(ptr);\n-    ///     // ref-ref transmute\n-    ///     let _: &f32 = std::mem::transmute(&1u32);\n-    /// }\n-    /// // These can be respectively written:\n-    /// let _ = ptr as *const f32;\n-    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n-    /// ```\n-    pub TRANSMUTE_PTR_TO_PTR,\n-    complexity,\n-    \"transmutes from a pointer to a pointer / a reference to a reference\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for transmutes between collections whose\n-    /// types have different ABI, size or alignment.\n-    ///\n-    /// **Why is this bad?** This is undefined behavior.\n-    ///\n-    /// **Known problems:** Currently, we cannot know whether a type is a\n-    /// collection, so we just lint the ones that come with `std`.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // different size, therefore likely out-of-bounds memory access\n-    /// // You absolutely do not want this in your code!\n-    /// unsafe {\n-    ///     std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n-    /// };\n-    /// ```\n-    ///\n-    /// You must always iterate, map and collect the values:\n-    ///\n-    /// ```rust\n-    /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n-    /// ```\n-    pub UNSOUND_COLLECTION_TRANSMUTE,\n-    correctness,\n-    \"transmute between collections of layout-incompatible types\"\n-}\n-\n-declare_lint_pass!(Transmute => [\n-    CROSSPOINTER_TRANSMUTE,\n-    TRANSMUTE_PTR_TO_REF,\n-    TRANSMUTE_PTR_TO_PTR,\n-    USELESS_TRANSMUTE,\n-    WRONG_TRANSMUTE,\n-    TRANSMUTE_INT_TO_CHAR,\n-    TRANSMUTE_BYTES_TO_STR,\n-    TRANSMUTE_INT_TO_BOOL,\n-    TRANSMUTE_INT_TO_FLOAT,\n-    TRANSMUTE_FLOAT_TO_INT,\n-    UNSOUND_COLLECTION_TRANSMUTE,\n-    TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-]);\n-\n-// used to check for UNSOUND_COLLECTION_TRANSMUTE\n-static COLLECTIONS: &[&[&str]] = &[\n-    &paths::VEC,\n-    &paths::VEC_DEQUE,\n-    &paths::BINARY_HEAP,\n-    &paths::BTREESET,\n-    &paths::BTREEMAP,\n-    &paths::HASHSET,\n-    &paths::HASHMAP,\n-];\n-impl<'tcx> LateLintPass<'tcx> for Transmute {\n-    #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n-            if let ExprKind::Path(ref qpath) = path_expr.kind;\n-            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n-            if match_def_path(cx, def_id, &paths::TRANSMUTE);\n-            then {\n-                // Avoid suggesting from/to bits and dereferencing raw pointers in const contexts.\n-                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n-                // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n-                let const_context = in_constant(cx, e.hir_id);\n-\n-                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n-                let to_ty = cx.typeck_results().expr_ty(e);\n-\n-                match (&from_ty.kind(), &to_ty.kind()) {\n-                    _ if from_ty == to_ty => span_lint(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                    ),\n-                    (ty::Ref(_, rty, rty_mutbl), ty::RawPtr(ptr_ty)) => span_lint_and_then(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        \"transmute from a reference to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let rty_and_mut = ty::TypeAndMut {\n-                                    ty: rty,\n-                                    mutbl: *rty_mutbl,\n-                                };\n-\n-                                let sugg = if *ptr_ty == rty_and_mut {\n-                                    arg.as_ty(to_ty)\n-                                } else {\n-                                    arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n-                                };\n-\n-                                diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                            }\n-                        },\n-                    ),\n-                    (ty::Int(_) | ty::Uint(_), ty::RawPtr(_)) => span_lint_and_then(\n-                        cx,\n-                        USELESS_TRANSMUTE,\n-                        e.span,\n-                        \"transmute from an integer to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"try\",\n-                                    arg.as_ty(&to_ty.to_string()).to_string(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            }\n-                        },\n-                    ),\n-                    (ty::Float(_) | ty::Char, ty::Ref(..) | ty::RawPtr(_)) => span_lint(\n-                        cx,\n-                        WRONG_TRANSMUTE,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                    ),\n-                    (ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                        cx,\n-                        CROSSPOINTER_TRANSMUTE,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                    ),\n-                    (_, ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                        cx,\n-                        CROSSPOINTER_TRANSMUTE,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                    ),\n-                    (ty::RawPtr(from_pty), ty::Ref(_, to_ref_ty, mutbl)) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_PTR_TO_REF,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from a pointer type (`{}`) to a reference type \\\n-                             (`{}`)\",\n-                            from_ty, to_ty\n-                        ),\n-                        |diag| {\n-                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let (deref, cast) = if *mutbl == Mutability::Mut {\n-                                (\"&mut *\", \"*mut\")\n-                            } else {\n-                                (\"&*\", \"*const\")\n-                            };\n-\n-                            let arg = if from_pty.ty == *to_ref_ty {\n-                                arg\n-                            } else {\n-                                arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n-                            };\n-\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"try\",\n-                                sugg::make_unop(deref, arg).to_string(),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n-                        span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_INT_TO_CHAR,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a `char`\", from_ty),\n-                            |diag| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let arg = if let ty::Int(_) = from_ty.kind() {\n-                                    arg.as_ty(ast::UintTy::U32.name_str())\n-                                } else {\n-                                    arg\n-                                };\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"consider using\",\n-                                    format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n-                                    Applicability::Unspecified,\n-                                );\n-                            },\n-                        )\n-                    },\n-                    (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n-                        if_chain! {\n-                            if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n-                            if let ty::Uint(ty::UintTy::U8) = slice_ty.kind();\n-                            if from_mutbl == to_mutbl;\n-                            then {\n-                                let postfix = if *from_mutbl == Mutability::Mut {\n-                                    \"_mut\"\n-                                } else {\n-                                    \"\"\n-                                };\n-\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    TRANSMUTE_BYTES_TO_STR,\n-                                    e.span,\n-                                    &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                                    \"consider using\",\n-                                    format!(\n-                                        \"std::str::from_utf8{}({}).unwrap()\",\n-                                        postfix,\n-                                        snippet(cx, args[0].span, \"..\"),\n-                                    ),\n-                                    Applicability::Unspecified,\n-                                );\n-                            } else {\n-                                if (cx.tcx.erase_regions(from_ty) != cx.tcx.erase_regions(to_ty))\n-                                    && !const_context {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        TRANSMUTE_PTR_TO_PTR,\n-                                        e.span,\n-                                        \"transmute from a reference to a reference\",\n-                                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                            let ty_from_and_mut = ty::TypeAndMut {\n-                                                ty: ty_from,\n-                                                mutbl: *from_mutbl\n-                                            };\n-                                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n-                                            let sugg_paren = arg\n-                                                .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n-                                                .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n-                                            let sugg = if *to_mutbl == Mutability::Mut {\n-                                                sugg_paren.mut_addr_deref()\n-                                            } else {\n-                                                sugg_paren.addr_deref()\n-                                            };\n-                                            diag.span_suggestion(\n-                                                e.span,\n-                                                \"try\",\n-                                                sugg.to_string(),\n-                                                Applicability::Unspecified,\n-                                            );\n-                                        },\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    },\n-                    (ty::RawPtr(_), ty::RawPtr(to_ty)) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_PTR_TO_PTR,\n-                        e.span,\n-                        \"transmute from a pointer to a pointer\",\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n-                                diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n-                            }\n-                        },\n-                    ),\n-                    (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n-                        span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_INT_TO_BOOL,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n-                            |diag| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n-                                diag.span_suggestion(\n-                                    e.span,\n-                                    \"consider using\",\n-                                    sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n-                                    Applicability::Unspecified,\n-                                );\n-                            },\n-                        )\n-                    },\n-                    (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_INT_TO_FLOAT,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                        |diag| {\n-                            let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                            let arg = if let ty::Int(int_ty) = from_ty.kind() {\n-                                arg.as_ty(format!(\n-                                    \"u{}\",\n-                                    int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n-                                ))\n-                            } else {\n-                                arg\n-                            };\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"consider using\",\n-                                format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_FLOAT_TO_INT,\n-                        e.span,\n-                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n-                        |diag| {\n-                            let mut expr = &args[0];\n-                            let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n-\n-                            if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                                expr = &inner_expr;\n-                            }\n-\n-                            if_chain! {\n-                                // if the expression is a float literal and it is unsuffixed then\n-                                // add a suffix so the suggestion is valid and unambiguous\n-                                let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n-                                if let ExprKind::Lit(lit) = &expr.kind;\n-                                if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n-                                then {\n-                                    match arg {\n-                                        sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n-                                        _ => arg = sugg::Sugg::NonParen(op)\n-                                    }\n-                                }\n-                            }\n-\n-                            arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n-\n-                            // cast the result of `to_bits` if `to_ty` is signed\n-                            arg = if let ty::Int(int_ty) = to_ty.kind() {\n-                                arg.as_ty(int_ty.name_str().to_string())\n-                            } else {\n-                                arg\n-                            };\n-\n-                            diag.span_suggestion(\n-                                e.span,\n-                                \"consider using\",\n-                                arg.to_string(),\n-                                Applicability::Unspecified,\n-                            );\n-                        },\n-                    ),\n-                    (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n-                        if from_adt.did != to_adt.did ||\n-                                !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n-                            return;\n-                        }\n-                        if from_substs.types().zip(to_substs.types())\n-                                              .any(|(from_ty, to_ty)| is_layout_incompatible(cx, from_ty, to_ty)) {\n-                            span_lint(\n-                                cx,\n-                                UNSOUND_COLLECTION_TRANSMUTE,\n-                                e.span,\n-                                &format!(\n-                                    \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n-                                    from_ty,\n-                                    to_ty\n-                                )\n-                            );\n-                        }\n-                    },\n-                    (_, _) if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) => span_lint_and_then(\n-                        cx,\n-                        TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n-                            from_ty,\n-                            to_ty\n-                        ),\n-                        |diag| {\n-                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n-                                diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n-                            }\n-                        }\n-                    ),\n-                    _ => {\n-                        return;\n-                    },\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n-/// not available , use\n-/// the type's `ToString` implementation. In weird cases it could lead to types\n-/// with invalid `'_`\n-/// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n-    let seg = last_path_segment(path);\n-    if_chain! {\n-        if let Some(ref params) = seg.args;\n-        if !params.parenthesized;\n-        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).nth(1);\n-        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n-        then {\n-            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n-        }\n-    }\n-\n-    to_ref_ty.to_string()\n-}\n-\n-// check if the component types of the transmuted collection and the result have different ABI,\n-// size or alignment\n-fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n-    let empty_param_env = ty::ParamEnv::empty();\n-    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n-    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n-        return false;\n-    }\n-    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n-    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n-    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n-        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n-    } else {\n-        // no idea about layout, so don't lint\n-        false\n-    }\n-}\n-\n-/// Check if the type conversion can be expressed as a pointer cast, instead of\n-/// a transmute. In certain cases, including some invalid casts from array\n-/// references to pointers, this may cause additional errors to be emitted and/or\n-/// ICE error messages. This function will panic if that occurs.\n-fn can_be_expressed_as_pointer_cast<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    from_ty: Ty<'tcx>,\n-    to_ty: Ty<'tcx>,\n-) -> bool {\n-    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n-    matches!(\n-        check_cast(cx, e, from_ty, to_ty),\n-        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n-    )\n-}\n-\n-/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n-/// the cast. In certain cases, including some invalid casts from array references\n-/// to pointers, this may cause additional errors to be emitted and/or ICE error\n-/// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n-    let hir_id = e.hir_id;\n-    let local_def_id = hir_id.owner;\n-\n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n-\n-        // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(\n-            !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n-        );\n-\n-        if let Ok(check) = CastCheck::new(\n-            &fn_ctxt, e, from_ty, to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP, DUMMY_SP,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returing Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n-}"}, {"sha": "ce87defaa940622b1978111b9a8f35d7197e6288", "filename": "clippy_lints/src/transmute/crosspointer_transmute.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fcrosspointer_transmute.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,37 @@\n+use super::CROSSPOINTER_TRANSMUTE;\n+use crate::utils::span_lint;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `crosspointer_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+            span_lint(\n+                cx,\n+                CROSSPOINTER_TRANSMUTE,\n+                e.span,\n+                &format!(\n+                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+            );\n+            true\n+        },\n+        (_, ty::RawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+            span_lint(\n+                cx,\n+                CROSSPOINTER_TRANSMUTE,\n+                e.span,\n+                &format!(\n+                    \"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "c1870f5208b4502071501f30f50d604c0bf46b92", "filename": "clippy_lints/src/transmute/mod.rs", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,363 @@\n+mod crosspointer_transmute;\n+mod transmute_float_to_int;\n+mod transmute_int_to_bool;\n+mod transmute_int_to_char;\n+mod transmute_int_to_float;\n+mod transmute_ptr_to_ptr;\n+mod transmute_ptr_to_ref;\n+mod transmute_ref_to_ref;\n+mod transmutes_expressible_as_ptr_casts;\n+mod unsound_collection_transmute;\n+mod useless_transmute;\n+mod utils;\n+mod wrong_transmute;\n+\n+use crate::utils::{in_constant, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes that can't ever be correct on any\n+    /// architecture.\n+    ///\n+    /// **Why is this bad?** It's basically guaranteed to be undefined behaviour.\n+    ///\n+    /// **Known problems:** When accessing C, users might want to store pointer\n+    /// sized objects in `extradata` arguments to save an allocation.\n+    ///\n+    /// **Example:**\n+    /// ```ignore\n+    /// let ptr: *const T = core::intrinsics::transmute('x')\n+    /// ```\n+    pub WRONG_TRANSMUTE,\n+    correctness,\n+    \"transmutes that are confusing at best, undefined behaviour at worst and always useless\"\n+}\n+\n+// FIXME: Move this to `complexity` again, after #5343 is fixed\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes to the original type of the object\n+    /// and transmutes that could be a cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// core::intrinsics::transmute(t); // where the result type is the same as `t`'s\n+    /// ```\n+    pub USELESS_TRANSMUTE,\n+    nursery,\n+    \"transmutes that have the same to and from types or could be a cast/coercion\"\n+}\n+\n+// FIXME: Merge this lint with USELESS_TRANSMUTE once that is out of the nursery.\n+declare_clippy_lint! {\n+    /// **What it does:**Checks for transmutes that could be a pointer cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let p: *const [i32] = &[];\n+    /// unsafe { std::mem::transmute::<*const [i32], *const [u16]>(p) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let p: *const [i32] = &[];\n+    /// p as *const [u16];\n+    /// ```\n+    pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    complexity,\n+    \"transmutes that could be a pointer cast\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n+    ///\n+    /// **Why is this bad?** It's easy to mistakenly transmute between a type and a\n+    /// pointer to that type.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// core::intrinsics::transmute(t) // where the result type is the same as\n+    ///                                // `*t` or `&t`'s\n+    /// ```\n+    pub CROSSPOINTER_TRANSMUTE,\n+    complexity,\n+    \"transmutes that have to or from types that are a pointer to the other\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a reference.\n+    ///\n+    /// **Why is this bad?** This can always be rewritten with `&` and `*`.\n+    ///\n+    /// **Known problems:**\n+    /// - `mem::transmute` in statics and constants is stable from Rust 1.46.0,\n+    /// while dereferencing raw pointer is not stable yet.\n+    /// If you need to do this in those places,\n+    /// you would have to use `transmute` instead.\n+    ///\n+    /// **Example:**\n+    /// ```rust,ignore\n+    /// unsafe {\n+    ///     let _: &T = std::mem::transmute(p); // where p: *const T\n+    /// }\n+    ///\n+    /// // can be written:\n+    /// let _: &T = &*p;\n+    /// ```\n+    pub TRANSMUTE_PTR_TO_REF,\n+    complexity,\n+    \"transmutes from a pointer to a reference type\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `char`.\n+    ///\n+    /// **Why is this bad?** Not every integer is a Unicode scalar value.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_u32`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid Unicode scalar value,\n+    /// use [`from_u32_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle `None` returned from [`from_u32`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_u32`]: https://doc.rust-lang.org/std/char/fn.from_u32.html\n+    /// [`from_u32_unchecked`]: https://doc.rust-lang.org/std/char/fn.from_u32_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1_u32;\n+    /// unsafe {\n+    ///     let _: char = std::mem::transmute(x); // where x: u32\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _ = std::char::from_u32(x).unwrap();\n+    /// ```\n+    pub TRANSMUTE_INT_TO_CHAR,\n+    complexity,\n+    \"transmutes from an integer to a `char`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a `&[u8]` to a `&str`.\n+    ///\n+    /// **Why is this bad?** Not every byte slice is a valid UTF-8 string.\n+    ///\n+    /// **Known problems:**\n+    /// - [`from_utf8`] which this lint suggests using is slower than `transmute`\n+    /// as it needs to validate the input.\n+    /// If you are certain that the input is always a valid UTF-8,\n+    /// use [`from_utf8_unchecked`] which is as fast as `transmute`\n+    /// but has a semantically meaningful name.\n+    /// - You might want to handle errors returned from [`from_utf8`] instead of calling `unwrap`.\n+    ///\n+    /// [`from_utf8`]: https://doc.rust-lang.org/std/str/fn.from_utf8.html\n+    /// [`from_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked.html\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let b: &[u8] = &[1_u8, 2_u8];\n+    /// unsafe {\n+    ///     let _: &str = std::mem::transmute(b); // where b: &[u8]\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _ = std::str::from_utf8(b).unwrap();\n+    /// ```\n+    pub TRANSMUTE_BYTES_TO_STR,\n+    complexity,\n+    \"transmutes from a `&[u8]` to a `&str`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a `bool`.\n+    ///\n+    /// **Why is this bad?** This might result in an invalid in-memory representation of a `bool`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = 1_u8;\n+    /// unsafe {\n+    ///     let _: bool = std::mem::transmute(x); // where x: u8\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: bool = x != 0;\n+    /// ```\n+    pub TRANSMUTE_INT_TO_BOOL,\n+    complexity,\n+    \"transmutes from an integer to a `bool`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from an integer to a float.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `from_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// unsafe {\n+    ///     let _: f32 = std::mem::transmute(1_u32); // where x: u32\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: f32 = f32::from_bits(1_u32);\n+    /// ```\n+    pub TRANSMUTE_INT_TO_FLOAT,\n+    complexity,\n+    \"transmutes from an integer to a float\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a float to an integer.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous and error-prone, whereas `to_bits` is intuitive\n+    /// and safe.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// unsafe {\n+    ///     let _: u32 = std::mem::transmute(1f32);\n+    /// }\n+    ///\n+    /// // should be:\n+    /// let _: u32 = 1f32.to_bits();\n+    /// ```\n+    pub TRANSMUTE_FLOAT_TO_INT,\n+    complexity,\n+    \"transmutes from a float to an integer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes from a pointer to a pointer, or\n+    /// from a reference to a reference.\n+    ///\n+    /// **Why is this bad?** Transmutes are dangerous, and these can instead be\n+    /// written as casts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let ptr = &1u32 as *const u32;\n+    /// unsafe {\n+    ///     // pointer-to-pointer transmute\n+    ///     let _: *const f32 = std::mem::transmute(ptr);\n+    ///     // ref-ref transmute\n+    ///     let _: &f32 = std::mem::transmute(&1u32);\n+    /// }\n+    /// // These can be respectively written:\n+    /// let _ = ptr as *const f32;\n+    /// let _ = unsafe{ &*(&1u32 as *const u32 as *const f32) };\n+    /// ```\n+    pub TRANSMUTE_PTR_TO_PTR,\n+    complexity,\n+    \"transmutes from a pointer to a pointer / a reference to a reference\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for transmutes between collections whose\n+    /// types have different ABI, size or alignment.\n+    ///\n+    /// **Why is this bad?** This is undefined behavior.\n+    ///\n+    /// **Known problems:** Currently, we cannot know whether a type is a\n+    /// collection, so we just lint the ones that come with `std`.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // different size, therefore likely out-of-bounds memory access\n+    /// // You absolutely do not want this in your code!\n+    /// unsafe {\n+    ///     std::mem::transmute::<_, Vec<u32>>(vec![2_u16])\n+    /// };\n+    /// ```\n+    ///\n+    /// You must always iterate, map and collect the values:\n+    ///\n+    /// ```rust\n+    /// vec![2_u16].into_iter().map(u32::from).collect::<Vec<_>>();\n+    /// ```\n+    pub UNSOUND_COLLECTION_TRANSMUTE,\n+    correctness,\n+    \"transmute between collections of layout-incompatible types\"\n+}\n+\n+declare_lint_pass!(Transmute => [\n+    CROSSPOINTER_TRANSMUTE,\n+    TRANSMUTE_PTR_TO_REF,\n+    TRANSMUTE_PTR_TO_PTR,\n+    USELESS_TRANSMUTE,\n+    WRONG_TRANSMUTE,\n+    TRANSMUTE_INT_TO_CHAR,\n+    TRANSMUTE_BYTES_TO_STR,\n+    TRANSMUTE_INT_TO_BOOL,\n+    TRANSMUTE_INT_TO_FLOAT,\n+    TRANSMUTE_FLOAT_TO_INT,\n+    UNSOUND_COLLECTION_TRANSMUTE,\n+    TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Transmute {\n+    #[allow(clippy::similar_names, clippy::too_many_lines)]\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n+            if let ExprKind::Path(ref qpath) = path_expr.kind;\n+            if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n+            if match_def_path(cx, def_id, &paths::TRANSMUTE);\n+            then {\n+                // Avoid suggesting from/to bits and dereferencing raw pointers in const contexts.\n+                // See https://github.com/rust-lang/rust/issues/73736 for progress on making them `const fn`.\n+                // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n+                let const_context = in_constant(cx, e.hir_id);\n+\n+                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let to_ty = cx.typeck_results().expr_ty(e);\n+\n+                // If useless_transmute is triggered, the other lints can be skipped.\n+                if useless_transmute::check(cx, e, from_ty, to_ty, args) {\n+                    return;\n+                }\n+\n+                let mut linted = wrong_transmute::check(cx, e, from_ty, to_ty);\n+                linted |= crosspointer_transmute::check(cx, e, from_ty, to_ty);\n+                linted |= transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, args, qpath);\n+                linted |= transmute_int_to_char::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_ref_to_ref::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_int_to_bool::check(cx, e, from_ty, to_ty, args);\n+                linted |= transmute_int_to_float::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= transmute_float_to_int::check(cx, e, from_ty, to_ty, args, const_context);\n+                linted |= unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n+\n+                if !linted {\n+                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, args);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "562d880e39afbffefa4cc996a9bdf0793fc2c61a", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,65 @@\n+use super::TRANSMUTE_FLOAT_TO_INT;\n+use crate::utils::{span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_float_to_int` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Float(float_ty), ty::Int(_) | ty::Uint(_)) if !const_context => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_FLOAT_TO_INT,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                |diag| {\n+                    let mut expr = &args[0];\n+                    let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n+\n+                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n+                        expr = &inner_expr;\n+                    }\n+\n+                    if_chain! {\n+                        // if the expression is a float literal and it is unsuffixed then\n+                        // add a suffix so the suggestion is valid and unambiguous\n+                        let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n+                        if let ExprKind::Lit(lit) = &expr.kind;\n+                        if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n+                        then {\n+                            match arg {\n+                                sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n+                                _ => arg = sugg::Sugg::NonParen(op)\n+                            }\n+                        }\n+                    }\n+\n+                    arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n+\n+                    // cast the result of `to_bits` if `to_ty` is signed\n+                    arg = if let ty::Int(int_ty) = to_ty.kind() {\n+                        arg.as_ty(int_ty.name_str().to_string())\n+                    } else {\n+                        arg\n+                    };\n+\n+                    diag.span_suggestion(e.span, \"consider using\", arg.to_string(), Applicability::Unspecified);\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "5b609f906a3d7d9070ac98e7c55166318b222947", "filename": "clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,41 @@\n+use super::TRANSMUTE_INT_TO_BOOL;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+use std::borrow::Cow;\n+\n+/// Checks for `transmute_int_to_bool` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_INT_TO_BOOL,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using\",\n+                        sugg::make_binop(ast::BinOpKind::Ne, &arg, &zero).to_string(),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "48473e0d799dac25a8d7bfa33fa2e38465c87963", "filename": "clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,46 @@\n+use super::TRANSMUTE_INT_TO_CHAR;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_int_to_char` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n+            {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_INT_TO_CHAR,\n+                    e.span,\n+                    &format!(\"transmute from a `{}` to a `char`\", from_ty),\n+                    |diag| {\n+                        let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                        let arg = if let ty::Int(_) = from_ty.kind() {\n+                            arg.as_ty(ast::UintTy::U32.name_str())\n+                        } else {\n+                            arg\n+                        };\n+                        diag.span_suggestion(\n+                            e.span,\n+                            \"consider using\",\n+                            format!(\"std::char::from_u32({}).unwrap()\", arg.to_string()),\n+                            Applicability::Unspecified,\n+                        );\n+                    },\n+                )\n+            };\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "f83fba8966a11ac1399300c57c5207e4ac48a64f", "filename": "clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,47 @@\n+use super::TRANSMUTE_INT_TO_FLOAT;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_int_to_float` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Int(_) | ty::Uint(_), ty::Float(_)) if !const_context => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_INT_TO_FLOAT,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = if let ty::Int(int_ty) = from_ty.kind() {\n+                        arg.as_ty(format!(\n+                            \"u{}\",\n+                            int_ty.bit_width().map_or_else(|| \"size\".to_string(), |v| v.to_string())\n+                        ))\n+                    } else {\n+                        arg\n+                    };\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"consider using\",\n+                        format!(\"{}::from_bits({})\", to_ty, arg.to_string()),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "f4e60a3020cf58367976647d181e7333012bbfdb", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ptr.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,35 @@\n+use super::TRANSMUTE_PTR_TO_PTR;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_ptr_to_ptr` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(_), ty::RawPtr(to_ty)) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_PTR_TO_PTR,\n+                e.span,\n+                \"transmute from a pointer to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n+                        diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "a6719b68098a5f1645d648d36caa9bdbd5b5f8d4", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,55 @@\n+use super::utils::get_type_snippet;\n+use super::TRANSMUTE_PTR_TO_REF;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_ptr_to_ref` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    qpath: &'tcx QPath<'_>,\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::RawPtr(from_pty), ty::Ref(_, to_ref_ty, mutbl)) => {\n+            span_lint_and_then(\n+                cx,\n+                TRANSMUTE_PTR_TO_REF,\n+                e.span,\n+                &format!(\n+                    \"transmute from a pointer type (`{}`) to a reference type (`{}`)\",\n+                    from_ty, to_ty\n+                ),\n+                |diag| {\n+                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let (deref, cast) = if *mutbl == Mutability::Mut {\n+                        (\"&mut *\", \"*mut\")\n+                    } else {\n+                        (\"&*\", \"*const\")\n+                    };\n+\n+                    let arg = if from_pty.ty == *to_ref_ty {\n+                        arg\n+                    } else {\n+                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                    };\n+\n+                    diag.span_suggestion(\n+                        e.span,\n+                        \"try\",\n+                        sugg::make_unop(deref, arg).to_string(),\n+                        Applicability::Unspecified,\n+                    );\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "ccfcb03e87ac3f559aa9a1078bab4d5cfdc5b6d2", "filename": "clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,88 @@\n+use super::{TRANSMUTE_BYTES_TO_STR, TRANSMUTE_PTR_TO_PTR};\n+use crate::utils::{snippet, span_lint_and_sugg, span_lint_and_then, sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, Mutability};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `transmute_bytes_to_str` and `transmute_ptr_to_ptr` lints.\n+/// Returns `true` if either one triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+    const_context: bool,\n+) -> bool {\n+    let mut triggered = false;\n+\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Ref(_, ty_from, from_mutbl), ty::Ref(_, ty_to, to_mutbl)) => {\n+            if_chain! {\n+                if let (&ty::Slice(slice_ty), &ty::Str) = (&ty_from.kind(), &ty_to.kind());\n+                if let ty::Uint(ty::UintTy::U8) = slice_ty.kind();\n+                if from_mutbl == to_mutbl;\n+                then {\n+                    let postfix = if *from_mutbl == Mutability::Mut {\n+                        \"_mut\"\n+                    } else {\n+                        \"\"\n+                    };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        TRANSMUTE_BYTES_TO_STR,\n+                        e.span,\n+                        &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n+                        \"consider using\",\n+                        format!(\n+                            \"std::str::from_utf8{}({}).unwrap()\",\n+                            postfix,\n+                            snippet(cx, args[0].span, \"..\"),\n+                        ),\n+                        Applicability::Unspecified,\n+                    );\n+                    triggered = true;\n+                } else {\n+                    if (cx.tcx.erase_regions(from_ty) != cx.tcx.erase_regions(to_ty))\n+                        && !const_context {\n+                        span_lint_and_then(\n+                            cx,\n+                            TRANSMUTE_PTR_TO_PTR,\n+                            e.span,\n+                            \"transmute from a reference to a reference\",\n+                            |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                let ty_from_and_mut = ty::TypeAndMut {\n+                                    ty: ty_from,\n+                                    mutbl: *from_mutbl\n+                                };\n+                                let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n+                                let sugg_paren = arg\n+                                    .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n+                                    .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));\n+                                let sugg = if *to_mutbl == Mutability::Mut {\n+                                    sugg_paren.mut_addr_deref()\n+                                } else {\n+                                    sugg_paren.addr_deref()\n+                                };\n+                                diag.span_suggestion(\n+                                    e.span,\n+                                    \"try\",\n+                                    sugg.to_string(),\n+                                    Applicability::Unspecified,\n+                                );\n+                            },\n+                        );\n+\n+                        triggered = true;\n+                    }\n+                }\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    triggered\n+}"}, {"sha": "dea896622f11c5727efb8e9d7f83959832a9adb0", "filename": "clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,38 @@\n+use super::utils::can_be_expressed_as_pointer_cast;\n+use super::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS;\n+use crate::utils::{span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+/// Checks for `transmutes_expressible_as_ptr_casts` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) {\n+        span_lint_and_then(\n+            cx,\n+            TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+            e.span,\n+            &format!(\n+                \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n+                from_ty, to_ty\n+            ),\n+            |diag| {\n+                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n+                    diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n+                }\n+            },\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "503c5e0ff3822c19a0a723716eb290b18f20c203", "filename": "clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,48 @@\n+use super::utils::is_layout_incompatible;\n+use super::UNSOUND_COLLECTION_TRANSMUTE;\n+use crate::utils::{match_def_path, paths, span_lint};\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+// used to check for UNSOUND_COLLECTION_TRANSMUTE\n+static COLLECTIONS: &[&[&str]] = &[\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+    &paths::BINARY_HEAP,\n+    &paths::BTREESET,\n+    &paths::BTREEMAP,\n+    &paths::HASHSET,\n+    &paths::HASHMAP,\n+];\n+\n+/// Checks for `unsound_collection_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n+            if from_adt.did != to_adt.did || !COLLECTIONS.iter().any(|path| match_def_path(cx, to_adt.did, path)) {\n+                return false;\n+            }\n+            if from_substs\n+                .types()\n+                .zip(to_substs.types())\n+                .any(|(from_ty, to_ty)| is_layout_incompatible(cx, from_ty, to_ty))\n+            {\n+                span_lint(\n+                    cx,\n+                    UNSOUND_COLLECTION_TRANSMUTE,\n+                    e.span,\n+                    &format!(\n+                        \"transmute from `{}` to `{}` with mismatched layout is unsound\",\n+                        from_ty, to_ty\n+                    ),\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "83441514af0511fa529ec9fdca8a83de00ec6588", "filename": "clippy_lints/src/transmute/useless_transmute.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,73 @@\n+use super::USELESS_TRANSMUTE;\n+use crate::utils::{span_lint, span_lint_and_then, sugg};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `useless_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    args: &'tcx [Expr<'_>],\n+) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        _ if from_ty == to_ty => {\n+            span_lint(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+            );\n+            true\n+        },\n+        (ty::Ref(_, rty, rty_mutbl), ty::RawPtr(ptr_ty)) => {\n+            span_lint_and_then(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                \"transmute from a reference to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        let rty_and_mut = ty::TypeAndMut {\n+                            ty: rty,\n+                            mutbl: *rty_mutbl,\n+                        };\n+\n+                        let sugg = if *ptr_ty == rty_and_mut {\n+                            arg.as_ty(to_ty)\n+                        } else {\n+                            arg.as_ty(cx.tcx.mk_ptr(rty_and_mut)).as_ty(to_ty)\n+                        };\n+\n+                        diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        (ty::Int(_) | ty::Uint(_), ty::RawPtr(_)) => {\n+            span_lint_and_then(\n+                cx,\n+                USELESS_TRANSMUTE,\n+                e.span,\n+                \"transmute from an integer to a pointer\",\n+                |diag| {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        diag.span_suggestion(\n+                            e.span,\n+                            \"try\",\n+                            arg.as_ty(&to_ty.to_string()).to_string(),\n+                            Applicability::Unspecified,\n+                        );\n+                    }\n+                },\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "55008d8ec3f16e8ab587766037c419bd3e103d2a", "filename": "clippy_lints/src/transmute/utils.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,104 @@\n+use crate::utils::{is_normalizable, last_path_segment, snippet};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, cast::CastKind, Ty};\n+use rustc_span::DUMMY_SP;\n+use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n+\n+/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// not available , use\n+/// the type's `ToString` implementation. In weird cases it could lead to types\n+/// with invalid `'_`\n+/// lifetime, but it should be rare.\n+pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n+    let seg = last_path_segment(path);\n+    if_chain! {\n+        if let Some(ref params) = seg.args;\n+        if !params.parenthesized;\n+        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).nth(1);\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n+        then {\n+            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n+        }\n+    }\n+\n+    to_ref_ty.to_string()\n+}\n+\n+// check if the component types of the transmuted collection and the result have different ABI,\n+// size or alignment\n+pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+    let empty_param_env = ty::ParamEnv::empty();\n+    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n+    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n+        return false;\n+    }\n+    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n+    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n+    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n+        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n+    } else {\n+        // no idea about layout, so don't lint\n+        false\n+    }\n+}\n+\n+/// Check if the type conversion can be expressed as a pointer cast, instead of\n+/// a transmute. In certain cases, including some invalid casts from array\n+/// references to pointers, this may cause additional errors to be emitted and/or\n+/// ICE error messages. This function will panic if that occurs.\n+pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> bool {\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n+    matches!(\n+        check_cast(cx, e, from_ty, to_ty),\n+        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n+    )\n+}\n+\n+/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n+/// the cast. In certain cases, including some invalid casts from array references\n+/// to pointers, this may cause additional errors to be emitted and/or ICE error\n+/// messages. This function will panic if that occurs.\n+fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n+    let hir_id = e.hir_id;\n+    let local_def_id = hir_id.owner;\n+\n+    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n+\n+        // If we already have errors, we can't be sure we can pointer cast.\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n+\n+        if let Ok(check) = CastCheck::new(\n+            &fn_ctxt, e, from_ty, to_ty,\n+            // We won't show any error to the user, so we don't care what the span is here.\n+            DUMMY_SP, DUMMY_SP,\n+        ) {\n+            let res = check.do_check(&fn_ctxt);\n+\n+            // do_check's documentation says that it might return Ok and create\n+            // errors in the fcx instead of returing Err in some cases. Those cases\n+            // should be filtered out before getting here.\n+            assert!(\n+                !fn_ctxt.errors_reported_since_creation(),\n+                \"`fn_ctxt` contained errors after cast check!\"\n+            );\n+\n+            res.ok()\n+        } else {\n+            None\n+        }\n+    })\n+}"}, {"sha": "d6d77f2c834569ebec9b106b23047b8b4e5e0249", "filename": "clippy_lints/src/transmute/wrong_transmute.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cd6ca051ce5d2f7182df68eeccebfb0b830525c/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fwrong_transmute.rs?ref=3cd6ca051ce5d2f7182df68eeccebfb0b830525c", "patch": "@@ -0,0 +1,22 @@\n+use super::WRONG_TRANSMUTE;\n+use crate::utils::span_lint;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+/// Checks for `wrong_transmute` lint.\n+/// Returns `true` if it's triggered, otherwise returns `false`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n+    match (&from_ty.kind(), &to_ty.kind()) {\n+        (ty::Float(_) | ty::Char, ty::Ref(..) | ty::RawPtr(_)) => {\n+            span_lint(\n+                cx,\n+                WRONG_TRANSMUTE,\n+                e.span,\n+                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n+            );\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}]}