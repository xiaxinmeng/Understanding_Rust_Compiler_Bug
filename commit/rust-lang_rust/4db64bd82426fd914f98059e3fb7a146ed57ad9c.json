{"sha": "4db64bd82426fd914f98059e3fb7a146ed57ad9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYjY0YmQ4MjQyNmZkOTE0Zjk4MDU5ZTNmYjdhMTQ2ZWQ1N2FkOWM=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:09:58Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-22T23:09:58Z"}, "message": "Rollup merge of #21217 - Gankro:docadoca, r=steveklabnik\n\nNot sure on what *exactly* should be said here, but I think this is the most important bit. This PR also establishes conventions for describing performance minimally.\r\n\r\nI suggest to describe preformance for individual methods we use a `# Performance` heading. Not sure if we should have \r\n\r\n```\r\n# Performance: O(1)\r\ndetails details\r\n```\r\nor\r\n\r\n```\r\n# Performance:\r\nO(1)\r\ndetails details\r\n```\r\n\r\nSince I think most methods don't need discussion, the former seems more resonable. But it's kind of weird to have info \"in\" the heading.\r\n\r\nr? @steveklabnik", "tree": {"sha": "ad1ef659671f2f6385cf3bf5c0d49480e927cf1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad1ef659671f2f6385cf3bf5c0d49480e927cf1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4db64bd82426fd914f98059e3fb7a146ed57ad9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4db64bd82426fd914f98059e3fb7a146ed57ad9c", "html_url": "https://github.com/rust-lang/rust/commit/4db64bd82426fd914f98059e3fb7a146ed57ad9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4db64bd82426fd914f98059e3fb7a146ed57ad9c/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c76ce8c36cf39ee8036401a95c583dda8f0f38d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c76ce8c36cf39ee8036401a95c583dda8f0f38d6", "html_url": "https://github.com/rust-lang/rust/commit/c76ce8c36cf39ee8036401a95c583dda8f0f38d6"}, {"sha": "3819c222a84a9c21992b81939420643c0a969e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3819c222a84a9c21992b81939420643c0a969e7d", "html_url": "https://github.com/rust-lang/rust/commit/3819c222a84a9c21992b81939420643c0a969e7d"}], "stats": {"total": 54, "additions": 52, "deletions": 2}, "files": [{"sha": "21bea5dcdcb82f334066b85eed23d4134029f1c4", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4db64bd82426fd914f98059e3fb7a146ed57ad9c/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db64bd82426fd914f98059e3fb7a146ed57ad9c/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=4db64bd82426fd914f98059e3fb7a146ed57ad9c", "patch": "@@ -49,8 +49,8 @@\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `DList` when:\n-//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate inconsistent\n-//! performance during insertions.\n+//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate amortization.\n+//! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n //!\n //! ### Use a `HashMap` when:\n@@ -85,6 +85,56 @@\n //! or \"most important\" one at any given time.\n //! * You want a priority queue.\n //!\n+//! # Performance\n+//!\n+//! Choosing the right collection for the job requires an understanding of what each collection\n+//! is good at. Here we briefly summarize the performance of different collections for certain\n+//! important operations. For further details, see each type's documentation.\n+//!\n+//! Throughout the documentation, we will follow a few conventions. For all operations,\n+//! the collection's size is denoted by n. If another collection is involved in the operation, it\n+//! contains m elements. Operations which have an *amortized* cost are suffixed with a `*`.\n+//! Operations with an *expected* cost are suffixed with a `~`.\n+//!\n+//! All amortized costs are for the potential need to resize when capacity is exhausted.\n+//! If a resize occurs it will take O(n) time. Our collections never automatically shrink,\n+//! so removal operations aren't amortized. Over a sufficiently large series of\n+//! operations, the average cost per operation will deterministically equal the given cost.\n+//!\n+//! Only HashMap has expected costs, due to the probabilistic nature of hashing. It is\n+//! theoretically possible, though very unlikely, for HashMap to experience worse performance.\n+//!\n+//! ## Sequences\n+//!\n+//! |         | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |---------|----------------|-----------------|----------------|--------|----------------|\n+//! | Vec     | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | RingBuf | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | DList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! | Bitv    | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//!\n+//! Note that where ties occur, Vec is generally going to be faster than RingBuf, and RingBuf\n+//! is generally going to be faster than DList. Bitv is not a general purpose collection, and\n+//! therefore cannot reasonably be compared.\n+//!\n+//! ## Maps\n+//!\n+//! For Sets, all operations have the cost of the equivalent Map operation. For BitvSet,\n+//! refer to VecMap.\n+//!\n+//! |          | get       | insert   | remove   | predecessor |\n+//! |----------|-----------|----------|----------|-------------|\n+//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         |\n+//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    |\n+//! | VecMap   | O(1)      | O(1)?    | O(1)     | O(n)        |\n+//!\n+//! Note that VecMap is *incredibly* inefficient in terms of space. The O(1) insertion time\n+//! assumes space for the element is already allocated. Otherwise, a large key may require a\n+//! massive reallocation, with no direct relation to the number of elements in the collection.\n+//! VecMap should only be seriously considered for small keys.\n+//!\n+//! Note also that BTreeMap's precise preformance depends on the value of B.\n+//!\n //! # Correct and Efficient Usage of Collections\n //!\n //! Of course, knowing which collection is the right one for the job doesn't instantly"}]}