{"sha": "f03518bfad10481f5df900f7e15bab368f1fec04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMzUxOGJmYWQxMDQ4MWY1ZGY5MDBmN2UxNWJhYjM2OGYxZmVjMDQ=", "commit": {"author": {"name": "bobtwinkles", "email": "srkoser+GitHub@gmail.com", "date": "2018-05-10T09:48:53Z"}, "committer": {"name": "bobtwinkles", "email": "srkoser+github@gmail.com", "date": "2018-05-15T03:49:02Z"}, "message": "Framework and rough implementation for invalidates facts\n\nthis probably doesn't compile and definitely doesn't work", "tree": {"sha": "e2f57319132f654235ecb1a5b454d9a90a3ed99d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2f57319132f654235ecb1a5b454d9a90a3ed99d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f03518bfad10481f5df900f7e15bab368f1fec04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f03518bfad10481f5df900f7e15bab368f1fec04", "html_url": "https://github.com/rust-lang/rust/commit/f03518bfad10481f5df900f7e15bab368f1fec04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f03518bfad10481f5df900f7e15bab368f1fec04/comments", "author": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bobtwinkles", "id": 1514748, "node_id": "MDQ6VXNlcjE1MTQ3NDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1514748?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobtwinkles", "html_url": "https://github.com/bobtwinkles", "followers_url": "https://api.github.com/users/bobtwinkles/followers", "following_url": "https://api.github.com/users/bobtwinkles/following{/other_user}", "gists_url": "https://api.github.com/users/bobtwinkles/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobtwinkles/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobtwinkles/subscriptions", "organizations_url": "https://api.github.com/users/bobtwinkles/orgs", "repos_url": "https://api.github.com/users/bobtwinkles/repos", "events_url": "https://api.github.com/users/bobtwinkles/events{/privacy}", "received_events_url": "https://api.github.com/users/bobtwinkles/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ecbe9b7f71b41422f9c9e45b1d31eefacea31a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ecbe9b7f71b41422f9c9e45b1d31eefacea31a3", "html_url": "https://github.com/rust-lang/rust/commit/6ecbe9b7f71b41422f9c9e45b1d31eefacea31a3"}], "stats": {"total": 851, "additions": 851, "deletions": 0}, "files": [{"sha": "2b2aadba7f92e39db1cfab1487a2da4fe7c5a56a", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=f03518bfad10481f5df900f7e15bab368f1fec04", "patch": "@@ -38,6 +38,9 @@ crate struct AllFacts {\n \n     // `region_live_at(R, P)` when the region R appears in a live variable at P\n     crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n+\n+    // `invalidates(P, B)` when the borrow B is invalidated at point P\n+    crate invalidates: Vec<(LocationIndex, BorrowIndex)>,\n }\n \n impl AllFacts {\n@@ -69,6 +72,7 @@ impl AllFacts {\n                 killed,\n                 outlives,\n                 region_live_at,\n+                invalidates,\n             ])\n         }\n         Ok(())"}, {"sha": "464843ec8af851f60cc922b6a9d8c8f82439b2f2", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "added", "additions": 846, "deletions": 0, "changes": 846, "blob_url": "https://github.com/rust-lang/rust/blob/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=f03518bfad10481f5df900f7e15bab368f1fec04", "patch": "@@ -0,0 +1,846 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use borrow_check::{JustWrite, WriteAndRead};\n+use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n+use borrow_check::{Context, ContextKind};\n+use borrow_check::{LocalMutationIsAllowed, MutateMode};\n+use borrow_check::nll::facts::AllFacts;\n+use rustc::hir;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::visit::TyContext;\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::Place::Projection;\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::{Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n+\n+pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n+    mir: &Mir<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n+) {\n+    if !all_facts.is_some() {\n+        // Nothing to do if we don't have any facts\n+        return;\n+    }\n+\n+    let mut ig = InvalidationGenerator {\n+        all_facts: all_facts.unwrap()\n+        borrow_set,\n+        infcx,\n+        regioncx,\n+        location_table,\n+        mir,\n+    };\n+}\n+\n+/// 'cg = the duration of the constraint generation process itself.\n+struct InvalidationGenerator<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cg mut AllFacts,\n+    location_table: &'cg LocationTable,\n+    regioncx: &'cg mut RegionInferenceContext<'tcx>,\n+    mir: &'cg Mir<'tcx>,\n+    borrow_set: &'cg BorrowSet<'tcx>,\n+}\n+\n+/// Visits the whole MIR and generates invalidates() facts\n+/// Most of the code implementing this was stolen from borrow_check/mod.rs\n+impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for InvalidationGenerator {\n+    fn visit_statement(&mut self, block: BasicBlock, statement: &Statemnt<'tcx>, location: Location) {\n+        match statement.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.consumer_rvalue(\n+                    ContextKind::AssignRhs.new(location),\n+                    (rhs, location),\n+                    locaiton\n+                );\n+\n+                self.mutate_place(\n+                    ContextKind::AssignLhs.new(location),\n+                    (lhs, location),\n+                    Shallow(None),\n+                    JustWrite\n+                );\n+            }\n+            StatementKind::SetDiscriminant {\n+                ref place,\n+                variant_index: _,\n+            } => {\n+                self.mutate_place(\n+                    ContextKind::SetDiscrim.new(location),\n+                    (place, location),\n+                    Shallow(Some(ArtificialField::Discriminant)),\n+                    JustWrite,\n+                );\n+            }\n+            StatementKind::InlineAsm {\n+                ref asm,\n+                ref outputs,\n+                ref inputs,\n+            } => {\n+                let context = ContextKind::InlineAsm.new(location);\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        // FIXME(eddyb) indirect inline asm outputs should\n+                        // be encoeded through MIR place derefs instead.\n+                        self.access_place(\n+                            context,\n+                            (output, location),\n+                            (Deep, Read(ReadKind::Copy)),\n+                            LocalMutationIsAllowed::No,\n+                        );\n+                    } else {\n+                        self.mutate_place(\n+                            context,\n+                            (output, location),\n+                            if o.is_rw { Deep } else { Shallow(None) },\n+                            if o.is_rw { WriteAndRead } else { JustWrite },\n+                        );\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(context, (input, location));\n+                }\n+            }\n+            // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n+            StatementKind::EndRegion(..) |\n+            StatementKind::Nop |\n+            StatementKind::UserAssertTy(..) |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) => {\n+                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // to borrow check.\n+            }\n+            StatementKind::StorageDead(local) => {\n+                self.access_place(\n+                    ContextKind::StorageDead.new(location),\n+                    (&Place::Local(local), location),\n+                    (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n+                    LocalMutationIsAllowed::Yes,\n+                );\n+            }\n+        }\n+\n+        self.super_statment(block, statement, location);\n+    }\n+\n+    fn visit_terminator(\n+        &mut self,\n+        block: BasicBlock,\n+        terminator: &Terminator<'tcx>,\n+        location: Location\n+    ) {\n+        match terminator.kind {\n+            TerminatorKind::SwitchInt {\n+                ref discr,\n+                switch_ty: _,\n+                values: _,\n+                targets: _,\n+            } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(loc,c (discr, location)));\n+            }\n+            TerminatorKind::Drop {\n+                location: ref drop_place,\n+                target: _,\n+                unwind: _,\n+            } => {\n+                let tcx = self.infcx.tcx;\n+                let gcx = tcx.global_tcx();\n+                let drop_place_ty = drop_place.ty(self.mir, tcx);\n+                let drop_place_ty = tcx.erase_regions(&drop_place_ty).to_ty(tcx);\n+                self.visit_terminator_drop(loc, term)\n+            }\n+            TerminatorKind::DropAndReplace {\n+                location: ref drop_place,\n+                value: ref new_value,\n+                target: _,\n+                unwind: _,\n+            } => {\n+                self.mutate_place(\n+                    ContextKind::DropAndReplace.new(loc),\n+                    (drop_place, location),\n+                    Deep,\n+                    JustWrite,\n+                );\n+                self.consume_operand(\n+                    ContextKind::DropAndReplace.new(loc),\n+                    (new_value, location),\n+                );\n+            }\n+            TerminatorKind::Call {\n+                ref func,\n+                ref args,\n+                ref destination,\n+                cleanup: _,\n+            } => {\n+                self.consume_operand(ContextKind::CallOperator.new(loc), (func, location));\n+                for arg in args {\n+                    self.consume_operand(\n+                        ContextKind::CallOperand.new(loc),\n+                        (arg, location),\n+                    );\n+                }\n+                if let Some((ref dest, _ /*bb*/)) = *destination {\n+                    self.mutate_place(\n+                        ContextKind::CallDest.new(loc),\n+                        (dest, location),\n+                        Deep,\n+                        JustWrite,\n+                    );\n+                }\n+            }\n+            TerminatorKind::Assert {\n+                ref cond,\n+                expected: _,\n+                ref msg,\n+                target: _,\n+                cleanup: _,\n+            } => {\n+                self.consume_operand(ContextKind::Assert.new(loc), (cond, location));\n+                use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n+                if let BoundsCheck { ref len, ref index } = *msg {\n+                    self.consume_operand(ContextKind::Assert.new(loc), (len, location));\n+                    self.consume_operand(\n+                        ContextKind::Assert.new(loc),\n+                        (index, location),\n+                    );\n+                }\n+            }\n+            TerminatorKind::Yield {\n+                ref value,\n+                resume: _,\n+                drop: _,\n+            } => {\n+                self.consume_operand(ContextKind::Yield.new(loc), (value, location));\n+\n+                // ** TODO(bob_twinkles) figure out what the equivalent of this is\n+                // if self.movable_generator {\n+                //     // Look for any active borrows to locals\n+                //     let borrow_set = self.borrow_set.clone();\n+                //     flow_state.with_outgoing_borrows(|borrows| {\n+                //         for i in borrows {\n+                //             let borrow = &borrow_set[i];\n+                //             self.check_for_local_borrow(borrow, span);\n+                //         }\n+                //     });\n+                // }\n+            }\n+            TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n+                // ** TODO(bob_twinkles) figure out what the equivalent of this is\n+                // // Returning from the function implicitly kills storage for all locals and statics.\n+                // // Often, the storage will already have been killed by an explicit\n+                // // StorageDead, but we don't always emit those (notably on unwind paths),\n+                // // so this \"extra check\" serves as a kind of backup.\n+                // let borrow_set = self.borrow_set.clone();\n+                // flow_state.with_outgoing_borrows(|borrows| {\n+                //     for i in borrows {\n+                //         let borrow = &borrow_set[i];\n+                //         let context = ContextKind::StorageDead.new(loc);\n+                //         self.check_for_invalidation_at_exit(context, borrow, span);\n+                //     }\n+                // });\n+            }\n+            TerminatorKind::Goto { target: _ }\n+            | TerminatorKind::Abort\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::FalseEdges {\n+                real_target: _,\n+                imaginary_targets: _,\n+            }\n+            | TerminatorKind::FalseUnwind {\n+                real_target: _,\n+                unwind: _,\n+            } => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+\n+        self.super_terminator(block, terminator, location);\n+    }\n+}\n+\n+impl<'cg, 'cx, 'gcx, 'tcx> InvalidationGenerator {\n+    /// Simulates dropping of a variable\n+    fn visit_terminator_drop(\n+        &mut self,\n+        loc: Location,\n+        term: &Terminator<'tcx>,\n+        drop_place: &Place<'tcx>,\n+        erased_drop_place_ty: ty::Ty<'gcx>,\n+        location: Location\n+    ) {\n+        let gcx = self.infcx.tcx.global_tcx();\n+        let drop_field = |\n+        ig: &mut InvalidationGenerator<'cx, 'gcx, 'tcx>,\n+        (index, field): (usize, ty::Ty<'gcx>),\n+        | {\n+            let field_ty = gcx.normalize_erasing_regions(mir.param_env, field);\n+            let place = drop_place.clone().field(Field::new(index), field_ty);\n+\n+            ig.visit_terminator_drop(loc, term, &place, field_ty, location);\n+        };\n+\n+        match erased_drop_place_ty.sty {\n+            // When a struct is being dropped, we need to check\n+            // whether it has a destructor, if it does, then we can\n+            // call it, if it does not then we need to check the\n+            // individual fields instead. This way if `foo` has a\n+            // destructor but `bar` does not, we will only check for\n+            // borrows of `x.foo` and not `x.bar`. See #47703.\n+            ty::TyAdt(def, substs) if def.is_struct() && !def.has_dtor(self.infcx.tcx) => {\n+                def.all_fields()\n+                    .map(|field| field.ty(gcx, substs))\n+                    .enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Same as above, but for tuples.\n+            ty::TyTuple(tys) => {\n+                tys.iter().cloned().enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            // Closures and generators also have disjoint fields, but they are only\n+            // directly accessed in the body of the closure/generator.\n+            ty::TyClosure(def, substs)\n+            | ty::TyGenerator(def, substs, ..)\n+                if *drop_place == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty()\n+            => {\n+                substs.upvar_tys(def, self.infcx.tcx).enumerate()\n+                    .for_each(|field| drop_field(self, field));\n+            }\n+            _ => {\n+                // We have now refined the type of the value being\n+                // dropped (potentially) to just the type of a\n+                // subfield; so check whether that field's type still\n+                // \"needs drop\". If so, we assume that the destructor\n+                // may access any data it likes (i.e., a Deep Write).\n+                if erased_drop_place_ty.needs_drop(gcx, self.param_env) {\n+                    self.access_place(\n+                        ContextKind::Drop.new(loc),\n+                        (drop_place, location),\n+                        (Deep, Write(WriteKind::StorageDeadOrDrop)),\n+                        LocalMutationIsAllowed::Yes,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Simulates mutation of a place\n+    fn mutate_place(\n+        &mut self,\n+        context: Context,\n+        place_location: &(Place<'tcx>, location),\n+        kind: (ShallowOrDeep, ReadOrWrite),\n+        mode: MutateMode,\n+    ) {\n+        self.access_place(\n+            context,\n+            place_location,\n+            (kind, Write(WriteKind::Mutate)),\n+            LocalMutationIsAllowed::ExceptUpvars,\n+        );\n+    }\n+\n+    /// Simulates consumption of an operand\n+    fn consume_operand(\n+        &mut self,\n+        context: Context,\n+        (operand, location): (&Operand<'tcx>, location),\n+    ) {\n+        match *operand {\n+            Operand::Copy(ref place) => {\n+                self.access_place(\n+                    context,\n+                    (place, location),\n+                    (Deep, Read(ReadKind::Copy)),\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+            Operand::Move(ref place) => {\n+                self.access_place(\n+                    context,\n+                    (place, location),\n+                    (Deep, Write(WriteKind::move)),\n+                    LocalMutationIsAllowed::Yes,\n+                );\n+            }\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    // Simulates consumption of an rvalue\n+    fn consume_rvalue(\n+        &mut self,\n+        context: Context,\n+        (rvalue, location): (&Rvalue<'tcx>, Location),\n+        _location: Location,\n+    ) {\n+        match *rvalue {\n+            Rvalue::Ref(_ /*rgn*/, bk, ref place) => {\n+                let access_kind = match bk {\n+                    BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n+                    BorrowKind::Unique | BorrowKind::Mut { .. } => {\n+                        let wk = WriteKind::MutableBorrow(bk);\n+                        if self.allow_two_phase_borrow(bk) {\n+                            (Deep, Reservation(wk))\n+                        } else {\n+                            (Deep, Write(wk))\n+                        }\n+                    }\n+                };\n+\n+                self.access_place(\n+                    context,\n+                    (place, location),\n+                    access_kind,\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n+\n+            Rvalue::Use(ref operand)\n+            | Rvalue::Repeat(ref operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n+                self.consume_operand(context, (operand, location))\n+            }\n+\n+            Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n+                let af = match *rvalue {\n+                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n+                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    _ => unreachable!(),\n+                };\n+                self.access_place(\n+                    context,\n+                    (place, location),\n+                    (Shallow(Some(af)), Read(ReadKind::Copy)),\n+                    LocalMutationIsAllowed::No,\n+                );\n+                self.check_if_path_or_subpath_is_moved(\n+                    context,\n+                    InitializationRequiringAction::Use,\n+                    (place, location),\n+                );\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n+            | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, (operand1, location));\n+                self.consume_operand(context, (operand2, location));\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+            }\n+\n+            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, (operand, location));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Simulates an access to a place\n+    fn access_place(\n+        &mut self,\n+        context: Context,\n+        place_location: (&Place<'tcx>, Location),\n+        kind: (ShallowOrDeep, ReadOrWrite),\n+        is_local_mutation_allowed: LocalMutationIsAllowed,\n+    ) {\n+        let (sd, rw) = kind;\n+        // note: not doing check_access_permissions checks because they don't generate invalidates\n+        self.check_acess_for_conflict(context, place_location, sd, rw);\n+    }\n+\n+    fn check_access_for_conflict(\n+        &mut self,\n+        context: Context,\n+        (place, location): (&Place<'tcx>, Location),\n+        sd: ShallowOrDeep,\n+        rw: ReadOrWrite,\n+    ) {\n+        debug!(\n+            \"invalidation::check_access_for_conflict(context={:?}, place_location={:?}, sd={:?}, \\\n+             rw={:?})\",\n+            context,\n+            (place, location),\n+            sd,\n+            rw,\n+        );\n+        self.each_borrow_involving_path(\n+            context,\n+            (sd, place_location.0),\n+            flow_state,\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n+                // Obviously an activation is compatible with its own\n+                // reservation (or even prior activating uses of same\n+                // borrow); so don't check if they interfere.\n+                //\n+                // NOTE: *reservations* do conflict with themselves;\n+                // thus aren't injecting unsoundenss w/ this check.)\n+                (Activation(_, activating), _) if activating == borrow_index => {\n+                    debug!(\n+                        \"check_access_for_conflict place_location: {:?} sd: {:?} rw: {:?} \\\n+                         skipping {:?} b/c activation of same borrow_index\",\n+                        (place, location),\n+                        sd,\n+                        rw,\n+                        (borrow_index, borrow),\n+                    );\n+                    Control::Continue\n+                }\n+\n+                (Read(_), BorrowKind::Shared) | (Reservation(..), BorrowKind::Shared) => {\n+                    Control::Continue\n+                }\n+\n+                (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n+                    // Reading from mere reservations of mutable-borrows is OK.\n+                    if this.is_active(borrow, context.loc) {\n+                        self.generate_invalidates(borrow_index);\n+                        Control::Break\n+                    } else {\n+                        assert!(this.allow_two_phase_borrow(borrow.kind));\n+                        Control::Continue\n+                    }\n+                }\n+\n+                // ****** XXX: rewrite the rest of this function to use generate_invalidates instead of reporting errors ******\n+                (Reservation(kind), BorrowKind::Unique)\n+                | (Reservation(kind), BorrowKind::Mut { .. })\n+                | (Activation(kind, _), _)\n+                | (Write(kind), _) => {\n+                    match rw {\n+                        Reservation(_) => {\n+                            debug!(\n+                                \"recording invalid reservation of \\\n+                                 place: {:?}\",\n+                                place_span.0\n+                            );\n+                            this.reservation_error_reported.insert(place_span.0.clone());\n+                        }\n+                        Activation(_, activating) => {\n+                            debug!(\n+                                \"observing check_place for activation of \\\n+                                 borrow_index: {:?}\",\n+                                activating\n+                            );\n+                        }\n+                        Read(..) | Write(..) => {}\n+                    }\n+\n+                    match kind {\n+                        WriteKind::MutableBorrow(bk) => {\n+                            error_reported = true;\n+                            this.report_conflicting_borrow(\n+                                context,\n+                                place_span,\n+                                bk,\n+                                &borrow,\n+                            )\n+                        }\n+                        WriteKind::StorageDeadOrDrop => {\n+                            error_reported = true;\n+                            this.report_borrowed_value_does_not_live_long_enough(\n+                                context,\n+                                borrow,\n+                                place_span.1,\n+                            );\n+                        }\n+                        WriteKind::Mutate => {\n+                            error_reported = true;\n+                            this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n+                        }\n+                        WriteKind::Move => {\n+                            error_reported = true;\n+                            this.report_move_out_while_borrowed(context, place_span, &borrow)\n+                        }\n+                    }\n+                    Control::Break\n+                }\n+            },\n+        );\n+    }\n+\n+    /// Returns true if the borrow represented by `kind` is\n+    /// allowed to be split into separate Reservation and\n+    /// Activation phases.\n+    fn allow_two_phase_borrow(&self, kind: BorrowKind) -> bool {\n+        self.infcx.tcx.two_phase_borrows()\n+            && (kind.allows_two_phase_borrow()\n+                || self.infcx.tcx.sess.opts.debugging_opts.two_phase_beyond_autoref)\n+    }\n+\n+    /// Generate a new invalidates(L, B) fact\n+    fn generate_invalidates(&mut self, b: BorrowIndex, l: LocationIndex) {\n+        self.all_facts.invalidates.append((l, b));\n+    }\n+\n+    /// This function iterates over all borrows that intersect with an\n+    /// an access to a place, invoking the `op` callback for each one.\n+    ///\n+    /// \"Current borrow\" here means a borrow that reaches the point in\n+    /// the control-flow where the access occurs.\n+    ///\n+    /// The borrow's phase is represented by the IsActive parameter\n+    /// passed to the callback.\n+    fn each_borrow_involving_path<F>(\n+        &mut self,\n+        _context: Context,\n+        access_place: (ShallowOrDeep, &Place<'tcx>),\n+        mut op: F,\n+    ) where\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n+    {\n+        let (access, place) = access_place;\n+\n+        // FIXME: analogous code in check_loans first maps `place` to\n+        // its base_path.\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        let borrow_set = self.borrow_set.clone();\n+        for i in borrow_set.borrows.iter() {\n+            let borrowed = &borrow_set[i];\n+\n+            if self.places_conflict(&borrowed.borrowed_place, place, access) {\n+                debug!(\n+                    \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n+                    i, borrowed, place, access\n+                );\n+                let ctrl = op(self, i, borrowed);\n+                if ctrl == Control::Break {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Returns whether an access of kind `access` to `access_place` conflicts with\n+    /// a borrow/full access to `borrow_place` (for deep accesses to mutable\n+    /// locations, this function is symmetric between `borrow_place` & `access_place`).\n+    fn places_conflict(\n+        &mut self,\n+        borrow_place: &Place<'tcx>,\n+        access_place: &Place<'tcx>,\n+        access: ShallowOrDeep,\n+    ) -> bool {\n+        debug!(\n+            \"places_conflict({:?},{:?},{:?})\",\n+            borrow_place, access_place, access\n+        );\n+\n+        // Return all the prefixes of `place` in reverse order, including\n+        // downcasts.\n+        fn place_elements<'a, 'tcx>(place: &'a Place<'tcx>) -> Vec<&'a Place<'tcx>> {\n+            let mut result = vec![];\n+            let mut place = place;\n+            loop {\n+                result.push(place);\n+                match place {\n+                    Place::Projection(interior) => {\n+                        place = &interior.base;\n+                    }\n+                    Place::Local(_) | Place::Static(_) => {\n+                        result.reverse();\n+                        return result;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let borrow_components = place_elements(borrow_place);\n+        let access_components = place_elements(access_place);\n+        debug!(\n+            \"places_conflict: components {:?} / {:?}\",\n+            borrow_components, access_components\n+        );\n+\n+        let borrow_components = borrow_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        let access_components = access_components\n+            .into_iter()\n+            .map(Some)\n+            .chain(iter::repeat(None));\n+        // The borrowck rules for proving disjointness are applied from the \"root\" of the\n+        // borrow forwards, iterating over \"similar\" projections in lockstep until\n+        // we can prove overlap one way or another. Essentially, we treat `Overlap` as\n+        // a monoid and report a conflict if the product ends up not being `Disjoint`.\n+        //\n+        // At each step, if we didn't run out of borrow or place, we know that our elements\n+        // have the same type, and that they only overlap if they are the identical.\n+        //\n+        // For example, if we are comparing these:\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  (*x1[i].y).w.b\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //      *x1[2].y    |  *x1[i].y     -- equal or disjoint\n+        //     (*x1[2].y).z | (*x1[i].y).w  -- we are disjoint and don't need to check more!\n+        //\n+        // Because `zip` does potentially bad things to the iterator inside, this loop\n+        // also handles the case where the access might be a *prefix* of the borrow, e.g.\n+        //\n+        // BORROW:  (*x1[2].y).z.a\n+        // ACCESS:  x1[i].y\n+        //\n+        // Then our steps are:\n+        //       x1         |   x1          -- places are the same\n+        //       x1[2]      |   x1[i]       -- equal or disjoint (disjoint if indexes differ)\n+        //       x1[2].y    |   x1[i].y     -- equal or disjoint\n+        //\n+        // -- here we run out of access - the borrow can access a part of it. If this\n+        // is a full deep access, then we *know* the borrow conflicts with it. However,\n+        // if the access is shallow, then we can proceed:\n+        //\n+        //       x1[2].y    | (*x1[i].y)    -- a deref! the access can't get past this, so we\n+        //                                     are disjoint\n+        //\n+        // Our invariant is, that at each step of the iteration:\n+        //  - If we didn't run out of access to match, our borrow and access are comparable\n+        //    and either equal or disjoint.\n+        //  - If we did run out of accesss, the borrow can access a part of it.\n+        for (borrow_c, access_c) in borrow_components.zip(access_components) {\n+            // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+            debug!(\"places_conflict: {:?} vs. {:?}\", borrow_c, access_c);\n+            match (borrow_c, access_c) {\n+                (None, _) => {\n+                    // If we didn't run out of access, the borrow can access all of our\n+                    // place (e.g. a borrow of `a.b` with an access to `a.b.c`),\n+                    // so we have a conflict.\n+                    //\n+                    // If we did, then we still know that the borrow can access a *part*\n+                    // of our place that our access cares about (a borrow of `a.b.c`\n+                    // with an access to `a.b`), so we still have a conflict.\n+                    //\n+                    // FIXME: Differs from AST-borrowck; includes drive-by fix\n+                    // to #38899. Will probably need back-compat mode flag.\n+                    debug!(\"places_conflict: full borrow, CONFLICT\");\n+                    return true;\n+                }\n+                (Some(borrow_c), None) => {\n+                    // We know that the borrow can access a part of our place. This\n+                    // is a conflict if that is a part our access cares about.\n+\n+                    let (base, elem) = match borrow_c {\n+                        Place::Projection(box Projection { base, elem }) => (base, elem),\n+                        _ => bug!(\"place has no base?\"),\n+                    };\n+                    let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+\n+                    match (elem, &base_ty.sty, access) {\n+                        (_, _, Shallow(Some(ArtificialField::Discriminant)))\n+                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                            // The discriminant and array length are like\n+                            // additional fields on the type; they do not\n+                            // overlap any existing data there. Furthermore,\n+                            // they cannot actually be a prefix of any\n+                            // borrowed place (at least in MIR as it is\n+                            // currently.)\n+                            //\n+                            // e.g. a (mutable) borrow of `a[5]` while we read the\n+                            // array length of `a`.\n+                            debug!(\"places_conflict: implicit field\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Shallow(None)) => {\n+                            // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n+                            // prefix thereof - the shallow access can't touch anything behind\n+                            // the pointer.\n+                            debug!(\"places_conflict: shallow access behind ptr\");\n+                            return false;\n+                        }\n+                        (\n+                            ProjectionElem::Deref,\n+                            ty::TyRef(\n+                                _,\n+                                ty::TypeAndMut {\n+                                    ty: _,\n+                                    mutbl: hir::MutImmutable,\n+                                },\n+                            ),\n+                            _,\n+                        ) => {\n+                            // the borrow goes through a dereference of a shared reference.\n+                            //\n+                            // I'm not sure why we are tracking these borrows - shared\n+                            // references can *always* be aliased, which means the\n+                            // permission check already account for this borrow.\n+                            debug!(\"places_conflict: behind a shared ref\");\n+                            return false;\n+                        }\n+\n+                        (ProjectionElem::Deref, _, Deep)\n+                        | (ProjectionElem::Field { .. }, _, _)\n+                        | (ProjectionElem::Index { .. }, _, _)\n+                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                        | (ProjectionElem::Subslice { .. }, _, _)\n+                        | (ProjectionElem::Downcast { .. }, _, _) => {\n+                            // Recursive case. This can still be disjoint on a\n+                            // further iteration if this a shallow access and\n+                            // there's a deref later on, e.g. a borrow\n+                            // of `*x.y` while accessing `x`.\n+                        }\n+                    }\n+                }\n+                (Some(borrow_c), Some(access_c)) => {\n+                    match self.place_element_conflict(&borrow_c, access_c) {\n+                        Overlap::Arbitrary => {\n+                            // We have encountered different fields of potentially\n+                            // the same union - the borrow now partially overlaps.\n+                            //\n+                            // There is no *easy* way of comparing the fields\n+                            // further on, because they might have different types\n+                            // (e.g. borrows of `u.a.0` and `u.b.y` where `.0` and\n+                            // `.y` come from different structs).\n+                            //\n+                            // We could try to do some things here - e.g. count\n+                            // dereferences - but that's probably not a good\n+                            // idea, at least for now, so just give up and\n+                            // report a conflict. This is unsafe code anyway so\n+                            // the user could always use raw pointers.\n+                            debug!(\"places_conflict: arbitrary -> conflict\");\n+                            return true;\n+                        }\n+                        Overlap::EqualOrDisjoint => {\n+                            // This is the recursive case - proceed to the next element.\n+                        }\n+                        Overlap::Disjoint => {\n+                            // We have proven the borrow disjoint - further\n+                            // projections will remain disjoint.\n+                            debug!(\"places_conflict: disjoint\");\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        unreachable!(\"iter::repeat returned None\")\n+    }\n+}"}, {"sha": "12620ed3fc09f76ebb0fb9efecf1869ec8e8680a", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03518bfad10481f5df900f7e15bab368f1fec04/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=f03518bfad10481f5df900f7e15bab368f1fec04", "patch": "@@ -37,6 +37,7 @@ mod renumber;\n mod subtype_constraint_generation;\n crate mod type_check;\n mod universal_regions;\n+mod invalidation;\n \n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;"}]}