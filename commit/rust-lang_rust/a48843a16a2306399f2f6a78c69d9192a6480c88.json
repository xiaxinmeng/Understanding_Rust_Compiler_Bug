{"sha": "a48843a16a2306399f2f6a78c69d9192a6480c88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ODg0M2ExNmEyMzA2Mzk5ZjJmNmE3OGM2OWQ5MTkyYTY0ODBjODg=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-07-12T13:26:02Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-07-15T20:04:49Z"}, "message": "Use Chalk closure support", "tree": {"sha": "2fbaf1c22c631e9e2278e6a33940ccf6ea98037c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fbaf1c22c631e9e2278e6a33940ccf6ea98037c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a48843a16a2306399f2f6a78c69d9192a6480c88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a48843a16a2306399f2f6a78c69d9192a6480c88", "html_url": "https://github.com/rust-lang/rust/commit/a48843a16a2306399f2f6a78c69d9192a6480c88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a48843a16a2306399f2f6a78c69d9192a6480c88/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b63e23e98e7dfbe57de93ebe256254825512e148", "url": "https://api.github.com/repos/rust-lang/rust/commits/b63e23e98e7dfbe57de93ebe256254825512e148", "html_url": "https://github.com/rust-lang/rust/commit/b63e23e98e7dfbe57de93ebe256254825512e148"}], "stats": {"total": 441, "additions": 86, "deletions": 355}, "files": [{"sha": "3a9973abffa8fc415c1ad6d83185feb2772bb607", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -17,9 +17,9 @@ pub use hir_ty::db::{\n     AssociatedTyDataQuery, AssociatedTyValueQuery, CallableItemSignatureQuery, FieldTypesQuery,\n     GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery, HirDatabase,\n     HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, InferQueryQuery,\n-    InherentImplsInCrateQuery, InternAssocTyValueQuery, InternChalkImplQuery, InternTypeCtorQuery,\n-    InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery, TraitDatumQuery,\n-    TraitImplsInCrateQuery, TraitImplsInDepsQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n+    InherentImplsInCrateQuery, InternTypeCtorQuery, InternTypeParamIdQuery,\n+    ReturnTypeImplTraitsQuery, StructDatumQuery, TraitDatumQuery, TraitImplsInCrateQuery,\n+    TraitImplsInDepsQuery, TraitSolveQuery, TyQuery, ValueTyQuery,\n };\n \n #[test]"}, {"sha": "d8a7987715019a7afbe8dc01bb90bb3aac3adb5c", "filename": "crates/ra_hir_ty/src/db.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdb.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -3,16 +3,16 @@\n use std::sync::Arc;\n \n use hir_def::{\n-    db::DefDatabase, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId, TypeParamId,\n-    VariantId,\n+    db::DefDatabase, expr::ExprId, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId,\n+    TypeParamId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n use ra_prof::profile;\n \n use crate::{\n     method_resolution::{InherentImpls, TraitImpls},\n-    traits::{chalk, AssocTyValue, Impl},\n+    traits::chalk,\n     Binders, CallableDef, GenericPredicate, InferenceResult, OpaqueTyId, PolyFnSig,\n     ReturnTypeImplTraits, TraitRef, Ty, TyDefId, TypeCtor, ValueTyDefId,\n };\n@@ -85,9 +85,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::interned]\n     fn intern_impl_trait_id(&self, id: OpaqueTyId) -> InternedOpaqueTyId;\n     #[salsa::interned]\n-    fn intern_chalk_impl(&self, impl_: Impl) -> crate::traits::GlobalImplId;\n-    #[salsa::interned]\n-    fn intern_assoc_ty_value(&self, assoc_ty_value: AssocTyValue) -> crate::traits::AssocTyValueId;\n+    fn intern_closure(&self, id: (DefWithBodyId, ExprId)) -> ClosureId;\n \n     #[salsa::invoke(chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk::AssocTypeId) -> Arc<chalk::AssociatedTyDatum>;\n@@ -151,3 +149,7 @@ impl_intern_key!(GlobalTypeParamId);\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct InternedOpaqueTyId(salsa::InternId);\n impl_intern_key!(InternedOpaqueTyId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct ClosureId(salsa::InternId);\n+impl_intern_key!(ClosureId);"}, {"sha": "c972bf84503c98b43c582482e40ce813bb8135c0", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -40,7 +40,11 @@ fn setup_tracing() -> tracing::subscriber::DefaultGuard {\n     use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n     use tracing_tree::HierarchicalLayer;\n     let filter = EnvFilter::from_env(\"CHALK_DEBUG\");\n-    let layer = HierarchicalLayer::default().with_indent_amount(2).with_writer(std::io::stderr);\n+    let layer = HierarchicalLayer::default()\n+        .with_indent_lines(true)\n+        .with_ansi(false)\n+        .with_indent_amount(2)\n+        .with_writer(std::io::stderr);\n     let subscriber = Registry::default().with(filter).with(layer);\n     tracing::subscriber::set_default(subscriber)\n }"}, {"sha": "3f6d2cf35213052b34608b385a0a3f7ba6b414da", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 49, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -3,10 +3,8 @@ use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n use chalk_solve::Solver;\n-use hir_def::{\n-    expr::ExprId, lang_item::LangItemTarget, DefWithBodyId, ImplId, TraitId, TypeAliasId,\n-};\n-use ra_db::{impl_intern_key, salsa, CrateId};\n+use hir_def::{lang_item::LangItemTarget, TraitId};\n+use ra_db::CrateId;\n use ra_prof::profile;\n \n use crate::{db::HirDatabase, DebruijnIndex, Substs};\n@@ -16,7 +14,6 @@ use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty,\n use self::chalk::{from_chalk, Interner, ToChalk};\n \n pub(crate) mod chalk;\n-mod builtin;\n \n // This controls the maximum size of types Chalk considers. If we set this too\n // high, we can run into slow edge cases; if we set it too low, Chalk won't\n@@ -274,47 +271,3 @@ impl FnTrait {\n         }\n     }\n }\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ClosureFnTraitImplData {\n-    def: DefWithBodyId,\n-    expr: ExprId,\n-    fn_trait: FnTrait,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct UnsizeToSuperTraitObjectData {\n-    trait_: TraitId,\n-    super_trait: TraitId,\n-}\n-\n-/// An impl. Usually this comes from an impl block, but some built-in types get\n-/// synthetic impls.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum Impl {\n-    /// A normal impl from an impl block.\n-    ImplDef(ImplId),\n-    /// Closure types implement the Fn traits synthetically.\n-    // FIXME: implement closure support from Chalk, remove this\n-    ClosureFnTraitImpl(ClosureFnTraitImplData),\n-}\n-/// This exists just for Chalk, because our ImplIds are only unique per module.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct GlobalImplId(salsa::InternId);\n-impl_intern_key!(GlobalImplId);\n-\n-/// An associated type value. Usually this comes from a `type` declaration\n-/// inside an impl block, but for built-in impls we have to synthesize it.\n-/// (We only need this because Chalk wants a unique ID for each of these.)\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub enum AssocTyValue {\n-    /// A normal assoc type value from an impl block.\n-    TypeAlias(TypeAliasId),\n-    /// The output type of the Fn trait implementation.\n-    ClosureFnTraitImplOutput(ClosureFnTraitImplData),\n-}\n-/// This exists just for Chalk, because it needs a unique ID for each associated\n-/// type value in an impl (even synthetic ones).\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct AssocTyValueId(salsa::InternId);\n-impl_intern_key!(AssocTyValueId);"}, {"sha": "60cc9a9f50c212be1f4997700a1dfe4de0ef4371", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b63e23e98e7dfbe57de93ebe256254825512e148/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63e23e98e7dfbe57de93ebe256254825512e148/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=b63e23e98e7dfbe57de93ebe256254825512e148", "patch": "@@ -1,178 +0,0 @@\n-//! This module provides the built-in trait implementations, e.g. to make\n-//! closures implement `Fn`.\n-use hir_def::{expr::Expr, TraitId, TypeAliasId};\n-use hir_expand::name::name;\n-use ra_db::CrateId;\n-\n-use super::{AssocTyValue, Impl};\n-use crate::{\n-    db::HirDatabase, ApplicationTy, BoundVar, DebruijnIndex, Substs, TraitRef, Ty, TypeCtor,\n-};\n-\n-pub(super) struct BuiltinImplData {\n-    pub num_vars: usize,\n-    pub trait_ref: TraitRef,\n-    pub where_clauses: Vec<super::GenericPredicate>,\n-    pub assoc_ty_values: Vec<AssocTyValue>,\n-}\n-\n-pub(super) struct BuiltinImplAssocTyValueData {\n-    pub impl_: Impl,\n-    pub assoc_ty_id: TypeAliasId,\n-    pub num_vars: usize,\n-    pub value: Ty,\n-}\n-\n-pub(super) fn get_builtin_impls(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: &Ty,\n-    // The first argument for the trait, if present\n-    _arg: &Option<Ty>,\n-    trait_: TraitId,\n-    mut callback: impl FnMut(Impl),\n-) {\n-    // Note: since impl_datum needs to be infallible, we need to make sure here\n-    // that we have all prerequisites to build the respective impls.\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Closure { def, expr }, .. }) = ty {\n-        for &fn_trait in [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n-        {\n-            if let Some(actual_trait) = fn_trait.get_id(db, krate) {\n-                if trait_ == actual_trait {\n-                    let impl_ = super::ClosureFnTraitImplData { def: *def, expr: *expr, fn_trait };\n-                    if check_closure_fn_trait_impl_prerequisites(db, krate, impl_) {\n-                        callback(Impl::ClosureFnTraitImpl(impl_));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub(super) fn impl_datum(db: &dyn HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n-    match impl_ {\n-        Impl::ImplDef(_) => unreachable!(),\n-        Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n-    }\n-}\n-\n-pub(super) fn associated_ty_value(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: AssocTyValue,\n-) -> BuiltinImplAssocTyValueData {\n-    match data {\n-        AssocTyValue::TypeAlias(_) => unreachable!(),\n-        AssocTyValue::ClosureFnTraitImplOutput(data) => {\n-            closure_fn_trait_output_assoc_ty_value(db, krate, data)\n-        }\n-    }\n-}\n-\n-// Closure Fn trait impls\n-\n-fn check_closure_fn_trait_impl_prerequisites(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: super::ClosureFnTraitImplData,\n-) -> bool {\n-    // the respective Fn/FnOnce/FnMut trait needs to exist\n-    if data.fn_trait.get_id(db, krate).is_none() {\n-        return false;\n-    }\n-\n-    // FIXME: there are more assumptions that we should probably check here:\n-    // the traits having no type params, FnOnce being a supertrait\n-\n-    // the FnOnce trait needs to exist and have an assoc type named Output\n-    let fn_once_trait = match (super::FnTrait::FnOnce).get_id(db, krate) {\n-        Some(t) => t,\n-        None => return false,\n-    };\n-    db.trait_data(fn_once_trait).associated_type_by_name(&name![Output]).is_some()\n-}\n-\n-fn closure_fn_trait_impl_datum(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: super::ClosureFnTraitImplData,\n-) -> BuiltinImplData {\n-    // for some closure |X, Y| -> Z:\n-    // impl<T, U, V> Fn<(T, U)> for closure<fn(T, U) -> V> { Output = V }\n-\n-    let trait_ = data\n-        .fn_trait\n-        .get_id(db, krate) // get corresponding fn trait\n-        // the existence of the Fn trait has been checked before\n-        .expect(\"fn trait for closure impl missing\");\n-\n-    let num_args: u16 = match &db.body(data.def)[data.expr] {\n-        Expr::Lambda { args, .. } => args.len() as u16,\n-        _ => {\n-            log::warn!(\"closure for closure type {:?} not found\", data);\n-            0\n-        }\n-    };\n-\n-    let arg_ty = Ty::apply(\n-        TypeCtor::Tuple { cardinality: num_args },\n-        Substs::builder(num_args as usize)\n-            .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n-            .build(),\n-    );\n-    let sig_ty = Ty::apply(\n-        TypeCtor::FnPtr { num_args, is_varargs: false },\n-        Substs::builder(num_args as usize + 1)\n-            .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n-            .build(),\n-    );\n-\n-    let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n-\n-    let trait_ref = TraitRef {\n-        trait_,\n-        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n-    };\n-\n-    let output_ty_id = AssocTyValue::ClosureFnTraitImplOutput(data);\n-\n-    BuiltinImplData {\n-        num_vars: num_args as usize + 1,\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        assoc_ty_values: vec![output_ty_id],\n-    }\n-}\n-\n-fn closure_fn_trait_output_assoc_ty_value(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: super::ClosureFnTraitImplData,\n-) -> BuiltinImplAssocTyValueData {\n-    let impl_ = Impl::ClosureFnTraitImpl(data);\n-\n-    let num_args: u16 = match &db.body(data.def)[data.expr] {\n-        Expr::Lambda { args, .. } => args.len() as u16,\n-        _ => {\n-            log::warn!(\"closure for closure type {:?} not found\", data);\n-            0\n-        }\n-    };\n-\n-    let output_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, num_args.into()));\n-\n-    let fn_once_trait =\n-        (super::FnTrait::FnOnce).get_id(db, krate).expect(\"assoc ty value should not exist\");\n-\n-    let output_ty_id = db\n-        .trait_data(fn_once_trait)\n-        .associated_type_by_name(&name![Output])\n-        .expect(\"assoc ty value should not exist\");\n-\n-    BuiltinImplAssocTyValueData {\n-        impl_,\n-        assoc_ty_id: output_ty_id,\n-        num_vars: num_args as usize + 1,\n-        value: output_ty,\n-    }\n-}"}, {"sha": "7f8ba2f121dba98fc868c2cd5c3451cb28d99b67", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -12,15 +12,17 @@ use hir_def::{\n };\n use ra_db::{salsa::InternKey, CrateId};\n \n-use super::{builtin, AssocTyValue, ChalkContext, Impl};\n+use super::ChalkContext;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     utils::generics,\n-    CallableDef, DebruijnIndex, GenericPredicate, Substs, Ty, TypeCtor,\n+    CallableDef, DebruijnIndex, FnSig, GenericPredicate, Substs, Ty, TypeCtor,\n+};\n+use mapping::{\n+    convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n };\n-use mapping::{convert_where_clauses, generic_predicate_to_inline_bound, make_binders};\n \n pub use self::interner::*;\n \n@@ -102,9 +104,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         let in_self = self.db.trait_impls_in_crate(self.krate);\n         let impl_maps = [in_deps, in_self];\n \n-        let id_to_chalk = |id: hir_def::ImplId| Impl::ImplDef(id).to_chalk(self.db);\n+        let id_to_chalk = |id: hir_def::ImplId| id.to_chalk(self.db);\n \n-        let mut result: Vec<_> = if fps.is_empty() {\n+        let result: Vec<_> = if fps.is_empty() {\n             debug!(\"Unrestricted search for {:?} impls...\", trait_);\n             impl_maps\n                 .iter()\n@@ -121,13 +123,6 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                 .collect()\n         };\n \n-        let arg: Option<Ty> =\n-            parameters.get(1).map(|p| from_chalk(self.db, p.assert_ty_ref(&Interner).clone()));\n-\n-        builtin::get_builtin_impls(self.db, self.krate, &ty, &arg, trait_, |i| {\n-            result.push(i.to_chalk(self.db))\n-        });\n-\n         debug!(\"impls_for_trait returned {} impls\", result.len());\n         result\n     }\n@@ -217,32 +212,40 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> rust_ir::ClosureKind {\n-        // FIXME: implement closure support\n-        unimplemented!()\n+        // Fn is the closure kind that implements all three traits\n+        rust_ir::ClosureKind::Fn\n     }\n     fn closure_inputs_and_output(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n-        _substs: &chalk_ir::Substitution<Interner>,\n+        substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<rust_ir::FnDefInputsAndOutputDatum<Interner>> {\n-        // FIXME: implement closure support\n-        unimplemented!()\n+        let sig_ty: Ty =\n+            from_chalk(self.db, substs.at(&Interner, 0).assert_ty_ref(&Interner).clone());\n+        let sig = FnSig::from_fn_ptr_substs(\n+            &sig_ty.substs().expect(\"first closure param should be fn ptr\"),\n+            false,\n+        );\n+        let io = rust_ir::FnDefInputsAndOutputDatum {\n+            argument_types: sig.params().iter().map(|ty| ty.clone().to_chalk(self.db)).collect(),\n+            return_type: sig.ret().clone().to_chalk(self.db),\n+        };\n+        make_binders(io.shifted_in(&Interner), 0)\n     }\n     fn closure_upvars(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Binders<chalk_ir::Ty<Interner>> {\n-        // FIXME: implement closure support\n-        unimplemented!()\n+        let ty = Ty::unit().to_chalk(self.db);\n+        make_binders(ty, 0)\n     }\n     fn closure_fn_substitution(\n         &self,\n         _closure_id: chalk_ir::ClosureId<Interner>,\n         _substs: &chalk_ir::Substitution<Interner>,\n     ) -> chalk_ir::Substitution<Interner> {\n-        // FIXME: implement closure support\n-        unimplemented!()\n+        Substs::empty().to_chalk(self.db)\n     }\n \n     fn trait_name(&self, _trait_id: chalk_ir::TraitId<Interner>) -> String {\n@@ -417,11 +420,8 @@ pub(crate) fn impl_datum_query(\n ) -> Arc<ImplDatum> {\n     let _p = ra_prof::profile(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n-    let impl_: Impl = from_chalk(db, impl_id);\n-    match impl_ {\n-        Impl::ImplDef(impl_def) => impl_def_datum(db, krate, impl_id, impl_def),\n-        _ => Arc::new(builtin::impl_datum(db, krate, impl_).to_chalk(db)),\n-    }\n+    let impl_: hir_def::ImplId = from_chalk(db, impl_id);\n+    impl_def_datum(db, krate, impl_id, impl_)\n }\n \n fn impl_def_datum(\n@@ -472,7 +472,7 @@ fn impl_def_datum(\n             let name = &db.type_alias_data(type_alias).name;\n             trait_data.associated_type_by_name(name).is_some()\n         })\n-        .map(|type_alias| AssocTyValue::TypeAlias(type_alias).to_chalk(db))\n+        .map(|type_alias| TypeAliasAsValue(type_alias).to_chalk(db))\n         .collect();\n     debug!(\"impl_datum: {:?}\", impl_datum_bound);\n     let impl_datum = ImplDatum {\n@@ -489,13 +489,8 @@ pub(crate) fn associated_ty_value_query(\n     krate: CrateId,\n     id: AssociatedTyValueId,\n ) -> Arc<AssociatedTyValue> {\n-    let data: AssocTyValue = from_chalk(db, id);\n-    match data {\n-        AssocTyValue::TypeAlias(type_alias) => {\n-            type_alias_associated_ty_value(db, krate, type_alias)\n-        }\n-        _ => Arc::new(builtin::associated_ty_value(db, krate, data).to_chalk(db)),\n-    }\n+    let type_alias: TypeAliasAsValue = from_chalk(db, id);\n+    type_alias_associated_ty_value(db, krate, type_alias.0)\n }\n \n fn type_alias_associated_ty_value(\n@@ -518,7 +513,7 @@ fn type_alias_associated_ty_value(\n     let ty = db.ty(type_alias.into());\n     let value_bound = rust_ir::AssociatedTyValueBound { ty: ty.value.to_chalk(db) };\n     let value = rust_ir::AssociatedTyValue {\n-        impl_id: Impl::ImplDef(impl_id).to_chalk(db),\n+        impl_id: impl_id.to_chalk(db),\n         associated_ty_id: assoc_ty.to_chalk(db),\n         value: make_binders(value_bound, ty.num_binders),\n     };\n@@ -581,18 +576,6 @@ impl From<crate::CallableDefId> for FnDefId {\n     }\n }\n \n-impl From<ImplId> for crate::traits::GlobalImplId {\n-    fn from(impl_id: ImplId) -> Self {\n-        InternKey::from_intern_id(impl_id.0)\n-    }\n-}\n-\n-impl From<crate::traits::GlobalImplId> for ImplId {\n-    fn from(impl_id: crate::traits::GlobalImplId) -> Self {\n-        chalk_ir::ImplId(impl_id.as_intern_id())\n-    }\n-}\n-\n impl From<OpaqueTyId> for crate::db::InternedOpaqueTyId {\n     fn from(id: OpaqueTyId) -> Self {\n         InternKey::from_intern_id(id.0)\n@@ -605,14 +588,14 @@ impl From<crate::db::InternedOpaqueTyId> for OpaqueTyId {\n     }\n }\n \n-impl From<rust_ir::AssociatedTyValueId<Interner>> for crate::traits::AssocTyValueId {\n-    fn from(id: rust_ir::AssociatedTyValueId<Interner>) -> Self {\n+impl From<chalk_ir::ClosureId<Interner>> for crate::db::ClosureId {\n+    fn from(id: chalk_ir::ClosureId<Interner>) -> Self {\n         Self::from_intern_id(id.0)\n     }\n }\n \n-impl From<crate::traits::AssocTyValueId> for rust_ir::AssociatedTyValueId<Interner> {\n-    fn from(assoc_ty_value_id: crate::traits::AssocTyValueId) -> Self {\n-        rust_ir::AssociatedTyValueId(assoc_ty_value_id.as_intern_id())\n+impl From<crate::db::ClosureId> for chalk_ir::ClosureId<Interner> {\n+    fn from(id: crate::db::ClosureId) -> Self {\n+        chalk_ir::ClosureId(id.as_intern_id())\n     }\n }"}, {"sha": "796947e690b8159edf369cebfb20cec0e0f32807", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 33, "deletions": 64, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -15,7 +15,7 @@ use ra_db::salsa::InternKey;\n use crate::{\n     db::HirDatabase,\n     primitive::{FloatBitness, FloatTy, IntBitness, IntTy, Signedness},\n-    traits::{builtin, AssocTyValue, Canonical, Impl, Obligation},\n+    traits::{Canonical, Obligation},\n     ApplicationTy, CallableDef, GenericPredicate, InEnvironment, OpaqueTy, OpaqueTyId,\n     ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeCtor,\n };\n@@ -311,8 +311,15 @@ impl ToChalk for TypeCtor {\n             }\n             TypeCtor::Never => TypeName::Never,\n \n-            // FIXME convert these\n-            TypeCtor::Adt(_) | TypeCtor::FnPtr { .. } | TypeCtor::Closure { .. } => {\n+            TypeCtor::Closure { def, expr } => {\n+                let closure_id = db.intern_closure((def, expr));\n+                TypeName::Closure(closure_id.into())\n+            }\n+\n+            TypeCtor::FnPtr { .. } => panic!(\"Trying to convert FnPtr to TypeName\"),\n+\n+            TypeCtor::Adt(_) => {\n+                // FIXME no interning needed anymore\n                 // other TypeCtors get interned and turned into a chalk StructId\n                 let struct_id = db.intern_type_ctor(self).into();\n                 TypeName::Adt(struct_id)\n@@ -355,13 +362,16 @@ impl ToChalk for TypeCtor {\n                 let callable_def = from_chalk(db, fn_def_id);\n                 TypeCtor::FnDef(callable_def)\n             }\n+            TypeName::Array => TypeCtor::Array,\n \n-            TypeName::Array | TypeName::Error => {\n-                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n-                unreachable!()\n+            TypeName::Closure(id) => {\n+                let id: crate::db::ClosureId = id.into();\n+                let (def, expr) = db.lookup_intern_closure(id);\n+                TypeCtor::Closure { def, expr }\n             }\n-            TypeName::Closure(_) => {\n-                // FIXME: implement closure support\n+\n+            TypeName::Error => {\n+                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n                 unreachable!()\n             }\n         }\n@@ -433,15 +443,15 @@ impl ToChalk for Mutability {\n     }\n }\n \n-impl ToChalk for Impl {\n+impl ToChalk for hir_def::ImplId {\n     type Chalk = ImplId;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> ImplId {\n-        db.intern_chalk_impl(self).into()\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> ImplId {\n+        chalk_ir::ImplId(self.as_intern_id())\n     }\n \n-    fn from_chalk(db: &dyn HirDatabase, impl_id: ImplId) -> Impl {\n-        db.lookup_intern_chalk_impl(impl_id.into())\n+    fn from_chalk(_db: &dyn HirDatabase, impl_id: ImplId) -> hir_def::ImplId {\n+        InternKey::from_intern_id(impl_id.0)\n     }\n }\n \n@@ -469,15 +479,20 @@ impl ToChalk for TypeAliasId {\n     }\n }\n \n-impl ToChalk for AssocTyValue {\n+pub struct TypeAliasAsValue(pub TypeAliasId);\n+\n+impl ToChalk for TypeAliasAsValue {\n     type Chalk = AssociatedTyValueId;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValueId {\n-        db.intern_assoc_ty_value(self).into()\n+    fn to_chalk(self, _db: &dyn HirDatabase) -> AssociatedTyValueId {\n+        rust_ir::AssociatedTyValueId(self.0.as_intern_id())\n     }\n \n-    fn from_chalk(db: &dyn HirDatabase, assoc_ty_value_id: AssociatedTyValueId) -> AssocTyValue {\n-        db.lookup_intern_assoc_ty_value(assoc_ty_value_id.into())\n+    fn from_chalk(\n+        _db: &dyn HirDatabase,\n+        assoc_ty_value_id: AssociatedTyValueId,\n+    ) -> TypeAliasAsValue {\n+        TypeAliasAsValue(TypeAliasId::from_intern_id(assoc_ty_value_id.0))\n     }\n }\n \n@@ -686,52 +701,6 @@ where\n     }\n }\n \n-impl ToChalk for builtin::BuiltinImplData {\n-    type Chalk = ImplDatum;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> ImplDatum {\n-        let impl_type = rust_ir::ImplType::External;\n-        let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n-\n-        let impl_datum_bound =\n-            rust_ir::ImplDatumBound { trait_ref: self.trait_ref.to_chalk(db), where_clauses };\n-        let associated_ty_value_ids =\n-            self.assoc_ty_values.into_iter().map(|v| v.to_chalk(db)).collect();\n-        rust_ir::ImplDatum {\n-            binders: make_binders(impl_datum_bound, self.num_vars),\n-            impl_type,\n-            polarity: rust_ir::Polarity::Positive,\n-            associated_ty_value_ids,\n-        }\n-    }\n-\n-    fn from_chalk(_db: &dyn HirDatabase, _data: ImplDatum) -> Self {\n-        unimplemented!()\n-    }\n-}\n-\n-impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n-    type Chalk = AssociatedTyValue;\n-\n-    fn to_chalk(self, db: &dyn HirDatabase) -> AssociatedTyValue {\n-        let ty = self.value.to_chalk(db);\n-        let value_bound = rust_ir::AssociatedTyValueBound { ty };\n-\n-        rust_ir::AssociatedTyValue {\n-            associated_ty_id: self.assoc_ty_id.to_chalk(db),\n-            impl_id: self.impl_.to_chalk(db),\n-            value: make_binders(value_bound, self.num_vars),\n-        }\n-    }\n-\n-    fn from_chalk(\n-        _db: &dyn HirDatabase,\n-        _data: AssociatedTyValue,\n-    ) -> builtin::BuiltinImplAssocTyValueData {\n-        unimplemented!()\n-    }\n-}\n-\n pub(super) fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T>\n where\n     T: HasInterner<Interner = Interner>,"}, {"sha": "d40cfeb02dd7205a886fbed9336dbd9a55087e4b", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a48843a16a2306399f2f6a78c69d9192a6480c88/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=a48843a16a2306399f2f6a78c69d9192a6480c88", "patch": "@@ -281,8 +281,6 @@ impl RootDatabase {\n             // HirDatabase\n             hir::db::InternTypeCtorQuery\n             hir::db::InternTypeParamIdQuery\n-            hir::db::InternChalkImplQuery\n-            hir::db::InternAssocTyValueQuery\n         ];\n \n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));"}]}