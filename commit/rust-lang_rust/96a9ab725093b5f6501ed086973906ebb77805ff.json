{"sha": "96a9ab725093b5f6501ed086973906ebb77805ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTlhYjcyNTA5M2I1ZjY1MDFlZDA4Njk3MzkwNmViYjc3ODA1ZmY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-09T18:01:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-09T18:01:04Z"}, "message": "Merge #7614\n\n7614: Unleash inner item resolution to users r=jonas-schievink a=jonas-schievink\n\n![Peek 2021-02-09 17-30](https://user-images.githubusercontent.com/1786438/107394800-8627f300-6afc-11eb-8662-ed07226bc58f.gif)\r\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "a339e6bc8a3873137b6dd16667d3dedf824716ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a339e6bc8a3873137b6dd16667d3dedf824716ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a9ab725093b5f6501ed086973906ebb77805ff", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgIs3gCRBK7hj4Ov3rIwAAdHIIALFKvjAv+K106LYsMyge5MGf\nKG3nueXo9QOI4Kx0tKzk0UbqUYlKxeB/Bus0Lm6kZ2UMoCDcFhSTs576AW+C+1QI\nxgw6qx+RF1pCvS8YSJbsSPU4krByzo0Moqi05WkrioQ1mqIlysr+btNbaJ0uFgD0\n6mjL9ljs4g0tcPIJ6dbm0tWU1fHAUhrvIp9GeGRwpPyeQMgb8cpC3IAozcX6vVzO\nLrOWSoCrdCYw02sE5nRgZamRlW2sEHTpcGr7riSfgFvlDEtieBn54sZ+QnaAhC8Q\nSvdnt+dEdAjaZyr8eK2gDgfCd0K1V2EPKzSadT302AZFKo59peRKHRzj+moqN0Q=\n=bcHM\n-----END PGP SIGNATURE-----\n", "payload": "tree a339e6bc8a3873137b6dd16667d3dedf824716ea\nparent 98b82859551555a1b0671c75307d56a17aa545b6\nparent 85906aa304c2265f3ae692d62306ba07694ece45\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1612893664 +0000\ncommitter GitHub <noreply@github.com> 1612893664 +0000\n\nMerge #7614\n\n7614: Unleash inner item resolution to users r=jonas-schievink a=jonas-schievink\n\n![Peek 2021-02-09 17-30](https://user-images.githubusercontent.com/1786438/107394800-8627f300-6afc-11eb-8662-ed07226bc58f.gif)\r\n\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a9ab725093b5f6501ed086973906ebb77805ff", "html_url": "https://github.com/rust-lang/rust/commit/96a9ab725093b5f6501ed086973906ebb77805ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a9ab725093b5f6501ed086973906ebb77805ff/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98b82859551555a1b0671c75307d56a17aa545b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/98b82859551555a1b0671c75307d56a17aa545b6", "html_url": "https://github.com/rust-lang/rust/commit/98b82859551555a1b0671c75307d56a17aa545b6"}, {"sha": "85906aa304c2265f3ae692d62306ba07694ece45", "url": "https://api.github.com/repos/rust-lang/rust/commits/85906aa304c2265f3ae692d62306ba07694ece45", "html_url": "https://github.com/rust-lang/rust/commit/85906aa304c2265f3ae692d62306ba07694ece45"}], "stats": {"total": 570, "additions": 333, "deletions": 237}, "files": [{"sha": "210b4a617ffcb607b96c3889e5ebf5271d970406", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     body::Body,\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId, Statement},\n-    DefWithBodyId,\n+    BlockId, DefWithBodyId,\n };\n \n pub type ScopeId = Idx<ScopeData>;\n@@ -39,6 +39,7 @@ impl ScopeEntry {\n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeData {\n     parent: Option<ScopeId>,\n+    block: Option<BlockId>,\n     entries: Vec<ScopeEntry>,\n }\n \n@@ -61,6 +62,11 @@ impl ExprScopes {\n         &self.scopes[scope].entries\n     }\n \n+    /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.\n+    pub fn block(&self, scope: ScopeId) -> Option<BlockId> {\n+        self.scopes[scope].block\n+    }\n+\n     pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n         std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n     }\n@@ -79,11 +85,15 @@ impl ExprScopes {\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: None, entries: vec![] })\n+        self.scopes.alloc(ScopeData { parent: None, block: None, entries: vec![] })\n     }\n \n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n-        self.scopes.alloc(ScopeData { parent: Some(parent), entries: vec![] })\n+        self.scopes.alloc(ScopeData { parent: Some(parent), block: None, entries: vec![] })\n+    }\n+\n+    fn new_block_scope(&mut self, parent: ScopeId, block: BlockId) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: Some(parent), block: Some(block), entries: vec![] })\n     }\n \n     fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n@@ -136,7 +146,11 @@ fn compute_block_scopes(\n fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n     scopes.set_scope(expr, scope);\n     match &body[expr] {\n-        Expr::Block { statements, tail, .. } => {\n+        Expr::Block { statements, tail, id, .. } => {\n+            let scope = scopes.new_block_scope(scope, *id);\n+            // Overwrite the old scope for the block expr, so that every block scope can be found\n+            // via the block itself (important for blocks that only contain items, no expressions).\n+            scopes.set_scope(expr, scope);\n             compute_block_scopes(&statements, *tail, body, scopes, scope);\n         }\n         Expr::For { iterable, pat, body: body_expr, .. } => {"}, {"sha": "bb43569d722b6448f8a9eb48d3f570d8e16f6a93", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 4, "deletions": 100, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -1,10 +1,10 @@\n mod block;\n \n-use base_db::{fixture::WithFixture, FilePosition, SourceDatabase};\n+use base_db::{fixture::WithFixture, SourceDatabase};\n use expect_test::Expect;\n use test_utils::mark;\n \n-use crate::{test_db::TestDB, BlockId, ModuleDefId};\n+use crate::{test_db::TestDB, ModuleDefId};\n \n use super::*;\n \n@@ -37,104 +37,8 @@ fn check_diagnostics(ra_fixture: &str) {\n fn block_def_map_at(ra_fixture: &str) -> String {\n     let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n \n-    let krate = db.crate_graph().iter().next().unwrap();\n-    let def_map = db.crate_def_map(krate);\n-\n-    let mut block =\n-        block_at_pos(&db, &def_map, position).expect(\"couldn't find enclosing function or block\");\n-    loop {\n-        let def_map = db.block_def_map(block).unwrap_or_else(|| def_map.clone());\n-        let new_block = block_at_pos(&db, &def_map, position);\n-        match new_block {\n-            Some(new_block) => {\n-                assert_ne!(block, new_block);\n-                block = new_block;\n-            }\n-            None => {\n-                return def_map.dump(&db);\n-            }\n-        }\n-    }\n-}\n-\n-fn block_at_pos(db: &dyn DefDatabase, def_map: &DefMap, position: FilePosition) -> Option<BlockId> {\n-    // Find the smallest (innermost) function containing the cursor.\n-    let mut size = None;\n-    let mut fn_def = None;\n-    for (_, module) in def_map.modules() {\n-        let file_id = module.definition_source(db).file_id;\n-        if file_id != position.file_id.into() {\n-            continue;\n-        }\n-        let root = db.parse_or_expand(file_id).unwrap();\n-        let ast_map = db.ast_id_map(file_id);\n-        let item_tree = db.item_tree(file_id);\n-        for decl in module.scope.declarations() {\n-            if let ModuleDefId::FunctionId(it) = decl {\n-                let ast = ast_map.get(item_tree[it.lookup(db).id.value].ast_id).to_node(&root);\n-                let range = ast.syntax().text_range();\n-\n-                if !range.contains(position.offset) {\n-                    continue;\n-                }\n-\n-                let new_size = match size {\n-                    None => range.len(),\n-                    Some(size) => {\n-                        if range.len() < size {\n-                            range.len()\n-                        } else {\n-                            size\n-                        }\n-                    }\n-                };\n-                if size != Some(new_size) {\n-                    size = Some(new_size);\n-                    fn_def = Some(it);\n-                }\n-            }\n-        }\n-    }\n-\n-    let (body, source_map) = db.body_with_source_map(fn_def?.into());\n-\n-    // Now find the smallest encompassing block expression in the function body.\n-    let mut size = None;\n-    let mut block_id = None;\n-    for (expr_id, expr) in body.exprs.iter() {\n-        if let Expr::Block { id, .. } = expr {\n-            if let Ok(ast) = source_map.expr_syntax(expr_id) {\n-                if ast.file_id != position.file_id.into() {\n-                    continue;\n-                }\n-\n-                let root = db.parse_or_expand(ast.file_id).unwrap();\n-                let ast = ast.value.to_node(&root);\n-                let range = ast.syntax().text_range();\n-\n-                if !range.contains(position.offset) {\n-                    continue;\n-                }\n-\n-                let new_size = match size {\n-                    None => range.len(),\n-                    Some(size) => {\n-                        if range.len() < size {\n-                            range.len()\n-                        } else {\n-                            size\n-                        }\n-                    }\n-                };\n-                if size != Some(new_size) {\n-                    size = Some(new_size);\n-                    block_id = Some(*id);\n-                }\n-            }\n-        }\n-    }\n-\n-    Some(block_id.expect(\"can't find block containing cursor\"))\n+    let module = db.module_at_position(position);\n+    module.def_map(&db).dump(&db)\n }\n \n fn check_at(ra_fixture: &str, expect: Expect) {"}, {"sha": "a5ec0883fb83e26bb6c8c5141661cc741cf578e6", "filename": "crates/hir_def/src/body/tests/block.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -232,3 +232,30 @@ fn f() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn super_does_not_resolve_to_block_module() {\n+    check_at(\n+        r#\"\n+fn main() {\n+    struct Struct {}\n+    mod module {\n+        use super::Struct;\n+\n+        $0\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+        block scope\n+        Struct: t\n+        module: t\n+\n+        block scope::module\n+        Struct: _\n+\n+        crate\n+        main: v\n+    \"#]],\n+    );\n+}"}, {"sha": "5e2a711b84a5b6a6e5905685d0ef68f36b7d5241", "filename": "crates/hir_def/src/find_path.rs", "status": "modified", "additions": 91, "deletions": 10, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -13,8 +13,6 @@ use crate::{\n     ModuleDefId, ModuleId,\n };\n \n-// FIXME: handle local items\n-\n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n@@ -107,17 +105,17 @@ fn find_path_inner(\n \n     // - if the item is already in scope, return the name under which it is\n     let def_map = from.def_map(db);\n-    let from_scope: &crate::item_scope::ItemScope = &def_map[from.local_id].scope;\n-    let scope_name =\n-        if let Some((name, _)) = from_scope.name_of(item) { Some(name.clone()) } else { None };\n+    let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n+    });\n     if prefixed.is_none() && scope_name.is_some() {\n         return scope_name\n             .map(|scope_name| ModPath::from_segments(PathKind::Plain, vec![scope_name]));\n     }\n \n     // - if the item is the crate root, return `crate`\n     let root = def_map.module_id(def_map.root());\n-    if item == ItemInNs::Types(ModuleDefId::ModuleId(root)) {\n+    if item == ItemInNs::Types(ModuleDefId::ModuleId(root)) && def_map.block_id().is_none() {\n         return Some(ModPath::from_segments(PathKind::Crate, Vec::new()));\n     }\n \n@@ -230,7 +228,12 @@ fn find_path_inner(\n         }\n     }\n \n-    if let Some(prefix) = prefixed.map(PrefixKind::prefix) {\n+    if let Some(mut prefix) = prefixed.map(PrefixKind::prefix) {\n+        if matches!(prefix, PathKind::Crate | PathKind::Super(0)) && def_map.block_id().is_some() {\n+            // Inner items cannot be referred to via `crate::` or `self::` paths.\n+            prefix = PathKind::Plain;\n+        }\n+\n         best_path.or_else(|| {\n             scope_name.map(|scope_name| ModPath::from_segments(prefix, vec![scope_name]))\n         })\n@@ -358,14 +361,14 @@ mod tests {\n     /// module the cursor is in.\n     fn check_found_path_(ra_fixture: &str, path: &str, prefix_kind: Option<PrefixKind>) {\n         let (db, pos) = TestDB::with_position(ra_fixture);\n-        let module = db.module_for_file(pos.file_id);\n+        let module = db.module_at_position(pos);\n         let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n         let ast_path =\n             parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n         let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n \n-        let crate_def_map = module.def_map(&db);\n-        let resolved = crate_def_map\n+        let def_map = module.def_map(&db);\n+        let resolved = def_map\n             .resolve_path(\n                 &db,\n                 module.local_id,\n@@ -788,4 +791,82 @@ mod tests {\n         check_found_path(code, \"u8\", \"u8\", \"u8\", \"u8\");\n         check_found_path(code, \"u16\", \"u16\", \"u16\", \"u16\");\n     }\n+\n+    #[test]\n+    fn inner_items() {\n+        check_found_path(\n+            r#\"\n+            fn main() {\n+                struct Inner {}\n+                $0\n+            }\n+        \"#,\n+            \"Inner\",\n+            \"Inner\",\n+            \"Inner\",\n+            \"Inner\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_items_from_outer_scope() {\n+        check_found_path(\n+            r#\"\n+            fn main() {\n+                struct Struct {}\n+                {\n+                    $0\n+                }\n+            }\n+        \"#,\n+            \"Struct\",\n+            \"Struct\",\n+            \"Struct\",\n+            \"Struct\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_items_from_inner_module() {\n+        check_found_path(\n+            r#\"\n+            fn main() {\n+                mod module {\n+                    struct Struct {}\n+                }\n+                {\n+                    $0\n+                }\n+            }\n+        \"#,\n+            \"module::Struct\",\n+            \"module::Struct\",\n+            \"module::Struct\",\n+            \"module::Struct\",\n+        );\n+    }\n+\n+    #[test]\n+    #[ignore]\n+    fn inner_items_from_parent_module() {\n+        // FIXME: ItemTree currently associates all inner items with `main`. Luckily, this sort of\n+        // code is very rare, so this isn't terrible.\n+        // To fix it, we should probably build dedicated `ItemTree`s for inner items, and not store\n+        // them in the file's main ItemTree. This would also allow us to stop parsing function\n+        // bodies when we only want to compute the crate's main DefMap.\n+        check_found_path(\n+            r#\"\n+            fn main() {\n+                struct Struct {}\n+                mod module {\n+                    $0\n+                }\n+            }\n+        \"#,\n+            \"super::Struct\",\n+            \"super::Struct\",\n+            \"super::Struct\",\n+            \"super::Struct\",\n+        );\n+    }\n }"}, {"sha": "34ff07f3c4d07b1f1b0e023cca6dc8db1a6fd41c", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -316,7 +316,7 @@ impl DefMap {\n     ///\n     /// If `f` returns `Some(val)`, iteration is stopped and `Some(val)` is returned. If `f` returns\n     /// `None`, iteration continues.\n-    fn with_ancestor_maps<T>(\n+    pub fn with_ancestor_maps<T>(\n         &self,\n         db: &dyn DefDatabase,\n         local_mod: LocalModuleId,"}, {"sha": "a8467c88e6e0f5ef810c3413447d2e8c1282eb9c", "filename": "crates/hir_def/src/resolver.rs", "status": "modified", "additions": 97, "deletions": 118, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -10,7 +10,6 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     body::scope::{ExprScopes, ScopeId},\n-    body::Body,\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n@@ -58,8 +57,6 @@ enum Scope {\n     AdtScope(AdtId),\n     /// Local bindings\n     ExprScope(ExprScope),\n-    /// Temporary hack to support local items.\n-    LocalItemsScope(Arc<Body>),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -169,13 +166,7 @@ impl Resolver {\n         for scope in self.scopes.iter().rev() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams { .. }\n-                | Scope::ImplDefScope(_)\n-                | Scope::LocalItemsScope(_)\n-                    if skip_to_mod =>\n-                {\n-                    continue\n-                }\n+                Scope::GenericParams { .. } | Scope::ImplDefScope(_) if skip_to_mod => continue,\n \n                 Scope::GenericParams { params, def } => {\n                     if let Some(local_id) = params.find_type_by_name(first_name) {\n@@ -199,41 +190,13 @@ impl Resolver {\n                     }\n                 }\n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(\n-                        db,\n-                        m.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Other,\n-                    );\n-                    let res = to_type_ns(module_def)?;\n-                    return Some((res, idx));\n-                }\n-                Scope::LocalItemsScope(body) => {\n-                    let def = body.item_scope.get(first_name);\n-                    if let Some(res) = to_type_ns(def) {\n-                        return Some((res, None));\n+                    if let Some(res) = m.resolve_path_in_type_ns(db, path) {\n+                        return Some(res);\n                     }\n                 }\n             }\n         }\n-        return None;\n-        fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n-            let res = match per_ns.take_types()? {\n-                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n-                ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n-\n-                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n-                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n-\n-                ModuleDefId::FunctionId(_)\n-                | ModuleDefId::ConstId(_)\n-                | ModuleDefId::StaticId(_)\n-                | ModuleDefId::ModuleId(_) => return None,\n-            };\n-            Some(res)\n-        }\n+        None\n     }\n \n     pub fn resolve_path_in_type_ns_fully(\n@@ -280,7 +243,6 @@ impl Resolver {\n                 | Scope::ExprScope(_)\n                 | Scope::GenericParams { .. }\n                 | Scope::ImplDefScope(_)\n-                | Scope::LocalItemsScope(_)\n                     if skip_to_mod =>\n                 {\n                     continue\n@@ -335,63 +297,14 @@ impl Resolver {\n                 }\n \n                 Scope::ModuleScope(m) => {\n-                    let (module_def, idx) = m.crate_def_map.resolve_path(\n-                        db,\n-                        m.module_id,\n-                        &path,\n-                        BuiltinShadowMode::Other,\n-                    );\n-                    return match idx {\n-                        None => {\n-                            let value = to_value_ns(module_def)?;\n-                            Some(ResolveValueResult::ValueNs(value))\n-                        }\n-                        Some(idx) => {\n-                            let ty = match module_def.take_types()? {\n-                                ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n-                                ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n-                                ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n-                                ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n-\n-                                ModuleDefId::ModuleId(_)\n-                                | ModuleDefId::FunctionId(_)\n-                                | ModuleDefId::EnumVariantId(_)\n-                                | ModuleDefId::ConstId(_)\n-                                | ModuleDefId::StaticId(_) => return None,\n-                            };\n-                            Some(ResolveValueResult::Partial(ty, idx))\n-                        }\n-                    };\n-                }\n-                Scope::LocalItemsScope(body) => {\n-                    // we don't bother looking in the builtin scope here because there are no builtin values\n-                    let def = to_value_ns(body.item_scope.get(first_name));\n-\n-                    if let Some(res) = def {\n-                        return Some(ResolveValueResult::ValueNs(res));\n+                    if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                        return Some(def);\n                     }\n                 }\n             }\n         }\n-        return None;\n-\n-        fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n-            let res = match per_ns.take_values()? {\n-                ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n-                ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n-                ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n-                ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n-                ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n-\n-                ModuleDefId::AdtId(AdtId::EnumId(_))\n-                | ModuleDefId::AdtId(AdtId::UnionId(_))\n-                | ModuleDefId::TraitId(_)\n-                | ModuleDefId::TypeAliasId(_)\n-                | ModuleDefId::BuiltinType(_)\n-                | ModuleDefId::ModuleId(_) => return None,\n-            };\n-            Some(res)\n-        }\n+\n+        None\n     }\n \n     pub fn resolve_path_in_value_ns_fully(\n@@ -410,11 +323,6 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<MacroDefId> {\n-        // Search item scope legacy macro first\n-        if let Some(def) = self.resolve_local_macro_def(path) {\n-            return Some(def);\n-        }\n-\n         let (item_map, module) = self.module_scope()?;\n         item_map.resolve_path(db, module, &path, BuiltinShadowMode::Other).0.take_macros()\n     }\n@@ -447,16 +355,6 @@ impl Resolver {\n         })\n     }\n \n-    fn resolve_local_macro_def(&self, path: &ModPath) -> Option<MacroDefId> {\n-        let name = path.as_ident()?;\n-        self.scopes.iter().rev().find_map(|scope| {\n-            if let Scope::LocalItemsScope(body) = scope {\n-                return body.item_scope.get_legacy_macro(name);\n-            }\n-            None\n-        })\n-    }\n-\n     pub fn module(&self) -> Option<ModuleId> {\n         let (def_map, local_id) = self.module_scope()?;\n         Some(def_map.module_id(local_id))\n@@ -538,9 +436,6 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::LocalItemsScope(body) => body.item_scope.entries().for_each(|(name, def)| {\n-                f(name.clone(), ScopeDef::PerNs(def));\n-            }),\n             &Scope::GenericParams { ref params, def: parent } => {\n                 for (local_id, param) in params.types.iter() {\n                     if let Some(ref name) = param.name {\n@@ -584,10 +479,19 @@ pub fn resolver_for_scope(\n     scope_id: Option<ScopeId>,\n ) -> Resolver {\n     let mut r = owner.resolver(db);\n-    r = r.push_local_items_scope(db.body(owner));\n     let scopes = db.expr_scopes(owner);\n     let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n+        if let Some(block) = scopes.block(scope) {\n+            if let Some(def_map) = db.block_def_map(block) {\n+                let root = def_map.root();\n+                r = r.push_module_scope(def_map, root);\n+                // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n+                // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n+                // innermost module scope instead?\n+            }\n+        }\n+\n         r = r.push_expr_scope(owner, Arc::clone(&scopes), scope);\n     }\n     r\n@@ -612,10 +516,6 @@ impl Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }\n \n-    fn push_local_items_scope(self, body: Arc<Body>) -> Resolver {\n-        self.push_scope(Scope::LocalItemsScope(body))\n-    }\n-\n     fn push_expr_scope(\n         self,\n         owner: DefWithBodyId,\n@@ -626,6 +526,85 @@ impl Resolver {\n     }\n }\n \n+impl ModuleItemMap {\n+    fn resolve_path_in_value_ns(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<ResolveValueResult> {\n+        let (module_def, idx) =\n+            self.crate_def_map.resolve_path(db, self.module_id, &path, BuiltinShadowMode::Other);\n+        match idx {\n+            None => {\n+                let value = to_value_ns(module_def)?;\n+                Some(ResolveValueResult::ValueNs(value))\n+            }\n+            Some(idx) => {\n+                let ty = match module_def.take_types()? {\n+                    ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+                    ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+                    ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n+                    ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+                    ModuleDefId::ModuleId(_)\n+                    | ModuleDefId::FunctionId(_)\n+                    | ModuleDefId::EnumVariantId(_)\n+                    | ModuleDefId::ConstId(_)\n+                    | ModuleDefId::StaticId(_) => return None,\n+                };\n+                Some(ResolveValueResult::Partial(ty, idx))\n+            }\n+        }\n+    }\n+\n+    fn resolve_path_in_type_ns(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+    ) -> Option<(TypeNs, Option<usize>)> {\n+        let (module_def, idx) =\n+            self.crate_def_map.resolve_path(db, self.module_id, &path, BuiltinShadowMode::Other);\n+        let res = to_type_ns(module_def)?;\n+        Some((res, idx))\n+    }\n+}\n+\n+fn to_value_ns(per_ns: PerNs) -> Option<ValueNs> {\n+    let res = match per_ns.take_values()? {\n+        ModuleDefId::FunctionId(it) => ValueNs::FunctionId(it),\n+        ModuleDefId::AdtId(AdtId::StructId(it)) => ValueNs::StructId(it),\n+        ModuleDefId::EnumVariantId(it) => ValueNs::EnumVariantId(it),\n+        ModuleDefId::ConstId(it) => ValueNs::ConstId(it),\n+        ModuleDefId::StaticId(it) => ValueNs::StaticId(it),\n+\n+        ModuleDefId::AdtId(AdtId::EnumId(_))\n+        | ModuleDefId::AdtId(AdtId::UnionId(_))\n+        | ModuleDefId::TraitId(_)\n+        | ModuleDefId::TypeAliasId(_)\n+        | ModuleDefId::BuiltinType(_)\n+        | ModuleDefId::ModuleId(_) => return None,\n+    };\n+    Some(res)\n+}\n+\n+fn to_type_ns(per_ns: PerNs) -> Option<TypeNs> {\n+    let res = match per_ns.take_types()? {\n+        ModuleDefId::AdtId(it) => TypeNs::AdtId(it),\n+        ModuleDefId::EnumVariantId(it) => TypeNs::EnumVariantId(it),\n+\n+        ModuleDefId::TypeAliasId(it) => TypeNs::TypeAliasId(it),\n+        ModuleDefId::BuiltinType(it) => TypeNs::BuiltinType(it),\n+\n+        ModuleDefId::TraitId(it) => TypeNs::TraitId(it),\n+\n+        ModuleDefId::FunctionId(_)\n+        | ModuleDefId::ConstId(_)\n+        | ModuleDefId::StaticId(_)\n+        | ModuleDefId::ModuleId(_) => return None,\n+    };\n+    Some(res)\n+}\n+\n pub trait HasResolver: Copy {\n     /// Builds a resolver for type references inside this def.\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver;"}, {"sha": "eda982c85e18427c8dd142255d4e9f9ec8ea880a", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 95, "deletions": 4, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a9ab725093b5f6501ed086973906ebb77805ff/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=96a9ab725093b5f6501ed086973906ebb77805ff", "patch": "@@ -5,17 +5,17 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, Upcast};\n+use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, FilePosition, Upcast};\n use base_db::{AnchoredPath, SourceDatabase};\n-use hir_expand::db::AstDatabase;\n use hir_expand::diagnostics::Diagnostic;\n use hir_expand::diagnostics::DiagnosticSinkBuilder;\n+use hir_expand::{db::AstDatabase, InFile};\n use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n-use syntax::{TextRange, TextSize};\n+use syntax::{algo, ast, AstNode, TextRange, TextSize};\n use test_utils::extract_annotations;\n \n-use crate::{db::DefDatabase, ModuleDefId, ModuleId};\n+use crate::{db::DefDatabase, nameres::DefMap, Lookup, ModuleDefId, ModuleId};\n \n #[salsa::database(\n     base_db::SourceDatabaseExtStorage,\n@@ -84,6 +84,97 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n+    pub(crate) fn module_at_position(&self, position: FilePosition) -> ModuleId {\n+        let file_module = self.module_for_file(position.file_id);\n+        let mut def_map = file_module.def_map(self);\n+\n+        def_map = match self.block_at_position(&def_map, position) {\n+            Some(it) => it,\n+            None => return file_module,\n+        };\n+        loop {\n+            let new_map = self.block_at_position(&def_map, position);\n+            match new_map {\n+                Some(new_block) if !Arc::ptr_eq(&new_block, &def_map) => {\n+                    def_map = new_block;\n+                }\n+                _ => {\n+                    // FIXME: handle `mod` inside block expression\n+                    return def_map.module_id(def_map.root());\n+                }\n+            }\n+        }\n+    }\n+\n+    fn block_at_position(&self, def_map: &DefMap, position: FilePosition) -> Option<Arc<DefMap>> {\n+        // Find the smallest (innermost) function in `def_map` containing the cursor.\n+        let mut size = None;\n+        let mut fn_def = None;\n+        for (_, module) in def_map.modules() {\n+            let file_id = module.definition_source(self).file_id;\n+            if file_id != position.file_id.into() {\n+                continue;\n+            }\n+            let root = self.parse_or_expand(file_id).unwrap();\n+            let ast_map = self.ast_id_map(file_id);\n+            let item_tree = self.item_tree(file_id);\n+            for decl in module.scope.declarations() {\n+                if let ModuleDefId::FunctionId(it) = decl {\n+                    let ast =\n+                        ast_map.get(item_tree[it.lookup(self).id.value].ast_id).to_node(&root);\n+                    let range = ast.syntax().text_range();\n+\n+                    if !range.contains(position.offset) {\n+                        continue;\n+                    }\n+\n+                    let new_size = match size {\n+                        None => range.len(),\n+                        Some(size) => {\n+                            if range.len() < size {\n+                                range.len()\n+                            } else {\n+                                size\n+                            }\n+                        }\n+                    };\n+                    if size != Some(new_size) {\n+                        size = Some(new_size);\n+                        fn_def = Some(it);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Find the innermost block expression that has a `DefMap`.\n+        let def_with_body = fn_def?.into();\n+        let (_, source_map) = self.body_with_source_map(def_with_body);\n+        let scopes = self.expr_scopes(def_with_body);\n+        let root = self.parse(position.file_id);\n+\n+        let scope_iter = algo::ancestors_at_offset(&root.syntax_node(), position.offset)\n+            .filter_map(|node| {\n+                let block = ast::BlockExpr::cast(node)?;\n+                let expr = ast::Expr::from(block);\n+                let expr_id = source_map.node_expr(InFile::new(position.file_id.into(), &expr))?;\n+                let scope = scopes.scope_for(expr_id).unwrap();\n+                Some(scope)\n+            });\n+\n+        for scope in scope_iter {\n+            let containing_blocks =\n+                scopes.scope_chain(Some(scope)).filter_map(|scope| scopes.block(scope));\n+\n+            for block in containing_blocks {\n+                if let Some(def_map) = self.block_def_map(block) {\n+                    return Some(def_map);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event> {\n         *self.events.lock().unwrap() = Some(Vec::new());\n         f();"}]}