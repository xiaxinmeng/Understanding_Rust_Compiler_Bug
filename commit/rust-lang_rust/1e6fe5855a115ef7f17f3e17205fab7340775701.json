{"sha": "1e6fe5855a115ef7f17f3e17205fab7340775701", "node_id": "C_kwDOAAsO6NoAKDFlNmZlNTg1NWExMTVlZjdmMTdmM2UxNzIwNWZhYjczNDA3NzU3MDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T15:47:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-15T15:47:17Z"}, "message": "Auto merge of #94079 - petrochenkov:cstr, r=joshtriplett\n\nlibrary: Move `CStr` to libcore, and `CString` to liballoc\n\nCloses https://github.com/rust-lang/rust/issues/46736\n\nInteresting points:\n- Stability:\n    - To make `CStr(ing)` from libcore/liballoc unusable without enabling features I had to make these structures unstable, and reexport them from libstd using stable type aliases instead of `pub use` reexports. (Because stability of `use` items is not checked.)\n- Relying on target ABI in libcore is ok:\n    - https://github.com/rust-lang/rust/pull/94079#issuecomment-1044263371\n- `trait CStrExt` (UPDATE: used only in `cfg(bootstrap)` mode, otherwise lang items are used instead)\n    - https://github.com/rust-lang/rust/pull/94079#issuecomment-1047863450\n- `strlen`\n    - https://github.com/rust-lang/rust/pull/94079#issuecomment-1047863450\n\nOtherwise it's just a code move + some minor hackery usual for liballoc in `cfg(test)` mode.", "tree": {"sha": "10d4001f37a7a8f4780f878f9d72f9e60fc9ad73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10d4001f37a7a8f4780f878f9d72f9e60fc9ad73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e6fe5855a115ef7f17f3e17205fab7340775701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e6fe5855a115ef7f17f3e17205fab7340775701", "html_url": "https://github.com/rust-lang/rust/commit/1e6fe5855a115ef7f17f3e17205fab7340775701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e6fe5855a115ef7f17f3e17205fab7340775701/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69a5ae35fe5bb507ca5987e12392dce5186480b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/69a5ae35fe5bb507ca5987e12392dce5186480b9", "html_url": "https://github.com/rust-lang/rust/commit/69a5ae35fe5bb507ca5987e12392dce5186480b9"}, {"sha": "f62c84e6b9b9720c2a49279843029b1c50fec54e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f62c84e6b9b9720c2a49279843029b1c50fec54e", "html_url": "https://github.com/rust-lang/rust/commit/f62c84e6b9b9720c2a49279843029b1c50fec54e"}], "stats": {"total": 1635, "additions": 940, "deletions": 695}, "files": [{"sha": "9eba61f8d293b64253f12af8745b21b5e76d2f67", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -731,9 +731,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.70\"\n+version = \"0.1.71\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80873f979f0a344a4ade87c2f70d9ccf5720b83b10c97ec7cd745895d021e85a\"\n+checksum = \"163437f05ca8f29d7e9128ea728dedf5eb620e445fbca273641d3a3050305f23\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\","}, {"sha": "9318ebb40b09ba66f267554ab8eb91e17f632257", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -326,6 +326,8 @@ language_item_table! {\n     Range,                   sym::Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n     RangeToInclusive,        sym::RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n     RangeTo,                 sym::RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+\n+    CStr,                    sym::CStr,                c_str,                      Target::Struct,         GenericRequirement::None;\n }\n \n pub enum GenericRequirement {"}, {"sha": "566d27212d08dcbfee7b44a6f50553222b1b69d5", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -417,6 +417,7 @@ impl<'a> CrateLoader<'a> {\n \n         let crate_metadata = CrateMetadata::new(\n             self.sess,\n+            &self.cstore,\n             metadata,\n             crate_root,\n             raw_proc_macros,"}, {"sha": "8d0e8467404cae2939cdc0be9dd816f4605e3e72", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,6 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n-use crate::creader::CrateMetadataRef;\n+use crate::creader::{CStore, CrateMetadataRef};\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n@@ -1737,6 +1737,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n impl CrateMetadata {\n     crate fn new(\n         sess: &Session,\n+        cstore: &CStore,\n         blob: MetadataBlob,\n         root: CrateRoot<'static>,\n         raw_proc_macros: Option<&'static [ProcMacro]>,\n@@ -1752,11 +1753,6 @@ impl CrateMetadata {\n             .decode((&blob, sess))\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n-        let incoherent_impls = root\n-            .incoherent_impls\n-            .decode((&blob, sess))\n-            .map(|incoherent_impls| (incoherent_impls.self_ty, incoherent_impls.impls))\n-            .collect();\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n         let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n@@ -1765,11 +1761,11 @@ impl CrateMetadata {\n         // that does not copy any data. It just does some data verification.\n         let def_path_hash_map = root.def_path_hash_map.decode(&blob);\n \n-        CrateMetadata {\n+        let mut cdata = CrateMetadata {\n             blob,\n             root,\n             trait_impls,\n-            incoherent_impls,\n+            incoherent_impls: Default::default(),\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n             def_path_hash_map,\n@@ -1786,7 +1782,17 @@ impl CrateMetadata {\n             hygiene_context: Default::default(),\n             def_key_cache: Default::default(),\n             def_path_hash_cache: Default::default(),\n-        }\n+        };\n+\n+        // Need `CrateMetadataRef` to decode `DefId`s in simplified types.\n+        cdata.incoherent_impls = cdata\n+            .root\n+            .incoherent_impls\n+            .decode(CrateMetadataRef { cdata: &cdata, cstore })\n+            .map(|incoherent_impls| (incoherent_impls.self_ty, incoherent_impls.impls))\n+            .collect();\n+\n+        cdata\n     }\n \n     crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {"}, {"sha": "e04cc42b6d7e5f56631bde132508a0dffbc6148d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -644,7 +644,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n-                self.assemble_inherent_impl_candidates_for_type(def.did());\n+                let def_id = def.did();\n+                self.assemble_inherent_impl_candidates_for_type(def_id);\n+                if Some(def_id) == self.tcx.lang_items().c_str() {\n+                    self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty);\n+                }\n             }\n             ty::Foreign(did) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);"}, {"sha": "5ad0c4ac52d49c45f5dd614ce9bd50bebdd0ea50", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -55,7 +55,12 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n         let self_ty = self.tcx.type_of(item.def_id);\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n-                self.check_def_id(item, def.did());\n+                let def_id = def.did();\n+                if !def_id.is_local() && Some(def_id) == self.tcx.lang_items().c_str() {\n+                    self.check_primitive_impl(item.def_id, self_ty, items, ty.span)\n+                } else {\n+                    self.check_def_id(item, def_id);\n+                }\n             }\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);"}, {"sha": "172a008e89a06486d7787fba36198747be9d14cc", "filename": "library/alloc/src/ffi/c_str.rs", "status": "renamed", "additions": 132, "deletions": 611, "changes": 743, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fffi%2Fc_str.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,25 +1,25 @@\n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n #[cfg(test)]\n mod tests;\n \n-use crate::ascii;\n-use crate::borrow::{Borrow, Cow};\n-use crate::cmp::Ordering;\n-use crate::error::Error;\n-use crate::fmt::{self, Write};\n-use crate::io;\n-use crate::mem;\n-use crate::num::NonZeroU8;\n-use crate::ops;\n-use crate::os::raw::c_char;\n-use crate::ptr;\n+use crate::borrow::{Cow, ToOwned};\n+use crate::boxed::Box;\n use crate::rc::Rc;\n-use crate::slice;\n-use crate::str::{self, Utf8Error};\n+use crate::slice::hack::into_vec;\n+use crate::string::String;\n+use crate::vec::Vec;\n+use core::borrow::Borrow;\n+use core::ffi::{c_char, CStr};\n+use core::fmt;\n+use core::mem;\n+use core::num::NonZeroU8;\n+use core::ops;\n+use core::ptr;\n+use core::slice;\n+use core::slice::memchr;\n+use core::str::{self, Utf8Error};\n+\n+#[cfg(target_has_atomic = \"ptr\")]\n use crate::sync::Arc;\n-use crate::sys;\n-use crate::sys_common::memchr;\n \n /// A type representing an owned, C-compatible, nul-terminated string with no nul bytes in the\n /// middle.\n@@ -108,98 +108,14 @@ use crate::sys_common::memchr;\n /// and other memory errors.\n #[derive(PartialEq, PartialOrd, Eq, Ord, Hash, Clone)]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"cstring_type\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n pub struct CString {\n     // Invariant 1: the slice ends with a zero byte and has a length of at least one.\n     // Invariant 2: the slice contains only one zero byte.\n     // Improper usage of unsafe function can break Invariant 2, but not Invariant 1.\n     inner: Box<[u8]>,\n }\n \n-/// Representation of a borrowed C string.\n-///\n-/// This type represents a borrowed reference to a nul-terminated\n-/// array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n-/// slice, or unsafely from a raw `*const c_char`. It can then be\n-/// converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or\n-/// into an owned [`CString`].\n-///\n-/// `&CStr` is to [`CString`] as <code>&[str]</code> is to [`String`]: the former\n-/// in each pair are borrowed references; the latter are owned\n-/// strings.\n-///\n-/// Note that this structure is **not** `repr(C)` and is not recommended to be\n-/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n-/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n-/// a safe interface to other consumers.\n-///\n-/// # Examples\n-///\n-/// Inspecting a foreign C string:\n-///\n-/// ```ignore (extern-declaration)\n-/// use std::ffi::CStr;\n-/// use std::os::raw::c_char;\n-///\n-/// extern \"C\" { fn my_string() -> *const c_char; }\n-///\n-/// unsafe {\n-///     let slice = CStr::from_ptr(my_string());\n-///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n-/// }\n-/// ```\n-///\n-/// Passing a Rust-originating C string:\n-///\n-/// ```ignore (extern-declaration)\n-/// use std::ffi::{CString, CStr};\n-/// use std::os::raw::c_char;\n-///\n-/// fn work(data: &CStr) {\n-///     extern \"C\" { fn work_with(data: *const c_char); }\n-///\n-///     unsafe { work_with(data.as_ptr()) }\n-/// }\n-///\n-/// let s = CString::new(\"data data data data\").expect(\"CString::new failed\");\n-/// work(&s);\n-/// ```\n-///\n-/// Converting a foreign C string into a Rust [`String`]:\n-///\n-/// ```ignore (extern-declaration)\n-/// use std::ffi::CStr;\n-/// use std::os::raw::c_char;\n-///\n-/// extern \"C\" { fn my_string() -> *const c_char; }\n-///\n-/// fn my_string_safe() -> String {\n-///     unsafe {\n-///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n-///     }\n-/// }\n-///\n-/// println!(\"string: {}\", my_string_safe());\n-/// ```\n-///\n-/// [str]: prim@str \"str\"\n-#[derive(Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-// FIXME:\n-// `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n-// on `CStr` being layout-compatible with `[u8]`.\n-// When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.\n-// Anyway, `CStr` representation and layout are considered implementation detail, are\n-// not documented and must not be relied upon.\n-pub struct CStr {\n-    // FIXME: this should not be represented with a DST slice but rather with\n-    //        just a raw `c_char` along with some form of marker to make\n-    //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n-    //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n-    inner: [c_char],\n-}\n-\n /// An error indicating that an interior nul byte was found.\n ///\n /// While Rust strings may contain nul bytes in the middle, C strings\n@@ -216,28 +132,13 @@ pub struct CStr {\n /// let _: NulError = CString::new(b\"f\\0oo\".to_vec()).unwrap_err();\n /// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// An error indicating that a nul byte was not in the expected position.\n-///\n-/// The slice used to create a [`CStr`] must have one and only one nul byte,\n-/// positioned at the end.\n-///\n-/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n-/// See its documentation for more.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::ffi::{CStr, FromBytesWithNulError};\n-///\n-/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n-/// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-pub struct FromBytesWithNulError {\n-    kind: FromBytesWithNulErrorKind,\n+enum FromBytesWithNulErrorKind {\n+    InteriorNul(usize),\n+    NotNulTerminated,\n }\n \n /// An error indicating that a nul byte was not in the expected position.\n@@ -256,27 +157,12 @@ pub struct FromBytesWithNulError {\n /// let _: FromVecWithNulError = CString::from_vec_with_nul(b\"f\\0oo\".to_vec()).unwrap_err();\n /// ```\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n pub struct FromVecWithNulError {\n     error_kind: FromBytesWithNulErrorKind,\n     bytes: Vec<u8>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum FromBytesWithNulErrorKind {\n-    InteriorNul(usize),\n-    NotNulTerminated,\n-}\n-\n-impl FromBytesWithNulError {\n-    fn interior_nul(pos: usize) -> FromBytesWithNulError {\n-        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::InteriorNul(pos) }\n-    }\n-    fn not_nul_terminated() -> FromBytesWithNulError {\n-        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::NotNulTerminated }\n-    }\n-}\n-\n #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n impl FromVecWithNulError {\n     /// Returns a slice of [`u8`]s bytes that were attempted to convert to a [`CString`].\n@@ -328,27 +214,6 @@ impl FromVecWithNulError {\n     }\n }\n \n-/// An error indicating that no nul byte was present.\n-///\n-/// A slice used to create a [`CStr`] must contain a nul byte somewhere\n-/// within the slice.\n-///\n-/// This error is created by the [`CStr::from_bytes_until_nul`] method.\n-///\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n-pub struct FromBytesUntilNulError(());\n-\n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n-impl Error for FromBytesUntilNulError {}\n-\n-#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n-impl fmt::Display for FromBytesUntilNulError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"data provided does not contain a nul\")\n-    }\n-}\n-\n /// An error indicating invalid UTF-8 when converting a [`CString`] into a [`String`].\n ///\n /// `CString` is just a wrapper over a buffer of bytes with a nul terminator;\n@@ -358,7 +223,7 @@ impl fmt::Display for FromBytesUntilNulError {\n /// This `struct` is created by [`CString::into_string()`]. See\n /// its documentation for more.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n pub struct IntoStringError {\n     inner: CString,\n     error: Utf8Error,\n@@ -536,7 +401,11 @@ impl CString {\n         // information about the size of the allocation is correct on Rust's\n         // side.\n         unsafe {\n-            let len = sys::strlen(ptr) + 1; // Including the NUL byte\n+            extern \"C\" {\n+                /// Provided by libc or compiler_builtins.\n+                fn strlen(s: *const c_char) -> usize;\n+            }\n+            let len = strlen(ptr) + 1; // Including the NUL byte\n             let slice = slice::from_raw_parts_mut(ptr, len as usize);\n             CString { inner: Box::from_raw(slice as *mut [c_char] as *mut [u8]) }\n         }\n@@ -626,7 +495,7 @@ impl CString {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n-        let mut vec = self.into_inner().into_vec();\n+        let mut vec = into_vec(self.into_inner());\n         let _nul = vec.pop();\n         debug_assert_eq!(_nul, Some(0u8));\n         vec\n@@ -647,7 +516,7 @@ impl CString {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes_with_nul(self) -> Vec<u8> {\n-        self.into_inner().into_vec()\n+        into_vec(self.into_inner())\n     }\n \n     /// Returns the contents of this `CString` as a slice of bytes.\n@@ -842,7 +711,7 @@ impl ops::Deref for CString {\n \n     #[inline]\n     fn deref(&self) -> &CStr {\n-        unsafe { CStr::_from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n+        unsafe { CStr::from_bytes_with_nul_unchecked(self.as_bytes_with_nul()) }\n     }\n }\n \n@@ -864,25 +733,6 @@ impl From<CString> for Vec<u8> {\n     }\n }\n \n-#[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\n-impl fmt::Debug for CStr {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"\\\"\")?;\n-        for byte in self.to_bytes().iter().flat_map(|&b| ascii::escape_default(b)) {\n-            f.write_char(byte as char)?;\n-        }\n-        write!(f, \"\\\"\")\n-    }\n-}\n-\n-#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n-impl Default for &CStr {\n-    fn default() -> Self {\n-        const SLICE: &[c_char] = &[0];\n-        unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n-    }\n-}\n-\n #[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n impl Default for CString {\n     /// Creates an empty `CString`.\n@@ -910,6 +760,7 @@ impl<'a> From<Cow<'a, CStr>> for CString {\n     }\n }\n \n+#[cfg(not(test))]\n #[stable(feature = \"box_from_c_str\", since = \"1.17.0\")]\n impl From<&CStr> for Box<CStr> {\n     /// Converts a `&CStr` into a `Box<CStr>`,\n@@ -938,7 +789,8 @@ impl From<Box<CStr>> for CString {\n     /// Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n-        s.into_c_string()\n+        let raw = Box::into_raw(s) as *mut [u8];\n+        CString { inner: unsafe { Box::from_raw(raw) } }\n     }\n }\n \n@@ -964,6 +816,7 @@ impl From<Vec<NonZeroU8>> for CString {\n     }\n }\n \n+#[cfg(not(test))]\n #[stable(feature = \"more_box_slice_clone\", since = \"1.29.0\")]\n impl Clone for Box<CStr> {\n     #[inline]\n@@ -1008,6 +861,7 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n     }\n }\n \n+#[cfg(target_has_atomic = \"ptr\")]\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n     /// Converts a [`CString`] into an <code>[Arc]<[CStr]></code> by moving the [`CString`]\n@@ -1019,6 +873,7 @@ impl From<CString> for Arc<CStr> {\n     }\n }\n \n+#[cfg(target_has_atomic = \"ptr\")]\n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<&CStr> for Arc<CStr> {\n     /// Converts a `&CStr` into a `Arc<CStr>`,\n@@ -1052,6 +907,7 @@ impl From<&CStr> for Rc<CStr> {\n     }\n }\n \n+#[cfg(not(test))]\n #[stable(feature = \"default_box_extra\", since = \"1.17.0\")]\n impl Default for Box<CStr> {\n     fn default() -> Box<CStr> {\n@@ -1099,57 +955,13 @@ impl NulError {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for NulError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        \"nul byte found in data\"\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for NulError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"nul byte found in provided data at position: {}\", self.0)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl From<NulError> for io::Error {\n-    /// Converts a [`NulError`] into a [`io::Error`].\n-    fn from(_: NulError) -> io::Error {\n-        io::const_io_error!(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n-    }\n-}\n-\n-#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n-impl Error for FromBytesWithNulError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        match self.kind {\n-            FromBytesWithNulErrorKind::InteriorNul(..) => {\n-                \"data provided contains an interior nul byte\"\n-            }\n-            FromBytesWithNulErrorKind::NotNulTerminated => \"data provided is not nul terminated\",\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n-impl fmt::Display for FromBytesWithNulError {\n-    #[allow(deprecated, deprecated_in_future)]\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(self.description())?;\n-        if let FromBytesWithNulErrorKind::InteriorNul(pos) = self.kind {\n-            write!(f, \" at byte pos {pos}\")?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n-impl Error for FromVecWithNulError {}\n-\n #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n impl fmt::Display for FromVecWithNulError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -1179,18 +991,18 @@ impl IntoStringError {\n     pub fn utf8_error(&self) -> Utf8Error {\n         self.error\n     }\n+\n+    #[doc(hidden)]\n+    #[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+    pub fn __source(&self) -> &Utf8Error {\n+        &self.error\n+    }\n }\n \n-#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n-impl Error for IntoStringError {\n-    #[allow(deprecated)]\n+impl IntoStringError {\n     fn description(&self) -> &str {\n         \"C string contained non-utf8 bytes\"\n     }\n-\n-    fn source(&self) -> Option<&(dyn Error + 'static)> {\n-        Some(&self.error)\n-    }\n }\n \n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n@@ -1201,327 +1013,126 @@ impl fmt::Display for IntoStringError {\n     }\n }\n \n-impl CStr {\n-    /// Wraps a raw C string with a safe C string wrapper.\n-    ///\n-    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n-    /// allows inspection and interoperation of non-owned C strings. The total\n-    /// size of the raw C string must be smaller than `isize::MAX` **bytes**\n-    /// in memory due to calling the `slice::from_raw_parts` function.\n-    /// This method is unsafe for a number of reasons:\n-    ///\n-    /// * There is no guarantee to the validity of `ptr`.\n-    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n-    ///   `ptr`.\n-    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n-    ///   valid nul terminator byte at the end of the string.\n-    /// * It is not guaranteed that the memory pointed by `ptr` won't change\n-    ///   before the `CStr` has been destroyed.\n-    ///\n-    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n-    /// > currently implemented with an up-front calculation of the length of\n-    /// > the string. This is not guaranteed to always be the case.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore (extern-declaration)\n-    /// # fn main() {\n-    /// use std::ffi::CStr;\n-    /// use std::os::raw::c_char;\n-    ///\n-    /// extern \"C\" {\n-    ///     fn my_string() -> *const c_char;\n-    /// }\n-    ///\n-    /// unsafe {\n-    ///     let slice = CStr::from_ptr(my_string());\n-    ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n-    /// }\n-    /// # }\n-    /// ```\n-    #[inline]\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n-        // SAFETY: The caller has provided a pointer that points to a valid C\n-        // string with a NUL terminator of size less than `isize::MAX`, whose\n-        // content remain valid and doesn't change for the lifetime of the\n-        // returned `CStr`.\n-        //\n-        // Thus computing the length is fine (a NUL byte exists), the call to\n-        // from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning\n-        // the call to `from_bytes_with_nul_unchecked` is correct.\n-        //\n-        // The cast from c_char to u8 is ok because a c_char is always one byte.\n-        unsafe {\n-            let len = sys::strlen(ptr);\n-            let ptr = ptr as *const u8;\n-            Self::_from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n-        }\n-    }\n+#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\n+impl ToOwned for CStr {\n+    type Owned = CString;\n \n-    /// Creates a C string wrapper from a byte slice.\n-    ///\n-    /// This method will create a `CStr` from any byte slice that contains at\n-    /// least one nul byte. The caller does not need to know or specify where\n-    /// the nul byte is located.\n-    ///\n-    /// If the first byte is a nul character, this method will return an\n-    /// empty `CStr`. If multiple nul characters are present, the `CStr` will\n-    /// end at the first one.\n-    ///\n-    /// If the slice only has a single nul byte at the end, this method is\n-    /// equivalent to [`CStr::from_bytes_with_nul`].\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// #![feature(cstr_from_bytes_until_nul)]\n-    ///\n-    /// use std::ffi::CStr;\n-    ///\n-    /// let mut buffer = [0u8; 16];\n-    /// unsafe {\n-    ///     // Here we might call an unsafe C function that writes a string\n-    ///     // into the buffer.\n-    ///     let buf_ptr = buffer.as_mut_ptr();\n-    ///     buf_ptr.write_bytes(b'A', 8);\n-    /// }\n-    /// // Attempt to extract a C nul-terminated string from the buffer.\n-    /// let c_str = CStr::from_bytes_until_nul(&buffer[..]).unwrap();\n-    /// assert_eq!(c_str.to_str().unwrap(), \"AAAAAAAA\");\n-    /// ```\n-    ///\n-    #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n-    pub fn from_bytes_until_nul(bytes: &[u8]) -> Result<&CStr, FromBytesUntilNulError> {\n-        let nul_pos = memchr::memchr(0, bytes);\n-        match nul_pos {\n-            Some(nul_pos) => {\n-                // SAFETY: We know there is a nul byte at nul_pos, so this slice\n-                // (ending at the nul byte) is a well-formed C string.\n-                let subslice = &bytes[..nul_pos + 1];\n-                Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })\n-            }\n-            None => Err(FromBytesUntilNulError(())),\n-        }\n+    fn to_owned(&self) -> CString {\n+        CString { inner: self.to_bytes_with_nul().into() }\n     }\n \n-    /// Creates a C string wrapper from a byte slice.\n-    ///\n-    /// This function will cast the provided `bytes` to a `CStr`\n-    /// wrapper after ensuring that the byte slice is nul-terminated\n-    /// and does not contain any interior nul bytes.\n-    ///\n-    /// If the nul byte may not be at the end,\n-    /// [`CStr::from_bytes_until_nul`] can be used instead.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ffi::CStr;\n-    ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n-    /// assert!(cstr.is_ok());\n-    /// ```\n-    ///\n-    /// Creating a `CStr` without a trailing nul terminator is an error:\n-    ///\n-    /// ```\n-    /// use std::ffi::CStr;\n-    ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n-    /// assert!(cstr.is_err());\n-    /// ```\n-    ///\n-    /// Creating a `CStr` with an interior nul byte is an error:\n-    ///\n-    /// ```\n-    /// use std::ffi::CStr;\n-    ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n-    /// assert!(cstr.is_err());\n-    /// ```\n-    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-    pub fn from_bytes_with_nul(bytes: &[u8]) -> Result<&Self, FromBytesWithNulError> {\n-        let nul_pos = memchr::memchr(0, bytes);\n-        match nul_pos {\n-            Some(nul_pos) if nul_pos + 1 == bytes.len() => {\n-                // SAFETY: We know there is only one nul byte, at the end\n-                // of the byte slice.\n-                Ok(unsafe { Self::_from_bytes_with_nul_unchecked(bytes) })\n-            }\n-            Some(nul_pos) => Err(FromBytesWithNulError::interior_nul(nul_pos)),\n-            None => Err(FromBytesWithNulError::not_nul_terminated()),\n-        }\n+    fn clone_into(&self, target: &mut CString) {\n+        let mut b = into_vec(mem::take(&mut target.inner));\n+        self.to_bytes_with_nul().clone_into(&mut b);\n+        target.inner = b.into_boxed_slice();\n     }\n+}\n \n-    /// Unsafely creates a C string wrapper from a byte slice.\n-    ///\n-    /// This function will cast the provided `bytes` to a `CStr` wrapper without\n-    /// performing any sanity checks. The provided slice **must** be nul-terminated\n-    /// and not contain any interior nul bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::ffi::{CStr, CString};\n-    ///\n-    /// unsafe {\n-    ///     let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n-    ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n-    ///     assert_eq!(cstr, &*cstring);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[must_use]\n-    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-    #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n-    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n-        // We're in a const fn, so this is the best we can do\n-        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n-        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n+#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n+impl From<&CStr> for CString {\n+    fn from(s: &CStr) -> CString {\n+        s.to_owned()\n     }\n+}\n+\n+#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n+impl ops::Index<ops::RangeFull> for CString {\n+    type Output = CStr;\n \n     #[inline]\n-    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &Self {\n-        // SAFETY: Casting to CStr is safe because its internal representation\n-        // is a [u8] too (safe only inside std).\n-        // Dereferencing the obtained pointer is safe because it comes from a\n-        // reference. Making a reference is then safe because its lifetime\n-        // is bound by the lifetime of the given `bytes`.\n-        unsafe { &*(bytes as *const [u8] as *const Self) }\n+    fn index(&self, _index: ops::RangeFull) -> &CStr {\n+        self\n     }\n+}\n \n-    /// Returns the inner pointer to this C string.\n-    ///\n-    /// The returned pointer will be valid for as long as `self` is, and points\n-    /// to a contiguous region of memory terminated with a 0 byte to represent\n-    /// the end of the string.\n-    ///\n-    /// **WARNING**\n-    ///\n-    /// The returned pointer is read-only; writing to it (including passing it\n-    /// to C code that writes to it) causes undefined behavior.\n-    ///\n-    /// It is your responsibility to make sure that the underlying memory is not\n-    /// freed too early. For example, the following code will cause undefined\n-    /// behavior when `ptr` is used inside the `unsafe` block:\n-    ///\n-    /// ```no_run\n-    /// # #![allow(unused_must_use)] #![allow(temporary_cstring_as_ptr)]\n-    /// use std::ffi::CString;\n-    ///\n-    /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n-    /// unsafe {\n-    ///     // `ptr` is dangling\n-    ///     *ptr;\n-    /// }\n-    /// ```\n-    ///\n-    /// This happens because the pointer returned by `as_ptr` does not carry any\n-    /// lifetime information and the [`CString`] is deallocated immediately after\n-    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n-    /// expression is evaluated.\n-    /// To fix the problem, bind the `CString` to a local variable:\n-    ///\n-    /// ```no_run\n-    /// # #![allow(unused_must_use)]\n-    /// use std::ffi::CString;\n-    ///\n-    /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n-    /// let ptr = hello.as_ptr();\n-    /// unsafe {\n-    ///     // `ptr` is valid because `hello` is in scope\n-    ///     *ptr;\n-    /// }\n-    /// ```\n-    ///\n-    /// This way, the lifetime of the [`CString`] in `hello` encompasses\n-    /// the lifetime of `ptr` and the `unsafe` block.\n+#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n+impl AsRef<CStr> for CString {\n     #[inline]\n-    #[must_use]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n-    pub const fn as_ptr(&self) -> *const c_char {\n-        self.inner.as_ptr()\n+    fn as_ref(&self) -> &CStr {\n+        self\n     }\n+}\n \n-    /// Converts this C string to a byte slice.\n+#[cfg(bootstrap)]\n+#[doc(hidden)]\n+#[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+pub trait CStrExt {\n+    /// Converts a `CStr` into a <code>[Cow]<[str]></code>.\n     ///\n-    /// The returned slice will **not** contain the trailing nul terminator that this C\n-    /// string has.\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return a <code>[Cow]::[Borrowed]\\(&[str])</code>\n+    /// with the corresponding <code>&[str]</code> slice. Otherwise, it will\n+    /// replace any invalid UTF-8 sequences with\n+    /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n+    /// <code>[Cow]::[Owned]\\(&[str])</code> with the result.\n     ///\n-    /// > **Note**: This method is currently implemented as a constant-time\n-    /// > cast, but it is planned to alter its definition in the future to\n-    /// > perform the length calculation whenever this method is called.\n+    /// [str]: prim@str \"str\"\n+    /// [Borrowed]: Cow::Borrowed\n+    /// [Owned]: Cow::Owned\n+    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER \"std::char::REPLACEMENT_CHARACTER\"\n     ///\n     /// # Examples\n     ///\n+    /// Calling `to_string_lossy` on a `CStr` containing valid UTF-8:\n+    ///\n     /// ```\n+    /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello World\\0\")\n+    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_string_lossy(), Cow::Borrowed(\"Hello World\"));\n     /// ```\n-    #[inline]\n-    #[must_use = \"this returns the result of the operation, \\\n-                  without modifying the original\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_bytes(&self) -> &[u8] {\n-        let bytes = self.to_bytes_with_nul();\n-        // SAFETY: to_bytes_with_nul returns slice with length at least 1\n-        unsafe { bytes.get_unchecked(..bytes.len() - 1) }\n-    }\n-\n-    /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n-    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n-    /// will retain the trailing nul terminator instead of chopping it off.\n-    ///\n-    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n-    /// > it is planned to alter its definition in the future to perform the\n-    /// > length calculation whenever this method is called.\n-    ///\n-    /// # Examples\n+    /// Calling `to_string_lossy` on a `CStr` containing invalid UTF-8:\n     ///\n     /// ```\n+    /// use std::borrow::Cow;\n     /// use std::ffi::CStr;\n     ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n+    /// let cstr = CStr::from_bytes_with_nul(b\"Hello \\xF0\\x90\\x80World\\0\")\n+    ///                  .expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(\n+    ///     cstr.to_string_lossy(),\n+    ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<'_, str>\n+    /// );\n     /// ```\n-    #[inline]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn to_bytes_with_nul(&self) -> &[u8] {\n-        unsafe { &*(&self.inner as *const [c_char] as *const [u8]) }\n-    }\n+    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n+    fn to_string_lossy(&self) -> Cow<'_, str>;\n \n-    /// Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.\n-    ///\n-    /// If the contents of the `CStr` are valid UTF-8 data, this\n-    /// function will return the corresponding <code>&[str]</code> slice. Otherwise,\n-    /// it will return an error with details of where UTF-8 validation failed.\n-    ///\n-    /// [str]: prim@str \"str\"\n+    /// Converts a <code>[Box]<[CStr]></code> into a [`CString`] without copying or allocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::ffi::CStr;\n+    /// use std::ffi::CString;\n     ///\n-    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n-    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n+    /// let c_string = CString::new(b\"foo\".to_vec()).expect(\"CString::new failed\");\n+    /// let boxed = c_string.into_boxed_c_str();\n+    /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));\n     /// ```\n-    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n-    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n-        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n-        // instead of in `from_ptr()`, it may be worth considering if this should\n-        // be rewritten to do the UTF-8 check inline with the length calculation\n-        // instead of doing it afterwards.\n-        str::from_utf8(self.to_bytes())\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n+    #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n+    fn into_c_string(self: Box<Self>) -> CString;\n+}\n+\n+#[cfg(bootstrap)]\n+#[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+impl CStrExt for CStr {\n+    fn to_string_lossy(&self) -> Cow<'_, str> {\n+        String::from_utf8_lossy(self.to_bytes())\n     }\n \n+    fn into_c_string(self: Box<Self>) -> CString {\n+        CString::from(self)\n+    }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[cfg(not(test))]\n+impl CStr {\n     /// Converts a `CStr` into a <code>[Cow]<[str]></code>.\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n@@ -1534,7 +1145,7 @@ impl CStr {\n     /// [str]: prim@str \"str\"\n     /// [Borrowed]: Cow::Borrowed\n     /// [Owned]: Cow::Owned\n-    /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER \"std::char::REPLACEMENT_CHARACTER\"\n+    /// [U+FFFD]: core::char::REPLACEMENT_CHARACTER \"std::char::REPLACEMENT_CHARACTER\"\n     ///\n     /// # Examples\n     ///\n@@ -1562,6 +1173,7 @@ impl CStr {\n     ///     Cow::Owned(String::from(\"Hello \ufffdWorld\")) as Cow<'_, str>\n     /// );\n     /// ```\n+    #[rustc_allow_incoherent_impl]\n     #[must_use = \"this returns the result of the operation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n@@ -1580,101 +1192,10 @@ impl CStr {\n     /// let boxed = c_string.into_boxed_c_str();\n     /// assert_eq!(boxed.into_c_string(), CString::new(\"foo\").expect(\"CString::new failed\"));\n     /// ```\n+    #[rustc_allow_incoherent_impl]\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"into_boxed_c_str\", since = \"1.20.0\")]\n-    pub fn into_c_string(self: Box<CStr>) -> CString {\n-        let raw = Box::into_raw(self) as *mut [u8];\n-        CString { inner: unsafe { Box::from_raw(raw) } }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialEq for CStr {\n-    fn eq(&self, other: &CStr) -> bool {\n-        self.to_bytes().eq(other.to_bytes())\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Eq for CStr {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl PartialOrd for CStr {\n-    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n-        self.to_bytes().partial_cmp(&other.to_bytes())\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Ord for CStr {\n-    fn cmp(&self, other: &CStr) -> Ordering {\n-        self.to_bytes().cmp(&other.to_bytes())\n-    }\n-}\n-\n-#[stable(feature = \"cstr_borrow\", since = \"1.3.0\")]\n-impl ToOwned for CStr {\n-    type Owned = CString;\n-\n-    fn to_owned(&self) -> CString {\n-        CString { inner: self.to_bytes_with_nul().into() }\n-    }\n-\n-    fn clone_into(&self, target: &mut CString) {\n-        let mut b = Vec::from(mem::take(&mut target.inner));\n-        self.to_bytes_with_nul().clone_into(&mut b);\n-        target.inner = b.into_boxed_slice();\n-    }\n-}\n-\n-#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n-impl From<&CStr> for CString {\n-    /// Copies the contents of the `&CStr` into a newly allocated `CString`.\n-    fn from(s: &CStr) -> CString {\n-        s.to_owned()\n-    }\n-}\n-\n-#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n-impl ops::Index<ops::RangeFull> for CString {\n-    type Output = CStr;\n-\n-    #[inline]\n-    fn index(&self, _index: ops::RangeFull) -> &CStr {\n-        self\n-    }\n-}\n-\n-#[stable(feature = \"cstr_range_from\", since = \"1.47.0\")]\n-impl ops::Index<ops::RangeFrom<usize>> for CStr {\n-    type Output = CStr;\n-\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n-        let bytes = self.to_bytes_with_nul();\n-        // we need to manually check the starting index to account for the null\n-        // byte, since otherwise we could get an empty string that doesn't end\n-        // in a null.\n-        if index.start < bytes.len() {\n-            unsafe { CStr::_from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n-        } else {\n-            panic!(\n-                \"index out of bounds: the len is {} but the index is {}\",\n-                bytes.len(),\n-                index.start\n-            );\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n-impl AsRef<CStr> for CStr {\n-    #[inline]\n-    fn as_ref(&self) -> &CStr {\n-        self\n-    }\n-}\n-\n-#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n-impl AsRef<CStr> for CString {\n-    #[inline]\n-    fn as_ref(&self) -> &CStr {\n-        self\n+    pub fn into_c_string(self: Box<Self>) -> CString {\n+        CString::from(self)\n     }\n }", "previous_filename": "library/std/src/ffi/c_str.rs"}, {"sha": "0b7476d5cc7b7a6e3e5782ab6e5ff846a12ad5fb", "filename": "library/alloc/src/ffi/c_str/tests.rs", "status": "renamed", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -1,10 +1,12 @@\n use super::*;\n-use crate::borrow::Cow::{Borrowed, Owned};\n-use crate::collections::hash_map::DefaultHasher;\n-use crate::hash::{Hash, Hasher};\n-use crate::os::raw::c_char;\n use crate::rc::Rc;\n use crate::sync::Arc;\n+use core::assert_matches::assert_matches;\n+use core::ffi::FromBytesUntilNulError;\n+use core::hash::{Hash, Hasher};\n+\n+#[allow(deprecated)]\n+use core::hash::SipHasher13 as DefaultHasher;\n \n #[test]\n fn c_to_rust() {\n@@ -47,22 +49,6 @@ fn borrowed() {\n     }\n }\n \n-#[test]\n-fn to_str() {\n-    let data = b\"123\\xE2\\x80\\xA6\\0\";\n-    let ptr = data.as_ptr() as *const c_char;\n-    unsafe {\n-        assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n-        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n-    }\n-    let data = b\"123\\xE2\\0\";\n-    let ptr = data.as_ptr() as *const c_char;\n-    unsafe {\n-        assert!(CStr::from_ptr(ptr).to_str().is_err());\n-        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n-    }\n-}\n-\n #[test]\n fn to_owned() {\n     let data = b\"123\\0\";\n@@ -78,9 +64,11 @@ fn equal_hash() {\n     let ptr = data.as_ptr() as *const c_char;\n     let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n \n+    #[allow(deprecated)]\n     let mut s = DefaultHasher::new();\n     cstr.hash(&mut s);\n     let cstr_hash = s.finish();\n+    #[allow(deprecated)]\n     let mut s = DefaultHasher::new();\n     CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n     let cstring_hash = s.finish();\n@@ -122,11 +110,11 @@ fn cstr_from_bytes_until_nul() {\n     // Test an empty slice. This should fail because it\n     // does not contain a nul byte.\n     let b = b\"\";\n-    assert_eq!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError(())));\n+    assert_matches!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError { .. }));\n \n     // Test a non-empty slice, that does not contain a nul byte.\n     let b = b\"hello\";\n-    assert_eq!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError(())));\n+    assert_matches!(CStr::from_bytes_until_nul(&b[..]), Err(FromBytesUntilNulError { .. }));\n \n     // Test an empty nul-terminated string\n     let b = b\"\\0\";", "previous_filename": "library/std/src/ffi/c_str/tests.rs"}, {"sha": "eed2851c1539b13e8eccc8ce63221876455583dc", "filename": "library/alloc/src/ffi/mod.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fffi%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -0,0 +1,91 @@\n+//! Utilities related to FFI bindings.\n+//!\n+//! This module provides utilities to handle data across non-Rust\n+//! interfaces, like other programming languages and the underlying\n+//! operating system. It is mainly of use for FFI (Foreign Function\n+//! Interface) bindings and code that needs to exchange C-like strings\n+//! with other languages.\n+//!\n+//! # Overview\n+//!\n+//! Rust represents owned strings with the [`String`] type, and\n+//! borrowed slices of strings with the [`str`] primitive. Both are\n+//! always in UTF-8 encoding, and may contain nul bytes in the middle,\n+//! i.e., if you look at the bytes that make up the string, there may\n+//! be a `\\0` among them. Both `String` and `str` store their length\n+//! explicitly; there are no nul terminators at the end of strings\n+//! like in C.\n+//!\n+//! C strings are different from Rust strings:\n+//!\n+//! * **Encodings** - Rust strings are UTF-8, but C strings may use\n+//! other encodings. If you are using a string from C, you should\n+//! check its encoding explicitly, rather than just assuming that it\n+//! is UTF-8 like you can do in Rust.\n+//!\n+//! * **Character size** - C strings may use `char` or `wchar_t`-sized\n+//! characters; please **note** that C's `char` is different from Rust's.\n+//! The C standard leaves the actual sizes of those types open to\n+//! interpretation, but defines different APIs for strings made up of\n+//! each character type. Rust strings are always UTF-8, so different\n+//! Unicode characters will be encoded in a variable number of bytes\n+//! each. The Rust type [`char`] represents a '[Unicode scalar\n+//! value]', which is similar to, but not the same as, a '[Unicode\n+//! code point]'.\n+//!\n+//! * **Nul terminators and implicit string lengths** - Often, C\n+//! strings are nul-terminated, i.e., they have a `\\0` character at the\n+//! end. The length of a string buffer is not stored, but has to be\n+//! calculated; to compute the length of a string, C code must\n+//! manually call a function like `strlen()` for `char`-based strings,\n+//! or `wcslen()` for `wchar_t`-based ones. Those functions return\n+//! the number of characters in the string excluding the nul\n+//! terminator, so the buffer length is really `len+1` characters.\n+//! Rust strings don't have a nul terminator; their length is always\n+//! stored and does not need to be calculated. While in Rust\n+//! accessing a string's length is an *O*(1) operation (because the\n+//! length is stored); in C it is an *O*(*n*) operation because the\n+//! length needs to be computed by scanning the string for the nul\n+//! terminator.\n+//!\n+//! * **Internal nul characters** - When C strings have a nul\n+//! terminator character, this usually means that they cannot have nul\n+//! characters in the middle \u2014 a nul character would essentially\n+//! truncate the string. Rust strings *can* have nul characters in\n+//! the middle, because nul does not have to mark the end of the\n+//! string in Rust.\n+//!\n+//! # Representations of non-Rust strings\n+//!\n+//! [`CString`] and [`CStr`] are useful when you need to transfer\n+//! UTF-8 strings to and from languages with a C ABI, like Python.\n+//!\n+//! * **From Rust to C:** [`CString`] represents an owned, C-friendly\n+//! string: it is nul-terminated, and has no internal nul characters.\n+//! Rust code can create a [`CString`] out of a normal string (provided\n+//! that the string doesn't have nul characters in the middle), and\n+//! then use a variety of methods to obtain a raw <code>\\*mut [u8]</code> that can\n+//! then be passed as an argument to functions which use the C\n+//! conventions for strings.\n+//!\n+//! * **From C to Rust:** [`CStr`] represents a borrowed C string; it\n+//! is what you would use to wrap a raw <code>\\*const [u8]</code> that you got from\n+//! a C function. A [`CStr`] is guaranteed to be a nul-terminated array\n+//! of bytes. Once you have a [`CStr`], you can convert it to a Rust\n+//! <code>&[str]</code> if it's valid UTF-8, or lossily convert it by adding\n+//! replacement characters.\n+//!\n+//! [`String`]: crate::string::String\n+//! [`CStr`]: core::ffi::CStr\n+\n+#![unstable(feature = \"alloc_ffi\", issue = \"94079\")]\n+\n+#[cfg(bootstrap)]\n+#[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+pub use self::c_str::CStrExt;\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n+pub use self::c_str::FromVecWithNulError;\n+#[unstable(feature = \"alloc_c_string\", issue = \"94079\")]\n+pub use self::c_str::{CString, IntoStringError, NulError};\n+\n+mod c_str;"}, {"sha": "4d2dc4ecee0b80f566a983750dd3731ce73afa7c", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -86,11 +86,13 @@\n #![allow(explicit_outlives_requirements)]\n //\n // Library features:\n+#![cfg_attr(not(no_global_oom_handling), feature(alloc_c_string))]\n #![feature(alloc_layout_extra)]\n #![feature(allocator_api)]\n #![feature(array_chunks)]\n #![feature(array_methods)]\n #![feature(array_windows)]\n+#![feature(assert_matches)]\n #![feature(async_iterator)]\n #![feature(coerce_unsized)]\n #![cfg_attr(not(no_global_oom_handling), feature(const_alloc_error))]\n@@ -104,9 +106,12 @@\n #![feature(const_maybe_uninit_write)]\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_refs_to_cell)]\n+#![feature(core_c_str)]\n #![feature(core_intrinsics)]\n+#![feature(core_ffi_c)]\n #![feature(const_eval_select)]\n #![feature(const_pin)]\n+#![feature(cstr_from_bytes_until_nul)]\n #![feature(dispatch_from_dyn)]\n #![feature(exact_size_is_empty)]\n #![feature(extend_one)]\n@@ -152,6 +157,7 @@\n #![feature(exclusive_range_pattern)]\n #![feature(fundamental)]\n #![cfg_attr(not(test), feature(generator_trait))]\n+#![feature(hashmap_internals)]\n #![feature(lang_items)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n@@ -160,6 +166,7 @@\n #![feature(nll)] // Not necessary, but here to test the `nll` feature.\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(rustc_attrs)]\n+#![feature(slice_internals)]\n #![feature(staged_api)]\n #![cfg_attr(test, feature(test))]\n #![feature(unboxed_closures)]\n@@ -205,6 +212,8 @@ mod boxed {\n }\n pub mod borrow;\n pub mod collections;\n+#[cfg(not(no_global_oom_handling))]\n+pub mod ffi;\n pub mod fmt;\n pub mod rc;\n pub mod slice;"}, {"sha": "02a47c57b8ae3bcec2a7c27e8018b1d922d53543", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -153,7 +153,7 @@ pub use hack::to_vec;\n // functions are actually methods that are in `impl [T]` but not in\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n-mod hack {\n+pub(crate) mod hack {\n     use core::alloc::Allocator;\n \n     use crate::boxed::Box;"}, {"sha": "8fbb10e1d5cb6745e0d4f986782e3d653104e155", "filename": "library/alloc/tests/c_str.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Ftests%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Ftests%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fc_str.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -0,0 +1,18 @@\n+use std::borrow::Cow::{Borrowed, Owned};\n+use std::ffi::{c_char, CStr};\n+\n+#[test]\n+fn to_str() {\n+    let data = b\"123\\xE2\\x80\\xA6\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    unsafe {\n+        assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n+        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n+    }\n+    let data = b\"123\\xE2\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    unsafe {\n+        assert!(CStr::from_ptr(ptr).to_str().is_err());\n+        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n+    }\n+}"}, {"sha": "8de159246c6e0693f6e60f19725e1ba6985f5252", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -12,6 +12,8 @@\n #![feature(const_nonnull_slice_from_raw_parts)]\n #![feature(const_ptr_write)]\n #![feature(const_try)]\n+#![feature(core_c_str)]\n+#![feature(core_ffi_c)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n@@ -49,6 +51,7 @@ mod binary_heap;\n mod borrow;\n mod boxed;\n mod btree_set_hash;\n+mod c_str;\n mod const_fns;\n mod cow_str;\n mod fmt;"}, {"sha": "15d9d013997bebba375db4391854498633fe6d61", "filename": "library/core/src/ffi/c_str.rs", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fc_str.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -0,0 +1,570 @@\n+use crate::ascii;\n+use crate::cmp::Ordering;\n+use crate::ffi::c_char;\n+use crate::fmt::{self, Write};\n+use crate::ops;\n+use crate::slice;\n+use crate::slice::memchr;\n+use crate::str;\n+\n+/// Representation of a borrowed C string.\n+///\n+/// This type represents a borrowed reference to a nul-terminated\n+/// array of bytes. It can be constructed safely from a <code>&[[u8]]</code>\n+/// slice, or unsafely from a raw `*const c_char`. It can then be\n+/// converted to a Rust <code>&[str]</code> by performing UTF-8 validation, or\n+/// into an owned `CString`.\n+///\n+/// `&CStr` is to `CString` as <code>&[str]</code> is to `String`: the former\n+/// in each pair are borrowed references; the latter are owned\n+/// strings.\n+///\n+/// Note that this structure is **not** `repr(C)` and is not recommended to be\n+/// placed in the signatures of FFI functions. Instead, safe wrappers of FFI\n+/// functions may leverage the unsafe [`CStr::from_ptr`] constructor to provide\n+/// a safe interface to other consumers.\n+///\n+/// # Examples\n+///\n+/// Inspecting a foreign C string:\n+///\n+/// ```ignore (extern-declaration)\n+/// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n+///\n+/// extern \"C\" { fn my_string() -> *const c_char; }\n+///\n+/// unsafe {\n+///     let slice = CStr::from_ptr(my_string());\n+///     println!(\"string buffer size without nul terminator: {}\", slice.to_bytes().len());\n+/// }\n+/// ```\n+///\n+/// Passing a Rust-originating C string:\n+///\n+/// ```ignore (extern-declaration)\n+/// use std::ffi::{CString, CStr};\n+/// use std::os::raw::c_char;\n+///\n+/// fn work(data: &CStr) {\n+///     extern \"C\" { fn work_with(data: *const c_char); }\n+///\n+///     unsafe { work_with(data.as_ptr()) }\n+/// }\n+///\n+/// let s = CString::new(\"data data data data\").expect(\"CString::new failed\");\n+/// work(&s);\n+/// ```\n+///\n+/// Converting a foreign C string into a Rust `String`:\n+///\n+/// ```ignore (extern-declaration)\n+/// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n+///\n+/// extern \"C\" { fn my_string() -> *const c_char; }\n+///\n+/// fn my_string_safe() -> String {\n+///     unsafe {\n+///         CStr::from_ptr(my_string()).to_string_lossy().into_owned()\n+///     }\n+/// }\n+///\n+/// println!(\"string: {}\", my_string_safe());\n+/// ```\n+///\n+/// [str]: prim@str \"str\"\n+#[derive(Hash)]\n+#[cfg_attr(not(test), rustc_diagnostic_item = \"CStr\")]\n+#[unstable(feature = \"core_c_str\", issue = \"94079\")]\n+#[cfg_attr(not(bootstrap), lang = \"CStr\")]\n+// FIXME:\n+// `fn from` in `impl From<&CStr> for Box<CStr>` current implementation relies\n+// on `CStr` being layout-compatible with `[u8]`.\n+// When attribute privacy is implemented, `CStr` should be annotated as `#[repr(transparent)]`.\n+// Anyway, `CStr` representation and layout are considered implementation detail, are\n+// not documented and must not be relied upon.\n+pub struct CStr {\n+    // FIXME: this should not be represented with a DST slice but rather with\n+    //        just a raw `c_char` along with some form of marker to make\n+    //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n+    //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n+    inner: [c_char],\n+}\n+\n+/// An error indicating that a nul byte was not in the expected position.\n+///\n+/// The slice used to create a [`CStr`] must have one and only one nul byte,\n+/// positioned at the end.\n+///\n+/// This error is created by the [`CStr::from_bytes_with_nul`] method.\n+/// See its documentation for more.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::ffi::{CStr, FromBytesWithNulError};\n+///\n+/// let _: FromBytesWithNulError = CStr::from_bytes_with_nul(b\"f\\0oo\").unwrap_err();\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"core_c_str\", issue = \"94079\")]\n+pub struct FromBytesWithNulError {\n+    kind: FromBytesWithNulErrorKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum FromBytesWithNulErrorKind {\n+    InteriorNul(usize),\n+    NotNulTerminated,\n+}\n+\n+impl FromBytesWithNulError {\n+    fn interior_nul(pos: usize) -> FromBytesWithNulError {\n+        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::InteriorNul(pos) }\n+    }\n+    fn not_nul_terminated() -> FromBytesWithNulError {\n+        FromBytesWithNulError { kind: FromBytesWithNulErrorKind::NotNulTerminated }\n+    }\n+\n+    #[doc(hidden)]\n+    #[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+    pub fn __description(&self) -> &str {\n+        match self.kind {\n+            FromBytesWithNulErrorKind::InteriorNul(..) => {\n+                \"data provided contains an interior nul byte\"\n+            }\n+            FromBytesWithNulErrorKind::NotNulTerminated => \"data provided is not nul terminated\",\n+        }\n+    }\n+}\n+\n+/// An error indicating that no nul byte was present.\n+///\n+/// A slice used to create a [`CStr`] must contain a nul byte somewhere\n+/// within the slice.\n+///\n+/// This error is created by the [`CStr::from_bytes_until_nul`] method.\n+///\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+pub struct FromBytesUntilNulError(());\n+\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+impl fmt::Display for FromBytesUntilNulError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"data provided does not contain a nul\")\n+    }\n+}\n+\n+#[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\n+impl fmt::Debug for CStr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"\\\"\")?;\n+        for byte in self.to_bytes().iter().flat_map(|&b| ascii::escape_default(b)) {\n+            f.write_char(byte as char)?;\n+        }\n+        write!(f, \"\\\"\")\n+    }\n+}\n+\n+#[stable(feature = \"cstr_default\", since = \"1.10.0\")]\n+impl Default for &CStr {\n+    fn default() -> Self {\n+        const SLICE: &[c_char] = &[0];\n+        // SAFETY: `SLICE` is indeed pointing to a valid nul-terminated string.\n+        unsafe { CStr::from_ptr(SLICE.as_ptr()) }\n+    }\n+}\n+\n+#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n+impl fmt::Display for FromBytesWithNulError {\n+    #[allow(deprecated, deprecated_in_future)]\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.__description())?;\n+        if let FromBytesWithNulErrorKind::InteriorNul(pos) = self.kind {\n+            write!(f, \" at byte pos {pos}\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl CStr {\n+    /// Wraps a raw C string with a safe C string wrapper.\n+    ///\n+    /// This function will wrap the provided `ptr` with a `CStr` wrapper, which\n+    /// allows inspection and interoperation of non-owned C strings. The total\n+    /// size of the raw C string must be smaller than `isize::MAX` **bytes**\n+    /// in memory due to calling the `slice::from_raw_parts` function.\n+    /// This method is unsafe for a number of reasons:\n+    ///\n+    /// * There is no guarantee to the validity of `ptr`.\n+    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n+    ///   `ptr`.\n+    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n+    ///   valid nul terminator byte at the end of the string.\n+    /// * It is not guaranteed that the memory pointed by `ptr` won't change\n+    ///   before the `CStr` has been destroyed.\n+    ///\n+    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n+    /// > currently implemented with an up-front calculation of the length of\n+    /// > the string. This is not guaranteed to always be the case.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (extern-declaration)\n+    /// # fn main() {\n+    /// use std::ffi::CStr;\n+    /// use std::os::raw::c_char;\n+    ///\n+    /// extern \"C\" {\n+    ///     fn my_string() -> *const c_char;\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let slice = CStr::from_ptr(my_string());\n+    ///     println!(\"string returned: {}\", slice.to_str().unwrap());\n+    /// }\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n+        // SAFETY: The caller has provided a pointer that points to a valid C\n+        // string with a NUL terminator of size less than `isize::MAX`, whose\n+        // content remain valid and doesn't change for the lifetime of the\n+        // returned `CStr`.\n+        //\n+        // Thus computing the length is fine (a NUL byte exists), the call to\n+        // from_raw_parts is safe because we know the length is at most `isize::MAX`, meaning\n+        // the call to `from_bytes_with_nul_unchecked` is correct.\n+        //\n+        // The cast from c_char to u8 is ok because a c_char is always one byte.\n+        unsafe {\n+            extern \"C\" {\n+                /// Provided by libc or compiler_builtins.\n+                fn strlen(s: *const c_char) -> usize;\n+            }\n+            let len = strlen(ptr);\n+            let ptr = ptr as *const u8;\n+            CStr::from_bytes_with_nul_unchecked(slice::from_raw_parts(ptr, len as usize + 1))\n+        }\n+    }\n+\n+    /// Creates a C string wrapper from a byte slice.\n+    ///\n+    /// This method will create a `CStr` from any byte slice that contains at\n+    /// least one nul byte. The caller does not need to know or specify where\n+    /// the nul byte is located.\n+    ///\n+    /// If the first byte is a nul character, this method will return an\n+    /// empty `CStr`. If multiple nul characters are present, the `CStr` will\n+    /// end at the first one.\n+    ///\n+    /// If the slice only has a single nul byte at the end, this method is\n+    /// equivalent to [`CStr::from_bytes_with_nul`].\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(cstr_from_bytes_until_nul)]\n+    ///\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let mut buffer = [0u8; 16];\n+    /// unsafe {\n+    ///     // Here we might call an unsafe C function that writes a string\n+    ///     // into the buffer.\n+    ///     let buf_ptr = buffer.as_mut_ptr();\n+    ///     buf_ptr.write_bytes(b'A', 8);\n+    /// }\n+    /// // Attempt to extract a C nul-terminated string from the buffer.\n+    /// let c_str = CStr::from_bytes_until_nul(&buffer[..]).unwrap();\n+    /// assert_eq!(c_str.to_str().unwrap(), \"AAAAAAAA\");\n+    /// ```\n+    ///\n+    #[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+    pub fn from_bytes_until_nul(bytes: &[u8]) -> Result<&CStr, FromBytesUntilNulError> {\n+        let nul_pos = memchr::memchr(0, bytes);\n+        match nul_pos {\n+            Some(nul_pos) => {\n+                let subslice = &bytes[..nul_pos + 1];\n+                // SAFETY: We know there is a nul byte at nul_pos, so this slice\n+                // (ending at the nul byte) is a well-formed C string.\n+                Ok(unsafe { CStr::from_bytes_with_nul_unchecked(subslice) })\n+            }\n+            None => Err(FromBytesUntilNulError(())),\n+        }\n+    }\n+\n+    /// Creates a C string wrapper from a byte slice.\n+    ///\n+    /// This function will cast the provided `bytes` to a `CStr`\n+    /// wrapper after ensuring that the byte slice is nul-terminated\n+    /// and does not contain any interior nul bytes.\n+    ///\n+    /// If the nul byte may not be at the end,\n+    /// [`CStr::from_bytes_until_nul`] can be used instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"hello\\0\");\n+    /// assert!(cstr.is_ok());\n+    /// ```\n+    ///\n+    /// Creating a `CStr` without a trailing nul terminator is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"hello\");\n+    /// assert!(cstr.is_err());\n+    /// ```\n+    ///\n+    /// Creating a `CStr` with an interior nul byte is an error:\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"he\\0llo\\0\");\n+    /// assert!(cstr.is_err());\n+    /// ```\n+    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+    pub fn from_bytes_with_nul(bytes: &[u8]) -> Result<&Self, FromBytesWithNulError> {\n+        let nul_pos = memchr::memchr(0, bytes);\n+        match nul_pos {\n+            Some(nul_pos) if nul_pos + 1 == bytes.len() => {\n+                // SAFETY: We know there is only one nul byte, at the end\n+                // of the byte slice.\n+                Ok(unsafe { Self::from_bytes_with_nul_unchecked(bytes) })\n+            }\n+            Some(nul_pos) => Err(FromBytesWithNulError::interior_nul(nul_pos)),\n+            None => Err(FromBytesWithNulError::not_nul_terminated()),\n+        }\n+    }\n+\n+    /// Unsafely creates a C string wrapper from a byte slice.\n+    ///\n+    /// This function will cast the provided `bytes` to a `CStr` wrapper without\n+    /// performing any sanity checks. The provided slice **must** be nul-terminated\n+    /// and not contain any interior nul bytes.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::{CStr, CString};\n+    ///\n+    /// unsafe {\n+    ///     let cstring = CString::new(\"hello\").expect(\"CString::new failed\");\n+    ///     let cstr = CStr::from_bytes_with_nul_unchecked(cstring.to_bytes_with_nul());\n+    ///     assert_eq!(cstr, &*cstring);\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[must_use]\n+    #[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+    #[rustc_const_stable(feature = \"const_cstr_unchecked\", since = \"1.59.0\")]\n+    pub const unsafe fn from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n+        // We're in a const fn, so this is the best we can do\n+        debug_assert!(!bytes.is_empty() && bytes[bytes.len() - 1] == 0);\n+        // SAFETY: Calling an inner function with the same prerequisites.\n+        unsafe { Self::_from_bytes_with_nul_unchecked(bytes) }\n+    }\n+\n+    #[inline]\n+    const unsafe fn _from_bytes_with_nul_unchecked(bytes: &[u8]) -> &CStr {\n+        // SAFETY: Casting to CStr is safe because its internal representation\n+        // is a [u8] too (safe only inside std).\n+        // Dereferencing the obtained pointer is safe because it comes from a\n+        // reference. Making a reference is then safe because its lifetime\n+        // is bound by the lifetime of the given `bytes`.\n+        unsafe { &*(bytes as *const [u8] as *const CStr) }\n+    }\n+\n+    /// Returns the inner pointer to this C string.\n+    ///\n+    /// The returned pointer will be valid for as long as `self` is, and points\n+    /// to a contiguous region of memory terminated with a 0 byte to represent\n+    /// the end of the string.\n+    ///\n+    /// **WARNING**\n+    ///\n+    /// The returned pointer is read-only; writing to it (including passing it\n+    /// to C code that writes to it) causes undefined behavior.\n+    ///\n+    /// It is your responsibility to make sure that the underlying memory is not\n+    /// freed too early. For example, the following code will cause undefined\n+    /// behavior when `ptr` is used inside the `unsafe` block:\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_must_use)] #![allow(temporary_cstring_as_ptr)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// let ptr = CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr();\n+    /// unsafe {\n+    ///     // `ptr` is dangling\n+    ///     *ptr;\n+    /// }\n+    /// ```\n+    ///\n+    /// This happens because the pointer returned by `as_ptr` does not carry any\n+    /// lifetime information and the `CString` is deallocated immediately after\n+    /// the `CString::new(\"Hello\").expect(\"CString::new failed\").as_ptr()`\n+    /// expression is evaluated.\n+    /// To fix the problem, bind the `CString` to a local variable:\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_must_use)]\n+    /// use std::ffi::CString;\n+    ///\n+    /// let hello = CString::new(\"Hello\").expect(\"CString::new failed\");\n+    /// let ptr = hello.as_ptr();\n+    /// unsafe {\n+    ///     // `ptr` is valid because `hello` is in scope\n+    ///     *ptr;\n+    /// }\n+    /// ```\n+    ///\n+    /// This way, the lifetime of the `CString` in `hello` encompasses\n+    /// the lifetime of `ptr` and the `unsafe` block.\n+    #[inline]\n+    #[must_use]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"const_str_as_ptr\", since = \"1.32.0\")]\n+    pub const fn as_ptr(&self) -> *const c_char {\n+        self.inner.as_ptr()\n+    }\n+\n+    /// Converts this C string to a byte slice.\n+    ///\n+    /// The returned slice will **not** contain the trailing nul terminator that this C\n+    /// string has.\n+    ///\n+    /// > **Note**: This method is currently implemented as a constant-time\n+    /// > cast, but it is planned to alter its definition in the future to\n+    /// > perform the length calculation whenever this method is called.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes(), b\"foo\");\n+    /// ```\n+    #[inline]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_bytes(&self) -> &[u8] {\n+        let bytes = self.to_bytes_with_nul();\n+        // SAFETY: to_bytes_with_nul returns slice with length at least 1\n+        unsafe { bytes.get_unchecked(..bytes.len() - 1) }\n+    }\n+\n+    /// Converts this C string to a byte slice containing the trailing 0 byte.\n+    ///\n+    /// This function is the equivalent of [`CStr::to_bytes`] except that it\n+    /// will retain the trailing nul terminator instead of chopping it off.\n+    ///\n+    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n+    /// > it is planned to alter its definition in the future to perform the\n+    /// > length calculation whenever this method is called.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_bytes_with_nul(), b\"foo\\0\");\n+    /// ```\n+    #[inline]\n+    #[must_use = \"this returns the result of the operation, \\\n+                  without modifying the original\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn to_bytes_with_nul(&self) -> &[u8] {\n+        // SAFETY: Transmuting a slice of `c_char`s to a slice of `u8`s\n+        // is safe on all supported targets.\n+        unsafe { &*(&self.inner as *const [c_char] as *const [u8]) }\n+    }\n+\n+    /// Yields a <code>&[str]</code> slice if the `CStr` contains valid UTF-8.\n+    ///\n+    /// If the contents of the `CStr` are valid UTF-8 data, this\n+    /// function will return the corresponding <code>&[str]</code> slice. Otherwise,\n+    /// it will return an error with details of where UTF-8 validation failed.\n+    ///\n+    /// [str]: prim@str \"str\"\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::CStr;\n+    ///\n+    /// let cstr = CStr::from_bytes_with_nul(b\"foo\\0\").expect(\"CStr::from_bytes_with_nul failed\");\n+    /// assert_eq!(cstr.to_str(), Ok(\"foo\"));\n+    /// ```\n+    #[stable(feature = \"cstr_to_str\", since = \"1.4.0\")]\n+    pub fn to_str(&self) -> Result<&str, str::Utf8Error> {\n+        // N.B., when `CStr` is changed to perform the length check in `.to_bytes()`\n+        // instead of in `from_ptr()`, it may be worth considering if this should\n+        // be rewritten to do the UTF-8 check inline with the length calculation\n+        // instead of doing it afterwards.\n+        str::from_utf8(self.to_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialEq for CStr {\n+    fn eq(&self, other: &CStr) -> bool {\n+        self.to_bytes().eq(other.to_bytes())\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Eq for CStr {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl PartialOrd for CStr {\n+    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n+        self.to_bytes().partial_cmp(&other.to_bytes())\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Ord for CStr {\n+    fn cmp(&self, other: &CStr) -> Ordering {\n+        self.to_bytes().cmp(&other.to_bytes())\n+    }\n+}\n+\n+#[stable(feature = \"cstr_range_from\", since = \"1.47.0\")]\n+impl ops::Index<ops::RangeFrom<usize>> for CStr {\n+    type Output = CStr;\n+\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &CStr {\n+        let bytes = self.to_bytes_with_nul();\n+        // we need to manually check the starting index to account for the null\n+        // byte, since otherwise we could get an empty string that doesn't end\n+        // in a null.\n+        if index.start < bytes.len() {\n+            // SAFETY: Non-empty tail of a valid `CStr` is still a valid `CStr`.\n+            unsafe { CStr::from_bytes_with_nul_unchecked(&bytes[index.start..]) }\n+        } else {\n+            panic!(\n+                \"index out of bounds: the len is {} but the index is {}\",\n+                bytes.len(),\n+                index.start\n+            );\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"cstring_asref\", since = \"1.7.0\")]\n+impl AsRef<CStr> for CStr {\n+    #[inline]\n+    fn as_ref(&self) -> &CStr {\n+        self\n+    }\n+}"}, {"sha": "6c49521c223853ada5241bb591ac502164ab1e18", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -14,6 +14,11 @@ use crate::marker::PhantomData;\n use crate::num::*;\n use crate::ops::{Deref, DerefMut};\n \n+#[unstable(feature = \"core_c_str\", issue = \"94079\")]\n+pub use self::c_str::{CStr, FromBytesUntilNulError, FromBytesWithNulError};\n+\n+mod c_str;\n+\n macro_rules! type_alias_no_nz {\n     {\n       $Docfile:tt, $Alias:ident = $Real:ty;"}, {"sha": "78d01c268f53e5546b3771be44aa54e05d470fdb", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -20,7 +20,7 @@\n // FIXME: Fill me in with more detail when the interface settles\n //! This library is built on the assumption of a few existing symbols:\n //!\n-//! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n+//! * `memcpy`, `memcmp`, `memset`, `strlen` - These are core memory routines which are\n //!   often generated by LLVM. Additionally, this library can make explicit\n //!   calls to these functions. Their signatures are the same as found in C.\n //!   These functions are often provided by the system libc, but can also be"}, {"sha": "f2d6583206035e9c966ffcd0887130cf37898893", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -16,7 +16,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2.116\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.69\" }\n+compiler_builtins = { version = \"0.1.71\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep-of-std'] }"}, {"sha": "3f85c2095cbd4fd44077e7df316508d9783c23e8", "filename": "library/std/src/error.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -26,6 +26,7 @@ use crate::borrow::Cow;\n use crate::cell;\n use crate::char;\n use crate::fmt::{self, Debug, Display, Write};\n+use crate::io;\n use crate::mem::transmute;\n use crate::num;\n use crate::str;\n@@ -612,6 +613,48 @@ impl Error for alloc::collections::TryReserveError {}\n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n impl Error for time::FromFloatSecsError {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for alloc::ffi::NulError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"nul byte found in data\"\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl From<alloc::ffi::NulError> for io::Error {\n+    /// Converts a [`alloc::ffi::NulError`] into a [`io::Error`].\n+    fn from(_: alloc::ffi::NulError) -> io::Error {\n+        io::const_io_error!(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n+    }\n+}\n+\n+#[stable(feature = \"frombyteswithnulerror_impls\", since = \"1.17.0\")]\n+impl Error for core::ffi::FromBytesWithNulError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        self.__description()\n+    }\n+}\n+\n+#[unstable(feature = \"cstr_from_bytes_until_nul\", issue = \"95027\")]\n+impl Error for core::ffi::FromBytesUntilNulError {}\n+\n+#[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n+impl Error for alloc::ffi::FromVecWithNulError {}\n+\n+#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n+impl Error for alloc::ffi::IntoStringError {\n+    #[allow(deprecated)]\n+    fn description(&self) -> &str {\n+        \"C string contained non-utf8 bytes\"\n+    }\n+\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        Some(self.__source())\n+    }\n+}\n+\n // Copied from `any.rs`.\n impl dyn Error + 'static {\n     /// Returns `true` if the inner type is the same as `T`."}, {"sha": "0141a2bccdf161eac2c89aa2b8c9bfe22a94dbec", "filename": "library/std/src/ffi/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -146,12 +146,24 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n-pub use self::c_str::FromBytesWithNulError;\n+/// See [alloc::ffi::FromVecWithNulError].\n #[stable(feature = \"cstring_from_vec_with_nul\", since = \"1.58.0\")]\n-pub use self::c_str::FromVecWithNulError;\n+pub type FromVecWithNulError = alloc::ffi::FromVecWithNulError;\n+/// See [alloc::ffi::CString].\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type CString = alloc::ffi::CString;\n+/// See [alloc::ffi::IntoStringError].\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type IntoStringError = alloc::ffi::IntoStringError;\n+/// See [alloc::ffi::NulError].\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::c_str::{CStr, CString, IntoStringError, NulError};\n+pub type NulError = alloc::ffi::NulError;\n+/// See [core::ffi::CStr].\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub type CStr = core::ffi::CStr;\n+/// See [core::ffi::FromBytesWithNulError].\n+#[stable(feature = \"cstr_from_bytes\", since = \"1.10.0\")]\n+pub type FromBytesWithNulError = core::ffi::FromBytesWithNulError;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::os_str::{OsStr, OsString};\n@@ -176,5 +188,4 @@ pub use core::ffi::{c_ptrdiff_t, c_size_t, c_ssize_t};\n )]\n pub use core::ffi::{VaList, VaListImpl};\n \n-mod c_str;\n mod os_str;"}, {"sha": "039e3d59a4d4053c034011b867cfd394fec2ecd4", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -260,7 +260,10 @@\n #![feature(atomic_mut_ptr)]\n #![feature(char_error_internals)]\n #![feature(char_internals)]\n+#![feature(core_c_str)]\n #![feature(core_intrinsics)]\n+#![feature(cstr_from_bytes_until_nul)]\n+#![feature(cstr_internals)]\n #![feature(duration_checked_float)]\n #![feature(duration_constants)]\n #![feature(exact_size_is_empty)]\n@@ -286,6 +289,7 @@\n //\n // Library features (alloc):\n #![feature(alloc_layout_extra)]\n+#![feature(alloc_c_string)]\n #![feature(allocator_api)]\n #![feature(get_mut_unchecked)]\n #![feature(map_try_insert)]"}, {"sha": "f7533696df4af7036bf0027952cc698749dbf478", "filename": "library/std/src/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fv1.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -95,3 +95,7 @@ pub use crate::string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n pub use crate::vec::Vec;\n+\n+#[cfg(bootstrap)]\n+#[unstable(feature = \"cstr_internals\", issue = \"none\")]\n+pub use alloc::ffi::CStrExt;"}, {"sha": "60b7a973cc2c1d7c94a2c66640b6194e6e5b11dd", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -71,16 +71,6 @@ pub fn unsupported_err() -> crate::io::Error {\n     )\n }\n \n-pub unsafe fn strlen(start: *const c_char) -> usize {\n-    let mut str = start;\n-\n-    while *str != 0 {\n-        str = str.offset(1);\n-    }\n-\n-    (str as usize) - (start as usize)\n-}\n-\n #[no_mangle]\n pub extern \"C\" fn floor(x: f64) -> f64 {\n     unsafe { intrinsics::floorf64(x) }"}, {"sha": "696400670e04d1f8f543b258602a258191e6158c", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -5,7 +5,6 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::io::ErrorKind;\n-use crate::os::raw::c_char;\n use crate::sync::atomic::{AtomicBool, Ordering};\n \n pub mod abi;\n@@ -130,15 +129,6 @@ pub fn decode_error_kind(code: i32) -> ErrorKind {\n     }\n }\n \n-pub unsafe fn strlen(mut s: *const c_char) -> usize {\n-    let mut n = 0;\n-    while unsafe { *s } != 0 {\n-        n += 1;\n-        s = unsafe { s.offset(1) };\n-    }\n-    return n;\n-}\n-\n pub fn abort_internal() -> ! {\n     abi::usercalls::exit(true)\n }"}, {"sha": "5ffa381f2e50f07e1f8580ac0243e5ecd919e4a8", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -99,5 +99,3 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n         (x1, x2)\n     }\n }\n-\n-pub use libc::strlen;"}, {"sha": "aedeb02e656d6652d9b77eadd91997865b1520be", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -3,7 +3,6 @@\n use crate::io::ErrorKind;\n \n pub use self::rand::hashmap_random_keys;\n-pub use libc::strlen;\n \n #[cfg(not(target_os = \"espidf\"))]\n #[macro_use]"}, {"sha": "4c9ade4a8c7906714b84cd6437243a2501ab2d77", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -4,10 +4,6 @@ pub mod memchr {\n     pub use core::slice::memchr::{memchr, memrchr};\n }\n \n-// This is not necessarily correct. May want to consider making it part of the\n-// spec definition?\n-use crate::os::raw::c_char;\n-\n // SAFETY: must be called only once during runtime initialization.\n // NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n@@ -38,15 +34,3 @@ pub fn abort_internal() -> ! {\n pub fn hashmap_random_keys() -> (u64, u64) {\n     (1, 2)\n }\n-\n-pub unsafe fn strlen(mut s: *const c_char) -> usize {\n-    // SAFETY: The caller must guarantee `s` points to a valid 0-terminated string.\n-    unsafe {\n-        let mut n = 0;\n-        while *s != 0 {\n-            n += 1;\n-            s = s.offset(1);\n-        }\n-        n\n-    }\n-}"}, {"sha": "31c7208bbf1eef3951d9a87cbd85b387ef036730", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -7,7 +7,6 @@ use crate::path::PathBuf;\n use crate::time::Duration;\n \n pub use self::rand::hashmap_random_keys;\n-pub use libc::strlen;\n \n #[macro_use]\n pub mod compat;"}, {"sha": "e5fa6deefc5de3d85b1e1afcbcc1cb14cececa02", "filename": "src/tools/clippy/clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e6fe5855a115ef7f17f3e17205fab7340775701/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fpaths.rs?ref=1e6fe5855a115ef7f17f3e17205fab7340775701", "patch": "@@ -23,7 +23,7 @@ pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n-pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n+pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible"}]}