{"sha": "293e885daaa6fdb518f713e46170e1fc5cdb7183", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5M2U4ODVkYWFhNmZkYjUxOGY3MTNlNDYxNzBlMWZjNWNkYjcxODM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-28T21:10:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-23T12:54:22Z"}, "message": "Iterate DefId to encode attributes.", "tree": {"sha": "c5c45dc68305c2d79f3b2f0165a198b0a0bfc6cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c45dc68305c2d79f3b2f0165a198b0a0bfc6cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293e885daaa6fdb518f713e46170e1fc5cdb7183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293e885daaa6fdb518f713e46170e1fc5cdb7183", "html_url": "https://github.com/rust-lang/rust/commit/293e885daaa6fdb518f713e46170e1fc5cdb7183", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293e885daaa6fdb518f713e46170e1fc5cdb7183/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1bf6d0e48fdf5be3c3a1264b5d0ef8f1f272e5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bf6d0e48fdf5be3c3a1264b5d0ef8f1f272e5f", "html_url": "https://github.com/rust-lang/rust/commit/f1bf6d0e48fdf5be3c3a1264b5d0ef8f1f272e5f"}], "stats": {"total": 21, "additions": 4, "deletions": 17}, "files": [{"sha": "c80f70ae5286f5266558df8e9ea024e7be628bd1", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/293e885daaa6fdb518f713e46170e1fc5cdb7183/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293e885daaa6fdb518f713e46170e1fc5cdb7183/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=293e885daaa6fdb518f713e46170e1fc5cdb7183", "patch": "@@ -1,7 +1,6 @@\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n-use rustc_ast as ast;\n use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -437,7 +436,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs);\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -769,6 +768,7 @@ impl EncodeContext<'a, 'tcx> {\n                 def_kind => def_kind,\n             });\n             record!(self.tables.span[def_id] <- tcx.def_span(def_id));\n+            record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n             if should_encode_visibility(def_kind) {\n                 record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n             }\n@@ -799,7 +799,6 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         record!(self.tables.children[def_id] <- variant.fields.iter().map(|f| {\n             assert!(f.did.is_local());\n@@ -854,7 +853,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_mir_for_ctfe(def_id.expect_local());\n     }\n \n-    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n+    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>) {\n         let tcx = self.tcx;\n         let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n@@ -887,7 +886,6 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.tables.attributes[def_id] <- attrs);\n         if self.is_proc_macro {\n             record!(self.tables.children[def_id] <- &[]);\n         } else {\n@@ -905,18 +903,13 @@ impl EncodeContext<'a, 'tcx> {\n         variant_index: VariantIdx,\n         field_index: usize,\n     ) {\n-        let tcx = self.tcx;\n         let variant = &adt_def.variants[variant_index];\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().local_def_id_to_hir_id(variant.def_id.expect_local());\n-        let variant_data = tcx.hir().expect_variant_data(variant_id);\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n@@ -1043,7 +1036,6 @@ impl EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n             }\n         }\n-        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n@@ -1145,7 +1137,6 @@ impl EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n             }\n         }\n-        record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n@@ -1296,7 +1287,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m, &item.attrs);\n+                return self.encode_info_for_mod(item.hir_id, m);\n             }\n             hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1389,7 +1380,6 @@ impl EncodeContext<'a, 'tcx> {\n             }\n         };\n         record!(self.tables.kind[def_id] <- entry_kind);\n-        record!(self.tables.attributes[def_id] <- item.attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n@@ -1507,7 +1497,6 @@ impl EncodeContext<'a, 'tcx> {\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1540,7 +1529,6 @@ impl EncodeContext<'a, 'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         }\n-        record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n         self.encode_item_type(def_id.to_def_id());\n         if let ty::Closure(def_id, substs) = *ty.kind() {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n@@ -1837,7 +1825,6 @@ impl EncodeContext<'a, 'tcx> {\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n             }\n         }\n-        record!(self.tables.attributes[def_id] <- nitem.attrs);\n         self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);"}]}