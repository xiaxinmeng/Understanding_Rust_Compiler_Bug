{"sha": "fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "node_id": "C_kwDOAAsO6NoAKGZhZDk0MDdjNWE4ZTYxYWUzZDc5YjFkOTJmOGE2OThlOWI3NDYxYTA", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-12-17T11:22:41Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-12-17T12:22:25Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "24d39999379efe41f125b1b48ea050aa42883c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24d39999379efe41f125b1b48ea050aa42883c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmG8gQEACgkQHKDfKvWd\naKWX8xAAm3Ig8ifErhgQ1H4cMcnSrEzRWBfUzPFWIg7RKG1t4hzKZP85C4Imwz3V\n/ecSw8rDr9C5ADgCLmIRdri+OXWR9Gs/Cqo8CVS1gW5to6yxRtmITIakHVT3I4jB\neLVigQO/qk0YRpOO2mLbiztpkqeP2cWACH2YIIFoEWdPpkC6Fm7iqgK0QUZIS+wA\nIXUpX16TnReVsRwKJNE3+0BxciRTGXc7BQlWix3PKQovhzz8QeRzunEy3spohFpv\nO5dy/bC9Y2DngsgBucvh4q5GI+jJy1DT+BcadDVn1eROMY605xgws/fo7foC8G7T\nDVeB5SrpBVJP8z8ApOGau0IpUDa5u4gCy62DAPA2s613hwaD9x4GldhvNW8r89w6\nIql0SLnDkrGfZr+FD5NoDy7hnjBJqM3olMv+EEpoljT15He9Ev+Tl/TA2gaWp3in\nQF0ppMBOjW/MWtgR5wKGKDjxrD+trY6hLphiWbCw6omH9e5pyVPiOv75qxLXM01J\nOdS/23tYKvngL1BGdwDzQBfBXbWfLjv7ZAjYix3P7nwFjFR2K8RPw6DvDZijy3UA\nySzx/LE/6uoMMwQ2lwma1MA6Wb4iBSOAyG/0xIFZSNiXF+edbmUPy4xkNw0UB+Y0\nbLt/nXvwBVK++vHTs4n9sKWI18dq0ETa1ZRMK3RCkGdP1xLRczU=\n=bIuD\n-----END PGP SIGNATURE-----", "payload": "tree 24d39999379efe41f125b1b48ea050aa42883c42\nparent b2f8a27ff2662b440d0dd65cdb609d303b2fa280\nparent 40fd785199d80a06c1a1664d64209f78343c0e05\nauthor flip1995 <philipp.krones@embecosm.com> 1639740161 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1639743745 +0100\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "html_url": "https://github.com/rust-lang/rust/commit/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2f8a27ff2662b440d0dd65cdb609d303b2fa280", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2f8a27ff2662b440d0dd65cdb609d303b2fa280", "html_url": "https://github.com/rust-lang/rust/commit/b2f8a27ff2662b440d0dd65cdb609d303b2fa280"}, {"sha": "40fd785199d80a06c1a1664d64209f78343c0e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/40fd785199d80a06c1a1664d64209f78343c0e05", "html_url": "https://github.com/rust-lang/rust/commit/40fd785199d80a06c1a1664d64209f78343c0e05"}], "stats": {"total": 7346, "additions": 2883, "deletions": 4463}, "files": [{"sha": "e82a0ec4765bb25b5a284ffe75bce721e0d5cd1b", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -27,9 +27,11 @@ out\n # Generated by dogfood\n /target_recur/\n \n+# Generated by lintcheck\n+/lintcheck-logs\n+\n # gh pages docs\n util/gh-pages/lints.json\n-**/metadata_collection.json\n \n # rustfmt backups\n *.rs.bk"}, {"sha": "7b5279cda6ea396f48cf49df821ee9b48ab31075", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -3118,6 +3118,7 @@ Released 2018-09-13\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option\n [`result_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_unit_fn\n [`result_unit_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_unit_err\n+[`return_self_not_must_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#return_self_not_must_use\n [`reversed_empty_ranges`]: https://rust-lang.github.io/rust-clippy/master/index.html#reversed_empty_ranges\n [`same_functions_in_if_condition`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_functions_in_if_condition\n [`same_item_push`]: https://rust-lang.github.io/rust-clippy/master/index.html#same_item_push\n@@ -3209,6 +3210,7 @@ Released 2018-09-13\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n+[`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unnecessary_wraps`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_wraps\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern"}, {"sha": "73b0167d363f62ef5d78b3c9ed91c22123e4df00", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -162,7 +162,8 @@ define the `CLIPPY_DISABLE_DOCS_LINKS` environment variable.\n \n You can add options to your code to `allow`/`warn`/`deny` Clippy lints:\n \n-*   the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy::all)]`)\n+*   the whole set of `Warn` lints using the `clippy` lint group (`#![deny(clippy::all)]`).\n+    Note that `rustc` has additional [lint groups](https://doc.rust-lang.org/rustc/lints/groups.html).\n \n *   all lints using both the `clippy` and `clippy::pedantic` lint groups (`#![deny(clippy::all)]`,\n     `#![deny(clippy::pedantic)]`). Note that `clippy::pedantic` contains some very aggressive"}, {"sha": "f419781dbc82f1ef46f1f121f35aedbf2f6184ba", "filename": "clippy_lints/src/asm_syntax.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fasm_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fasm_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fasm_syntax.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -65,13 +65,15 @@ declare_clippy_lint! {\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n     /// # unsafe { let ptr = \"\".as_ptr();\n+    /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n     /// # }\n     /// ```\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n     /// # unsafe { let ptr = \"\".as_ptr();\n+    /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n     /// # }\n     /// ```\n@@ -102,13 +104,15 @@ declare_clippy_lint! {\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n     /// # unsafe { let ptr = \"\".as_ptr();\n+    /// # use std::arch::asm;\n     /// asm!(\"lea ({}), {}\", in(reg) ptr, lateout(reg) _, options(att_syntax));\n     /// # }\n     /// ```\n     /// Use instead:\n     /// ```rust,no_run\n     /// # #![feature(asm)]\n     /// # unsafe { let ptr = \"\".as_ptr();\n+    /// # use std::arch::asm;\n     /// asm!(\"lea {}, [{}]\", lateout(reg) _, in(reg) ptr);\n     /// # }\n     /// ```"}, {"sha": "b7f414742f1566bd69731f71ce323c6364c7b947", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n+use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -122,15 +122,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        // block\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(block_expr) = &block.expr;\n-        // inner block is optional. unwrap it if it exists, or use the expression as is otherwise.\n-        if let Some(begin_panic_call) = match block_expr.kind {\n-            ExprKind::Block(inner_block, _) => &inner_block.expr,\n-            _ => &block.expr,\n-        };\n+        let begin_panic_call = peel_blocks(then);\n         // function call\n         if let Some(arg) = match_panic_call(cx, begin_panic_call);\n         // bind the second argument of the `assert!` macro if it exists"}, {"sha": "475fdb440d4ecf8b0347551f308f9542bb3e0730", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -73,9 +73,11 @@ impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n \n             let body = self.cx.tcx.hir().body(eid);\n             let ex = &body.value;\n-            if matches!(ex.kind, ExprKind::Block(_, _)) && !body.value.span.from_expansion() {\n-                self.found_block = Some(ex);\n-                return;\n+            if let ExprKind::Block(block, _) = ex.kind {\n+                if !body.value.span.from_expansion() && !block.stmts.is_empty() {\n+                    self.found_block = Some(ex);\n+                    return;\n+                }\n             }\n         }\n         walk_expr(self, expr);"}, {"sha": "92336a54e27ee2ec3f0e1fb2522c36d2f22513d4", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n+use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PatKind};\n@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(count, _, [count_recv], _) = expr.kind;\n-            if count.ident.name == sym!(count);\n+            if count.ident.name == sym::count;\n             if let ExprKind::MethodCall(filter, _, [filter_recv, filter_arg], _) = count_recv.kind;\n             if filter.ident.name == sym!(filter);\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_arg.kind;\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                        cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n                        &paths::SLICE_ITER);\n             let operand_is_arg = |expr| {\n-                let expr = peel_ref_operators(cx, remove_blocks(expr));\n+                let expr = peel_ref_operators(cx, peel_blocks(expr));\n                 path_to_local_id(expr, arg_id)\n             };\n             let needle = if operand_is_arg(l) {"}, {"sha": "c71e9f10f79ec95c331e71df7a20b254458c6721", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -75,7 +75,7 @@ fn check_arm<'tcx>(\n     outer_guard: Option<&'tcx Guard<'tcx>>,\n     outer_else_body: Option<&'tcx Expr<'tcx>>,\n ) {\n-    let inner_expr = strip_singleton_blocks(outer_then_body);\n+    let inner_expr = peel_blocks_with_stmt(outer_then_body);\n     if_chain! {\n         if let Some(inner) = IfLetOrMatch::parse(cx, inner_expr);\n         if let Some((inner_scrutinee, inner_then_pat, inner_else_body)) = match inner {\n@@ -138,20 +138,6 @@ fn check_arm<'tcx>(\n     }\n }\n \n-fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n-    while let ExprKind::Block(block, _) = expr.kind {\n-        match (block.stmts, block.expr) {\n-            ([stmt], None) => match stmt.kind {\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n-                _ => break,\n-            },\n-            ([], Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n /// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n /// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {"}, {"sha": "eccb18982f30da8a74e4f8a8626a94ef7c5e3189", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{is_automatically_derived, is_default_equivalent, remove_blocks};\n+use clippy_utils::{is_automatically_derived, is_default_equivalent, peel_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                         }\n                     }\n                 }\n-                let should_emit = match remove_blocks(func_expr).kind {\n+                let should_emit = match peel_blocks(func_expr).kind {\n                     ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n                     ExprKind::Call(callee, args)\n                         if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),"}, {"sha": "2de2bfc040b5306c6d62b7d137dd023823834d1d", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::consts::{\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, sugg};\n+use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, peel_blocks, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -546,13 +546,9 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n-        if else_block.stmts.is_empty();\n-        if let Some(else_body_expr) = else_block.expr;\n+        if let Some(higher::If { cond, then, r#else: Some(r#else) }) = higher::If::hir(expr);\n+        let if_body_expr = peel_blocks(then);\n+        let else_body_expr = peel_blocks(r#else);\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);\n         then {\n             let positive_abs_sugg = ("}, {"sha": "16e5c5ca603db450474ce1697cf4e110041bbc6e", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n@@ -77,10 +77,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n             if is_lang_ctor(cx, then_call_qpath, OptionSome);\n-            if let ExprKind::Block(els_block, _) = els.kind;\n-            if els_block.stmts.is_empty();\n-            if let Some(els_expr) = els_block.expr;\n-            if let ExprKind::Path(ref qpath) = els_expr.kind;\n+            if let ExprKind::Path(ref qpath) = peel_blocks(els).kind;\n             if is_lang_ctor(cx, qpath, OptionNone);\n             if !stmts_contains_early_return(then_block.stmts);\n             then {"}, {"sha": "26a196aab5972ca577430009543fa05fa9d53251", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,10 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n-use clippy_utils::SpanlessEq;\n+use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -52,13 +51,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             // Ensure that the binary operator is >, != and <\n             if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n \n-            // Check if the true condition block has only one statement\n-            if let ExprKind::Block(block, _) = then.kind;\n-            if block.stmts.len() == 1 && block.expr.is_none();\n-\n             // Check if assign operation is done\n-            if let StmtKind::Semi(e) = block.stmts[0].kind;\n-            if let Some(target) = subtracts_one(cx, e);\n+            if let Some(target) = subtracts_one(cx, then);\n \n             // Extracting out the variable name\n             if let ExprKind::Path(QPath::Resolved(_, ares_path)) = target.kind;\n@@ -138,8 +132,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n     }\n }\n \n-fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n-    match expr.kind {\n+fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    match peel_blocks_with_stmt(expr).kind {\n         ExprKind::AssignOp(ref op1, target, value) => {\n             if_chain! {\n                 if BinOpKind::Sub == op1.node;"}, {"sha": "3d3999d4cc0d8a99bbc0bd7b408a74834402da8d", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -181,6 +181,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(methods::WRONG_SELF_CONVENTION),\n@@ -220,7 +221,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_copy_const::DECLARE_INTERIOR_MUTABLE_CONST),\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n-    LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n@@ -246,6 +246,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(reference::REF_IN_DEREF),\n     LintId::of(regex::INVALID_REGEX),\n     LintId::of(repeat_once::REPEAT_ONCE),\n+    LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(returns::LET_AND_RETURN),\n     LintId::of(returns::NEEDLESS_RETURN),\n     LintId::of(self_assignment::SELF_ASSIGNMENT),"}, {"sha": "766c5ba1bcb0f73e3837ad856f266257b433ebea", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -315,6 +315,7 @@ store.register_lints(&[\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n     methods::USELESS_ASREF,\n@@ -422,6 +423,7 @@ store.register_lints(&[\n     regex::INVALID_REGEX,\n     regex::TRIVIAL_REGEX,\n     repeat_once::REPEAT_ONCE,\n+    return_self_not_must_use::RETURN_SELF_NOT_MUST_USE,\n     returns::LET_AND_RETURN,\n     returns::NEEDLESS_RETURN,\n     same_name_method::SAME_NAME_METHOD,"}, {"sha": "e3cf067001834a3b16b00d480584e2771e37ed2e", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -18,6 +18,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n+    LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n     LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),"}, {"sha": "2ea0b696f1feb3ad437c61d8c9c1072de7da606f", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -17,6 +17,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(misc::CMP_OWNED),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),"}, {"sha": "8594338ffa5ab5558dfb2ae26a4eb7f6e831f08a", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -15,8 +15,8 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(loops::MUT_RANGE_BOUND),\n     LintId::of(methods::SUSPICIOUS_MAP),\n     LintId::of(mut_key::MUTABLE_KEY_TYPE),\n-    LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n+    LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n ])"}, {"sha": "d1c7956a7a5c89f8ce9be63a2c6d5f6b21e52979", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -340,6 +340,7 @@ mod ref_option_ref;\n mod reference;\n mod regex;\n mod repeat_once;\n+mod return_self_not_must_use;\n mod returns;\n mod same_name_method;\n mod self_assignment;\n@@ -852,6 +853,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(trailing_empty_array::TrailingEmptyArray));\n     store.register_early_pass(|| Box::new(octal_escapes::OctalEscapes));\n     store.register_late_pass(|| Box::new(needless_late_init::NeedlessLateInit));\n+    store.register_late_pass(|| Box::new(return_self_not_must_use::ReturnSelfNotMustUse));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "0e2b78609c2c13c90f3ab022f477a183a75d6171", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// - We bail out if the function has a `where` clause where lifetimes\n-    /// are mentioned due to potenial false positives.\n+    /// are mentioned due to potential false positives.\n     /// - Lifetime bounds such as `impl Foo + 'a` and `T: 'a` must be elided with the\n     /// placeholder notation `'_` because the fully elided notation leaves the type bound to `'static`.\n     ///"}, {"sha": "d276c901059974a54c38d51601f26c3a6d070638", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -3,11 +3,11 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -21,71 +21,55 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if let ExprKind::Block(block, _) = body.kind {\n-        // Ensure the `if let` statement is the only expression or statement in the for-loop\n-        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n-            let match_stmt = &block.stmts[0];\n-            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n-                Some(inner_expr)\n-            } else {\n-                None\n-            }\n-        } else if block.stmts.is_empty() {\n-            block.expr\n-        } else {\n-            None\n-        };\n+    let inner_expr = peel_blocks_with_stmt(body);\n+    if_chain! {\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+            = higher::IfLet::hir(cx, inner_expr);\n+        // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+        if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+        if path_to_local_id(let_expr, pat_hir_id);\n+        // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+        if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n+        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n+        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if some_ctor || ok_ctor;\n+        // Ensure expr in `if let` is not used afterwards\n+        if !is_local_used(cx, if_then, pat_hir_id);\n+        then {\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+            // Prepare the error message\n+            let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n \n-        if_chain! {\n-            if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n-                = higher::IfLet::hir(cx, inner_expr);\n-            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n-            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(let_expr, pat_hir_id);\n-            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-            let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-            let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n-            if some_ctor || ok_ctor;\n-            // Ensure epxr in `if let` is not used afterwards\n-            if !is_local_used(cx, if_then, pat_hir_id);\n-            then {\n-                let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-                // Prepare the error message\n-                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n-\n-                // Prepare the help message\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n-                    ty::Ref(_, inner, _) => match inner.kind() {\n-                        ty::Ref(..) => \".copied()\",\n-                        _ => \"\"\n-                    }\n+            // Prepare the help message\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+            let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n+                ty::Ref(_, inner, _) => match inner.kind() {\n+                    ty::Ref(..) => \".copied()\",\n                     _ => \"\"\n-                };\n+                }\n+                _ => \"\"\n+            };\n \n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_FLATTEN,\n-                    span,\n-                    &msg,\n-                    |diag| {\n-                        let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n-                        diag.span_suggestion(\n-                            arg.span,\n-                            \"try\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_help(\n-                            inner_expr.span,\n-                            \"...and remove the `if let` statement in the for loop\",\n-                        );\n-                    }\n-                );\n-            }\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_FLATTEN,\n+                span,\n+                &msg,\n+                |diag| {\n+                    let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n+                    diag.span_suggestion(\n+                        arg.span,\n+                        \"try\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    diag.span_help(\n+                        inner_expr.span,\n+                        \"...and remove the `if let` statement in the for loop\",\n+                    );\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "aa382f8a974b8dfaa9a55ce8e3be3c72d1b50fbe", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "68ffcd1abfb18240ce55c9bc8be3ddafa92af3fd", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -92,9 +92,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n }\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr);\n-    let mut iter = stmts.chain(expr).flatten();\n+    let mut iter = block.stmts.iter().filter_map(stmt_to_expr).chain(block.expr);\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n "}, {"sha": "262a26951c68110152da002292a89b57145c607c", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -36,7 +36,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "34a70ca76c6a2a81df2d5ab1e4b1ec35c4a673ed", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -307,16 +307,5 @@ fn get_some_expr(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                ..\n-            },\n-            _,\n-        ) => is_none_expr(cx, expr),\n-        _ => false,\n-    }\n+    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }"}, {"sha": "174c7da28d3ec1f246deac0c3dd52274aed9e1f9", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_trait_method;\n-use clippy_utils::remove_blocks;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n+use clippy_utils::{is_trait_method, peel_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -60,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             then {\n                 let closure_body = cx.tcx.hir().body(body_id);\n-                let closure_expr = remove_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(&closure_body.value);\n                 match closure_body.params[0].pat.kind {\n                     hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None"}, {"sha": "acac08872264dc9f829729742f6556e49a76df2c", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -9,7 +9,7 @@ use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, pe\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n+    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n     strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n@@ -658,7 +658,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n             if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = remove_blocks(arms[0].body);\n+            let body = peel_blocks(arms[0].body);\n             if path_to_local_id(body, arg);\n \n             then {\n@@ -723,7 +723,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             return;\n         }\n         let els = arms[1].body;\n-        let els = if is_unit_expr(remove_blocks(els)) {\n+        let els = if is_unit_expr(peel_blocks(els)) {\n             None\n         } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n             if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n@@ -1481,7 +1481,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n-    let match_body = remove_blocks(arms[0].body);\n+    let match_body = peel_blocks(arms[0].body);\n     let mut snippet_body = if match_body.span.from_expansion() {\n         Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n     } else {\n@@ -1678,7 +1678,7 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n         if is_lang_ctor(cx, qpath, OptionSome);\n         if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;"}, {"sha": "150bafc0f5db228f216127d3382c0be03e8ec353", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,7 +1,7 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::{remove_blocks, visitors::find_all_ret_expressions};\n+use clippy_utils::{peel_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -152,7 +152,7 @@ pub(crate) trait BindInsteadOfMap {\n         match arg.kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n-                let closure_expr = remove_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(&closure_body.value);\n \n                 if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, closure_args_span) {\n                     true"}, {"sha": "6d8733c08b43012b5870de5e382410baa783cbfb", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, SpanlessEq};\n+use clippy_utils::{is_trait_method, path_to_local_id, peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -25,7 +25,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n         },\n         hir::ExprKind::Closure(_, _, c, _, _) => {\n             let body = cx.tcx.hir().body(*c);\n-            let closure_expr = remove_blocks(&body.value);\n+            let closure_expr = peel_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n                 hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, args, _) => {"}, {"sha": "90492ffda3cc6e626706dde8ee340b459ff7bd38", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -12,15 +12,7 @@ use super::IMPLICIT_CLONE;\n pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, span: Span) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-        if match method_name {\n-            \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n-            \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n-            \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n-            \"to_vec\" => cx.tcx.impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true),\n-            _ => false,\n-        };\n+        if is_clone_like(cx, method_name, method_def_id);\n         let return_type = cx.typeck_results().expr_ty(expr);\n         let input_type = cx.typeck_results().expr_ty(recv).peel_refs();\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n@@ -38,3 +30,22 @@ pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv\n         }\n     }\n }\n+\n+/// Returns true if the named method can be used to clone the receiver.\n+/// Note that `to_string` is not flagged by `implicit_clone`. So other lints that call\n+/// `is_clone_like` and that do flag `to_string` must handle it separately. See, e.g.,\n+/// `is_to_owned_like` in `unnecessary_to_owned.rs`.\n+pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir::def_id::DefId) -> bool {\n+    match method_name {\n+        \"to_os_string\" => is_diag_item_method(cx, method_def_id, sym::OsStr),\n+        \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n+        \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n+        \"to_vec\" => {\n+            cx.tcx\n+                .impl_of_method(method_def_id)\n+                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n+                == Some(true)\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "3c43671dd34c9e0f1e44581989f1c1751880ba5f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -56,7 +56,9 @@ mod suspicious_splitn;\n mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n+mod unnecessary_iter_cloned;\n mod unnecessary_lazy_eval;\n+mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n@@ -1885,6 +1887,32 @@ declare_clippy_lint! {\n     \"usages of `str::splitn` that can be replaced with `str::split`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary calls to [`ToOwned::to_owned`](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned)\n+    /// and other `to_owned`-like functions.\n+    ///\n+    /// ### Why is this bad?\n+    /// The unnecessary calls result in useless allocations.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy().to_string());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub UNNECESSARY_TO_OWNED,\n+    perf,\n+    \"unnecessary calls to `to_owned`-like functions\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1964,7 +1992,8 @@ impl_lint_pass!(Methods => [\n     MANUAL_STR_REPEAT,\n     EXTEND_WITH_DRAIN,\n     MANUAL_SPLIT_ONCE,\n-    NEEDLESS_SPLITN\n+    NEEDLESS_SPLITN,\n+    UNNECESSARY_TO_OWNED,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2007,6 +2036,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 single_char_add_str::check(cx, expr, args);\n                 into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {"}, {"sha": "fa74a8f3dc363b8a7df525d59c5df03650153f4f", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, meets_msrv, msrvs, path_to_local_id, paths, remove_blocks};\n+use clippy_utils::{match_def_path, meets_msrv, msrvs, path_to_local_id, paths, peel_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -53,7 +53,7 @@ pub(super) fn check<'tcx>(\n             }),\n         hir::ExprKind::Closure(_, _, body_id, _, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n                 hir::ExprKind::MethodCall(_, _, args, _) => {"}, {"sha": "47a811996085e59d95fa98475a33a0a367a9f1d8", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, strip_pat_refs};\n+use clippy_utils::{is_trait_method, path_to_local_id, peel_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -31,7 +31,7 @@ pub(super) fn check(\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n             if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;"}, {"sha": "8300df03e9935a9f0219364edc2ebc3a817cd2c4", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,177 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher::ForLoop;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n+use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+use rustc_span::{sym, Symbol};\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        then {\n+            check_for_loop_iter(cx, parent, method_name, receiver)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is an iterator in a `for` loop and, if so, determines whether the\n+/// iterated-over items could be iterated over by reference. The reason why `check` above does not\n+/// include this code directly is so that it can be called from\n+/// `unnecessary_into_owned::check_into_iter_call_arg`.\n+pub fn check_for_loop_iter(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(grandparent) = get_parent_expr(cx, expr).and_then(|parent| get_parent_expr(cx, parent));\n+        if let Some(ForLoop { pat, body, .. }) = ForLoop::hir(grandparent);\n+        let (clone_or_copy_needed, addr_of_exprs) = clone_or_copy_needed(cx, pat, body);\n+        if !clone_or_copy_needed;\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let snippet = if_chain! {\n+                if let ExprKind::MethodCall(maybe_iter_method_name, _, [collection], _) = receiver.kind;\n+                if maybe_iter_method_name.ident.name == sym::iter;\n+\n+                if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                if implements_trait(cx, receiver_ty, iterator_trait_id, &[]);\n+                if let Some(iter_item_ty) = get_iterator_item_ty(cx, receiver_ty);\n+\n+                if let Some(into_iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::IntoIterator);\n+                let collection_ty = cx.typeck_results().expr_ty(collection);\n+                if implements_trait(cx, collection_ty, into_iterator_trait_id, &[]);\n+                if let Some(into_iter_item_ty) = get_associated_type(cx, collection_ty, into_iterator_trait_id, \"Item\");\n+\n+                if iter_item_ty == into_iter_item_ty;\n+                if let Some(collection_snippet) = snippet_opt(cx, collection.span);\n+                then {\n+                    collection_snippet\n+                } else {\n+                    receiver_snippet\n+                }\n+            };\n+            span_lint_and_then(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                expr.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                |diag| {\n+                    diag.span_suggestion(expr.span, \"use\", snippet, Applicability::MachineApplicable);\n+                    for addr_of_expr in addr_of_exprs {\n+                        match addr_of_expr.kind {\n+                            ExprKind::AddrOf(_, _, referent) => {\n+                                let span = addr_of_expr.span.with_hi(referent.span.lo());\n+                                diag.span_suggestion(span, \"remove this `&`\", String::new(), Applicability::MachineApplicable);\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                    }\n+                }\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n+/// `CloneOrCopyVisitor`.\n+fn clone_or_copy_needed(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, _, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}\n+\n+/// Returns true if the named method is `IntoIterator::into_iter`.\n+pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n+    cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)\n+}"}, {"sha": "c48bacfce0d37739f159b379fac6d10921093dac", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,397 @@\n+use super::implicit_clone::is_clone_like;\n+use super::unnecessary_iter_cloned::{self, is_into_iter};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_span::{sym, Symbol};\n+use std::cmp::max;\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n+    if_chain! {\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if let [receiver] = args;\n+        then {\n+            if is_cloned_or_copied(cx, method_name, method_def_id) {\n+                unnecessary_iter_cloned::check(cx, expr, method_name, receiver);\n+            } else if is_to_owned_like(cx, method_name, method_def_id) {\n+                // At this point, we know the call is of a `to_owned`-like function. The functions\n+                // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n+                // based on its context, that is, whether it is a referent in an `AddrOf` expression, an\n+                // argument in a `into_iter` call, or an argument in the call of some other function.\n+                if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n+                    return;\n+                }\n+                if check_into_iter_call_arg(cx, expr, method_name, receiver) {\n+                    return;\n+                }\n+                check_other_call_arg(cx, expr, method_name, receiver);\n+            }\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is a referent in an `AddrOf` expression and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+#[allow(clippy::too_many_lines)]\n+fn check_addr_of_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    method_def_id: DefId,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind;\n+        let adjustments = cx.typeck_results().expr_adjustments(parent).iter().collect::<Vec<_>>();\n+        if let Some(target_ty) = match adjustments[..]\n+        {\n+            // For matching uses of `Cow::from`\n+            [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching uses of arrays\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Pointer(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching everything else\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Deref(Some(OverloadedDeref { .. })),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ] => Some(target_ty),\n+            _ => None,\n+        };\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // Only flag cases where the receiver is copyable or the method is `Cow::into_owned`. This\n+        // restriction is to ensure there is not overlap between `redundant_clone` and this lint.\n+        if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n+            if receiver_ty == target_ty && n_target_refs >= n_receiver_refs {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_TO_OWNED,\n+                    parent.span,\n+                    &format!(\"unnecessary use of `{}`\", method_name),\n+                    \"use\",\n+                    format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_target_refs - n_receiver_refs),\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n+            }\n+            if_chain! {\n+                if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+                if implements_trait(cx, receiver_ty, deref_trait_id, &[]);\n+                if get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(target_ty);\n+                then {\n+                    if n_receiver_refs > 0 {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            parent.span,\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"use\",\n+                            receiver_snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_TO_OWNED,\n+                            expr.span.with_lo(receiver.span.hi()),\n+                            &format!(\"unnecessary use of `{}`\", method_name),\n+                            \"remove this\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    return true;\n+                }\n+            }\n+            if_chain! {\n+                if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+                if implements_trait(cx, receiver_ty, as_ref_trait_id, &[GenericArg::from(target_ty)]);\n+                then {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        parent.span,\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"use\",\n+                        format!(\"{}.as_ref()\", receiver_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks whether `expr` is an argument in an `into_iter` call and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+fn check_into_iter_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let Some(callee_def_id) = fn_def_id(cx, parent);\n+        if is_into_iter(cx, callee_def_id);\n+        if let Some(iterator_trait_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n+        let parent_ty = cx.typeck_results().expr_ty(parent);\n+        if implements_trait(cx, parent_ty, iterator_trait_id, &[]);\n+        if let Some(item_ty) = get_iterator_item_ty(cx, parent_ty);\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver) {\n+                return true;\n+            }\n+            let cloned_or_copied = if is_copy(cx, item_ty) {\n+                \"copied\"\n+            } else {\n+                \"cloned\"\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                parent.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{}.iter().{}()\", receiver_snippet, cloned_or_copied),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks whether `expr` is an argument in a function call and, if so, determines whether its call\n+/// of a `to_owned`-like function is unnecessary.\n+fn check_other_call_arg(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n+        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        if let Some(input) = fn_sig.inputs().get(i);\n+        let (input, n_refs) = peel_mid_ty_refs(input);\n+        if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n+        if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n+        if let [trait_predicate] = trait_predicates\n+            .iter()\n+            .filter(|trait_predicate| trait_predicate.def_id() != sized_def_id)\n+            .collect::<Vec<_>>()[..];\n+        if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+        if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // If the callee has type parameters, they could appear in `projection_predicate.ty` or the\n+        // types of `trait_predicate.trait_ref.substs`.\n+        if if trait_predicate.def_id() == deref_trait_id {\n+            if let [projection_predicate] = projection_predicates[..] {\n+                let normalized_ty =\n+                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.ty);\n+                implements_trait(cx, receiver_ty, deref_trait_id, &[])\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\") == Some(normalized_ty)\n+            } else {\n+                false\n+            }\n+        } else if trait_predicate.def_id() == as_ref_trait_id {\n+            let composed_substs = compose_substs(\n+                cx,\n+                &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n+                call_substs\n+            );\n+            implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n+        } else {\n+            false\n+        };\n+        // We can't add an `&` when the trait is `Deref` because `Target = &T` won't match\n+        // `Target = T`.\n+        if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n+        let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                maybe_arg.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_refs),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}\n+\n+/// Walks an expression's ancestors until it finds a non-`AddrOf` expression. Returns the first such\n+/// expression found (if any) along with the immediately prior expression.\n+fn skip_addr_of_ancestors(\n+    cx: &LateContext<'tcx>,\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    while let Some(parent) = get_parent_expr(cx, expr) {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind {\n+            expr = parent;\n+        } else {\n+            return Some((parent, expr));\n+        }\n+    }\n+    None\n+}\n+\n+/// Checks whether an expression is a function or method call and, if so, returns its `DefId`,\n+/// `Substs`, and arguments.\n+fn get_callee_substs_and_args(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+    if_chain! {\n+        if let ExprKind::Call(callee, args) = expr.kind;\n+        let callee_ty = cx.typeck_results().expr_ty(callee);\n+        if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n+        then {\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            return Some((*callee_def_id, substs, args));\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, args, _) = expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        then {\n+            let substs = cx.typeck_results().node_substs(expr.hir_id);\n+            return Some((method_def_id, substs, args));\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns the `TraitPredicate`s and `ProjectionPredicate`s for a function's input type.\n+fn get_input_traits_and_projections(\n+    cx: &LateContext<'tcx>,\n+    callee_def_id: DefId,\n+    input: Ty<'tcx>,\n+) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n+    let mut trait_predicates = Vec::new();\n+    let mut projection_predicates = Vec::new();\n+    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n+        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n+        // `as`. The remaining n are trait parameters.\n+        let is_input_substs = |substs: SubstsRef<'tcx>| {\n+            if_chain! {\n+                if let Some(arg) = substs.iter().next();\n+                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n+                if arg_ty == input;\n+                then {\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+        match predicate.kind().skip_binder() {\n+            PredicateKind::Trait(trait_predicate) => {\n+                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                    trait_predicates.push(trait_predicate);\n+                }\n+            },\n+            PredicateKind::Projection(projection_predicate) => {\n+                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                    projection_predicates.push(projection_predicate);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+    (trait_predicates, projection_predicates)\n+}\n+\n+/// Composes two substitutions by applying the latter to the types of the former.\n+fn compose_substs(cx: &LateContext<'tcx>, left: &[GenericArg<'tcx>], right: SubstsRef<'tcx>) -> Vec<GenericArg<'tcx>> {\n+    left.iter()\n+        .map(|arg| {\n+            if let GenericArgKind::Type(arg_ty) = arg.unpack() {\n+                let normalized_ty = cx.tcx.subst_and_normalize_erasing_regions(right, cx.param_env, arg_ty);\n+                GenericArg::from(normalized_ty)\n+            } else {\n+                *arg\n+            }\n+        })\n+        .collect()\n+}\n+\n+/// Returns true if the named method is `Iterator::cloned` or `Iterator::copied`.\n+fn is_cloned_or_copied(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    (method_name.as_str() == \"cloned\" || method_name.as_str() == \"copied\")\n+        && is_diag_trait_item(cx, method_def_id, sym::Iterator)\n+}\n+\n+/// Returns true if the named method can be used to convert the receiver to its \"owned\"\n+/// representation.\n+fn is_to_owned_like(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    is_clone_like(cx, &*method_name.as_str(), method_def_id)\n+        || is_cow_into_owned(cx, method_name, method_def_id)\n+        || is_to_string(cx, method_name, method_def_id)\n+}\n+\n+/// Returns true if the named method is `Cow::into_owned`.\n+fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"into_owned\" && is_diag_item_method(cx, method_def_id, sym::Cow)\n+}\n+\n+/// Returns true if the named method is `ToString::to_string`.\n+fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n+    method_name.as_str() == \"to_string\" && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+}"}, {"sha": "db6aab0671bd08d7a58a9a0a02675072d6d45c7e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -57,6 +58,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,9 @@ impl MissingDoc {\n             return;\n         }\n \n-        let has_doc = attrs.iter().any(|a| a.doc_str().is_some());\n+        let has_doc = attrs\n+            .iter()\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "fa7274990db390d1c3f32fb67153b61daaecdd76", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -88,10 +88,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "d391fbecf82e14ea9b2cffde2267704bd6f8ecf4", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 53, "deletions": 44, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -6,10 +6,10 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{is_else_clause, is_expn_of};\n+use clippy_utils::{get_parent_node, is_else_clause, is_expn_of, peel_blocks, peel_blocks_with_stmt};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Node, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n@@ -74,6 +74,36 @@ declare_clippy_lint! {\n \n declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n \n+fn condition_needs_parentheses(e: &Expr<'_>) -> bool {\n+    let mut inner = e;\n+    while let ExprKind::Binary(_, i, _)\n+    | ExprKind::Call(i, _)\n+    | ExprKind::Cast(i, _)\n+    | ExprKind::Type(i, _)\n+    | ExprKind::Index(i, _) = inner.kind\n+    {\n+        if matches!(\n+            i.kind,\n+            ExprKind::Block(..)\n+                | ExprKind::ConstBlock(..)\n+                | ExprKind::If(..)\n+                | ExprKind::Loop(..)\n+                | ExprKind::Match(..)\n+        ) {\n+            return true;\n+        }\n+        inner = i;\n+    }\n+    false\n+}\n+\n+fn is_parent_stmt(cx: &LateContext<'_>, id: HirId) -> bool {\n+    matches!(\n+        get_parent_node(cx.tcx, id),\n+        Some(Node::Stmt(..) | Node::Block(Block { stmts: &[], .. }))\n+    )\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::{Bool, RetBool};\n@@ -99,6 +129,10 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     snip = snip.blockify();\n                 }\n \n+                if condition_needs_parentheses(cond) && is_parent_stmt(cx, e.hir_id) {\n+                    snip = snip.maybe_par();\n+                }\n+\n                 span_lint_and_sugg(\n                     cx,\n                     NEEDLESS_BOOL,\n@@ -109,8 +143,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(then, _) = then.kind {\n-                match (fetch_bool_block(then), fetch_bool_expr(r#else)) {\n+            if let Some((a, b)) = fetch_bool_block(then).and_then(|a| Some((a, fetch_bool_block(r#else)?))) {\n+                match (a, b) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,\n@@ -133,8 +167,6 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     (Bool(false), Bool(true)) => reduce(false, true),\n                     _ => (),\n                 }\n-            } else {\n-                panic!(\"IfExpr `then` node is not an `ExprKind::Block`\");\n             }\n         }\n     }\n@@ -237,8 +269,6 @@ fn check_comparison<'a, 'tcx>(\n     right_false: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n     no_literal: Option<(impl FnOnce(Sugg<'a>, Sugg<'a>) -> Sugg<'a>, &str)>,\n ) {\n-    use self::Expression::{Bool, Other};\n-\n     if let ExprKind::Binary(op, left_side, right_side) = e.kind {\n         let (l_ty, r_ty) = (\n             cx.typeck_results().expr_ty(left_side),\n@@ -270,19 +300,19 @@ fn check_comparison<'a, 'tcx>(\n             }\n \n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-                (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n+                (Some(true), None) => left_true.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n-                (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n+                (None, Some(true)) => right_true.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n-                (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n+                (Some(false), None) => left_false.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n-                (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n+                (None, Some(false)) => right_false.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n-                (Other, Other) => no_literal.map_or((), |(h, m)| {\n+                (None, None) => no_literal.map_or((), |(h, m)| {\n                     let left_side = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     let right_side = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n@@ -331,41 +361,20 @@ fn suggest_bool_comparison<'a, 'tcx>(\n enum Expression {\n     Bool(bool),\n     RetBool(bool),\n-    Other,\n }\n \n-fn fetch_bool_block(block: &Block<'_>) -> Expression {\n-    match (&*block.stmts, block.expr.as_ref()) {\n-        (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => {\n-            if let StmtKind::Semi(e) = e.kind {\n-                if let ExprKind::Ret(_) = e.kind {\n-                    fetch_bool_expr(e)\n-                } else {\n-                    Expression::Other\n-                }\n-            } else {\n-                Expression::Other\n-            }\n-        },\n-        _ => Expression::Other,\n+fn fetch_bool_block(expr: &Expr<'_>) -> Option<Expression> {\n+    match peel_blocks_with_stmt(expr).kind {\n+        ExprKind::Ret(Some(ret)) => Some(Expression::RetBool(fetch_bool_expr(ret)?)),\n+        _ => Some(Expression::Bool(fetch_bool_expr(expr)?)),\n     }\n }\n \n-fn fetch_bool_expr(expr: &Expr<'_>) -> Expression {\n-    match expr.kind {\n-        ExprKind::Block(block, _) => fetch_bool_block(block),\n-        ExprKind::Lit(ref lit_ptr) => {\n-            if let LitKind::Bool(value) = lit_ptr.node {\n-                Expression::Bool(value)\n-            } else {\n-                Expression::Other\n-            }\n-        },\n-        ExprKind::Ret(Some(expr)) => match fetch_bool_expr(expr) {\n-            Expression::Bool(value) => Expression::RetBool(value),\n-            _ => Expression::Other,\n-        },\n-        _ => Expression::Other,\n+fn fetch_bool_expr(expr: &Expr<'_>) -> Option<bool> {\n+    if let ExprKind::Lit(ref lit_ptr) = peel_blocks(expr).kind {\n+        if let LitKind::Bool(value) = lit_ptr.node {\n+            return Some(value);\n+        }\n     }\n+    None\n }"}, {"sha": "094a3f111ba5ae5d9f4b17415166ce4e7b92c09c", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -73,7 +73,7 @@ fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) ->\n     seen\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n struct LocalAssign {\n     lhs_id: HirId,\n     lhs_span: Span,\n@@ -154,14 +154,15 @@ fn assignment_suggestions<'tcx>(\n         assignments.push(assign);\n     }\n \n-    let suggestions = assignments.clone()\n-        .into_iter()\n+    let suggestions = assignments\n+        .iter()\n         .map(|assignment| Some((assignment.span.until(assignment.rhs_span), String::new())))\n-        .chain(\n-            assignments\n-                .into_iter()\n-                .map(|assignment| Some((assignment.rhs_span.shrink_to_hi().with_hi(assignment.span.hi()), String::new())))\n-        )\n+        .chain(assignments.iter().map(|assignment| {\n+            Some((\n+                assignment.rhs_span.shrink_to_hi().with_hi(assignment.span.hi()),\n+                String::new(),\n+            ))\n+        }))\n         .collect::<Option<Vec<(Span, String)>>>()?;\n \n     let applicability = if suggestions.len() > 1 {"}, {"sha": "9d5babc5de840d69e3f5941cc0459a5420fd2ed2", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n use clippy_utils::is_lint_allowed;\n+use clippy_utils::peel_blocks;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n@@ -114,7 +115,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n-    match expr.kind {\n+    match peel_blocks(expr).kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n         ExprKind::Index(a, b) | ExprKind::Binary(_, a, b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n@@ -150,9 +151,6 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| has_no_effect(cx, expr))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "203f03d3603c8058a19821b16519c2e16199978c", "filename": "clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -13,24 +13,28 @@ use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Warns about fields in struct implementing `Send` that are neither `Send` nor `Copy`.\n+    /// This lint warns about a `Send` implementation for a type that\n+    /// contains fields that are not safe to be sent across threads.\n+    /// It tries to detect fields that can cause a soundness issue\n+    /// when sent to another thread (e.g., `Rc`) while allowing `!Send` fields\n+    /// that are expected to exist in a `Send` type, such as raw pointers.\n     ///\n     /// ### Why is this bad?\n-    /// Sending the struct to another thread will transfer the ownership to\n-    /// the new thread by dropping in the current thread during the transfer.\n-    /// This causes soundness issues for non-`Send` fields, as they are also\n-    /// dropped and might not be set up to handle this.\n+    /// Sending the struct to another thread effectively sends all of its fields,\n+    /// and the fields that do not implement `Send` can lead to soundness bugs\n+    /// such as data races when accessed in a thread\n+    /// that is different from the thread that created it.\n     ///\n     /// See:\n     /// * [*The Rustonomicon* about *Send and Sync*](https://doc.rust-lang.org/nomicon/send-and-sync.html)\n     /// * [The documentation of `Send`](https://doc.rust-lang.org/std/marker/trait.Send.html)\n     ///\n     /// ### Known Problems\n-    /// Data structures that contain raw pointers may cause false positives.\n-    /// They are sometimes safe to be sent across threads but do not implement\n-    /// the `Send` trait. This lint has a heuristic to filter out basic cases\n-    /// such as `Vec<*const T>`, but it's not perfect. Feel free to create an\n-    /// issue if you have a suggestion on how this heuristic can be improved.\n+    /// This lint relies on heuristics to distinguish types that are actually\n+    /// unsafe to be sent across threads and `!Send` types that are expected to\n+    /// exist in  `Send` type. Its rule can filter out basic cases such as\n+    /// `Vec<*const T>`, but it's not perfect. Feel free to create an issue if\n+    /// you have a suggestion on how this heuristic can be improved.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n@@ -46,8 +50,8 @@ declare_clippy_lint! {\n     /// or specify correct bounds on generic type parameters (`T: Send`).\n     #[clippy::version = \"1.57.0\"]\n     pub NON_SEND_FIELDS_IN_SEND_TY,\n-    suspicious,\n-    \"there is field that does not implement `Send` in a `Send` struct\"\n+    nursery,\n+    \"there is a field that is not safe to be sent to another thread in a `Send` struct\"\n }\n \n #[derive(Copy, Clone)]\n@@ -120,14 +124,14 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n                         NON_SEND_FIELDS_IN_SEND_TY,\n                         item.span,\n                         &format!(\n-                            \"this implementation is unsound, as some fields in `{}` are `!Send`\",\n+                            \"some fields in `{}` are not safe to be sent to another thread\",\n                             snippet(cx, hir_impl.self_ty.span, \"Unknown\")\n                         ),\n                         |diag| {\n                             for field in non_send_fields {\n                                 diag.span_note(\n                                     field.def.span,\n-                                    &format!(\"the type of field `{}` is `!Send`\", field.def.ident.name),\n+                                    &format!(\"it is not safe to send field `{}` to another thread\", field.def.ident.name),\n                                 );\n \n                                 match field.generic_params.len() {"}, {"sha": "953de0f72a86bbdd7d8ec75c8d73d63b3e8d061c", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,15 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, in_constant, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n-    CaptureKind,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -86,28 +85,6 @@ struct OptionIfLetElseOccurence {\n     none_expr: String,\n }\n \n-/// Extracts the body of a given arm. If the arm contains only an expression,\n-/// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n-    if let ExprKind::Block(\n-        Block {\n-            stmts: block_stmts,\n-            expr: Some(block_expr),\n-            ..\n-        },\n-        _,\n-    ) = expr.kind\n-    {\n-        if let [] = block_stmts {\n-            Some(block_expr)\n-        } else {\n-            Some(expr)\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n@@ -135,7 +112,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n         if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n         if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n-        if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n+        if let PatKind::Binding(bind_annotation, _, id, None) = &inner_pat.kind;\n         if let Some(some_captures) = can_move_expr_to_closure(cx, if_then);\n         if let Some(none_captures) = can_move_expr_to_closure(cx, if_else);\n         if some_captures\n@@ -145,8 +122,8 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_expr(if_then)?;\n-            let none_body = extract_body_from_expr(if_else)?;\n+            let some_body = peel_blocks(if_then);\n+            let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {"}, {"sha": "c765c8962cf70ee8ac533fe58940f38cbd74061a", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 8, "deletions": 57, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n+use clippy_utils::{eq_expr_value, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -68,14 +67,8 @@ impl QuestionMark {\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n                 if let Some(else_inner) = r#else {\n-                    if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_inner.kind;\n-                        if block.stmts.is_empty();\n-                        if let Some(block_expr) = &block.expr;\n-                        if eq_expr_value(cx, subject, block_expr);\n-                        then {\n-                            replacement = Some(format!(\"Some({}?)\", receiver_str));\n-                        }\n+                    if eq_expr_value(cx, subject, peel_blocks(else_inner)) {\n+                        replacement = Some(format!(\"Some({}?)\", receiver_str));\n                     }\n                 } else if Self::moves_by_default(cx, subject)\n                     && !matches!(subject.kind, ExprKind::Call(..) | ExprKind::MethodCall(..))\n@@ -110,10 +103,7 @@ impl QuestionMark {\n \n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-            if let ExprKind::Block(block, None) = if_then.kind;\n-            if block.stmts.is_empty();\n-            if let Some(trailing_expr) = &block.expr;\n-            if path_to_local_id(trailing_expr, bind_id);\n+            if path_to_local_id(peel_blocks(if_then), bind_id);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n@@ -159,59 +149,20 @@ impl QuestionMark {\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        match expression.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_none(cx, return_expression);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expression).kind {\n             ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n             _ => false,\n         }\n     }\n \n     fn expression_returns_unmodified_err(cx: &LateContext<'_>, expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n-        match expr.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_unmodified_err(cx, return_expression, cond_expr);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expr).kind {\n             ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(cx, ret_expr, cond_expr),\n-            ExprKind::Path(_) => path_to_local(expr) == path_to_local(cond_expr),\n+            ExprKind::Path(_) => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         }\n     }\n-\n-    fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-        // Check if last expression is a return statement. Then, return the expression\n-        if_chain! {\n-            if block.stmts.len() == 1;\n-            if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(expr) = expr.kind;\n-            if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n-\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        // Check for `return` without a semicolon.\n-        if_chain! {\n-            if block.stmts.is_empty();\n-            if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.kind);\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {"}, {"sha": "09c64485bbb27f4b605e27d51e7d48b15e1bb2c9", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -342,7 +342,7 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,"}, {"sha": "1118da6c8cb57299cff3acb51bf8c2d0940a5367", "filename": "clippy_lints/src/return_self_not_must_use.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,105 @@\n+use clippy_utils::{diagnostics::span_lint, must_use_attr, nth_arg, return_ty};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{Body, FnDecl, HirId, TraitItem, TraitItemKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// This lint warns when a method returning `Self` doesn't have the `#[must_use]` attribute.\n+    ///\n+    /// ### Why is this bad?\n+    /// It prevents to \"forget\" to use the newly created value.\n+    ///\n+    /// ### Limitations\n+    /// This lint is only applied on methods taking a `self` argument. It would be mostly noise\n+    /// if it was added on constructors for example.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// pub struct Bar;\n+    ///\n+    /// impl Bar {\n+    ///     // Bad\n+    ///     pub fn bar(&self) -> Self {\n+    ///         Self\n+    ///     }\n+    ///\n+    ///     // Good\n+    ///     #[must_use]\n+    ///     pub fn foo(&self) -> Self {\n+    ///         Self\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.59.0\"]\n+    pub RETURN_SELF_NOT_MUST_USE,\n+    suspicious,\n+    \"missing `#[must_use]` annotation on a method returning `Self`\"\n+}\n+\n+declare_lint_pass!(ReturnSelfNotMustUse => [RETURN_SELF_NOT_MUST_USE]);\n+\n+fn check_method(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'tcx>, fn_def: LocalDefId, span: Span, hir_id: HirId) {\n+    if_chain! {\n+        // If it comes from an external macro, better ignore it.\n+        if !in_external_macro(cx.sess(), span);\n+        if decl.implicit_self.has_implicit_self();\n+        // We only show this warning for public exported methods.\n+        if cx.access_levels.is_exported(fn_def);\n+        if cx.tcx.visibility(fn_def.to_def_id()).is_public();\n+        // No need to warn if the attribute is already present.\n+        if must_use_attr(cx.tcx.hir().attrs(hir_id)).is_none();\n+        let ret_ty = return_ty(cx, hir_id);\n+        let self_arg = nth_arg(cx, hir_id, 0);\n+        // If `Self` has the same type as the returned type, then we want to warn.\n+        //\n+        // For this check, we don't want to remove the reference on the returned type because if\n+        // there is one, we shouldn't emit a warning!\n+        if self_arg.peel_refs() == ret_ty;\n+\n+        then {\n+            span_lint(\n+                cx,\n+                RETURN_SELF_NOT_MUST_USE,\n+                span,\n+                \"missing `#[must_use]` attribute on a method returning `Self`\",\n+            );\n+        }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'tcx>,\n+        _: &'tcx Body<'tcx>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if_chain! {\n+            // We are only interested in methods, not in functions or associated functions.\n+            if matches!(kind, FnKind::Method(_, _, _));\n+            if let Some(fn_def) = cx.tcx.hir().opt_local_def_id(hir_id);\n+            if let Some(impl_def) = cx.tcx.impl_of_method(fn_def.to_def_id());\n+            // We don't want this method to be te implementation of a trait because the\n+            // `#[must_use]` should be put on the trait definition directly.\n+            if cx.tcx.trait_id_of_impl(impl_def).is_none();\n+\n+            then {\n+                check_method(cx, decl, fn_def, span, hir_id);\n+            }\n+        }\n+    }\n+\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n+        if let TraitItemKind::Fn(ref sig, _) = item.kind {\n+            check_method(cx, sig.decl, item.def_id, item.span, item.hir_id());\n+        }\n+    }\n+}"}, {"sha": "73600a8a08773402f7d3144ae91f325202e8ab14", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::SpanlessEq;\n use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method_calls, paths};\n+use clippy_utils::{peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n@@ -201,17 +201,14 @@ fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n-    match src.kind {\n+    match peel_blocks(src).kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n             left,\n             _,\n         ) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "481e595743585a8ea3ad5794b0dc53a93b4f459c", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -350,16 +350,28 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         match item.kind {\n-            ImplItemKind::Const(ty, _) | ImplItemKind::TyAlias(ty) => self.check_ty(\n-                cx,\n-                ty,\n-                CheckTyContext {\n-                    is_in_trait_impl: true,\n-                    ..CheckTyContext::default()\n-                },\n-            ),\n-            // methods are covered by check_fn\n-            ImplItemKind::Fn(..) => (),\n+            ImplItemKind::Const(ty, _) => {\n+                let is_in_trait_impl = if let Some(hir::Node::Item(item)) =\n+                    cx.tcx.hir().find(cx.tcx.hir().get_parent_item(item.hir_id()))\n+                {\n+                    matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+                } else {\n+                    false\n+                };\n+\n+                self.check_ty(\n+                    cx,\n+                    ty,\n+                    CheckTyContext {\n+                        is_in_trait_impl,\n+                        ..CheckTyContext::default()\n+                    },\n+                );\n+            },\n+            // Methods are covered by check_fn.\n+            // Type aliases are ignored because oftentimes it's impossible to\n+            // make type alias declaration in trait simpler, see #1013\n+            ImplItemKind::Fn(..) | ImplItemKind::TyAlias(..) => (),\n         }\n     }\n \n@@ -417,6 +429,14 @@ impl Types {\n     }\n \n     fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, context: CheckTyContext) {\n+        // Ignore functions in trait implementations as they are usually forced by the trait definition.\n+        //\n+        // FIXME: idially we would like to warn *if the compicated type can be simplified*, but it's hard to\n+        // check.\n+        if context.is_in_trait_impl {\n+            return;\n+        }\n+\n         for input in decl.inputs {\n             self.check_ty(cx, input, context);\n         }\n@@ -435,12 +455,12 @@ impl Types {\n             return;\n         }\n \n-        if !context.is_nested_call && type_complexity::check(cx, hir_ty, self.type_complexity_threshold) {\n+        // Skip trait implementations; see issue #605.\n+        if context.is_in_trait_impl {\n             return;\n         }\n \n-        // Skip trait implementations; see issue #605.\n-        if context.is_in_trait_impl {\n+        if !context.is_nested_call && type_complexity::check(cx, hir_ty, self.type_complexity_threshold) {\n             return;\n         }\n "}, {"sha": "fe35ff33d35a4736f49f8a3b656e75b3f82b787d", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n                                     trait_name\n                                 ),\n                                 Some(last_semi),\n-                                &\"probably caused by this trailing semicolon\".to_string(),\n+                                \"probably caused by this trailing semicolon\",\n                             );\n                         },\n                         None => {},"}, {"sha": "81e9c2e15c97a19b8a4d7220b90576a998b06dc9", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls, path_to_res,\n-    paths, SpanlessEq,\n+    higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls,\n+    path_to_res, paths, peel_blocks_with_stmt, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -662,10 +661,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n-            if let ExprKind::Block(block, _) = &body.value.kind;\n-            let stmts = &block.stmts;\n-            if stmts.len() == 1 && block.expr.is_none();\n-            if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n+            let only_expr = peel_blocks_with_stmt(&body.value);\n             if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);"}, {"sha": "7707eebd6223e2cb01ab4b0b4bd559ab3fc7aa6c", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -8,6 +8,11 @@\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n //! a simple mistake)\n \n+use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n+use clippy_utils::{last_path_segment, match_def_path, match_function_call, match_path, paths};\n use if_chain::if_chain;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -25,12 +30,6 @@ use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n-use clippy_utils::{\n-    diagnostics::span_lint, last_path_segment, match_def_path, match_function_call, match_path, paths, ty::match_type,\n-    ty::walk_ptrs_ty_depth,\n-};\n-\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../util/gh-pages/lints.json\";\n /// These lints are excluded from the export."}, {"sha": "b8e53e47ed9e58c74a3c944743aa196f61ac499b", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -41,13 +41,15 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Consider expressions containing potential side effects as not equal.\n+    #[must_use]\n     pub fn deny_side_effects(self) -> Self {\n         Self {\n             allow_side_effects: false,\n             ..self\n         }\n     }\n \n+    #[must_use]\n     pub fn expr_fallback(self, expr_fallback: impl FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a) -> Self {\n         Self {\n             expr_fallback: Some(Box::new(expr_fallback)),"}, {"sha": "d384c5a069eb0a8b6fbc879961b603e896a363a6", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 75, "deletions": 18, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -72,10 +72,10 @@ use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visi\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs,\n-    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node,\n-    Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n-    UnOp,\n+    def, Arm, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n+    ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem,\n+    TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1223,6 +1223,70 @@ pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n     }\n }\n \n+/// Removes blocks around an expression, only if the block contains just one expression\n+/// and no statements. Unsafe blocks are not removed.\n+///\n+/// Examples:\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{{ x }}`          -> `x`\n+///  * `{ x; }`           -> `{ x; }`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n+    }\n+    expr\n+}\n+\n+/// Removes blocks around an expression, only if the block contains just one expression\n+/// or just one expression statement with a semicolon. Unsafe blocks are not removed.\n+///\n+/// Examples:\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{ x; }`           -> `x`\n+///  * `{{ x; }}`         -> `x`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks_with_stmt<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        }\n+        | Block {\n+            stmts:\n+                [\n+                    Stmt {\n+                        kind: StmtKind::Expr(inner) | StmtKind::Semi(inner),\n+                        ..\n+                    },\n+                ],\n+            expr: None,\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n+    }\n+    expr\n+}\n+\n /// Checks if the given expression is the else clause of either an `if` or `if let` expression.\n pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let mut iter = tcx.hir().parent_iter(expr.hir_id);\n@@ -1328,6 +1392,13 @@ pub fn return_ty<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId) -> Ty<'tcx>\n     cx.tcx.erase_late_bound_regions(ret_ty)\n }\n \n+/// Convenience function to get the nth argument type of a function.\n+pub fn nth_arg<'tcx>(cx: &LateContext<'tcx>, fn_item: hir::HirId, nth: usize) -> Ty<'tcx> {\n+    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+    let arg = cx.tcx.fn_sig(fn_def_id).input(nth);\n+    cx.tcx.erase_late_bound_regions(arg)\n+}\n+\n /// Checks if an expression is constructing a tuple-like enum variant or struct\n pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(fun, _) = expr.kind {\n@@ -1404,20 +1475,6 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n     has_attr(attrs, sym::automatically_derived)\n }\n \n-/// Remove blocks around an expression.\n-///\n-/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n-/// themselves.\n-pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(block, ..) = expr.kind {\n-        match (block.stmts.is_empty(), block.expr.as_ref()) {\n-            (true, Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n pub fn is_self(slf: &Param<'_>) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower"}, {"sha": "586934df46037a3609de57bdfa0307e0ba619142", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -294,6 +294,7 @@ impl<'a> Sugg<'a> {\n     /// Adds parentheses to any expression that might need them. Suitable to the\n     /// `self` argument of a method call\n     /// (e.g., to build `bar.foo()` or `(1 + 2).foo()`).\n+    #[must_use]\n     pub fn maybe_par(self) -> Self {\n         match self {\n             Sugg::NonParen(..) => self,"}, {"sha": "6d191d4a59bde9948d4fa84e26aacc9ed5d7268c", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -58,14 +58,20 @@ pub fn contains_adt_constructor<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, adt: &'tc\n pub fn get_iterator_item_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     cx.tcx\n         .get_diagnostic_item(sym::Iterator)\n-        .and_then(|iter_did| {\n-            cx.tcx.associated_items(iter_did).find_by_name_and_kind(\n-                cx.tcx,\n-                Ident::from_str(\"Item\"),\n-                ty::AssocKind::Type,\n-                iter_did,\n-            )\n-        })\n+        .and_then(|iter_did| get_associated_type(cx, ty, iter_did, \"Item\"))\n+}\n+\n+/// Returns the associated type `name` for `ty` as an implementation of `trait_id`.\n+/// Do not invoke without first verifying that the type implements the trait.\n+pub fn get_associated_type<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    trait_id: DefId,\n+    name: &str,\n+) -> Option<Ty<'tcx>> {\n+    cx.tcx\n+        .associated_items(trait_id)\n+        .find_by_name_and_kind(cx.tcx, Ident::from_str(name), ty::AssocKind::Type, trait_id)\n         .map(|assoc| {\n             let proj = cx.tcx.mk_projection(assoc.def_id, cx.tcx.mk_substs_trait(ty, &[]));\n             cx.tcx.normalize_erasing_regions(cx.param_env, proj)"}, {"sha": "2066915e1d184a9d6d9d8c96256dddfd057f040c", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n }\n \n pub struct ParamBindingIdCollector {\n-    binding_hir_ids: Vec<hir::HirId>,\n+    pub binding_hir_ids: Vec<hir::HirId>,\n }\n impl<'tcx> ParamBindingIdCollector {\n     fn collect_binding_hir_ids(body: &'tcx hir::Body<'tcx>) -> Vec<hir::HirId> {"}, {"sha": "8f22bd656836c882fddbbdba867b8454f4aa6512", "filename": "lintcheck-logs/lintcheck_crates_logs.txt", "status": "removed", "additions": 0, "deletions": 3862, "changes": 3862, "blob_url": "https://github.com/rust-lang/rust/blob/b2f8a27ff2662b440d0dd65cdb609d303b2fa280/lintcheck-logs%2Flintcheck_crates_logs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b2f8a27ff2662b440d0dd65cdb609d303b2fa280/lintcheck-logs%2Flintcheck_crates_logs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck-logs%2Flintcheck_crates_logs.txt?ref=b2f8a27ff2662b440d0dd65cdb609d303b2fa280"}, {"sha": "53e669254cfeafde12b584fec22c15c4e2cc168b", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 135, "deletions": 39, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -12,7 +12,7 @@ use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::{collections::HashMap, io::ErrorKind};\n use std::{\n-    env, fmt,\n+    env,\n     fs::write,\n     path::{Path, PathBuf},\n     thread,\n@@ -101,13 +101,28 @@ struct ClippyWarning {\n     is_ice: bool,\n }\n \n-impl std::fmt::Display for ClippyWarning {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        writeln!(\n-            f,\n-            r#\"target/lintcheck/sources/{}-{}/{}:{}:{} {} \"{}\"\"#,\n-            &self.crate_name, &self.crate_version, &self.file, &self.line, &self.column, &self.linttype, &self.message\n-        )\n+#[allow(unused)]\n+impl ClippyWarning {\n+    fn to_output(&self, markdown: bool) -> String {\n+        let file = format!(\"{}-{}/{}\", &self.crate_name, &self.crate_version, &self.file);\n+        let file_with_pos = format!(\"{}:{}:{}\", &file, &self.line, &self.column);\n+        if markdown {\n+            let lint = format!(\"`{}`\", self.linttype);\n+\n+            let mut output = String::from(\"| \");\n+            output.push_str(&format!(\n+                \"[`{}`](../target/lintcheck/sources/{}#L{})\",\n+                file_with_pos, file, self.line\n+            ));\n+            output.push_str(&format!(r#\" | {:<50} | \"{}\" |\"#, lint, self.message));\n+            output.push('\\n');\n+            output\n+        } else {\n+            format!(\n+                \"target/lintcheck/sources/{} {} \\\"{}\\\"\\n\",\n+                file_with_pos, self.linttype, self.message\n+            )\n+        }\n     }\n }\n \n@@ -264,6 +279,7 @@ impl Crate {\n         thread_limit: usize,\n         total_crates_to_lint: usize,\n         fix: bool,\n+        lint_filter: &Vec<String>,\n     ) -> Vec<ClippyWarning> {\n         // advance the atomic index by one\n         let index = target_dir_index.fetch_add(1, Ordering::SeqCst);\n@@ -288,9 +304,9 @@ impl Crate {\n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n         let mut args = if fix {\n-            vec![\"--fix\", \"--allow-no-vcs\", \"--\", \"--cap-lints=warn\"]\n+            vec![\"--fix\", \"--allow-no-vcs\", \"--\"]\n         } else {\n-            vec![\"--\", \"--message-format=json\", \"--\", \"--cap-lints=warn\"]\n+            vec![\"--\", \"--message-format=json\", \"--\"]\n         };\n \n         if let Some(options) = &self.options {\n@@ -301,6 +317,13 @@ impl Crate {\n             args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n         }\n \n+        if lint_filter.is_empty() {\n+            args.push(\"--cap-lints=warn\");\n+        } else {\n+            args.push(\"--cap-lints=allow\");\n+            args.extend(lint_filter.iter().map(|filter| filter.as_str()))\n+        }\n+\n         let all_output = std::process::Command::new(&cargo_clippy_path)\n             // use the looping index to create individual target dirs\n             .env(\n@@ -360,14 +383,18 @@ impl Crate {\n \n #[derive(Debug)]\n struct LintcheckConfig {\n-    // max number of jobs to spawn (default 1)\n+    /// max number of jobs to spawn (default 1)\n     max_jobs: usize,\n-    // we read the sources to check from here\n+    /// we read the sources to check from here\n     sources_toml_path: PathBuf,\n-    // we save the clippy lint results here\n+    /// we save the clippy lint results here\n     lintcheck_results_path: PathBuf,\n-    // whether to just run --fix and not collect all the warnings\n+    /// whether to just run --fix and not collect all the warnings\n     fix: bool,\n+    /// A list of lint that this lintcheck run shound focus on\n+    lint_filter: Vec<String>,\n+    /// Indicate if the output should support markdown syntax\n+    markdown: bool,\n }\n \n impl LintcheckConfig {\n@@ -383,12 +410,17 @@ impl LintcheckConfig {\n                 .to_string()\n         });\n \n+        let markdown = clap_config.is_present(\"markdown\");\n         let sources_toml_path = PathBuf::from(sources_toml);\n \n         // for the path where we save the lint results, get the filename without extension (so for\n         // wasd.toml, use \"wasd\"...)\n         let filename: PathBuf = sources_toml_path.file_stem().unwrap().into();\n-        let lintcheck_results_path = PathBuf::from(format!(\"lintcheck-logs/{}_logs.txt\", filename.display()));\n+        let lintcheck_results_path = PathBuf::from(format!(\n+            \"lintcheck-logs/{}_logs.{}\",\n+            filename.display(),\n+            if markdown { \"md\" } else { \"txt\" }\n+        ));\n \n         // look at the --threads arg, if 0 is passed, ask rayon rayon how many threads it would spawn and\n         // use half of that for the physical core count\n@@ -410,12 +442,27 @@ impl LintcheckConfig {\n             None => 1,\n         };\n         let fix: bool = clap_config.is_present(\"fix\");\n+        let lint_filter: Vec<String> = clap_config\n+            .values_of(\"filter\")\n+            .map(|iter| {\n+                iter.map(|lint_name| {\n+                    let mut filter = lint_name.replace('_', \"-\");\n+                    if !filter.starts_with(\"clippy::\") {\n+                        filter.insert_str(0, \"clippy::\");\n+                    }\n+                    filter\n+                })\n+                .collect()\n+            })\n+            .unwrap_or_default();\n \n         LintcheckConfig {\n             max_jobs,\n             sources_toml_path,\n             lintcheck_results_path,\n             fix,\n+            lint_filter,\n+            markdown,\n         }\n     }\n }\n@@ -577,10 +624,15 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String,\n     // to not have a lint with 200 and 2 warnings take the same spot\n     stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n \n+    let mut header = String::from(\"| lint                                               | count |\\n\");\n+    header.push_str(\"| -------------------------------------------------- | ----- |\\n\");\n     let stats_string = stats\n         .iter()\n-        .map(|(lint, count)| format!(\"{} {}\\n\", lint, count))\n-        .collect::<String>();\n+        .map(|(lint, count)| format!(\"| {:<50} |  {:>4} |\\n\", lint, count))\n+        .fold(header, |mut table, line| {\n+            table.push_str(&line);\n+            table\n+        });\n \n     (stats_string, counter)\n }\n@@ -682,6 +734,15 @@ pub fn main() {\n     let old_stats = read_stats_from_file(&config.lintcheck_results_path);\n \n     let counter = AtomicUsize::new(1);\n+    let lint_filter: Vec<String> = config\n+        .lint_filter\n+        .iter()\n+        .map(|filter| {\n+            let mut filter = filter.clone();\n+            filter.insert_str(0, \"--force-warn=\");\n+            filter\n+        })\n+        .collect();\n \n     let clippy_warnings: Vec<ClippyWarning> = if let Some(only_one_crate) = clap_config.value_of(\"only\") {\n         // if we don't have the specified crate in the .toml, throw an error\n@@ -705,7 +766,9 @@ pub fn main() {\n             .into_iter()\n             .map(|krate| krate.download_and_extract())\n             .filter(|krate| krate.name == only_one_crate)\n-            .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1, config.fix))\n+            .flat_map(|krate| {\n+                krate.run_clippy_lints(&cargo_clippy_path, &AtomicUsize::new(0), 1, 1, config.fix, &lint_filter)\n+            })\n             .collect()\n     } else {\n         if config.max_jobs > 1 {\n@@ -729,7 +792,14 @@ pub fn main() {\n                 .into_par_iter()\n                 .map(|krate| krate.download_and_extract())\n                 .flat_map(|krate| {\n-                    krate.run_clippy_lints(&cargo_clippy_path, &counter, num_cpus, num_crates, config.fix)\n+                    krate.run_clippy_lints(\n+                        &cargo_clippy_path,\n+                        &counter,\n+                        num_cpus,\n+                        num_crates,\n+                        config.fix,\n+                        &lint_filter,\n+                    )\n                 })\n                 .collect()\n         } else {\n@@ -738,7 +808,9 @@ pub fn main() {\n             crates\n                 .into_iter()\n                 .map(|krate| krate.download_and_extract())\n-                .flat_map(|krate| krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates, config.fix))\n+                .flat_map(|krate| {\n+                    krate.run_clippy_lints(&cargo_clippy_path, &counter, 1, num_crates, config.fix, &lint_filter)\n+                })\n                 .collect()\n         }\n     };\n@@ -758,22 +830,31 @@ pub fn main() {\n         .map(|w| (&w.crate_name, &w.message))\n         .collect();\n \n-    let mut all_msgs: Vec<String> = clippy_warnings.iter().map(ToString::to_string).collect();\n+    let mut all_msgs: Vec<String> = clippy_warnings\n+        .iter()\n+        .map(|warn| warn.to_output(config.markdown))\n+        .collect();\n     all_msgs.sort();\n-    all_msgs.push(\"\\n\\n\\n\\nStats:\\n\".into());\n+    all_msgs.push(\"\\n\\n### Stats:\\n\\n\".into());\n     all_msgs.push(stats_formatted);\n \n     // save the text into lintcheck-logs/logs.txt\n     let mut text = clippy_ver; // clippy version number on top\n-    text.push_str(&format!(\"\\n{}\", all_msgs.join(\"\")));\n-    text.push_str(\"ICEs:\\n\");\n+    text.push_str(\"\\n### Reports\\n\\n\");\n+    if config.markdown {\n+        text.push_str(\"| file | lint | message |\\n\");\n+        text.push_str(\"| --- | --- | --- |\\n\");\n+    }\n+    text.push_str(&format!(\"{}\", all_msgs.join(\"\")));\n+    text.push_str(\"\\n\\n### ICEs:\\n\");\n     ices.iter()\n         .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n \n     println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n+    std::fs::create_dir_all(config.lintcheck_results_path.parent().unwrap()).unwrap();\n     write(&config.lintcheck_results_path, text).unwrap();\n \n-    print_stats(old_stats, new_stats);\n+    print_stats(old_stats, new_stats, &config.lint_filter);\n }\n \n /// read the previous stats from the lintcheck-log file\n@@ -787,26 +868,27 @@ fn read_stats_from_file(file_path: &Path) -> HashMap<String, usize> {\n \n     let lines: Vec<String> = file_content.lines().map(ToString::to_string).collect();\n \n-    // search for the beginning \"Stats:\" and the end \"ICEs:\" of the section we want\n-    let start = lines.iter().position(|line| line == \"Stats:\").unwrap();\n-    let end = lines.iter().position(|line| line == \"ICEs:\").unwrap();\n-\n-    let stats_lines = &lines[start + 1..end];\n-\n-    stats_lines\n+    lines\n         .iter()\n-        .map(|line| {\n-            let mut spl = line.split(' ');\n-            (\n-                spl.next().unwrap().to_string(),\n-                spl.next().unwrap().parse::<usize>().unwrap(),\n-            )\n+        .skip_while(|line| line.as_str() != \"### Stats:\")\n+        // Skipping the table header and the `Stats:` label\n+        .skip(4)\n+        .take_while(|line| line.starts_with(\"| \"))\n+        .filter_map(|line| {\n+            let mut spl = line.split('|');\n+            // Skip the first `|` symbol\n+            spl.next();\n+            if let (Some(lint), Some(count)) = (spl.next(), spl.next()) {\n+                Some((lint.trim().to_string(), count.trim().parse::<usize>().unwrap()))\n+            } else {\n+                None\n+            }\n         })\n         .collect::<HashMap<String, usize>>()\n }\n \n /// print how lint counts changed between runs\n-fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>) {\n+fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>, lint_filter: &Vec<String>) {\n     let same_in_both_hashmaps = old_stats\n         .iter()\n         .filter(|(old_key, old_val)| new_stats.get::<&String>(&old_key) == Some(old_val))\n@@ -845,6 +927,7 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n     old_stats_deduped\n         .iter()\n         .filter(|(old_key, _)| new_stats_deduped.get::<&String>(&old_key).is_none())\n+        .filter(|(old_key, _)| lint_filter.is_empty() || lint_filter.contains(old_key))\n         .for_each(|(old_key, old_value)| {\n             println!(\"{} {} => 0\", old_key, old_value);\n         });\n@@ -903,6 +986,19 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 .long(\"--fix\")\n                 .help(\"runs cargo clippy --fix and checks if all suggestions apply\"),\n         )\n+        .arg(\n+            Arg::with_name(\"filter\")\n+                .long(\"--filter\")\n+                .takes_value(true)\n+                .multiple(true)\n+                .value_name(\"clippy_lint_name\")\n+                .help(\"apply a filter to only collect specified lints, this also overrides `allow` attributes\"),\n+        )\n+        .arg(\n+            Arg::with_name(\"markdown\")\n+                .long(\"--markdown\")\n+                .help(\"change the reports table to use markdown links\"),\n+        )\n         .get_matches()\n }\n "}, {"sha": "49eecf18b4c4f83f5fadacb8f6ad593bc2969cac", "filename": "tests/ui-toml/strict_non_send_fields_in_send_ty/test.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui-toml%2Fstrict_non_send_fields_in_send_ty%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui-toml%2Fstrict_non_send_fields_in_send_ty%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fstrict_non_send_fields_in_send_ty%2Ftest.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,86 +1,86 @@\n-error: this implementation is unsound, as some fields in `NoGeneric` are `!Send`\n+error: some fields in `NoGeneric` are not safe to be sent to another thread\n   --> $DIR/test.rs:11:1\n    |\n LL | unsafe impl Send for NoGeneric {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::non-send-fields-in-send-ty` implied by `-D warnings`\n-note: the type of field `rc_is_not_send` is `!Send`\n+note: it is not safe to send field `rc_is_not_send` to another thread\n   --> $DIR/test.rs:8:5\n    |\n LL |     rc_is_not_send: Rc<String>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n \n-error: this implementation is unsound, as some fields in `MultiField<T>` are `!Send`\n+error: some fields in `MultiField<T>` are not safe to be sent to another thread\n   --> $DIR/test.rs:19:1\n    |\n LL | unsafe impl<T> Send for MultiField<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field1` is `!Send`\n+note: it is not safe to send field `field1` to another thread\n   --> $DIR/test.rs:14:5\n    |\n LL |     field1: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n-note: the type of field `field2` is `!Send`\n+note: it is not safe to send field `field2` to another thread\n   --> $DIR/test.rs:15:5\n    |\n LL |     field2: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n-note: the type of field `field3` is `!Send`\n+note: it is not safe to send field `field3` to another thread\n   --> $DIR/test.rs:16:5\n    |\n LL |     field3: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `MyOption<T>` are `!Send`\n+error: some fields in `MyOption<T>` are not safe to be sent to another thread\n   --> $DIR/test.rs:26:1\n    |\n LL | unsafe impl<T> Send for MyOption<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `0` is `!Send`\n+note: it is not safe to send field `0` to another thread\n   --> $DIR/test.rs:22:12\n    |\n LL |     MySome(T),\n    |            ^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `HeuristicTest` are `!Send`\n+error: some fields in `HeuristicTest` are not safe to be sent to another thread\n   --> $DIR/test.rs:41:1\n    |\n LL | unsafe impl Send for HeuristicTest {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field1` is `!Send`\n+note: it is not safe to send field `field1` to another thread\n   --> $DIR/test.rs:34:5\n    |\n LL |     field1: Vec<*const NonSend>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n-note: the type of field `field2` is `!Send`\n+note: it is not safe to send field `field2` to another thread\n   --> $DIR/test.rs:35:5\n    |\n LL |     field2: [*const NonSend; 3],\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n-note: the type of field `field3` is `!Send`\n+note: it is not safe to send field `field3` to another thread\n   --> $DIR/test.rs:36:5\n    |\n LL |     field3: (*const NonSend, *const NonSend, *const NonSend),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n-note: the type of field `field4` is `!Send`\n+note: it is not safe to send field `field4` to another thread\n   --> $DIR/test.rs:37:5\n    |\n LL |     field4: (*const NonSend, Rc<u8>),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n-note: the type of field `field5` is `!Send`\n+note: it is not safe to send field `field5` to another thread\n   --> $DIR/test.rs:38:5\n    |\n LL |     field5: Vec<Vec<*const NonSend>>,"}, {"sha": "f9bc9436b079293e5cf79cbbca4a602853074d2b", "filename": "tests/ui/auxiliary/option_helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fauxiliary%2Foption_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Foption_helpers.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code, unused_variables)]\n+#![allow(dead_code, unused_variables, clippy::return_self_not_must_use)]\n \n /// Utility macro to test linting behavior in `option_methods()`\n /// The lints included in `option_methods()` should not lint if the call to map is partially"}, {"sha": "169589f6d4e7006044976d31c1d32085071ad9d1", "filename": "tests/ui/blocks_in_if_conditions_closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fblocks_in_if_conditions_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fblocks_in_if_conditions_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fblocks_in_if_conditions_closure.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -44,6 +44,14 @@ fn macro_in_closure() {\n     }\n }\n \n+fn closure(_: impl FnMut()) -> bool {\n+    true\n+}\n+\n+fn function_with_empty_closure() {\n+    if closure(|| {}) {}\n+}\n+\n #[rustfmt::skip]\n fn main() {\n     let mut range = 0..10;"}, {"sha": "0029fc673f1107105b110987b20bd6ff236dfab9", "filename": "tests/ui/deref_addrof.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::return_self_not_must_use)]\n #![warn(clippy::deref_addrof)]\n \n fn get_number() -> usize {"}, {"sha": "f2f02dd5e723d8a78c1918c4f8e597df4239c0aa", "filename": "tests/ui/deref_addrof.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,4 +1,5 @@\n // run-rustfix\n+#![allow(clippy::return_self_not_must_use)]\n #![warn(clippy::deref_addrof)]\n \n fn get_number() -> usize {"}, {"sha": "5bc1cbfa215100e5bdf0c41648e40dc85722927e", "filename": "tests/ui/deref_addrof.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fderef_addrof.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_addrof.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,55 +1,55 @@\n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:18:13\n+  --> $DIR/deref_addrof.rs:19:13\n    |\n LL |     let b = *&a;\n    |             ^^^ help: try this: `a`\n    |\n    = note: `-D clippy::deref-addrof` implied by `-D warnings`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:20:13\n+  --> $DIR/deref_addrof.rs:21:13\n    |\n LL |     let b = *&get_number();\n    |             ^^^^^^^^^^^^^^ help: try this: `get_number()`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:25:13\n+  --> $DIR/deref_addrof.rs:26:13\n    |\n LL |     let b = *&bytes[1..2][0];\n    |             ^^^^^^^^^^^^^^^^ help: try this: `bytes[1..2][0]`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:29:13\n+  --> $DIR/deref_addrof.rs:30:13\n    |\n LL |     let b = *&(a);\n    |             ^^^^^ help: try this: `(a)`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:31:13\n+  --> $DIR/deref_addrof.rs:32:13\n    |\n LL |     let b = *(&a);\n    |             ^^^^^ help: try this: `a`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:34:13\n+  --> $DIR/deref_addrof.rs:35:13\n    |\n LL |     let b = *((&a));\n    |             ^^^^^^^ help: try this: `a`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:36:13\n+  --> $DIR/deref_addrof.rs:37:13\n    |\n LL |     let b = *&&a;\n    |             ^^^^ help: try this: `&a`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:38:14\n+  --> $DIR/deref_addrof.rs:39:14\n    |\n LL |     let b = **&aref;\n    |              ^^^^^^ help: try this: `aref`\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:44:9\n+  --> $DIR/deref_addrof.rs:45:9\n    |\n LL |         *& $visitor\n    |         ^^^^^^^^^^^ help: try this: `$visitor`\n@@ -60,7 +60,7 @@ LL |         m!(self)\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: immediately dereferencing a reference\n-  --> $DIR/deref_addrof.rs:51:9\n+  --> $DIR/deref_addrof.rs:52:9\n    |\n LL |         *& mut $visitor\n    |         ^^^^^^^^^^^^^^^ help: try this: `$visitor`"}, {"sha": "85da1f4e10437cb6a3669e47b3dc3a35f5494913", "filename": "tests/ui/needless_bool/fixable.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -53,6 +53,7 @@ fn main() {\n     needless_bool(x);\n     needless_bool2(x);\n     needless_bool3(x);\n+    needless_bool_condition();\n }\n \n fn bool_ret3(x: bool) -> bool {\n@@ -98,3 +99,19 @@ fn needless_bool_in_the_suggestion_wraps_the_predicate_of_if_else_statement_in_b\n         true\n     } else { !returns_bool() };\n }\n+\n+unsafe fn no(v: u8) -> u8 {\n+    v\n+}\n+\n+#[allow(clippy::unnecessary_operation)]\n+fn needless_bool_condition() -> bool {\n+    (unsafe { no(4) } & 1 != 0);\n+    let _brackets_unneeded = unsafe { no(4) } & 1 != 0;\n+    fn foo() -> bool {\n+        // parentheses are needed here\n+        (unsafe { no(4) } & 1 != 0)\n+    }\n+\n+    foo()\n+}"}, {"sha": "add606302511b89dea3099e5fd13848ab0835f70", "filename": "tests/ui/needless_bool/fixable.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -65,6 +65,7 @@ fn main() {\n     needless_bool(x);\n     needless_bool2(x);\n     needless_bool3(x);\n+    needless_bool_condition();\n }\n \n fn bool_ret3(x: bool) -> bool {\n@@ -130,3 +131,23 @@ fn needless_bool_in_the_suggestion_wraps_the_predicate_of_if_else_statement_in_b\n         true\n     };\n }\n+\n+unsafe fn no(v: u8) -> u8 {\n+    v\n+}\n+\n+#[allow(clippy::unnecessary_operation)]\n+fn needless_bool_condition() -> bool {\n+    if unsafe { no(4) } & 1 != 0 {\n+        true\n+    } else {\n+        false\n+    };\n+    let _brackets_unneeded = if unsafe { no(4) } & 1 != 0 { true } else { false };\n+    fn foo() -> bool {\n+        // parentheses are needed here\n+        if unsafe { no(4) } & 1 != 0 { true } else { false }\n+    }\n+\n+    foo()\n+}"}, {"sha": "22c0a7bb491c6d495d47a9b418348ff85a79c185", "filename": "tests/ui/needless_bool/fixable.stderr", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_bool%2Ffixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_bool%2Ffixable.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -31,7 +31,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `!(x && y)`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:71:5\n+  --> $DIR/fixable.rs:72:5\n    |\n LL | /     if x {\n LL | |         return true;\n@@ -41,7 +41,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:79:5\n+  --> $DIR/fixable.rs:80:5\n    |\n LL | /     if x {\n LL | |         return false;\n@@ -51,7 +51,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:87:5\n+  --> $DIR/fixable.rs:88:5\n    |\n LL | /     if x && y {\n LL | |         return true;\n@@ -61,7 +61,7 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return x && y`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:95:5\n+  --> $DIR/fixable.rs:96:5\n    |\n LL | /     if x && y {\n LL | |         return false;\n@@ -71,33 +71,33 @@ LL | |     };\n    | |_____^ help: you can reduce it to: `return !(x && y)`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:103:8\n+  --> $DIR/fixable.rs:104:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n    |\n    = note: `-D clippy::bool-comparison` implied by `-D warnings`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:107:8\n+  --> $DIR/fixable.rs:108:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: equality checks against true are unnecessary\n-  --> $DIR/fixable.rs:117:8\n+  --> $DIR/fixable.rs:118:8\n    |\n LL |     if x == true {};\n    |        ^^^^^^^^^ help: try simplifying it as shown: `x`\n \n error: equality checks against false can be replaced by a negation\n-  --> $DIR/fixable.rs:118:8\n+  --> $DIR/fixable.rs:119:8\n    |\n LL |     if x == false {};\n    |        ^^^^^^^^^^ help: try simplifying it as shown: `!x`\n \n error: this if-then-else expression returns a bool literal\n-  --> $DIR/fixable.rs:127:12\n+  --> $DIR/fixable.rs:128:12\n    |\n LL |       } else if returns_bool() {\n    |  ____________^\n@@ -107,5 +107,27 @@ LL | |         true\n LL | |     };\n    | |_____^ help: you can reduce it to: `{ !returns_bool() }`\n \n-error: aborting due to 12 previous errors\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:141:5\n+   |\n+LL | /     if unsafe { no(4) } & 1 != 0 {\n+LL | |         true\n+LL | |     } else {\n+LL | |         false\n+LL | |     };\n+   | |_____^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:146:30\n+   |\n+LL |     let _brackets_unneeded = if unsafe { no(4) } & 1 != 0 { true } else { false };\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `unsafe { no(4) } & 1 != 0`\n+\n+error: this if-then-else expression returns a bool literal\n+  --> $DIR/fixable.rs:149:9\n+   |\n+LL |         if unsafe { no(4) } & 1 != 0 { true } else { false }\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: you can reduce it to: `(unsafe { no(4) } & 1 != 0)`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "89e012c066fe4d9593460873e0049ada3c8a8993", "filename": "tests/ui/needless_late_init.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -39,6 +39,19 @@ fn main() {\n         e = format!(\"{}\", c);\n     }\n \n+    let f;\n+    match 1 {\n+        1 => f = \"three\",\n+        _ => return,\n+    }; // has semi\n+\n+    let g: usize;\n+    if true {\n+        g = 5;\n+    } else {\n+        panic!();\n+    }\n+\n     println!(\"{}\", a);\n }\n "}, {"sha": "ef79e635d2ae623da06255747c8dc3fd66f059e4", "filename": "tests/ui/needless_late_init.stderr", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -105,7 +105,43 @@ LL |     };\n    |      +\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:50:5\n+  --> $DIR/needless_late_init.rs:42:5\n+   |\n+LL |     let f;\n+   |     ^^^^^^\n+   |\n+help: declare `f` here\n+   |\n+LL |     let f = match 1 {\n+   |     +++++++\n+help: remove the assignments from the `match` arms\n+   |\n+LL -         1 => f = \"three\",\n+LL +         1 => \"three\",\n+   | \n+\n+error: unneeded late initalization\n+  --> $DIR/needless_late_init.rs:48:5\n+   |\n+LL |     let g: usize;\n+   |     ^^^^^^^^^^^^^\n+   |\n+help: declare `g` here\n+   |\n+LL |     let g: usize = if true {\n+   |     ++++++++++++++\n+help: remove the assignments from the branches\n+   |\n+LL -         g = 5;\n+LL +         5\n+   | \n+help: add a semicolon after the `if` expression\n+   |\n+LL |     };\n+   |      +\n+\n+error: unneeded late initalization\n+  --> $DIR/needless_late_init.rs:63:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -126,7 +162,7 @@ LL |     };\n    |      +\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:67:5\n+  --> $DIR/needless_late_init.rs:80:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -146,5 +182,5 @@ help: add a semicolon after the `match` expression\n LL |     };\n    |      +\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "b516f9d86b75b652b0e4f788c85cc16853d573a4", "filename": "tests/ui/needless_late_init_fixable.fixed", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+\n+#![allow(unused, clippy::assign_op_pattern)]\n+\n+fn main() {\n+    \n+    let a = \"zero\";\n+\n+    \n+    \n+    let b = 1;\n+    let c = 2;\n+\n+    \n+    let d: usize = 1;\n+\n+    \n+    let mut e = 1;\n+    e = 2;\n+\n+    \n+    let h = format!(\"{}\", e);\n+\n+    println!(\"{}\", a);\n+}"}, {"sha": "75a4bc916deacb5cbd52e2f10c9f1fa5643abf5d", "filename": "tests/ui/needless_late_init_fixable.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![allow(unused, clippy::assign_op_pattern)]\n \n fn main() {\n@@ -16,19 +18,6 @@ fn main() {\n     e = 1;\n     e = 2;\n \n-    let f;\n-    match 1 {\n-        1 => f = \"three\",\n-        _ => return,\n-    }; // has semi\n-\n-    let g: usize;\n-    if true {\n-        g = 5;\n-    } else {\n-        panic!();\n-    }\n-\n     let h;\n     h = format!(\"{}\", e);\n "}, {"sha": "3f3d4f5286b2b2e088a737288c3759955bbcd1af", "filename": "tests/ui/needless_late_init_fixable.stderr", "status": "modified", "additions": 7, "deletions": 43, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fneedless_late_init_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,5 @@\n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:4:5\n+  --> $DIR/needless_late_init_fixable.rs:6:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -11,7 +11,7 @@ LL |     let a = \"zero\";\n    |     ~~~~~\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:7:5\n+  --> $DIR/needless_late_init_fixable.rs:9:5\n    |\n LL |     let b;\n    |     ^^^^^^\n@@ -22,7 +22,7 @@ LL |     let b = 1;\n    |     ~~~~~\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:8:5\n+  --> $DIR/needless_late_init_fixable.rs:10:5\n    |\n LL |     let c;\n    |     ^^^^^^\n@@ -33,7 +33,7 @@ LL |     let c = 2;\n    |     ~~~~~\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:12:5\n+  --> $DIR/needless_late_init_fixable.rs:14:5\n    |\n LL |     let d: usize;\n    |     ^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |     let d: usize = 1;\n    |     ~~~~~~~~~~~~\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:15:5\n+  --> $DIR/needless_late_init_fixable.rs:17:5\n    |\n LL |     let mut e;\n    |     ^^^^^^^^^^\n@@ -55,43 +55,7 @@ LL |     let mut e = 1;\n    |     ~~~~~~~~~\n \n error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:19:5\n-   |\n-LL |     let f;\n-   |     ^^^^^^\n-   |\n-help: declare `f` here\n-   |\n-LL |     let f = match 1 {\n-   |     +++++++\n-help: remove the assignments from the `match` arms\n-   |\n-LL -         1 => f = \"three\",\n-LL +         1 => \"three\",\n-   | \n-\n-error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:25:5\n-   |\n-LL |     let g: usize;\n-   |     ^^^^^^^^^^^^^\n-   |\n-help: declare `g` here\n-   |\n-LL |     let g: usize = if true {\n-   |     ++++++++++++++\n-help: remove the assignments from the branches\n-   |\n-LL -         g = 5;\n-LL +         5\n-   | \n-help: add a semicolon after the `if` expression\n-   |\n-LL |     };\n-   |      +\n-\n-error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:32:5\n+  --> $DIR/needless_late_init_fixable.rs:21:5\n    |\n LL |     let h;\n    |     ^^^^^^\n@@ -101,5 +65,5 @@ help: declare `h` here\n LL |     let h = format!(\"{}\", e);\n    |     ~~~~~\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "60df4e226e4fa47078c43dc3bb66e1ff30e3e6e3", "filename": "tests/ui/non_send_fields_in_send_ty.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fnon_send_fields_in_send_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fnon_send_fields_in_send_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_send_fields_in_send_ty.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,166 +1,166 @@\n-error: this implementation is unsound, as some fields in `RingBuffer<T>` are `!Send`\n+error: some fields in `RingBuffer<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:16:1\n    |\n LL | unsafe impl<T> Send for RingBuffer<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::non-send-fields-in-send-ty` implied by `-D warnings`\n-note: the type of field `data` is `!Send`\n+note: it is not safe to send field `data` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:11:5\n    |\n LL |     data: Vec<UnsafeCell<T>>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameter `T` that satisfy `Vec<UnsafeCell<T>>: Send`\n \n-error: this implementation is unsound, as some fields in `MvccRwLock<T>` are `!Send`\n+error: some fields in `MvccRwLock<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:24:1\n    |\n LL | unsafe impl<T> Send for MvccRwLock<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `lock` is `!Send`\n+note: it is not safe to send field `lock` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:21:5\n    |\n LL |     lock: Mutex<Box<T>>,\n    |     ^^^^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameter `T` that satisfy `Mutex<Box<T>>: Send`\n \n-error: this implementation is unsound, as some fields in `ArcGuard<RC, T>` are `!Send`\n+error: some fields in `ArcGuard<RC, T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:32:1\n    |\n LL | unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `head` is `!Send`\n+note: it is not safe to send field `head` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:29:5\n    |\n LL |     head: Arc<RC>,\n    |     ^^^^^^^^^^^^^\n    = help: add bounds on type parameter `RC` that satisfy `Arc<RC>: Send`\n \n-error: this implementation is unsound, as some fields in `DeviceHandle<T>` are `!Send`\n+error: some fields in `DeviceHandle<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:48:1\n    |\n LL | unsafe impl<T: UsbContext> Send for DeviceHandle<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `context` is `!Send`\n+note: it is not safe to send field `context` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:44:5\n    |\n LL |     context: T,\n    |     ^^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `NoGeneric` are `!Send`\n+error: some fields in `NoGeneric` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:55:1\n    |\n LL | unsafe impl Send for NoGeneric {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `rc_is_not_send` is `!Send`\n+note: it is not safe to send field `rc_is_not_send` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:52:5\n    |\n LL |     rc_is_not_send: Rc<String>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n \n-error: this implementation is unsound, as some fields in `MultiField<T>` are `!Send`\n+error: some fields in `MultiField<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:63:1\n    |\n LL | unsafe impl<T> Send for MultiField<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field1` is `!Send`\n+note: it is not safe to send field `field1` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:58:5\n    |\n LL |     field1: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n-note: the type of field `field2` is `!Send`\n+note: it is not safe to send field `field2` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:59:5\n    |\n LL |     field2: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n-note: the type of field `field3` is `!Send`\n+note: it is not safe to send field `field3` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:60:5\n    |\n LL |     field3: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `MyOption<T>` are `!Send`\n+error: some fields in `MyOption<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:70:1\n    |\n LL | unsafe impl<T> Send for MyOption<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `0` is `!Send`\n+note: it is not safe to send field `0` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:66:12\n    |\n LL |     MySome(T),\n    |            ^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `MultiParam<A, B>` are `!Send`\n+error: some fields in `MultiParam<A, B>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:82:1\n    |\n LL | unsafe impl<A, B> Send for MultiParam<A, B> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `vec` is `!Send`\n+note: it is not safe to send field `vec` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:79:5\n    |\n LL |     vec: Vec<(A, B)>,\n    |     ^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameters `A, B` that satisfy `Vec<(A, B)>: Send`\n \n-error: this implementation is unsound, as some fields in `HeuristicTest` are `!Send`\n+error: some fields in `HeuristicTest` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:100:1\n    |\n LL | unsafe impl Send for HeuristicTest {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field4` is `!Send`\n+note: it is not safe to send field `field4` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:95:5\n    |\n LL |     field4: (*const NonSend, Rc<u8>),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n \n-error: this implementation is unsound, as some fields in `AttrTest3<T>` are `!Send`\n+error: some fields in `AttrTest3<T>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:119:1\n    |\n LL | unsafe impl<T> Send for AttrTest3<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `0` is `!Send`\n+note: it is not safe to send field `0` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:114:11\n    |\n LL |     Enum2(T),\n    |           ^\n    = help: add `T: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `Complex<P, u32>` are `!Send`\n+error: some fields in `Complex<P, u32>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:127:1\n    |\n LL | unsafe impl<P> Send for Complex<P, u32> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field1` is `!Send`\n+note: it is not safe to send field `field1` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:123:5\n    |\n LL |     field1: A,\n    |     ^^^^^^^^^\n    = help: add `P: Send` bound in `Send` impl\n \n-error: this implementation is unsound, as some fields in `Complex<Q, MutexGuard<'static, bool>>` are `!Send`\n+error: some fields in `Complex<Q, MutexGuard<'static, bool>>` are not safe to be sent to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:130:1\n    |\n LL | unsafe impl<Q: Send> Send for Complex<Q, MutexGuard<'static, bool>> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: the type of field `field2` is `!Send`\n+note: it is not safe to send field `field2` to another thread\n   --> $DIR/non_send_fields_in_send_ty.rs:124:5\n    |\n LL |     field2: B,"}, {"sha": "7790c816481d1b78bbc2320c3b1cf57d36a3242b", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -86,6 +86,19 @@ fn pattern_to_vec(pattern: &str) -> Vec<String> {\n         .collect::<Vec<_>>()\n }\n \n+enum DummyEnum {\n+    One(u8),\n+    Two,\n+}\n+\n+// should not warn since there is a compled complex subpat\n+// see #7991\n+fn complex_subpat() -> DummyEnum {\n+    let x = Some(DummyEnum::One(1));\n+    let _ = if let Some(_one @ DummyEnum::One(..)) = x { 1 } else { 2 };\n+    DummyEnum::Two\n+}\n+\n fn main() {\n     let optional = Some(5);\n     let _ = optional.map_or(5, |x| x + 2);\n@@ -159,4 +172,5 @@ fn main() {\n     }\n \n     let _ = pattern_to_vec(\"hello world\");\n+    let _ = complex_subpat();\n }"}, {"sha": "3d9f76ee4a6b570430f18538518b18cc33a47973", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -109,6 +109,19 @@ fn pattern_to_vec(pattern: &str) -> Vec<String> {\n         .collect::<Vec<_>>()\n }\n \n+enum DummyEnum {\n+    One(u8),\n+    Two,\n+}\n+\n+// should not warn since there is a compled complex subpat\n+// see #7991\n+fn complex_subpat() -> DummyEnum {\n+    let x = Some(DummyEnum::One(1));\n+    let _ = if let Some(_one @ DummyEnum::One(..)) = x { 1 } else { 2 };\n+    DummyEnum::Two\n+}\n+\n fn main() {\n     let optional = Some(5);\n     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n@@ -188,4 +201,5 @@ fn main() {\n     }\n \n     let _ = pattern_to_vec(\"hello world\");\n+    let _ = complex_subpat();\n }"}, {"sha": "546131ceb5b633688ae9113df9a96f41e373fcd1", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -153,13 +153,13 @@ LL | |             }\n    | |_____________^ help: try: `s.find('.').map_or_else(|| vec![s.to_string()], |idx| vec![s[..idx].to_string(), s[idx..].to_string()])`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:114:13\n+  --> $DIR/option_if_let_else.rs:127:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:123:13\n+  --> $DIR/option_if_let_else.rs:136:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^\n@@ -181,13 +181,13 @@ LL ~         });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:151:13\n+  --> $DIR/option_if_let_else.rs:164:13\n    |\n LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or(s.len(), |x| s.len() + x)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:155:13\n+  --> $DIR/option_if_let_else.rs:168:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^"}, {"sha": "13ce0f32d4bb14b7e6f2777be15ee32fc6e7e52b", "filename": "tests/ui/question_mark.fixed", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fquestion_mark.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fquestion_mark.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -136,6 +136,24 @@ fn result_func(x: Result<i32, i32>) -> Result<i32, i32> {\n     Ok(y)\n }\n \n+// see issue #8019\n+pub enum NotOption {\n+    None,\n+    First,\n+    AfterFirst,\n+}\n+\n+fn obj(_: i32) -> Result<(), NotOption> {\n+    Err(NotOption::First)\n+}\n+\n+fn f() -> NotOption {\n+    if obj(2).is_err() {\n+        return NotOption::None;\n+    }\n+    NotOption::First\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -157,4 +175,5 @@ fn main() {\n     func();\n \n     let _ = result_func(Ok(42));\n+    let _ = f();\n }"}, {"sha": "60590fd931188042efee4d99058ea3dac6ecd219", "filename": "tests/ui/question_mark.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fquestion_mark.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -168,6 +168,24 @@ fn result_func(x: Result<i32, i32>) -> Result<i32, i32> {\n     Ok(y)\n }\n \n+// see issue #8019\n+pub enum NotOption {\n+    None,\n+    First,\n+    AfterFirst,\n+}\n+\n+fn obj(_: i32) -> Result<(), NotOption> {\n+    Err(NotOption::First)\n+}\n+\n+fn f() -> NotOption {\n+    if obj(2).is_err() {\n+        return NotOption::None;\n+    }\n+    NotOption::First\n+}\n+\n fn main() {\n     some_func(Some(42));\n     some_func(None);\n@@ -189,4 +207,5 @@ fn main() {\n     func();\n \n     let _ = result_func(Ok(42));\n+    let _ = f();\n }"}, {"sha": "bdf3f3d799582085b2b39a341445074f18e603b2", "filename": "tests/ui/return_self_not_must_use.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freturn_self_not_must_use.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,42 @@\n+#![crate_type = \"lib\"]\n+\n+#[derive(Clone)]\n+pub struct Bar;\n+\n+pub trait Whatever {\n+    fn what(&self) -> Self;\n+    // There should be no warning here!\n+    fn what2(&self) -> &Self;\n+}\n+\n+impl Bar {\n+    // There should be no warning here!\n+    pub fn not_new() -> Self {\n+        Self\n+    }\n+    pub fn foo(&self) -> Self {\n+        Self\n+    }\n+    pub fn bar(self) -> Self {\n+        self\n+    }\n+    // There should be no warning here!\n+    fn foo2(&self) -> Self {\n+        Self\n+    }\n+    // There should be no warning here!\n+    pub fn foo3(&self) -> &Self {\n+        self\n+    }\n+}\n+\n+impl Whatever for Bar {\n+    // There should be no warning here!\n+    fn what(&self) -> Self {\n+        self.foo2()\n+    }\n+    // There should be no warning here!\n+    fn what2(&self) -> &Self {\n+        self\n+    }\n+}"}, {"sha": "3793a5559ba55394fcc6497bf113a88e5aadd6e0", "filename": "tests/ui/return_self_not_must_use.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Freturn_self_not_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Freturn_self_not_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freturn_self_not_must_use.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,26 @@\n+error: missing `#[must_use]` attribute on a method returning `Self`\n+  --> $DIR/return_self_not_must_use.rs:7:5\n+   |\n+LL |     fn what(&self) -> Self;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::return-self-not-must-use` implied by `-D warnings`\n+\n+error: missing `#[must_use]` attribute on a method returning `Self`\n+  --> $DIR/return_self_not_must_use.rs:17:5\n+   |\n+LL | /     pub fn foo(&self) -> Self {\n+LL | |         Self\n+LL | |     }\n+   | |_____^\n+\n+error: missing `#[must_use]` attribute on a method returning `Self`\n+  --> $DIR/return_self_not_must_use.rs:20:5\n+   |\n+LL | /     pub fn bar(self) -> Self {\n+LL | |         self\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "1ccb0a1d167d23edb4cc1e79648dd691700efc1a", "filename": "tests/ui/should_impl_trait/corner_cases.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fcorner_cases.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_lifetimes,\n     clippy::missing_safety_doc,\n     clippy::wrong_self_convention,\n-    clippy::missing_panics_doc\n+    clippy::missing_panics_doc,\n+    clippy::return_self_not_must_use\n )]\n \n use std::ops::Mul;"}, {"sha": "20d49f5a9763413100e898613f1f9554704d0325", "filename": "tests/ui/should_impl_trait/method_list_1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_lifetimes,\n     clippy::missing_safety_doc,\n     clippy::wrong_self_convention,\n-    clippy::missing_panics_doc\n+    clippy::missing_panics_doc,\n+    clippy::return_self_not_must_use\n )]\n \n use std::ops::Mul;"}, {"sha": "2b7d4628c3fa02b703e9a58cb98b73d4a1dd6489", "filename": "tests/ui/should_impl_trait/method_list_1.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_1.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,5 @@\n error: method `add` can be confused for the standard trait method `std::ops::Add::add`\n-  --> $DIR/method_list_1.rs:24:5\n+  --> $DIR/method_list_1.rs:25:5\n    |\n LL | /     pub fn add(self, other: T) -> T {\n LL | |         unimplemented!()\n@@ -10,7 +10,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Add` or choosing a less ambiguous method name\n \n error: method `as_mut` can be confused for the standard trait method `std::convert::AsMut::as_mut`\n-  --> $DIR/method_list_1.rs:28:5\n+  --> $DIR/method_list_1.rs:29:5\n    |\n LL | /     pub fn as_mut(&mut self) -> &mut T {\n LL | |         unimplemented!()\n@@ -20,7 +20,7 @@ LL | |     }\n    = help: consider implementing the trait `std::convert::AsMut` or choosing a less ambiguous method name\n \n error: method `as_ref` can be confused for the standard trait method `std::convert::AsRef::as_ref`\n-  --> $DIR/method_list_1.rs:32:5\n+  --> $DIR/method_list_1.rs:33:5\n    |\n LL | /     pub fn as_ref(&self) -> &T {\n LL | |         unimplemented!()\n@@ -30,7 +30,7 @@ LL | |     }\n    = help: consider implementing the trait `std::convert::AsRef` or choosing a less ambiguous method name\n \n error: method `bitand` can be confused for the standard trait method `std::ops::BitAnd::bitand`\n-  --> $DIR/method_list_1.rs:36:5\n+  --> $DIR/method_list_1.rs:37:5\n    |\n LL | /     pub fn bitand(self, rhs: T) -> T {\n LL | |         unimplemented!()\n@@ -40,7 +40,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::BitAnd` or choosing a less ambiguous method name\n \n error: method `bitor` can be confused for the standard trait method `std::ops::BitOr::bitor`\n-  --> $DIR/method_list_1.rs:40:5\n+  --> $DIR/method_list_1.rs:41:5\n    |\n LL | /     pub fn bitor(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -50,7 +50,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::BitOr` or choosing a less ambiguous method name\n \n error: method `bitxor` can be confused for the standard trait method `std::ops::BitXor::bitxor`\n-  --> $DIR/method_list_1.rs:44:5\n+  --> $DIR/method_list_1.rs:45:5\n    |\n LL | /     pub fn bitxor(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -60,7 +60,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::BitXor` or choosing a less ambiguous method name\n \n error: method `borrow` can be confused for the standard trait method `std::borrow::Borrow::borrow`\n-  --> $DIR/method_list_1.rs:48:5\n+  --> $DIR/method_list_1.rs:49:5\n    |\n LL | /     pub fn borrow(&self) -> &str {\n LL | |         unimplemented!()\n@@ -70,7 +70,7 @@ LL | |     }\n    = help: consider implementing the trait `std::borrow::Borrow` or choosing a less ambiguous method name\n \n error: method `borrow_mut` can be confused for the standard trait method `std::borrow::BorrowMut::borrow_mut`\n-  --> $DIR/method_list_1.rs:52:5\n+  --> $DIR/method_list_1.rs:53:5\n    |\n LL | /     pub fn borrow_mut(&mut self) -> &mut str {\n LL | |         unimplemented!()\n@@ -80,7 +80,7 @@ LL | |     }\n    = help: consider implementing the trait `std::borrow::BorrowMut` or choosing a less ambiguous method name\n \n error: method `clone` can be confused for the standard trait method `std::clone::Clone::clone`\n-  --> $DIR/method_list_1.rs:56:5\n+  --> $DIR/method_list_1.rs:57:5\n    |\n LL | /     pub fn clone(&self) -> Self {\n LL | |         unimplemented!()\n@@ -90,7 +90,7 @@ LL | |     }\n    = help: consider implementing the trait `std::clone::Clone` or choosing a less ambiguous method name\n \n error: method `cmp` can be confused for the standard trait method `std::cmp::Ord::cmp`\n-  --> $DIR/method_list_1.rs:60:5\n+  --> $DIR/method_list_1.rs:61:5\n    |\n LL | /     pub fn cmp(&self, other: &Self) -> Self {\n LL | |         unimplemented!()\n@@ -100,7 +100,7 @@ LL | |     }\n    = help: consider implementing the trait `std::cmp::Ord` or choosing a less ambiguous method name\n \n error: method `deref` can be confused for the standard trait method `std::ops::Deref::deref`\n-  --> $DIR/method_list_1.rs:68:5\n+  --> $DIR/method_list_1.rs:69:5\n    |\n LL | /     pub fn deref(&self) -> &Self {\n LL | |         unimplemented!()\n@@ -110,7 +110,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Deref` or choosing a less ambiguous method name\n \n error: method `deref_mut` can be confused for the standard trait method `std::ops::DerefMut::deref_mut`\n-  --> $DIR/method_list_1.rs:72:5\n+  --> $DIR/method_list_1.rs:73:5\n    |\n LL | /     pub fn deref_mut(&mut self) -> &mut Self {\n LL | |         unimplemented!()\n@@ -120,7 +120,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::DerefMut` or choosing a less ambiguous method name\n \n error: method `div` can be confused for the standard trait method `std::ops::Div::div`\n-  --> $DIR/method_list_1.rs:76:5\n+  --> $DIR/method_list_1.rs:77:5\n    |\n LL | /     pub fn div(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -130,7 +130,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Div` or choosing a less ambiguous method name\n \n error: method `drop` can be confused for the standard trait method `std::ops::Drop::drop`\n-  --> $DIR/method_list_1.rs:80:5\n+  --> $DIR/method_list_1.rs:81:5\n    |\n LL | /     pub fn drop(&mut self) {\n LL | |         unimplemented!()"}, {"sha": "3efec1c52023bdb91c14d5483d8fe62c7ddf70b6", "filename": "tests/ui/should_impl_trait/method_list_2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -7,7 +7,8 @@\n     clippy::needless_lifetimes,\n     clippy::missing_safety_doc,\n     clippy::wrong_self_convention,\n-    clippy::missing_panics_doc\n+    clippy::missing_panics_doc,\n+    clippy::return_self_not_must_use\n )]\n \n use std::ops::Mul;"}, {"sha": "b6fd435695698e6ca47adee8a423824472e6b14d", "filename": "tests/ui/should_impl_trait/method_list_2.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshould_impl_trait%2Fmethod_list_2.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,5 @@\n error: method `eq` can be confused for the standard trait method `std::cmp::PartialEq::eq`\n-  --> $DIR/method_list_2.rs:25:5\n+  --> $DIR/method_list_2.rs:26:5\n    |\n LL | /     pub fn eq(&self, other: &Self) -> bool {\n LL | |         unimplemented!()\n@@ -10,7 +10,7 @@ LL | |     }\n    = help: consider implementing the trait `std::cmp::PartialEq` or choosing a less ambiguous method name\n \n error: method `from_iter` can be confused for the standard trait method `std::iter::FromIterator::from_iter`\n-  --> $DIR/method_list_2.rs:29:5\n+  --> $DIR/method_list_2.rs:30:5\n    |\n LL | /     pub fn from_iter<T>(iter: T) -> Self {\n LL | |         unimplemented!()\n@@ -20,7 +20,7 @@ LL | |     }\n    = help: consider implementing the trait `std::iter::FromIterator` or choosing a less ambiguous method name\n \n error: method `from_str` can be confused for the standard trait method `std::str::FromStr::from_str`\n-  --> $DIR/method_list_2.rs:33:5\n+  --> $DIR/method_list_2.rs:34:5\n    |\n LL | /     pub fn from_str(s: &str) -> Result<Self, Self> {\n LL | |         unimplemented!()\n@@ -30,7 +30,7 @@ LL | |     }\n    = help: consider implementing the trait `std::str::FromStr` or choosing a less ambiguous method name\n \n error: method `hash` can be confused for the standard trait method `std::hash::Hash::hash`\n-  --> $DIR/method_list_2.rs:37:5\n+  --> $DIR/method_list_2.rs:38:5\n    |\n LL | /     pub fn hash(&self, state: &mut T) {\n LL | |         unimplemented!()\n@@ -40,7 +40,7 @@ LL | |     }\n    = help: consider implementing the trait `std::hash::Hash` or choosing a less ambiguous method name\n \n error: method `index` can be confused for the standard trait method `std::ops::Index::index`\n-  --> $DIR/method_list_2.rs:41:5\n+  --> $DIR/method_list_2.rs:42:5\n    |\n LL | /     pub fn index(&self, index: usize) -> &Self {\n LL | |         unimplemented!()\n@@ -50,7 +50,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Index` or choosing a less ambiguous method name\n \n error: method `index_mut` can be confused for the standard trait method `std::ops::IndexMut::index_mut`\n-  --> $DIR/method_list_2.rs:45:5\n+  --> $DIR/method_list_2.rs:46:5\n    |\n LL | /     pub fn index_mut(&mut self, index: usize) -> &mut Self {\n LL | |         unimplemented!()\n@@ -60,7 +60,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::IndexMut` or choosing a less ambiguous method name\n \n error: method `into_iter` can be confused for the standard trait method `std::iter::IntoIterator::into_iter`\n-  --> $DIR/method_list_2.rs:49:5\n+  --> $DIR/method_list_2.rs:50:5\n    |\n LL | /     pub fn into_iter(self) -> Self {\n LL | |         unimplemented!()\n@@ -70,7 +70,7 @@ LL | |     }\n    = help: consider implementing the trait `std::iter::IntoIterator` or choosing a less ambiguous method name\n \n error: method `mul` can be confused for the standard trait method `std::ops::Mul::mul`\n-  --> $DIR/method_list_2.rs:53:5\n+  --> $DIR/method_list_2.rs:54:5\n    |\n LL | /     pub fn mul(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -80,7 +80,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Mul` or choosing a less ambiguous method name\n \n error: method `neg` can be confused for the standard trait method `std::ops::Neg::neg`\n-  --> $DIR/method_list_2.rs:57:5\n+  --> $DIR/method_list_2.rs:58:5\n    |\n LL | /     pub fn neg(self) -> Self {\n LL | |         unimplemented!()\n@@ -90,7 +90,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Neg` or choosing a less ambiguous method name\n \n error: method `next` can be confused for the standard trait method `std::iter::Iterator::next`\n-  --> $DIR/method_list_2.rs:61:5\n+  --> $DIR/method_list_2.rs:62:5\n    |\n LL | /     pub fn next(&mut self) -> Option<Self> {\n LL | |         unimplemented!()\n@@ -100,7 +100,7 @@ LL | |     }\n    = help: consider implementing the trait `std::iter::Iterator` or choosing a less ambiguous method name\n \n error: method `not` can be confused for the standard trait method `std::ops::Not::not`\n-  --> $DIR/method_list_2.rs:65:5\n+  --> $DIR/method_list_2.rs:66:5\n    |\n LL | /     pub fn not(self) -> Self {\n LL | |         unimplemented!()\n@@ -110,7 +110,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Not` or choosing a less ambiguous method name\n \n error: method `rem` can be confused for the standard trait method `std::ops::Rem::rem`\n-  --> $DIR/method_list_2.rs:69:5\n+  --> $DIR/method_list_2.rs:70:5\n    |\n LL | /     pub fn rem(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -120,7 +120,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Rem` or choosing a less ambiguous method name\n \n error: method `shl` can be confused for the standard trait method `std::ops::Shl::shl`\n-  --> $DIR/method_list_2.rs:73:5\n+  --> $DIR/method_list_2.rs:74:5\n    |\n LL | /     pub fn shl(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -130,7 +130,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Shl` or choosing a less ambiguous method name\n \n error: method `shr` can be confused for the standard trait method `std::ops::Shr::shr`\n-  --> $DIR/method_list_2.rs:77:5\n+  --> $DIR/method_list_2.rs:78:5\n    |\n LL | /     pub fn shr(self, rhs: Self) -> Self {\n LL | |         unimplemented!()\n@@ -140,7 +140,7 @@ LL | |     }\n    = help: consider implementing the trait `std::ops::Shr` or choosing a less ambiguous method name\n \n error: method `sub` can be confused for the standard trait method `std::ops::Sub::sub`\n-  --> $DIR/method_list_2.rs:81:5\n+  --> $DIR/method_list_2.rs:82:5\n    |\n LL | /     pub fn sub(self, rhs: Self) -> Self {\n LL | |         unimplemented!()"}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "86a7bd7b62735443e8c305b04a6932bedd213c8d", "filename": "tests/ui/type_complexity.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_complexity.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -30,6 +30,15 @@ trait T {\n     fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n }\n \n+// Should not warn since there is likely no way to simplify this (#1013)\n+impl T for () {\n+    const A: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![];\n+\n+    type B = Vec<Vec<Box<(u32, u32, u32, u32)>>>;\n+\n+    fn method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n+}\n+\n fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> {\n     vec![]\n }"}, {"sha": "9da7edb1c3b74e27275e6f6f9b1810163040a45b", "filename": "tests/ui/type_complexity.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftype_complexity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Ftype_complexity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_complexity.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -73,19 +73,19 @@ LL |     fn def_method(&self, p: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/type_complexity.rs:33:15\n+  --> $DIR/type_complexity.rs:42:15\n    |\n LL | fn test1() -> Vec<Vec<Box<(u32, u32, u32, u32)>>> {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/type_complexity.rs:37:14\n+  --> $DIR/type_complexity.rs:46:14\n    |\n LL | fn test2(_x: Vec<Vec<Box<(u32, u32, u32, u32)>>>) {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: very complex type used. Consider factoring parts into `type` definitions\n-  --> $DIR/type_complexity.rs:40:13\n+  --> $DIR/type_complexity.rs:49:13\n    |\n LL |     let _y: Vec<Vec<Box<(u32, u32, u32, u32)>>> = vec![];\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e01e9f07bafdaf28d8e2552a7e2110b5af69f736", "filename": "tests/ui/unnecessary_iter_cloned.fixed", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "6ef2966c8b762d373060133bca21c4ab68ba5fd9", "filename": "tests/ui/unnecessary_iter_cloned.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,142 @@\n+// run-rustfix\n+\n+#![allow(unused_assignments)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+#[allow(dead_code)]\n+#[derive(Clone, Copy)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let path = std::path::Path::new(\"x\");\n+\n+    let _ = check_files(&[(FileType::Account, path)]);\n+    let _ = check_files_vec(vec![(FileType::Account, path)]);\n+\n+    // negative tests\n+    let _ = check_files_ref(&[(FileType::Account, path)]);\n+    let _ = check_files_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_ref_mut(&[(FileType::Account, path)]);\n+    let _ = check_files_self_and_arg(&[(FileType::Account, path)]);\n+    let _ = check_files_mut_path_buf(&[(FileType::Account, std::path::PathBuf::new())]);\n+}\n+\n+// `check_files` and its variants are based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_vec(files: Vec<(FileType, &std::path::Path)>) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref t, path) in files.iter().copied() {\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (mut t, path) in files.iter().copied() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_ref_mut(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (ref mut t, path) in files.iter().copied() {\n+        *t = FileType::PrivateKey;\n+        let other = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn check_files_self_and_arg(files: &[(FileType, &std::path::Path)]) -> bool {\n+    for (t, path) in files.iter().copied() {\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.join(path).is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+#[allow(unused_assignments)]\n+fn check_files_mut_path_buf(files: &[(FileType, std::path::PathBuf)]) -> bool {\n+    for (mut t, path) in files.iter().cloned() {\n+        t = FileType::PrivateKey;\n+        let other = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() || !other.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}"}, {"sha": "e44379f8aa04783b35390018a3a5538e11a3c640", "filename": "tests/ui/unnecessary_iter_cloned.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_iter_cloned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_iter_cloned.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,35 @@\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:31:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+help: use\n+   |\n+LL |     for (t, path) in files {\n+   |                      ~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: unnecessary use of `copied`\n+  --> $DIR/unnecessary_iter_cloned.rs:46:22\n+   |\n+LL |     for (t, path) in files.iter().copied() {\n+   |                      ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for (t, path) in files.iter() {\n+   |                      ~~~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let other = match get_file_path(&t) {\n+LL +         let other = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "720138db137726cbf6c1844a6ba2d63b8aa0e7c6", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, CString, OsStr, OsString};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n+\n+    require_c_str(&Cow::from(c_str));\n+    require_c_str(c_str);\n+\n+    require_os_str(os_str);\n+    require_os_str(&Cow::from(os_str));\n+    require_os_str(os_str);\n+\n+    require_path(path);\n+    require_path(&Cow::from(path));\n+    require_path(path);\n+\n+    require_str(s);\n+    require_str(&Cow::from(s));\n+    require_str(s);\n+    require_str(x_ref.as_ref());\n+\n+    require_slice(slice);\n+    require_slice(&Cow::from(slice));\n+    require_slice(array.as_ref());\n+    require_slice(array_ref.as_ref());\n+    require_slice(slice);\n+    require_slice(x_ref);\n+\n+    require_x(&Cow::<X>::Owned(x.clone()));\n+    require_x(x_ref);\n+\n+    require_deref_c_str(c_str);\n+    require_deref_os_str(os_str);\n+    require_deref_path(path);\n+    require_deref_str(s);\n+    require_deref_slice(slice);\n+\n+    require_impl_deref_c_str(c_str);\n+    require_impl_deref_os_str(os_str);\n+    require_impl_deref_path(path);\n+    require_impl_deref_str(s);\n+    require_impl_deref_slice(slice);\n+\n+    require_deref_str_slice(s, slice);\n+    require_deref_slice_str(slice, s);\n+\n+    require_as_ref_c_str(c_str);\n+    require_as_ref_os_str(os_str);\n+    require_as_ref_path(path);\n+    require_as_ref_str(s);\n+    require_as_ref_str(&x);\n+    require_as_ref_slice(array);\n+    require_as_ref_slice(array_ref);\n+    require_as_ref_slice(slice);\n+\n+    require_impl_as_ref_c_str(c_str);\n+    require_impl_as_ref_os_str(os_str);\n+    require_impl_as_ref_path(path);\n+    require_impl_as_ref_str(s);\n+    require_impl_as_ref_str(&x);\n+    require_impl_as_ref_slice(array);\n+    require_impl_as_ref_slice(array_ref);\n+    require_impl_as_ref_slice(slice);\n+\n+    require_as_ref_str_slice(s, array);\n+    require_as_ref_str_slice(s, array_ref);\n+    require_as_ref_str_slice(s, slice);\n+    require_as_ref_slice_str(array, s);\n+    require_as_ref_slice_str(array_ref, s);\n+    require_as_ref_slice_str(slice, s);\n+\n+    let _ = x.join(x_ref);\n+\n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = slice.iter().copied();\n+    let _ = slice.iter().copied();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+    let _ = [std::path::PathBuf::new()][..].iter().cloned();\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x_ref.to_string());\n+\n+    // `X` isn't copy.\n+    require_slice(&x.to_owned());\n+    require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap());\n+    require_os_str(&OsString::from(\"x\"));\n+    require_path(&std::path::PathBuf::from(\"x\"));\n+    require_str(&String::from(\"x\"));\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types {\n+        let path = match get_file_path(t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n+fn require_string(_: &String) {}"}, {"sha": "60b2e718f5d499aefb887461737c0ab0ea42d68e", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,214 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, CString, OsStr, OsString};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Clone)]\n+enum FileType {\n+    Account,\n+    PrivateKey,\n+    Certificate,\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+    let x_ref = &x;\n+\n+    require_c_str(&Cow::from(c_str).into_owned());\n+    require_c_str(&c_str.to_owned());\n+\n+    require_os_str(&os_str.to_os_string());\n+    require_os_str(&Cow::from(os_str).into_owned());\n+    require_os_str(&os_str.to_owned());\n+\n+    require_path(&path.to_path_buf());\n+    require_path(&Cow::from(path).into_owned());\n+    require_path(&path.to_owned());\n+\n+    require_str(&s.to_string());\n+    require_str(&Cow::from(s).into_owned());\n+    require_str(&s.to_owned());\n+    require_str(&x_ref.to_string());\n+\n+    require_slice(&slice.to_vec());\n+    require_slice(&Cow::from(slice).into_owned());\n+    require_slice(&array.to_owned());\n+    require_slice(&array_ref.to_owned());\n+    require_slice(&slice.to_owned());\n+    require_slice(&x_ref.to_owned());\n+\n+    require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+    require_x(&x_ref.to_owned());\n+\n+    require_deref_c_str(c_str.to_owned());\n+    require_deref_os_str(os_str.to_owned());\n+    require_deref_path(path.to_owned());\n+    require_deref_str(s.to_owned());\n+    require_deref_slice(slice.to_owned());\n+\n+    require_impl_deref_c_str(c_str.to_owned());\n+    require_impl_deref_os_str(os_str.to_owned());\n+    require_impl_deref_path(path.to_owned());\n+    require_impl_deref_str(s.to_owned());\n+    require_impl_deref_slice(slice.to_owned());\n+\n+    require_deref_str_slice(s.to_owned(), slice.to_owned());\n+    require_deref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    require_as_ref_c_str(c_str.to_owned());\n+    require_as_ref_os_str(os_str.to_owned());\n+    require_as_ref_path(path.to_owned());\n+    require_as_ref_str(s.to_owned());\n+    require_as_ref_str(x.to_owned());\n+    require_as_ref_slice(array.to_owned());\n+    require_as_ref_slice(array_ref.to_owned());\n+    require_as_ref_slice(slice.to_owned());\n+\n+    require_impl_as_ref_c_str(c_str.to_owned());\n+    require_impl_as_ref_os_str(os_str.to_owned());\n+    require_impl_as_ref_path(path.to_owned());\n+    require_impl_as_ref_str(s.to_owned());\n+    require_impl_as_ref_str(x.to_owned());\n+    require_impl_as_ref_slice(array.to_owned());\n+    require_impl_as_ref_slice(array_ref.to_owned());\n+    require_impl_as_ref_slice(slice.to_owned());\n+\n+    require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+    require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    let _ = x.join(&x_ref.to_string());\n+\n+    let _ = slice.to_vec().into_iter();\n+    let _ = slice.to_owned().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+    let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+\n+    let _ = IntoIterator::into_iter(slice.to_vec());\n+    let _ = IntoIterator::into_iter(slice.to_owned());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+    let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+\n+    let _ = check_files(&[FileType::Account]);\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x_ref.to_string());\n+\n+    // `X` isn't copy.\n+    require_slice(&x.to_owned());\n+    require_deref_slice(x.to_owned());\n+\n+    // The following should be flagged by `redundant_clone`, but not by this lint.\n+    require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+    require_os_str(&OsString::from(\"x\").to_os_string());\n+    require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+    require_str(&String::from(\"x\").to_string());\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+// `check_files` is based on:\n+// https://github.com/breard-r/acmed/blob/1f0dcc32aadbc5e52de6d23b9703554c0f925113/acmed/src/storage.rs#L262\n+fn check_files(file_types: &[FileType]) -> bool {\n+    for t in file_types.to_vec() {\n+        let path = match get_file_path(&t) {\n+            Ok(p) => p,\n+            Err(_) => {\n+                return false;\n+            },\n+        };\n+        if !path.is_file() {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::Error> {\n+    Ok(std::path::PathBuf::new())\n+}\n+\n+fn require_string(_: &String) {}"}, {"sha": "1dfc65e22e2bc7c9d023389b9ba02ef74fd14f47", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=fad9407c5a8e61ae3d79b1d92f8a698e9b7461a0", "patch": "@@ -0,0 +1,495 @@\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:150:64\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                                                                ^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::redundant-clone` implied by `-D warnings`\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:150:20\n+   |\n+LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:151:40\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                                        ^^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:151:21\n+   |\n+LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n+   |                     ^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:152:48\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                                                ^^^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:152:19\n+   |\n+LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: redundant clone\n+  --> $DIR/unnecessary_to_owned.rs:153:35\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                                   ^^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/unnecessary_to_owned.rs:153:18\n+   |\n+LL |     require_str(&String::from(\"x\").to_string());\n+   |                  ^^^^^^^^^^^^^^^^^\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:59:36\n+   |\n+LL |     require_c_str(&Cow::from(c_str).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:60:19\n+   |\n+LL |     require_c_str(&c_str.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_os_string`\n+  --> $DIR/unnecessary_to_owned.rs:62:20\n+   |\n+LL |     require_os_str(&os_str.to_os_string());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:63:38\n+   |\n+LL |     require_os_str(&Cow::from(os_str).into_owned());\n+   |                                      ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:64:20\n+   |\n+LL |     require_os_str(&os_str.to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_path_buf`\n+  --> $DIR/unnecessary_to_owned.rs:66:18\n+   |\n+LL |     require_path(&path.to_path_buf());\n+   |                  ^^^^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:67:34\n+   |\n+LL |     require_path(&Cow::from(path).into_owned());\n+   |                                  ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:68:18\n+   |\n+LL |     require_path(&path.to_owned());\n+   |                  ^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:70:17\n+   |\n+LL |     require_str(&s.to_string());\n+   |                 ^^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:71:30\n+   |\n+LL |     require_str(&Cow::from(s).into_owned());\n+   |                              ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:72:17\n+   |\n+LL |     require_str(&s.to_owned());\n+   |                 ^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:73:17\n+   |\n+LL |     require_str(&x_ref.to_string());\n+   |                 ^^^^^^^^^^^^^^^^^^ help: use: `x_ref.as_ref()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:75:19\n+   |\n+LL |     require_slice(&slice.to_vec());\n+   |                   ^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:76:36\n+   |\n+LL |     require_slice(&Cow::from(slice).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:77:19\n+   |\n+LL |     require_slice(&array.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `array.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:78:19\n+   |\n+LL |     require_slice(&array_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:79:19\n+   |\n+LL |     require_slice(&slice.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:80:19\n+   |\n+LL |     require_slice(&x_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:82:42\n+   |\n+LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+   |                                          ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:83:15\n+   |\n+LL |     require_x(&x_ref.to_owned());\n+   |               ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:85:25\n+   |\n+LL |     require_deref_c_str(c_str.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:86:26\n+   |\n+LL |     require_deref_os_str(os_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:87:24\n+   |\n+LL |     require_deref_path(path.to_owned());\n+   |                        ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:88:23\n+   |\n+LL |     require_deref_str(s.to_owned());\n+   |                       ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:89:25\n+   |\n+LL |     require_deref_slice(slice.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:91:30\n+   |\n+LL |     require_impl_deref_c_str(c_str.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:92:31\n+   |\n+LL |     require_impl_deref_os_str(os_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:93:29\n+   |\n+LL |     require_impl_deref_path(path.to_owned());\n+   |                             ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:94:28\n+   |\n+LL |     require_impl_deref_str(s.to_owned());\n+   |                            ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:95:30\n+   |\n+LL |     require_impl_deref_slice(slice.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:97:29\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:97:43\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                           ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:98:29\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                             ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:98:47\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                               ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:100:26\n+   |\n+LL |     require_as_ref_c_str(c_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:101:27\n+   |\n+LL |     require_as_ref_os_str(os_str.to_owned());\n+   |                           ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:102:25\n+   |\n+LL |     require_as_ref_path(path.to_owned());\n+   |                         ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:103:24\n+   |\n+LL |     require_as_ref_str(s.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:104:24\n+   |\n+LL |     require_as_ref_str(x.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:105:26\n+   |\n+LL |     require_as_ref_slice(array.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:106:26\n+   |\n+LL |     require_as_ref_slice(array_ref.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:107:26\n+   |\n+LL |     require_as_ref_slice(slice.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:109:31\n+   |\n+LL |     require_impl_as_ref_c_str(c_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:110:32\n+   |\n+LL |     require_impl_as_ref_os_str(os_str.to_owned());\n+   |                                ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:111:30\n+   |\n+LL |     require_impl_as_ref_path(path.to_owned());\n+   |                              ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:112:29\n+   |\n+LL |     require_impl_as_ref_str(s.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:113:29\n+   |\n+LL |     require_impl_as_ref_str(x.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:114:31\n+   |\n+LL |     require_impl_as_ref_slice(array.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:115:31\n+   |\n+LL |     require_impl_as_ref_slice(array_ref.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:116:31\n+   |\n+LL |     require_impl_as_ref_slice(slice.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:120:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:120:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:121:30\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:121:48\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:122:30\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:122:52\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                                                    ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:123:30\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:123:48\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:125:20\n+   |\n+LL |     let _ = x.join(&x_ref.to_string());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:127:13\n+   |\n+LL |     let _ = slice.to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:128:13\n+   |\n+LL |     let _ = slice.to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:129:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:130:13\n+   |\n+LL |     let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:132:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:133:13\n+   |\n+LL |     let _ = IntoIterator::into_iter(slice.to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:134:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:135:13\n+   |\n+LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:196:14\n+   |\n+LL |     for t in file_types.to_vec() {\n+   |              ^^^^^^^^^^^^^^^^^^^\n+   |\n+help: use\n+   |\n+LL |     for t in file_types {\n+   |              ~~~~~~~~~~\n+help: remove this `&`\n+   |\n+LL -         let path = match get_file_path(&t) {\n+LL +         let path = match get_file_path(t) {\n+   | \n+\n+error: aborting due to 76 previous errors\n+"}]}