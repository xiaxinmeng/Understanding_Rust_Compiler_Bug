{"sha": "347db068a5786d3cac6e2204d7e14b635ece558d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0N2RiMDY4YTU3ODZkM2NhYzZlMjIwNGQ3ZTE0YjYzNWVjZTU1OGQ=", "commit": {"author": {"name": "Stuart Pernsteiner", "email": "spernsteiner@galois.com", "date": "2017-08-14T22:27:20Z"}, "committer": {"name": "Stuart Pernsteiner", "email": "spernsteiner@galois.com", "date": "2017-09-06T17:01:15Z"}, "message": "hir::print: fix parenthesization of exprs", "tree": {"sha": "6ad277ee06fb505c6b222773978a211be7f733c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ad277ee06fb505c6b222773978a211be7f733c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/347db068a5786d3cac6e2204d7e14b635ece558d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/347db068a5786d3cac6e2204d7e14b635ece558d", "html_url": "https://github.com/rust-lang/rust/commit/347db068a5786d3cac6e2204d7e14b635ece558d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/347db068a5786d3cac6e2204d7e14b635ece558d/comments", "author": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spernsteiner", "id": 3031136, "node_id": "MDQ6VXNlcjMwMzExMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/3031136?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spernsteiner", "html_url": "https://github.com/spernsteiner", "followers_url": "https://api.github.com/users/spernsteiner/followers", "following_url": "https://api.github.com/users/spernsteiner/following{/other_user}", "gists_url": "https://api.github.com/users/spernsteiner/gists{/gist_id}", "starred_url": "https://api.github.com/users/spernsteiner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spernsteiner/subscriptions", "organizations_url": "https://api.github.com/users/spernsteiner/orgs", "repos_url": "https://api.github.com/users/spernsteiner/repos", "events_url": "https://api.github.com/users/spernsteiner/events{/privacy}", "received_events_url": "https://api.github.com/users/spernsteiner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b2151ea21c2b1fa517bda90ca881e3f27e9188a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b2151ea21c2b1fa517bda90ca881e3f27e9188a", "html_url": "https://github.com/rust-lang/rust/commit/5b2151ea21c2b1fa517bda90ca881e3f27e9188a"}], "stats": {"total": 218, "additions": 180, "deletions": 38}, "files": [{"sha": "dce7dd33db4235bb361034fc1c666c7a212f5faa", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 180, "deletions": 38, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/347db068a5786d3cac6e2204d7e14b635ece558d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347db068a5786d3cac6e2204d7e14b635ece558d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=347db068a5786d3cac6e2204d7e14b635ece558d", "patch": "@@ -20,6 +20,7 @@ use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n+use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos};\n \n use hir;\n@@ -210,18 +211,6 @@ pub fn visibility_qualified(vis: &hir::Visibility, w: &str) -> String {\n     })\n }\n \n-fn needs_parentheses(expr: &hir::Expr) -> bool {\n-    match expr.node {\n-        hir::ExprAssign(..) |\n-        hir::ExprBinary(..) |\n-        hir::ExprClosure(..) |\n-        hir::ExprAssignOp(..) |\n-        hir::ExprCast(..) |\n-        hir::ExprType(..) => true,\n-        _ => false,\n-    }\n-}\n-\n impl<'a> State<'a> {\n     pub fn cbox(&mut self, u: usize) -> io::Result<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n@@ -1047,7 +1036,7 @@ impl<'a> State<'a> {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else if \")?;\n-                        self.print_expr(&i)?;\n+                        self.print_expr_as_cond(&i)?;\n                         self.s.space()?;\n                         self.print_expr(&then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n@@ -1075,7 +1064,7 @@ impl<'a> State<'a> {\n                     elseopt: Option<&hir::Expr>)\n                     -> io::Result<()> {\n         self.head(\"if\")?;\n-        self.print_expr(test)?;\n+        self.print_expr_as_cond(test)?;\n         self.s.space()?;\n         self.print_expr(blk)?;\n         self.print_else(elseopt)\n@@ -1091,7 +1080,7 @@ impl<'a> State<'a> {\n         self.print_pat(pat)?;\n         self.s.space()?;\n         self.word_space(\"=\")?;\n-        self.print_expr(expr)?;\n+        self.print_expr_as_cond(expr)?;\n         self.s.space()?;\n         self.print_block(blk)?;\n         self.print_else(elseopt)\n@@ -1104,8 +1093,31 @@ impl<'a> State<'a> {\n         self.pclose()\n     }\n \n-    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr) -> io::Result<()> {\n-        let needs_par = needs_parentheses(expr);\n+    pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n+        let needs_par = expr_precedence(expr) < prec;\n+        if needs_par {\n+            self.popen()?;\n+        }\n+        self.print_expr(expr)?;\n+        if needs_par {\n+            self.pclose()?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Print an expr using syntax that's acceptable in a condition position, such as the `cond` in\n+    /// `if cond { ... }`.\n+    pub fn print_expr_as_cond(&mut self, expr: &hir::Expr) -> io::Result<()> {\n+        let needs_par = match expr.node {\n+            // These cases need parens due to the parse error observed in #26461: `if return {}`\n+            // parses as the erroneous construct `if (return {})`, not `if (return) {}`.\n+            hir::ExprClosure(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprBreak(..) => true,\n+\n+            _ => contains_exterior_struct_lit(expr),\n+        };\n+\n         if needs_par {\n             self.popen()?;\n         }\n@@ -1182,7 +1194,14 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n-        self.print_expr_maybe_paren(func)?;\n+        let prec =\n+            match func.node {\n+                hir::ExprField(..) |\n+                hir::ExprTupField(..) => parser::PREC_FORCE_PAREN,\n+                _ => parser::PREC_POSTFIX,\n+            };\n+\n+        self.print_expr_maybe_paren(func, prec)?;\n         self.print_call_post(args)\n     }\n \n@@ -1191,7 +1210,7 @@ impl<'a> State<'a> {\n                               args: &[hir::Expr])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n-        self.print_expr(&args[0])?;\n+        self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n         if !segment.parameters.lifetimes.is_empty() ||\n@@ -1207,15 +1226,25 @@ impl<'a> State<'a> {\n                          lhs: &hir::Expr,\n                          rhs: &hir::Expr)\n                          -> io::Result<()> {\n-        self.print_expr(lhs)?;\n+        let assoc_op = bin_op_to_assoc_op(op.node);\n+        let prec = assoc_op.precedence() as i8;\n+        let fixity = assoc_op.fixity();\n+\n+        let (left_prec, right_prec) = match fixity {\n+            Fixity::Left => (prec, prec + 1),\n+            Fixity::Right => (prec + 1, prec),\n+            Fixity::None => (prec + 1, prec + 1),\n+        };\n+\n+        self.print_expr_maybe_paren(lhs, left_prec)?;\n         self.s.space()?;\n         self.word_space(op.node.as_str())?;\n-        self.print_expr(rhs)\n+        self.print_expr_maybe_paren(rhs, right_prec)\n     }\n \n     fn print_expr_unary(&mut self, op: hir::UnOp, expr: &hir::Expr) -> io::Result<()> {\n         self.s.word(op.as_str())?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     fn print_expr_addr_of(&mut self,\n@@ -1224,7 +1253,7 @@ impl<'a> State<'a> {\n                           -> io::Result<()> {\n         self.s.word(\"&\")?;\n         self.print_mutability(mutability)?;\n-        self.print_expr_maybe_paren(expr)\n+        self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)\n     }\n \n     pub fn print_expr(&mut self, expr: &hir::Expr) -> io::Result<()> {\n@@ -1235,7 +1264,7 @@ impl<'a> State<'a> {\n         match expr.node {\n             hir::ExprBox(ref expr) => {\n                 self.word_space(\"box\")?;\n-                self.print_expr(expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n             hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(exprs)?;\n@@ -1268,13 +1297,15 @@ impl<'a> State<'a> {\n                 self.print_literal(&lit)?;\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::As.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.s.space()?;\n                 self.word_space(\"as\")?;\n                 self.print_type(&ty)?;\n             }\n             hir::ExprType(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                let prec = AssocOp::Colon.precedence() as i8;\n+                self.print_expr_maybe_paren(&expr, prec)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n             }\n@@ -1287,7 +1318,7 @@ impl<'a> State<'a> {\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(&test)?;\n+                self.print_expr_as_cond(&test)?;\n                 self.s.space()?;\n                 self.print_block(&blk)?;\n             }\n@@ -1304,7 +1335,7 @@ impl<'a> State<'a> {\n                 self.cbox(indent_unit)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_as_cond(&expr)?;\n                 self.s.space()?;\n                 self.bopen()?;\n                 for arm in arms {\n@@ -1335,30 +1366,32 @@ impl<'a> State<'a> {\n                 self.print_block(&blk)?;\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                let prec = AssocOp::Assign.precedence() as i8;\n+                self.print_expr_maybe_paren(&lhs, prec + 1)?;\n                 self.s.space()?;\n                 self.s.word(op.node.as_str())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n             hir::ExprField(ref expr, name) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n             hir::ExprTupField(ref expr, id) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n                 self.print_usize(id.node)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n                 self.print_expr(&index)?;\n                 self.s.word(\"]\")?;\n@@ -1374,7 +1407,7 @@ impl<'a> State<'a> {\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n-                    self.print_expr(expr)?;\n+                    self.print_expr_maybe_paren(expr, parser::PREC_JUMP)?;\n                     self.s.space()?;\n                 }\n             }\n@@ -1391,7 +1424,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         self.s.word(\" \")?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n                     }\n                     _ => (),\n                 }\n@@ -1463,7 +1496,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprYield(ref expr) => {\n                 self.s.word(\"yield\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n@@ -2246,3 +2279,112 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n         }\n     }\n }\n+\n+\n+fn expr_precedence(expr: &hir::Expr) -> i8 {\n+    use syntax::util::parser::*;\n+\n+    match expr.node {\n+        hir::ExprClosure(..) => PREC_CLOSURE,\n+\n+        hir::ExprBreak(..) |\n+        hir::ExprAgain(..) |\n+        hir::ExprRet(..) |\n+        hir::ExprYield(..) => PREC_JUMP,\n+\n+        hir::ExprIf(..) |\n+        hir::ExprWhile(..) |\n+        hir::ExprLoop(..) |\n+        hir::ExprMatch(..) |\n+        hir::ExprBlock(..) => PREC_BLOCK,\n+\n+        // Binop-like expr kinds, handled by `AssocOp`.\n+        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n+\n+        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n+        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n+\n+        hir::ExprAssign(..) |\n+        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n+\n+        // Unary, prefix\n+        hir::ExprBox(..) |\n+        hir::ExprAddrOf(..) |\n+        hir::ExprUnary(..) => PREC_PREFIX,\n+\n+        // Unary, postfix\n+        hir::ExprCall(..) |\n+        hir::ExprMethodCall(..) |\n+        hir::ExprField(..) |\n+        hir::ExprTupField(..) |\n+        hir::ExprIndex(..) |\n+        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n+\n+        // Never need parens\n+        hir::ExprArray(..) |\n+        hir::ExprRepeat(..) |\n+        hir::ExprTup(..) |\n+        hir::ExprLit(..) |\n+        hir::ExprPath(..) |\n+        hir::ExprStruct(..) => PREC_PAREN,\n+    }\n+}\n+\n+fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n+    use hir::BinOp_::*;\n+    match op {\n+        BiAdd => AssocOp::Add,\n+        BiSub => AssocOp::Subtract,\n+        BiMul => AssocOp::Multiply,\n+        BiDiv => AssocOp::Divide,\n+        BiRem => AssocOp::Modulus,\n+\n+        BiAnd => AssocOp::LAnd,\n+        BiOr => AssocOp::LOr,\n+\n+        BiBitXor => AssocOp::BitXor,\n+        BiBitAnd => AssocOp::BitAnd,\n+        BiBitOr => AssocOp::BitOr,\n+        BiShl => AssocOp::ShiftLeft,\n+        BiShr => AssocOp::ShiftRight,\n+\n+        BiEq => AssocOp::Equal,\n+        BiLt => AssocOp::Less,\n+        BiLe => AssocOp::LessEqual,\n+        BiNe => AssocOp::NotEqual,\n+        BiGe => AssocOp::GreaterEqual,\n+        BiGt => AssocOp::Greater,\n+    }\n+}\n+\n+/// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n+/// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n+/// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n+fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n+    match value.node {\n+        hir::ExprStruct(..) => true,\n+\n+        hir::ExprAssign(ref lhs, ref rhs) |\n+        hir::ExprAssignOp(_, ref lhs, ref rhs) |\n+        hir::ExprBinary(_, ref lhs, ref rhs) => {\n+            // X { y: 1 } + X { y: 2 }\n+            contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n+        }\n+        hir::ExprUnary(_, ref x) |\n+        hir::ExprCast(ref x, _) |\n+        hir::ExprType(ref x, _) |\n+        hir::ExprField(ref x, _) |\n+        hir::ExprTupField(ref x, _) |\n+        hir::ExprIndex(ref x, _) => {\n+            // &X { y: 1 }, X { y: 1 }.y\n+            contains_exterior_struct_lit(&x)\n+        }\n+\n+        hir::ExprMethodCall(.., ref exprs) => {\n+            // X { y: 1 }.bar(...)\n+            contains_exterior_struct_lit(&exprs[0])\n+        }\n+\n+        _ => false,\n+    }\n+}"}]}