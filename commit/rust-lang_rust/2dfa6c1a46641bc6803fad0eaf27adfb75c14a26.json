{"sha": "2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZmE2YzFhNDY2NDFiYzY4MDNmYWQwZWFmMjdhZGZiNzVjMTRhMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-28T10:59:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-28T10:59:34Z"}, "message": "Auto merge of #1461 - RalfJung:rwlock-win, r=oli-obk\n\nImplement rwlocks on Windows\n\nFixes https://github.com/rust-lang/miri/issues/1059", "tree": {"sha": "99d06d97bb7738d0613527feff0d403447643e03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99d06d97bb7738d0613527feff0d403447643e03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "html_url": "https://github.com/rust-lang/rust/commit/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d", "html_url": "https://github.com/rust-lang/rust/commit/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d"}, {"sha": "3a5bcb97edd5bab769341aacde18a05c015aa396", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5bcb97edd5bab769341aacde18a05c015aa396", "html_url": "https://github.com/rust-lang/rust/commit/3a5bcb97edd5bab769341aacde18a05c015aa396"}], "stats": {"total": 784, "additions": 522, "deletions": 262}, "files": [{"sha": "c1eaf4eb4865dddd381ca01468fc8b112675209c", "filename": "src/helpers.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -467,6 +467,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n     }\n+    \n+    fn read_scalar_at_offset(\n+        &self,\n+        op: OpTy<'tcx, Tag>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        let this = self.eval_context_ref();\n+        let op_place = this.deref_operand(op)?;\n+        let offset = Size::from_bytes(offset);\n+        // Ensure that the following read at an offset is within bounds\n+        assert!(op_place.layout.size >= offset + layout.size);\n+        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        this.read_scalar(value_place.into())\n+    }\n+\n+    fn write_scalar_at_offset(\n+        &mut self,\n+        op: OpTy<'tcx, Tag>,\n+        offset: u64,\n+        value: impl Into<ScalarMaybeUninit<Tag>>,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        let op_place = this.deref_operand(op)?;\n+        let offset = Size::from_bytes(offset);\n+        // Ensure that the following read at an offset is within bounds\n+        assert!(op_place.layout.size >= offset + layout.size);\n+        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        this.write_scalar(value, value_place.into())\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "9b15cb9ac9a31a96bc1b550101dc91d948102a39", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,34 +1,24 @@\n use rustc_middle::mir;\n \n use crate::*;\n-use helpers::check_arg_count;\n+use shims::posix::dlsym as posix;\n+use shims::windows::dlsym as windows;\n \n #[derive(Debug, Copy, Clone)]\n+#[allow(non_camel_case_types)]\n pub enum Dlsym {\n-    GetEntropy,\n+    Posix(posix::Dlsym),\n+    Windows(windows::Dlsym),\n }\n \n impl Dlsym {\n     // Returns an error for unsupported symbols, and None if this symbol\n     // should become a NULL pointer (pretend it does not exist).\n     pub fn from_str(name: &[u8], target_os: &str) -> InterpResult<'static, Option<Dlsym>> {\n-        use self::Dlsym::*;\n-        let name = String::from_utf8_lossy(name);\n+        let name = &*String::from_utf8_lossy(name);\n         Ok(match target_os {\n-            \"linux\" => match &*name {\n-                \"__pthread_get_minstack\" => None,\n-                _ => throw_unsup_format!(\"unsupported Linux dlsym: {}\", name),\n-            }\n-            \"macos\" => match &*name {\n-                \"getentropy\" => Some(GetEntropy),\n-                _ => throw_unsup_format!(\"unsupported macOS dlsym: {}\", name),\n-            }\n-            \"windows\" => match &*name {\n-                \"SetThreadStackGuarantee\" => None,\n-                \"AcquireSRWLockExclusive\" => None,\n-                \"GetSystemTimePreciseAsFileTime\" => None,\n-                _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n-            }\n+            \"linux\" | \"macos\" => posix::Dlsym::from_str(name, target_os)?.map(Dlsym::Posix),\n+            \"windows\" => windows::Dlsym::from_str(name)?.map(Dlsym::Windows),\n             os => bug!(\"dlsym not implemented for target_os {}\", os),\n         })\n     }\n@@ -42,23 +32,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n     ) -> InterpResult<'tcx> {\n-        use self::Dlsym::*;\n-\n         let this = self.eval_context_mut();\n-        let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n-\n         match dlsym {\n-            GetEntropy => {\n-                let &[ptr, len] = check_arg_count(args)?;\n-                let ptr = this.read_scalar(ptr)?.not_undef()?;\n-                let len = this.read_scalar(len)?.to_machine_usize(this)?;\n-                this.gen_random(ptr, len)?;\n-                this.write_null(dest)?;\n-            }\n+            Dlsym::Posix(dlsym) => posix::EvalContextExt::call_dlsym(this, dlsym, args, ret),\n+            Dlsym::Windows(dlsym) => windows::EvalContextExt::call_dlsym(this, dlsym, args, ret),\n         }\n-\n-        this.dump_place(*dest);\n-        this.go_to_block(ret);\n-        Ok(())\n     }\n }"}, {"sha": "a7495beef72ee21b03c090833d419fb65c8dad4a", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -129,7 +129,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This matches calls to the foreign item `panic_impl`.\n                 // The implementation is provided by the function with the `#[panic_handler]` attribute.\n                 \"panic_impl\" => {\n-                    this.check_panic_supported()?;\n                     let panic_impl_id = tcx.lang_items().panic_impl().unwrap();\n                     let panic_impl_instance = ty::Instance::mono(tcx, panic_impl_id);\n                     return Ok(Some(&*this.load_mir(panic_impl_instance.def, None)?));"}, {"sha": "56754a9ebde554664c66f45bccdb657c33a723c5", "filename": "src/shims/mod.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -52,14 +52,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return this.emulate_foreign_item(instance.def_id(), args, ret, unwind);\n         }\n \n-        // Better error message for panics on Windows.\n-        let def_id = instance.def_id();\n-        if Some(def_id) == this.tcx.lang_items().begin_panic_fn() ||\n-            Some(def_id) == this.tcx.lang_items().panic_impl()\n-        {\n-            this.check_panic_supported()?;\n-        }\n-\n         // Otherwise, load the MIR.\n         Ok(Some(&*this.load_mir(instance.def, None)?))\n     }"}, {"sha": "8e291c2012152bc7eeba603c35de3e59bf77d31b", "filename": "src/shims/panic.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -34,14 +34,6 @@ pub struct CatchUnwindData<'tcx> {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Check if panicking is supported on this target, and give a good error otherwise.\n-    fn check_panic_supported(&self) -> InterpResult<'tcx> {\n-        match self.eval_context_ref().tcx.sess.target.target.target_os.as_str() {\n-            \"linux\" | \"macos\" => Ok(()),\n-            _ => throw_unsup_format!(\"panicking is not supported on this target\"),\n-        }\n-    }\n-\n     /// Handles the special `miri_start_panic` intrinsic, which is called\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     fn handle_miri_start_panic("}, {"sha": "52d9844bed5113ef3aa4356b8ad2f294e9aad49c", "filename": "src/shims/posix/dlsym.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fdlsym.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -0,0 +1,39 @@\n+use rustc_middle::mir;\n+\n+use crate::*;\n+use shims::posix::linux::dlsym as linux;\n+use shims::posix::macos::dlsym as macos;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Dlsym {\n+    Linux(linux::Dlsym),\n+    MacOs(macos::Dlsym),\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str(name: &str, target_os: &str) -> InterpResult<'static, Option<Dlsym>> {\n+        Ok(match target_os {\n+            \"linux\" => linux::Dlsym::from_str(name)?.map(Dlsym::Linux),\n+            \"macos\" => macos::Dlsym::from_str(name)?.map(Dlsym::MacOs),\n+            _ => unreachable!(),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        args: &[OpTy<'tcx, Tag>],\n+        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        match dlsym {\n+            Dlsym::Linux(dlsym) => linux::EvalContextExt::call_dlsym(this, dlsym, args, ret),\n+            Dlsym::MacOs(dlsym) => macos::EvalContextExt::call_dlsym(this, dlsym, args, ret),\n+        }\n+    }\n+}"}, {"sha": "9be300edf495a74acf9b790123a9c1f669cc10ba", "filename": "src/shims/posix/linux/dlsym.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fdlsym.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -0,0 +1,34 @@\n+use rustc_middle::mir;\n+\n+use crate::*;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Dlsym {\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n+        Ok(match &*name {\n+            \"__pthread_get_minstack\" => None,\n+            _ => throw_unsup_format!(\"unsupported Linux dlsym: {}\", name),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        _args: &[OpTy<'tcx, Tag>],\n+        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (_dest, _ret) = ret.expect(\"we don't support any diverging dlsym\");\n+        assert!(this.tcx.sess.target.target.target_os == \"linux\");\n+\n+        match dlsym {}\n+    }\n+}"}, {"sha": "cadd6a8ea384e0c142dcbb268fd9c8cfff39229c", "filename": "src/shims/posix/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fmod.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1,2 @@\n pub mod foreign_items;\n+pub mod dlsym;"}, {"sha": "8256c10b0d3973ce5b5c38f4ff4542355eab5b3a", "filename": "src/shims/posix/macos/dlsym.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fdlsym.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -0,0 +1,49 @@\n+use rustc_middle::mir;\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[allow(non_camel_case_types)]\n+pub enum Dlsym {\n+    getentropy,\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n+        Ok(match name {\n+            \"getentropy\" => Some(Dlsym::getentropy),\n+            _ => throw_unsup_format!(\"unsupported macOS dlsym: {}\", name),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        args: &[OpTy<'tcx, Tag>],\n+        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n+        assert!(this.tcx.sess.target.target.target_os == \"macos\");\n+\n+        match dlsym {\n+            Dlsym::getentropy => {\n+                let &[ptr, len] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let len = this.read_scalar(len)?.to_machine_usize(this)?;\n+                this.gen_random(ptr, len)?;\n+                this.write_null(dest)?;\n+            }\n+        }\n+\n+        this.dump_place(*dest);\n+        this.go_to_block(ret);\n+        Ok(())\n+    }\n+}"}, {"sha": "cadd6a8ea384e0c142dcbb268fd9c8cfff39229c", "filename": "src/shims/posix/macos/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmacos%2Fmod.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1,2 @@\n pub mod foreign_items;\n+pub mod dlsym;"}, {"sha": "9916c65be0fb852c9c068da148317a632e7126bd", "filename": "src/shims/posix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fmod.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,5 @@\n pub mod foreign_items;\n+pub mod dlsym;\n \n mod fs;\n mod sync;"}, {"sha": "cce0ddc930df0f64bad9235849338273edb88e6f", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,58 +1,11 @@\n use std::convert::TryInto;\n use std::time::{Duration, SystemTime};\n-use std::ops::Not;\n-\n-use rustc_middle::ty::{layout::TyAndLayout, TyKind, TypeAndMut};\n-use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n use stacked_borrows::Tag;\n use thread::Time;\n \n \n-fn assert_ptr_target_min_size<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n-    operand: OpTy<'tcx, Tag>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ()> {\n-    let target_ty = match operand.layout.ty.kind {\n-        TyKind::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty,\n-        _ => panic!(\"Argument to pthread function was not a raw pointer\"),\n-    };\n-    let target_layout = ecx.layout_of(target_ty)?;\n-    assert!(target_layout.size.bytes() >= min_size);\n-    Ok(())\n-}\n-\n-fn get_at_offset<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n-    op: OpTy<'tcx, Tag>,\n-    offset: u64,\n-    layout: TyAndLayout<'tcx>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    // Ensure that the following read at an offset to the attr pointer is within bounds\n-    assert_ptr_target_min_size(ecx, op, min_size)?;\n-    let op_place = ecx.deref_operand(op)?;\n-    let value_place = op_place.offset(Size::from_bytes(offset), MemPlaceMeta::None, layout, ecx)?;\n-    ecx.read_scalar(value_place.into())\n-}\n-\n-fn set_at_offset<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    op: OpTy<'tcx, Tag>,\n-    offset: u64,\n-    value: impl Into<ScalarMaybeUninit<Tag>>,\n-    layout: TyAndLayout<'tcx>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ()> {\n-    // Ensure that the following write at an offset to the attr pointer is within bounds\n-    assert_ptr_target_min_size(ecx, op, min_size)?;\n-    let op_place = ecx.deref_operand(op)?;\n-    let value_place = op_place.offset(Size::from_bytes(offset), MemPlaceMeta::None, layout, ecx)?;\n-    ecx.write_scalar(value.into(), value_place.into())\n-}\n-\n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -66,8 +19,6 @@ fn set_at_offset<'mir, 'tcx: 'mir>(\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n-const PTHREAD_MUTEXATTR_T_MIN_SIZE: u64 = 4;\n-\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     kind: Scalar<Tag>,\n@@ -88,15 +39,15 @@ fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, attr_op, 0, ecx.machine.layouts.i32, PTHREAD_MUTEXATTR_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, attr_op, 0, kind, ecx.machine.layouts.i32, PTHREAD_MUTEXATTR_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(attr_op, 0, kind, ecx.machine.layouts.i32)\n }\n \n // pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n@@ -108,14 +59,12 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n-const PTHREAD_MUTEX_T_MIN_SIZE: u64 = 24;\n-\n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    get_at_offset(ecx, mutex_op, offset, ecx.machine.layouts.i32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(mutex_op, offset, ecx.machine.layouts.i32)\n }\n \n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n@@ -124,22 +73,22 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    set_at_offset(ecx, mutex_op, offset, kind, ecx.machine.layouts.i32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(mutex_op, offset, kind, ecx.machine.layouts.i32)\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, mutex_op, 4, ecx.machine.layouts.u32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(mutex_op, 4, ecx.machine.layouts.u32)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, mutex_op, 4, id, ecx.machine.layouts.u32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(mutex_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -165,21 +114,19 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n // (need to avoid this because it is set by static initializer macros)\n // bytes 4-7: rwlock id as u32 or 0 if id is not assigned yet.\n \n-const PTHREAD_RWLOCK_T_MIN_SIZE: u64 = 32;\n-\n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, rwlock_op, 4, ecx.machine.layouts.u32, PTHREAD_RWLOCK_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(rwlock_op, 4, ecx.machine.layouts.u32)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, rwlock_op, 4, id, ecx.machine.layouts.u32, PTHREAD_RWLOCK_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(rwlock_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -204,21 +151,19 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n // store an i32 in the first four bytes equal to the corresponding libc clock id constant\n // (e.g. CLOCK_REALTIME).\n \n-const PTHREAD_CONDATTR_T_MIN_SIZE: u64 = 4;\n-\n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, attr_op, 0, ecx.machine.layouts.i32, PTHREAD_CONDATTR_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, attr_op, 0, clock_id, ecx.machine.layouts.i32, PTHREAD_CONDATTR_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(attr_op, 0, clock_id, ecx.machine.layouts.i32)\n }\n \n // pthread_cond_t\n@@ -230,21 +175,19 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // bytes 4-7: the conditional variable id as u32 or 0 if id is not assigned yet.\n // bytes 8-11: the clock id constant as i32\n \n-const PTHREAD_COND_T_MIN_SIZE: u64 = 12;\n-\n fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, cond_op, 4, ecx.machine.layouts.u32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(cond_op, 4, ecx.machine.layouts.u32)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, cond_op, 4, id, ecx.machine.layouts.u32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(cond_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -267,15 +210,15 @@ fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, cond_op, 8, ecx.machine.layouts.i32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, cond_op, 8, clock_id, ecx.machine.layouts.i32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(cond_op, 8, clock_id, ecx.machine.layouts.i32)\n }\n \n /// Try to reacquire the mutex associated with the condition variable after we\n@@ -604,27 +547,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_reader_unlock(id, active_thread) {\n-            // The thread was a reader.\n-            if this.rwlock_is_locked(id).not() {\n-                // No more readers owning the lock. Give it to a writer if there\n-                // is any.\n-                this.rwlock_dequeue_and_lock_writer(id);\n-            }\n             Ok(0)\n-        } else if Some(active_thread) == this.rwlock_writer_unlock(id) {\n-            // The thread was a writer.\n-            //\n-            // We are prioritizing writers here against the readers. As a\n-            // result, not only readers can starve writers, but also writers can\n-            // starve readers.\n-            if this.rwlock_dequeue_and_lock_writer(id) {\n-                // Someone got the write lock, nice.\n-            } else {\n-                // Give the lock to all readers.\n-                while this.rwlock_dequeue_and_lock_reader(id) {\n-                    // Rinse and repeat.\n-                }\n-            }\n+        } else if this.rwlock_writer_unlock(id, active_thread) {\n             Ok(0)\n         } else {\n             throw_ub_format!(\"unlocked an rwlock that was not locked by the active thread\");"}, {"sha": "0cd9ef0565058d6bd34cbbc45d9507511ce01aaf", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -230,7 +230,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();\n-        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n+        assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n         // Windows has a special magic linker section that is run on certain events.\n         // Instead of searching for that section and supporting arbitrary hooks in there\n         // (that would be basically https://github.com/rust-lang/miri/issues/450),"}, {"sha": "737fd4314f632cc33e360b392d90112ec9a6a5d0", "filename": "src/shims/windows/dlsym.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -0,0 +1,80 @@\n+use rustc_middle::mir;\n+\n+use crate::*;\n+use helpers::check_arg_count;\n+use shims::windows::sync::EvalContextExt as _;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Dlsym {\n+    AcquireSRWLockExclusive,\n+    ReleaseSRWLockExclusive,\n+    TryAcquireSRWLockExclusive,\n+    AcquireSRWLockShared,\n+    ReleaseSRWLockShared,\n+    TryAcquireSRWLockShared,\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n+        Ok(match name {\n+            \"AcquireSRWLockExclusive\" => Some(Dlsym::AcquireSRWLockExclusive),\n+            \"ReleaseSRWLockExclusive\" => Some(Dlsym::ReleaseSRWLockExclusive),\n+            \"TryAcquireSRWLockExclusive\" => Some(Dlsym::TryAcquireSRWLockExclusive),\n+            \"AcquireSRWLockShared\" => Some(Dlsym::AcquireSRWLockShared),\n+            \"ReleaseSRWLockShared\" => Some(Dlsym::ReleaseSRWLockShared),\n+            \"TryAcquireSRWLockShared\" => Some(Dlsym::TryAcquireSRWLockShared),\n+            \"SetThreadStackGuarantee\" => None,\n+            \"GetSystemTimePreciseAsFileTime\" => None,\n+            _ => throw_unsup_format!(\"unsupported Windows dlsym: {}\", name),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        args: &[OpTy<'tcx, Tag>],\n+        ret: Option<(PlaceTy<'tcx, Tag>, mir::BasicBlock)>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (dest, ret) = ret.expect(\"we don't support any diverging dlsym\");\n+        assert!(this.tcx.sess.target.target.target_os == \"windows\");\n+\n+        match dlsym {\n+            Dlsym::AcquireSRWLockExclusive => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.AcquireSRWLockExclusive(ptr)?;\n+            }\n+            Dlsym::ReleaseSRWLockExclusive => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.ReleaseSRWLockExclusive(ptr)?;\n+            }\n+            Dlsym::TryAcquireSRWLockExclusive => {\n+                let &[ptr] = check_arg_count(args)?;\n+                let ret = this.TryAcquireSRWLockExclusive(ptr)?;\n+                this.write_scalar(Scalar::from_u8(ret), dest)?;\n+            }\n+            Dlsym::AcquireSRWLockShared => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.AcquireSRWLockShared(ptr)?;\n+            }\n+            Dlsym::ReleaseSRWLockShared => {\n+                let &[ptr] = check_arg_count(args)?;\n+                this.ReleaseSRWLockShared(ptr)?;\n+            }\n+            Dlsym::TryAcquireSRWLockShared => {\n+                let &[ptr] = check_arg_count(args)?;\n+                let ret = this.TryAcquireSRWLockShared(ptr)?;\n+                this.write_scalar(Scalar::from_u8(ret), dest)?;\n+            }\n+        }\n+\n+        this.dump_place(*dest);\n+        this.go_to_block(ret);\n+        Ok(())\n+    }\n+}"}, {"sha": "e8937bbb3085558915e8a178b54569e634475811", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -21,6 +21,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // HANDLE = isize\n         // DWORD = ULONG = u32\n         // BOOL = i32\n+        // BOOLEAN = u8\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n@@ -256,7 +257,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Better error for attempts to create a thread\n             \"CreateThread\" => {\n-                throw_unsup_format!(\"Miri does not support threading\");\n+                throw_unsup_format!(\"Miri does not support concurrency on Windows\");\n             }\n \n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n@@ -291,7 +292,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n@@ -300,8 +301,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n                 #[allow(non_snake_case)]\n                 let &[_lpCriticalSection] = check_arg_count(args)?;\n-                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows not supported\");\n-                // There is only one thread, so this always succeeds and returns TRUE\n+                assert_eq!(this.get_total_thread_count(), 1, \"concurrency on Windows is not supported\");\n+                // There is only one thread, so this always succeeds and returns TRUE.\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n "}, {"sha": "04f9ace8e799b92ec4cce160ca007eb8f4c36c81", "filename": "src/shims/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fmod.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1,4 @@\n pub mod foreign_items;\n+pub mod dlsym;\n+\n+mod sync;"}, {"sha": "7bad3c08a598f499c62478cf30c964b253f0cc21", "filename": "src/shims/windows/sync.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -0,0 +1,135 @@\n+use crate::*;\n+\n+// Locks are pointer-sized pieces of data, initialized to 0.\n+// We use the first 4 bytes to store the RwLockId.\n+\n+fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    lock_op: OpTy<'tcx, Tag>,\n+) -> InterpResult<'tcx, RwLockId> {\n+    let id = ecx.read_scalar_at_offset(lock_op, 0, ecx.machine.layouts.u32)?.to_u32()?;\n+    if id == 0 {\n+        // 0 is a default value and also not a valid rwlock id. Need to allocate\n+        // a new rwlock.\n+        let id = ecx.rwlock_create();\n+        ecx.write_scalar_at_offset(lock_op, 0, id.to_u32_scalar(), ecx.machine.layouts.u32)?;\n+        Ok(id)\n+    } else {\n+        Ok(RwLockId::from_u32(id))\n+    }\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    #[allow(non_snake_case)]\n+    fn AcquireSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if this.rwlock_is_locked(id) {\n+            // Note: this will deadlock if the lock is already locked by this\n+            // thread in any way.\n+            //\n+            // FIXME: Detect and report the deadlock proactively. (We currently\n+            // report the deadlock only when no thread can continue execution,\n+            // but we could detect that this lock is already locked and report\n+            // an error.)\n+            this.rwlock_enqueue_and_block_writer(id, active_thread);\n+        } else {\n+            this.rwlock_writer_lock(id, active_thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn TryAcquireSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, u8> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if this.rwlock_is_locked(id) {\n+            // Lock is already held.\n+            Ok(0)\n+        } else {\n+            this.rwlock_writer_lock(id, active_thread);\n+            Ok(1)\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn ReleaseSRWLockExclusive(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if !this.rwlock_writer_unlock(id, active_thread) {\n+            // The docs do not say anything about this case, but it seems better to not allow it.\n+            throw_ub_format!(\"calling ReleaseSRWLockExclusive on an SRWLock that is not exclusively locked by the current thread\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn AcquireSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if this.rwlock_is_write_locked(id) {\n+            this.rwlock_enqueue_and_block_reader(id, active_thread);\n+        } else {\n+            this.rwlock_reader_lock(id, active_thread);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn TryAcquireSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, u8> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if this.rwlock_is_write_locked(id) {\n+            Ok(0)\n+        } else {\n+            this.rwlock_reader_lock(id, active_thread);\n+            Ok(1)\n+        }\n+    }\n+\n+    #[allow(non_snake_case)]\n+    fn ReleaseSRWLockShared(\n+        &mut self,\n+        lock_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let id = srwlock_get_or_create_id(this, lock_op)?;\n+        let active_thread = this.get_active_thread();\n+\n+        if !this.rwlock_reader_unlock(id, active_thread) {\n+            // The docs do not say anything about this case, but it seems better to not allow it.\n+            throw_ub_format!(\"calling ReleaseSRWLockShared on an SRWLock that is not locked by the current thread\");\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "7e3c27b386dfe0ba694c07154f2b6f2aef010373", "filename": "src/sync.rs", "status": "modified", "additions": 105, "deletions": 60, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -3,6 +3,8 @@ use std::convert::TryFrom;\n use std::num::NonZeroU32;\n use std::ops::Not;\n \n+use log::trace;\n+\n use rustc_index::vec::{Idx, IndexVec};\n \n use crate::*;\n@@ -102,6 +104,52 @@ pub(super) struct SynchronizationState {\n     condvars: IndexVec<CondvarId, Condvar>,\n }\n \n+// Private extension trait for local helper methods\n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Take a reader out of the queue waiting for the lock.\n+    /// Returns `true` if some thread got the rwlock.\n+    #[inline]\n+    fn rwlock_dequeue_and_lock_reader(&mut self, id: RwLockId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n+            this.unblock_thread(reader);\n+            this.rwlock_reader_lock(id, reader);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Take the writer out of the queue waiting for the lock.\n+    /// Returns `true` if some thread got the rwlock.\n+    #[inline]\n+    fn rwlock_dequeue_and_lock_writer(&mut self, id: RwLockId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n+            this.unblock_thread(writer);\n+            this.rwlock_writer_lock(id, writer);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Take a thread out of the queue waiting for the mutex, and lock\n+    /// the mutex for it. Returns `true` if some thread has the mutex now.\n+    #[inline]\n+    fn mutex_dequeue_and_lock(&mut self, id: MutexId) -> bool {\n+        let this = self.eval_context_mut();\n+        if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n+            this.unblock_thread(thread);\n+            this.mutex_lock(id, thread);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n // Public interface to synchronization primitives. Please note that in most\n // cases, the function calls are infallible and it is the client's (shim\n // implementation's) responsibility to detect and deal with erroneous\n@@ -124,8 +172,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Check if locked.\n-    fn mutex_is_locked(&mut self, id: MutexId) -> bool {\n-        let this = self.eval_context_mut();\n+    fn mutex_is_locked(&self, id: MutexId) -> bool {\n+        let this = self.eval_context_ref();\n         this.machine.threads.sync.mutexes[id].owner.is_some()\n     }\n \n@@ -174,7 +222,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             Some(old_lock_count)\n         } else {\n-            // Mutex is unlocked.\n+            // Mutex is not locked.\n             None\n         }\n     }\n@@ -188,20 +236,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.block_thread(thread);\n     }\n \n-    #[inline]\n-    /// Take a thread out of the queue waiting for the mutex, and lock\n-    /// the mutex for it. Returns `true` if some thread has the mutex now.\n-    fn mutex_dequeue_and_lock(&mut self, id: MutexId) -> bool {\n-        let this = self.eval_context_mut();\n-        if let Some(thread) = this.machine.threads.sync.mutexes[id].queue.pop_front() {\n-            this.unblock_thread(thread);\n-            this.mutex_lock(id, thread);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     #[inline]\n     /// Create state for a new read write lock.\n     fn rwlock_create(&mut self) -> RwLockId {\n@@ -211,30 +245,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     #[inline]\n     /// Check if locked.\n-    fn rwlock_is_locked(&mut self, id: RwLockId) -> bool {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].writer.is_some()\n-            || this.machine.threads.sync.rwlocks[id].readers.is_empty().not()\n+    fn rwlock_is_locked(&self, id: RwLockId) -> bool {\n+        let this = self.eval_context_ref();\n+        let rwlock = &this.machine.threads.sync.rwlocks[id];\n+        trace!(\n+            \"rwlock_is_locked: {:?} writer is {:?} and there are {} reader threads (some of which could hold multiple read locks)\",\n+            id, rwlock.writer, rwlock.readers.len(),\n+        );\n+        rwlock.writer.is_some()|| rwlock.readers.is_empty().not()\n     }\n \n     #[inline]\n     /// Check if write locked.\n-    fn rwlock_is_write_locked(&mut self, id: RwLockId) -> bool {\n-        let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].writer.is_some()\n+    fn rwlock_is_write_locked(&self, id: RwLockId) -> bool {\n+        let this = self.eval_context_ref();\n+        let rwlock = &this.machine.threads.sync.rwlocks[id];\n+        trace!(\"rwlock_is_write_locked: {:?} writer is {:?}\", id, rwlock.writer);\n+        rwlock.writer.is_some()\n     }\n \n     /// Read-lock the lock by adding the `reader` the list of threads that own\n     /// this lock.\n     fn rwlock_reader_lock(&mut self, id: RwLockId, reader: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_write_locked(id), \"the lock is write locked\");\n+        trace!(\"rwlock_reader_lock: {:?} now also held (one more time) by {:?}\", id, reader);\n         let count = this.machine.threads.sync.rwlocks[id].readers.entry(reader).or_insert(0);\n         *count = count.checked_add(1).expect(\"the reader counter overflowed\");\n     }\n \n-    /// Try read-unlock the lock for `reader`. Returns `true` if succeeded,\n-    /// `false` if this `reader` did not hold the lock.\n+    /// Try read-unlock the lock for `reader` and potentially give the lock to a new owner.\n+    /// Returns `true` if succeeded, `false` if this `reader` did not hold the lock.\n     fn rwlock_reader_unlock(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n         match this.machine.threads.sync.rwlocks[id].readers.entry(reader) {\n@@ -243,12 +284,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 assert!(*count > 0, \"rwlock locked with count == 0\");\n                 *count -= 1;\n                 if *count == 0 {\n+                    trace!(\"rwlock_reader_unlock: {:?} no longer held by {:?}\", id, reader);\n                     entry.remove();\n+                } else {\n+                    trace!(\"rwlock_reader_unlock: {:?} held one less time by {:?}\", id, reader);\n                 }\n-                true\n             }\n-            Entry::Vacant(_) => false,\n+            Entry::Vacant(_) => return false, // we did not even own this lock\n+        }\n+        // The thread was a reader. If the lock is not held any more, give it to a writer.\n+        if this.rwlock_is_locked(id).not() {\n+            this.rwlock_dequeue_and_lock_writer(id);\n         }\n+        true\n     }\n \n     #[inline]\n@@ -259,38 +307,49 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         reader: ThreadId,\n     ) {\n         let this = self.eval_context_mut();\n-        assert!(this.rwlock_is_write_locked(id), \"queueing on not write locked lock\");\n+        assert!(this.rwlock_is_write_locked(id), \"read-queueing on not write locked rwlock\");\n         this.machine.threads.sync.rwlocks[id].reader_queue.push_back(reader);\n         this.block_thread(reader);\n     }\n \n-    #[inline]\n-    /// Take a reader out the queue waiting for the lock.\n-    /// Returns `true` if some thread got the rwlock.\n-    fn rwlock_dequeue_and_lock_reader(&mut self, id: RwLockId) -> bool {\n-        let this = self.eval_context_mut();\n-        if let Some(reader) = this.machine.threads.sync.rwlocks[id].reader_queue.pop_front() {\n-            this.unblock_thread(reader);\n-            this.rwlock_reader_lock(id, reader);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     #[inline]\n     /// Lock by setting the writer that owns the lock.\n     fn rwlock_writer_lock(&mut self, id: RwLockId, writer: ThreadId) {\n         let this = self.eval_context_mut();\n         assert!(!this.rwlock_is_locked(id), \"the rwlock is already locked\");\n+        trace!(\"rwlock_writer_lock: {:?} now held by {:?}\", id, writer);\n         this.machine.threads.sync.rwlocks[id].writer = Some(writer);\n     }\n \n     #[inline]\n     /// Try to unlock by removing the writer.\n-    fn rwlock_writer_unlock(&mut self, id: RwLockId) -> Option<ThreadId> {\n+    fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n-        this.machine.threads.sync.rwlocks[id].writer.take()\n+        let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n+        if let Some(current_writer) = rwlock.writer {\n+            if current_writer != expected_writer {\n+                // Only the owner can unlock the rwlock.\n+                return false;\n+            }\n+            rwlock.writer = None;\n+            trace!(\"rwlock_writer_unlock: {:?} unlocked by {:?}\", id, expected_writer);\n+            // The thread was a writer.\n+            //\n+            // We are prioritizing writers here against the readers. As a\n+            // result, not only readers can starve writers, but also writers can\n+            // starve readers.\n+            if this.rwlock_dequeue_and_lock_writer(id) {\n+                // Someone got the write lock, nice.\n+            } else {\n+                // Give the lock to all readers.\n+                while this.rwlock_dequeue_and_lock_reader(id) {\n+                    // Rinse and repeat.\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     #[inline]\n@@ -301,25 +360,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         writer: ThreadId,\n     ) {\n         let this = self.eval_context_mut();\n-        assert!(this.rwlock_is_locked(id), \"queueing on unlocked lock\");\n+        assert!(this.rwlock_is_locked(id), \"write-queueing on unlocked rwlock\");\n         this.machine.threads.sync.rwlocks[id].writer_queue.push_back(writer);\n         this.block_thread(writer);\n     }\n \n-    #[inline]\n-    /// Take the writer out the queue waiting for the lock.\n-    /// Returns `true` if some thread got the rwlock.\n-    fn rwlock_dequeue_and_lock_writer(&mut self, id: RwLockId) -> bool {\n-        let this = self.eval_context_mut();\n-        if let Some(writer) = this.machine.threads.sync.rwlocks[id].writer_queue.pop_front() {\n-            this.unblock_thread(writer);\n-            this.rwlock_writer_lock(id, writer);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n     #[inline]\n     /// Create state for a new conditional variable.\n     fn condvar_create(&mut self) -> CondvarId {"}, {"sha": "1bfa289a52b4e1bc13944c5161baaf8b13b6d5e8", "filename": "tests/compile-fail/abort-terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fabort-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fabort-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fabort-terminator.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,5 +1,4 @@\n // error-pattern: the evaluated program aborted\n-// ignore-windows (panics dont work on Windows)\n #![feature(unwind_attributes)]\n \n #[unwind(aborts)]"}, {"sha": "27760eed8dba9b05965601d01a71dcf87b86084b", "filename": "tests/compile-fail/concurrency/thread-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fconcurrency%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fconcurrency%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fconcurrency%2Fthread-spawn.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -3,7 +3,7 @@\n \n use std::thread;\n \n-// error-pattern: Miri does not support threading\n+// error-pattern: Miri does not support concurrency on Windows\n \n fn main() {\n     thread::spawn(|| {});"}, {"sha": "80d74f026232e44c09ea3a65640ce04e9422443e", "filename": "tests/compile-fail/panic/double_panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fpanic%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Fcompile-fail%2Fpanic%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fdouble_panic.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,5 +1,4 @@\n // error-pattern: the evaluated program aborted\n-// ignore-windows (panics dont work on Windows)\n \n struct Foo;\n impl Drop for Foo {"}, {"sha": "142ba85c42c77d2c88a9f6366f8a820a2bf92efe", "filename": "tests/compile-fail/panic/windows1.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fwindows1.rs?ref=bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d", "patch": "@@ -1,9 +0,0 @@\n-// ignore-linux\n-// ignore-macos\n-\n-// Test that panics on Windows give a reasonable error message.\n-\n-// error-pattern: panicking is not supported on this target\n-fn main() {\n-    core::panic!(\"this is {}\", \"Windows\");\n-}"}, {"sha": "da2cfb59362ef2fe1ca8174d3913e19412fca990", "filename": "tests/compile-fail/panic/windows2.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fwindows2.rs?ref=bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d", "patch": "@@ -1,9 +0,0 @@\n-// ignore-linux\n-// ignore-macos\n-\n-// Test that panics on Windows give a reasonable error message.\n-\n-// error-pattern: panicking is not supported on this target\n-fn main() {\n-    std::panic!(\"this is Windows\");\n-}"}, {"sha": "a2e7bf5a7d438ab69b86c0cdb85101fec7bdb795", "filename": "tests/compile-fail/panic/windows3.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d/tests%2Fcompile-fail%2Fpanic%2Fwindows3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fwindows3.rs?ref=bde2eb4a442ec5c02703cbaa2807a6e2f59ec70d", "patch": "@@ -1,10 +0,0 @@\n-// ignore-linux\n-// ignore-macos\n-\n-// Test that panics on Windows give a reasonable error message.\n-\n-// error-pattern: panicking is not supported on this target\n-#[allow(unconditional_panic)]\n-fn main() {\n-    let _val = 1/0;\n-}"}, {"sha": "749db855e296f13f10ebf8c1b7b7dbbe86ab0cb6", "filename": "tests/run-pass/concurrency/sync_singlethread.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fconcurrency%2Fsync_singlethread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fconcurrency%2Fsync_singlethread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fsync_singlethread.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -6,10 +6,7 @@ use std::hint;\n \n fn main() {\n     test_mutex_stdlib();\n-    #[cfg(not(target_os = \"windows\"))] // TODO: implement RwLock on Windows\n-    {\n-        test_rwlock_stdlib();\n-    }\n+    test_rwlock_stdlib();\n     test_spin_loop_hint();\n     test_thread_yield_now();\n }\n@@ -24,7 +21,6 @@ fn test_mutex_stdlib() {\n     drop(m);\n }\n \n-#[cfg(not(target_os = \"windows\"))]\n fn test_rwlock_stdlib() {\n     use std::sync::RwLock;\n     let rw = RwLock::new(0);"}, {"sha": "ac41de586e8a7adb08ccce1a57ffa9908204e3eb", "filename": "tests/run-pass/panic/catch_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fcatch_panic.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,7 +1,7 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n // normalize-stderr-test \"[^ ]*libcore/[a-z/]+.rs[0-9:]*\" -> \"$$LOC\"\n #![feature(never_type)]\n #![allow(unconditional_panic)]\n+\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::cell::Cell;\n "}, {"sha": "fac5415696fc675e9f9ddfb5241daf954957b6de", "filename": "tests/run-pass/panic/div-by-zero-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n #![allow(unconditional_panic)]\n \n fn main() {"}, {"sha": "d255811be2a94dd04ba9d1d6b4445088d80844bb", "filename": "tests/run-pass/panic/div-by-zero-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fdiv-by-zero-2.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'attempt to divide by zero', $DIR/div-by-zero-2.rs:5:14\n+thread 'main' panicked at 'attempt to divide by zero', $DIR/div-by-zero-2.rs:4:14"}, {"sha": "bf5eed1c550f1b1b4f81491454e2825a5e8e6f28", "filename": "tests/run-pass/panic/overflowing-lsh-neg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n #![allow(arithmetic_overflow)]\n \n fn main() {"}, {"sha": "04d98a0a2f155b767dc541b6081b6cc9564ccddc", "filename": "tests/run-pass/panic/overflowing-lsh-neg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-lsh-neg.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'attempt to shift left with overflow', $DIR/overflowing-lsh-neg.rs:5:14\n+thread 'main' panicked at 'attempt to shift left with overflow', $DIR/overflowing-lsh-neg.rs:4:14"}, {"sha": "4c0106f0fb1fd3bd7b9aa8d375f6f88c35ddbdbd", "filename": "tests/run-pass/panic/overflowing-rsh-1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n #![allow(arithmetic_overflow)]\n \n fn main() {"}, {"sha": "a9a72f46222df4d2fdebd036f2ac59d6a5c62296", "filename": "tests/run-pass/panic/overflowing-rsh-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-1.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'attempt to shift right with overflow', $DIR/overflowing-rsh-1.rs:5:14\n+thread 'main' panicked at 'attempt to shift right with overflow', $DIR/overflowing-rsh-1.rs:4:14"}, {"sha": "19d16e7bc84a2e3117977e7ec0b4bd03f894fa6a", "filename": "tests/run-pass/panic/overflowing-rsh-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n #![allow(arithmetic_overflow)]\n \n fn main() {"}, {"sha": "24b61194565dd1230806f29167cf44856581a95a", "filename": "tests/run-pass/panic/overflowing-rsh-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Foverflowing-rsh-2.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'attempt to shift right with overflow', $DIR/overflowing-rsh-2.rs:6:14\n+thread 'main' panicked at 'attempt to shift right with overflow', $DIR/overflowing-rsh-2.rs:5:14"}, {"sha": "9d9ad28df5a710bfc205cb68a8b8024fa33dd277", "filename": "tests/run-pass/panic/panic1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic1.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n fn main() {\n     std::panic!(\"panicking from libstd\");\n }"}, {"sha": "954b8799a082351c51f7f18e76dd35be0c2ef790", "filename": "tests/run-pass/panic/panic1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic1.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'panicking from libstd', $DIR/panic1.rs:3:5\n+thread 'main' panicked at 'panicking from libstd', $DIR/panic1.rs:2:5"}, {"sha": "d90e3f2e0ac132433efac639f03569322869c305", "filename": "tests/run-pass/panic/panic2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic2.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n fn main() {\n     std::panic!(\"{}-panicking from libstd\", 42);\n }"}, {"sha": "e90e3502cbfbf99515811e3fef3eae2843d2b338", "filename": "tests/run-pass/panic/panic2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic2.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at '42-panicking from libstd', $DIR/panic2.rs:3:5\n+thread 'main' panicked at '42-panicking from libstd', $DIR/panic2.rs:2:5"}, {"sha": "418ee4f8411eb9472274a162b0ce0d8c43e6e273", "filename": "tests/run-pass/panic/panic3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic3.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n fn main() {\n     core::panic!(\"panicking from libcore\");\n }"}, {"sha": "0a3c191b282ec22c60fd72517033c15d78395d0d", "filename": "tests/run-pass/panic/panic3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic3.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'panicking from libcore', $DIR/panic3.rs:3:5\n+thread 'main' panicked at 'panicking from libcore', $DIR/panic3.rs:2:5"}, {"sha": "0fcc53813b5d79dcb47edfc8a6ba51f1000b8732", "filename": "tests/run-pass/panic/panic4.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic4.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n fn main() {\n     core::panic!(\"{}-panicking from libcore\", 42);\n }"}, {"sha": "946059b1e49fc5adb3b3ba8fbab626e8587ee49a", "filename": "tests/run-pass/panic/panic4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fpanic4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fpanic4.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at '42-panicking from libcore', $DIR/panic4.rs:3:5\n+thread 'main' panicked at '42-panicking from libcore', $DIR/panic4.rs:2:5"}, {"sha": "ac2e8d5305dfef2c0935275988373dd18d1de8ac", "filename": "tests/run-pass/panic/std-panic-locations.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fstd-panic-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Fpanic%2Fstd-panic-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic%2Fstd-panic-locations.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n #![feature(option_expect_none, option_unwrap_none)]\n //! Test that panic locations for `#[track_caller]` functions in std have the correct\n //! location reported."}, {"sha": "3dff2cc1e0c9300d3b013af52375f0425758ffd6", "filename": "tests/run-pass/transmute_fat2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Ftransmute_fat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Ftransmute_fat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat2.rs?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1,4 +1,3 @@\n-// ignore-windows: Unwind panicking does not currently work on Windows\n fn main() {\n     #[cfg(target_pointer_width=\"64\")]\n     let bad = unsafe {"}, {"sha": "08849a5b517a4e9e3a9fa6dd90e9879f4dedfdbe", "filename": "tests/run-pass/transmute_fat2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Ftransmute_fat2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2dfa6c1a46641bc6803fad0eaf27adfb75c14a26/tests%2Frun-pass%2Ftransmute_fat2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat2.stderr?ref=2dfa6c1a46641bc6803fad0eaf27adfb75c14a26", "patch": "@@ -1 +1 @@\n-thread 'main' panicked at 'index out of bounds: the len is 0 but the index is 0', $DIR/transmute_fat2.rs:12:5\n+thread 'main' panicked at 'index out of bounds: the len is 0 but the index is 0', $DIR/transmute_fat2.rs:11:5"}]}