{"sha": "1f46f771a6b579c1330976c1638ccc4a03e8863f", "node_id": "C_kwDOAAsO6NoAKDFmNDZmNzcxYTZiNTc5YzEzMzA5NzZjMTYzOGNjYzRhMDNlODg2M2Y", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-17T15:23:28Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-03-28T17:00:29Z"}, "message": "Remove some special code handling TAIT being passed through if and match\n\nThis is not necessary for RPIT anymore, since we reverted that to using inference vars.", "tree": {"sha": "a54fc28fe4ae7cb77086229aa99f69216de5aae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a54fc28fe4ae7cb77086229aa99f69216de5aae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f46f771a6b579c1330976c1638ccc4a03e8863f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f46f771a6b579c1330976c1638ccc4a03e8863f", "html_url": "https://github.com/rust-lang/rust/commit/1f46f771a6b579c1330976c1638ccc4a03e8863f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f46f771a6b579c1330976c1638ccc4a03e8863f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02536fe18b78c0bbda2543617d75a4873e1016dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/02536fe18b78c0bbda2543617d75a4873e1016dd", "html_url": "https://github.com/rust-lang/rust/commit/02536fe18b78c0bbda2543617d75a4873e1016dd"}], "stats": {"total": 95, "additions": 68, "deletions": 27}, "files": [{"sha": "e9e810344776b963d52a0eeb85fbd6ecbcc8c376", "filename": "compiler/rustc_typeck/src/check/expectation.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpectation.rs?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -1,6 +1,5 @@\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_span::{self, Span};\n \n use super::Expectation::*;\n@@ -44,7 +43,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n     pub(super) fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n-        match self.strip_opaque(fcx) {\n+        match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() { ExpectHasType(ety) } else { NoExpectation }\n@@ -105,35 +104,14 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// for the program to type-check). `only_has_type` will return\n     /// such a constraint, if it exists.\n     pub(super) fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n-        match self.strip_opaque(fcx) {\n-            ExpectHasType(ty) => Some(ty),\n+        match self {\n+            ExpectHasType(ty) => Some(fcx.resolve_vars_if_possible(ty)),\n             NoExpectation | ExpectCastableToType(_) | ExpectRvalueLikeUnsized(_) | IsLast(_) => {\n                 None\n             }\n         }\n     }\n \n-    /// We must not treat opaque types as expected types in their defining scope, as that\n-    /// will break `fn foo() -> impl Trait { if cond { a } else { b } }` if `a` and `b` are\n-    /// only \"equal\" if they coerce to a common target, like two different function items\n-    /// coercing to a function pointer if they have the same signature.\n-    fn strip_opaque(self, fcx: &FnCtxt<'a, 'tcx>) -> Self {\n-        match self {\n-            ExpectHasType(ty) => {\n-                let ty = fcx.resolve_vars_if_possible(ty);\n-                match *ty.kind() {\n-                    ty::Opaque(def_id, _)\n-                        if fcx.infcx.opaque_type_origin(def_id, DUMMY_SP).is_some() =>\n-                    {\n-                        NoExpectation\n-                    }\n-                    _ => self,\n-                }\n-            }\n-            _ => self,\n-        }\n-    }\n-\n     /// Like `only_has_type`, but instead of returning `None` if no\n     /// hard constraint exists, creates a fresh type variable.\n     pub(super) fn coercion_target_type(self, fcx: &FnCtxt<'a, 'tcx>, span: Span) -> Ty<'tcx> {"}, {"sha": "aa172f3f19b6b3288fce71f4da4880beb528011d", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.rs?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -0,0 +1,14 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo = impl std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+        //~^ ERROR `Foo` cannot be built from an iterator over elements of type `_`\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c3902f34706bd3bf01a7de6d56aaad36044ad043", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches.stderr?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: a value of type `Foo` cannot be built from an iterator over elements of type `_`\n+  --> $DIR/branches.rs:9:28\n+   |\n+LL |         std::iter::empty().collect()\n+   |                            ^^^^^^^ value of type `Foo` cannot be built from `std::iter::Iterator<Item=_>`\n+   |\n+   = help: the trait `FromIterator<_>` is not implemented for `Foo`\n+note: required by a bound in `collect`\n+  --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn collect<B: FromIterator<Self::Item>>(self) -> B\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `collect`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "af605e4d8062dbb7fc809962fee0a2cd5943018a", "filename": "src/test/ui/lazy-type-alias-impl-trait/branches2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flazy-type-alias-impl-trait%2Fbranches2.rs?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -0,0 +1,28 @@\n+#![feature(type_alias_impl_trait)]\n+\n+// run-pass\n+\n+type Foo = impl std::iter::FromIterator<i32> + PartialEq<Vec<i32>> + std::fmt::Debug;\n+\n+fn foo(b: bool) -> Foo {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+    }\n+}\n+\n+fn bar(b: bool) -> impl PartialEq<Vec<i32>> + std::fmt::Debug {\n+    if b {\n+        vec![42_i32]\n+    } else {\n+        std::iter::empty().collect()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(foo(true), vec![42]);\n+    assert_eq!(foo(false), vec![]);\n+    assert_eq!(bar(true), vec![42]);\n+    assert_eq!(bar(false), vec![]);\n+}"}, {"sha": "bcc9c57f91ce6c5a0ed8840bad320afdde2ba763", "filename": "src/test/ui/type-alias-impl-trait/issue-63279.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63279.stderr?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -21,7 +21,9 @@ error[E0308]: mismatched types\n    |\n LL | type Closure = impl FnOnce();\n    |                ------------- the expected opaque type\n-...\n+LL | \n+LL | fn c() -> Closure {\n+   |           ------- expected `Closure` because of return type\n LL |     || -> Closure { || () }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found closure\n    |"}, {"sha": "7a22b360a31d0b1f160ec93e34ec5aa254918725", "filename": "src/test/ui/type-alias-impl-trait/issue-74280.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1f46f771a6b579c1330976c1638ccc4a03e8863f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-74280.stderr?ref=1f46f771a6b579c1330976c1638ccc4a03e8863f", "patch": "@@ -3,7 +3,10 @@ error[E0308]: mismatched types\n    |\n LL | type Test = impl Copy;\n    |             --------- the expected opaque type\n-...\n+LL | \n+LL | fn test() -> Test {\n+   |              ---- expected `Test` because of return type\n+LL |     let y = || -> Test { () };\n LL |     7\n    |     ^ expected `()`, found integer\n    |"}]}