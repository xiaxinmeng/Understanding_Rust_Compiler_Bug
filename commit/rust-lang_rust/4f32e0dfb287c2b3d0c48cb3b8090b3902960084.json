{"sha": "4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMzJlMGRmYjI4N2MyYjNkMGM0OGNiM2I4MDkwYjM5MDI5NjAwODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-14T02:02:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-14T02:02:13Z"}, "message": "Auto merge of #41294 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 4 pull requests\n\n- Successful merges: #41279, #41281, #41287, #41292\n- Failed merges:", "tree": {"sha": "ed7f957c40617780eb7606fc90319da67485918d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed7f957c40617780eb7606fc90319da67485918d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "html_url": "https://github.com/rust-lang/rust/commit/4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a74299778cdad4ea999e4ee8f8c1ef793338bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a74299778cdad4ea999e4ee8f8c1ef793338bd", "html_url": "https://github.com/rust-lang/rust/commit/28a74299778cdad4ea999e4ee8f8c1ef793338bd"}, {"sha": "c04ae0f0cfcdc01180afa447585016d52e2667a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c04ae0f0cfcdc01180afa447585016d52e2667a9", "html_url": "https://github.com/rust-lang/rust/commit/c04ae0f0cfcdc01180afa447585016d52e2667a9"}], "stats": {"total": 735, "additions": 334, "deletions": 401}, "files": [{"sha": "beea82b9230cd641dd1ca263cf31025ace4aebb5", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -1 +1 @@\n-Subproject commit a2c56870d4dc589237102cc5e0fe7b9ebd0d14a1\n+Subproject commit beea82b9230cd641dd1ca263cf31025ace4aebb5"}, {"sha": "b060f732145f2fa16df84c74e511df08a3a47c5d", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -1 +1 @@\n-Subproject commit acedc32cacae80cf2f4925753a4ce7f7ffd7c86a\n+Subproject commit b060f732145f2fa16df84c74e511df08a3a47c5d"}, {"sha": "9a42b82beff67ef674e45aab0779d3cd40e8ac3e", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -103,12 +103,14 @@ impl Gamma {\n         assert!(shape > 0.0, \"Gamma::new called with shape <= 0\");\n         assert!(scale > 0.0, \"Gamma::new called with scale <= 0\");\n \n-        let repr = match shape {\n-            1.0 => One(Exp::new(1.0 / scale)),\n-            0.0...1.0 => Small(GammaSmallShape::new_raw(shape, scale)),\n-            _ => Large(GammaLargeShape::new_raw(shape, scale)),\n+        let repr = if shape == 1.0 {\n+            One(Exp::new(1.0 / scale))\n+        } else if 0.0 <= shape && shape < 1.0 {\n+            Small(GammaSmallShape::new_raw(shape, scale))\n+        } else {\n+            Large(GammaLargeShape::new_raw(shape, scale))\n         };\n-        Gamma { repr: repr }\n+        Gamma { repr }\n     }\n }\n "}, {"sha": "cbbfeacadb4087a2e8912bb415986d57435ec605", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -53,7 +53,6 @@ pub use self::NativeLibraryKind::*;\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n-    pub crate_name: Symbol,\n     pub crate_hash: Svh,\n }\n "}, {"sha": "adc9aabb8c77a1abf24a93f9807e890cb9d1b020", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -13,7 +13,6 @@ pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n \n use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n-use hir::svh::Svh;\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -402,15 +401,14 @@ impl Session {\n \n     /// Returns the symbol name for the registrar function,\n     /// given the crate Svh and the function DefIndex.\n-    pub fn generate_plugin_registrar_symbol(&self, svh: &Svh, index: DefIndex)\n+    pub fn generate_plugin_registrar_symbol(&self, disambiguator: Symbol, index: DefIndex)\n                                             -> String {\n-        format!(\"__rustc_plugin_registrar__{}_{}\", svh, index.as_usize())\n+        format!(\"__rustc_plugin_registrar__{}_{}\", disambiguator, index.as_usize())\n     }\n \n-    pub fn generate_derive_registrar_symbol(&self,\n-                                            svh: &Svh,\n-                                            index: DefIndex) -> String {\n-        format!(\"__rustc_derive_registrar__{}_{}\", svh, index.as_usize())\n+    pub fn generate_derive_registrar_symbol(&self, disambiguator: Symbol, index: DefIndex)\n+                                            -> String {\n+        format!(\"__rustc_derive_registrar__{}_{}\", disambiguator, index.as_usize())\n     }\n \n     pub fn sysroot<'a>(&'a self) -> &'a Path {"}, {"sha": "1d7100a7a4e445d9e3bace044c2fa3fc93ea4488", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -33,7 +33,7 @@ pub enum Adjust<'tcx> {\n     /// Go from a safe fn pointer to an unsafe fn pointer.\n     UnsafeFnPointer,\n \n-    // Go from a non-capturing closure to an fn pointer.\n+    /// Go from a non-capturing closure to an fn pointer.\n     ClosureFnPointer,\n \n     /// Go from a mut raw pointer to a const raw pointer."}, {"sha": "6b136d0fa0cbbd425c198fa421f877c2d11367c0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -1140,7 +1140,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(),\n          \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.link.crate_name.as_str()));\n+         || link::link_binary(sess, trans, outputs, &trans.crate_name.as_str()));\n }\n \n fn escape_dep_filename(filename: &str) -> String {"}, {"sha": "a8ee999505e2074e2755a593316c05d8acd591ce", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -600,7 +600,7 @@ impl<'a> CrateLoader<'a> {\n             Err(err) => self.sess.span_fatal(span, &err),\n         };\n \n-        let sym = self.sess.generate_derive_registrar_symbol(&root.hash,\n+        let sym = self.sess.generate_derive_registrar_symbol(root.disambiguator,\n                                                              root.macro_derive_registrar.unwrap());\n         let registrar = unsafe {\n             let sym = match lib.symbol(&sym) {\n@@ -654,7 +654,7 @@ impl<'a> CrateLoader<'a> {\n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n-                                 -> Option<(PathBuf, Svh, DefIndex)> {\n+                                 -> Option<(PathBuf, Symbol, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: Symbol::intern(name),\n              ident: Symbol::intern(name),\n@@ -675,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n         let root = ekrate.metadata.get_root();\n         match (ekrate.dylib.as_ref(), root.plugin_registrar_fn) {\n             (Some(dylib), Some(reg)) => {\n-                Some((dylib.to_path_buf(), root.hash, reg))\n+                Some((dylib.to_path_buf(), root.disambiguator, reg))\n             }\n             (None, Some(_)) => {\n                 span_err!(self.sess, span, E0457,"}, {"sha": "3bf22f8a6c82729d70aa48f61f9d0d114f0d6852", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -14,7 +14,7 @@ use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n                             EncodedMetadata, EncodedMetadataHash};\n-use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n@@ -1380,7 +1380,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let link_meta = self.link_meta;\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let root = self.lazy(&CrateRoot {\n-            name: link_meta.crate_name,\n+            name: tcx.crate_name(LOCAL_CRATE),\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n             disambiguator: tcx.sess.local_crate_disambiguator(),"}, {"sha": "ed49e8a14c8c7b0097825e234b382d52e8f98967", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -100,8 +100,8 @@ impl<'a> PluginLoader<'a> {\n     fn load_plugin(&mut self, span: Span, name: &str, args: Vec<ast::NestedMetaItem>) {\n         let registrar = self.reader.find_plugin_registrar(span, name);\n \n-        if let Some((lib, svh, index)) = registrar {\n-            let symbol = self.sess.generate_plugin_registrar_symbol(&svh, index);\n+        if let Some((lib, disambiguator, index)) = registrar {\n+            let symbol = self.sess.generate_plugin_registrar_symbol(disambiguator, index);\n             let fun = self.dylink_registrar(span, lib, symbol);\n             self.plugins.push(PluginRegistrar {\n                 fun: fun,"}, {"sha": "7468f4ace1b16d760d811f728bd94caafa444925", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -47,7 +47,6 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n /// The LLVM module name containing crate-metadata. This includes a `.` on\n@@ -136,11 +135,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n     \"rust_out\".to_string()\n }\n \n-pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n-                       name: &str)\n-                       -> LinkMeta {\n+pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n     let r = LinkMeta {\n-        crate_name: Symbol::intern(name),\n         crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);"}, {"sha": "5d6717272fdf3d000fdea7c56f5a14815f081cc1", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -15,6 +15,7 @@ use back::symbol_names::symbol_name;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n+use rustc::ty::TyCtxt;\n use syntax::attr;\n use trans_item::TransItem;\n \n@@ -64,15 +65,15 @@ impl ExportedSymbols {\n         }\n \n         if let Some(id) = scx.sess().derive_registrar_fn.get() {\n-            let svh = &scx.link_meta().crate_hash;\n             let def_id = scx.tcx().hir.local_def_id(id);\n             let idx = def_id.index;\n-            let registrar = scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            let registrar = scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n             local_crate.push((registrar, SymbolExportLevel::C));\n         }\n \n         if scx.sess().crate_types.borrow().contains(&config::CrateTypeDylib) {\n-            local_crate.push((scx.metadata_symbol_name(),\n+            local_crate.push((metadata_symbol_name(scx.tcx()),\n                               SymbolExportLevel::Rust));\n         }\n \n@@ -173,6 +174,12 @@ impl ExportedSymbols {\n     }\n }\n \n+pub fn metadata_symbol_name(tcx: TyCtxt) -> String {\n+    format!(\"rust_metadata_{}_{}\",\n+            tcx.crate_name(LOCAL_CRATE),\n+            tcx.crate_disambiguator(LOCAL_CRATE))\n+}\n+\n pub fn crate_export_threshold(crate_type: config::CrateType)\n                                      -> SymbolExportLevel {\n     match crate_type {"}, {"sha": "8facbd6cc278373299585b0dd64dd5904fcc62f8", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -179,14 +179,14 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     if let Some(id) = node_id {\n         if scx.sess().plugin_registrar_fn.get() == Some(id) {\n-            let svh = &scx.link_meta().crate_hash;\n             let idx = def_id.index;\n-            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            return scx.sess().generate_plugin_registrar_symbol(disambiguator, idx);\n         }\n         if scx.sess().derive_registrar_fn.get() == Some(id) {\n-            let svh = &scx.link_meta().crate_hash;\n             let idx = def_id.index;\n-            return scx.sess().generate_derive_registrar_symbol(svh, idx);\n+            let disambiguator = scx.sess().local_crate_disambiguator();\n+            return scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n         }\n     }\n "}, {"sha": "c770bbdb90f72569b46571cb3d18d769d4f395a9", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 151, "deletions": 150, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -32,13 +32,14 @@ use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n-use llvm::{Linkage, ValueRef, Vector, get_param};\n+use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n use middle::cstore::EncodedMetadata;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n+use rustc::dep_graph::{AssertDepGraphSafe, DepNode};\n+use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n@@ -56,7 +57,7 @@ use common::CrateContext;\n use common::{type_is_zero_size, val_ty};\n use common;\n use consts;\n-use context::{SharedCrateContext, CrateContextList};\n+use context::{self, LocalCrateContext, SharedCrateContext, Stats};\n use debuginfo;\n use declare;\n use machine;\n@@ -724,19 +725,24 @@ fn contains_null(s: &str) -> bool {\n     s.bytes().any(|b| b == 0)\n }\n \n-fn write_metadata(cx: &SharedCrateContext,\n-                  exported_symbols: &NodeSet)\n-                  -> EncodedMetadata {\n+fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                            link_meta: &LinkMeta,\n+                            exported_symbols: &NodeSet)\n+                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n     use flate;\n \n+    let (metadata_llcx, metadata_llmod) = unsafe {\n+        context::create_context_and_module(tcx.sess, \"metadata\")\n+    };\n+\n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n     enum MetadataKind {\n         None,\n         Uncompressed,\n         Compressed\n     }\n \n-    let kind = cx.sess().crate_types.borrow().iter().map(|ty| {\n+    let kind = tcx.sess.crate_types.borrow().iter().map(|ty| {\n         match *ty {\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib |\n@@ -750,35 +756,35 @@ fn write_metadata(cx: &SharedCrateContext,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return EncodedMetadata {\n+        return (metadata_llcx, metadata_llmod, EncodedMetadata {\n             raw_data: vec![],\n             hashes: vec![],\n-        };\n+        });\n     }\n \n-    let cstore = &cx.tcx().sess.cstore;\n-    let metadata = cstore.encode_metadata(cx.tcx(),\n-                                          cx.link_meta(),\n+    let cstore = &tcx.sess.cstore;\n+    let metadata = cstore.encode_metadata(tcx,\n+                                          &link_meta,\n                                           exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n-        return metadata;\n+        return (metadata_llcx, metadata_llmod, metadata);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata.raw_data));\n \n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed);\n-    let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n-    let name = cx.metadata_symbol_name();\n+    let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let name = symbol_export::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst).to_ref(), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let section_name =\n-            cx.tcx().sess.cstore.metadata_section_name(&cx.sess().target.target);\n+            tcx.sess.cstore.metadata_section_name(&tcx.sess.target.target);\n         let name = CString::new(section_name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n \n@@ -787,15 +793,16 @@ fn write_metadata(cx: &SharedCrateContext,\n         // metadata doesn't get loaded into memory.\n         let directive = format!(\".section {}\", section_name);\n         let directive = CString::new(directive).unwrap();\n-        llvm::LLVMSetModuleInlineAsm(cx.metadata_llmod(), directive.as_ptr())\n+        llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return metadata;\n+    return (metadata_llcx, metadata_llmod, metadata);\n }\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n-                                 ccxs: &CrateContextList<'a, 'tcx>,\n+                                 scx: &SharedCrateContext<'a, 'tcx>,\n+                                 llvm_modules: &[ModuleLlvm],\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n@@ -810,7 +817,6 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         .map(|&(ref name, _)| &name[..])\n         .collect::<FxHashSet<&str>>();\n \n-    let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n     let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n@@ -825,8 +831,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // incremental compilation, we don't need to collect. See below for more\n         // information.\n         if !incr_comp {\n-            for ccx in ccxs.iter_need_trans() {\n-                for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+            for ll in llvm_modules {\n+                for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                     let linkage = llvm::LLVMRustGetLinkage(val);\n                     // We only care about external declarations (not definitions)\n                     // and available_externally definitions.\n@@ -862,8 +868,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in ccxs.iter_need_trans() {\n-            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+        for ll in llvm_modules {\n+            for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                 let linkage = llvm::LLVMRustGetLinkage(val);\n \n                 let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n@@ -922,33 +928,34 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_imps(cx: &CrateContextList) {\n+fn create_imps(sess: &Session,\n+               llvm_modules: &[ModuleLlvm]) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n     // underscores added in front).\n-    let prefix = if cx.shared().sess().target.target.target_pointer_width == \"32\" {\n+    let prefix = if sess.target.target.target_pointer_width == \"32\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter_need_trans() {\n-            let exported: Vec<_> = iter_globals(ccx.llmod())\n+        for ll in llvm_modules {\n+            let exported: Vec<_> = iter_globals(ll.llmod)\n                                        .filter(|&val| {\n                                            llvm::LLVMRustGetLinkage(val) ==\n                                            llvm::Linkage::ExternalLinkage &&\n                                            llvm::LLVMIsDeclaration(val) == 0\n                                        })\n                                        .collect();\n \n-            let i8p_ty = Type::i8p(&ccx);\n+            let i8p_ty = Type::i8p_llcx(ll.llcx);\n             for val in exported {\n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                 let mut imp_name = prefix.as_bytes().to_vec();\n                 imp_name.extend(name.to_bytes());\n                 let imp_name = CString::new(imp_name).unwrap();\n-                let imp = llvm::LLVMAddGlobal(ccx.llmod(),\n+                let imp = llvm::LLVMAddGlobal(ll.llmod,\n                                               i8p_ty.to_ref(),\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n@@ -1058,28 +1065,28 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // particular items that will be processed.\n     let krate = tcx.hir.krate();\n \n-    let ty::CrateAnalysis { reachable, name, .. } = analysis;\n+    let ty::CrateAnalysis { reachable, .. } = analysis;\n     let exported_symbols = find_exported_symbols(tcx, reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n-    let link_meta = link::build_link_meta(incremental_hashes_map, &name);\n+    let link_meta = link::build_link_meta(incremental_hashes_map);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n-                                             link_meta.clone(),\n                                              exported_symbols,\n                                              check_overflow);\n     // Translate the metadata.\n-    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n-        write_metadata(&shared_ccx, shared_ccx.exported_symbols())\n-    });\n+    let (metadata_llcx, metadata_llmod, metadata) =\n+        time(tcx.sess.time_passes(), \"write metadata\", || {\n+            write_metadata(tcx, &link_meta, shared_ccx.exported_symbols())\n+        });\n \n     let metadata_module = ModuleTranslation {\n         name: link::METADATA_MODULE_NAME.to_string(),\n         symbol_name_hash: 0, // we always rebuild metadata, at least for now\n         source: ModuleSource::Translated(ModuleLlvm {\n-            llcx: shared_ccx.metadata_llcx(),\n-            llmod: shared_ccx.metadata_llmod(),\n+            llcx: metadata_llcx,\n+            llmod: metadata_llmod,\n         }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n@@ -1090,6 +1097,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n         return CrateTranslation {\n+            crate_name: tcx.crate_name(LOCAL_CRATE),\n             modules: vec![],\n             metadata_module: metadata_module,\n             link: link_meta,\n@@ -1107,73 +1115,78 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let symbol_map = Rc::new(symbol_map);\n \n-    let previous_work_products = trans_reuse_previous_work_products(&shared_ccx,\n-                                                                    &codegen_units,\n-                                                                    &symbol_map);\n-\n-    let crate_context_list = CrateContextList::new(&shared_ccx,\n-                                                   codegen_units,\n-                                                   previous_work_products,\n-                                                   symbol_map.clone());\n-    let modules: Vec<_> = crate_context_list.iter_all()\n-        .map(|ccx| {\n-            let source = match ccx.previous_work_product() {\n-                Some(buf) => ModuleSource::Preexisting(buf.clone()),\n-                None => ModuleSource::Translated(ModuleLlvm {\n-                    llcx: ccx.llcx(),\n-                    llmod: ccx.llmod(),\n-                }),\n-            };\n-\n-            ModuleTranslation {\n-                name: String::from(ccx.codegen_unit().name()),\n-                symbol_name_hash: ccx.codegen_unit()\n-                                     .compute_symbol_name_hash(&shared_ccx,\n-                                                               &symbol_map),\n-                source: source,\n-            }\n+    let mut all_stats = Stats::default();\n+    let modules: Vec<ModuleTranslation> = codegen_units\n+        .into_iter()\n+        .map(|cgu| {\n+            let dep_node = cgu.work_product_dep_node();\n+            let (stats, module) =\n+                tcx.dep_graph.with_task(dep_node,\n+                                        AssertDepGraphSafe(&shared_ccx),\n+                                        AssertDepGraphSafe((cgu, symbol_map.clone())),\n+                                        module_translation);\n+            all_stats.extend(stats);\n+            module\n         })\n         .collect();\n \n-    assert_module_sources::assert_module_sources(tcx, &modules);\n+    fn module_translation<'a, 'tcx>(\n+        scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n+        args: AssertDepGraphSafe<(CodegenUnit<'tcx>, Rc<SymbolMap<'tcx>>)>)\n+        -> (Stats, ModuleTranslation)\n+    {\n+        // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n+        let AssertDepGraphSafe(scx) = scx;\n+        let AssertDepGraphSafe((cgu, symbol_map)) = args;\n+\n+        let cgu_name = String::from(cgu.name());\n+        let cgu_id = cgu.work_product_id();\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_map);\n+\n+        // Check whether there is a previous work-product we can\n+        // re-use.  Not only must the file exist, and the inputs not\n+        // be dirty, but the hash of the symbols we will generate must\n+        // be the same.\n+        let previous_work_product =\n+            scx.dep_graph().previous_work_product(&cgu_id).and_then(|work_product| {\n+                if work_product.input_hash == symbol_name_hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    Some(work_product)\n+                } else {\n+                    if scx.sess().opts.debugging_opts.incremental_info {\n+                        println!(\"incremental: CGU `{}` invalidated because of \\\n+                                  changed partitioning hash.\",\n+                                 cgu.name());\n+                    }\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, symbol_name_hash);\n+                    None\n+                }\n+            });\n+\n+        if let Some(buf) = previous_work_product {\n+            // Don't need to translate this module.\n+            let module = ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Preexisting(buf.clone())\n+            };\n+            return (Stats::default(), module);\n+        }\n \n-    // Instantiate translation items without filling out definitions yet...\n-    for ccx in crate_context_list.iter_need_trans() {\n-        let dep_node = ccx.codegen_unit().work_product_dep_node();\n-        tcx.dep_graph.with_task(dep_node,\n-                                ccx,\n-                                AssertDepGraphSafe(symbol_map.clone()),\n-                                trans_decl_task);\n-\n-        fn trans_decl_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n-                                     symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n-            // FIXME(#40304): Instead of this, the symbol-map should be an\n-            // on-demand thing that we compute.\n-            let AssertDepGraphSafe(symbol_map) = symbol_map;\n-            let cgu = ccx.codegen_unit();\n-            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n-            for (trans_item, linkage) in trans_items {\n+        // Instantiate translation items without filling out definitions yet...\n+        let lcx = LocalCrateContext::new(scx, cgu, symbol_map.clone());\n+        let module = {\n+            let ccx = CrateContext::new(scx, &lcx);\n+            let trans_items = ccx.codegen_unit()\n+                                 .items_in_deterministic_order(ccx.tcx(), &symbol_map);\n+            for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n-        }\n-    }\n \n-    // ... and now that we have everything pre-defined, fill out those definitions.\n-    for ccx in crate_context_list.iter_need_trans() {\n-        let dep_node = ccx.codegen_unit().work_product_dep_node();\n-        tcx.dep_graph.with_task(dep_node,\n-                                ccx,\n-                                AssertDepGraphSafe(symbol_map.clone()),\n-                                trans_def_task);\n-\n-        fn trans_def_task<'a, 'tcx>(ccx: CrateContext<'a, 'tcx>,\n-                                    symbol_map: AssertDepGraphSafe<Rc<SymbolMap<'tcx>>>) {\n-            // FIXME(#40304): Instead of this, the symbol-map should be an\n-            // on-demand thing that we compute.\n-            let AssertDepGraphSafe(symbol_map) = symbol_map;\n-            let cgu = ccx.codegen_unit();\n-            let trans_items = cgu.items_in_deterministic_order(ccx.tcx(), &symbol_map);\n-            for (trans_item, _) in trans_items {\n+            // ... and now that we have everything pre-defined, fill out those definitions.\n+            for &(trans_item, _) in &trans_items {\n                 trans_item.define(&ccx);\n             }\n \n@@ -1211,26 +1224,38 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if ccx.sess().opts.debuginfo != NoDebugInfo {\n                 debuginfo::finalize(&ccx);\n             }\n-        }\n+\n+            ModuleTranslation {\n+                name: cgu_name,\n+                symbol_name_hash,\n+                source: ModuleSource::Translated(ModuleLlvm {\n+                    llcx: ccx.llcx(),\n+                    llmod: ccx.llmod(),\n+                })\n+            }\n+        };\n+\n+        (lcx.into_stats(), module)\n     }\n \n+    assert_module_sources::assert_module_sources(tcx, &modules);\n+\n     symbol_names_test::report_symbol_names(&shared_ccx);\n \n     if shared_ccx.sess().trans_stats() {\n-        let stats = shared_ccx.stats();\n         println!(\"--- trans stats ---\");\n-        println!(\"n_glues_created: {}\", stats.n_glues_created.get());\n-        println!(\"n_null_glues: {}\", stats.n_null_glues.get());\n-        println!(\"n_real_glues: {}\", stats.n_real_glues.get());\n+        println!(\"n_glues_created: {}\", all_stats.n_glues_created.get());\n+        println!(\"n_null_glues: {}\", all_stats.n_null_glues.get());\n+        println!(\"n_real_glues: {}\", all_stats.n_real_glues.get());\n \n-        println!(\"n_fns: {}\", stats.n_fns.get());\n-        println!(\"n_inlines: {}\", stats.n_inlines.get());\n-        println!(\"n_closures: {}\", stats.n_closures.get());\n+        println!(\"n_fns: {}\", all_stats.n_fns.get());\n+        println!(\"n_inlines: {}\", all_stats.n_inlines.get());\n+        println!(\"n_closures: {}\", all_stats.n_closures.get());\n         println!(\"fn stats:\");\n-        stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n+        all_stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n-        for tuple in stats.fn_stats.borrow().iter() {\n+        for tuple in all_stats.fn_stats.borrow().iter() {\n             match *tuple {\n                 (ref name, insns) => {\n                     println!(\"{} insns, {}\", insns, *name);\n@@ -1240,7 +1265,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     if shared_ccx.sess().count_llvm_insns() {\n-        for (k, v) in shared_ccx.stats().llvm_insns.borrow().iter() {\n+        for (k, v) in all_stats.llvm_insns.borrow().iter() {\n             println!(\"{:7} {}\", *v, *k);\n         }\n     }\n@@ -1250,11 +1275,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n                                                          &symbol_map);\n \n+    // Get the list of llvm modules we created. We'll do a few wacky\n+    // transforms on them now.\n+\n+    let llvm_modules: Vec<_> =\n+        modules.iter()\n+               .filter_map(|module| match module.source {\n+                   ModuleSource::Translated(llvm) => Some(llvm),\n+                   _ => None,\n+               })\n+               .collect();\n+\n     // Now that we have all symbols that are exported from the CGUs of this\n     // crate, we can run the `internalize_symbols` pass.\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n-                            &crate_context_list,\n+                            &shared_ccx,\n+                            &llvm_modules,\n                             &symbol_map,\n                             &exported_symbols);\n     });\n@@ -1265,7 +1302,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(&crate_context_list);\n+        create_imps(sess, &llvm_modules);\n     }\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n@@ -1282,6 +1319,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n \n     CrateTranslation {\n+        crate_name: tcx.crate_name(LOCAL_CRATE),\n         modules: modules,\n         metadata_module: metadata_module,\n         link: link_meta,\n@@ -1480,43 +1518,6 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-/// For each CGU, identify if we can reuse an existing object file (or\n-/// maybe other context).\n-fn trans_reuse_previous_work_products(scx: &SharedCrateContext,\n-                                      codegen_units: &[CodegenUnit],\n-                                      symbol_map: &SymbolMap)\n-                                      -> Vec<Option<WorkProduct>> {\n-    debug!(\"trans_reuse_previous_work_products()\");\n-    codegen_units\n-        .iter()\n-        .map(|cgu| {\n-            let id = cgu.work_product_id();\n-\n-            let hash = cgu.compute_symbol_name_hash(scx, symbol_map);\n-\n-            debug!(\"trans_reuse_previous_work_products: id={:?} hash={}\", id, hash);\n-\n-            if let Some(work_product) = scx.dep_graph().previous_work_product(&id) {\n-                if work_product.input_hash == hash {\n-                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n-                    return Some(work_product);\n-                } else {\n-                    if scx.sess().opts.debugging_opts.incremental_info {\n-                        println!(\"incremental: CGU `{}` invalidated because of \\\n-                                  changed partitioning hash.\",\n-                                  cgu.name());\n-                    }\n-                    debug!(\"trans_reuse_previous_work_products: \\\n-                            not reusing {:?} because hash changed to {:?}\",\n-                           work_product, hash);\n-                }\n-            }\n-\n-            None\n-        })\n-        .collect()\n-}\n-\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();"}, {"sha": "c3770470bfd056536d620c38affa728d11e11aa7", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 40, "deletions": 165, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -10,9 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap,\n-                       DepTrackingMapConfig, WorkProduct};\n-use middle::cstore::LinkMeta;\n+use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap, DepTrackingMapConfig};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n@@ -47,6 +45,7 @@ use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n use abi::Abi;\n \n+#[derive(Clone, Default)]\n pub struct Stats {\n     pub n_glues_created: Cell<usize>,\n     pub n_null_glues: Cell<usize>,\n@@ -60,19 +59,30 @@ pub struct Stats {\n     pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n \n+impl Stats {\n+    pub fn extend(&mut self, stats: Stats) {\n+        self.n_glues_created.set(self.n_glues_created.get() + stats.n_glues_created.get());\n+        self.n_null_glues.set(self.n_null_glues.get() + stats.n_null_glues.get());\n+        self.n_real_glues.set(self.n_real_glues.get() + stats.n_real_glues.get());\n+        self.n_fns.set(self.n_fns.get() + stats.n_fns.get());\n+        self.n_inlines.set(self.n_inlines.get() + stats.n_inlines.get());\n+        self.n_closures.set(self.n_closures.get() + stats.n_closures.get());\n+        self.n_llvm_insns.set(self.n_llvm_insns.get() + stats.n_llvm_insns.get());\n+        self.llvm_insns.borrow_mut().extend(\n+            stats.llvm_insns.borrow().iter()\n+                                     .map(|(key, value)| (key.clone(), value.clone())));\n+        self.fn_stats.borrow_mut().append(&mut *stats.fn_stats.borrow_mut());\n+    }\n+}\n+\n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n /// per crate.  The data here is shared between all compilation units of the\n /// crate, so it must not contain references to any LLVM data structures\n /// (aside from metadata-related ones).\n pub struct SharedCrateContext<'a, 'tcx: 'a> {\n-    metadata_llmod: ModuleRef,\n-    metadata_llcx: ContextRef,\n-\n     exported_symbols: NodeSet,\n-    link_meta: LinkMeta,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     empty_param_env: ty::ParameterEnvironment<'tcx>,\n-    stats: Stats,\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n@@ -89,7 +99,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    previous_work_product: Option<WorkProduct>,\n+    stats: Stats,\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n     /// Cache instances of monomorphic and polymorphic items\n@@ -214,107 +224,23 @@ impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n     }\n }\n \n-/// This list owns a number of LocalCrateContexts and binds them to their common\n-/// SharedCrateContext. This type just exists as a convenience, something to\n-/// pass around all LocalCrateContexts with and get an iterator over them.\n-pub struct CrateContextList<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: Vec<LocalCrateContext<'tcx>>,\n-}\n-\n-impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n-    pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n-               codegen_units: Vec<CodegenUnit<'tcx>>,\n-               previous_work_products: Vec<Option<WorkProduct>>,\n-               symbol_map: Rc<SymbolMap<'tcx>>)\n-               -> CrateContextList<'a, 'tcx> {\n-        CrateContextList {\n-            shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, wp)| {\n-                LocalCrateContext::new(shared_ccx, cgu, wp, symbol_map.clone())\n-            }).collect()\n-        }\n-    }\n-\n-    /// Iterate over all crate contexts, whether or not they need\n-    /// translation.  That is, whether or not a `.o` file is available\n-    /// for re-use from a previous incr. comp.).\n-    pub fn iter_all<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n-        CrateContextIterator {\n-            shared: self.shared,\n-            index: 0,\n-            local_ccxs: &self.local_ccxs[..],\n-            filter_to_previous_work_product_unavail: false,\n-        }\n-    }\n-\n-    /// Iterator over all CCX that need translation (cannot reuse results from\n-    /// previous incr. comp.).\n-    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n-        CrateContextIterator {\n-            shared: self.shared,\n-            index: 0,\n-            local_ccxs: &self.local_ccxs[..],\n-            filter_to_previous_work_product_unavail: true,\n-        }\n-    }\n-\n-    pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n-        self.shared\n-    }\n-}\n-\n /// A CrateContext value binds together one LocalCrateContext with the\n /// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: &'a [LocalCrateContext<'tcx>],\n-    /// The index of `local` in `local_ccxs`.  This is used in\n-    /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n-    index: usize,\n+    local_ccx: &'a LocalCrateContext<'tcx>,\n }\n \n-impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n-}\n-\n-pub struct CrateContextIterator<'a, 'tcx: 'a> {\n-    shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccxs: &'a [LocalCrateContext<'tcx>],\n-    index: usize,\n-\n-    /// if true, only return results where `previous_work_product` is none\n-    filter_to_previous_work_product_unavail: bool,\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n+               local_ccx: &'a LocalCrateContext<'tcx>)\n+               -> Self {\n+        CrateContext { shared, local_ccx }\n+    }\n }\n \n-impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n-    type Item = CrateContext<'a, 'tcx>;\n-\n-    fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        loop {\n-            if self.index >= self.local_ccxs.len() {\n-                return None;\n-            }\n-\n-            let index = self.index;\n-            self.index += 1;\n-\n-            let ccx = CrateContext {\n-                shared: self.shared,\n-                index: index,\n-                local_ccxs: self.local_ccxs,\n-            };\n-\n-            if\n-                self.filter_to_previous_work_product_unavail &&\n-                ccx.previous_work_product().is_some()\n-            {\n-                continue;\n-            }\n-\n-            return Some(ccx);\n-        }\n-    }\n+impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n }\n \n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n@@ -347,7 +273,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n     !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocMode::PIC\n }\n \n-unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n+pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n@@ -405,14 +331,9 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-               link_meta: LinkMeta,\n                exported_symbols: NodeSet,\n                check_overflow: bool)\n                -> SharedCrateContext<'b, 'tcx> {\n-        let (metadata_llcx, metadata_llmod) = unsafe {\n-            create_context_and_module(&tcx.sess, \"metadata\")\n-        };\n-\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n         // attributes in LLVM IR as well as native dependencies (in C these\n@@ -459,23 +380,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n \n         SharedCrateContext {\n-            metadata_llmod: metadata_llmod,\n-            metadata_llcx: metadata_llcx,\n             exported_symbols: exported_symbols,\n-            link_meta: link_meta,\n             empty_param_env: tcx.empty_parameter_environment(),\n             tcx: tcx,\n-            stats: Stats {\n-                n_glues_created: Cell::new(0),\n-                n_null_glues: Cell::new(0),\n-                n_real_glues: Cell::new(0),\n-                n_fns: Cell::new(0),\n-                n_inlines: Cell::new(0),\n-                n_closures: Cell::new(0),\n-                n_llvm_insns: Cell::new(0),\n-                llvm_insns: RefCell::new(FxHashMap()),\n-                fn_stats: RefCell::new(Vec::new()),\n-            },\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n             translation_items: RefCell::new(FxHashSet()),\n@@ -492,14 +399,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         ty.is_sized(self.tcx, &self.empty_param_env, DUMMY_SP)\n     }\n \n-    pub fn metadata_llmod(&self) -> ModuleRef {\n-        self.metadata_llmod\n-    }\n-\n-    pub fn metadata_llcx(&self) -> ContextRef {\n-        self.metadata_llcx\n-    }\n-\n     pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n         &self.exported_symbols\n     }\n@@ -512,10 +411,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.project_cache\n     }\n \n-    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n-        &self.link_meta\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -528,31 +423,20 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.tcx.dep_graph\n     }\n \n-    pub fn stats<'a>(&'a self) -> &'a Stats {\n-        &self.stats\n-    }\n-\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n \n     pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n         &self.translation_items\n     }\n-\n-    pub fn metadata_symbol_name(&self) -> String {\n-        format!(\"rust_metadata_{}_{}\",\n-                self.link_meta().crate_name,\n-                self.link_meta().crate_hash)\n-    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n-    fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>,\n-               previous_work_product: Option<WorkProduct>,\n-               symbol_map: Rc<SymbolMap<'tcx>>)\n-           -> LocalCrateContext<'tcx> {\n+    pub fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n+                   codegen_unit: CodegenUnit<'tcx>,\n+                   symbol_map: Rc<SymbolMap<'tcx>>)\n+                   -> LocalCrateContext<'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n             //\n@@ -578,7 +462,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n-                previous_work_product: previous_work_product,\n+                stats: Stats::default(),\n                 codegen_unit: codegen_unit,\n                 needs_unwind_cleanup_cache: RefCell::new(FxHashMap()),\n                 instances: RefCell::new(FxHashMap()),\n@@ -647,10 +531,13 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n-            index: 0,\n-            local_ccxs: local_ccxs\n+            local_ccx: &local_ccxs[0]\n         }\n     }\n+\n+    pub fn into_stats(self) -> Stats {\n+        self.stats\n+    }\n }\n \n impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n@@ -659,7 +546,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     fn local(&self) -> &'b LocalCrateContext<'tcx> {\n-        &self.local_ccxs[self.index]\n+        self.local_ccx\n     }\n \n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -688,10 +575,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n-    pub fn previous_work_product(&self) -> Option<&WorkProduct> {\n-        self.local().previous_work_product.as_ref()\n-    }\n-\n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n         &self.local().codegen_unit\n     }\n@@ -700,14 +583,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         unsafe { llvm::LLVMRustGetModuleDataLayout(self.llmod()) }\n     }\n \n-    pub fn exported_symbols<'a>(&'a self) -> &'a NodeSet {\n-        &self.shared.exported_symbols\n-    }\n-\n-    pub fn link_meta<'a>(&'a self) -> &'a LinkMeta {\n-        &self.shared.link_meta\n-    }\n-\n     pub fn needs_unwind_cleanup_cache(&self) -> &RefCell<FxHashMap<Ty<'tcx>, bool>> {\n         &self.local().needs_unwind_cleanup_cache\n     }\n@@ -777,7 +652,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n \n     pub fn stats<'a>(&'a self) -> &'a Stats {\n-        &self.shared.stats\n+        &self.local().stats\n     }\n \n     pub fn int_type(&self) -> Type {"}, {"sha": "1f4756a94ea33518b14740dd227ed339e2eb455c", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -26,7 +26,7 @@ use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor,\n                       DICompositeType, DILexicalBlock, DIFlags};\n \n use rustc::hir::def::CtorKind;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::subst::Substs;\n use rustc::ty::util::TypeIdHasher;\n@@ -810,7 +810,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.link_meta().crate_name.to_string()).unwrap()\n+        CString::new(scc.tcx().crate_name(LOCAL_CRATE).to_string()).unwrap()\n     }\n }\n "}, {"sha": "0a873767d935997b5601dc2495c263a41955c37e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -37,7 +37,7 @@ pub fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n     // visible). It might better to use the `exported_items` set from\n     // `driver::CrateAnalysis` in the future, but (atm) this set is not\n     // available in the translation pass.\n-    !cx.exported_symbols().contains(&node_id)\n+    !cx.shared().exported_symbols().contains(&node_id)\n }\n \n #[allow(non_snake_case)]"}, {"sha": "abda358bc4f87c8d36d3c05255f3eade1e302b88", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -40,6 +40,7 @@\n #![feature(conservative_impl_trait)]\n \n use rustc::dep_graph::WorkProduct;\n+use syntax_pos::symbol::Symbol;\n \n extern crate flate;\n extern crate libc;\n@@ -165,6 +166,7 @@ unsafe impl Send for ModuleTranslation { }\n unsafe impl Sync for ModuleTranslation { }\n \n pub struct CrateTranslation {\n+    pub crate_name: Symbol,\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,\n     pub link: middle::cstore::LinkMeta,"}, {"sha": "d70afc0cce5a3cbebfa7ff9bc997b53b0b5137c2", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind};\n+use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n@@ -82,6 +82,10 @@ impl Type {\n         ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i8_llcx(llcx: ContextRef) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(llcx))\n+    }\n+\n     pub fn i16(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n     }\n@@ -123,6 +127,10 @@ impl Type {\n         Type::i8(ccx).ptr_to()\n     }\n \n+    pub fn i8p_llcx(llcx: ContextRef) -> Type {\n+        Type::i8_llcx(llcx).ptr_to()\n+    }\n+\n     pub fn int(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),"}, {"sha": "9c5870c12aad450d5da70494c16e8ecb573d8fca", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.write_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n+                self.apply_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n                 return Some(CallStep::Builtin);\n             }\n "}, {"sha": "2e9057800a54a3583033e5457f7689ca890b51a1", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -714,13 +714,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.commit_if_ok(|_| {\n             let ok = coerce.coerce(&[expr], source, target)?;\n             let adjustment = self.register_infer_ok_obligations(ok);\n-            if !adjustment.is_identity() {\n-                debug!(\"Success, coerced with {:?}\", adjustment);\n-                if self.tables.borrow().adjustments.get(&expr.id).is_some() {\n-                    bug!(\"expr already has an adjustment on it!\");\n-                }\n-                self.write_adjustment(expr.id, adjustment);\n-            }\n+            self.apply_adjustment(expr.id, adjustment);\n \n             // We should now have added sufficient adjustments etc to\n             // ensure that the type of expression, post-adjustment, is\n@@ -782,9 +776,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Reify both sides and return the reified fn pointer type.\n                 let fn_ptr = self.tcx.mk_fn_ptr(fty);\n                 for expr in exprs.iter().map(|e| e.as_coercion_site()).chain(Some(new)) {\n-                    // No adjustments can produce a fn item, so this should never trip.\n-                    assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                    self.write_adjustment(expr.id, Adjustment {\n+                    // The only adjustment that can produce an fn item is\n+                    // `NeverToAny`, so this should always be valid.\n+                    self.apply_adjustment(expr.id, Adjustment {\n                         kind: Adjust::ReifyFnPointer,\n                         target: fn_ptr\n                     });\n@@ -805,9 +799,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match result {\n                 Ok(ok) => {\n                     let adjustment = self.register_infer_ok_obligations(ok);\n-                    if !adjustment.is_identity() {\n-                        self.write_adjustment(new.id, adjustment);\n-                    }\n+                    self.apply_adjustment(new.id, adjustment);\n                     return Ok(adjustment.target);\n                 }\n                 Err(e) => first_error = Some(e),\n@@ -827,7 +819,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }) => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n-                            // Reborrow that we can safely ignore.\n+                            // Reborrow that we can safely ignore, because\n+                            // the next adjustment can only be a DerefRef\n+                            // which will be merged into it.\n                             mutbl_adj == mt_orig.mutbl\n                         }\n                         _ => false,\n@@ -860,19 +854,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Ok(ok) => {\n                 let adjustment = self.register_infer_ok_obligations(ok);\n-                if !adjustment.is_identity() {\n-                    let mut tables = self.tables.borrow_mut();\n-                    for expr in exprs {\n-                        let expr = expr.as_coercion_site();\n-                        if let Some(&mut Adjustment {\n-                            kind: Adjust::NeverToAny,\n-                            ref mut target\n-                        }) = tables.adjustments.get_mut(&expr.id) {\n-                            *target = adjustment.target;\n-                            continue;\n-                        }\n-                        tables.adjustments.insert(expr.id, adjustment);\n-                    }\n+                for expr in exprs {\n+                    let expr = expr.as_coercion_site();\n+                    self.apply_adjustment(expr.id, adjustment);\n                 }\n                 Ok(adjustment.target)\n             }"}, {"sha": "28ac335cf195a12a29da60f5f62baefafd6513a9", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let target = target.adjust_for_autoref(self.tcx, autoref);\n \n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id, Adjustment {\n+        self.apply_adjustment(self.self_expr.id, Adjustment {\n             kind: Adjust::DerefRef {\n                 autoderefs: pick.autoderefs,\n                 autoref: autoref,\n@@ -433,7 +433,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n-            // Count autoderefs.\n+            // Count autoderefs. We don't need to fix up the autoref - the parent\n+            // expression will fix them up for us.\n             let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n             match adjustment {\n                 Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n@@ -464,7 +465,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // expects. This is annoying and horrible. We\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n-                    let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n+                    let adj = self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n                     let (autoderefs, unsize, adjusted_base_ty) = match adj {\n                         Some(Adjustment {\n                             kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n@@ -537,6 +538,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // a preference for mut\n                     let method_call = ty::MethodCall::expr(expr.id);\n                     if self.tables.borrow().method_map.contains_key(&method_call) {\n+                        self.tables.borrow_mut().adjustments.remove(&base_expr.id);\n                         let method = self.try_overloaded_deref(expr.span,\n                                                                Some(&base_expr),\n                                                                self.node_ty(base_expr.id),"}, {"sha": "9ecf0ffa71ebd65500ff8a3dc70744b6214efddc", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -299,7 +299,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             };\n \n-            self.write_adjustment(self_expr.id, Adjustment {\n+            self.apply_adjustment(self_expr.id, Adjustment {\n                 kind: Adjust::DerefRef {\n                     autoderefs: autoderefs,\n                     autoref: autoref,"}, {"sha": "5e7325275b8199c17fdecc0daa07c00d9141cf35", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 14, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -95,7 +95,7 @@ use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n-use rustc::ty::adjustment;\n+use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n@@ -108,6 +108,7 @@ use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::cell::{Cell, RefCell};\n+use std::collections::hash_map::Entry;\n use std::cmp;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -1637,12 +1638,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_autoderef_adjustment(&self,\n+    pub fn apply_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       derefs: usize,\n                                       adjusted_ty: Ty<'tcx>) {\n-        self.write_adjustment(node_id, adjustment::Adjustment {\n-            kind: adjustment::Adjust::DerefRef {\n+        self.apply_adjustment(node_id, Adjustment {\n+            kind: Adjust::DerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n                 unsize: false\n@@ -1651,16 +1652,42 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn write_adjustment(&self,\n-                            node_id: ast::NodeId,\n-                            adj: adjustment::Adjustment<'tcx>) {\n-        debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n+    pub fn apply_adjustment(&self, node_id: ast::NodeId, adj: Adjustment<'tcx>) {\n+        debug!(\"apply_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n             return;\n         }\n \n-        self.tables.borrow_mut().adjustments.insert(node_id, adj);\n+        match self.tables.borrow_mut().adjustments.entry(node_id) {\n+            Entry::Vacant(entry) => { entry.insert(adj); },\n+            Entry::Occupied(mut entry) => {\n+                debug!(\" - composing on top of {:?}\", entry.get());\n+                let composed_kind = match (entry.get().kind, adj.kind) {\n+                    // Applying any adjustment on top of a NeverToAny\n+                    // is a valid NeverToAny adjustment, because it can't\n+                    // be reached.\n+                    (Adjust::NeverToAny, _) => Adjust::NeverToAny,\n+                    (Adjust::DerefRef {\n+                        autoderefs: 1,\n+                        autoref: Some(AutoBorrow::Ref(..)),\n+                        unsize: false\n+                    }, Adjust::DerefRef { autoderefs, .. }) if autoderefs > 0 => {\n+                        // A reborrow has no effect before a dereference.\n+                        adj.kind\n+                    }\n+                    // FIXME: currently we never try to compose autoderefs\n+                    // and ReifyFnPointer/UnsafeFnPointer, but we could.\n+                    _ =>\n+                        bug!(\"while adjusting {}, can't compose {:?} and {:?}\",\n+                             node_id, entry.get(), adj)\n+                };\n+                *entry.get_mut() = Adjustment {\n+                    kind: composed_kind,\n+                    target: adj.target\n+                };\n+            }\n+        }\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -2097,7 +2124,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n                 assert!(!unsize);\n-                self.write_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n+                self.apply_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n@@ -2480,8 +2507,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n-            self.write_adjustment(expr.id, adjustment::Adjustment {\n-                kind: adjustment::Adjust::NeverToAny,\n+            self.apply_adjustment(expr.id, Adjustment {\n+                kind: Adjust::NeverToAny,\n                 target: adj_ty\n             });\n             ty = adj_ty;\n@@ -2731,7 +2758,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n                             autoderef.finalize(lvalue_pref, &[base]);\n-                            self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n+                            self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n \n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n \n@@ -2855,7 +2882,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, &[base]);\n-                self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n+                self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n         }"}, {"sha": "d4755020fef22cb533a56664a6bf24d2b256b1a2", "filename": "src/test/run-pass/issue-41213.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Ftest%2Frun-pass%2Fissue-41213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f32e0dfb287c2b3d0c48cb3b8090b3902960084/src%2Ftest%2Frun-pass%2Fissue-41213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41213.rs?ref=4f32e0dfb287c2b3d0c48cb3b8090b3902960084", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum A {\n+    A1,\n+    A2,\n+    A3,\n+}\n+\n+enum B {\n+    B1(String, String),\n+    B2(String, String),\n+}\n+\n+fn main() {\n+    let a = A::A1;\n+    loop {\n+        let _ctor = match a {\n+            A::A3 => break,\n+            A::A1 => B::B1,\n+            A::A2 => B::B2,\n+        };\n+        break;\n+    }\n+}"}]}