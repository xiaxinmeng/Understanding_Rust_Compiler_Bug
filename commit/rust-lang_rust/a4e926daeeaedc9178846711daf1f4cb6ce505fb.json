{"sha": "a4e926daeeaedc9178846711daf1f4cb6ce505fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZTkyNmRhZWVhZWRjOTE3ODg0NjcxMWRhZjFmNGNiNmNlNTA1ZmI=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-08-27T13:45:01Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-08-31T02:56:59Z"}, "message": "std: move \"mod tests/benches\" to separate files\n\nAlso doing fmt inplace as requested.", "tree": {"sha": "0c830f716f6f5ad17736d459f5de9b9199006d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c830f716f6f5ad17736d459f5de9b9199006d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4e926daeeaedc9178846711daf1f4cb6ce505fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e926daeeaedc9178846711daf1f4cb6ce505fb", "html_url": "https://github.com/rust-lang/rust/commit/a4e926daeeaedc9178846711daf1f4cb6ce505fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4e926daeeaedc9178846711daf1f4cb6ce505fb/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db6cbfc49ca655739ba8caae43ebd7c77c8a1179", "url": "https://api.github.com/repos/rust-lang/rust/commits/db6cbfc49ca655739ba8caae43ebd7c77c8a1179", "html_url": "https://github.com/rust-lang/rust/commit/db6cbfc49ca655739ba8caae43ebd7c77c8a1179"}], "stats": {"total": 33268, "additions": 16569, "deletions": 16699}, "files": [{"sha": "cc29e1c0b05229953da2d09827849fbf0e63c245", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 3, "deletions": 52, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -66,6 +66,9 @@\n \n #![unstable(feature = \"backtrace\", issue = \"53487\")]\n \n+#[cfg(test)]\n+mod tests;\n+\n // NB: A note on resolution of a backtrace:\n //\n // Backtraces primarily happen in two steps, one is where we actually capture\n@@ -438,55 +441,3 @@ impl RawFrame {\n         }\n     }\n }\n-\n-#[test]\n-fn test_debug() {\n-    let backtrace = Backtrace {\n-        inner: Inner::Captured(Mutex::new(Capture {\n-            actual_start: 1,\n-            resolved: true,\n-            frames: vec![\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![BacktraceSymbol {\n-                        name: Some(b\"std::backtrace::Backtrace::create\".to_vec()),\n-                        filename: Some(BytesOrWide::Bytes(b\"rust/backtrace.rs\".to_vec())),\n-                        lineno: Some(100),\n-                    }],\n-                },\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![BacktraceSymbol {\n-                        name: Some(b\"__rust_maybe_catch_panic\".to_vec()),\n-                        filename: None,\n-                        lineno: None,\n-                    }],\n-                },\n-                BacktraceFrame {\n-                    frame: RawFrame::Fake,\n-                    symbols: vec![\n-                        BacktraceSymbol {\n-                            name: Some(b\"std::rt::lang_start_internal\".to_vec()),\n-                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n-                            lineno: Some(300),\n-                        },\n-                        BacktraceSymbol {\n-                            name: Some(b\"std::rt::lang_start\".to_vec()),\n-                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n-                            lineno: Some(400),\n-                        },\n-                    ],\n-                },\n-            ],\n-        })),\n-    };\n-\n-    #[rustfmt::skip]\n-    let expected = \"Backtrace [\\\n-    \\n    { fn: \\\"__rust_maybe_catch_panic\\\" },\\\n-    \\n    { fn: \\\"std::rt::lang_start_internal\\\", file: \\\"rust/rt.rs\\\", line: 300 },\\\n-    \\n    { fn: \\\"std::rt::lang_start\\\", file: \\\"rust/rt.rs\\\", line: 400 },\\\n-    \\n]\";\n-\n-    assert_eq!(format!(\"{:#?}\", backtrace), expected);\n-}"}, {"sha": "287359cd545e312761e8d99471886bd0236cc766", "filename": "library/std/src/backtrace/tests.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,53 @@\n+use super::*;\n+\n+#[test]\n+fn test_debug() {\n+    let backtrace = Backtrace {\n+        inner: Inner::Captured(Mutex::new(Capture {\n+            actual_start: 1,\n+            resolved: true,\n+            frames: vec![\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![BacktraceSymbol {\n+                        name: Some(b\"std::backtrace::Backtrace::create\".to_vec()),\n+                        filename: Some(BytesOrWide::Bytes(b\"rust/backtrace.rs\".to_vec())),\n+                        lineno: Some(100),\n+                    }],\n+                },\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![BacktraceSymbol {\n+                        name: Some(b\"__rust_maybe_catch_panic\".to_vec()),\n+                        filename: None,\n+                        lineno: None,\n+                    }],\n+                },\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![\n+                        BacktraceSymbol {\n+                            name: Some(b\"std::rt::lang_start_internal\".to_vec()),\n+                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                            lineno: Some(300),\n+                        },\n+                        BacktraceSymbol {\n+                            name: Some(b\"std::rt::lang_start\".to_vec()),\n+                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                            lineno: Some(400),\n+                        },\n+                    ],\n+                },\n+            ],\n+        })),\n+    };\n+\n+    #[rustfmt::skip]\n+    let expected = \"Backtrace [\\\n+    \\n    { fn: \\\"__rust_maybe_catch_panic\\\" },\\\n+    \\n    { fn: \\\"std::rt::lang_start_internal\\\", file: \\\"rust/rt.rs\\\", line: 300 },\\\n+    \\n    { fn: \\\"std::rt::lang_start\\\", file: \\\"rust/rt.rs\\\", line: 400 },\\\n+    \\n]\";\n+\n+    assert_eq!(format!(\"{:#?}\", backtrace), expected);\n+}"}, {"sha": "77cc5b93dbb5029a16f76db73c7a0c44efb00d08", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 931, "changes": 933, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,4 +1,5 @@\n-// ignore-tidy-filelength\n+#[cfg(test)]\n+mod tests;\n \n use self::Entry::*;\n \n@@ -2754,933 +2755,3 @@ fn assert_covariance() {\n         d\n     }\n }\n-\n-#[cfg(test)]\n-mod test_map {\n-    use super::Entry::{Occupied, Vacant};\n-    use super::HashMap;\n-    use super::RandomState;\n-    use crate::cell::RefCell;\n-    use rand::{thread_rng, Rng};\n-    use realstd::collections::TryReserveError::*;\n-\n-    // https://github.com/rust-lang/rust/issues/62301\n-    fn _assert_hashmap_is_unwind_safe() {\n-        fn assert_unwind_safe<T: crate::panic::UnwindSafe>() {}\n-        assert_unwind_safe::<HashMap<(), crate::cell::UnsafeCell<()>>>();\n-    }\n-\n-    #[test]\n-    fn test_zero_capacities() {\n-        type HM = HashMap<i32, i32>;\n-\n-        let m = HM::new();\n-        assert_eq!(m.capacity(), 0);\n-\n-        let m = HM::default();\n-        assert_eq!(m.capacity(), 0);\n-\n-        let m = HM::with_hasher(RandomState::new());\n-        assert_eq!(m.capacity(), 0);\n-\n-        let m = HM::with_capacity(0);\n-        assert_eq!(m.capacity(), 0);\n-\n-        let m = HM::with_capacity_and_hasher(0, RandomState::new());\n-        assert_eq!(m.capacity(), 0);\n-\n-        let mut m = HM::new();\n-        m.insert(1, 1);\n-        m.insert(2, 2);\n-        m.remove(&1);\n-        m.remove(&2);\n-        m.shrink_to_fit();\n-        assert_eq!(m.capacity(), 0);\n-\n-        let mut m = HM::new();\n-        m.reserve(0);\n-        assert_eq!(m.capacity(), 0);\n-    }\n-\n-    #[test]\n-    fn test_create_capacity_zero() {\n-        let mut m = HashMap::with_capacity(0);\n-\n-        assert!(m.insert(1, 1).is_none());\n-\n-        assert!(m.contains_key(&1));\n-        assert!(!m.contains_key(&0));\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.len(), 0);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(m.len(), 1);\n-        assert!(m.insert(2, 4).is_none());\n-        assert_eq!(m.len(), 2);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&2).unwrap(), 4);\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let mut m = HashMap::new();\n-        assert_eq!(m.len(), 0);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(m.len(), 1);\n-        assert!(m.insert(2, 4).is_none());\n-        assert_eq!(m.len(), 2);\n-        let m2 = m.clone();\n-        assert_eq!(*m2.get(&1).unwrap(), 2);\n-        assert_eq!(*m2.get(&2).unwrap(), 4);\n-        assert_eq!(m2.len(), 2);\n-    }\n-\n-    thread_local! { static DROP_VECTOR: RefCell<Vec<i32>> = RefCell::new(Vec::new()) }\n-\n-    #[derive(Hash, PartialEq, Eq)]\n-    struct Droppable {\n-        k: usize,\n-    }\n-\n-    impl Droppable {\n-        fn new(k: usize) -> Droppable {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[k] += 1;\n-            });\n-\n-            Droppable { k }\n-        }\n-    }\n-\n-    impl Drop for Droppable {\n-        fn drop(&mut self) {\n-            DROP_VECTOR.with(|slot| {\n-                slot.borrow_mut()[self.k] -= 1;\n-            });\n-        }\n-    }\n-\n-    impl Clone for Droppable {\n-        fn clone(&self) -> Droppable {\n-            Droppable::new(self.k)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drops() {\n-        DROP_VECTOR.with(|slot| {\n-            *slot.borrow_mut() = vec![0; 200];\n-        });\n-\n-        {\n-            let mut m = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Droppable::new(i);\n-                let d2 = Droppable::new(i + 100);\n-                m.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for i in 0..50 {\n-                let k = Droppable::new(i);\n-                let v = m.remove(&k);\n-\n-                assert!(v.is_some());\n-\n-                DROP_VECTOR.with(|v| {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i + 100], 1);\n-                });\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..50 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                    assert_eq!(v.borrow()[i + 100], 0);\n-                }\n-\n-                for i in 50..100 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                    assert_eq!(v.borrow()[i + 100], 1);\n-                }\n-            });\n-        }\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_into_iter_drops() {\n-        DROP_VECTOR.with(|v| {\n-            *v.borrow_mut() = vec![0; 200];\n-        });\n-\n-        let hm = {\n-            let mut hm = HashMap::new();\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 0);\n-                }\n-            });\n-\n-            for i in 0..100 {\n-                let d1 = Droppable::new(i);\n-                let d2 = Droppable::new(i + 100);\n-                hm.insert(d1, d2);\n-            }\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            hm\n-        };\n-\n-        // By the way, ensure that cloning doesn't screw up the dropping.\n-        drop(hm.clone());\n-\n-        {\n-            let mut half = hm.into_iter().take(50);\n-\n-            DROP_VECTOR.with(|v| {\n-                for i in 0..200 {\n-                    assert_eq!(v.borrow()[i], 1);\n-                }\n-            });\n-\n-            for _ in half.by_ref() {}\n-\n-            DROP_VECTOR.with(|v| {\n-                let nk = (0..100).filter(|&i| v.borrow()[i] == 1).count();\n-\n-                let nv = (0..100).filter(|&i| v.borrow()[i + 100] == 1).count();\n-\n-                assert_eq!(nk, 50);\n-                assert_eq!(nv, 50);\n-            });\n-        };\n-\n-        DROP_VECTOR.with(|v| {\n-            for i in 0..200 {\n-                assert_eq!(v.borrow()[i], 0);\n-            }\n-        });\n-    }\n-\n-    #[test]\n-    fn test_empty_remove() {\n-        let mut m: HashMap<i32, bool> = HashMap::new();\n-        assert_eq!(m.remove(&0), None);\n-    }\n-\n-    #[test]\n-    fn test_empty_entry() {\n-        let mut m: HashMap<i32, bool> = HashMap::new();\n-        match m.entry(0) {\n-            Occupied(_) => panic!(),\n-            Vacant(_) => {}\n-        }\n-        assert!(*m.entry(0).or_insert(true));\n-        assert_eq!(m.len(), 1);\n-    }\n-\n-    #[test]\n-    fn test_empty_iter() {\n-        let mut m: HashMap<i32, bool> = HashMap::new();\n-        assert_eq!(m.drain().next(), None);\n-        assert_eq!(m.keys().next(), None);\n-        assert_eq!(m.values().next(), None);\n-        assert_eq!(m.values_mut().next(), None);\n-        assert_eq!(m.iter().next(), None);\n-        assert_eq!(m.iter_mut().next(), None);\n-        assert_eq!(m.len(), 0);\n-        assert!(m.is_empty());\n-        assert_eq!(m.into_iter().next(), None);\n-    }\n-\n-    #[test]\n-    fn test_lots_of_insertions() {\n-        let mut m = HashMap::new();\n-\n-        // Try this a few times to make sure we never screw up the hashmap's\n-        // internal state.\n-        for _ in 0..10 {\n-            assert!(m.is_empty());\n-\n-            for i in 1..1001 {\n-                assert!(m.insert(i, i).is_none());\n-\n-                for j in 1..=i {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, Some(&j));\n-                }\n-\n-                for j in i + 1..1001 {\n-                    let r = m.get(&j);\n-                    assert_eq!(r, None);\n-                }\n-            }\n-\n-            for i in 1001..2001 {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            // remove forwards\n-            for i in 1..1001 {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in 1..=i {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in i + 1..1001 {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-\n-            for i in 1..1001 {\n-                assert!(!m.contains_key(&i));\n-            }\n-\n-            for i in 1..1001 {\n-                assert!(m.insert(i, i).is_none());\n-            }\n-\n-            // remove backwards\n-            for i in (1..1001).rev() {\n-                assert!(m.remove(&i).is_some());\n-\n-                for j in i..1001 {\n-                    assert!(!m.contains_key(&j));\n-                }\n-\n-                for j in 1..i {\n-                    assert!(m.contains_key(&j));\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_find_mut() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 12).is_none());\n-        assert!(m.insert(2, 8).is_none());\n-        assert!(m.insert(5, 14).is_none());\n-        let new = 100;\n-        match m.get_mut(&5) {\n-            None => panic!(),\n-            Some(x) => *x = new,\n-        }\n-        assert_eq!(m.get(&5), Some(&new));\n-    }\n-\n-    #[test]\n-    fn test_insert_overwrite() {\n-        let mut m = HashMap::new();\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(!m.insert(1, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_insert_conflicts() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(m.insert(5, 3).is_none());\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-    }\n-\n-    #[test]\n-    fn test_conflict_remove() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert!(m.insert(5, 3).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert!(m.insert(9, 4).is_none());\n-        assert_eq!(*m.get(&1).unwrap(), 2);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert!(m.remove(&1).is_some());\n-        assert_eq!(*m.get(&9).unwrap(), 4);\n-        assert_eq!(*m.get(&5).unwrap(), 3);\n-    }\n-\n-    #[test]\n-    fn test_is_empty() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1, 2).is_none());\n-        assert!(!m.is_empty());\n-        assert!(m.remove(&1).is_some());\n-        assert!(m.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut m = HashMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.remove(&1), Some(2));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_remove_entry() {\n-        let mut m = HashMap::new();\n-        m.insert(1, 2);\n-        assert_eq!(m.remove_entry(&1), Some((1, 2)));\n-        assert_eq!(m.remove(&1), None);\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut m = HashMap::with_capacity(4);\n-        for i in 0..32 {\n-            assert!(m.insert(i, i * 2).is_none());\n-        }\n-        assert_eq!(m.len(), 32);\n-\n-        let mut observed: u32 = 0;\n-\n-        for (k, v) in &m {\n-            assert_eq!(*v, *k * 2);\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let keys: Vec<_> = map.keys().cloned().collect();\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let values: Vec<_> = map.values().cloned().collect();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_values_mut() {\n-        let vec = vec![(1, 1), (2, 2), (3, 3)];\n-        let mut map: HashMap<_, _> = vec.into_iter().collect();\n-        for value in map.values_mut() {\n-            *value = (*value) * 2\n-        }\n-        let values: Vec<_> = map.values().cloned().collect();\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&2));\n-        assert!(values.contains(&4));\n-        assert!(values.contains(&6));\n-    }\n-\n-    #[test]\n-    fn test_into_keys() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let keys: Vec<_> = map.into_keys().collect();\n-\n-        assert_eq!(keys.len(), 3);\n-        assert!(keys.contains(&1));\n-        assert!(keys.contains(&2));\n-        assert!(keys.contains(&3));\n-    }\n-\n-    #[test]\n-    fn test_into_values() {\n-        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n-        let map: HashMap<_, _> = vec.into_iter().collect();\n-        let values: Vec<_> = map.into_values().collect();\n-\n-        assert_eq!(values.len(), 3);\n-        assert!(values.contains(&'a'));\n-        assert!(values.contains(&'b'));\n-        assert!(values.contains(&'c'));\n-    }\n-\n-    #[test]\n-    fn test_find() {\n-        let mut m = HashMap::new();\n-        assert!(m.get(&1).is_none());\n-        m.insert(1, 2);\n-        match m.get(&1) {\n-            None => panic!(),\n-            Some(v) => assert_eq!(*v, 2),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        let mut m1 = HashMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n-\n-        let mut m2 = HashMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n-\n-        assert!(m1 != m2);\n-\n-        m2.insert(3, 4);\n-\n-        assert_eq!(m1, m2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut map = HashMap::new();\n-        let empty: HashMap<i32, i32> = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(3, 4);\n-\n-        let map_str = format!(\"{:?}\", map);\n-\n-        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_reserve_shrink_to_fit() {\n-        let mut m = HashMap::new();\n-        m.insert(0, 0);\n-        m.remove(&0);\n-        assert!(m.capacity() >= m.len());\n-        for i in 0..128 {\n-            m.insert(i, i);\n-        }\n-        m.reserve(256);\n-\n-        let usable_cap = m.capacity();\n-        for i in 128..(128 + 256) {\n-            m.insert(i, i);\n-            assert_eq!(m.capacity(), usable_cap);\n-        }\n-\n-        for i in 100..(128 + 256) {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-\n-        assert_eq!(m.len(), 100);\n-        assert!(!m.is_empty());\n-        assert!(m.capacity() >= m.len());\n-\n-        for i in 0..100 {\n-            assert_eq!(m.remove(&i), Some(i));\n-        }\n-        m.shrink_to_fit();\n-        m.insert(0, 0);\n-\n-        assert_eq!(m.len(), 1);\n-        assert!(m.capacity() >= m.len());\n-        assert_eq!(m.remove(&0), Some(0));\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [(1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        for &(k, v) in &xs {\n-            assert_eq!(map.get(&k), Some(&v));\n-        }\n-\n-        assert_eq!(map.iter().len(), xs.len() - 1);\n-    }\n-\n-    #[test]\n-    fn test_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_mut_size_hint() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.size_hint(), (3, Some(3)));\n-    }\n-\n-    #[test]\n-    fn test_iter_mut_len() {\n-        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        let mut iter = map.iter_mut();\n-\n-        for _ in iter.by_ref().take(3) {}\n-\n-        assert_eq!(iter.len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_index() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        assert_eq!(map[&2], 1);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_index_nonexistent() {\n-        let mut map = HashMap::new();\n-\n-        map.insert(1, 2);\n-        map.insert(2, 1);\n-        map.insert(3, 4);\n-\n-        map[&4];\n-    }\n-\n-    #[test]\n-    fn test_entry() {\n-        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        // Existing key (insert)\n-        match map.entry(1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        assert_eq!(map.get(&1).unwrap(), &100);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (update)\n-        match map.entry(2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                let new_v = (*v) * 10;\n-                *v = new_v;\n-            }\n-        }\n-        assert_eq!(map.get(&2).unwrap(), &200);\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        match map.entry(3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove(), 30);\n-            }\n-        }\n-        assert_eq!(map.get(&3), None);\n-        assert_eq!(map.len(), 5);\n-\n-        // Inexistent key (insert)\n-        match map.entry(10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(*view.insert(1000), 1000);\n-            }\n-        }\n-        assert_eq!(map.get(&10).unwrap(), &1000);\n-        assert_eq!(map.len(), 6);\n-    }\n-\n-    #[test]\n-    fn test_entry_take_doesnt_corrupt() {\n-        #![allow(deprecated)] //rand\n-        // Test for #19292\n-        fn check(m: &HashMap<i32, ()>) {\n-            for k in m.keys() {\n-                assert!(m.contains_key(k), \"{} is in keys() but not in the map?\", k);\n-            }\n-        }\n-\n-        let mut m = HashMap::new();\n-        let mut rng = thread_rng();\n-\n-        // Populate the map with some items.\n-        for _ in 0..50 {\n-            let x = rng.gen_range(-10, 10);\n-            m.insert(x, ());\n-        }\n-\n-        for _ in 0..1000 {\n-            let x = rng.gen_range(-10, 10);\n-            match m.entry(x) {\n-                Vacant(_) => {}\n-                Occupied(e) => {\n-                    e.remove();\n-                }\n-            }\n-\n-            check(&m);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_extend_ref() {\n-        let mut a = HashMap::new();\n-        a.insert(1, \"one\");\n-        let mut b = HashMap::new();\n-        b.insert(2, \"two\");\n-        b.insert(3, \"three\");\n-\n-        a.extend(&b);\n-\n-        assert_eq!(a.len(), 3);\n-        assert_eq!(a[&1], \"one\");\n-        assert_eq!(a[&2], \"two\");\n-        assert_eq!(a[&3], \"three\");\n-    }\n-\n-    #[test]\n-    fn test_capacity_not_less_than_len() {\n-        let mut a = HashMap::new();\n-        let mut item = 0;\n-\n-        for _ in 0..116 {\n-            a.insert(item, 0);\n-            item += 1;\n-        }\n-\n-        assert!(a.capacity() > a.len());\n-\n-        let free = a.capacity() - a.len();\n-        for _ in 0..free {\n-            a.insert(item, 0);\n-            item += 1;\n-        }\n-\n-        assert_eq!(a.len(), a.capacity());\n-\n-        // Insert at capacity should cause allocation.\n-        a.insert(item, 0);\n-        assert!(a.capacity() > a.len());\n-    }\n-\n-    #[test]\n-    fn test_occupied_entry_key() {\n-        let mut a = HashMap::new();\n-        let key = \"hello there\";\n-        let value = \"value goes here\";\n-        assert!(a.is_empty());\n-        a.insert(key.clone(), value.clone());\n-        assert_eq!(a.len(), 1);\n-        assert_eq!(a[key], value);\n-\n-        match a.entry(key.clone()) {\n-            Vacant(_) => panic!(),\n-            Occupied(e) => assert_eq!(key, *e.key()),\n-        }\n-        assert_eq!(a.len(), 1);\n-        assert_eq!(a[key], value);\n-    }\n-\n-    #[test]\n-    fn test_vacant_entry_key() {\n-        let mut a = HashMap::new();\n-        let key = \"hello there\";\n-        let value = \"value goes here\";\n-\n-        assert!(a.is_empty());\n-        match a.entry(key.clone()) {\n-            Occupied(_) => panic!(),\n-            Vacant(e) => {\n-                assert_eq!(key, *e.key());\n-                e.insert(value.clone());\n-            }\n-        }\n-        assert_eq!(a.len(), 1);\n-        assert_eq!(a[key], value);\n-    }\n-\n-    #[test]\n-    fn test_retain() {\n-        let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n-\n-        map.retain(|&k, _| k % 2 == 0);\n-        assert_eq!(map.len(), 50);\n-        assert_eq!(map[&2], 20);\n-        assert_eq!(map[&4], 40);\n-        assert_eq!(map[&6], 60);\n-    }\n-\n-    #[test]\n-    fn test_try_reserve() {\n-        let mut empty_bytes: HashMap<u8, u8> = HashMap::new();\n-\n-        const MAX_USIZE: usize = usize::MAX;\n-\n-        if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\");\n-        }\n-\n-        if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n-        } else {\n-            panic!(\"usize::MAX / 8 should trigger an OOM!\")\n-        }\n-    }\n-\n-    #[test]\n-    fn test_raw_entry() {\n-        use super::RawEntryMut::{Occupied, Vacant};\n-\n-        let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n-\n-        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n-\n-        let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n-            use core::hash::{BuildHasher, Hash, Hasher};\n-\n-            let mut hasher = map.hasher().build_hasher();\n-            k.hash(&mut hasher);\n-            hasher.finish()\n-        };\n-\n-        // Existing key (insert)\n-        match map.raw_entry_mut().from_key(&1) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                assert_eq!(view.get(), &10);\n-                assert_eq!(view.insert(100), 10);\n-            }\n-        }\n-        let hash1 = compute_hash(&map, 1);\n-        assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n-        assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n-        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (update)\n-        match map.raw_entry_mut().from_key(&2) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(mut view) => {\n-                let v = view.get_mut();\n-                let new_v = (*v) * 10;\n-                *v = new_v;\n-            }\n-        }\n-        let hash2 = compute_hash(&map, 2);\n-        assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n-        assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n-        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n-        assert_eq!(map.len(), 6);\n-\n-        // Existing key (take)\n-        let hash3 = compute_hash(&map, 3);\n-        match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n-            Vacant(_) => unreachable!(),\n-            Occupied(view) => {\n-                assert_eq!(view.remove_entry(), (3, 30));\n-            }\n-        }\n-        assert_eq!(map.raw_entry().from_key(&3), None);\n-        assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n-        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n-        assert_eq!(map.len(), 5);\n-\n-        // Nonexistent key (insert)\n-        match map.raw_entry_mut().from_key(&10) {\n-            Occupied(_) => unreachable!(),\n-            Vacant(view) => {\n-                assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n-            }\n-        }\n-        assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n-        assert_eq!(map.len(), 6);\n-\n-        // Ensure all lookup methods produce equivalent results.\n-        for k in 0..12 {\n-            let hash = compute_hash(&map, k);\n-            let v = map.get(&k).cloned();\n-            let kv = v.as_ref().map(|v| (&k, v));\n-\n-            assert_eq!(map.raw_entry().from_key(&k), kv);\n-            assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n-            assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n-\n-            match map.raw_entry_mut().from_key(&k) {\n-                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n-                Vacant(_) => assert_eq!(v, None),\n-            }\n-            match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n-                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n-                Vacant(_) => assert_eq!(v, None),\n-            }\n-            match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n-                Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n-                Vacant(_) => assert_eq!(v, None),\n-            }\n-        }\n-    }\n-}"}, {"sha": "4283d80b78e6444106ed9173c71d129ef8bd59b9", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "added", "additions": 926, "deletions": 0, "changes": 926, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,926 @@\n+use super::Entry::{Occupied, Vacant};\n+use super::HashMap;\n+use super::RandomState;\n+use crate::cell::RefCell;\n+use rand::{thread_rng, Rng};\n+use realstd::collections::TryReserveError::*;\n+\n+// https://github.com/rust-lang/rust/issues/62301\n+fn _assert_hashmap_is_unwind_safe() {\n+    fn assert_unwind_safe<T: crate::panic::UnwindSafe>() {}\n+    assert_unwind_safe::<HashMap<(), crate::cell::UnsafeCell<()>>>();\n+}\n+\n+#[test]\n+fn test_zero_capacities() {\n+    type HM = HashMap<i32, i32>;\n+\n+    let m = HM::new();\n+    assert_eq!(m.capacity(), 0);\n+\n+    let m = HM::default();\n+    assert_eq!(m.capacity(), 0);\n+\n+    let m = HM::with_hasher(RandomState::new());\n+    assert_eq!(m.capacity(), 0);\n+\n+    let m = HM::with_capacity(0);\n+    assert_eq!(m.capacity(), 0);\n+\n+    let m = HM::with_capacity_and_hasher(0, RandomState::new());\n+    assert_eq!(m.capacity(), 0);\n+\n+    let mut m = HM::new();\n+    m.insert(1, 1);\n+    m.insert(2, 2);\n+    m.remove(&1);\n+    m.remove(&2);\n+    m.shrink_to_fit();\n+    assert_eq!(m.capacity(), 0);\n+\n+    let mut m = HM::new();\n+    m.reserve(0);\n+    assert_eq!(m.capacity(), 0);\n+}\n+\n+#[test]\n+fn test_create_capacity_zero() {\n+    let mut m = HashMap::with_capacity(0);\n+\n+    assert!(m.insert(1, 1).is_none());\n+\n+    assert!(m.contains_key(&1));\n+    assert!(!m.contains_key(&0));\n+}\n+\n+#[test]\n+fn test_insert() {\n+    let mut m = HashMap::new();\n+    assert_eq!(m.len(), 0);\n+    assert!(m.insert(1, 2).is_none());\n+    assert_eq!(m.len(), 1);\n+    assert!(m.insert(2, 4).is_none());\n+    assert_eq!(m.len(), 2);\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+    assert_eq!(*m.get(&2).unwrap(), 4);\n+}\n+\n+#[test]\n+fn test_clone() {\n+    let mut m = HashMap::new();\n+    assert_eq!(m.len(), 0);\n+    assert!(m.insert(1, 2).is_none());\n+    assert_eq!(m.len(), 1);\n+    assert!(m.insert(2, 4).is_none());\n+    assert_eq!(m.len(), 2);\n+    let m2 = m.clone();\n+    assert_eq!(*m2.get(&1).unwrap(), 2);\n+    assert_eq!(*m2.get(&2).unwrap(), 4);\n+    assert_eq!(m2.len(), 2);\n+}\n+\n+thread_local! { static DROP_VECTOR: RefCell<Vec<i32>> = RefCell::new(Vec::new()) }\n+\n+#[derive(Hash, PartialEq, Eq)]\n+struct Droppable {\n+    k: usize,\n+}\n+\n+impl Droppable {\n+    fn new(k: usize) -> Droppable {\n+        DROP_VECTOR.with(|slot| {\n+            slot.borrow_mut()[k] += 1;\n+        });\n+\n+        Droppable { k }\n+    }\n+}\n+\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        DROP_VECTOR.with(|slot| {\n+            slot.borrow_mut()[self.k] -= 1;\n+        });\n+    }\n+}\n+\n+impl Clone for Droppable {\n+    fn clone(&self) -> Droppable {\n+        Droppable::new(self.k)\n+    }\n+}\n+\n+#[test]\n+fn test_drops() {\n+    DROP_VECTOR.with(|slot| {\n+        *slot.borrow_mut() = vec![0; 200];\n+    });\n+\n+    {\n+        let mut m = HashMap::new();\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 0);\n+            }\n+        });\n+\n+        for i in 0..100 {\n+            let d1 = Droppable::new(i);\n+            let d2 = Droppable::new(i + 100);\n+            m.insert(d1, d2);\n+        }\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 1);\n+            }\n+        });\n+\n+        for i in 0..50 {\n+            let k = Droppable::new(i);\n+            let v = m.remove(&k);\n+\n+            assert!(v.is_some());\n+\n+            DROP_VECTOR.with(|v| {\n+                assert_eq!(v.borrow()[i], 1);\n+                assert_eq!(v.borrow()[i + 100], 1);\n+            });\n+        }\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..50 {\n+                assert_eq!(v.borrow()[i], 0);\n+                assert_eq!(v.borrow()[i + 100], 0);\n+            }\n+\n+            for i in 50..100 {\n+                assert_eq!(v.borrow()[i], 1);\n+                assert_eq!(v.borrow()[i + 100], 1);\n+            }\n+        });\n+    }\n+\n+    DROP_VECTOR.with(|v| {\n+        for i in 0..200 {\n+            assert_eq!(v.borrow()[i], 0);\n+        }\n+    });\n+}\n+\n+#[test]\n+fn test_into_iter_drops() {\n+    DROP_VECTOR.with(|v| {\n+        *v.borrow_mut() = vec![0; 200];\n+    });\n+\n+    let hm = {\n+        let mut hm = HashMap::new();\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 0);\n+            }\n+        });\n+\n+        for i in 0..100 {\n+            let d1 = Droppable::new(i);\n+            let d2 = Droppable::new(i + 100);\n+            hm.insert(d1, d2);\n+        }\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 1);\n+            }\n+        });\n+\n+        hm\n+    };\n+\n+    // By the way, ensure that cloning doesn't screw up the dropping.\n+    drop(hm.clone());\n+\n+    {\n+        let mut half = hm.into_iter().take(50);\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 1);\n+            }\n+        });\n+\n+        for _ in half.by_ref() {}\n+\n+        DROP_VECTOR.with(|v| {\n+            let nk = (0..100).filter(|&i| v.borrow()[i] == 1).count();\n+\n+            let nv = (0..100).filter(|&i| v.borrow()[i + 100] == 1).count();\n+\n+            assert_eq!(nk, 50);\n+            assert_eq!(nv, 50);\n+        });\n+    };\n+\n+    DROP_VECTOR.with(|v| {\n+        for i in 0..200 {\n+            assert_eq!(v.borrow()[i], 0);\n+        }\n+    });\n+}\n+\n+#[test]\n+fn test_empty_remove() {\n+    let mut m: HashMap<i32, bool> = HashMap::new();\n+    assert_eq!(m.remove(&0), None);\n+}\n+\n+#[test]\n+fn test_empty_entry() {\n+    let mut m: HashMap<i32, bool> = HashMap::new();\n+    match m.entry(0) {\n+        Occupied(_) => panic!(),\n+        Vacant(_) => {}\n+    }\n+    assert!(*m.entry(0).or_insert(true));\n+    assert_eq!(m.len(), 1);\n+}\n+\n+#[test]\n+fn test_empty_iter() {\n+    let mut m: HashMap<i32, bool> = HashMap::new();\n+    assert_eq!(m.drain().next(), None);\n+    assert_eq!(m.keys().next(), None);\n+    assert_eq!(m.values().next(), None);\n+    assert_eq!(m.values_mut().next(), None);\n+    assert_eq!(m.iter().next(), None);\n+    assert_eq!(m.iter_mut().next(), None);\n+    assert_eq!(m.len(), 0);\n+    assert!(m.is_empty());\n+    assert_eq!(m.into_iter().next(), None);\n+}\n+\n+#[test]\n+fn test_lots_of_insertions() {\n+    let mut m = HashMap::new();\n+\n+    // Try this a few times to make sure we never screw up the hashmap's\n+    // internal state.\n+    for _ in 0..10 {\n+        assert!(m.is_empty());\n+\n+        for i in 1..1001 {\n+            assert!(m.insert(i, i).is_none());\n+\n+            for j in 1..=i {\n+                let r = m.get(&j);\n+                assert_eq!(r, Some(&j));\n+            }\n+\n+            for j in i + 1..1001 {\n+                let r = m.get(&j);\n+                assert_eq!(r, None);\n+            }\n+        }\n+\n+        for i in 1001..2001 {\n+            assert!(!m.contains_key(&i));\n+        }\n+\n+        // remove forwards\n+        for i in 1..1001 {\n+            assert!(m.remove(&i).is_some());\n+\n+            for j in 1..=i {\n+                assert!(!m.contains_key(&j));\n+            }\n+\n+            for j in i + 1..1001 {\n+                assert!(m.contains_key(&j));\n+            }\n+        }\n+\n+        for i in 1..1001 {\n+            assert!(!m.contains_key(&i));\n+        }\n+\n+        for i in 1..1001 {\n+            assert!(m.insert(i, i).is_none());\n+        }\n+\n+        // remove backwards\n+        for i in (1..1001).rev() {\n+            assert!(m.remove(&i).is_some());\n+\n+            for j in i..1001 {\n+                assert!(!m.contains_key(&j));\n+            }\n+\n+            for j in 1..i {\n+                assert!(m.contains_key(&j));\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_find_mut() {\n+    let mut m = HashMap::new();\n+    assert!(m.insert(1, 12).is_none());\n+    assert!(m.insert(2, 8).is_none());\n+    assert!(m.insert(5, 14).is_none());\n+    let new = 100;\n+    match m.get_mut(&5) {\n+        None => panic!(),\n+        Some(x) => *x = new,\n+    }\n+    assert_eq!(m.get(&5), Some(&new));\n+}\n+\n+#[test]\n+fn test_insert_overwrite() {\n+    let mut m = HashMap::new();\n+    assert!(m.insert(1, 2).is_none());\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+    assert!(!m.insert(1, 3).is_none());\n+    assert_eq!(*m.get(&1).unwrap(), 3);\n+}\n+\n+#[test]\n+fn test_insert_conflicts() {\n+    let mut m = HashMap::with_capacity(4);\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(m.insert(5, 3).is_none());\n+    assert!(m.insert(9, 4).is_none());\n+    assert_eq!(*m.get(&9).unwrap(), 4);\n+    assert_eq!(*m.get(&5).unwrap(), 3);\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+}\n+\n+#[test]\n+fn test_conflict_remove() {\n+    let mut m = HashMap::with_capacity(4);\n+    assert!(m.insert(1, 2).is_none());\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+    assert!(m.insert(5, 3).is_none());\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+    assert_eq!(*m.get(&5).unwrap(), 3);\n+    assert!(m.insert(9, 4).is_none());\n+    assert_eq!(*m.get(&1).unwrap(), 2);\n+    assert_eq!(*m.get(&5).unwrap(), 3);\n+    assert_eq!(*m.get(&9).unwrap(), 4);\n+    assert!(m.remove(&1).is_some());\n+    assert_eq!(*m.get(&9).unwrap(), 4);\n+    assert_eq!(*m.get(&5).unwrap(), 3);\n+}\n+\n+#[test]\n+fn test_is_empty() {\n+    let mut m = HashMap::with_capacity(4);\n+    assert!(m.insert(1, 2).is_none());\n+    assert!(!m.is_empty());\n+    assert!(m.remove(&1).is_some());\n+    assert!(m.is_empty());\n+}\n+\n+#[test]\n+fn test_remove() {\n+    let mut m = HashMap::new();\n+    m.insert(1, 2);\n+    assert_eq!(m.remove(&1), Some(2));\n+    assert_eq!(m.remove(&1), None);\n+}\n+\n+#[test]\n+fn test_remove_entry() {\n+    let mut m = HashMap::new();\n+    m.insert(1, 2);\n+    assert_eq!(m.remove_entry(&1), Some((1, 2)));\n+    assert_eq!(m.remove(&1), None);\n+}\n+\n+#[test]\n+fn test_iterate() {\n+    let mut m = HashMap::with_capacity(4);\n+    for i in 0..32 {\n+        assert!(m.insert(i, i * 2).is_none());\n+    }\n+    assert_eq!(m.len(), 32);\n+\n+    let mut observed: u32 = 0;\n+\n+    for (k, v) in &m {\n+        assert_eq!(*v, *k * 2);\n+        observed |= 1 << *k;\n+    }\n+    assert_eq!(observed, 0xFFFF_FFFF);\n+}\n+\n+#[test]\n+fn test_keys() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: HashMap<_, _> = vec.into_iter().collect();\n+    let keys: Vec<_> = map.keys().cloned().collect();\n+    assert_eq!(keys.len(), 3);\n+    assert!(keys.contains(&1));\n+    assert!(keys.contains(&2));\n+    assert!(keys.contains(&3));\n+}\n+\n+#[test]\n+fn test_values() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: HashMap<_, _> = vec.into_iter().collect();\n+    let values: Vec<_> = map.values().cloned().collect();\n+    assert_eq!(values.len(), 3);\n+    assert!(values.contains(&'a'));\n+    assert!(values.contains(&'b'));\n+    assert!(values.contains(&'c'));\n+}\n+\n+#[test]\n+fn test_values_mut() {\n+    let vec = vec![(1, 1), (2, 2), (3, 3)];\n+    let mut map: HashMap<_, _> = vec.into_iter().collect();\n+    for value in map.values_mut() {\n+        *value = (*value) * 2\n+    }\n+    let values: Vec<_> = map.values().cloned().collect();\n+    assert_eq!(values.len(), 3);\n+    assert!(values.contains(&2));\n+    assert!(values.contains(&4));\n+    assert!(values.contains(&6));\n+}\n+\n+#[test]\n+fn test_into_keys() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: HashMap<_, _> = vec.into_iter().collect();\n+    let keys: Vec<_> = map.into_keys().collect();\n+\n+    assert_eq!(keys.len(), 3);\n+    assert!(keys.contains(&1));\n+    assert!(keys.contains(&2));\n+    assert!(keys.contains(&3));\n+}\n+\n+#[test]\n+fn test_into_values() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: HashMap<_, _> = vec.into_iter().collect();\n+    let values: Vec<_> = map.into_values().collect();\n+\n+    assert_eq!(values.len(), 3);\n+    assert!(values.contains(&'a'));\n+    assert!(values.contains(&'b'));\n+    assert!(values.contains(&'c'));\n+}\n+\n+#[test]\n+fn test_find() {\n+    let mut m = HashMap::new();\n+    assert!(m.get(&1).is_none());\n+    m.insert(1, 2);\n+    match m.get(&1) {\n+        None => panic!(),\n+        Some(v) => assert_eq!(*v, 2),\n+    }\n+}\n+\n+#[test]\n+fn test_eq() {\n+    let mut m1 = HashMap::new();\n+    m1.insert(1, 2);\n+    m1.insert(2, 3);\n+    m1.insert(3, 4);\n+\n+    let mut m2 = HashMap::new();\n+    m2.insert(1, 2);\n+    m2.insert(2, 3);\n+\n+    assert!(m1 != m2);\n+\n+    m2.insert(3, 4);\n+\n+    assert_eq!(m1, m2);\n+}\n+\n+#[test]\n+fn test_show() {\n+    let mut map = HashMap::new();\n+    let empty: HashMap<i32, i32> = HashMap::new();\n+\n+    map.insert(1, 2);\n+    map.insert(3, 4);\n+\n+    let map_str = format!(\"{:?}\", map);\n+\n+    assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n+    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n+}\n+\n+#[test]\n+fn test_reserve_shrink_to_fit() {\n+    let mut m = HashMap::new();\n+    m.insert(0, 0);\n+    m.remove(&0);\n+    assert!(m.capacity() >= m.len());\n+    for i in 0..128 {\n+        m.insert(i, i);\n+    }\n+    m.reserve(256);\n+\n+    let usable_cap = m.capacity();\n+    for i in 128..(128 + 256) {\n+        m.insert(i, i);\n+        assert_eq!(m.capacity(), usable_cap);\n+    }\n+\n+    for i in 100..(128 + 256) {\n+        assert_eq!(m.remove(&i), Some(i));\n+    }\n+    m.shrink_to_fit();\n+\n+    assert_eq!(m.len(), 100);\n+    assert!(!m.is_empty());\n+    assert!(m.capacity() >= m.len());\n+\n+    for i in 0..100 {\n+        assert_eq!(m.remove(&i), Some(i));\n+    }\n+    m.shrink_to_fit();\n+    m.insert(0, 0);\n+\n+    assert_eq!(m.len(), 1);\n+    assert!(m.capacity() >= m.len());\n+    assert_eq!(m.remove(&0), Some(0));\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    let xs = [(1, 1), (2, 2), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+    let map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    for &(k, v) in &xs {\n+        assert_eq!(map.get(&k), Some(&v));\n+    }\n+\n+    assert_eq!(map.iter().len(), xs.len() - 1);\n+}\n+\n+#[test]\n+fn test_size_hint() {\n+    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+    let map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    let mut iter = map.iter();\n+\n+    for _ in iter.by_ref().take(3) {}\n+\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n+}\n+\n+#[test]\n+fn test_iter_len() {\n+    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+    let map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    let mut iter = map.iter();\n+\n+    for _ in iter.by_ref().take(3) {}\n+\n+    assert_eq!(iter.len(), 3);\n+}\n+\n+#[test]\n+fn test_mut_size_hint() {\n+    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    let mut iter = map.iter_mut();\n+\n+    for _ in iter.by_ref().take(3) {}\n+\n+    assert_eq!(iter.size_hint(), (3, Some(3)));\n+}\n+\n+#[test]\n+fn test_iter_mut_len() {\n+    let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    let mut iter = map.iter_mut();\n+\n+    for _ in iter.by_ref().take(3) {}\n+\n+    assert_eq!(iter.len(), 3);\n+}\n+\n+#[test]\n+fn test_index() {\n+    let mut map = HashMap::new();\n+\n+    map.insert(1, 2);\n+    map.insert(2, 1);\n+    map.insert(3, 4);\n+\n+    assert_eq!(map[&2], 1);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_index_nonexistent() {\n+    let mut map = HashMap::new();\n+\n+    map.insert(1, 2);\n+    map.insert(2, 1);\n+    map.insert(3, 4);\n+\n+    map[&4];\n+}\n+\n+#[test]\n+fn test_entry() {\n+    let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    // Existing key (insert)\n+    match map.entry(1) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            assert_eq!(view.get(), &10);\n+            assert_eq!(view.insert(100), 10);\n+        }\n+    }\n+    assert_eq!(map.get(&1).unwrap(), &100);\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (update)\n+    match map.entry(2) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            let v = view.get_mut();\n+            let new_v = (*v) * 10;\n+            *v = new_v;\n+        }\n+    }\n+    assert_eq!(map.get(&2).unwrap(), &200);\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (take)\n+    match map.entry(3) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(view) => {\n+            assert_eq!(view.remove(), 30);\n+        }\n+    }\n+    assert_eq!(map.get(&3), None);\n+    assert_eq!(map.len(), 5);\n+\n+    // Inexistent key (insert)\n+    match map.entry(10) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(view) => {\n+            assert_eq!(*view.insert(1000), 1000);\n+        }\n+    }\n+    assert_eq!(map.get(&10).unwrap(), &1000);\n+    assert_eq!(map.len(), 6);\n+}\n+\n+#[test]\n+fn test_entry_take_doesnt_corrupt() {\n+    #![allow(deprecated)] //rand\n+    // Test for #19292\n+    fn check(m: &HashMap<i32, ()>) {\n+        for k in m.keys() {\n+            assert!(m.contains_key(k), \"{} is in keys() but not in the map?\", k);\n+        }\n+    }\n+\n+    let mut m = HashMap::new();\n+    let mut rng = thread_rng();\n+\n+    // Populate the map with some items.\n+    for _ in 0..50 {\n+        let x = rng.gen_range(-10, 10);\n+        m.insert(x, ());\n+    }\n+\n+    for _ in 0..1000 {\n+        let x = rng.gen_range(-10, 10);\n+        match m.entry(x) {\n+            Vacant(_) => {}\n+            Occupied(e) => {\n+                e.remove();\n+            }\n+        }\n+\n+        check(&m);\n+    }\n+}\n+\n+#[test]\n+fn test_extend_ref() {\n+    let mut a = HashMap::new();\n+    a.insert(1, \"one\");\n+    let mut b = HashMap::new();\n+    b.insert(2, \"two\");\n+    b.insert(3, \"three\");\n+\n+    a.extend(&b);\n+\n+    assert_eq!(a.len(), 3);\n+    assert_eq!(a[&1], \"one\");\n+    assert_eq!(a[&2], \"two\");\n+    assert_eq!(a[&3], \"three\");\n+}\n+\n+#[test]\n+fn test_capacity_not_less_than_len() {\n+    let mut a = HashMap::new();\n+    let mut item = 0;\n+\n+    for _ in 0..116 {\n+        a.insert(item, 0);\n+        item += 1;\n+    }\n+\n+    assert!(a.capacity() > a.len());\n+\n+    let free = a.capacity() - a.len();\n+    for _ in 0..free {\n+        a.insert(item, 0);\n+        item += 1;\n+    }\n+\n+    assert_eq!(a.len(), a.capacity());\n+\n+    // Insert at capacity should cause allocation.\n+    a.insert(item, 0);\n+    assert!(a.capacity() > a.len());\n+}\n+\n+#[test]\n+fn test_occupied_entry_key() {\n+    let mut a = HashMap::new();\n+    let key = \"hello there\";\n+    let value = \"value goes here\";\n+    assert!(a.is_empty());\n+    a.insert(key.clone(), value.clone());\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+\n+    match a.entry(key.clone()) {\n+        Vacant(_) => panic!(),\n+        Occupied(e) => assert_eq!(key, *e.key()),\n+    }\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+}\n+\n+#[test]\n+fn test_vacant_entry_key() {\n+    let mut a = HashMap::new();\n+    let key = \"hello there\";\n+    let value = \"value goes here\";\n+\n+    assert!(a.is_empty());\n+    match a.entry(key.clone()) {\n+        Occupied(_) => panic!(),\n+        Vacant(e) => {\n+            assert_eq!(key, *e.key());\n+            e.insert(value.clone());\n+        }\n+    }\n+    assert_eq!(a.len(), 1);\n+    assert_eq!(a[key], value);\n+}\n+\n+#[test]\n+fn test_retain() {\n+    let mut map: HashMap<i32, i32> = (0..100).map(|x| (x, x * 10)).collect();\n+\n+    map.retain(|&k, _| k % 2 == 0);\n+    assert_eq!(map.len(), 50);\n+    assert_eq!(map[&2], 20);\n+    assert_eq!(map[&4], 40);\n+    assert_eq!(map[&6], 60);\n+}\n+\n+#[test]\n+fn test_try_reserve() {\n+    let mut empty_bytes: HashMap<u8, u8> = HashMap::new();\n+\n+    const MAX_USIZE: usize = usize::MAX;\n+\n+    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n+    } else {\n+        panic!(\"usize::MAX should trigger an overflow!\");\n+    }\n+\n+    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8) {\n+    } else {\n+        panic!(\"usize::MAX / 8 should trigger an OOM!\")\n+    }\n+}\n+\n+#[test]\n+fn test_raw_entry() {\n+    use super::RawEntryMut::{Occupied, Vacant};\n+\n+    let xs = [(1i32, 10i32), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+    let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+    let compute_hash = |map: &HashMap<i32, i32>, k: i32| -> u64 {\n+        use core::hash::{BuildHasher, Hash, Hasher};\n+\n+        let mut hasher = map.hasher().build_hasher();\n+        k.hash(&mut hasher);\n+        hasher.finish()\n+    };\n+\n+    // Existing key (insert)\n+    match map.raw_entry_mut().from_key(&1) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            assert_eq!(view.get(), &10);\n+            assert_eq!(view.insert(100), 10);\n+        }\n+    }\n+    let hash1 = compute_hash(&map, 1);\n+    assert_eq!(map.raw_entry().from_key(&1).unwrap(), (&1, &100));\n+    assert_eq!(map.raw_entry().from_hash(hash1, |k| *k == 1).unwrap(), (&1, &100));\n+    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash1, &1).unwrap(), (&1, &100));\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (update)\n+    match map.raw_entry_mut().from_key(&2) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(mut view) => {\n+            let v = view.get_mut();\n+            let new_v = (*v) * 10;\n+            *v = new_v;\n+        }\n+    }\n+    let hash2 = compute_hash(&map, 2);\n+    assert_eq!(map.raw_entry().from_key(&2).unwrap(), (&2, &200));\n+    assert_eq!(map.raw_entry().from_hash(hash2, |k| *k == 2).unwrap(), (&2, &200));\n+    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash2, &2).unwrap(), (&2, &200));\n+    assert_eq!(map.len(), 6);\n+\n+    // Existing key (take)\n+    let hash3 = compute_hash(&map, 3);\n+    match map.raw_entry_mut().from_key_hashed_nocheck(hash3, &3) {\n+        Vacant(_) => unreachable!(),\n+        Occupied(view) => {\n+            assert_eq!(view.remove_entry(), (3, 30));\n+        }\n+    }\n+    assert_eq!(map.raw_entry().from_key(&3), None);\n+    assert_eq!(map.raw_entry().from_hash(hash3, |k| *k == 3), None);\n+    assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash3, &3), None);\n+    assert_eq!(map.len(), 5);\n+\n+    // Nonexistent key (insert)\n+    match map.raw_entry_mut().from_key(&10) {\n+        Occupied(_) => unreachable!(),\n+        Vacant(view) => {\n+            assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n+        }\n+    }\n+    assert_eq!(map.raw_entry().from_key(&10).unwrap(), (&10, &1000));\n+    assert_eq!(map.len(), 6);\n+\n+    // Ensure all lookup methods produce equivalent results.\n+    for k in 0..12 {\n+        let hash = compute_hash(&map, k);\n+        let v = map.get(&k).cloned();\n+        let kv = v.as_ref().map(|v| (&k, v));\n+\n+        assert_eq!(map.raw_entry().from_key(&k), kv);\n+        assert_eq!(map.raw_entry().from_hash(hash, |q| *q == k), kv);\n+        assert_eq!(map.raw_entry().from_key_hashed_nocheck(hash, &k), kv);\n+\n+        match map.raw_entry_mut().from_key(&k) {\n+            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+            Vacant(_) => assert_eq!(v, None),\n+        }\n+        match map.raw_entry_mut().from_key_hashed_nocheck(hash, &k) {\n+            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+            Vacant(_) => assert_eq!(v, None),\n+        }\n+        match map.raw_entry_mut().from_hash(hash, |q| *q == k) {\n+            Occupied(mut o) => assert_eq!(Some(o.get_key_value()), kv),\n+            Vacant(_) => assert_eq!(v, None),\n+        }\n+    }\n+}"}, {"sha": "8c39725ef3550011917ca3a93c62ee5297246463", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 419, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use crate::borrow::Borrow;\n use crate::collections::TryReserveError;\n use crate::fmt;\n@@ -1579,422 +1582,3 @@ fn assert_covariance() {\n         d\n     }\n }\n-\n-#[cfg(test)]\n-mod test_set {\n-    use super::super::map::RandomState;\n-    use super::HashSet;\n-\n-    #[test]\n-    fn test_zero_capacities() {\n-        type HS = HashSet<i32>;\n-\n-        let s = HS::new();\n-        assert_eq!(s.capacity(), 0);\n-\n-        let s = HS::default();\n-        assert_eq!(s.capacity(), 0);\n-\n-        let s = HS::with_hasher(RandomState::new());\n-        assert_eq!(s.capacity(), 0);\n-\n-        let s = HS::with_capacity(0);\n-        assert_eq!(s.capacity(), 0);\n-\n-        let s = HS::with_capacity_and_hasher(0, RandomState::new());\n-        assert_eq!(s.capacity(), 0);\n-\n-        let mut s = HS::new();\n-        s.insert(1);\n-        s.insert(2);\n-        s.remove(&1);\n-        s.remove(&2);\n-        s.shrink_to_fit();\n-        assert_eq!(s.capacity(), 0);\n-\n-        let mut s = HS::new();\n-        s.reserve(0);\n-        assert_eq!(s.capacity(), 0);\n-    }\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = HashSet::new();\n-        let mut ys = HashSet::new();\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(5));\n-        assert!(ys.insert(11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(xs.insert(7));\n-        assert!(xs.insert(19));\n-        assert!(xs.insert(4));\n-        assert!(ys.insert(2));\n-        assert!(ys.insert(-11));\n-        assert!(xs.is_disjoint(&ys));\n-        assert!(ys.is_disjoint(&xs));\n-        assert!(ys.insert(7));\n-        assert!(!xs.is_disjoint(&ys));\n-        assert!(!ys.is_disjoint(&xs));\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = HashSet::new();\n-        assert!(a.insert(0));\n-        assert!(a.insert(5));\n-        assert!(a.insert(11));\n-        assert!(a.insert(7));\n-\n-        let mut b = HashSet::new();\n-        assert!(b.insert(0));\n-        assert!(b.insert(7));\n-        assert!(b.insert(19));\n-        assert!(b.insert(250));\n-        assert!(b.insert(11));\n-        assert!(b.insert(200));\n-\n-        assert!(!a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(!b.is_superset(&a));\n-\n-        assert!(b.insert(5));\n-\n-        assert!(a.is_subset(&b));\n-        assert!(!a.is_superset(&b));\n-        assert!(!b.is_subset(&a));\n-        assert!(b.is_superset(&a));\n-    }\n-\n-    #[test]\n-    fn test_iterate() {\n-        let mut a = HashSet::new();\n-        for i in 0..32 {\n-            assert!(a.insert(i));\n-        }\n-        let mut observed: u32 = 0;\n-        for k in &a {\n-            observed |= 1 << *k;\n-        }\n-        assert_eq!(observed, 0xFFFF_FFFF);\n-    }\n-\n-    #[test]\n-    fn test_intersection() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-        assert!(a.intersection(&b).next().is_none());\n-\n-        assert!(a.insert(11));\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(77));\n-        assert!(a.insert(103));\n-        assert!(a.insert(5));\n-        assert!(a.insert(-5));\n-\n-        assert!(b.insert(2));\n-        assert!(b.insert(11));\n-        assert!(b.insert(77));\n-        assert!(b.insert(-9));\n-        assert!(b.insert(-42));\n-        assert!(b.insert(5));\n-        assert!(b.insert(3));\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for x in a.intersection(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        assert!(a.insert(9)); // make a bigger than b\n-\n-        i = 0;\n-        for x in a.intersection(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        i = 0;\n-        for x in b.intersection(&a) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for x in a.difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n-        assert!(a.insert(11));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(3));\n-        assert!(b.insert(9));\n-        assert!(b.insert(14));\n-        assert!(b.insert(22));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 5, 11, 14, 22];\n-        for x in a.symmetric_difference(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_union() {\n-        let mut a = HashSet::new();\n-        let mut b = HashSet::new();\n-        assert!(a.union(&b).next().is_none());\n-        assert!(b.union(&a).next().is_none());\n-\n-        assert!(a.insert(1));\n-        assert!(a.insert(3));\n-        assert!(a.insert(11));\n-        assert!(a.insert(16));\n-        assert!(a.insert(19));\n-        assert!(a.insert(24));\n-\n-        assert!(b.insert(-2));\n-        assert!(b.insert(1));\n-        assert!(b.insert(5));\n-        assert!(b.insert(9));\n-        assert!(b.insert(13));\n-        assert!(b.insert(19));\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for x in a.union(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        assert!(a.insert(9)); // make a bigger than b\n-        assert!(a.insert(5));\n-\n-        i = 0;\n-        for x in a.union(&b) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-\n-        i = 0;\n-        for x in b.union(&a) {\n-            assert!(expected.contains(x));\n-            i += 1\n-        }\n-        assert_eq!(i, expected.len());\n-    }\n-\n-    #[test]\n-    fn test_from_iter() {\n-        let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];\n-\n-        let set: HashSet<_> = xs.iter().cloned().collect();\n-\n-        for x in &xs {\n-            assert!(set.contains(x));\n-        }\n-\n-        assert_eq!(set.iter().len(), xs.len() - 1);\n-    }\n-\n-    #[test]\n-    fn test_move_iter() {\n-        let hs = {\n-            let mut hs = HashSet::new();\n-\n-            hs.insert('a');\n-            hs.insert('b');\n-\n-            hs\n-        };\n-\n-        let v = hs.into_iter().collect::<Vec<char>>();\n-        assert!(v == ['a', 'b'] || v == ['b', 'a']);\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        // These constants once happened to expose a bug in insert().\n-        // I'm keeping them around to prevent a regression.\n-        let mut s1 = HashSet::new();\n-\n-        s1.insert(1);\n-        s1.insert(2);\n-        s1.insert(3);\n-\n-        let mut s2 = HashSet::new();\n-\n-        s2.insert(1);\n-        s2.insert(2);\n-\n-        assert!(s1 != s2);\n-\n-        s2.insert(3);\n-\n-        assert_eq!(s1, s2);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let mut set = HashSet::new();\n-        let empty = HashSet::<i32>::new();\n-\n-        set.insert(1);\n-        set.insert(2);\n-\n-        let set_str = format!(\"{:?}\", set);\n-\n-        assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n-    }\n-\n-    #[test]\n-    fn test_trivial_drain() {\n-        let mut s = HashSet::<i32>::new();\n-        for _ in s.drain() {}\n-        assert!(s.is_empty());\n-        drop(s);\n-\n-        let mut s = HashSet::<i32>::new();\n-        drop(s.drain());\n-        assert!(s.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut s: HashSet<_> = (1..100).collect();\n-\n-        // try this a bunch of times to make sure we don't screw up internal state.\n-        for _ in 0..20 {\n-            assert_eq!(s.len(), 99);\n-\n-            {\n-                let mut last_i = 0;\n-                let mut d = s.drain();\n-                for (i, x) in d.by_ref().take(50).enumerate() {\n-                    last_i = i;\n-                    assert!(x != 0);\n-                }\n-                assert_eq!(last_i, 49);\n-            }\n-\n-            for _ in &s {\n-                panic!(\"s should be empty!\");\n-            }\n-\n-            // reset to try again.\n-            s.extend(1..100);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_replace() {\n-        use crate::hash;\n-\n-        #[derive(Debug)]\n-        struct Foo(&'static str, i32);\n-\n-        impl PartialEq for Foo {\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl Eq for Foo {}\n-\n-        impl hash::Hash for Foo {\n-            fn hash<H: hash::Hasher>(&self, h: &mut H) {\n-                self.0.hash(h);\n-            }\n-        }\n-\n-        let mut s = HashSet::new();\n-        assert_eq!(s.replace(Foo(\"a\", 1)), None);\n-        assert_eq!(s.len(), 1);\n-        assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n-        assert_eq!(s.len(), 1);\n-\n-        let mut it = s.iter();\n-        assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_extend_ref() {\n-        let mut a = HashSet::new();\n-        a.insert(1);\n-\n-        a.extend(&[2, 3, 4]);\n-\n-        assert_eq!(a.len(), 4);\n-        assert!(a.contains(&1));\n-        assert!(a.contains(&2));\n-        assert!(a.contains(&3));\n-        assert!(a.contains(&4));\n-\n-        let mut b = HashSet::new();\n-        b.insert(5);\n-        b.insert(6);\n-\n-        a.extend(&b);\n-\n-        assert_eq!(a.len(), 6);\n-        assert!(a.contains(&1));\n-        assert!(a.contains(&2));\n-        assert!(a.contains(&3));\n-        assert!(a.contains(&4));\n-        assert!(a.contains(&5));\n-        assert!(a.contains(&6));\n-    }\n-\n-    #[test]\n-    fn test_retain() {\n-        let xs = [1, 2, 3, 4, 5, 6];\n-        let mut set: HashSet<i32> = xs.iter().cloned().collect();\n-        set.retain(|&k| k % 2 == 0);\n-        assert_eq!(set.len(), 3);\n-        assert!(set.contains(&2));\n-        assert!(set.contains(&4));\n-        assert!(set.contains(&6));\n-    }\n-}"}, {"sha": "3582390cee4bcecc0c53a177fb55493f0ed0ebea", "filename": "library/std/src/collections/hash/set/tests.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,415 @@\n+use super::super::map::RandomState;\n+use super::HashSet;\n+\n+#[test]\n+fn test_zero_capacities() {\n+    type HS = HashSet<i32>;\n+\n+    let s = HS::new();\n+    assert_eq!(s.capacity(), 0);\n+\n+    let s = HS::default();\n+    assert_eq!(s.capacity(), 0);\n+\n+    let s = HS::with_hasher(RandomState::new());\n+    assert_eq!(s.capacity(), 0);\n+\n+    let s = HS::with_capacity(0);\n+    assert_eq!(s.capacity(), 0);\n+\n+    let s = HS::with_capacity_and_hasher(0, RandomState::new());\n+    assert_eq!(s.capacity(), 0);\n+\n+    let mut s = HS::new();\n+    s.insert(1);\n+    s.insert(2);\n+    s.remove(&1);\n+    s.remove(&2);\n+    s.shrink_to_fit();\n+    assert_eq!(s.capacity(), 0);\n+\n+    let mut s = HS::new();\n+    s.reserve(0);\n+    assert_eq!(s.capacity(), 0);\n+}\n+\n+#[test]\n+fn test_disjoint() {\n+    let mut xs = HashSet::new();\n+    let mut ys = HashSet::new();\n+    assert!(xs.is_disjoint(&ys));\n+    assert!(ys.is_disjoint(&xs));\n+    assert!(xs.insert(5));\n+    assert!(ys.insert(11));\n+    assert!(xs.is_disjoint(&ys));\n+    assert!(ys.is_disjoint(&xs));\n+    assert!(xs.insert(7));\n+    assert!(xs.insert(19));\n+    assert!(xs.insert(4));\n+    assert!(ys.insert(2));\n+    assert!(ys.insert(-11));\n+    assert!(xs.is_disjoint(&ys));\n+    assert!(ys.is_disjoint(&xs));\n+    assert!(ys.insert(7));\n+    assert!(!xs.is_disjoint(&ys));\n+    assert!(!ys.is_disjoint(&xs));\n+}\n+\n+#[test]\n+fn test_subset_and_superset() {\n+    let mut a = HashSet::new();\n+    assert!(a.insert(0));\n+    assert!(a.insert(5));\n+    assert!(a.insert(11));\n+    assert!(a.insert(7));\n+\n+    let mut b = HashSet::new();\n+    assert!(b.insert(0));\n+    assert!(b.insert(7));\n+    assert!(b.insert(19));\n+    assert!(b.insert(250));\n+    assert!(b.insert(11));\n+    assert!(b.insert(200));\n+\n+    assert!(!a.is_subset(&b));\n+    assert!(!a.is_superset(&b));\n+    assert!(!b.is_subset(&a));\n+    assert!(!b.is_superset(&a));\n+\n+    assert!(b.insert(5));\n+\n+    assert!(a.is_subset(&b));\n+    assert!(!a.is_superset(&b));\n+    assert!(!b.is_subset(&a));\n+    assert!(b.is_superset(&a));\n+}\n+\n+#[test]\n+fn test_iterate() {\n+    let mut a = HashSet::new();\n+    for i in 0..32 {\n+        assert!(a.insert(i));\n+    }\n+    let mut observed: u32 = 0;\n+    for k in &a {\n+        observed |= 1 << *k;\n+    }\n+    assert_eq!(observed, 0xFFFF_FFFF);\n+}\n+\n+#[test]\n+fn test_intersection() {\n+    let mut a = HashSet::new();\n+    let mut b = HashSet::new();\n+    assert!(a.intersection(&b).next().is_none());\n+\n+    assert!(a.insert(11));\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(77));\n+    assert!(a.insert(103));\n+    assert!(a.insert(5));\n+    assert!(a.insert(-5));\n+\n+    assert!(b.insert(2));\n+    assert!(b.insert(11));\n+    assert!(b.insert(77));\n+    assert!(b.insert(-9));\n+    assert!(b.insert(-42));\n+    assert!(b.insert(5));\n+    assert!(b.insert(3));\n+\n+    let mut i = 0;\n+    let expected = [3, 5, 11, 77];\n+    for x in a.intersection(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    assert!(a.insert(9)); // make a bigger than b\n+\n+    i = 0;\n+    for x in a.intersection(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    i = 0;\n+    for x in b.intersection(&a) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_difference() {\n+    let mut a = HashSet::new();\n+    let mut b = HashSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(5));\n+    assert!(a.insert(9));\n+    assert!(a.insert(11));\n+\n+    assert!(b.insert(3));\n+    assert!(b.insert(9));\n+\n+    let mut i = 0;\n+    let expected = [1, 5, 11];\n+    for x in a.difference(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_symmetric_difference() {\n+    let mut a = HashSet::new();\n+    let mut b = HashSet::new();\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(5));\n+    assert!(a.insert(9));\n+    assert!(a.insert(11));\n+\n+    assert!(b.insert(-2));\n+    assert!(b.insert(3));\n+    assert!(b.insert(9));\n+    assert!(b.insert(14));\n+    assert!(b.insert(22));\n+\n+    let mut i = 0;\n+    let expected = [-2, 1, 5, 11, 14, 22];\n+    for x in a.symmetric_difference(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_union() {\n+    let mut a = HashSet::new();\n+    let mut b = HashSet::new();\n+    assert!(a.union(&b).next().is_none());\n+    assert!(b.union(&a).next().is_none());\n+\n+    assert!(a.insert(1));\n+    assert!(a.insert(3));\n+    assert!(a.insert(11));\n+    assert!(a.insert(16));\n+    assert!(a.insert(19));\n+    assert!(a.insert(24));\n+\n+    assert!(b.insert(-2));\n+    assert!(b.insert(1));\n+    assert!(b.insert(5));\n+    assert!(b.insert(9));\n+    assert!(b.insert(13));\n+    assert!(b.insert(19));\n+\n+    let mut i = 0;\n+    let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+    for x in a.union(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    assert!(a.insert(9)); // make a bigger than b\n+    assert!(a.insert(5));\n+\n+    i = 0;\n+    for x in a.union(&b) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+\n+    i = 0;\n+    for x in b.union(&a) {\n+        assert!(expected.contains(x));\n+        i += 1\n+    }\n+    assert_eq!(i, expected.len());\n+}\n+\n+#[test]\n+fn test_from_iter() {\n+    let xs = [1, 2, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+    let set: HashSet<_> = xs.iter().cloned().collect();\n+\n+    for x in &xs {\n+        assert!(set.contains(x));\n+    }\n+\n+    assert_eq!(set.iter().len(), xs.len() - 1);\n+}\n+\n+#[test]\n+fn test_move_iter() {\n+    let hs = {\n+        let mut hs = HashSet::new();\n+\n+        hs.insert('a');\n+        hs.insert('b');\n+\n+        hs\n+    };\n+\n+    let v = hs.into_iter().collect::<Vec<char>>();\n+    assert!(v == ['a', 'b'] || v == ['b', 'a']);\n+}\n+\n+#[test]\n+fn test_eq() {\n+    // These constants once happened to expose a bug in insert().\n+    // I'm keeping them around to prevent a regression.\n+    let mut s1 = HashSet::new();\n+\n+    s1.insert(1);\n+    s1.insert(2);\n+    s1.insert(3);\n+\n+    let mut s2 = HashSet::new();\n+\n+    s2.insert(1);\n+    s2.insert(2);\n+\n+    assert!(s1 != s2);\n+\n+    s2.insert(3);\n+\n+    assert_eq!(s1, s2);\n+}\n+\n+#[test]\n+fn test_show() {\n+    let mut set = HashSet::new();\n+    let empty = HashSet::<i32>::new();\n+\n+    set.insert(1);\n+    set.insert(2);\n+\n+    let set_str = format!(\"{:?}\", set);\n+\n+    assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n+    assert_eq!(format!(\"{:?}\", empty), \"{}\");\n+}\n+\n+#[test]\n+fn test_trivial_drain() {\n+    let mut s = HashSet::<i32>::new();\n+    for _ in s.drain() {}\n+    assert!(s.is_empty());\n+    drop(s);\n+\n+    let mut s = HashSet::<i32>::new();\n+    drop(s.drain());\n+    assert!(s.is_empty());\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut s: HashSet<_> = (1..100).collect();\n+\n+    // try this a bunch of times to make sure we don't screw up internal state.\n+    for _ in 0..20 {\n+        assert_eq!(s.len(), 99);\n+\n+        {\n+            let mut last_i = 0;\n+            let mut d = s.drain();\n+            for (i, x) in d.by_ref().take(50).enumerate() {\n+                last_i = i;\n+                assert!(x != 0);\n+            }\n+            assert_eq!(last_i, 49);\n+        }\n+\n+        for _ in &s {\n+            panic!(\"s should be empty!\");\n+        }\n+\n+        // reset to try again.\n+        s.extend(1..100);\n+    }\n+}\n+\n+#[test]\n+fn test_replace() {\n+    use crate::hash;\n+\n+    #[derive(Debug)]\n+    struct Foo(&'static str, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Self) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    impl Eq for Foo {}\n+\n+    impl hash::Hash for Foo {\n+        fn hash<H: hash::Hasher>(&self, h: &mut H) {\n+            self.0.hash(h);\n+        }\n+    }\n+\n+    let mut s = HashSet::new();\n+    assert_eq!(s.replace(Foo(\"a\", 1)), None);\n+    assert_eq!(s.len(), 1);\n+    assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n+    assert_eq!(s.len(), 1);\n+\n+    let mut it = s.iter();\n+    assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_extend_ref() {\n+    let mut a = HashSet::new();\n+    a.insert(1);\n+\n+    a.extend(&[2, 3, 4]);\n+\n+    assert_eq!(a.len(), 4);\n+    assert!(a.contains(&1));\n+    assert!(a.contains(&2));\n+    assert!(a.contains(&3));\n+    assert!(a.contains(&4));\n+\n+    let mut b = HashSet::new();\n+    b.insert(5);\n+    b.insert(6);\n+\n+    a.extend(&b);\n+\n+    assert_eq!(a.len(), 6);\n+    assert!(a.contains(&1));\n+    assert!(a.contains(&2));\n+    assert!(a.contains(&3));\n+    assert!(a.contains(&4));\n+    assert!(a.contains(&5));\n+    assert!(a.contains(&6));\n+}\n+\n+#[test]\n+fn test_retain() {\n+    let xs = [1, 2, 3, 4, 5, 6];\n+    let mut set: HashSet<i32> = xs.iter().cloned().collect();\n+    set.retain(|&k| k % 2 == 0);\n+    assert_eq!(set.len(), 3);\n+    assert!(set.contains(&2));\n+    assert!(set.contains(&4));\n+    assert!(set.contains(&6));\n+}"}, {"sha": "d38911ba0db90b0801c462704f7869f4a1e66e55", "filename": "library/std/src/env.rs", "status": "modified", "additions": 3, "deletions": 109, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -10,6 +10,9 @@\n \n #![stable(feature = \"env\", since = \"1.0.0\")]\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::error::Error;\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n@@ -944,112 +947,3 @@ pub mod consts {\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n     pub const EXE_EXTENSION: &str = os::EXE_EXTENSION;\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::path::Path;\n-\n-    #[test]\n-    #[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\n-    fn test_self_exe_path() {\n-        let path = current_exe();\n-        assert!(path.is_ok());\n-        let path = path.unwrap();\n-\n-        // Hard to test this function\n-        assert!(path.is_absolute());\n-    }\n-\n-    #[test]\n-    fn test() {\n-        assert!((!Path::new(\"test-path\").is_absolute()));\n-\n-        #[cfg(not(target_env = \"sgx\"))]\n-        current_dir().unwrap();\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn split_paths_windows() {\n-        use crate::path::PathBuf;\n-\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>()\n-                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n-        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n-        assert!(check_parse(r\"c:\\;c:\\Program Files\\\", &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n-        assert!(check_parse(\n-            r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]\n-        ));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn split_paths_unix() {\n-        use crate::path::PathBuf;\n-\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed).collect::<Vec<_>>()\n-                == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(\"/\", &mut [\"/\"]));\n-        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n-        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn join_paths_unix() {\n-        use crate::ffi::OsStr;\n-\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"], \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"], \":/bin:::/usr/bin:\"));\n-        assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn join_paths_windows() {\n-        use crate::ffi::OsStr;\n-\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"], r\"c:\\windows;c:\\\"));\n-        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"], r\";c:\\windows;;;c:\\;\"));\n-        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"], r#\"\"c:\\te;st\";c:\\\"#));\n-        assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n-    }\n-\n-    #[test]\n-    fn args_debug() {\n-        assert_eq!(\n-            format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args())\n-        );\n-        assert_eq!(\n-            format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n-            format!(\"{:?}\", args_os())\n-        );\n-    }\n-}"}, {"sha": "94cace03af64e6f0e01192d8247a75075c9c6dcf", "filename": "library/std/src/env/tests.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fenv%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fenv%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fenv%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,102 @@\n+use super::*;\n+\n+use crate::path::Path;\n+\n+#[test]\n+#[cfg_attr(any(target_os = \"emscripten\", target_env = \"sgx\"), ignore)]\n+fn test_self_exe_path() {\n+    let path = current_exe();\n+    assert!(path.is_ok());\n+    let path = path.unwrap();\n+\n+    // Hard to test this function\n+    assert!(path.is_absolute());\n+}\n+\n+#[test]\n+fn test() {\n+    assert!((!Path::new(\"test-path\").is_absolute()));\n+\n+    #[cfg(not(target_env = \"sgx\"))]\n+    current_dir().unwrap();\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn split_paths_windows() {\n+    use crate::path::PathBuf;\n+\n+    fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+        split_paths(unparsed).collect::<Vec<_>>()\n+            == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+    }\n+\n+    assert!(check_parse(\"\", &mut [\"\"]));\n+    assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n+    assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n+    assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n+    assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n+    assert!(check_parse(r\"c:\\;c:\\Program Files\\\", &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+    assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n+    assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#, &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+}\n+\n+#[test]\n+#[cfg(unix)]\n+fn split_paths_unix() {\n+    use crate::path::PathBuf;\n+\n+    fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n+        split_paths(unparsed).collect::<Vec<_>>()\n+            == parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n+    }\n+\n+    assert!(check_parse(\"\", &mut [\"\"]));\n+    assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n+    assert!(check_parse(\"/\", &mut [\"/\"]));\n+    assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n+    assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n+}\n+\n+#[test]\n+#[cfg(unix)]\n+fn join_paths_unix() {\n+    use crate::ffi::OsStr;\n+\n+    fn test_eq(input: &[&str], output: &str) -> bool {\n+        &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n+    }\n+\n+    assert!(test_eq(&[], \"\"));\n+    assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"], \"/bin:/usr/bin:/usr/local/bin\"));\n+    assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"], \":/bin:::/usr/bin:\"));\n+    assert!(join_paths([\"/te:st\"].iter().cloned()).is_err());\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn join_paths_windows() {\n+    use crate::ffi::OsStr;\n+\n+    fn test_eq(input: &[&str], output: &str) -> bool {\n+        &*join_paths(input.iter().cloned()).unwrap() == OsStr::new(output)\n+    }\n+\n+    assert!(test_eq(&[], \"\"));\n+    assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"], r\"c:\\windows;c:\\\"));\n+    assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"], r\";c:\\windows;;;c:\\;\"));\n+    assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"], r#\"\"c:\\te;st\";c:\\\"#));\n+    assert!(join_paths([r#\"c:\\te\"st\"#].iter().cloned()).is_err());\n+}\n+\n+#[test]\n+fn args_debug() {\n+    assert_eq!(\n+        format!(\"Args {{ inner: {:?} }}\", args().collect::<Vec<_>>()),\n+        format!(\"{:?}\", args())\n+    );\n+    assert_eq!(\n+        format!(\"ArgsOs {{ inner: {:?} }}\", args_os().collect::<Vec<_>>()),\n+        format!(\"{:?}\", args_os())\n+    );\n+}"}, {"sha": "8da033439768e08b550b9607594e5bb459daaf56", "filename": "library/std/src/error.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -13,6 +13,9 @@\n // coherence challenge (e.g., specialization, neg impls, etc) we can\n // reconsider what crate these items belong in.\n \n+#[cfg(test)]\n+mod tests;\n+\n use core::array;\n use core::convert::Infallible;\n \n@@ -738,44 +741,3 @@ impl dyn Error + Send + Sync {\n         })\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::Error;\n-    use crate::fmt;\n-\n-    #[derive(Debug, PartialEq)]\n-    struct A;\n-    #[derive(Debug, PartialEq)]\n-    struct B;\n-\n-    impl fmt::Display for A {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            write!(f, \"A\")\n-        }\n-    }\n-    impl fmt::Display for B {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            write!(f, \"B\")\n-        }\n-    }\n-\n-    impl Error for A {}\n-    impl Error for B {}\n-\n-    #[test]\n-    fn downcasting() {\n-        let mut a = A;\n-        let a = &mut a as &mut (dyn Error + 'static);\n-        assert_eq!(a.downcast_ref::<A>(), Some(&A));\n-        assert_eq!(a.downcast_ref::<B>(), None);\n-        assert_eq!(a.downcast_mut::<A>(), Some(&mut A));\n-        assert_eq!(a.downcast_mut::<B>(), None);\n-\n-        let a: Box<dyn Error> = Box::new(A);\n-        match a.downcast::<B>() {\n-            Ok(..) => panic!(\"expected error\"),\n-            Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n-        }\n-    }\n-}"}, {"sha": "66d6924f34d2b2dea3742bb02bdff131bf64872a", "filename": "library/std/src/error/tests.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,37 @@\n+use super::Error;\n+use crate::fmt;\n+\n+#[derive(Debug, PartialEq)]\n+struct A;\n+#[derive(Debug, PartialEq)]\n+struct B;\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"A\")\n+    }\n+}\n+impl fmt::Display for B {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"B\")\n+    }\n+}\n+\n+impl Error for A {}\n+impl Error for B {}\n+\n+#[test]\n+fn downcasting() {\n+    let mut a = A;\n+    let a = &mut a as &mut (dyn Error + 'static);\n+    assert_eq!(a.downcast_ref::<A>(), Some(&A));\n+    assert_eq!(a.downcast_ref::<B>(), None);\n+    assert_eq!(a.downcast_mut::<A>(), Some(&mut A));\n+    assert_eq!(a.downcast_mut::<B>(), None);\n+\n+    let a: Box<dyn Error> = Box::new(A);\n+    match a.downcast::<B>() {\n+        Ok(..) => panic!(\"expected error\"),\n+        Err(e) => assert_eq!(*e.downcast::<A>().unwrap(), A),\n+    }\n+}"}, {"sha": "59c2da5273bded106154c46223e9bf011243a3d3", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 3, "deletions": 763, "changes": 766, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -11,6 +11,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n+#[cfg(test)]\n+mod tests;\n+\n #[cfg(not(test))]\n use crate::intrinsics;\n #[cfg(not(test))]\n@@ -909,766 +912,3 @@ impl f32 {\n         x\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::f32::consts;\n-    use crate::num::FpCategory as Fp;\n-    use crate::num::*;\n-\n-    #[test]\n-    fn test_num_f32() {\n-        test_num(10f32, 2f32);\n-    }\n-\n-    #[test]\n-    fn test_min_nan() {\n-        assert_eq!(f32::NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f32.min(f32::NAN), 2.0);\n-    }\n-\n-    #[test]\n-    fn test_max_nan() {\n-        assert_eq!(f32::NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f32.max(f32::NAN), 2.0);\n-    }\n-\n-    #[test]\n-    fn test_nan() {\n-        let nan: f32 = f32::NAN;\n-        assert!(nan.is_nan());\n-        assert!(!nan.is_infinite());\n-        assert!(!nan.is_finite());\n-        assert!(!nan.is_normal());\n-        assert!(nan.is_sign_positive());\n-        assert!(!nan.is_sign_negative());\n-        assert_eq!(Fp::Nan, nan.classify());\n-    }\n-\n-    #[test]\n-    fn test_infinity() {\n-        let inf: f32 = f32::INFINITY;\n-        assert!(inf.is_infinite());\n-        assert!(!inf.is_finite());\n-        assert!(inf.is_sign_positive());\n-        assert!(!inf.is_sign_negative());\n-        assert!(!inf.is_nan());\n-        assert!(!inf.is_normal());\n-        assert_eq!(Fp::Infinite, inf.classify());\n-    }\n-\n-    #[test]\n-    fn test_neg_infinity() {\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert!(neg_inf.is_infinite());\n-        assert!(!neg_inf.is_finite());\n-        assert!(!neg_inf.is_sign_positive());\n-        assert!(neg_inf.is_sign_negative());\n-        assert!(!neg_inf.is_nan());\n-        assert!(!neg_inf.is_normal());\n-        assert_eq!(Fp::Infinite, neg_inf.classify());\n-    }\n-\n-    #[test]\n-    fn test_zero() {\n-        let zero: f32 = 0.0f32;\n-        assert_eq!(0.0, zero);\n-        assert!(!zero.is_infinite());\n-        assert!(zero.is_finite());\n-        assert!(zero.is_sign_positive());\n-        assert!(!zero.is_sign_negative());\n-        assert!(!zero.is_nan());\n-        assert!(!zero.is_normal());\n-        assert_eq!(Fp::Zero, zero.classify());\n-    }\n-\n-    #[test]\n-    fn test_neg_zero() {\n-        let neg_zero: f32 = -0.0;\n-        assert_eq!(0.0, neg_zero);\n-        assert!(!neg_zero.is_infinite());\n-        assert!(neg_zero.is_finite());\n-        assert!(!neg_zero.is_sign_positive());\n-        assert!(neg_zero.is_sign_negative());\n-        assert!(!neg_zero.is_nan());\n-        assert!(!neg_zero.is_normal());\n-        assert_eq!(Fp::Zero, neg_zero.classify());\n-    }\n-\n-    #[test]\n-    fn test_one() {\n-        let one: f32 = 1.0f32;\n-        assert_eq!(1.0, one);\n-        assert!(!one.is_infinite());\n-        assert!(one.is_finite());\n-        assert!(one.is_sign_positive());\n-        assert!(!one.is_sign_negative());\n-        assert!(!one.is_nan());\n-        assert!(one.is_normal());\n-        assert_eq!(Fp::Normal, one.classify());\n-    }\n-\n-    #[test]\n-    fn test_is_nan() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert!(nan.is_nan());\n-        assert!(!0.0f32.is_nan());\n-        assert!(!5.3f32.is_nan());\n-        assert!(!(-10.732f32).is_nan());\n-        assert!(!inf.is_nan());\n-        assert!(!neg_inf.is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_infinite() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert!(!nan.is_infinite());\n-        assert!(inf.is_infinite());\n-        assert!(neg_inf.is_infinite());\n-        assert!(!0.0f32.is_infinite());\n-        assert!(!42.8f32.is_infinite());\n-        assert!(!(-109.2f32).is_infinite());\n-    }\n-\n-    #[test]\n-    fn test_is_finite() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert!(!nan.is_finite());\n-        assert!(!inf.is_finite());\n-        assert!(!neg_inf.is_finite());\n-        assert!(0.0f32.is_finite());\n-        assert!(42.8f32.is_finite());\n-        assert!((-109.2f32).is_finite());\n-    }\n-\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let zero: f32 = 0.0f32;\n-        let neg_zero: f32 = -0.0;\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f32.is_normal());\n-        assert!(1e-37f32.is_normal());\n-        assert!(!1e-38f32.is_normal());\n-    }\n-\n-    #[test]\n-    fn test_classify() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let zero: f32 = 0.0f32;\n-        let neg_zero: f32 = -0.0;\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1f32.classify(), Fp::Normal);\n-        assert_eq!(1e-37f32.classify(), Fp::Normal);\n-        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_floor() {\n-        assert_approx_eq!(1.0f32.floor(), 1.0f32);\n-        assert_approx_eq!(1.3f32.floor(), 1.0f32);\n-        assert_approx_eq!(1.5f32.floor(), 1.0f32);\n-        assert_approx_eq!(1.7f32.floor(), 1.0f32);\n-        assert_approx_eq!(0.0f32.floor(), 0.0f32);\n-        assert_approx_eq!((-0.0f32).floor(), -0.0f32);\n-        assert_approx_eq!((-1.0f32).floor(), -1.0f32);\n-        assert_approx_eq!((-1.3f32).floor(), -2.0f32);\n-        assert_approx_eq!((-1.5f32).floor(), -2.0f32);\n-        assert_approx_eq!((-1.7f32).floor(), -2.0f32);\n-    }\n-\n-    #[test]\n-    fn test_ceil() {\n-        assert_approx_eq!(1.0f32.ceil(), 1.0f32);\n-        assert_approx_eq!(1.3f32.ceil(), 2.0f32);\n-        assert_approx_eq!(1.5f32.ceil(), 2.0f32);\n-        assert_approx_eq!(1.7f32.ceil(), 2.0f32);\n-        assert_approx_eq!(0.0f32.ceil(), 0.0f32);\n-        assert_approx_eq!((-0.0f32).ceil(), -0.0f32);\n-        assert_approx_eq!((-1.0f32).ceil(), -1.0f32);\n-        assert_approx_eq!((-1.3f32).ceil(), -1.0f32);\n-        assert_approx_eq!((-1.5f32).ceil(), -1.0f32);\n-        assert_approx_eq!((-1.7f32).ceil(), -1.0f32);\n-    }\n-\n-    #[test]\n-    fn test_round() {\n-        assert_approx_eq!(1.0f32.round(), 1.0f32);\n-        assert_approx_eq!(1.3f32.round(), 1.0f32);\n-        assert_approx_eq!(1.5f32.round(), 2.0f32);\n-        assert_approx_eq!(1.7f32.round(), 2.0f32);\n-        assert_approx_eq!(0.0f32.round(), 0.0f32);\n-        assert_approx_eq!((-0.0f32).round(), -0.0f32);\n-        assert_approx_eq!((-1.0f32).round(), -1.0f32);\n-        assert_approx_eq!((-1.3f32).round(), -1.0f32);\n-        assert_approx_eq!((-1.5f32).round(), -2.0f32);\n-        assert_approx_eq!((-1.7f32).round(), -2.0f32);\n-    }\n-\n-    #[test]\n-    fn test_trunc() {\n-        assert_approx_eq!(1.0f32.trunc(), 1.0f32);\n-        assert_approx_eq!(1.3f32.trunc(), 1.0f32);\n-        assert_approx_eq!(1.5f32.trunc(), 1.0f32);\n-        assert_approx_eq!(1.7f32.trunc(), 1.0f32);\n-        assert_approx_eq!(0.0f32.trunc(), 0.0f32);\n-        assert_approx_eq!((-0.0f32).trunc(), -0.0f32);\n-        assert_approx_eq!((-1.0f32).trunc(), -1.0f32);\n-        assert_approx_eq!((-1.3f32).trunc(), -1.0f32);\n-        assert_approx_eq!((-1.5f32).trunc(), -1.0f32);\n-        assert_approx_eq!((-1.7f32).trunc(), -1.0f32);\n-    }\n-\n-    #[test]\n-    fn test_fract() {\n-        assert_approx_eq!(1.0f32.fract(), 0.0f32);\n-        assert_approx_eq!(1.3f32.fract(), 0.3f32);\n-        assert_approx_eq!(1.5f32.fract(), 0.5f32);\n-        assert_approx_eq!(1.7f32.fract(), 0.7f32);\n-        assert_approx_eq!(0.0f32.fract(), 0.0f32);\n-        assert_approx_eq!((-0.0f32).fract(), -0.0f32);\n-        assert_approx_eq!((-1.0f32).fract(), -0.0f32);\n-        assert_approx_eq!((-1.3f32).fract(), -0.3f32);\n-        assert_approx_eq!((-1.5f32).fract(), -0.5f32);\n-        assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n-    }\n-\n-    #[test]\n-    fn test_abs() {\n-        assert_eq!(f32::INFINITY.abs(), f32::INFINITY);\n-        assert_eq!(1f32.abs(), 1f32);\n-        assert_eq!(0f32.abs(), 0f32);\n-        assert_eq!((-0f32).abs(), 0f32);\n-        assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(f32::NEG_INFINITY.abs(), f32::INFINITY);\n-        assert_eq!((1f32 / f32::NEG_INFINITY).abs(), 0f32);\n-        assert!(f32::NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(f32::INFINITY.signum(), 1f32);\n-        assert_eq!(1f32.signum(), 1f32);\n-        assert_eq!(0f32.signum(), 1f32);\n-        assert_eq!((-0f32).signum(), -1f32);\n-        assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(f32::NEG_INFINITY.signum(), -1f32);\n-        assert_eq!((1f32 / f32::NEG_INFINITY).signum(), -1f32);\n-        assert!(f32::NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_sign_positive() {\n-        assert!(f32::INFINITY.is_sign_positive());\n-        assert!(1f32.is_sign_positive());\n-        assert!(0f32.is_sign_positive());\n-        assert!(!(-0f32).is_sign_positive());\n-        assert!(!(-1f32).is_sign_positive());\n-        assert!(!f32::NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f32 / f32::NEG_INFINITY).is_sign_positive());\n-        assert!(f32::NAN.is_sign_positive());\n-        assert!(!(-f32::NAN).is_sign_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_sign_negative() {\n-        assert!(!f32::INFINITY.is_sign_negative());\n-        assert!(!1f32.is_sign_negative());\n-        assert!(!0f32.is_sign_negative());\n-        assert!((-0f32).is_sign_negative());\n-        assert!((-1f32).is_sign_negative());\n-        assert!(f32::NEG_INFINITY.is_sign_negative());\n-        assert!((1f32 / f32::NEG_INFINITY).is_sign_negative());\n-        assert!(!f32::NAN.is_sign_negative());\n-        assert!((-f32::NAN).is_sign_negative());\n-    }\n-\n-    #[test]\n-    fn test_mul_add() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n-        assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n-        assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n-        assert_approx_eq!(3.4f32.mul_add(-0.0, 5.6), 5.6);\n-        assert!(nan.mul_add(7.8, 9.0).is_nan());\n-        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n-        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n-        assert_eq!(8.9f32.mul_add(inf, 3.2), inf);\n-        assert_eq!((-3.2f32).mul_add(2.4, neg_inf), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_recip() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(1.0f32.recip(), 1.0);\n-        assert_eq!(2.0f32.recip(), 0.5);\n-        assert_eq!((-0.4f32).recip(), -2.5);\n-        assert_eq!(0.0f32.recip(), inf);\n-        assert!(nan.recip().is_nan());\n-        assert_eq!(inf.recip(), 0.0);\n-        assert_eq!(neg_inf.recip(), 0.0);\n-    }\n-\n-    #[test]\n-    fn test_powi() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(1.0f32.powi(1), 1.0);\n-        assert_approx_eq!((-3.1f32).powi(2), 9.61);\n-        assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n-        assert_eq!(8.3f32.powi(0), 1.0);\n-        assert!(nan.powi(2).is_nan());\n-        assert_eq!(inf.powi(3), inf);\n-        assert_eq!(neg_inf.powi(2), inf);\n-    }\n-\n-    #[test]\n-    fn test_powf() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(1.0f32.powf(1.0), 1.0);\n-        assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n-        assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n-        assert_approx_eq!((-3.1f32).powf(2.0), 9.61);\n-        assert_approx_eq!(5.9f32.powf(-2.0), 0.028727);\n-        assert_eq!(8.3f32.powf(0.0), 1.0);\n-        assert!(nan.powf(2.0).is_nan());\n-        assert_eq!(inf.powf(2.0), inf);\n-        assert_eq!(neg_inf.powf(3.0), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(f32::NAN.sqrt().is_nan());\n-        assert!(f32::NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f32).sqrt().is_nan());\n-        assert_eq!((-0.0f32).sqrt(), -0.0);\n-        assert_eq!(0.0f32.sqrt(), 0.0);\n-        assert_eq!(1.0f32.sqrt(), 1.0);\n-        assert_eq!(f32::INFINITY.sqrt(), f32::INFINITY);\n-    }\n-\n-    #[test]\n-    fn test_exp() {\n-        assert_eq!(1.0, 0.0f32.exp());\n-        assert_approx_eq!(2.718282, 1.0f32.exp());\n-        assert_approx_eq!(148.413162, 5.0f32.exp());\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(inf, inf.exp());\n-        assert_eq!(0.0, neg_inf.exp());\n-        assert!(nan.exp().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_exp2() {\n-        assert_eq!(32.0, 5.0f32.exp2());\n-        assert_eq!(1.0, 0.0f32.exp2());\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(inf, inf.exp2());\n-        assert_eq!(0.0, neg_inf.exp2());\n-        assert!(nan.exp2().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_ln() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n-        assert!(nan.ln().is_nan());\n-        assert_eq!(inf.ln(), inf);\n-        assert!(neg_inf.ln().is_nan());\n-        assert!((-2.3f32).ln().is_nan());\n-        assert_eq!((-0.0f32).ln(), neg_inf);\n-        assert_eq!(0.0f32.ln(), neg_inf);\n-        assert_approx_eq!(4.0f32.ln(), 1.386294);\n-    }\n-\n-    #[test]\n-    fn test_log() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(10.0f32.log(10.0), 1.0);\n-        assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n-        assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n-        assert!(1.0f32.log(1.0).is_nan());\n-        assert!(1.0f32.log(-13.9).is_nan());\n-        assert!(nan.log(2.3).is_nan());\n-        assert_eq!(inf.log(10.0), inf);\n-        assert!(neg_inf.log(8.8).is_nan());\n-        assert!((-2.3f32).log(0.1).is_nan());\n-        assert_eq!((-0.0f32).log(2.0), neg_inf);\n-        assert_eq!(0.0f32.log(7.0), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_log2() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_approx_eq!(10.0f32.log2(), 3.321928);\n-        assert_approx_eq!(2.3f32.log2(), 1.201634);\n-        assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n-        assert!(nan.log2().is_nan());\n-        assert_eq!(inf.log2(), inf);\n-        assert!(neg_inf.log2().is_nan());\n-        assert!((-2.3f32).log2().is_nan());\n-        assert_eq!((-0.0f32).log2(), neg_inf);\n-        assert_eq!(0.0f32.log2(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_log10() {\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(10.0f32.log10(), 1.0);\n-        assert_approx_eq!(2.3f32.log10(), 0.361728);\n-        assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n-        assert_eq!(1.0f32.log10(), 0.0);\n-        assert!(nan.log10().is_nan());\n-        assert_eq!(inf.log10(), inf);\n-        assert!(neg_inf.log10().is_nan());\n-        assert!((-2.3f32).log10().is_nan());\n-        assert_eq!((-0.0f32).log10(), neg_inf);\n-        assert_eq!(0.0f32.log10(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_to_degrees() {\n-        let pi: f32 = consts::PI;\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(0.0f32.to_degrees(), 0.0);\n-        assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n-        assert_eq!(pi.to_degrees(), 180.0);\n-        assert!(nan.to_degrees().is_nan());\n-        assert_eq!(inf.to_degrees(), inf);\n-        assert_eq!(neg_inf.to_degrees(), neg_inf);\n-        assert_eq!(1_f32.to_degrees(), 57.2957795130823208767981548141051703);\n-    }\n-\n-    #[test]\n-    fn test_to_radians() {\n-        let pi: f32 = consts::PI;\n-        let nan: f32 = f32::NAN;\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        assert_eq!(0.0f32.to_radians(), 0.0);\n-        assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n-        assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n-        assert_eq!(180.0f32.to_radians(), pi);\n-        assert!(nan.to_radians().is_nan());\n-        assert_eq!(inf.to_radians(), inf);\n-        assert_eq!(neg_inf.to_radians(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_asinh() {\n-        assert_eq!(0.0f32.asinh(), 0.0f32);\n-        assert_eq!((-0.0f32).asinh(), -0.0f32);\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(inf.asinh(), inf);\n-        assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_nan());\n-        assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n-        assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n-        assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n-        // regression test for the catastrophic cancellation fixed in 72486\n-        assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n-    }\n-\n-    #[test]\n-    fn test_acosh() {\n-        assert_eq!(1.0f32.acosh(), 0.0f32);\n-        assert!(0.999f32.acosh().is_nan());\n-\n-        let inf: f32 = f32::INFINITY;\n-        let neg_inf: f32 = f32::NEG_INFINITY;\n-        let nan: f32 = f32::NAN;\n-        assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_nan());\n-        assert!(nan.acosh().is_nan());\n-        assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n-        assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n-    }\n-\n-    #[test]\n-    fn test_atanh() {\n-        assert_eq!(0.0f32.atanh(), 0.0f32);\n-        assert_eq!((-0.0f32).atanh(), -0.0f32);\n-\n-        let inf32: f32 = f32::INFINITY;\n-        let neg_inf32: f32 = f32::NEG_INFINITY;\n-        assert_eq!(1.0f32.atanh(), inf32);\n-        assert_eq!((-1.0f32).atanh(), neg_inf32);\n-\n-        assert!(2f64.atanh().atanh().is_nan());\n-        assert!((-2f64).atanh().atanh().is_nan());\n-\n-        let inf64: f32 = f32::INFINITY;\n-        let neg_inf64: f32 = f32::NEG_INFINITY;\n-        let nan32: f32 = f32::NAN;\n-        assert!(inf64.atanh().is_nan());\n-        assert!(neg_inf64.atanh().is_nan());\n-        assert!(nan32.atanh().is_nan());\n-\n-        assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n-        assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n-    }\n-\n-    #[test]\n-    fn test_real_consts() {\n-        use super::consts;\n-\n-        let pi: f32 = consts::PI;\n-        let frac_pi_2: f32 = consts::FRAC_PI_2;\n-        let frac_pi_3: f32 = consts::FRAC_PI_3;\n-        let frac_pi_4: f32 = consts::FRAC_PI_4;\n-        let frac_pi_6: f32 = consts::FRAC_PI_6;\n-        let frac_pi_8: f32 = consts::FRAC_PI_8;\n-        let frac_1_pi: f32 = consts::FRAC_1_PI;\n-        let frac_2_pi: f32 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n-        let sqrt2: f32 = consts::SQRT_2;\n-        let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n-        let e: f32 = consts::E;\n-        let log2_e: f32 = consts::LOG2_E;\n-        let log10_e: f32 = consts::LOG10_E;\n-        let ln_2: f32 = consts::LN_2;\n-        let ln_10: f32 = consts::LN_10;\n-\n-        assert_approx_eq!(frac_pi_2, pi / 2f32);\n-        assert_approx_eq!(frac_pi_3, pi / 3f32);\n-        assert_approx_eq!(frac_pi_4, pi / 4f32);\n-        assert_approx_eq!(frac_pi_6, pi / 6f32);\n-        assert_approx_eq!(frac_pi_8, pi / 8f32);\n-        assert_approx_eq!(frac_1_pi, 1f32 / pi);\n-        assert_approx_eq!(frac_2_pi, 2f32 / pi);\n-        assert_approx_eq!(frac_2_sqrtpi, 2f32 / pi.sqrt());\n-        assert_approx_eq!(sqrt2, 2f32.sqrt());\n-        assert_approx_eq!(frac_1_sqrt2, 1f32 / 2f32.sqrt());\n-        assert_approx_eq!(log2_e, e.log2());\n-        assert_approx_eq!(log10_e, e.log10());\n-        assert_approx_eq!(ln_2, 2f32.ln());\n-        assert_approx_eq!(ln_10, 10f32.ln());\n-    }\n-\n-    #[test]\n-    fn test_float_bits_conv() {\n-        assert_eq!((1f32).to_bits(), 0x3f800000);\n-        assert_eq!((12.5f32).to_bits(), 0x41480000);\n-        assert_eq!((1337f32).to_bits(), 0x44a72000);\n-        assert_eq!((-14.25f32).to_bits(), 0xc1640000);\n-        assert_approx_eq!(f32::from_bits(0x3f800000), 1.0);\n-        assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n-        assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n-        assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n-\n-        // Check that NaNs roundtrip their bits regardless of signaling-ness\n-        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-        let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n-        let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n-        assert!(f32::from_bits(masked_nan1).is_nan());\n-        assert!(f32::from_bits(masked_nan2).is_nan());\n-\n-        assert_eq!(f32::from_bits(masked_nan1).to_bits(), masked_nan1);\n-        assert_eq!(f32::from_bits(masked_nan2).to_bits(), masked_nan2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_min_greater_than_max() {\n-        let _ = 1.0f32.clamp(3.0, 1.0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_min_is_nan() {\n-        let _ = 1.0f32.clamp(f32::NAN, 1.0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_max_is_nan() {\n-        let _ = 1.0f32.clamp(3.0, f32::NAN);\n-    }\n-\n-    #[test]\n-    fn test_total_cmp() {\n-        use core::cmp::Ordering;\n-\n-        fn quiet_bit_mask() -> u32 {\n-            1 << (f32::MANTISSA_DIGITS - 2)\n-        }\n-\n-        fn min_subnorm() -> f32 {\n-            f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n-        }\n-\n-        fn max_subnorm() -> f32 {\n-            f32::MIN_POSITIVE - min_subnorm()\n-        }\n-\n-        fn q_nan() -> f32 {\n-            f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n-        }\n-\n-        fn s_nan() -> f32 {\n-            f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n-        }\n-\n-        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n-        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n-        assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n-        assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n-        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n-        assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n-        assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n-        assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n-        assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n-        assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n-        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n-        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n-\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n-        assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n-        assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n-        assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n-        assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n-        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n-\n-        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n-        assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n-        assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n-        assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n-        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n-        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n-        assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n-        assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n-        assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n-        assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n-        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n-        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n-\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n-\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n-    }\n-}"}, {"sha": "0d4b865f3392a66304e13e47e9fa652099428534", "filename": "library/std/src/f32/tests.rs", "status": "added", "additions": 759, "deletions": 0, "changes": 759, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,759 @@\n+use crate::f32::consts;\n+use crate::num::FpCategory as Fp;\n+use crate::num::*;\n+\n+#[test]\n+fn test_num_f32() {\n+    test_num(10f32, 2f32);\n+}\n+\n+#[test]\n+fn test_min_nan() {\n+    assert_eq!(f32::NAN.min(2.0), 2.0);\n+    assert_eq!(2.0f32.min(f32::NAN), 2.0);\n+}\n+\n+#[test]\n+fn test_max_nan() {\n+    assert_eq!(f32::NAN.max(2.0), 2.0);\n+    assert_eq!(2.0f32.max(f32::NAN), 2.0);\n+}\n+\n+#[test]\n+fn test_nan() {\n+    let nan: f32 = f32::NAN;\n+    assert!(nan.is_nan());\n+    assert!(!nan.is_infinite());\n+    assert!(!nan.is_finite());\n+    assert!(!nan.is_normal());\n+    assert!(nan.is_sign_positive());\n+    assert!(!nan.is_sign_negative());\n+    assert_eq!(Fp::Nan, nan.classify());\n+}\n+\n+#[test]\n+fn test_infinity() {\n+    let inf: f32 = f32::INFINITY;\n+    assert!(inf.is_infinite());\n+    assert!(!inf.is_finite());\n+    assert!(inf.is_sign_positive());\n+    assert!(!inf.is_sign_negative());\n+    assert!(!inf.is_nan());\n+    assert!(!inf.is_normal());\n+    assert_eq!(Fp::Infinite, inf.classify());\n+}\n+\n+#[test]\n+fn test_neg_infinity() {\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert!(neg_inf.is_infinite());\n+    assert!(!neg_inf.is_finite());\n+    assert!(!neg_inf.is_sign_positive());\n+    assert!(neg_inf.is_sign_negative());\n+    assert!(!neg_inf.is_nan());\n+    assert!(!neg_inf.is_normal());\n+    assert_eq!(Fp::Infinite, neg_inf.classify());\n+}\n+\n+#[test]\n+fn test_zero() {\n+    let zero: f32 = 0.0f32;\n+    assert_eq!(0.0, zero);\n+    assert!(!zero.is_infinite());\n+    assert!(zero.is_finite());\n+    assert!(zero.is_sign_positive());\n+    assert!(!zero.is_sign_negative());\n+    assert!(!zero.is_nan());\n+    assert!(!zero.is_normal());\n+    assert_eq!(Fp::Zero, zero.classify());\n+}\n+\n+#[test]\n+fn test_neg_zero() {\n+    let neg_zero: f32 = -0.0;\n+    assert_eq!(0.0, neg_zero);\n+    assert!(!neg_zero.is_infinite());\n+    assert!(neg_zero.is_finite());\n+    assert!(!neg_zero.is_sign_positive());\n+    assert!(neg_zero.is_sign_negative());\n+    assert!(!neg_zero.is_nan());\n+    assert!(!neg_zero.is_normal());\n+    assert_eq!(Fp::Zero, neg_zero.classify());\n+}\n+\n+#[test]\n+fn test_one() {\n+    let one: f32 = 1.0f32;\n+    assert_eq!(1.0, one);\n+    assert!(!one.is_infinite());\n+    assert!(one.is_finite());\n+    assert!(one.is_sign_positive());\n+    assert!(!one.is_sign_negative());\n+    assert!(!one.is_nan());\n+    assert!(one.is_normal());\n+    assert_eq!(Fp::Normal, one.classify());\n+}\n+\n+#[test]\n+fn test_is_nan() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert!(nan.is_nan());\n+    assert!(!0.0f32.is_nan());\n+    assert!(!5.3f32.is_nan());\n+    assert!(!(-10.732f32).is_nan());\n+    assert!(!inf.is_nan());\n+    assert!(!neg_inf.is_nan());\n+}\n+\n+#[test]\n+fn test_is_infinite() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert!(!nan.is_infinite());\n+    assert!(inf.is_infinite());\n+    assert!(neg_inf.is_infinite());\n+    assert!(!0.0f32.is_infinite());\n+    assert!(!42.8f32.is_infinite());\n+    assert!(!(-109.2f32).is_infinite());\n+}\n+\n+#[test]\n+fn test_is_finite() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert!(!nan.is_finite());\n+    assert!(!inf.is_finite());\n+    assert!(!neg_inf.is_finite());\n+    assert!(0.0f32.is_finite());\n+    assert!(42.8f32.is_finite());\n+    assert!((-109.2f32).is_finite());\n+}\n+\n+#[test]\n+fn test_is_normal() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let zero: f32 = 0.0f32;\n+    let neg_zero: f32 = -0.0;\n+    assert!(!nan.is_normal());\n+    assert!(!inf.is_normal());\n+    assert!(!neg_inf.is_normal());\n+    assert!(!zero.is_normal());\n+    assert!(!neg_zero.is_normal());\n+    assert!(1f32.is_normal());\n+    assert!(1e-37f32.is_normal());\n+    assert!(!1e-38f32.is_normal());\n+}\n+\n+#[test]\n+fn test_classify() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let zero: f32 = 0.0f32;\n+    let neg_zero: f32 = -0.0;\n+    assert_eq!(nan.classify(), Fp::Nan);\n+    assert_eq!(inf.classify(), Fp::Infinite);\n+    assert_eq!(neg_inf.classify(), Fp::Infinite);\n+    assert_eq!(zero.classify(), Fp::Zero);\n+    assert_eq!(neg_zero.classify(), Fp::Zero);\n+    assert_eq!(1f32.classify(), Fp::Normal);\n+    assert_eq!(1e-37f32.classify(), Fp::Normal);\n+    assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n+}\n+\n+#[test]\n+fn test_floor() {\n+    assert_approx_eq!(1.0f32.floor(), 1.0f32);\n+    assert_approx_eq!(1.3f32.floor(), 1.0f32);\n+    assert_approx_eq!(1.5f32.floor(), 1.0f32);\n+    assert_approx_eq!(1.7f32.floor(), 1.0f32);\n+    assert_approx_eq!(0.0f32.floor(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).floor(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).floor(), -1.0f32);\n+    assert_approx_eq!((-1.3f32).floor(), -2.0f32);\n+    assert_approx_eq!((-1.5f32).floor(), -2.0f32);\n+    assert_approx_eq!((-1.7f32).floor(), -2.0f32);\n+}\n+\n+#[test]\n+fn test_ceil() {\n+    assert_approx_eq!(1.0f32.ceil(), 1.0f32);\n+    assert_approx_eq!(1.3f32.ceil(), 2.0f32);\n+    assert_approx_eq!(1.5f32.ceil(), 2.0f32);\n+    assert_approx_eq!(1.7f32.ceil(), 2.0f32);\n+    assert_approx_eq!(0.0f32.ceil(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).ceil(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).ceil(), -1.0f32);\n+    assert_approx_eq!((-1.3f32).ceil(), -1.0f32);\n+    assert_approx_eq!((-1.5f32).ceil(), -1.0f32);\n+    assert_approx_eq!((-1.7f32).ceil(), -1.0f32);\n+}\n+\n+#[test]\n+fn test_round() {\n+    assert_approx_eq!(1.0f32.round(), 1.0f32);\n+    assert_approx_eq!(1.3f32.round(), 1.0f32);\n+    assert_approx_eq!(1.5f32.round(), 2.0f32);\n+    assert_approx_eq!(1.7f32.round(), 2.0f32);\n+    assert_approx_eq!(0.0f32.round(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).round(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).round(), -1.0f32);\n+    assert_approx_eq!((-1.3f32).round(), -1.0f32);\n+    assert_approx_eq!((-1.5f32).round(), -2.0f32);\n+    assert_approx_eq!((-1.7f32).round(), -2.0f32);\n+}\n+\n+#[test]\n+fn test_trunc() {\n+    assert_approx_eq!(1.0f32.trunc(), 1.0f32);\n+    assert_approx_eq!(1.3f32.trunc(), 1.0f32);\n+    assert_approx_eq!(1.5f32.trunc(), 1.0f32);\n+    assert_approx_eq!(1.7f32.trunc(), 1.0f32);\n+    assert_approx_eq!(0.0f32.trunc(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).trunc(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).trunc(), -1.0f32);\n+    assert_approx_eq!((-1.3f32).trunc(), -1.0f32);\n+    assert_approx_eq!((-1.5f32).trunc(), -1.0f32);\n+    assert_approx_eq!((-1.7f32).trunc(), -1.0f32);\n+}\n+\n+#[test]\n+fn test_fract() {\n+    assert_approx_eq!(1.0f32.fract(), 0.0f32);\n+    assert_approx_eq!(1.3f32.fract(), 0.3f32);\n+    assert_approx_eq!(1.5f32.fract(), 0.5f32);\n+    assert_approx_eq!(1.7f32.fract(), 0.7f32);\n+    assert_approx_eq!(0.0f32.fract(), 0.0f32);\n+    assert_approx_eq!((-0.0f32).fract(), -0.0f32);\n+    assert_approx_eq!((-1.0f32).fract(), -0.0f32);\n+    assert_approx_eq!((-1.3f32).fract(), -0.3f32);\n+    assert_approx_eq!((-1.5f32).fract(), -0.5f32);\n+    assert_approx_eq!((-1.7f32).fract(), -0.7f32);\n+}\n+\n+#[test]\n+fn test_abs() {\n+    assert_eq!(f32::INFINITY.abs(), f32::INFINITY);\n+    assert_eq!(1f32.abs(), 1f32);\n+    assert_eq!(0f32.abs(), 0f32);\n+    assert_eq!((-0f32).abs(), 0f32);\n+    assert_eq!((-1f32).abs(), 1f32);\n+    assert_eq!(f32::NEG_INFINITY.abs(), f32::INFINITY);\n+    assert_eq!((1f32 / f32::NEG_INFINITY).abs(), 0f32);\n+    assert!(f32::NAN.abs().is_nan());\n+}\n+\n+#[test]\n+fn test_signum() {\n+    assert_eq!(f32::INFINITY.signum(), 1f32);\n+    assert_eq!(1f32.signum(), 1f32);\n+    assert_eq!(0f32.signum(), 1f32);\n+    assert_eq!((-0f32).signum(), -1f32);\n+    assert_eq!((-1f32).signum(), -1f32);\n+    assert_eq!(f32::NEG_INFINITY.signum(), -1f32);\n+    assert_eq!((1f32 / f32::NEG_INFINITY).signum(), -1f32);\n+    assert!(f32::NAN.signum().is_nan());\n+}\n+\n+#[test]\n+fn test_is_sign_positive() {\n+    assert!(f32::INFINITY.is_sign_positive());\n+    assert!(1f32.is_sign_positive());\n+    assert!(0f32.is_sign_positive());\n+    assert!(!(-0f32).is_sign_positive());\n+    assert!(!(-1f32).is_sign_positive());\n+    assert!(!f32::NEG_INFINITY.is_sign_positive());\n+    assert!(!(1f32 / f32::NEG_INFINITY).is_sign_positive());\n+    assert!(f32::NAN.is_sign_positive());\n+    assert!(!(-f32::NAN).is_sign_positive());\n+}\n+\n+#[test]\n+fn test_is_sign_negative() {\n+    assert!(!f32::INFINITY.is_sign_negative());\n+    assert!(!1f32.is_sign_negative());\n+    assert!(!0f32.is_sign_negative());\n+    assert!((-0f32).is_sign_negative());\n+    assert!((-1f32).is_sign_negative());\n+    assert!(f32::NEG_INFINITY.is_sign_negative());\n+    assert!((1f32 / f32::NEG_INFINITY).is_sign_negative());\n+    assert!(!f32::NAN.is_sign_negative());\n+    assert!((-f32::NAN).is_sign_negative());\n+}\n+\n+#[test]\n+fn test_mul_add() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_approx_eq!(12.3f32.mul_add(4.5, 6.7), 62.05);\n+    assert_approx_eq!((-12.3f32).mul_add(-4.5, -6.7), 48.65);\n+    assert_approx_eq!(0.0f32.mul_add(8.9, 1.2), 1.2);\n+    assert_approx_eq!(3.4f32.mul_add(-0.0, 5.6), 5.6);\n+    assert!(nan.mul_add(7.8, 9.0).is_nan());\n+    assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+    assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+    assert_eq!(8.9f32.mul_add(inf, 3.2), inf);\n+    assert_eq!((-3.2f32).mul_add(2.4, neg_inf), neg_inf);\n+}\n+\n+#[test]\n+fn test_recip() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(1.0f32.recip(), 1.0);\n+    assert_eq!(2.0f32.recip(), 0.5);\n+    assert_eq!((-0.4f32).recip(), -2.5);\n+    assert_eq!(0.0f32.recip(), inf);\n+    assert!(nan.recip().is_nan());\n+    assert_eq!(inf.recip(), 0.0);\n+    assert_eq!(neg_inf.recip(), 0.0);\n+}\n+\n+#[test]\n+fn test_powi() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(1.0f32.powi(1), 1.0);\n+    assert_approx_eq!((-3.1f32).powi(2), 9.61);\n+    assert_approx_eq!(5.9f32.powi(-2), 0.028727);\n+    assert_eq!(8.3f32.powi(0), 1.0);\n+    assert!(nan.powi(2).is_nan());\n+    assert_eq!(inf.powi(3), inf);\n+    assert_eq!(neg_inf.powi(2), inf);\n+}\n+\n+#[test]\n+fn test_powf() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(1.0f32.powf(1.0), 1.0);\n+    assert_approx_eq!(3.4f32.powf(4.5), 246.408218);\n+    assert_approx_eq!(2.7f32.powf(-3.2), 0.041652);\n+    assert_approx_eq!((-3.1f32).powf(2.0), 9.61);\n+    assert_approx_eq!(5.9f32.powf(-2.0), 0.028727);\n+    assert_eq!(8.3f32.powf(0.0), 1.0);\n+    assert!(nan.powf(2.0).is_nan());\n+    assert_eq!(inf.powf(2.0), inf);\n+    assert_eq!(neg_inf.powf(3.0), neg_inf);\n+}\n+\n+#[test]\n+fn test_sqrt_domain() {\n+    assert!(f32::NAN.sqrt().is_nan());\n+    assert!(f32::NEG_INFINITY.sqrt().is_nan());\n+    assert!((-1.0f32).sqrt().is_nan());\n+    assert_eq!((-0.0f32).sqrt(), -0.0);\n+    assert_eq!(0.0f32.sqrt(), 0.0);\n+    assert_eq!(1.0f32.sqrt(), 1.0);\n+    assert_eq!(f32::INFINITY.sqrt(), f32::INFINITY);\n+}\n+\n+#[test]\n+fn test_exp() {\n+    assert_eq!(1.0, 0.0f32.exp());\n+    assert_approx_eq!(2.718282, 1.0f32.exp());\n+    assert_approx_eq!(148.413162, 5.0f32.exp());\n+\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let nan: f32 = f32::NAN;\n+    assert_eq!(inf, inf.exp());\n+    assert_eq!(0.0, neg_inf.exp());\n+    assert!(nan.exp().is_nan());\n+}\n+\n+#[test]\n+fn test_exp2() {\n+    assert_eq!(32.0, 5.0f32.exp2());\n+    assert_eq!(1.0, 0.0f32.exp2());\n+\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let nan: f32 = f32::NAN;\n+    assert_eq!(inf, inf.exp2());\n+    assert_eq!(0.0, neg_inf.exp2());\n+    assert!(nan.exp2().is_nan());\n+}\n+\n+#[test]\n+fn test_ln() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_approx_eq!(1.0f32.exp().ln(), 1.0);\n+    assert!(nan.ln().is_nan());\n+    assert_eq!(inf.ln(), inf);\n+    assert!(neg_inf.ln().is_nan());\n+    assert!((-2.3f32).ln().is_nan());\n+    assert_eq!((-0.0f32).ln(), neg_inf);\n+    assert_eq!(0.0f32.ln(), neg_inf);\n+    assert_approx_eq!(4.0f32.ln(), 1.386294);\n+}\n+\n+#[test]\n+fn test_log() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(10.0f32.log(10.0), 1.0);\n+    assert_approx_eq!(2.3f32.log(3.5), 0.664858);\n+    assert_eq!(1.0f32.exp().log(1.0f32.exp()), 1.0);\n+    assert!(1.0f32.log(1.0).is_nan());\n+    assert!(1.0f32.log(-13.9).is_nan());\n+    assert!(nan.log(2.3).is_nan());\n+    assert_eq!(inf.log(10.0), inf);\n+    assert!(neg_inf.log(8.8).is_nan());\n+    assert!((-2.3f32).log(0.1).is_nan());\n+    assert_eq!((-0.0f32).log(2.0), neg_inf);\n+    assert_eq!(0.0f32.log(7.0), neg_inf);\n+}\n+\n+#[test]\n+fn test_log2() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_approx_eq!(10.0f32.log2(), 3.321928);\n+    assert_approx_eq!(2.3f32.log2(), 1.201634);\n+    assert_approx_eq!(1.0f32.exp().log2(), 1.442695);\n+    assert!(nan.log2().is_nan());\n+    assert_eq!(inf.log2(), inf);\n+    assert!(neg_inf.log2().is_nan());\n+    assert!((-2.3f32).log2().is_nan());\n+    assert_eq!((-0.0f32).log2(), neg_inf);\n+    assert_eq!(0.0f32.log2(), neg_inf);\n+}\n+\n+#[test]\n+fn test_log10() {\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(10.0f32.log10(), 1.0);\n+    assert_approx_eq!(2.3f32.log10(), 0.361728);\n+    assert_approx_eq!(1.0f32.exp().log10(), 0.434294);\n+    assert_eq!(1.0f32.log10(), 0.0);\n+    assert!(nan.log10().is_nan());\n+    assert_eq!(inf.log10(), inf);\n+    assert!(neg_inf.log10().is_nan());\n+    assert!((-2.3f32).log10().is_nan());\n+    assert_eq!((-0.0f32).log10(), neg_inf);\n+    assert_eq!(0.0f32.log10(), neg_inf);\n+}\n+\n+#[test]\n+fn test_to_degrees() {\n+    let pi: f32 = consts::PI;\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(0.0f32.to_degrees(), 0.0);\n+    assert_approx_eq!((-5.8f32).to_degrees(), -332.315521);\n+    assert_eq!(pi.to_degrees(), 180.0);\n+    assert!(nan.to_degrees().is_nan());\n+    assert_eq!(inf.to_degrees(), inf);\n+    assert_eq!(neg_inf.to_degrees(), neg_inf);\n+    assert_eq!(1_f32.to_degrees(), 57.2957795130823208767981548141051703);\n+}\n+\n+#[test]\n+fn test_to_radians() {\n+    let pi: f32 = consts::PI;\n+    let nan: f32 = f32::NAN;\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    assert_eq!(0.0f32.to_radians(), 0.0);\n+    assert_approx_eq!(154.6f32.to_radians(), 2.698279);\n+    assert_approx_eq!((-332.31f32).to_radians(), -5.799903);\n+    assert_eq!(180.0f32.to_radians(), pi);\n+    assert!(nan.to_radians().is_nan());\n+    assert_eq!(inf.to_radians(), inf);\n+    assert_eq!(neg_inf.to_radians(), neg_inf);\n+}\n+\n+#[test]\n+fn test_asinh() {\n+    assert_eq!(0.0f32.asinh(), 0.0f32);\n+    assert_eq!((-0.0f32).asinh(), -0.0f32);\n+\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let nan: f32 = f32::NAN;\n+    assert_eq!(inf.asinh(), inf);\n+    assert_eq!(neg_inf.asinh(), neg_inf);\n+    assert!(nan.asinh().is_nan());\n+    assert!((-0.0f32).asinh().is_sign_negative()); // issue 63271\n+    assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n+    assert_approx_eq!((-2.0f32).asinh(), -1.443635475178810342493276740273105f32);\n+    // regression test for the catastrophic cancellation fixed in 72486\n+    assert_approx_eq!((-3000.0f32).asinh(), -8.699514775987968673236893537700647f32);\n+}\n+\n+#[test]\n+fn test_acosh() {\n+    assert_eq!(1.0f32.acosh(), 0.0f32);\n+    assert!(0.999f32.acosh().is_nan());\n+\n+    let inf: f32 = f32::INFINITY;\n+    let neg_inf: f32 = f32::NEG_INFINITY;\n+    let nan: f32 = f32::NAN;\n+    assert_eq!(inf.acosh(), inf);\n+    assert!(neg_inf.acosh().is_nan());\n+    assert!(nan.acosh().is_nan());\n+    assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n+    assert_approx_eq!(3.0f32.acosh(), 1.76274717403908605046521864995958461f32);\n+}\n+\n+#[test]\n+fn test_atanh() {\n+    assert_eq!(0.0f32.atanh(), 0.0f32);\n+    assert_eq!((-0.0f32).atanh(), -0.0f32);\n+\n+    let inf32: f32 = f32::INFINITY;\n+    let neg_inf32: f32 = f32::NEG_INFINITY;\n+    assert_eq!(1.0f32.atanh(), inf32);\n+    assert_eq!((-1.0f32).atanh(), neg_inf32);\n+\n+    assert!(2f64.atanh().atanh().is_nan());\n+    assert!((-2f64).atanh().atanh().is_nan());\n+\n+    let inf64: f32 = f32::INFINITY;\n+    let neg_inf64: f32 = f32::NEG_INFINITY;\n+    let nan32: f32 = f32::NAN;\n+    assert!(inf64.atanh().is_nan());\n+    assert!(neg_inf64.atanh().is_nan());\n+    assert!(nan32.atanh().is_nan());\n+\n+    assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n+    assert_approx_eq!((-0.5f32).atanh(), -0.54930614433405484569762261846126285f32);\n+}\n+\n+#[test]\n+fn test_real_consts() {\n+    use super::consts;\n+\n+    let pi: f32 = consts::PI;\n+    let frac_pi_2: f32 = consts::FRAC_PI_2;\n+    let frac_pi_3: f32 = consts::FRAC_PI_3;\n+    let frac_pi_4: f32 = consts::FRAC_PI_4;\n+    let frac_pi_6: f32 = consts::FRAC_PI_6;\n+    let frac_pi_8: f32 = consts::FRAC_PI_8;\n+    let frac_1_pi: f32 = consts::FRAC_1_PI;\n+    let frac_2_pi: f32 = consts::FRAC_2_PI;\n+    let frac_2_sqrtpi: f32 = consts::FRAC_2_SQRT_PI;\n+    let sqrt2: f32 = consts::SQRT_2;\n+    let frac_1_sqrt2: f32 = consts::FRAC_1_SQRT_2;\n+    let e: f32 = consts::E;\n+    let log2_e: f32 = consts::LOG2_E;\n+    let log10_e: f32 = consts::LOG10_E;\n+    let ln_2: f32 = consts::LN_2;\n+    let ln_10: f32 = consts::LN_10;\n+\n+    assert_approx_eq!(frac_pi_2, pi / 2f32);\n+    assert_approx_eq!(frac_pi_3, pi / 3f32);\n+    assert_approx_eq!(frac_pi_4, pi / 4f32);\n+    assert_approx_eq!(frac_pi_6, pi / 6f32);\n+    assert_approx_eq!(frac_pi_8, pi / 8f32);\n+    assert_approx_eq!(frac_1_pi, 1f32 / pi);\n+    assert_approx_eq!(frac_2_pi, 2f32 / pi);\n+    assert_approx_eq!(frac_2_sqrtpi, 2f32 / pi.sqrt());\n+    assert_approx_eq!(sqrt2, 2f32.sqrt());\n+    assert_approx_eq!(frac_1_sqrt2, 1f32 / 2f32.sqrt());\n+    assert_approx_eq!(log2_e, e.log2());\n+    assert_approx_eq!(log10_e, e.log10());\n+    assert_approx_eq!(ln_2, 2f32.ln());\n+    assert_approx_eq!(ln_10, 10f32.ln());\n+}\n+\n+#[test]\n+fn test_float_bits_conv() {\n+    assert_eq!((1f32).to_bits(), 0x3f800000);\n+    assert_eq!((12.5f32).to_bits(), 0x41480000);\n+    assert_eq!((1337f32).to_bits(), 0x44a72000);\n+    assert_eq!((-14.25f32).to_bits(), 0xc1640000);\n+    assert_approx_eq!(f32::from_bits(0x3f800000), 1.0);\n+    assert_approx_eq!(f32::from_bits(0x41480000), 12.5);\n+    assert_approx_eq!(f32::from_bits(0x44a72000), 1337.0);\n+    assert_approx_eq!(f32::from_bits(0xc1640000), -14.25);\n+\n+    // Check that NaNs roundtrip their bits regardless of signaling-ness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    let masked_nan1 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+    let masked_nan2 = f32::NAN.to_bits() ^ 0x0055_5555;\n+    assert!(f32::from_bits(masked_nan1).is_nan());\n+    assert!(f32::from_bits(masked_nan2).is_nan());\n+\n+    assert_eq!(f32::from_bits(masked_nan1).to_bits(), masked_nan1);\n+    assert_eq!(f32::from_bits(masked_nan2).to_bits(), masked_nan2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_min_greater_than_max() {\n+    let _ = 1.0f32.clamp(3.0, 1.0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_min_is_nan() {\n+    let _ = 1.0f32.clamp(f32::NAN, 1.0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_max_is_nan() {\n+    let _ = 1.0f32.clamp(3.0, f32::NAN);\n+}\n+\n+#[test]\n+fn test_total_cmp() {\n+    use core::cmp::Ordering;\n+\n+    fn quiet_bit_mask() -> u32 {\n+        1 << (f32::MANTISSA_DIGITS - 2)\n+    }\n+\n+    fn min_subnorm() -> f32 {\n+        f32::MIN_POSITIVE / f32::powf(2.0, f32::MANTISSA_DIGITS as f32 - 1.0)\n+    }\n+\n+    fn max_subnorm() -> f32 {\n+        f32::MIN_POSITIVE - min_subnorm()\n+    }\n+\n+    fn q_nan() -> f32 {\n+        f32::from_bits(f32::NAN.to_bits() | quiet_bit_mask())\n+    }\n+\n+    fn s_nan() -> f32 {\n+        f32::from_bits((f32::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+    }\n+\n+    assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+    assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Equal, (-f32::INFINITY).total_cmp(&-f32::INFINITY));\n+    assert_eq!(Ordering::Equal, (-f32::MAX).total_cmp(&-f32::MAX));\n+    assert_eq!(Ordering::Equal, (-2.5_f32).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Equal, (-1.0_f32).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Equal, (-1.5_f32).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Equal, (-0.5_f32).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Equal, (-f32::MIN_POSITIVE).total_cmp(&-f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Equal, (-0.0_f32).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Equal, 0.0_f32.total_cmp(&0.0));\n+    assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Equal, f32::MIN_POSITIVE.total_cmp(&f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Equal, 0.5_f32.total_cmp(&0.5));\n+    assert_eq!(Ordering::Equal, 1.0_f32.total_cmp(&1.0));\n+    assert_eq!(Ordering::Equal, 1.5_f32.total_cmp(&1.5));\n+    assert_eq!(Ordering::Equal, 2.5_f32.total_cmp(&2.5));\n+    assert_eq!(Ordering::Equal, f32::MAX.total_cmp(&f32::MAX));\n+    assert_eq!(Ordering::Equal, f32::INFINITY.total_cmp(&f32::INFINITY));\n+    assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+    assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+    assert_eq!(Ordering::Less, (-f32::INFINITY).total_cmp(&-f32::MAX));\n+    assert_eq!(Ordering::Less, (-f32::MAX).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-2.5_f32).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-1.5_f32).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-1.0_f32).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-0.5_f32).total_cmp(&-f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-f32::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-0.0_f32).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, 0.0_f32.total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, f32::MIN_POSITIVE.total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, 0.5_f32.total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, 1.0_f32.total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, 1.5_f32.total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, 2.5_f32.total_cmp(&f32::MAX));\n+    assert_eq!(Ordering::Less, f32::MAX.total_cmp(&f32::INFINITY));\n+    assert_eq!(Ordering::Less, f32::INFINITY.total_cmp(&s_nan()));\n+    assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+    assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+    assert_eq!(Ordering::Greater, (-f32::INFINITY).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Greater, (-f32::MAX).total_cmp(&-f32::INFINITY));\n+    assert_eq!(Ordering::Greater, (-2.5_f32).total_cmp(&-f32::MAX));\n+    assert_eq!(Ordering::Greater, (-1.5_f32).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Greater, (-1.0_f32).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Greater, (-0.5_f32).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Greater, (-f32::MIN_POSITIVE).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Greater, (-0.0_f32).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Greater, 0.0_f32.total_cmp(&-0.0));\n+    assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+    assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Greater, f32::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Greater, 0.5_f32.total_cmp(&f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Greater, 1.0_f32.total_cmp(&0.5));\n+    assert_eq!(Ordering::Greater, 1.5_f32.total_cmp(&1.0));\n+    assert_eq!(Ordering::Greater, 2.5_f32.total_cmp(&1.5));\n+    assert_eq!(Ordering::Greater, f32::MAX.total_cmp(&2.5));\n+    assert_eq!(Ordering::Greater, f32::INFINITY.total_cmp(&f32::MAX));\n+    assert_eq!(Ordering::Greater, s_nan().total_cmp(&f32::INFINITY));\n+    assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::INFINITY));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MAX));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::MAX));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f32::INFINITY));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::INFINITY));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MAX));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::MAX));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+}"}, {"sha": "bd094bdb55dc343da3c1eb033cd52aed2ff30f7c", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 3, "deletions": 759, "changes": 762, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -11,6 +11,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n+#[cfg(test)]\n+mod tests;\n+\n #[cfg(not(test))]\n use crate::intrinsics;\n #[cfg(not(test))]\n@@ -936,762 +939,3 @@ impl f64 {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::f64::consts;\n-    use crate::num::FpCategory as Fp;\n-    use crate::num::*;\n-\n-    #[test]\n-    fn test_num_f64() {\n-        test_num(10f64, 2f64);\n-    }\n-\n-    #[test]\n-    fn test_min_nan() {\n-        assert_eq!(f64::NAN.min(2.0), 2.0);\n-        assert_eq!(2.0f64.min(f64::NAN), 2.0);\n-    }\n-\n-    #[test]\n-    fn test_max_nan() {\n-        assert_eq!(f64::NAN.max(2.0), 2.0);\n-        assert_eq!(2.0f64.max(f64::NAN), 2.0);\n-    }\n-\n-    #[test]\n-    fn test_nan() {\n-        let nan: f64 = f64::NAN;\n-        assert!(nan.is_nan());\n-        assert!(!nan.is_infinite());\n-        assert!(!nan.is_finite());\n-        assert!(!nan.is_normal());\n-        assert!(nan.is_sign_positive());\n-        assert!(!nan.is_sign_negative());\n-        assert_eq!(Fp::Nan, nan.classify());\n-    }\n-\n-    #[test]\n-    fn test_infinity() {\n-        let inf: f64 = f64::INFINITY;\n-        assert!(inf.is_infinite());\n-        assert!(!inf.is_finite());\n-        assert!(inf.is_sign_positive());\n-        assert!(!inf.is_sign_negative());\n-        assert!(!inf.is_nan());\n-        assert!(!inf.is_normal());\n-        assert_eq!(Fp::Infinite, inf.classify());\n-    }\n-\n-    #[test]\n-    fn test_neg_infinity() {\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert!(neg_inf.is_infinite());\n-        assert!(!neg_inf.is_finite());\n-        assert!(!neg_inf.is_sign_positive());\n-        assert!(neg_inf.is_sign_negative());\n-        assert!(!neg_inf.is_nan());\n-        assert!(!neg_inf.is_normal());\n-        assert_eq!(Fp::Infinite, neg_inf.classify());\n-    }\n-\n-    #[test]\n-    fn test_zero() {\n-        let zero: f64 = 0.0f64;\n-        assert_eq!(0.0, zero);\n-        assert!(!zero.is_infinite());\n-        assert!(zero.is_finite());\n-        assert!(zero.is_sign_positive());\n-        assert!(!zero.is_sign_negative());\n-        assert!(!zero.is_nan());\n-        assert!(!zero.is_normal());\n-        assert_eq!(Fp::Zero, zero.classify());\n-    }\n-\n-    #[test]\n-    fn test_neg_zero() {\n-        let neg_zero: f64 = -0.0;\n-        assert_eq!(0.0, neg_zero);\n-        assert!(!neg_zero.is_infinite());\n-        assert!(neg_zero.is_finite());\n-        assert!(!neg_zero.is_sign_positive());\n-        assert!(neg_zero.is_sign_negative());\n-        assert!(!neg_zero.is_nan());\n-        assert!(!neg_zero.is_normal());\n-        assert_eq!(Fp::Zero, neg_zero.classify());\n-    }\n-\n-    #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n-    #[test]\n-    fn test_one() {\n-        let one: f64 = 1.0f64;\n-        assert_eq!(1.0, one);\n-        assert!(!one.is_infinite());\n-        assert!(one.is_finite());\n-        assert!(one.is_sign_positive());\n-        assert!(!one.is_sign_negative());\n-        assert!(!one.is_nan());\n-        assert!(one.is_normal());\n-        assert_eq!(Fp::Normal, one.classify());\n-    }\n-\n-    #[test]\n-    fn test_is_nan() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert!(nan.is_nan());\n-        assert!(!0.0f64.is_nan());\n-        assert!(!5.3f64.is_nan());\n-        assert!(!(-10.732f64).is_nan());\n-        assert!(!inf.is_nan());\n-        assert!(!neg_inf.is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_infinite() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert!(!nan.is_infinite());\n-        assert!(inf.is_infinite());\n-        assert!(neg_inf.is_infinite());\n-        assert!(!0.0f64.is_infinite());\n-        assert!(!42.8f64.is_infinite());\n-        assert!(!(-109.2f64).is_infinite());\n-    }\n-\n-    #[test]\n-    fn test_is_finite() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert!(!nan.is_finite());\n-        assert!(!inf.is_finite());\n-        assert!(!neg_inf.is_finite());\n-        assert!(0.0f64.is_finite());\n-        assert!(42.8f64.is_finite());\n-        assert!((-109.2f64).is_finite());\n-    }\n-\n-    #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n-    #[test]\n-    fn test_is_normal() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let zero: f64 = 0.0f64;\n-        let neg_zero: f64 = -0.0;\n-        assert!(!nan.is_normal());\n-        assert!(!inf.is_normal());\n-        assert!(!neg_inf.is_normal());\n-        assert!(!zero.is_normal());\n-        assert!(!neg_zero.is_normal());\n-        assert!(1f64.is_normal());\n-        assert!(1e-307f64.is_normal());\n-        assert!(!1e-308f64.is_normal());\n-    }\n-\n-    #[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n-    #[test]\n-    fn test_classify() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let zero: f64 = 0.0f64;\n-        let neg_zero: f64 = -0.0;\n-        assert_eq!(nan.classify(), Fp::Nan);\n-        assert_eq!(inf.classify(), Fp::Infinite);\n-        assert_eq!(neg_inf.classify(), Fp::Infinite);\n-        assert_eq!(zero.classify(), Fp::Zero);\n-        assert_eq!(neg_zero.classify(), Fp::Zero);\n-        assert_eq!(1e-307f64.classify(), Fp::Normal);\n-        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n-    }\n-\n-    #[test]\n-    fn test_floor() {\n-        assert_approx_eq!(1.0f64.floor(), 1.0f64);\n-        assert_approx_eq!(1.3f64.floor(), 1.0f64);\n-        assert_approx_eq!(1.5f64.floor(), 1.0f64);\n-        assert_approx_eq!(1.7f64.floor(), 1.0f64);\n-        assert_approx_eq!(0.0f64.floor(), 0.0f64);\n-        assert_approx_eq!((-0.0f64).floor(), -0.0f64);\n-        assert_approx_eq!((-1.0f64).floor(), -1.0f64);\n-        assert_approx_eq!((-1.3f64).floor(), -2.0f64);\n-        assert_approx_eq!((-1.5f64).floor(), -2.0f64);\n-        assert_approx_eq!((-1.7f64).floor(), -2.0f64);\n-    }\n-\n-    #[test]\n-    fn test_ceil() {\n-        assert_approx_eq!(1.0f64.ceil(), 1.0f64);\n-        assert_approx_eq!(1.3f64.ceil(), 2.0f64);\n-        assert_approx_eq!(1.5f64.ceil(), 2.0f64);\n-        assert_approx_eq!(1.7f64.ceil(), 2.0f64);\n-        assert_approx_eq!(0.0f64.ceil(), 0.0f64);\n-        assert_approx_eq!((-0.0f64).ceil(), -0.0f64);\n-        assert_approx_eq!((-1.0f64).ceil(), -1.0f64);\n-        assert_approx_eq!((-1.3f64).ceil(), -1.0f64);\n-        assert_approx_eq!((-1.5f64).ceil(), -1.0f64);\n-        assert_approx_eq!((-1.7f64).ceil(), -1.0f64);\n-    }\n-\n-    #[test]\n-    fn test_round() {\n-        assert_approx_eq!(1.0f64.round(), 1.0f64);\n-        assert_approx_eq!(1.3f64.round(), 1.0f64);\n-        assert_approx_eq!(1.5f64.round(), 2.0f64);\n-        assert_approx_eq!(1.7f64.round(), 2.0f64);\n-        assert_approx_eq!(0.0f64.round(), 0.0f64);\n-        assert_approx_eq!((-0.0f64).round(), -0.0f64);\n-        assert_approx_eq!((-1.0f64).round(), -1.0f64);\n-        assert_approx_eq!((-1.3f64).round(), -1.0f64);\n-        assert_approx_eq!((-1.5f64).round(), -2.0f64);\n-        assert_approx_eq!((-1.7f64).round(), -2.0f64);\n-    }\n-\n-    #[test]\n-    fn test_trunc() {\n-        assert_approx_eq!(1.0f64.trunc(), 1.0f64);\n-        assert_approx_eq!(1.3f64.trunc(), 1.0f64);\n-        assert_approx_eq!(1.5f64.trunc(), 1.0f64);\n-        assert_approx_eq!(1.7f64.trunc(), 1.0f64);\n-        assert_approx_eq!(0.0f64.trunc(), 0.0f64);\n-        assert_approx_eq!((-0.0f64).trunc(), -0.0f64);\n-        assert_approx_eq!((-1.0f64).trunc(), -1.0f64);\n-        assert_approx_eq!((-1.3f64).trunc(), -1.0f64);\n-        assert_approx_eq!((-1.5f64).trunc(), -1.0f64);\n-        assert_approx_eq!((-1.7f64).trunc(), -1.0f64);\n-    }\n-\n-    #[test]\n-    fn test_fract() {\n-        assert_approx_eq!(1.0f64.fract(), 0.0f64);\n-        assert_approx_eq!(1.3f64.fract(), 0.3f64);\n-        assert_approx_eq!(1.5f64.fract(), 0.5f64);\n-        assert_approx_eq!(1.7f64.fract(), 0.7f64);\n-        assert_approx_eq!(0.0f64.fract(), 0.0f64);\n-        assert_approx_eq!((-0.0f64).fract(), -0.0f64);\n-        assert_approx_eq!((-1.0f64).fract(), -0.0f64);\n-        assert_approx_eq!((-1.3f64).fract(), -0.3f64);\n-        assert_approx_eq!((-1.5f64).fract(), -0.5f64);\n-        assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n-    }\n-\n-    #[test]\n-    fn test_abs() {\n-        assert_eq!(f64::INFINITY.abs(), f64::INFINITY);\n-        assert_eq!(1f64.abs(), 1f64);\n-        assert_eq!(0f64.abs(), 0f64);\n-        assert_eq!((-0f64).abs(), 0f64);\n-        assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(f64::NEG_INFINITY.abs(), f64::INFINITY);\n-        assert_eq!((1f64 / f64::NEG_INFINITY).abs(), 0f64);\n-        assert!(f64::NAN.abs().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_signum() {\n-        assert_eq!(f64::INFINITY.signum(), 1f64);\n-        assert_eq!(1f64.signum(), 1f64);\n-        assert_eq!(0f64.signum(), 1f64);\n-        assert_eq!((-0f64).signum(), -1f64);\n-        assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(f64::NEG_INFINITY.signum(), -1f64);\n-        assert_eq!((1f64 / f64::NEG_INFINITY).signum(), -1f64);\n-        assert!(f64::NAN.signum().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_is_sign_positive() {\n-        assert!(f64::INFINITY.is_sign_positive());\n-        assert!(1f64.is_sign_positive());\n-        assert!(0f64.is_sign_positive());\n-        assert!(!(-0f64).is_sign_positive());\n-        assert!(!(-1f64).is_sign_positive());\n-        assert!(!f64::NEG_INFINITY.is_sign_positive());\n-        assert!(!(1f64 / f64::NEG_INFINITY).is_sign_positive());\n-        assert!(f64::NAN.is_sign_positive());\n-        assert!(!(-f64::NAN).is_sign_positive());\n-    }\n-\n-    #[test]\n-    fn test_is_sign_negative() {\n-        assert!(!f64::INFINITY.is_sign_negative());\n-        assert!(!1f64.is_sign_negative());\n-        assert!(!0f64.is_sign_negative());\n-        assert!((-0f64).is_sign_negative());\n-        assert!((-1f64).is_sign_negative());\n-        assert!(f64::NEG_INFINITY.is_sign_negative());\n-        assert!((1f64 / f64::NEG_INFINITY).is_sign_negative());\n-        assert!(!f64::NAN.is_sign_negative());\n-        assert!((-f64::NAN).is_sign_negative());\n-    }\n-\n-    #[test]\n-    fn test_mul_add() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n-        assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n-        assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n-        assert_approx_eq!(3.4f64.mul_add(-0.0, 5.6), 5.6);\n-        assert!(nan.mul_add(7.8, 9.0).is_nan());\n-        assert_eq!(inf.mul_add(7.8, 9.0), inf);\n-        assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n-        assert_eq!(8.9f64.mul_add(inf, 3.2), inf);\n-        assert_eq!((-3.2f64).mul_add(2.4, neg_inf), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_recip() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(1.0f64.recip(), 1.0);\n-        assert_eq!(2.0f64.recip(), 0.5);\n-        assert_eq!((-0.4f64).recip(), -2.5);\n-        assert_eq!(0.0f64.recip(), inf);\n-        assert!(nan.recip().is_nan());\n-        assert_eq!(inf.recip(), 0.0);\n-        assert_eq!(neg_inf.recip(), 0.0);\n-    }\n-\n-    #[test]\n-    fn test_powi() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(1.0f64.powi(1), 1.0);\n-        assert_approx_eq!((-3.1f64).powi(2), 9.61);\n-        assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n-        assert_eq!(8.3f64.powi(0), 1.0);\n-        assert!(nan.powi(2).is_nan());\n-        assert_eq!(inf.powi(3), inf);\n-        assert_eq!(neg_inf.powi(2), inf);\n-    }\n-\n-    #[test]\n-    fn test_powf() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(1.0f64.powf(1.0), 1.0);\n-        assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n-        assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n-        assert_approx_eq!((-3.1f64).powf(2.0), 9.61);\n-        assert_approx_eq!(5.9f64.powf(-2.0), 0.028727);\n-        assert_eq!(8.3f64.powf(0.0), 1.0);\n-        assert!(nan.powf(2.0).is_nan());\n-        assert_eq!(inf.powf(2.0), inf);\n-        assert_eq!(neg_inf.powf(3.0), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_sqrt_domain() {\n-        assert!(f64::NAN.sqrt().is_nan());\n-        assert!(f64::NEG_INFINITY.sqrt().is_nan());\n-        assert!((-1.0f64).sqrt().is_nan());\n-        assert_eq!((-0.0f64).sqrt(), -0.0);\n-        assert_eq!(0.0f64.sqrt(), 0.0);\n-        assert_eq!(1.0f64.sqrt(), 1.0);\n-        assert_eq!(f64::INFINITY.sqrt(), f64::INFINITY);\n-    }\n-\n-    #[test]\n-    fn test_exp() {\n-        assert_eq!(1.0, 0.0f64.exp());\n-        assert_approx_eq!(2.718282, 1.0f64.exp());\n-        assert_approx_eq!(148.413159, 5.0f64.exp());\n-\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let nan: f64 = f64::NAN;\n-        assert_eq!(inf, inf.exp());\n-        assert_eq!(0.0, neg_inf.exp());\n-        assert!(nan.exp().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_exp2() {\n-        assert_eq!(32.0, 5.0f64.exp2());\n-        assert_eq!(1.0, 0.0f64.exp2());\n-\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let nan: f64 = f64::NAN;\n-        assert_eq!(inf, inf.exp2());\n-        assert_eq!(0.0, neg_inf.exp2());\n-        assert!(nan.exp2().is_nan());\n-    }\n-\n-    #[test]\n-    fn test_ln() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n-        assert!(nan.ln().is_nan());\n-        assert_eq!(inf.ln(), inf);\n-        assert!(neg_inf.ln().is_nan());\n-        assert!((-2.3f64).ln().is_nan());\n-        assert_eq!((-0.0f64).ln(), neg_inf);\n-        assert_eq!(0.0f64.ln(), neg_inf);\n-        assert_approx_eq!(4.0f64.ln(), 1.386294);\n-    }\n-\n-    #[test]\n-    fn test_log() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(10.0f64.log(10.0), 1.0);\n-        assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n-        assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n-        assert!(1.0f64.log(1.0).is_nan());\n-        assert!(1.0f64.log(-13.9).is_nan());\n-        assert!(nan.log(2.3).is_nan());\n-        assert_eq!(inf.log(10.0), inf);\n-        assert!(neg_inf.log(8.8).is_nan());\n-        assert!((-2.3f64).log(0.1).is_nan());\n-        assert_eq!((-0.0f64).log(2.0), neg_inf);\n-        assert_eq!(0.0f64.log(7.0), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_log2() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_approx_eq!(10.0f64.log2(), 3.321928);\n-        assert_approx_eq!(2.3f64.log2(), 1.201634);\n-        assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n-        assert!(nan.log2().is_nan());\n-        assert_eq!(inf.log2(), inf);\n-        assert!(neg_inf.log2().is_nan());\n-        assert!((-2.3f64).log2().is_nan());\n-        assert_eq!((-0.0f64).log2(), neg_inf);\n-        assert_eq!(0.0f64.log2(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_log10() {\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(10.0f64.log10(), 1.0);\n-        assert_approx_eq!(2.3f64.log10(), 0.361728);\n-        assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n-        assert_eq!(1.0f64.log10(), 0.0);\n-        assert!(nan.log10().is_nan());\n-        assert_eq!(inf.log10(), inf);\n-        assert!(neg_inf.log10().is_nan());\n-        assert!((-2.3f64).log10().is_nan());\n-        assert_eq!((-0.0f64).log10(), neg_inf);\n-        assert_eq!(0.0f64.log10(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_to_degrees() {\n-        let pi: f64 = consts::PI;\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(0.0f64.to_degrees(), 0.0);\n-        assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n-        assert_eq!(pi.to_degrees(), 180.0);\n-        assert!(nan.to_degrees().is_nan());\n-        assert_eq!(inf.to_degrees(), inf);\n-        assert_eq!(neg_inf.to_degrees(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_to_radians() {\n-        let pi: f64 = consts::PI;\n-        let nan: f64 = f64::NAN;\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        assert_eq!(0.0f64.to_radians(), 0.0);\n-        assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n-        assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n-        assert_eq!(180.0f64.to_radians(), pi);\n-        assert!(nan.to_radians().is_nan());\n-        assert_eq!(inf.to_radians(), inf);\n-        assert_eq!(neg_inf.to_radians(), neg_inf);\n-    }\n-\n-    #[test]\n-    fn test_asinh() {\n-        assert_eq!(0.0f64.asinh(), 0.0f64);\n-        assert_eq!((-0.0f64).asinh(), -0.0f64);\n-\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let nan: f64 = f64::NAN;\n-        assert_eq!(inf.asinh(), inf);\n-        assert_eq!(neg_inf.asinh(), neg_inf);\n-        assert!(nan.asinh().is_nan());\n-        assert!((-0.0f64).asinh().is_sign_negative());\n-        // issue 63271\n-        assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n-        assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n-        // regression test for the catastrophic cancellation fixed in 72486\n-        assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n-    }\n-\n-    #[test]\n-    fn test_acosh() {\n-        assert_eq!(1.0f64.acosh(), 0.0f64);\n-        assert!(0.999f64.acosh().is_nan());\n-\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let nan: f64 = f64::NAN;\n-        assert_eq!(inf.acosh(), inf);\n-        assert!(neg_inf.acosh().is_nan());\n-        assert!(nan.acosh().is_nan());\n-        assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n-        assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n-    }\n-\n-    #[test]\n-    fn test_atanh() {\n-        assert_eq!(0.0f64.atanh(), 0.0f64);\n-        assert_eq!((-0.0f64).atanh(), -0.0f64);\n-\n-        let inf: f64 = f64::INFINITY;\n-        let neg_inf: f64 = f64::NEG_INFINITY;\n-        let nan: f64 = f64::NAN;\n-        assert_eq!(1.0f64.atanh(), inf);\n-        assert_eq!((-1.0f64).atanh(), neg_inf);\n-        assert!(2f64.atanh().atanh().is_nan());\n-        assert!((-2f64).atanh().atanh().is_nan());\n-        assert!(inf.atanh().is_nan());\n-        assert!(neg_inf.atanh().is_nan());\n-        assert!(nan.atanh().is_nan());\n-        assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n-        assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n-    }\n-\n-    #[test]\n-    fn test_real_consts() {\n-        use super::consts;\n-        let pi: f64 = consts::PI;\n-        let frac_pi_2: f64 = consts::FRAC_PI_2;\n-        let frac_pi_3: f64 = consts::FRAC_PI_3;\n-        let frac_pi_4: f64 = consts::FRAC_PI_4;\n-        let frac_pi_6: f64 = consts::FRAC_PI_6;\n-        let frac_pi_8: f64 = consts::FRAC_PI_8;\n-        let frac_1_pi: f64 = consts::FRAC_1_PI;\n-        let frac_2_pi: f64 = consts::FRAC_2_PI;\n-        let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n-        let sqrt2: f64 = consts::SQRT_2;\n-        let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n-        let e: f64 = consts::E;\n-        let log2_e: f64 = consts::LOG2_E;\n-        let log10_e: f64 = consts::LOG10_E;\n-        let ln_2: f64 = consts::LN_2;\n-        let ln_10: f64 = consts::LN_10;\n-\n-        assert_approx_eq!(frac_pi_2, pi / 2f64);\n-        assert_approx_eq!(frac_pi_3, pi / 3f64);\n-        assert_approx_eq!(frac_pi_4, pi / 4f64);\n-        assert_approx_eq!(frac_pi_6, pi / 6f64);\n-        assert_approx_eq!(frac_pi_8, pi / 8f64);\n-        assert_approx_eq!(frac_1_pi, 1f64 / pi);\n-        assert_approx_eq!(frac_2_pi, 2f64 / pi);\n-        assert_approx_eq!(frac_2_sqrtpi, 2f64 / pi.sqrt());\n-        assert_approx_eq!(sqrt2, 2f64.sqrt());\n-        assert_approx_eq!(frac_1_sqrt2, 1f64 / 2f64.sqrt());\n-        assert_approx_eq!(log2_e, e.log2());\n-        assert_approx_eq!(log10_e, e.log10());\n-        assert_approx_eq!(ln_2, 2f64.ln());\n-        assert_approx_eq!(ln_10, 10f64.ln());\n-    }\n-\n-    #[test]\n-    fn test_float_bits_conv() {\n-        assert_eq!((1f64).to_bits(), 0x3ff0000000000000);\n-        assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n-        assert_eq!((1337f64).to_bits(), 0x4094e40000000000);\n-        assert_eq!((-14.25f64).to_bits(), 0xc02c800000000000);\n-        assert_approx_eq!(f64::from_bits(0x3ff0000000000000), 1.0);\n-        assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n-        assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n-        assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n-\n-        // Check that NaNs roundtrip their bits regardless of signaling-ness\n-        // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n-        let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n-        let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n-        assert!(f64::from_bits(masked_nan1).is_nan());\n-        assert!(f64::from_bits(masked_nan2).is_nan());\n-\n-        assert_eq!(f64::from_bits(masked_nan1).to_bits(), masked_nan1);\n-        assert_eq!(f64::from_bits(masked_nan2).to_bits(), masked_nan2);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_min_greater_than_max() {\n-        let _ = 1.0f64.clamp(3.0, 1.0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_min_is_nan() {\n-        let _ = 1.0f64.clamp(f64::NAN, 1.0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clamp_max_is_nan() {\n-        let _ = 1.0f64.clamp(3.0, f64::NAN);\n-    }\n-\n-    #[test]\n-    fn test_total_cmp() {\n-        use core::cmp::Ordering;\n-\n-        fn quiet_bit_mask() -> u64 {\n-            1 << (f64::MANTISSA_DIGITS - 2)\n-        }\n-\n-        fn min_subnorm() -> f64 {\n-            f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n-        }\n-\n-        fn max_subnorm() -> f64 {\n-            f64::MIN_POSITIVE - min_subnorm()\n-        }\n-\n-        fn q_nan() -> f64 {\n-            f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n-        }\n-\n-        fn s_nan() -> f64 {\n-            f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n-        }\n-\n-        assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n-        assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n-        assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n-        assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n-        assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n-        assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n-        assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n-        assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n-        assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n-        assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n-        assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n-        assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n-\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n-        assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n-        assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n-        assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n-        assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n-        assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n-\n-        assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n-        assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n-        assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n-        assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n-        assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n-        assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n-        assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n-        assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n-        assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n-        assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n-        assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n-        assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n-\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n-        assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n-\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n-        assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n-    }\n-}"}, {"sha": "5c163cfe90e0b2eff9030bc80dd0cfeb4c71532c", "filename": "library/std/src/f64/tests.rs", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,755 @@\n+use crate::f64::consts;\n+use crate::num::FpCategory as Fp;\n+use crate::num::*;\n+\n+#[test]\n+fn test_num_f64() {\n+    test_num(10f64, 2f64);\n+}\n+\n+#[test]\n+fn test_min_nan() {\n+    assert_eq!(f64::NAN.min(2.0), 2.0);\n+    assert_eq!(2.0f64.min(f64::NAN), 2.0);\n+}\n+\n+#[test]\n+fn test_max_nan() {\n+    assert_eq!(f64::NAN.max(2.0), 2.0);\n+    assert_eq!(2.0f64.max(f64::NAN), 2.0);\n+}\n+\n+#[test]\n+fn test_nan() {\n+    let nan: f64 = f64::NAN;\n+    assert!(nan.is_nan());\n+    assert!(!nan.is_infinite());\n+    assert!(!nan.is_finite());\n+    assert!(!nan.is_normal());\n+    assert!(nan.is_sign_positive());\n+    assert!(!nan.is_sign_negative());\n+    assert_eq!(Fp::Nan, nan.classify());\n+}\n+\n+#[test]\n+fn test_infinity() {\n+    let inf: f64 = f64::INFINITY;\n+    assert!(inf.is_infinite());\n+    assert!(!inf.is_finite());\n+    assert!(inf.is_sign_positive());\n+    assert!(!inf.is_sign_negative());\n+    assert!(!inf.is_nan());\n+    assert!(!inf.is_normal());\n+    assert_eq!(Fp::Infinite, inf.classify());\n+}\n+\n+#[test]\n+fn test_neg_infinity() {\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert!(neg_inf.is_infinite());\n+    assert!(!neg_inf.is_finite());\n+    assert!(!neg_inf.is_sign_positive());\n+    assert!(neg_inf.is_sign_negative());\n+    assert!(!neg_inf.is_nan());\n+    assert!(!neg_inf.is_normal());\n+    assert_eq!(Fp::Infinite, neg_inf.classify());\n+}\n+\n+#[test]\n+fn test_zero() {\n+    let zero: f64 = 0.0f64;\n+    assert_eq!(0.0, zero);\n+    assert!(!zero.is_infinite());\n+    assert!(zero.is_finite());\n+    assert!(zero.is_sign_positive());\n+    assert!(!zero.is_sign_negative());\n+    assert!(!zero.is_nan());\n+    assert!(!zero.is_normal());\n+    assert_eq!(Fp::Zero, zero.classify());\n+}\n+\n+#[test]\n+fn test_neg_zero() {\n+    let neg_zero: f64 = -0.0;\n+    assert_eq!(0.0, neg_zero);\n+    assert!(!neg_zero.is_infinite());\n+    assert!(neg_zero.is_finite());\n+    assert!(!neg_zero.is_sign_positive());\n+    assert!(neg_zero.is_sign_negative());\n+    assert!(!neg_zero.is_nan());\n+    assert!(!neg_zero.is_normal());\n+    assert_eq!(Fp::Zero, neg_zero.classify());\n+}\n+\n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n+#[test]\n+fn test_one() {\n+    let one: f64 = 1.0f64;\n+    assert_eq!(1.0, one);\n+    assert!(!one.is_infinite());\n+    assert!(one.is_finite());\n+    assert!(one.is_sign_positive());\n+    assert!(!one.is_sign_negative());\n+    assert!(!one.is_nan());\n+    assert!(one.is_normal());\n+    assert_eq!(Fp::Normal, one.classify());\n+}\n+\n+#[test]\n+fn test_is_nan() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert!(nan.is_nan());\n+    assert!(!0.0f64.is_nan());\n+    assert!(!5.3f64.is_nan());\n+    assert!(!(-10.732f64).is_nan());\n+    assert!(!inf.is_nan());\n+    assert!(!neg_inf.is_nan());\n+}\n+\n+#[test]\n+fn test_is_infinite() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert!(!nan.is_infinite());\n+    assert!(inf.is_infinite());\n+    assert!(neg_inf.is_infinite());\n+    assert!(!0.0f64.is_infinite());\n+    assert!(!42.8f64.is_infinite());\n+    assert!(!(-109.2f64).is_infinite());\n+}\n+\n+#[test]\n+fn test_is_finite() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert!(!nan.is_finite());\n+    assert!(!inf.is_finite());\n+    assert!(!neg_inf.is_finite());\n+    assert!(0.0f64.is_finite());\n+    assert!(42.8f64.is_finite());\n+    assert!((-109.2f64).is_finite());\n+}\n+\n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n+#[test]\n+fn test_is_normal() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let zero: f64 = 0.0f64;\n+    let neg_zero: f64 = -0.0;\n+    assert!(!nan.is_normal());\n+    assert!(!inf.is_normal());\n+    assert!(!neg_inf.is_normal());\n+    assert!(!zero.is_normal());\n+    assert!(!neg_zero.is_normal());\n+    assert!(1f64.is_normal());\n+    assert!(1e-307f64.is_normal());\n+    assert!(!1e-308f64.is_normal());\n+}\n+\n+#[cfg_attr(all(target_arch = \"wasm32\", target_os = \"emscripten\"), ignore)] // issue 42630\n+#[test]\n+fn test_classify() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let zero: f64 = 0.0f64;\n+    let neg_zero: f64 = -0.0;\n+    assert_eq!(nan.classify(), Fp::Nan);\n+    assert_eq!(inf.classify(), Fp::Infinite);\n+    assert_eq!(neg_inf.classify(), Fp::Infinite);\n+    assert_eq!(zero.classify(), Fp::Zero);\n+    assert_eq!(neg_zero.classify(), Fp::Zero);\n+    assert_eq!(1e-307f64.classify(), Fp::Normal);\n+    assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n+}\n+\n+#[test]\n+fn test_floor() {\n+    assert_approx_eq!(1.0f64.floor(), 1.0f64);\n+    assert_approx_eq!(1.3f64.floor(), 1.0f64);\n+    assert_approx_eq!(1.5f64.floor(), 1.0f64);\n+    assert_approx_eq!(1.7f64.floor(), 1.0f64);\n+    assert_approx_eq!(0.0f64.floor(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).floor(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).floor(), -1.0f64);\n+    assert_approx_eq!((-1.3f64).floor(), -2.0f64);\n+    assert_approx_eq!((-1.5f64).floor(), -2.0f64);\n+    assert_approx_eq!((-1.7f64).floor(), -2.0f64);\n+}\n+\n+#[test]\n+fn test_ceil() {\n+    assert_approx_eq!(1.0f64.ceil(), 1.0f64);\n+    assert_approx_eq!(1.3f64.ceil(), 2.0f64);\n+    assert_approx_eq!(1.5f64.ceil(), 2.0f64);\n+    assert_approx_eq!(1.7f64.ceil(), 2.0f64);\n+    assert_approx_eq!(0.0f64.ceil(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).ceil(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).ceil(), -1.0f64);\n+    assert_approx_eq!((-1.3f64).ceil(), -1.0f64);\n+    assert_approx_eq!((-1.5f64).ceil(), -1.0f64);\n+    assert_approx_eq!((-1.7f64).ceil(), -1.0f64);\n+}\n+\n+#[test]\n+fn test_round() {\n+    assert_approx_eq!(1.0f64.round(), 1.0f64);\n+    assert_approx_eq!(1.3f64.round(), 1.0f64);\n+    assert_approx_eq!(1.5f64.round(), 2.0f64);\n+    assert_approx_eq!(1.7f64.round(), 2.0f64);\n+    assert_approx_eq!(0.0f64.round(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).round(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).round(), -1.0f64);\n+    assert_approx_eq!((-1.3f64).round(), -1.0f64);\n+    assert_approx_eq!((-1.5f64).round(), -2.0f64);\n+    assert_approx_eq!((-1.7f64).round(), -2.0f64);\n+}\n+\n+#[test]\n+fn test_trunc() {\n+    assert_approx_eq!(1.0f64.trunc(), 1.0f64);\n+    assert_approx_eq!(1.3f64.trunc(), 1.0f64);\n+    assert_approx_eq!(1.5f64.trunc(), 1.0f64);\n+    assert_approx_eq!(1.7f64.trunc(), 1.0f64);\n+    assert_approx_eq!(0.0f64.trunc(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).trunc(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).trunc(), -1.0f64);\n+    assert_approx_eq!((-1.3f64).trunc(), -1.0f64);\n+    assert_approx_eq!((-1.5f64).trunc(), -1.0f64);\n+    assert_approx_eq!((-1.7f64).trunc(), -1.0f64);\n+}\n+\n+#[test]\n+fn test_fract() {\n+    assert_approx_eq!(1.0f64.fract(), 0.0f64);\n+    assert_approx_eq!(1.3f64.fract(), 0.3f64);\n+    assert_approx_eq!(1.5f64.fract(), 0.5f64);\n+    assert_approx_eq!(1.7f64.fract(), 0.7f64);\n+    assert_approx_eq!(0.0f64.fract(), 0.0f64);\n+    assert_approx_eq!((-0.0f64).fract(), -0.0f64);\n+    assert_approx_eq!((-1.0f64).fract(), -0.0f64);\n+    assert_approx_eq!((-1.3f64).fract(), -0.3f64);\n+    assert_approx_eq!((-1.5f64).fract(), -0.5f64);\n+    assert_approx_eq!((-1.7f64).fract(), -0.7f64);\n+}\n+\n+#[test]\n+fn test_abs() {\n+    assert_eq!(f64::INFINITY.abs(), f64::INFINITY);\n+    assert_eq!(1f64.abs(), 1f64);\n+    assert_eq!(0f64.abs(), 0f64);\n+    assert_eq!((-0f64).abs(), 0f64);\n+    assert_eq!((-1f64).abs(), 1f64);\n+    assert_eq!(f64::NEG_INFINITY.abs(), f64::INFINITY);\n+    assert_eq!((1f64 / f64::NEG_INFINITY).abs(), 0f64);\n+    assert!(f64::NAN.abs().is_nan());\n+}\n+\n+#[test]\n+fn test_signum() {\n+    assert_eq!(f64::INFINITY.signum(), 1f64);\n+    assert_eq!(1f64.signum(), 1f64);\n+    assert_eq!(0f64.signum(), 1f64);\n+    assert_eq!((-0f64).signum(), -1f64);\n+    assert_eq!((-1f64).signum(), -1f64);\n+    assert_eq!(f64::NEG_INFINITY.signum(), -1f64);\n+    assert_eq!((1f64 / f64::NEG_INFINITY).signum(), -1f64);\n+    assert!(f64::NAN.signum().is_nan());\n+}\n+\n+#[test]\n+fn test_is_sign_positive() {\n+    assert!(f64::INFINITY.is_sign_positive());\n+    assert!(1f64.is_sign_positive());\n+    assert!(0f64.is_sign_positive());\n+    assert!(!(-0f64).is_sign_positive());\n+    assert!(!(-1f64).is_sign_positive());\n+    assert!(!f64::NEG_INFINITY.is_sign_positive());\n+    assert!(!(1f64 / f64::NEG_INFINITY).is_sign_positive());\n+    assert!(f64::NAN.is_sign_positive());\n+    assert!(!(-f64::NAN).is_sign_positive());\n+}\n+\n+#[test]\n+fn test_is_sign_negative() {\n+    assert!(!f64::INFINITY.is_sign_negative());\n+    assert!(!1f64.is_sign_negative());\n+    assert!(!0f64.is_sign_negative());\n+    assert!((-0f64).is_sign_negative());\n+    assert!((-1f64).is_sign_negative());\n+    assert!(f64::NEG_INFINITY.is_sign_negative());\n+    assert!((1f64 / f64::NEG_INFINITY).is_sign_negative());\n+    assert!(!f64::NAN.is_sign_negative());\n+    assert!((-f64::NAN).is_sign_negative());\n+}\n+\n+#[test]\n+fn test_mul_add() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_approx_eq!(12.3f64.mul_add(4.5, 6.7), 62.05);\n+    assert_approx_eq!((-12.3f64).mul_add(-4.5, -6.7), 48.65);\n+    assert_approx_eq!(0.0f64.mul_add(8.9, 1.2), 1.2);\n+    assert_approx_eq!(3.4f64.mul_add(-0.0, 5.6), 5.6);\n+    assert!(nan.mul_add(7.8, 9.0).is_nan());\n+    assert_eq!(inf.mul_add(7.8, 9.0), inf);\n+    assert_eq!(neg_inf.mul_add(7.8, 9.0), neg_inf);\n+    assert_eq!(8.9f64.mul_add(inf, 3.2), inf);\n+    assert_eq!((-3.2f64).mul_add(2.4, neg_inf), neg_inf);\n+}\n+\n+#[test]\n+fn test_recip() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(1.0f64.recip(), 1.0);\n+    assert_eq!(2.0f64.recip(), 0.5);\n+    assert_eq!((-0.4f64).recip(), -2.5);\n+    assert_eq!(0.0f64.recip(), inf);\n+    assert!(nan.recip().is_nan());\n+    assert_eq!(inf.recip(), 0.0);\n+    assert_eq!(neg_inf.recip(), 0.0);\n+}\n+\n+#[test]\n+fn test_powi() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(1.0f64.powi(1), 1.0);\n+    assert_approx_eq!((-3.1f64).powi(2), 9.61);\n+    assert_approx_eq!(5.9f64.powi(-2), 0.028727);\n+    assert_eq!(8.3f64.powi(0), 1.0);\n+    assert!(nan.powi(2).is_nan());\n+    assert_eq!(inf.powi(3), inf);\n+    assert_eq!(neg_inf.powi(2), inf);\n+}\n+\n+#[test]\n+fn test_powf() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(1.0f64.powf(1.0), 1.0);\n+    assert_approx_eq!(3.4f64.powf(4.5), 246.408183);\n+    assert_approx_eq!(2.7f64.powf(-3.2), 0.041652);\n+    assert_approx_eq!((-3.1f64).powf(2.0), 9.61);\n+    assert_approx_eq!(5.9f64.powf(-2.0), 0.028727);\n+    assert_eq!(8.3f64.powf(0.0), 1.0);\n+    assert!(nan.powf(2.0).is_nan());\n+    assert_eq!(inf.powf(2.0), inf);\n+    assert_eq!(neg_inf.powf(3.0), neg_inf);\n+}\n+\n+#[test]\n+fn test_sqrt_domain() {\n+    assert!(f64::NAN.sqrt().is_nan());\n+    assert!(f64::NEG_INFINITY.sqrt().is_nan());\n+    assert!((-1.0f64).sqrt().is_nan());\n+    assert_eq!((-0.0f64).sqrt(), -0.0);\n+    assert_eq!(0.0f64.sqrt(), 0.0);\n+    assert_eq!(1.0f64.sqrt(), 1.0);\n+    assert_eq!(f64::INFINITY.sqrt(), f64::INFINITY);\n+}\n+\n+#[test]\n+fn test_exp() {\n+    assert_eq!(1.0, 0.0f64.exp());\n+    assert_approx_eq!(2.718282, 1.0f64.exp());\n+    assert_approx_eq!(148.413159, 5.0f64.exp());\n+\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let nan: f64 = f64::NAN;\n+    assert_eq!(inf, inf.exp());\n+    assert_eq!(0.0, neg_inf.exp());\n+    assert!(nan.exp().is_nan());\n+}\n+\n+#[test]\n+fn test_exp2() {\n+    assert_eq!(32.0, 5.0f64.exp2());\n+    assert_eq!(1.0, 0.0f64.exp2());\n+\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let nan: f64 = f64::NAN;\n+    assert_eq!(inf, inf.exp2());\n+    assert_eq!(0.0, neg_inf.exp2());\n+    assert!(nan.exp2().is_nan());\n+}\n+\n+#[test]\n+fn test_ln() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_approx_eq!(1.0f64.exp().ln(), 1.0);\n+    assert!(nan.ln().is_nan());\n+    assert_eq!(inf.ln(), inf);\n+    assert!(neg_inf.ln().is_nan());\n+    assert!((-2.3f64).ln().is_nan());\n+    assert_eq!((-0.0f64).ln(), neg_inf);\n+    assert_eq!(0.0f64.ln(), neg_inf);\n+    assert_approx_eq!(4.0f64.ln(), 1.386294);\n+}\n+\n+#[test]\n+fn test_log() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(10.0f64.log(10.0), 1.0);\n+    assert_approx_eq!(2.3f64.log(3.5), 0.664858);\n+    assert_eq!(1.0f64.exp().log(1.0f64.exp()), 1.0);\n+    assert!(1.0f64.log(1.0).is_nan());\n+    assert!(1.0f64.log(-13.9).is_nan());\n+    assert!(nan.log(2.3).is_nan());\n+    assert_eq!(inf.log(10.0), inf);\n+    assert!(neg_inf.log(8.8).is_nan());\n+    assert!((-2.3f64).log(0.1).is_nan());\n+    assert_eq!((-0.0f64).log(2.0), neg_inf);\n+    assert_eq!(0.0f64.log(7.0), neg_inf);\n+}\n+\n+#[test]\n+fn test_log2() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_approx_eq!(10.0f64.log2(), 3.321928);\n+    assert_approx_eq!(2.3f64.log2(), 1.201634);\n+    assert_approx_eq!(1.0f64.exp().log2(), 1.442695);\n+    assert!(nan.log2().is_nan());\n+    assert_eq!(inf.log2(), inf);\n+    assert!(neg_inf.log2().is_nan());\n+    assert!((-2.3f64).log2().is_nan());\n+    assert_eq!((-0.0f64).log2(), neg_inf);\n+    assert_eq!(0.0f64.log2(), neg_inf);\n+}\n+\n+#[test]\n+fn test_log10() {\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(10.0f64.log10(), 1.0);\n+    assert_approx_eq!(2.3f64.log10(), 0.361728);\n+    assert_approx_eq!(1.0f64.exp().log10(), 0.434294);\n+    assert_eq!(1.0f64.log10(), 0.0);\n+    assert!(nan.log10().is_nan());\n+    assert_eq!(inf.log10(), inf);\n+    assert!(neg_inf.log10().is_nan());\n+    assert!((-2.3f64).log10().is_nan());\n+    assert_eq!((-0.0f64).log10(), neg_inf);\n+    assert_eq!(0.0f64.log10(), neg_inf);\n+}\n+\n+#[test]\n+fn test_to_degrees() {\n+    let pi: f64 = consts::PI;\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(0.0f64.to_degrees(), 0.0);\n+    assert_approx_eq!((-5.8f64).to_degrees(), -332.315521);\n+    assert_eq!(pi.to_degrees(), 180.0);\n+    assert!(nan.to_degrees().is_nan());\n+    assert_eq!(inf.to_degrees(), inf);\n+    assert_eq!(neg_inf.to_degrees(), neg_inf);\n+}\n+\n+#[test]\n+fn test_to_radians() {\n+    let pi: f64 = consts::PI;\n+    let nan: f64 = f64::NAN;\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    assert_eq!(0.0f64.to_radians(), 0.0);\n+    assert_approx_eq!(154.6f64.to_radians(), 2.698279);\n+    assert_approx_eq!((-332.31f64).to_radians(), -5.799903);\n+    assert_eq!(180.0f64.to_radians(), pi);\n+    assert!(nan.to_radians().is_nan());\n+    assert_eq!(inf.to_radians(), inf);\n+    assert_eq!(neg_inf.to_radians(), neg_inf);\n+}\n+\n+#[test]\n+fn test_asinh() {\n+    assert_eq!(0.0f64.asinh(), 0.0f64);\n+    assert_eq!((-0.0f64).asinh(), -0.0f64);\n+\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let nan: f64 = f64::NAN;\n+    assert_eq!(inf.asinh(), inf);\n+    assert_eq!(neg_inf.asinh(), neg_inf);\n+    assert!(nan.asinh().is_nan());\n+    assert!((-0.0f64).asinh().is_sign_negative());\n+    // issue 63271\n+    assert_approx_eq!(2.0f64.asinh(), 1.443635475178810342493276740273105f64);\n+    assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n+    // regression test for the catastrophic cancellation fixed in 72486\n+    assert_approx_eq!((-67452098.07139316f64).asinh(), -18.72007542627454439398548429400083);\n+}\n+\n+#[test]\n+fn test_acosh() {\n+    assert_eq!(1.0f64.acosh(), 0.0f64);\n+    assert!(0.999f64.acosh().is_nan());\n+\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let nan: f64 = f64::NAN;\n+    assert_eq!(inf.acosh(), inf);\n+    assert!(neg_inf.acosh().is_nan());\n+    assert!(nan.acosh().is_nan());\n+    assert_approx_eq!(2.0f64.acosh(), 1.31695789692481670862504634730796844f64);\n+    assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n+}\n+\n+#[test]\n+fn test_atanh() {\n+    assert_eq!(0.0f64.atanh(), 0.0f64);\n+    assert_eq!((-0.0f64).atanh(), -0.0f64);\n+\n+    let inf: f64 = f64::INFINITY;\n+    let neg_inf: f64 = f64::NEG_INFINITY;\n+    let nan: f64 = f64::NAN;\n+    assert_eq!(1.0f64.atanh(), inf);\n+    assert_eq!((-1.0f64).atanh(), neg_inf);\n+    assert!(2f64.atanh().atanh().is_nan());\n+    assert!((-2f64).atanh().atanh().is_nan());\n+    assert!(inf.atanh().is_nan());\n+    assert!(neg_inf.atanh().is_nan());\n+    assert!(nan.atanh().is_nan());\n+    assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n+    assert_approx_eq!((-0.5f64).atanh(), -0.54930614433405484569762261846126285f64);\n+}\n+\n+#[test]\n+fn test_real_consts() {\n+    use super::consts;\n+    let pi: f64 = consts::PI;\n+    let frac_pi_2: f64 = consts::FRAC_PI_2;\n+    let frac_pi_3: f64 = consts::FRAC_PI_3;\n+    let frac_pi_4: f64 = consts::FRAC_PI_4;\n+    let frac_pi_6: f64 = consts::FRAC_PI_6;\n+    let frac_pi_8: f64 = consts::FRAC_PI_8;\n+    let frac_1_pi: f64 = consts::FRAC_1_PI;\n+    let frac_2_pi: f64 = consts::FRAC_2_PI;\n+    let frac_2_sqrtpi: f64 = consts::FRAC_2_SQRT_PI;\n+    let sqrt2: f64 = consts::SQRT_2;\n+    let frac_1_sqrt2: f64 = consts::FRAC_1_SQRT_2;\n+    let e: f64 = consts::E;\n+    let log2_e: f64 = consts::LOG2_E;\n+    let log10_e: f64 = consts::LOG10_E;\n+    let ln_2: f64 = consts::LN_2;\n+    let ln_10: f64 = consts::LN_10;\n+\n+    assert_approx_eq!(frac_pi_2, pi / 2f64);\n+    assert_approx_eq!(frac_pi_3, pi / 3f64);\n+    assert_approx_eq!(frac_pi_4, pi / 4f64);\n+    assert_approx_eq!(frac_pi_6, pi / 6f64);\n+    assert_approx_eq!(frac_pi_8, pi / 8f64);\n+    assert_approx_eq!(frac_1_pi, 1f64 / pi);\n+    assert_approx_eq!(frac_2_pi, 2f64 / pi);\n+    assert_approx_eq!(frac_2_sqrtpi, 2f64 / pi.sqrt());\n+    assert_approx_eq!(sqrt2, 2f64.sqrt());\n+    assert_approx_eq!(frac_1_sqrt2, 1f64 / 2f64.sqrt());\n+    assert_approx_eq!(log2_e, e.log2());\n+    assert_approx_eq!(log10_e, e.log10());\n+    assert_approx_eq!(ln_2, 2f64.ln());\n+    assert_approx_eq!(ln_10, 10f64.ln());\n+}\n+\n+#[test]\n+fn test_float_bits_conv() {\n+    assert_eq!((1f64).to_bits(), 0x3ff0000000000000);\n+    assert_eq!((12.5f64).to_bits(), 0x4029000000000000);\n+    assert_eq!((1337f64).to_bits(), 0x4094e40000000000);\n+    assert_eq!((-14.25f64).to_bits(), 0xc02c800000000000);\n+    assert_approx_eq!(f64::from_bits(0x3ff0000000000000), 1.0);\n+    assert_approx_eq!(f64::from_bits(0x4029000000000000), 12.5);\n+    assert_approx_eq!(f64::from_bits(0x4094e40000000000), 1337.0);\n+    assert_approx_eq!(f64::from_bits(0xc02c800000000000), -14.25);\n+\n+    // Check that NaNs roundtrip their bits regardless of signaling-ness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    let masked_nan1 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+    let masked_nan2 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+    assert!(f64::from_bits(masked_nan1).is_nan());\n+    assert!(f64::from_bits(masked_nan2).is_nan());\n+\n+    assert_eq!(f64::from_bits(masked_nan1).to_bits(), masked_nan1);\n+    assert_eq!(f64::from_bits(masked_nan2).to_bits(), masked_nan2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_min_greater_than_max() {\n+    let _ = 1.0f64.clamp(3.0, 1.0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_min_is_nan() {\n+    let _ = 1.0f64.clamp(f64::NAN, 1.0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clamp_max_is_nan() {\n+    let _ = 1.0f64.clamp(3.0, f64::NAN);\n+}\n+\n+#[test]\n+fn test_total_cmp() {\n+    use core::cmp::Ordering;\n+\n+    fn quiet_bit_mask() -> u64 {\n+        1 << (f64::MANTISSA_DIGITS - 2)\n+    }\n+\n+    fn min_subnorm() -> f64 {\n+        f64::MIN_POSITIVE / f64::powf(2.0, f64::MANTISSA_DIGITS as f64 - 1.0)\n+    }\n+\n+    fn max_subnorm() -> f64 {\n+        f64::MIN_POSITIVE - min_subnorm()\n+    }\n+\n+    fn q_nan() -> f64 {\n+        f64::from_bits(f64::NAN.to_bits() | quiet_bit_mask())\n+    }\n+\n+    fn s_nan() -> f64 {\n+        f64::from_bits((f64::NAN.to_bits() & !quiet_bit_mask()) + 42)\n+    }\n+\n+    assert_eq!(Ordering::Equal, (-q_nan()).total_cmp(&-q_nan()));\n+    assert_eq!(Ordering::Equal, (-s_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Equal, (-f64::INFINITY).total_cmp(&-f64::INFINITY));\n+    assert_eq!(Ordering::Equal, (-f64::MAX).total_cmp(&-f64::MAX));\n+    assert_eq!(Ordering::Equal, (-2.5_f64).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Equal, (-1.0_f64).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Equal, (-1.5_f64).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Equal, (-0.5_f64).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Equal, (-f64::MIN_POSITIVE).total_cmp(&-f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Equal, (-max_subnorm()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Equal, (-min_subnorm()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Equal, (-0.0_f64).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Equal, 0.0_f64.total_cmp(&0.0));\n+    assert_eq!(Ordering::Equal, min_subnorm().total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Equal, max_subnorm().total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Equal, f64::MIN_POSITIVE.total_cmp(&f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Equal, 0.5_f64.total_cmp(&0.5));\n+    assert_eq!(Ordering::Equal, 1.0_f64.total_cmp(&1.0));\n+    assert_eq!(Ordering::Equal, 1.5_f64.total_cmp(&1.5));\n+    assert_eq!(Ordering::Equal, 2.5_f64.total_cmp(&2.5));\n+    assert_eq!(Ordering::Equal, f64::MAX.total_cmp(&f64::MAX));\n+    assert_eq!(Ordering::Equal, f64::INFINITY.total_cmp(&f64::INFINITY));\n+    assert_eq!(Ordering::Equal, s_nan().total_cmp(&s_nan()));\n+    assert_eq!(Ordering::Equal, q_nan().total_cmp(&q_nan()));\n+\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+    assert_eq!(Ordering::Less, (-f64::INFINITY).total_cmp(&-f64::MAX));\n+    assert_eq!(Ordering::Less, (-f64::MAX).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-2.5_f64).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-1.5_f64).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-1.0_f64).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-0.5_f64).total_cmp(&-f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-f64::MIN_POSITIVE).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-max_subnorm()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-min_subnorm()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-0.0_f64).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, 0.0_f64.total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, min_subnorm().total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, max_subnorm().total_cmp(&f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, f64::MIN_POSITIVE.total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, 0.5_f64.total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, 1.0_f64.total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, 1.5_f64.total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, 2.5_f64.total_cmp(&f64::MAX));\n+    assert_eq!(Ordering::Less, f64::MAX.total_cmp(&f64::INFINITY));\n+    assert_eq!(Ordering::Less, f64::INFINITY.total_cmp(&s_nan()));\n+    assert_eq!(Ordering::Less, s_nan().total_cmp(&q_nan()));\n+\n+    assert_eq!(Ordering::Greater, (-s_nan()).total_cmp(&-q_nan()));\n+    assert_eq!(Ordering::Greater, (-f64::INFINITY).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Greater, (-f64::MAX).total_cmp(&-f64::INFINITY));\n+    assert_eq!(Ordering::Greater, (-2.5_f64).total_cmp(&-f64::MAX));\n+    assert_eq!(Ordering::Greater, (-1.5_f64).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Greater, (-1.0_f64).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Greater, (-0.5_f64).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Greater, (-f64::MIN_POSITIVE).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Greater, (-max_subnorm()).total_cmp(&-f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Greater, (-min_subnorm()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Greater, (-0.0_f64).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Greater, 0.0_f64.total_cmp(&-0.0));\n+    assert_eq!(Ordering::Greater, min_subnorm().total_cmp(&0.0));\n+    assert_eq!(Ordering::Greater, max_subnorm().total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Greater, f64::MIN_POSITIVE.total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Greater, 0.5_f64.total_cmp(&f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Greater, 1.0_f64.total_cmp(&0.5));\n+    assert_eq!(Ordering::Greater, 1.5_f64.total_cmp(&1.0));\n+    assert_eq!(Ordering::Greater, 2.5_f64.total_cmp(&1.5));\n+    assert_eq!(Ordering::Greater, f64::MAX.total_cmp(&2.5));\n+    assert_eq!(Ordering::Greater, f64::INFINITY.total_cmp(&f64::MAX));\n+    assert_eq!(Ordering::Greater, s_nan().total_cmp(&f64::INFINITY));\n+    assert_eq!(Ordering::Greater, q_nan().total_cmp(&s_nan()));\n+\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-s_nan()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::INFINITY));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MAX));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::MAX));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&f64::INFINITY));\n+    assert_eq!(Ordering::Less, (-q_nan()).total_cmp(&s_nan()));\n+\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::INFINITY));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MAX));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-2.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-1.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-max_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-min_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&-0.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&min_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&max_subnorm()));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MIN_POSITIVE));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&0.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.0));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&1.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&2.5));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::MAX));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n+    assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n+}"}, {"sha": "51deb217c7c29a3b8e06fccb1d40e473082927fd", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 199, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,4 +1,8 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n+\n+#[cfg(test)]\n+mod tests;\n+\n use crate::ascii;\n use crate::borrow::{Borrow, Cow};\n use crate::cmp::Ordering;\n@@ -1522,202 +1526,3 @@ impl AsRef<CStr> for CString {\n         self\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::borrow::Cow::{Borrowed, Owned};\n-    use crate::collections::hash_map::DefaultHasher;\n-    use crate::hash::{Hash, Hasher};\n-    use crate::os::raw::c_char;\n-    use crate::rc::Rc;\n-    use crate::sync::Arc;\n-\n-    #[test]\n-    fn c_to_rust() {\n-        let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const c_char;\n-        unsafe {\n-            assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n-            assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n-        }\n-    }\n-\n-    #[test]\n-    fn simple() {\n-        let s = CString::new(\"1234\").unwrap();\n-        assert_eq!(s.as_bytes(), b\"1234\");\n-        assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n-    }\n-\n-    #[test]\n-    fn build_with_zero1() {\n-        assert!(CString::new(&b\"\\0\"[..]).is_err());\n-    }\n-    #[test]\n-    fn build_with_zero2() {\n-        assert!(CString::new(vec![0]).is_err());\n-    }\n-\n-    #[test]\n-    fn build_with_zero3() {\n-        unsafe {\n-            let s = CString::from_vec_unchecked(vec![0]);\n-            assert_eq!(s.as_bytes(), b\"\\0\");\n-        }\n-    }\n-\n-    #[test]\n-    fn formatted() {\n-        let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();\n-        assert_eq!(format!(\"{:?}\", s), r#\"\"abc\\x01\\x02\\n\\xe2\\x80\\xa6\\xff\"\"#);\n-    }\n-\n-    #[test]\n-    fn borrowed() {\n-        unsafe {\n-            let s = CStr::from_ptr(b\"12\\0\".as_ptr() as *const _);\n-            assert_eq!(s.to_bytes(), b\"12\");\n-            assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n-        }\n-    }\n-\n-    #[test]\n-    fn to_str() {\n-        let data = b\"123\\xE2\\x80\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const c_char;\n-        unsafe {\n-            assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n-            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n-        }\n-        let data = b\"123\\xE2\\0\";\n-        let ptr = data.as_ptr() as *const c_char;\n-        unsafe {\n-            assert!(CStr::from_ptr(ptr).to_str().is_err());\n-            assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n-        }\n-    }\n-\n-    #[test]\n-    fn to_owned() {\n-        let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const c_char;\n-\n-        let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n-        assert_eq!(owned.as_bytes_with_nul(), data);\n-    }\n-\n-    #[test]\n-    fn equal_hash() {\n-        let data = b\"123\\xE2\\xFA\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const c_char;\n-        let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n-\n-        let mut s = DefaultHasher::new();\n-        cstr.hash(&mut s);\n-        let cstr_hash = s.finish();\n-        let mut s = DefaultHasher::new();\n-        CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n-        let cstring_hash = s.finish();\n-\n-        assert_eq!(cstr_hash, cstring_hash);\n-    }\n-\n-    #[test]\n-    fn from_bytes_with_nul() {\n-        let data = b\"123\\0\";\n-        let cstr = CStr::from_bytes_with_nul(data);\n-        assert_eq!(cstr.map(CStr::to_bytes), Ok(&b\"123\"[..]));\n-        let cstr = CStr::from_bytes_with_nul(data);\n-        assert_eq!(cstr.map(CStr::to_bytes_with_nul), Ok(&b\"123\\0\"[..]));\n-\n-        unsafe {\n-            let cstr = CStr::from_bytes_with_nul(data);\n-            let cstr_unchecked = CStr::from_bytes_with_nul_unchecked(data);\n-            assert_eq!(cstr, Ok(cstr_unchecked));\n-        }\n-    }\n-\n-    #[test]\n-    fn from_bytes_with_nul_unterminated() {\n-        let data = b\"123\";\n-        let cstr = CStr::from_bytes_with_nul(data);\n-        assert!(cstr.is_err());\n-    }\n-\n-    #[test]\n-    fn from_bytes_with_nul_interior() {\n-        let data = b\"1\\023\\0\";\n-        let cstr = CStr::from_bytes_with_nul(data);\n-        assert!(cstr.is_err());\n-    }\n-\n-    #[test]\n-    fn into_boxed() {\n-        let orig: &[u8] = b\"Hello, world!\\0\";\n-        let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n-        let boxed: Box<CStr> = Box::from(cstr);\n-        let cstring = cstr.to_owned().into_boxed_c_str().into_c_string();\n-        assert_eq!(cstr, &*boxed);\n-        assert_eq!(&*boxed, &*cstring);\n-        assert_eq!(&*cstring, cstr);\n-    }\n-\n-    #[test]\n-    fn boxed_default() {\n-        let boxed = <Box<CStr>>::default();\n-        assert_eq!(boxed.to_bytes_with_nul(), &[0]);\n-    }\n-\n-    #[test]\n-    fn test_c_str_clone_into() {\n-        let mut c_string = CString::new(\"lorem\").unwrap();\n-        let c_ptr = c_string.as_ptr();\n-        let c_str = CStr::from_bytes_with_nul(b\"ipsum\\0\").unwrap();\n-        c_str.clone_into(&mut c_string);\n-        assert_eq!(c_str, c_string.as_c_str());\n-        // The exact same size shouldn't have needed to move its allocation\n-        assert_eq!(c_ptr, c_string.as_ptr());\n-    }\n-\n-    #[test]\n-    fn into_rc() {\n-        let orig: &[u8] = b\"Hello, world!\\0\";\n-        let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n-        let rc: Rc<CStr> = Rc::from(cstr);\n-        let arc: Arc<CStr> = Arc::from(cstr);\n-\n-        assert_eq!(&*rc, cstr);\n-        assert_eq!(&*arc, cstr);\n-\n-        let rc2: Rc<CStr> = Rc::from(cstr.to_owned());\n-        let arc2: Arc<CStr> = Arc::from(cstr.to_owned());\n-\n-        assert_eq!(&*rc2, cstr);\n-        assert_eq!(&*arc2, cstr);\n-    }\n-\n-    #[test]\n-    fn cstr_const_constructor() {\n-        const CSTR: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"Hello, world!\\0\") };\n-\n-        assert_eq!(CSTR.to_str().unwrap(), \"Hello, world!\");\n-    }\n-\n-    #[test]\n-    fn cstr_index_from() {\n-        let original = b\"Hello, world!\\0\";\n-        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n-        let result = CStr::from_bytes_with_nul(&original[7..]).unwrap();\n-\n-        assert_eq!(&cstr[7..], result);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn cstr_index_from_empty() {\n-        let original = b\"Hello, world!\\0\";\n-        let cstr = CStr::from_bytes_with_nul(original).unwrap();\n-        let _ = &cstr[original.len()..];\n-    }\n-}"}, {"sha": "4dff3df63a8b6d79f1bb6886ee6204c1691b053c", "filename": "library/std/src/ffi/c_str/tests.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,195 @@\n+use super::*;\n+use crate::borrow::Cow::{Borrowed, Owned};\n+use crate::collections::hash_map::DefaultHasher;\n+use crate::hash::{Hash, Hasher};\n+use crate::os::raw::c_char;\n+use crate::rc::Rc;\n+use crate::sync::Arc;\n+\n+#[test]\n+fn c_to_rust() {\n+    let data = b\"123\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    unsafe {\n+        assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n+        assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n+    }\n+}\n+\n+#[test]\n+fn simple() {\n+    let s = CString::new(\"1234\").unwrap();\n+    assert_eq!(s.as_bytes(), b\"1234\");\n+    assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n+}\n+\n+#[test]\n+fn build_with_zero1() {\n+    assert!(CString::new(&b\"\\0\"[..]).is_err());\n+}\n+#[test]\n+fn build_with_zero2() {\n+    assert!(CString::new(vec![0]).is_err());\n+}\n+\n+#[test]\n+fn build_with_zero3() {\n+    unsafe {\n+        let s = CString::from_vec_unchecked(vec![0]);\n+        assert_eq!(s.as_bytes(), b\"\\0\");\n+    }\n+}\n+\n+#[test]\n+fn formatted() {\n+    let s = CString::new(&b\"abc\\x01\\x02\\n\\xE2\\x80\\xA6\\xFF\"[..]).unwrap();\n+    assert_eq!(format!(\"{:?}\", s), r#\"\"abc\\x01\\x02\\n\\xe2\\x80\\xa6\\xff\"\"#);\n+}\n+\n+#[test]\n+fn borrowed() {\n+    unsafe {\n+        let s = CStr::from_ptr(b\"12\\0\".as_ptr() as *const _);\n+        assert_eq!(s.to_bytes(), b\"12\");\n+        assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n+    }\n+}\n+\n+#[test]\n+fn to_str() {\n+    let data = b\"123\\xE2\\x80\\xA6\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    unsafe {\n+        assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n+        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n+    }\n+    let data = b\"123\\xE2\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    unsafe {\n+        assert!(CStr::from_ptr(ptr).to_str().is_err());\n+        assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n+    }\n+}\n+\n+#[test]\n+fn to_owned() {\n+    let data = b\"123\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+\n+    let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n+    assert_eq!(owned.as_bytes_with_nul(), data);\n+}\n+\n+#[test]\n+fn equal_hash() {\n+    let data = b\"123\\xE2\\xFA\\xA6\\0\";\n+    let ptr = data.as_ptr() as *const c_char;\n+    let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n+\n+    let mut s = DefaultHasher::new();\n+    cstr.hash(&mut s);\n+    let cstr_hash = s.finish();\n+    let mut s = DefaultHasher::new();\n+    CString::new(&data[..data.len() - 1]).unwrap().hash(&mut s);\n+    let cstring_hash = s.finish();\n+\n+    assert_eq!(cstr_hash, cstring_hash);\n+}\n+\n+#[test]\n+fn from_bytes_with_nul() {\n+    let data = b\"123\\0\";\n+    let cstr = CStr::from_bytes_with_nul(data);\n+    assert_eq!(cstr.map(CStr::to_bytes), Ok(&b\"123\"[..]));\n+    let cstr = CStr::from_bytes_with_nul(data);\n+    assert_eq!(cstr.map(CStr::to_bytes_with_nul), Ok(&b\"123\\0\"[..]));\n+\n+    unsafe {\n+        let cstr = CStr::from_bytes_with_nul(data);\n+        let cstr_unchecked = CStr::from_bytes_with_nul_unchecked(data);\n+        assert_eq!(cstr, Ok(cstr_unchecked));\n+    }\n+}\n+\n+#[test]\n+fn from_bytes_with_nul_unterminated() {\n+    let data = b\"123\";\n+    let cstr = CStr::from_bytes_with_nul(data);\n+    assert!(cstr.is_err());\n+}\n+\n+#[test]\n+fn from_bytes_with_nul_interior() {\n+    let data = b\"1\\023\\0\";\n+    let cstr = CStr::from_bytes_with_nul(data);\n+    assert!(cstr.is_err());\n+}\n+\n+#[test]\n+fn into_boxed() {\n+    let orig: &[u8] = b\"Hello, world!\\0\";\n+    let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n+    let boxed: Box<CStr> = Box::from(cstr);\n+    let cstring = cstr.to_owned().into_boxed_c_str().into_c_string();\n+    assert_eq!(cstr, &*boxed);\n+    assert_eq!(&*boxed, &*cstring);\n+    assert_eq!(&*cstring, cstr);\n+}\n+\n+#[test]\n+fn boxed_default() {\n+    let boxed = <Box<CStr>>::default();\n+    assert_eq!(boxed.to_bytes_with_nul(), &[0]);\n+}\n+\n+#[test]\n+fn test_c_str_clone_into() {\n+    let mut c_string = CString::new(\"lorem\").unwrap();\n+    let c_ptr = c_string.as_ptr();\n+    let c_str = CStr::from_bytes_with_nul(b\"ipsum\\0\").unwrap();\n+    c_str.clone_into(&mut c_string);\n+    assert_eq!(c_str, c_string.as_c_str());\n+    // The exact same size shouldn't have needed to move its allocation\n+    assert_eq!(c_ptr, c_string.as_ptr());\n+}\n+\n+#[test]\n+fn into_rc() {\n+    let orig: &[u8] = b\"Hello, world!\\0\";\n+    let cstr = CStr::from_bytes_with_nul(orig).unwrap();\n+    let rc: Rc<CStr> = Rc::from(cstr);\n+    let arc: Arc<CStr> = Arc::from(cstr);\n+\n+    assert_eq!(&*rc, cstr);\n+    assert_eq!(&*arc, cstr);\n+\n+    let rc2: Rc<CStr> = Rc::from(cstr.to_owned());\n+    let arc2: Arc<CStr> = Arc::from(cstr.to_owned());\n+\n+    assert_eq!(&*rc2, cstr);\n+    assert_eq!(&*arc2, cstr);\n+}\n+\n+#[test]\n+fn cstr_const_constructor() {\n+    const CSTR: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b\"Hello, world!\\0\") };\n+\n+    assert_eq!(CSTR.to_str().unwrap(), \"Hello, world!\");\n+}\n+\n+#[test]\n+fn cstr_index_from() {\n+    let original = b\"Hello, world!\\0\";\n+    let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+    let result = CStr::from_bytes_with_nul(&original[7..]).unwrap();\n+\n+    assert_eq!(&cstr[7..], result);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn cstr_index_from_empty() {\n+    let original = b\"Hello, world!\\0\";\n+    let cstr = CStr::from_bytes_with_nul(original).unwrap();\n+    let _ = &cstr[original.len()..];\n+}"}, {"sha": "e0be6d1c836aea9456a45197303778cfdce4c582", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 3, "deletions": 169, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use crate::borrow::{Borrow, Cow};\n use crate::cmp;\n use crate::fmt;\n@@ -1145,172 +1148,3 @@ impl FromStr for OsString {\n         Ok(OsString::from(s))\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::sys_common::{AsInner, IntoInner};\n-\n-    use crate::rc::Rc;\n-    use crate::sync::Arc;\n-\n-    #[test]\n-    fn test_os_string_with_capacity() {\n-        let os_string = OsString::with_capacity(0);\n-        assert_eq!(0, os_string.inner.into_inner().capacity());\n-\n-        let os_string = OsString::with_capacity(10);\n-        assert_eq!(10, os_string.inner.into_inner().capacity());\n-\n-        let mut os_string = OsString::with_capacity(0);\n-        os_string.push(\"abc\");\n-        assert!(os_string.inner.into_inner().capacity() >= 3);\n-    }\n-\n-    #[test]\n-    fn test_os_string_clear() {\n-        let mut os_string = OsString::from(\"abc\");\n-        assert_eq!(3, os_string.inner.as_inner().len());\n-\n-        os_string.clear();\n-        assert_eq!(&os_string, \"\");\n-        assert_eq!(0, os_string.inner.as_inner().len());\n-    }\n-\n-    #[test]\n-    fn test_os_string_capacity() {\n-        let os_string = OsString::with_capacity(0);\n-        assert_eq!(0, os_string.capacity());\n-\n-        let os_string = OsString::with_capacity(10);\n-        assert_eq!(10, os_string.capacity());\n-\n-        let mut os_string = OsString::with_capacity(0);\n-        os_string.push(\"abc\");\n-        assert!(os_string.capacity() >= 3);\n-    }\n-\n-    #[test]\n-    fn test_os_string_reserve() {\n-        let mut os_string = OsString::new();\n-        assert_eq!(os_string.capacity(), 0);\n-\n-        os_string.reserve(2);\n-        assert!(os_string.capacity() >= 2);\n-\n-        for _ in 0..16 {\n-            os_string.push(\"a\");\n-        }\n-\n-        assert!(os_string.capacity() >= 16);\n-        os_string.reserve(16);\n-        assert!(os_string.capacity() >= 32);\n-\n-        os_string.push(\"a\");\n-\n-        os_string.reserve(16);\n-        assert!(os_string.capacity() >= 33)\n-    }\n-\n-    #[test]\n-    fn test_os_string_reserve_exact() {\n-        let mut os_string = OsString::new();\n-        assert_eq!(os_string.capacity(), 0);\n-\n-        os_string.reserve_exact(2);\n-        assert!(os_string.capacity() >= 2);\n-\n-        for _ in 0..16 {\n-            os_string.push(\"a\");\n-        }\n-\n-        assert!(os_string.capacity() >= 16);\n-        os_string.reserve_exact(16);\n-        assert!(os_string.capacity() >= 32);\n-\n-        os_string.push(\"a\");\n-\n-        os_string.reserve_exact(16);\n-        assert!(os_string.capacity() >= 33)\n-    }\n-\n-    #[test]\n-    fn test_os_string_default() {\n-        let os_string: OsString = Default::default();\n-        assert_eq!(\"\", &os_string);\n-    }\n-\n-    #[test]\n-    fn test_os_str_is_empty() {\n-        let mut os_string = OsString::new();\n-        assert!(os_string.is_empty());\n-\n-        os_string.push(\"abc\");\n-        assert!(!os_string.is_empty());\n-\n-        os_string.clear();\n-        assert!(os_string.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_os_str_len() {\n-        let mut os_string = OsString::new();\n-        assert_eq!(0, os_string.len());\n-\n-        os_string.push(\"abc\");\n-        assert_eq!(3, os_string.len());\n-\n-        os_string.clear();\n-        assert_eq!(0, os_string.len());\n-    }\n-\n-    #[test]\n-    fn test_os_str_default() {\n-        let os_str: &OsStr = Default::default();\n-        assert_eq!(\"\", os_str);\n-    }\n-\n-    #[test]\n-    fn into_boxed() {\n-        let orig = \"Hello, world!\";\n-        let os_str = OsStr::new(orig);\n-        let boxed: Box<OsStr> = Box::from(os_str);\n-        let os_string = os_str.to_owned().into_boxed_os_str().into_os_string();\n-        assert_eq!(os_str, &*boxed);\n-        assert_eq!(&*boxed, &*os_string);\n-        assert_eq!(&*os_string, os_str);\n-    }\n-\n-    #[test]\n-    fn boxed_default() {\n-        let boxed = <Box<OsStr>>::default();\n-        assert!(boxed.is_empty());\n-    }\n-\n-    #[test]\n-    fn test_os_str_clone_into() {\n-        let mut os_string = OsString::with_capacity(123);\n-        os_string.push(\"hello\");\n-        let os_str = OsStr::new(\"bonjour\");\n-        os_str.clone_into(&mut os_string);\n-        assert_eq!(os_str, os_string);\n-        assert!(os_string.capacity() >= 123);\n-    }\n-\n-    #[test]\n-    fn into_rc() {\n-        let orig = \"Hello, world!\";\n-        let os_str = OsStr::new(orig);\n-        let rc: Rc<OsStr> = Rc::from(os_str);\n-        let arc: Arc<OsStr> = Arc::from(os_str);\n-\n-        assert_eq!(&*rc, os_str);\n-        assert_eq!(&*arc, os_str);\n-\n-        let rc2: Rc<OsStr> = Rc::from(os_str.to_owned());\n-        let arc2: Arc<OsStr> = Arc::from(os_str.to_owned());\n-\n-        assert_eq!(&*rc2, os_str);\n-        assert_eq!(&*arc2, os_str);\n-    }\n-}"}, {"sha": "283f2b577e89607bdd9940cc8b4c4d4300b35888", "filename": "library/std/src/ffi/os_str/tests.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,165 @@\n+use super::*;\n+use crate::sys_common::{AsInner, IntoInner};\n+\n+use crate::rc::Rc;\n+use crate::sync::Arc;\n+\n+#[test]\n+fn test_os_string_with_capacity() {\n+    let os_string = OsString::with_capacity(0);\n+    assert_eq!(0, os_string.inner.into_inner().capacity());\n+\n+    let os_string = OsString::with_capacity(10);\n+    assert_eq!(10, os_string.inner.into_inner().capacity());\n+\n+    let mut os_string = OsString::with_capacity(0);\n+    os_string.push(\"abc\");\n+    assert!(os_string.inner.into_inner().capacity() >= 3);\n+}\n+\n+#[test]\n+fn test_os_string_clear() {\n+    let mut os_string = OsString::from(\"abc\");\n+    assert_eq!(3, os_string.inner.as_inner().len());\n+\n+    os_string.clear();\n+    assert_eq!(&os_string, \"\");\n+    assert_eq!(0, os_string.inner.as_inner().len());\n+}\n+\n+#[test]\n+fn test_os_string_capacity() {\n+    let os_string = OsString::with_capacity(0);\n+    assert_eq!(0, os_string.capacity());\n+\n+    let os_string = OsString::with_capacity(10);\n+    assert_eq!(10, os_string.capacity());\n+\n+    let mut os_string = OsString::with_capacity(0);\n+    os_string.push(\"abc\");\n+    assert!(os_string.capacity() >= 3);\n+}\n+\n+#[test]\n+fn test_os_string_reserve() {\n+    let mut os_string = OsString::new();\n+    assert_eq!(os_string.capacity(), 0);\n+\n+    os_string.reserve(2);\n+    assert!(os_string.capacity() >= 2);\n+\n+    for _ in 0..16 {\n+        os_string.push(\"a\");\n+    }\n+\n+    assert!(os_string.capacity() >= 16);\n+    os_string.reserve(16);\n+    assert!(os_string.capacity() >= 32);\n+\n+    os_string.push(\"a\");\n+\n+    os_string.reserve(16);\n+    assert!(os_string.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_os_string_reserve_exact() {\n+    let mut os_string = OsString::new();\n+    assert_eq!(os_string.capacity(), 0);\n+\n+    os_string.reserve_exact(2);\n+    assert!(os_string.capacity() >= 2);\n+\n+    for _ in 0..16 {\n+        os_string.push(\"a\");\n+    }\n+\n+    assert!(os_string.capacity() >= 16);\n+    os_string.reserve_exact(16);\n+    assert!(os_string.capacity() >= 32);\n+\n+    os_string.push(\"a\");\n+\n+    os_string.reserve_exact(16);\n+    assert!(os_string.capacity() >= 33)\n+}\n+\n+#[test]\n+fn test_os_string_default() {\n+    let os_string: OsString = Default::default();\n+    assert_eq!(\"\", &os_string);\n+}\n+\n+#[test]\n+fn test_os_str_is_empty() {\n+    let mut os_string = OsString::new();\n+    assert!(os_string.is_empty());\n+\n+    os_string.push(\"abc\");\n+    assert!(!os_string.is_empty());\n+\n+    os_string.clear();\n+    assert!(os_string.is_empty());\n+}\n+\n+#[test]\n+fn test_os_str_len() {\n+    let mut os_string = OsString::new();\n+    assert_eq!(0, os_string.len());\n+\n+    os_string.push(\"abc\");\n+    assert_eq!(3, os_string.len());\n+\n+    os_string.clear();\n+    assert_eq!(0, os_string.len());\n+}\n+\n+#[test]\n+fn test_os_str_default() {\n+    let os_str: &OsStr = Default::default();\n+    assert_eq!(\"\", os_str);\n+}\n+\n+#[test]\n+fn into_boxed() {\n+    let orig = \"Hello, world!\";\n+    let os_str = OsStr::new(orig);\n+    let boxed: Box<OsStr> = Box::from(os_str);\n+    let os_string = os_str.to_owned().into_boxed_os_str().into_os_string();\n+    assert_eq!(os_str, &*boxed);\n+    assert_eq!(&*boxed, &*os_string);\n+    assert_eq!(&*os_string, os_str);\n+}\n+\n+#[test]\n+fn boxed_default() {\n+    let boxed = <Box<OsStr>>::default();\n+    assert!(boxed.is_empty());\n+}\n+\n+#[test]\n+fn test_os_str_clone_into() {\n+    let mut os_string = OsString::with_capacity(123);\n+    os_string.push(\"hello\");\n+    let os_str = OsStr::new(\"bonjour\");\n+    os_str.clone_into(&mut os_string);\n+    assert_eq!(os_str, os_string);\n+    assert!(os_string.capacity() >= 123);\n+}\n+\n+#[test]\n+fn into_rc() {\n+    let orig = \"Hello, world!\";\n+    let os_str = OsStr::new(orig);\n+    let rc: Rc<OsStr> = Rc::from(os_str);\n+    let arc: Arc<OsStr> = Arc::from(os_str);\n+\n+    assert_eq!(&*rc, os_str);\n+    assert_eq!(&*arc, os_str);\n+\n+    let rc2: Rc<OsStr> = Rc::from(os_str.to_owned());\n+    let arc2: Arc<OsStr> = Arc::from(os_str.to_owned());\n+\n+    assert_eq!(&*rc2, os_str);\n+    assert_eq!(&*arc2, os_str);\n+}"}, {"sha": "3cfb6bc9d3d0ba2f4ec2bdd3ef2ec5454c937c40", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 3, "deletions": 1348, "changes": 1351, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Filesystem manipulation operations.\n //!\n //! This module contains basic methods to manipulate the contents of the local\n@@ -10,6 +8,9 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n+mod tests;\n+\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n@@ -2194,1349 +2195,3 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n         &mut self.inner\n     }\n }\n-\n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n-mod tests {\n-    use crate::io::prelude::*;\n-\n-    use crate::fs::{self, File, OpenOptions};\n-    use crate::io::{ErrorKind, SeekFrom};\n-    use crate::path::Path;\n-    use crate::str;\n-    use crate::sys_common::io::test::{tmpdir, TempDir};\n-    use crate::thread;\n-\n-    use rand::{rngs::StdRng, RngCore, SeedableRng};\n-\n-    #[cfg(unix)]\n-    use crate::os::unix::fs::symlink as symlink_dir;\n-    #[cfg(unix)]\n-    use crate::os::unix::fs::symlink as symlink_file;\n-    #[cfg(unix)]\n-    use crate::os::unix::fs::symlink as symlink_junction;\n-    #[cfg(windows)]\n-    use crate::os::windows::fs::{symlink_dir, symlink_file};\n-    #[cfg(windows)]\n-    use crate::sys::fs::symlink_junction;\n-\n-    macro_rules! check {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n-            }\n-        };\n-    }\n-\n-    #[cfg(windows)]\n-    macro_rules! error {\n-        ($e:expr, $s:expr) => {\n-            match $e {\n-                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-                Err(ref err) => assert!(\n-                    err.raw_os_error() == Some($s),\n-                    format!(\"`{}` did not have a code of `{}`\", err, $s)\n-                ),\n-            }\n-        };\n-    }\n-\n-    #[cfg(unix)]\n-    macro_rules! error {\n-        ($e:expr, $s:expr) => {\n-            error_contains!($e, $s)\n-        };\n-    }\n-\n-    macro_rules! error_contains {\n-        ($e:expr, $s:expr) => {\n-            match $e {\n-                Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-                Err(ref err) => assert!(\n-                    err.to_string().contains($s),\n-                    format!(\"`{}` did not contain `{}`\", err, $s)\n-                ),\n-            }\n-        };\n-    }\n-\n-    // Several test fail on windows if the user does not have permission to\n-    // create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n-    // disabling these test on Windows, use this function to test whether we\n-    // have permission, and return otherwise. This way, we still don't run these\n-    // tests most of the time, but at least we do if the user has the right\n-    // permissions.\n-    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n-        if cfg!(unix) {\n-            return true;\n-        }\n-        let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n-\n-        match symlink_file(r\"nonexisting_target\", link) {\n-            Ok(_) => true,\n-            // ERROR_PRIVILEGE_NOT_HELD = 1314\n-            Err(ref err) if err.raw_os_error() == Some(1314) => false,\n-            Err(_) => true,\n-        }\n-    }\n-\n-    #[test]\n-    fn file_test_io_smoke_test() {\n-        let message = \"it's alright. have a good time\";\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n-        {\n-            let mut write_stream = check!(File::create(filename));\n-            check!(write_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = check!(File::open(filename));\n-            let mut read_buf = [0; 1028];\n-            let read_str = match check!(read_stream.read(&mut read_buf)) {\n-                0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[..n]).unwrap().to_string(),\n-            };\n-            assert_eq!(read_str, message);\n-        }\n-        check!(fs::remove_file(filename));\n-    }\n-\n-    #[test]\n-    fn invalid_path_raises() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let result = File::open(filename);\n-\n-        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n-        error!(result, \"No such file or directory\");\n-        #[cfg(target_os = \"vxworks\")]\n-        error!(result, \"no such file or directory\");\n-        #[cfg(windows)]\n-        error!(result, 2); // ERROR_FILE_NOT_FOUND\n-    }\n-\n-    #[test]\n-    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-\n-        let result = fs::remove_file(filename);\n-\n-        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n-        error!(result, \"No such file or directory\");\n-        #[cfg(target_os = \"vxworks\")]\n-        error!(result, \"no such file or directory\");\n-        #[cfg(windows)]\n-        error!(result, 2); // ERROR_FILE_NOT_FOUND\n-    }\n-\n-    #[test]\n-    fn file_test_io_non_positional_read() {\n-        let message: &str = \"ten-four\";\n-        let mut read_mem = [0; 8];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n-        {\n-            let mut rw_stream = check!(File::create(filename));\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = check!(File::open(filename));\n-            {\n-                let read_buf = &mut read_mem[0..4];\n-                check!(read_stream.read(read_buf));\n-            }\n-            {\n-                let read_buf = &mut read_mem[4..8];\n-                check!(read_stream.read(read_buf));\n-            }\n-        }\n-        check!(fs::remove_file(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, message);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_tell_smoke_test() {\n-        let message = \"ten-four\";\n-        let mut read_mem = [0; 4];\n-        let set_cursor = 4 as u64;\n-        let tell_pos_pre_read;\n-        let tell_pos_post_read;\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n-        {\n-            let mut rw_stream = check!(File::create(filename));\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = check!(File::open(filename));\n-            check!(read_stream.seek(SeekFrom::Start(set_cursor)));\n-            tell_pos_pre_read = check!(read_stream.seek(SeekFrom::Current(0)));\n-            check!(read_stream.read(&mut read_mem));\n-            tell_pos_post_read = check!(read_stream.seek(SeekFrom::Current(0)));\n-        }\n-        check!(fs::remove_file(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, &message[4..8]);\n-        assert_eq!(tell_pos_pre_read, set_cursor);\n-        assert_eq!(tell_pos_post_read, message.len() as u64);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_write() {\n-        let initial_msg = \"food-is-yummy\";\n-        let overwrite_msg = \"-the-bar!!\";\n-        let final_msg = \"foo-the-bar!!\";\n-        let seek_idx = 3;\n-        let mut read_mem = [0; 13];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n-        {\n-            let mut rw_stream = check!(File::create(filename));\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-            check!(rw_stream.seek(SeekFrom::Start(seek_idx)));\n-            check!(rw_stream.write(overwrite_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = check!(File::open(filename));\n-            check!(read_stream.read(&mut read_mem));\n-        }\n-        check!(fs::remove_file(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert!(read_str == final_msg);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_shakedown() {\n-        //                   01234567890123\n-        let initial_msg = \"qwer-asdf-zxcv\";\n-        let chunk_one: &str = \"qwer\";\n-        let chunk_two: &str = \"asdf\";\n-        let chunk_three: &str = \"zxcv\";\n-        let mut read_mem = [0; 4];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n-        {\n-            let mut rw_stream = check!(File::create(filename));\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = check!(File::open(filename));\n-\n-            check!(read_stream.seek(SeekFrom::End(-4)));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n-\n-            check!(read_stream.seek(SeekFrom::Current(-9)));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n-\n-            check!(read_stream.seek(SeekFrom::Start(0)));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n-        }\n-        check!(fs::remove_file(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_io_eof() {\n-        let tmpdir = tmpdir();\n-        let filename = tmpdir.join(\"file_rt_io_file_test_eof.txt\");\n-        let mut buf = [0; 256];\n-        {\n-            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n-            let mut rw = check!(oo.open(&filename));\n-            assert_eq!(check!(rw.read(&mut buf)), 0);\n-            assert_eq!(check!(rw.read(&mut buf)), 0);\n-        }\n-        check!(fs::remove_file(&filename));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn file_test_io_read_write_at() {\n-        use crate::os::unix::fs::FileExt;\n-\n-        let tmpdir = tmpdir();\n-        let filename = tmpdir.join(\"file_rt_io_file_test_read_write_at.txt\");\n-        let mut buf = [0; 256];\n-        let write1 = \"asdf\";\n-        let write2 = \"qwer-\";\n-        let write3 = \"-zxcv\";\n-        let content = \"qwer-asdf-zxcv\";\n-        {\n-            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n-            let mut rw = check!(oo.open(&filename));\n-            assert_eq!(check!(rw.write_at(write1.as_bytes(), 5)), write1.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n-            assert_eq!(check!(rw.read_at(&mut buf, 5)), write1.len());\n-            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n-            assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n-            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(\"\\0\\0\\0\\0\\0\"));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n-            assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n-            assert_eq!(check!(rw.read(&mut buf)), write1.len());\n-            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n-            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(rw.write_at(write3.as_bytes(), 9)), write3.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-        }\n-        {\n-            let mut read = check!(File::open(&filename));\n-            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 0);\n-            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n-            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(read.read(&mut buf)), write3.len());\n-            assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.read_at(&mut buf, 14)), 0);\n-            assert_eq!(check!(read.read_at(&mut buf, 15)), 0);\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-        }\n-        check!(fs::remove_file(&filename));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn set_get_unix_permissions() {\n-        use crate::os::unix::fs::PermissionsExt;\n-\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"set_get_unix_permissions\");\n-        check!(fs::create_dir(filename));\n-        let mask = 0o7777;\n-\n-        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0)));\n-        let metadata0 = check!(fs::metadata(filename));\n-        assert_eq!(mask & metadata0.permissions().mode(), 0);\n-\n-        check!(fs::set_permissions(filename, fs::Permissions::from_mode(0o1777)));\n-        let metadata1 = check!(fs::metadata(filename));\n-        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n-        assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n-        #[cfg(target_os = \"vxworks\")]\n-        assert_eq!(mask & metadata1.permissions().mode(), 0o0777);\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn file_test_io_seek_read_write() {\n-        use crate::os::windows::fs::FileExt;\n-\n-        let tmpdir = tmpdir();\n-        let filename = tmpdir.join(\"file_rt_io_file_test_seek_read_write.txt\");\n-        let mut buf = [0; 256];\n-        let write1 = \"asdf\";\n-        let write2 = \"qwer-\";\n-        let write3 = \"-zxcv\";\n-        let content = \"qwer-asdf-zxcv\";\n-        {\n-            let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n-            let mut rw = check!(oo.open(&filename));\n-            assert_eq!(check!(rw.seek_write(write1.as_bytes(), 5)), write1.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(rw.seek_read(&mut buf, 5)), write1.len());\n-            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(rw.seek(SeekFrom::Start(0))), 0);\n-            assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n-            assert_eq!(check!(rw.read(&mut buf)), write1.len());\n-            assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n-            assert_eq!(check!(rw.seek_read(&mut buf[..write2.len()], 0)), write2.len());\n-            assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n-            assert_eq!(check!(rw.seek_write(write3.as_bytes(), 9)), write3.len());\n-            assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 14);\n-        }\n-        {\n-            let mut read = check!(File::open(&filename));\n-            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n-            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n-            assert_eq!(check!(read.read(&mut buf)), write3.len());\n-            assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n-            assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n-            assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n-            assert_eq!(check!(read.seek_read(&mut buf, 14)), 0);\n-            assert_eq!(check!(read.seek_read(&mut buf, 15)), 0);\n-        }\n-        check!(fs::remove_file(&filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_file() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n-        {\n-            let mut opts = OpenOptions::new();\n-            let mut fs = check!(opts.read(true).write(true).create(true).open(filename));\n-            let msg = \"hw\";\n-            fs.write(msg.as_bytes()).unwrap();\n-\n-            let fstat_res = check!(fs.metadata());\n-            assert!(fstat_res.is_file());\n-        }\n-        let stat_res_fn = check!(fs::metadata(filename));\n-        assert!(stat_res_fn.is_file());\n-        let stat_res_meth = check!(filename.metadata());\n-        assert!(stat_res_meth.is_file());\n-        check!(fs::remove_file(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_dir() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(fs::create_dir(filename));\n-        let stat_res_fn = check!(fs::metadata(filename));\n-        assert!(stat_res_fn.is_dir());\n-        let stat_res_meth = check!(filename.metadata());\n-        assert!(stat_res_meth.is_dir());\n-        check!(fs::remove_dir(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(fs::create_dir(dir));\n-        assert!(!dir.is_file());\n-        check!(fs::remove_dir(dir));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        let tmpdir = tmpdir();\n-        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        check!(check!(File::create(file)).write(b\"foo\"));\n-        assert!(file.exists());\n-        check!(fs::remove_file(file));\n-        assert!(!file.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"before_and_after_dir\");\n-        assert!(!dir.exists());\n-        check!(fs::create_dir(dir));\n-        assert!(dir.exists());\n-        assert!(dir.is_dir());\n-        check!(fs::remove_dir(dir));\n-        assert!(!dir.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_readdir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"di_readdir\");\n-        check!(fs::create_dir(dir));\n-        let prefix = \"foo\";\n-        for n in 0..3 {\n-            let f = dir.join(&format!(\"{}.txt\", n));\n-            let mut w = check!(File::create(&f));\n-            let msg_str = format!(\"{}{}\", prefix, n.to_string());\n-            let msg = msg_str.as_bytes();\n-            check!(w.write(msg));\n-        }\n-        let files = check!(fs::read_dir(dir));\n-        let mut mem = [0; 4];\n-        for f in files {\n-            let f = f.unwrap().path();\n-            {\n-                let n = f.file_stem().unwrap();\n-                check!(check!(File::open(&f)).read(&mut mem));\n-                let read_str = str::from_utf8(&mem).unwrap();\n-                let expected = format!(\"{}{}\", prefix, n.to_str().unwrap());\n-                assert_eq!(expected, read_str);\n-            }\n-            check!(fs::remove_file(&f));\n-        }\n-        check!(fs::remove_dir(dir));\n-    }\n-\n-    #[test]\n-    fn file_create_new_already_exists_error() {\n-        let tmpdir = tmpdir();\n-        let file = &tmpdir.join(\"file_create_new_error_exists\");\n-        check!(fs::File::create(file));\n-        let e = fs::OpenOptions::new().write(true).create_new(true).open(file).unwrap_err();\n-        assert_eq!(e.kind(), ErrorKind::AlreadyExists);\n-    }\n-\n-    #[test]\n-    fn mkdir_path_already_exists_error() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"mkdir_error_twice\");\n-        check!(fs::create_dir(dir));\n-        let e = fs::create_dir(dir).unwrap_err();\n-        assert_eq!(e.kind(), ErrorKind::AlreadyExists);\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1/d2\");\n-        check!(fs::create_dir_all(&dir));\n-        assert!(dir.is_dir())\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_failure() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1\");\n-        let file = dir.join(\"f1\");\n-\n-        check!(fs::create_dir_all(&dir));\n-        check!(File::create(&file));\n-\n-        let result = fs::create_dir_all(&file);\n-\n-        assert!(result.is_err());\n-    }\n-\n-    #[test]\n-    fn concurrent_recursive_mkdir() {\n-        for _ in 0..100 {\n-            let dir = tmpdir();\n-            let mut dir = dir.join(\"a\");\n-            for _ in 0..40 {\n-                dir = dir.join(\"a\");\n-            }\n-            let mut join = vec![];\n-            for _ in 0..8 {\n-                let dir = dir.clone();\n-                join.push(thread::spawn(move || {\n-                    check!(fs::create_dir_all(&dir));\n-                }))\n-            }\n-\n-            // No `Display` on result of `join()`\n-            join.drain(..).map(|join| join.join().unwrap()).count();\n-        }\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_slash() {\n-        check!(fs::create_dir_all(Path::new(\"/\")));\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_dot() {\n-        check!(fs::create_dir_all(Path::new(\".\")));\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_empty() {\n-        check!(fs::create_dir_all(Path::new(\"\")));\n-    }\n-\n-    #[test]\n-    fn recursive_rmdir() {\n-        let tmpdir = tmpdir();\n-        let d1 = tmpdir.join(\"d1\");\n-        let dt = d1.join(\"t\");\n-        let dtt = dt.join(\"t\");\n-        let d2 = tmpdir.join(\"d2\");\n-        let canary = d2.join(\"do_not_delete\");\n-        check!(fs::create_dir_all(&dtt));\n-        check!(fs::create_dir_all(&d2));\n-        check!(check!(File::create(&canary)).write(b\"foo\"));\n-        check!(symlink_junction(&d2, &dt.join(\"d2\")));\n-        let _ = symlink_file(&canary, &d1.join(\"canary\"));\n-        check!(fs::remove_dir_all(&d1));\n-\n-        assert!(!d1.is_dir());\n-        assert!(canary.exists());\n-    }\n-\n-    #[test]\n-    fn recursive_rmdir_of_symlink() {\n-        // test we do not recursively delete a symlink but only dirs.\n-        let tmpdir = tmpdir();\n-        let link = tmpdir.join(\"d1\");\n-        let dir = tmpdir.join(\"d2\");\n-        let canary = dir.join(\"do_not_delete\");\n-        check!(fs::create_dir_all(&dir));\n-        check!(check!(File::create(&canary)).write(b\"foo\"));\n-        check!(symlink_junction(&dir, &link));\n-        check!(fs::remove_dir_all(&link));\n-\n-        assert!(!link.is_dir());\n-        assert!(canary.exists());\n-    }\n-\n-    #[test]\n-    // only Windows makes a distinction between file and directory symlinks.\n-    #[cfg(windows)]\n-    fn recursive_rmdir_of_file_symlink() {\n-        let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-\n-        let f1 = tmpdir.join(\"f1\");\n-        let f2 = tmpdir.join(\"f2\");\n-        check!(check!(File::create(&f1)).write(b\"foo\"));\n-        check!(symlink_file(&f1, &f2));\n-        match fs::remove_dir_all(&f2) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn unicode_path_is_dir() {\n-        assert!(Path::new(\".\").is_dir());\n-        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n-\n-        let tmpdir = tmpdir();\n-\n-        let mut dirpath = tmpdir.path().to_path_buf();\n-        dirpath.push(\"test-\uac00\u4e00\u30fc\u4f60\u597d\");\n-        check!(fs::create_dir(&dirpath));\n-        assert!(dirpath.is_dir());\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\u{ac00}\\u{4e00}\\u{30fc}\\u{4f60}\\u{597d}.rs\");\n-        check!(File::create(&filepath)); // ignore return; touch only\n-        assert!(!filepath.is_dir());\n-        assert!(filepath.exists());\n-    }\n-\n-    #[test]\n-    fn unicode_path_exists() {\n-        assert!(Path::new(\".\").exists());\n-        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n-\n-        let tmpdir = tmpdir();\n-        let unicode = tmpdir.path();\n-        let unicode = unicode.join(\"test-\uac01\u4e01\u30fc\u518d\u89c1\");\n-        check!(fs::create_dir(&unicode));\n-        assert!(unicode.exists());\n-        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_does_not_exist() {\n-        let from = Path::new(\"test/nonexistent-bogus-path\");\n-        let to = Path::new(\"test/other-bogus-path\");\n-\n-        match fs::copy(&from, &to) {\n-            Ok(..) => panic!(),\n-            Err(..) => {\n-                assert!(!from.exists());\n-                assert!(!to.exists());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_src_does_not_exist() {\n-        let tmpdir = tmpdir();\n-        let from = Path::new(\"test/nonexistent-bogus-path\");\n-        let to = tmpdir.join(\"out.txt\");\n-        check!(check!(File::create(&to)).write(b\"hello\"));\n-        assert!(fs::copy(&from, &to).is_err());\n-        assert!(!from.exists());\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&to)).read_to_end(&mut v));\n-        assert_eq!(v, b\"hello\");\n-    }\n-\n-    #[test]\n-    fn copy_file_ok() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(check!(File::create(&input)).write(b\"hello\"));\n-        check!(fs::copy(&input, &out));\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&out)).read_to_end(&mut v));\n-        assert_eq!(v, b\"hello\");\n-\n-        assert_eq!(check!(input.metadata()).permissions(), check!(out.metadata()).permissions());\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        check!(File::create(&out));\n-        match fs::copy(&*out, tmpdir.path()) {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_exists() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in\");\n-        let output = tmpdir.join(\"out\");\n-\n-        check!(check!(File::create(&input)).write(\"foo\".as_bytes()));\n-        check!(check!(File::create(&output)).write(\"bar\".as_bytes()));\n-        check!(fs::copy(&input, &output));\n-\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&output)).read_to_end(&mut v));\n-        assert_eq!(v, b\"foo\".to_vec());\n-    }\n-\n-    #[test]\n-    fn copy_file_src_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        match fs::copy(tmpdir.path(), &out) {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-        assert!(!out.exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_preserves_perm_bits() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        let attr = check!(check!(File::create(&input)).metadata());\n-        let mut p = attr.permissions();\n-        p.set_readonly(true);\n-        check!(fs::set_permissions(&input, p));\n-        check!(fs::copy(&input, &out));\n-        assert!(check!(out.metadata()).permissions().readonly());\n-        check!(fs::set_permissions(&input, attr.permissions()));\n-        check!(fs::set_permissions(&out, attr.permissions()));\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn copy_file_preserves_streams() {\n-        let tmp = tmpdir();\n-        check!(check!(File::create(tmp.join(\"in.txt:bunny\"))).write(\"carrot\".as_bytes()));\n-        assert_eq!(check!(fs::copy(tmp.join(\"in.txt\"), tmp.join(\"out.txt\"))), 0);\n-        assert_eq!(check!(tmp.join(\"out.txt\").metadata()).len(), 0);\n-        let mut v = Vec::new();\n-        check!(check!(File::open(tmp.join(\"out.txt:bunny\"))).read_to_end(&mut v));\n-        assert_eq!(v, b\"carrot\".to_vec());\n-    }\n-\n-    #[test]\n-    fn copy_file_returns_metadata_len() {\n-        let tmp = tmpdir();\n-        let in_path = tmp.join(\"in.txt\");\n-        let out_path = tmp.join(\"out.txt\");\n-        check!(check!(File::create(&in_path)).write(b\"lettuce\"));\n-        #[cfg(windows)]\n-        check!(check!(File::create(tmp.join(\"in.txt:bunny\"))).write(b\"carrot\"));\n-        let copied_len = check!(fs::copy(&in_path, &out_path));\n-        assert_eq!(check!(out_path.metadata()).len(), copied_len);\n-    }\n-\n-    #[test]\n-    fn copy_file_follows_dst_symlink() {\n-        let tmp = tmpdir();\n-        if !got_symlink_permission(&tmp) {\n-            return;\n-        };\n-\n-        let in_path = tmp.join(\"in.txt\");\n-        let out_path = tmp.join(\"out.txt\");\n-        let out_path_symlink = tmp.join(\"out_symlink.txt\");\n-\n-        check!(fs::write(&in_path, \"foo\"));\n-        check!(fs::write(&out_path, \"bar\"));\n-        check!(symlink_file(&out_path, &out_path_symlink));\n-\n-        check!(fs::copy(&in_path, &out_path_symlink));\n-\n-        assert!(check!(out_path_symlink.symlink_metadata()).file_type().is_symlink());\n-        assert_eq!(check!(fs::read(&out_path_symlink)), b\"foo\".to_vec());\n-        assert_eq!(check!(fs::read(&out_path)), b\"foo\".to_vec());\n-    }\n-\n-    #[test]\n-    fn symlinks_work() {\n-        let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n-        check!(symlink_file(&input, &out));\n-        assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n-        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&out)).read_to_end(&mut v));\n-        assert_eq!(v, b\"foobar\".to_vec());\n-    }\n-\n-    #[test]\n-    fn symlink_noexist() {\n-        // Symlinks can point to things that don't exist\n-        let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-\n-        // Use a relative path for testing. Symlinks get normalized by Windows,\n-        // so we may not get the same path back for absolute paths\n-        check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n-        assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(), \"foo\");\n-    }\n-\n-    #[test]\n-    fn read_link() {\n-        if cfg!(windows) {\n-            // directory symlink\n-            assert_eq!(\n-                check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n-                r\"C:\\ProgramData\"\n-            );\n-            // junction\n-            assert_eq!(\n-                check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n-                r\"C:\\Users\\Default\"\n-            );\n-            // junction with special permissions\n-            assert_eq!(\n-                check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n-                r\"C:\\Users\"\n-            );\n-        }\n-        let tmpdir = tmpdir();\n-        let link = tmpdir.join(\"link\");\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-        check!(symlink_file(&\"foo\", &link));\n-        assert_eq!(check!(fs::read_link(&link)).to_str().unwrap(), \"foo\");\n-    }\n-\n-    #[test]\n-    fn readlink_not_symlink() {\n-        let tmpdir = tmpdir();\n-        match fs::read_link(tmpdir.path()) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn links_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n-        check!(fs::hard_link(&input, &out));\n-        assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n-        assert_eq!(check!(fs::metadata(&out)).len(), check!(input.metadata()).len());\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&out)).read_to_end(&mut v));\n-        assert_eq!(v, b\"foobar\".to_vec());\n-\n-        // can't link to yourself\n-        match fs::hard_link(&input, &input) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-        // can't link to something that doesn't exist\n-        match fs::hard_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn chmod_works() {\n-        let tmpdir = tmpdir();\n-        let file = tmpdir.join(\"in.txt\");\n-\n-        check!(File::create(&file));\n-        let attr = check!(fs::metadata(&file));\n-        assert!(!attr.permissions().readonly());\n-        let mut p = attr.permissions();\n-        p.set_readonly(true);\n-        check!(fs::set_permissions(&file, p.clone()));\n-        let attr = check!(fs::metadata(&file));\n-        assert!(attr.permissions().readonly());\n-\n-        match fs::set_permissions(&tmpdir.join(\"foo\"), p.clone()) {\n-            Ok(..) => panic!(\"wanted an error\"),\n-            Err(..) => {}\n-        }\n-\n-        p.set_readonly(false);\n-        check!(fs::set_permissions(&file, p));\n-    }\n-\n-    #[test]\n-    fn fchmod_works() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let file = check!(File::create(&path));\n-        let attr = check!(fs::metadata(&path));\n-        assert!(!attr.permissions().readonly());\n-        let mut p = attr.permissions();\n-        p.set_readonly(true);\n-        check!(file.set_permissions(p.clone()));\n-        let attr = check!(fs::metadata(&path));\n-        assert!(attr.permissions().readonly());\n-\n-        p.set_readonly(false);\n-        check!(file.set_permissions(p));\n-    }\n-\n-    #[test]\n-    fn sync_doesnt_kill_anything() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::create(&path));\n-        check!(file.sync_all());\n-        check!(file.sync_data());\n-        check!(file.write(b\"foo\"));\n-        check!(file.sync_all());\n-        check!(file.sync_data());\n-    }\n-\n-    #[test]\n-    fn truncate_works() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::create(&path));\n-        check!(file.write(b\"foo\"));\n-        check!(file.sync_all());\n-\n-        // Do some simple things with truncation\n-        assert_eq!(check!(file.metadata()).len(), 3);\n-        check!(file.set_len(10));\n-        assert_eq!(check!(file.metadata()).len(), 10);\n-        check!(file.write(b\"bar\"));\n-        check!(file.sync_all());\n-        assert_eq!(check!(file.metadata()).len(), 10);\n-\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&path)).read_to_end(&mut v));\n-        assert_eq!(v, b\"foobar\\0\\0\\0\\0\".to_vec());\n-\n-        // Truncate to a smaller length, don't seek, and then write something.\n-        // Ensure that the intermediate zeroes are all filled in (we have `seek`ed\n-        // past the end of the file).\n-        check!(file.set_len(2));\n-        assert_eq!(check!(file.metadata()).len(), 2);\n-        check!(file.write(b\"wut\"));\n-        check!(file.sync_all());\n-        assert_eq!(check!(file.metadata()).len(), 9);\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&path)).read_to_end(&mut v));\n-        assert_eq!(v, b\"fo\\0\\0\\0\\0wut\".to_vec());\n-    }\n-\n-    #[test]\n-    fn open_flavors() {\n-        use crate::fs::OpenOptions as OO;\n-        fn c<T: Clone>(t: &T) -> T {\n-            t.clone()\n-        }\n-\n-        let tmpdir = tmpdir();\n-\n-        let mut r = OO::new();\n-        r.read(true);\n-        let mut w = OO::new();\n-        w.write(true);\n-        let mut rw = OO::new();\n-        rw.read(true).write(true);\n-        let mut a = OO::new();\n-        a.append(true);\n-        let mut ra = OO::new();\n-        ra.read(true).append(true);\n-\n-        #[cfg(windows)]\n-        let invalid_options = 87; // ERROR_INVALID_PARAMETER\n-        #[cfg(all(unix, not(target_os = \"vxworks\")))]\n-        let invalid_options = \"Invalid argument\";\n-        #[cfg(target_os = \"vxworks\")]\n-        let invalid_options = \"invalid argument\";\n-\n-        // Test various combinations of creation modes and access modes.\n-        //\n-        // Allowed:\n-        // creation mode           | read  | write | read-write | append | read-append |\n-        // :-----------------------|:-----:|:-----:|:----------:|:------:|:-----------:|\n-        // not set (open existing) |   X   |   X   |     X      |   X    |      X      |\n-        // create                  |       |   X   |     X      |   X    |      X      |\n-        // truncate                |       |   X   |     X      |        |             |\n-        // create and truncate     |       |   X   |     X      |        |             |\n-        // create_new              |       |   X   |     X      |   X    |      X      |\n-        //\n-        // tested in reverse order, so 'create_new' creates the file, and 'open existing' opens it.\n-\n-        // write-only\n-        check!(c(&w).create_new(true).open(&tmpdir.join(\"a\")));\n-        check!(c(&w).create(true).truncate(true).open(&tmpdir.join(\"a\")));\n-        check!(c(&w).truncate(true).open(&tmpdir.join(\"a\")));\n-        check!(c(&w).create(true).open(&tmpdir.join(\"a\")));\n-        check!(c(&w).open(&tmpdir.join(\"a\")));\n-\n-        // read-only\n-        error!(c(&r).create_new(true).open(&tmpdir.join(\"b\")), invalid_options);\n-        error!(c(&r).create(true).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n-        error!(c(&r).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n-        error!(c(&r).create(true).open(&tmpdir.join(\"b\")), invalid_options);\n-        check!(c(&r).open(&tmpdir.join(\"a\"))); // try opening the file created with write_only\n-\n-        // read-write\n-        check!(c(&rw).create_new(true).open(&tmpdir.join(\"c\")));\n-        check!(c(&rw).create(true).truncate(true).open(&tmpdir.join(\"c\")));\n-        check!(c(&rw).truncate(true).open(&tmpdir.join(\"c\")));\n-        check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n-        check!(c(&rw).open(&tmpdir.join(\"c\")));\n-\n-        // append\n-        check!(c(&a).create_new(true).open(&tmpdir.join(\"d\")));\n-        error!(c(&a).create(true).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n-        error!(c(&a).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n-        check!(c(&a).create(true).open(&tmpdir.join(\"d\")));\n-        check!(c(&a).open(&tmpdir.join(\"d\")));\n-\n-        // read-append\n-        check!(c(&ra).create_new(true).open(&tmpdir.join(\"e\")));\n-        error!(c(&ra).create(true).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n-        error!(c(&ra).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n-        check!(c(&ra).create(true).open(&tmpdir.join(\"e\")));\n-        check!(c(&ra).open(&tmpdir.join(\"e\")));\n-\n-        // Test opening a file without setting an access mode\n-        let mut blank = OO::new();\n-        error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n-\n-        // Test write works\n-        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n-\n-        // Test write fails for read-only\n-        check!(r.open(&tmpdir.join(\"h\")));\n-        {\n-            let mut f = check!(r.open(&tmpdir.join(\"h\")));\n-            assert!(f.write(\"wut\".as_bytes()).is_err());\n-        }\n-\n-        // Test write overwrites\n-        {\n-            let mut f = check!(c(&w).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"baz\".as_bytes()));\n-        }\n-        {\n-            let mut f = check!(c(&r).open(&tmpdir.join(\"h\")));\n-            let mut b = vec![0; 6];\n-            check!(f.read(&mut b));\n-            assert_eq!(b, \"bazbar\".as_bytes());\n-        }\n-\n-        // Test truncate works\n-        {\n-            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"foo\".as_bytes()));\n-        }\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n-\n-        // Test append works\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n-        {\n-            let mut f = check!(c(&a).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"bar\".as_bytes()));\n-        }\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 6);\n-\n-        // Test .append(true) equals .write(true).append(true)\n-        {\n-            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"baz\".as_bytes()));\n-        }\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 9);\n-    }\n-\n-    #[test]\n-    fn _assert_send_sync() {\n-        fn _assert_send_sync<T: Send + Sync>() {}\n-        _assert_send_sync::<OpenOptions>();\n-    }\n-\n-    #[test]\n-    fn binary_file() {\n-        let mut bytes = [0; 1024];\n-        StdRng::from_entropy().fill_bytes(&mut bytes);\n-\n-        let tmpdir = tmpdir();\n-\n-        check!(check!(File::create(&tmpdir.join(\"test\"))).write(&bytes));\n-        let mut v = Vec::new();\n-        check!(check!(File::open(&tmpdir.join(\"test\"))).read_to_end(&mut v));\n-        assert!(v == &bytes[..]);\n-    }\n-\n-    #[test]\n-    fn write_then_read() {\n-        let mut bytes = [0; 1024];\n-        StdRng::from_entropy().fill_bytes(&mut bytes);\n-\n-        let tmpdir = tmpdir();\n-\n-        check!(fs::write(&tmpdir.join(\"test\"), &bytes[..]));\n-        let v = check!(fs::read(&tmpdir.join(\"test\")));\n-        assert!(v == &bytes[..]);\n-\n-        check!(fs::write(&tmpdir.join(\"not-utf8\"), &[0xFF]));\n-        error_contains!(\n-            fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n-            \"stream did not contain valid UTF-8\"\n-        );\n-\n-        let s = \"\ud800\udc41\ud800\udc13\ud800\udc20\ud800\udc34\ud800\udc0d\";\n-        check!(fs::write(&tmpdir.join(\"utf8\"), s.as_bytes()));\n-        let string = check!(fs::read_to_string(&tmpdir.join(\"utf8\")));\n-        assert_eq!(string, s);\n-    }\n-\n-    #[test]\n-    fn file_try_clone() {\n-        let tmpdir = tmpdir();\n-\n-        let mut f1 = check!(\n-            OpenOptions::new().read(true).write(true).create(true).open(&tmpdir.join(\"test\"))\n-        );\n-        let mut f2 = check!(f1.try_clone());\n-\n-        check!(f1.write_all(b\"hello world\"));\n-        check!(f1.seek(SeekFrom::Start(2)));\n-\n-        let mut buf = vec![];\n-        check!(f2.read_to_end(&mut buf));\n-        assert_eq!(buf, b\"llo world\");\n-        drop(f2);\n-\n-        check!(f1.write_all(b\"!\"));\n-    }\n-\n-    #[test]\n-    #[cfg(not(windows))]\n-    fn unlink_readonly() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"file\");\n-        check!(File::create(&path));\n-        let mut perm = check!(fs::metadata(&path)).permissions();\n-        perm.set_readonly(true);\n-        check!(fs::set_permissions(&path, perm));\n-        check!(fs::remove_file(&path));\n-    }\n-\n-    #[test]\n-    fn mkdir_trailing_slash() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"file\");\n-        check!(fs::create_dir_all(&path.join(\"a/\")));\n-    }\n-\n-    #[test]\n-    fn canonicalize_works_simple() {\n-        let tmpdir = tmpdir();\n-        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n-        let file = tmpdir.join(\"test\");\n-        File::create(&file).unwrap();\n-        assert_eq!(fs::canonicalize(&file).unwrap(), file);\n-    }\n-\n-    #[test]\n-    fn realpath_works() {\n-        let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-\n-        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n-        let file = tmpdir.join(\"test\");\n-        let dir = tmpdir.join(\"test2\");\n-        let link = dir.join(\"link\");\n-        let linkdir = tmpdir.join(\"test3\");\n-\n-        File::create(&file).unwrap();\n-        fs::create_dir(&dir).unwrap();\n-        symlink_file(&file, &link).unwrap();\n-        symlink_dir(&dir, &linkdir).unwrap();\n-\n-        assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n-\n-        assert_eq!(fs::canonicalize(&tmpdir).unwrap(), tmpdir);\n-        assert_eq!(fs::canonicalize(&file).unwrap(), file);\n-        assert_eq!(fs::canonicalize(&link).unwrap(), file);\n-        assert_eq!(fs::canonicalize(&linkdir).unwrap(), dir);\n-        assert_eq!(fs::canonicalize(&linkdir.join(\"link\")).unwrap(), file);\n-    }\n-\n-    #[test]\n-    fn realpath_works_tricky() {\n-        let tmpdir = tmpdir();\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-\n-        let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n-        let a = tmpdir.join(\"a\");\n-        let b = a.join(\"b\");\n-        let c = b.join(\"c\");\n-        let d = a.join(\"d\");\n-        let e = d.join(\"e\");\n-        let f = a.join(\"f\");\n-\n-        fs::create_dir_all(&b).unwrap();\n-        fs::create_dir_all(&d).unwrap();\n-        File::create(&f).unwrap();\n-        if cfg!(not(windows)) {\n-            symlink_file(\"../d/e\", &c).unwrap();\n-            symlink_file(\"../f\", &e).unwrap();\n-        }\n-        if cfg!(windows) {\n-            symlink_file(r\"..\\d\\e\", &c).unwrap();\n-            symlink_file(r\"..\\f\", &e).unwrap();\n-        }\n-\n-        assert_eq!(fs::canonicalize(&c).unwrap(), f);\n-        assert_eq!(fs::canonicalize(&e).unwrap(), f);\n-    }\n-\n-    #[test]\n-    fn dir_entry_methods() {\n-        let tmpdir = tmpdir();\n-\n-        fs::create_dir_all(&tmpdir.join(\"a\")).unwrap();\n-        File::create(&tmpdir.join(\"b\")).unwrap();\n-\n-        for file in tmpdir.path().read_dir().unwrap().map(|f| f.unwrap()) {\n-            let fname = file.file_name();\n-            match fname.to_str() {\n-                Some(\"a\") => {\n-                    assert!(file.file_type().unwrap().is_dir());\n-                    assert!(file.metadata().unwrap().is_dir());\n-                }\n-                Some(\"b\") => {\n-                    assert!(file.file_type().unwrap().is_file());\n-                    assert!(file.metadata().unwrap().is_file());\n-                }\n-                f => panic!(\"unknown file name: {:?}\", f),\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn dir_entry_debug() {\n-        let tmpdir = tmpdir();\n-        File::create(&tmpdir.join(\"b\")).unwrap();\n-        let mut read_dir = tmpdir.path().read_dir().unwrap();\n-        let dir_entry = read_dir.next().unwrap().unwrap();\n-        let actual = format!(\"{:?}\", dir_entry);\n-        let expected = format!(\"DirEntry({:?})\", dir_entry.0.path());\n-        assert_eq!(actual, expected);\n-    }\n-\n-    #[test]\n-    fn read_dir_not_found() {\n-        let res = fs::read_dir(\"/path/that/does/not/exist\");\n-        assert_eq!(res.err().unwrap().kind(), ErrorKind::NotFound);\n-    }\n-\n-    #[test]\n-    fn create_dir_all_with_junctions() {\n-        let tmpdir = tmpdir();\n-        let target = tmpdir.join(\"target\");\n-\n-        let junction = tmpdir.join(\"junction\");\n-        let b = junction.join(\"a/b\");\n-\n-        let link = tmpdir.join(\"link\");\n-        let d = link.join(\"c/d\");\n-\n-        fs::create_dir(&target).unwrap();\n-\n-        check!(symlink_junction(&target, &junction));\n-        check!(fs::create_dir_all(&b));\n-        // the junction itself is not a directory, but `is_dir()` on a Path\n-        // follows links\n-        assert!(junction.is_dir());\n-        assert!(b.exists());\n-\n-        if !got_symlink_permission(&tmpdir) {\n-            return;\n-        };\n-        check!(symlink_dir(&target, &link));\n-        check!(fs::create_dir_all(&d));\n-        assert!(link.is_dir());\n-        assert!(d.exists());\n-    }\n-\n-    #[test]\n-    fn metadata_access_times() {\n-        let tmpdir = tmpdir();\n-\n-        let b = tmpdir.join(\"b\");\n-        File::create(&b).unwrap();\n-\n-        let a = check!(fs::metadata(&tmpdir.path()));\n-        let b = check!(fs::metadata(&b));\n-\n-        assert_eq!(check!(a.accessed()), check!(a.accessed()));\n-        assert_eq!(check!(a.modified()), check!(a.modified()));\n-        assert_eq!(check!(b.accessed()), check!(b.modified()));\n-\n-        if cfg!(target_os = \"macos\") || cfg!(target_os = \"windows\") {\n-            check!(a.created());\n-            check!(b.created());\n-        }\n-\n-        if cfg!(target_os = \"linux\") {\n-            // Not always available\n-            match (a.created(), b.created()) {\n-                (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n-                (Err(e1), Err(e2))\n-                    if e1.kind() == ErrorKind::Other && e2.kind() == ErrorKind::Other => {}\n-                (a, b) => panic!(\n-                    \"creation time must be always supported or not supported: {:?} {:?}\",\n-                    a, b,\n-                ),\n-            }\n-        }\n-    }\n-}"}, {"sha": "65a29076fefa811b4054040de1bfac5b8d7247d8", "filename": "library/std/src/fs/tests.rs", "status": "added", "additions": 1339, "deletions": 0, "changes": 1339, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,1339 @@\n+use crate::io::prelude::*;\n+\n+use crate::fs::{self, File, OpenOptions};\n+use crate::io::{ErrorKind, SeekFrom};\n+use crate::path::Path;\n+use crate::str;\n+use crate::sys_common::io::test::{tmpdir, TempDir};\n+use crate::thread;\n+\n+use rand::{rngs::StdRng, RngCore, SeedableRng};\n+\n+#[cfg(unix)]\n+use crate::os::unix::fs::symlink as symlink_dir;\n+#[cfg(unix)]\n+use crate::os::unix::fs::symlink as symlink_file;\n+#[cfg(unix)]\n+use crate::os::unix::fs::symlink as symlink_junction;\n+#[cfg(windows)]\n+use crate::os::windows::fs::{symlink_dir, symlink_file};\n+#[cfg(windows)]\n+use crate::sys::fs::symlink_junction;\n+\n+macro_rules! check {\n+    ($e:expr) => {\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+        }\n+    };\n+}\n+\n+#[cfg(windows)]\n+macro_rules! error {\n+    ($e:expr, $s:expr) => {\n+        match $e {\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+            Err(ref err) => assert!(\n+                err.raw_os_error() == Some($s),\n+                format!(\"`{}` did not have a code of `{}`\", err, $s)\n+            ),\n+        }\n+    };\n+}\n+\n+#[cfg(unix)]\n+macro_rules! error {\n+    ($e:expr, $s:expr) => {\n+        error_contains!($e, $s)\n+    };\n+}\n+\n+macro_rules! error_contains {\n+    ($e:expr, $s:expr) => {\n+        match $e {\n+            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n+            Err(ref err) => {\n+                assert!(err.to_string().contains($s), format!(\"`{}` did not contain `{}`\", err, $s))\n+            }\n+        }\n+    };\n+}\n+\n+// Several test fail on windows if the user does not have permission to\n+// create symlinks (the `SeCreateSymbolicLinkPrivilege`). Instead of\n+// disabling these test on Windows, use this function to test whether we\n+// have permission, and return otherwise. This way, we still don't run these\n+// tests most of the time, but at least we do if the user has the right\n+// permissions.\n+pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n+    if cfg!(unix) {\n+        return true;\n+    }\n+    let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n+\n+    match symlink_file(r\"nonexisting_target\", link) {\n+        Ok(_) => true,\n+        // ERROR_PRIVILEGE_NOT_HELD = 1314\n+        Err(ref err) if err.raw_os_error() == Some(1314) => false,\n+        Err(_) => true,\n+    }\n+}\n+\n+#[test]\n+fn file_test_io_smoke_test() {\n+    let message = \"it's alright. have a good time\";\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n+    {\n+        let mut write_stream = check!(File::create(filename));\n+        check!(write_stream.write(message.as_bytes()));\n+    }\n+    {\n+        let mut read_stream = check!(File::open(filename));\n+        let mut read_buf = [0; 1028];\n+        let read_str = match check!(read_stream.read(&mut read_buf)) {\n+            0 => panic!(\"shouldn't happen\"),\n+            n => str::from_utf8(&read_buf[..n]).unwrap().to_string(),\n+        };\n+        assert_eq!(read_str, message);\n+    }\n+    check!(fs::remove_file(filename));\n+}\n+\n+#[test]\n+fn invalid_path_raises() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n+    let result = File::open(filename);\n+\n+    #[cfg(all(unix, not(target_os = \"vxworks\")))]\n+    error!(result, \"No such file or directory\");\n+    #[cfg(target_os = \"vxworks\")]\n+    error!(result, \"no such file or directory\");\n+    #[cfg(windows)]\n+    error!(result, 2); // ERROR_FILE_NOT_FOUND\n+}\n+\n+#[test]\n+fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n+\n+    let result = fs::remove_file(filename);\n+\n+    #[cfg(all(unix, not(target_os = \"vxworks\")))]\n+    error!(result, \"No such file or directory\");\n+    #[cfg(target_os = \"vxworks\")]\n+    error!(result, \"no such file or directory\");\n+    #[cfg(windows)]\n+    error!(result, 2); // ERROR_FILE_NOT_FOUND\n+}\n+\n+#[test]\n+fn file_test_io_non_positional_read() {\n+    let message: &str = \"ten-four\";\n+    let mut read_mem = [0; 8];\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n+    {\n+        let mut rw_stream = check!(File::create(filename));\n+        check!(rw_stream.write(message.as_bytes()));\n+    }\n+    {\n+        let mut read_stream = check!(File::open(filename));\n+        {\n+            let read_buf = &mut read_mem[0..4];\n+            check!(read_stream.read(read_buf));\n+        }\n+        {\n+            let read_buf = &mut read_mem[4..8];\n+            check!(read_stream.read(read_buf));\n+        }\n+    }\n+    check!(fs::remove_file(filename));\n+    let read_str = str::from_utf8(&read_mem).unwrap();\n+    assert_eq!(read_str, message);\n+}\n+\n+#[test]\n+fn file_test_io_seek_and_tell_smoke_test() {\n+    let message = \"ten-four\";\n+    let mut read_mem = [0; 4];\n+    let set_cursor = 4 as u64;\n+    let tell_pos_pre_read;\n+    let tell_pos_post_read;\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n+    {\n+        let mut rw_stream = check!(File::create(filename));\n+        check!(rw_stream.write(message.as_bytes()));\n+    }\n+    {\n+        let mut read_stream = check!(File::open(filename));\n+        check!(read_stream.seek(SeekFrom::Start(set_cursor)));\n+        tell_pos_pre_read = check!(read_stream.seek(SeekFrom::Current(0)));\n+        check!(read_stream.read(&mut read_mem));\n+        tell_pos_post_read = check!(read_stream.seek(SeekFrom::Current(0)));\n+    }\n+    check!(fs::remove_file(filename));\n+    let read_str = str::from_utf8(&read_mem).unwrap();\n+    assert_eq!(read_str, &message[4..8]);\n+    assert_eq!(tell_pos_pre_read, set_cursor);\n+    assert_eq!(tell_pos_post_read, message.len() as u64);\n+}\n+\n+#[test]\n+fn file_test_io_seek_and_write() {\n+    let initial_msg = \"food-is-yummy\";\n+    let overwrite_msg = \"-the-bar!!\";\n+    let final_msg = \"foo-the-bar!!\";\n+    let seek_idx = 3;\n+    let mut read_mem = [0; 13];\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n+    {\n+        let mut rw_stream = check!(File::create(filename));\n+        check!(rw_stream.write(initial_msg.as_bytes()));\n+        check!(rw_stream.seek(SeekFrom::Start(seek_idx)));\n+        check!(rw_stream.write(overwrite_msg.as_bytes()));\n+    }\n+    {\n+        let mut read_stream = check!(File::open(filename));\n+        check!(read_stream.read(&mut read_mem));\n+    }\n+    check!(fs::remove_file(filename));\n+    let read_str = str::from_utf8(&read_mem).unwrap();\n+    assert!(read_str == final_msg);\n+}\n+\n+#[test]\n+fn file_test_io_seek_shakedown() {\n+    //                   01234567890123\n+    let initial_msg = \"qwer-asdf-zxcv\";\n+    let chunk_one: &str = \"qwer\";\n+    let chunk_two: &str = \"asdf\";\n+    let chunk_three: &str = \"zxcv\";\n+    let mut read_mem = [0; 4];\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n+    {\n+        let mut rw_stream = check!(File::create(filename));\n+        check!(rw_stream.write(initial_msg.as_bytes()));\n+    }\n+    {\n+        let mut read_stream = check!(File::open(filename));\n+\n+        check!(read_stream.seek(SeekFrom::End(-4)));\n+        check!(read_stream.read(&mut read_mem));\n+        assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n+\n+        check!(read_stream.seek(SeekFrom::Current(-9)));\n+        check!(read_stream.read(&mut read_mem));\n+        assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n+\n+        check!(read_stream.seek(SeekFrom::Start(0)));\n+        check!(read_stream.read(&mut read_mem));\n+        assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n+    }\n+    check!(fs::remove_file(filename));\n+}\n+\n+#[test]\n+fn file_test_io_eof() {\n+    let tmpdir = tmpdir();\n+    let filename = tmpdir.join(\"file_rt_io_file_test_eof.txt\");\n+    let mut buf = [0; 256];\n+    {\n+        let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+        let mut rw = check!(oo.open(&filename));\n+        assert_eq!(check!(rw.read(&mut buf)), 0);\n+        assert_eq!(check!(rw.read(&mut buf)), 0);\n+    }\n+    check!(fs::remove_file(&filename));\n+}\n+\n+#[test]\n+#[cfg(unix)]\n+fn file_test_io_read_write_at() {\n+    use crate::os::unix::fs::FileExt;\n+\n+    let tmpdir = tmpdir();\n+    let filename = tmpdir.join(\"file_rt_io_file_test_read_write_at.txt\");\n+    let mut buf = [0; 256];\n+    let write1 = \"asdf\";\n+    let write2 = \"qwer-\";\n+    let write3 = \"-zxcv\";\n+    let content = \"qwer-asdf-zxcv\";\n+    {\n+        let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+        let mut rw = check!(oo.open(&filename));\n+        assert_eq!(check!(rw.write_at(write1.as_bytes(), 5)), write1.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+        assert_eq!(check!(rw.read_at(&mut buf, 5)), write1.len());\n+        assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+        assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n+        assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(\"\\0\\0\\0\\0\\0\"));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 0);\n+        assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+        assert_eq!(check!(rw.read(&mut buf)), write1.len());\n+        assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(rw.read_at(&mut buf[..write2.len()], 0)), write2.len());\n+        assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(rw.write_at(write3.as_bytes(), 9)), write3.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+    }\n+    {\n+        let mut read = check!(File::open(&filename));\n+        assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 0);\n+        assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+        assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(read.read(&mut buf)), write3.len());\n+        assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.read_at(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.read_at(&mut buf, 14)), 0);\n+        assert_eq!(check!(read.read_at(&mut buf, 15)), 0);\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+    }\n+    check!(fs::remove_file(&filename));\n+}\n+\n+#[test]\n+#[cfg(unix)]\n+fn set_get_unix_permissions() {\n+    use crate::os::unix::fs::PermissionsExt;\n+\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"set_get_unix_permissions\");\n+    check!(fs::create_dir(filename));\n+    let mask = 0o7777;\n+\n+    check!(fs::set_permissions(filename, fs::Permissions::from_mode(0)));\n+    let metadata0 = check!(fs::metadata(filename));\n+    assert_eq!(mask & metadata0.permissions().mode(), 0);\n+\n+    check!(fs::set_permissions(filename, fs::Permissions::from_mode(0o1777)));\n+    let metadata1 = check!(fs::metadata(filename));\n+    #[cfg(all(unix, not(target_os = \"vxworks\")))]\n+    assert_eq!(mask & metadata1.permissions().mode(), 0o1777);\n+    #[cfg(target_os = \"vxworks\")]\n+    assert_eq!(mask & metadata1.permissions().mode(), 0o0777);\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn file_test_io_seek_read_write() {\n+    use crate::os::windows::fs::FileExt;\n+\n+    let tmpdir = tmpdir();\n+    let filename = tmpdir.join(\"file_rt_io_file_test_seek_read_write.txt\");\n+    let mut buf = [0; 256];\n+    let write1 = \"asdf\";\n+    let write2 = \"qwer-\";\n+    let write3 = \"-zxcv\";\n+    let content = \"qwer-asdf-zxcv\";\n+    {\n+        let oo = OpenOptions::new().create_new(true).write(true).read(true).clone();\n+        let mut rw = check!(oo.open(&filename));\n+        assert_eq!(check!(rw.seek_write(write1.as_bytes(), 5)), write1.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(rw.seek_read(&mut buf, 5)), write1.len());\n+        assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(rw.seek(SeekFrom::Start(0))), 0);\n+        assert_eq!(check!(rw.write(write2.as_bytes())), write2.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+        assert_eq!(check!(rw.read(&mut buf)), write1.len());\n+        assert_eq!(str::from_utf8(&buf[..write1.len()]), Ok(write1));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 9);\n+        assert_eq!(check!(rw.seek_read(&mut buf[..write2.len()], 0)), write2.len());\n+        assert_eq!(str::from_utf8(&buf[..write2.len()]), Ok(write2));\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 5);\n+        assert_eq!(check!(rw.seek_write(write3.as_bytes(), 9)), write3.len());\n+        assert_eq!(check!(rw.seek(SeekFrom::Current(0))), 14);\n+    }\n+    {\n+        let mut read = check!(File::open(&filename));\n+        assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+        assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.seek(SeekFrom::End(-5))), 9);\n+        assert_eq!(check!(read.read(&mut buf)), write3.len());\n+        assert_eq!(str::from_utf8(&buf[..write3.len()]), Ok(write3));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.seek_read(&mut buf, 0)), content.len());\n+        assert_eq!(str::from_utf8(&buf[..content.len()]), Ok(content));\n+        assert_eq!(check!(read.seek(SeekFrom::Current(0))), 14);\n+        assert_eq!(check!(read.seek_read(&mut buf, 14)), 0);\n+        assert_eq!(check!(read.seek_read(&mut buf, 15)), 0);\n+    }\n+    check!(fs::remove_file(&filename));\n+}\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_file() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n+    {\n+        let mut opts = OpenOptions::new();\n+        let mut fs = check!(opts.read(true).write(true).create(true).open(filename));\n+        let msg = \"hw\";\n+        fs.write(msg.as_bytes()).unwrap();\n+\n+        let fstat_res = check!(fs.metadata());\n+        assert!(fstat_res.is_file());\n+    }\n+    let stat_res_fn = check!(fs::metadata(filename));\n+    assert!(stat_res_fn.is_file());\n+    let stat_res_meth = check!(filename.metadata());\n+    assert!(stat_res_meth.is_file());\n+    check!(fs::remove_file(filename));\n+}\n+\n+#[test]\n+fn file_test_stat_is_correct_on_is_dir() {\n+    let tmpdir = tmpdir();\n+    let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n+    check!(fs::create_dir(filename));\n+    let stat_res_fn = check!(fs::metadata(filename));\n+    assert!(stat_res_fn.is_dir());\n+    let stat_res_meth = check!(filename.metadata());\n+    assert!(stat_res_meth.is_dir());\n+    check!(fs::remove_dir(filename));\n+}\n+\n+#[test]\n+fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    let tmpdir = tmpdir();\n+    let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n+    check!(fs::create_dir(dir));\n+    assert!(!dir.is_file());\n+    check!(fs::remove_dir(dir));\n+}\n+\n+#[test]\n+fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    let tmpdir = tmpdir();\n+    let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n+    check!(check!(File::create(file)).write(b\"foo\"));\n+    assert!(file.exists());\n+    check!(fs::remove_file(file));\n+    assert!(!file.exists());\n+}\n+\n+#[test]\n+fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    let tmpdir = tmpdir();\n+    let dir = &tmpdir.join(\"before_and_after_dir\");\n+    assert!(!dir.exists());\n+    check!(fs::create_dir(dir));\n+    assert!(dir.exists());\n+    assert!(dir.is_dir());\n+    check!(fs::remove_dir(dir));\n+    assert!(!dir.exists());\n+}\n+\n+#[test]\n+fn file_test_directoryinfo_readdir() {\n+    let tmpdir = tmpdir();\n+    let dir = &tmpdir.join(\"di_readdir\");\n+    check!(fs::create_dir(dir));\n+    let prefix = \"foo\";\n+    for n in 0..3 {\n+        let f = dir.join(&format!(\"{}.txt\", n));\n+        let mut w = check!(File::create(&f));\n+        let msg_str = format!(\"{}{}\", prefix, n.to_string());\n+        let msg = msg_str.as_bytes();\n+        check!(w.write(msg));\n+    }\n+    let files = check!(fs::read_dir(dir));\n+    let mut mem = [0; 4];\n+    for f in files {\n+        let f = f.unwrap().path();\n+        {\n+            let n = f.file_stem().unwrap();\n+            check!(check!(File::open(&f)).read(&mut mem));\n+            let read_str = str::from_utf8(&mem).unwrap();\n+            let expected = format!(\"{}{}\", prefix, n.to_str().unwrap());\n+            assert_eq!(expected, read_str);\n+        }\n+        check!(fs::remove_file(&f));\n+    }\n+    check!(fs::remove_dir(dir));\n+}\n+\n+#[test]\n+fn file_create_new_already_exists_error() {\n+    let tmpdir = tmpdir();\n+    let file = &tmpdir.join(\"file_create_new_error_exists\");\n+    check!(fs::File::create(file));\n+    let e = fs::OpenOptions::new().write(true).create_new(true).open(file).unwrap_err();\n+    assert_eq!(e.kind(), ErrorKind::AlreadyExists);\n+}\n+\n+#[test]\n+fn mkdir_path_already_exists_error() {\n+    let tmpdir = tmpdir();\n+    let dir = &tmpdir.join(\"mkdir_error_twice\");\n+    check!(fs::create_dir(dir));\n+    let e = fs::create_dir(dir).unwrap_err();\n+    assert_eq!(e.kind(), ErrorKind::AlreadyExists);\n+}\n+\n+#[test]\n+fn recursive_mkdir() {\n+    let tmpdir = tmpdir();\n+    let dir = tmpdir.join(\"d1/d2\");\n+    check!(fs::create_dir_all(&dir));\n+    assert!(dir.is_dir())\n+}\n+\n+#[test]\n+fn recursive_mkdir_failure() {\n+    let tmpdir = tmpdir();\n+    let dir = tmpdir.join(\"d1\");\n+    let file = dir.join(\"f1\");\n+\n+    check!(fs::create_dir_all(&dir));\n+    check!(File::create(&file));\n+\n+    let result = fs::create_dir_all(&file);\n+\n+    assert!(result.is_err());\n+}\n+\n+#[test]\n+fn concurrent_recursive_mkdir() {\n+    for _ in 0..100 {\n+        let dir = tmpdir();\n+        let mut dir = dir.join(\"a\");\n+        for _ in 0..40 {\n+            dir = dir.join(\"a\");\n+        }\n+        let mut join = vec![];\n+        for _ in 0..8 {\n+            let dir = dir.clone();\n+            join.push(thread::spawn(move || {\n+                check!(fs::create_dir_all(&dir));\n+            }))\n+        }\n+\n+        // No `Display` on result of `join()`\n+        join.drain(..).map(|join| join.join().unwrap()).count();\n+    }\n+}\n+\n+#[test]\n+fn recursive_mkdir_slash() {\n+    check!(fs::create_dir_all(Path::new(\"/\")));\n+}\n+\n+#[test]\n+fn recursive_mkdir_dot() {\n+    check!(fs::create_dir_all(Path::new(\".\")));\n+}\n+\n+#[test]\n+fn recursive_mkdir_empty() {\n+    check!(fs::create_dir_all(Path::new(\"\")));\n+}\n+\n+#[test]\n+fn recursive_rmdir() {\n+    let tmpdir = tmpdir();\n+    let d1 = tmpdir.join(\"d1\");\n+    let dt = d1.join(\"t\");\n+    let dtt = dt.join(\"t\");\n+    let d2 = tmpdir.join(\"d2\");\n+    let canary = d2.join(\"do_not_delete\");\n+    check!(fs::create_dir_all(&dtt));\n+    check!(fs::create_dir_all(&d2));\n+    check!(check!(File::create(&canary)).write(b\"foo\"));\n+    check!(symlink_junction(&d2, &dt.join(\"d2\")));\n+    let _ = symlink_file(&canary, &d1.join(\"canary\"));\n+    check!(fs::remove_dir_all(&d1));\n+\n+    assert!(!d1.is_dir());\n+    assert!(canary.exists());\n+}\n+\n+#[test]\n+fn recursive_rmdir_of_symlink() {\n+    // test we do not recursively delete a symlink but only dirs.\n+    let tmpdir = tmpdir();\n+    let link = tmpdir.join(\"d1\");\n+    let dir = tmpdir.join(\"d2\");\n+    let canary = dir.join(\"do_not_delete\");\n+    check!(fs::create_dir_all(&dir));\n+    check!(check!(File::create(&canary)).write(b\"foo\"));\n+    check!(symlink_junction(&dir, &link));\n+    check!(fs::remove_dir_all(&link));\n+\n+    assert!(!link.is_dir());\n+    assert!(canary.exists());\n+}\n+\n+#[test]\n+// only Windows makes a distinction between file and directory symlinks.\n+#[cfg(windows)]\n+fn recursive_rmdir_of_file_symlink() {\n+    let tmpdir = tmpdir();\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+\n+    let f1 = tmpdir.join(\"f1\");\n+    let f2 = tmpdir.join(\"f2\");\n+    check!(check!(File::create(&f1)).write(b\"foo\"));\n+    check!(symlink_file(&f1, &f2));\n+    match fs::remove_dir_all(&f2) {\n+        Ok(..) => panic!(\"wanted a failure\"),\n+        Err(..) => {}\n+    }\n+}\n+\n+#[test]\n+fn unicode_path_is_dir() {\n+    assert!(Path::new(\".\").is_dir());\n+    assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n+\n+    let tmpdir = tmpdir();\n+\n+    let mut dirpath = tmpdir.path().to_path_buf();\n+    dirpath.push(\"test-\uac00\u4e00\u30fc\u4f60\u597d\");\n+    check!(fs::create_dir(&dirpath));\n+    assert!(dirpath.is_dir());\n+\n+    let mut filepath = dirpath;\n+    filepath.push(\"unicode-file-\\u{ac00}\\u{4e00}\\u{30fc}\\u{4f60}\\u{597d}.rs\");\n+    check!(File::create(&filepath)); // ignore return; touch only\n+    assert!(!filepath.is_dir());\n+    assert!(filepath.exists());\n+}\n+\n+#[test]\n+fn unicode_path_exists() {\n+    assert!(Path::new(\".\").exists());\n+    assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n+\n+    let tmpdir = tmpdir();\n+    let unicode = tmpdir.path();\n+    let unicode = unicode.join(\"test-\uac01\u4e01\u30fc\u518d\u89c1\");\n+    check!(fs::create_dir(&unicode));\n+    assert!(unicode.exists());\n+    assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n+}\n+\n+#[test]\n+fn copy_file_does_not_exist() {\n+    let from = Path::new(\"test/nonexistent-bogus-path\");\n+    let to = Path::new(\"test/other-bogus-path\");\n+\n+    match fs::copy(&from, &to) {\n+        Ok(..) => panic!(),\n+        Err(..) => {\n+            assert!(!from.exists());\n+            assert!(!to.exists());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn copy_src_does_not_exist() {\n+    let tmpdir = tmpdir();\n+    let from = Path::new(\"test/nonexistent-bogus-path\");\n+    let to = tmpdir.join(\"out.txt\");\n+    check!(check!(File::create(&to)).write(b\"hello\"));\n+    assert!(fs::copy(&from, &to).is_err());\n+    assert!(!from.exists());\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&to)).read_to_end(&mut v));\n+    assert_eq!(v, b\"hello\");\n+}\n+\n+#[test]\n+fn copy_file_ok() {\n+    let tmpdir = tmpdir();\n+    let input = tmpdir.join(\"in.txt\");\n+    let out = tmpdir.join(\"out.txt\");\n+\n+    check!(check!(File::create(&input)).write(b\"hello\"));\n+    check!(fs::copy(&input, &out));\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&out)).read_to_end(&mut v));\n+    assert_eq!(v, b\"hello\");\n+\n+    assert_eq!(check!(input.metadata()).permissions(), check!(out.metadata()).permissions());\n+}\n+\n+#[test]\n+fn copy_file_dst_dir() {\n+    let tmpdir = tmpdir();\n+    let out = tmpdir.join(\"out\");\n+\n+    check!(File::create(&out));\n+    match fs::copy(&*out, tmpdir.path()) {\n+        Ok(..) => panic!(),\n+        Err(..) => {}\n+    }\n+}\n+\n+#[test]\n+fn copy_file_dst_exists() {\n+    let tmpdir = tmpdir();\n+    let input = tmpdir.join(\"in\");\n+    let output = tmpdir.join(\"out\");\n+\n+    check!(check!(File::create(&input)).write(\"foo\".as_bytes()));\n+    check!(check!(File::create(&output)).write(\"bar\".as_bytes()));\n+    check!(fs::copy(&input, &output));\n+\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&output)).read_to_end(&mut v));\n+    assert_eq!(v, b\"foo\".to_vec());\n+}\n+\n+#[test]\n+fn copy_file_src_dir() {\n+    let tmpdir = tmpdir();\n+    let out = tmpdir.join(\"out\");\n+\n+    match fs::copy(tmpdir.path(), &out) {\n+        Ok(..) => panic!(),\n+        Err(..) => {}\n+    }\n+    assert!(!out.exists());\n+}\n+\n+#[test]\n+fn copy_file_preserves_perm_bits() {\n+    let tmpdir = tmpdir();\n+    let input = tmpdir.join(\"in.txt\");\n+    let out = tmpdir.join(\"out.txt\");\n+\n+    let attr = check!(check!(File::create(&input)).metadata());\n+    let mut p = attr.permissions();\n+    p.set_readonly(true);\n+    check!(fs::set_permissions(&input, p));\n+    check!(fs::copy(&input, &out));\n+    assert!(check!(out.metadata()).permissions().readonly());\n+    check!(fs::set_permissions(&input, attr.permissions()));\n+    check!(fs::set_permissions(&out, attr.permissions()));\n+}\n+\n+#[test]\n+#[cfg(windows)]\n+fn copy_file_preserves_streams() {\n+    let tmp = tmpdir();\n+    check!(check!(File::create(tmp.join(\"in.txt:bunny\"))).write(\"carrot\".as_bytes()));\n+    assert_eq!(check!(fs::copy(tmp.join(\"in.txt\"), tmp.join(\"out.txt\"))), 0);\n+    assert_eq!(check!(tmp.join(\"out.txt\").metadata()).len(), 0);\n+    let mut v = Vec::new();\n+    check!(check!(File::open(tmp.join(\"out.txt:bunny\"))).read_to_end(&mut v));\n+    assert_eq!(v, b\"carrot\".to_vec());\n+}\n+\n+#[test]\n+fn copy_file_returns_metadata_len() {\n+    let tmp = tmpdir();\n+    let in_path = tmp.join(\"in.txt\");\n+    let out_path = tmp.join(\"out.txt\");\n+    check!(check!(File::create(&in_path)).write(b\"lettuce\"));\n+    #[cfg(windows)]\n+    check!(check!(File::create(tmp.join(\"in.txt:bunny\"))).write(b\"carrot\"));\n+    let copied_len = check!(fs::copy(&in_path, &out_path));\n+    assert_eq!(check!(out_path.metadata()).len(), copied_len);\n+}\n+\n+#[test]\n+fn copy_file_follows_dst_symlink() {\n+    let tmp = tmpdir();\n+    if !got_symlink_permission(&tmp) {\n+        return;\n+    };\n+\n+    let in_path = tmp.join(\"in.txt\");\n+    let out_path = tmp.join(\"out.txt\");\n+    let out_path_symlink = tmp.join(\"out_symlink.txt\");\n+\n+    check!(fs::write(&in_path, \"foo\"));\n+    check!(fs::write(&out_path, \"bar\"));\n+    check!(symlink_file(&out_path, &out_path_symlink));\n+\n+    check!(fs::copy(&in_path, &out_path_symlink));\n+\n+    assert!(check!(out_path_symlink.symlink_metadata()).file_type().is_symlink());\n+    assert_eq!(check!(fs::read(&out_path_symlink)), b\"foo\".to_vec());\n+    assert_eq!(check!(fs::read(&out_path)), b\"foo\".to_vec());\n+}\n+\n+#[test]\n+fn symlinks_work() {\n+    let tmpdir = tmpdir();\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+\n+    let input = tmpdir.join(\"in.txt\");\n+    let out = tmpdir.join(\"out.txt\");\n+\n+    check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n+    check!(symlink_file(&input, &out));\n+    assert!(check!(out.symlink_metadata()).file_type().is_symlink());\n+    assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&out)).read_to_end(&mut v));\n+    assert_eq!(v, b\"foobar\".to_vec());\n+}\n+\n+#[test]\n+fn symlink_noexist() {\n+    // Symlinks can point to things that don't exist\n+    let tmpdir = tmpdir();\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+\n+    // Use a relative path for testing. Symlinks get normalized by Windows,\n+    // so we may not get the same path back for absolute paths\n+    check!(symlink_file(&\"foo\", &tmpdir.join(\"bar\")));\n+    assert_eq!(check!(fs::read_link(&tmpdir.join(\"bar\"))).to_str().unwrap(), \"foo\");\n+}\n+\n+#[test]\n+fn read_link() {\n+    if cfg!(windows) {\n+        // directory symlink\n+        assert_eq!(\n+            check!(fs::read_link(r\"C:\\Users\\All Users\")).to_str().unwrap(),\n+            r\"C:\\ProgramData\"\n+        );\n+        // junction\n+        assert_eq!(\n+            check!(fs::read_link(r\"C:\\Users\\Default User\")).to_str().unwrap(),\n+            r\"C:\\Users\\Default\"\n+        );\n+        // junction with special permissions\n+        assert_eq!(\n+            check!(fs::read_link(r\"C:\\Documents and Settings\\\")).to_str().unwrap(),\n+            r\"C:\\Users\"\n+        );\n+    }\n+    let tmpdir = tmpdir();\n+    let link = tmpdir.join(\"link\");\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+    check!(symlink_file(&\"foo\", &link));\n+    assert_eq!(check!(fs::read_link(&link)).to_str().unwrap(), \"foo\");\n+}\n+\n+#[test]\n+fn readlink_not_symlink() {\n+    let tmpdir = tmpdir();\n+    match fs::read_link(tmpdir.path()) {\n+        Ok(..) => panic!(\"wanted a failure\"),\n+        Err(..) => {}\n+    }\n+}\n+\n+#[test]\n+fn links_work() {\n+    let tmpdir = tmpdir();\n+    let input = tmpdir.join(\"in.txt\");\n+    let out = tmpdir.join(\"out.txt\");\n+\n+    check!(check!(File::create(&input)).write(\"foobar\".as_bytes()));\n+    check!(fs::hard_link(&input, &out));\n+    assert_eq!(check!(fs::metadata(&out)).len(), check!(fs::metadata(&input)).len());\n+    assert_eq!(check!(fs::metadata(&out)).len(), check!(input.metadata()).len());\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&out)).read_to_end(&mut v));\n+    assert_eq!(v, b\"foobar\".to_vec());\n+\n+    // can't link to yourself\n+    match fs::hard_link(&input, &input) {\n+        Ok(..) => panic!(\"wanted a failure\"),\n+        Err(..) => {}\n+    }\n+    // can't link to something that doesn't exist\n+    match fs::hard_link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n+        Ok(..) => panic!(\"wanted a failure\"),\n+        Err(..) => {}\n+    }\n+}\n+\n+#[test]\n+fn chmod_works() {\n+    let tmpdir = tmpdir();\n+    let file = tmpdir.join(\"in.txt\");\n+\n+    check!(File::create(&file));\n+    let attr = check!(fs::metadata(&file));\n+    assert!(!attr.permissions().readonly());\n+    let mut p = attr.permissions();\n+    p.set_readonly(true);\n+    check!(fs::set_permissions(&file, p.clone()));\n+    let attr = check!(fs::metadata(&file));\n+    assert!(attr.permissions().readonly());\n+\n+    match fs::set_permissions(&tmpdir.join(\"foo\"), p.clone()) {\n+        Ok(..) => panic!(\"wanted an error\"),\n+        Err(..) => {}\n+    }\n+\n+    p.set_readonly(false);\n+    check!(fs::set_permissions(&file, p));\n+}\n+\n+#[test]\n+fn fchmod_works() {\n+    let tmpdir = tmpdir();\n+    let path = tmpdir.join(\"in.txt\");\n+\n+    let file = check!(File::create(&path));\n+    let attr = check!(fs::metadata(&path));\n+    assert!(!attr.permissions().readonly());\n+    let mut p = attr.permissions();\n+    p.set_readonly(true);\n+    check!(file.set_permissions(p.clone()));\n+    let attr = check!(fs::metadata(&path));\n+    assert!(attr.permissions().readonly());\n+\n+    p.set_readonly(false);\n+    check!(file.set_permissions(p));\n+}\n+\n+#[test]\n+fn sync_doesnt_kill_anything() {\n+    let tmpdir = tmpdir();\n+    let path = tmpdir.join(\"in.txt\");\n+\n+    let mut file = check!(File::create(&path));\n+    check!(file.sync_all());\n+    check!(file.sync_data());\n+    check!(file.write(b\"foo\"));\n+    check!(file.sync_all());\n+    check!(file.sync_data());\n+}\n+\n+#[test]\n+fn truncate_works() {\n+    let tmpdir = tmpdir();\n+    let path = tmpdir.join(\"in.txt\");\n+\n+    let mut file = check!(File::create(&path));\n+    check!(file.write(b\"foo\"));\n+    check!(file.sync_all());\n+\n+    // Do some simple things with truncation\n+    assert_eq!(check!(file.metadata()).len(), 3);\n+    check!(file.set_len(10));\n+    assert_eq!(check!(file.metadata()).len(), 10);\n+    check!(file.write(b\"bar\"));\n+    check!(file.sync_all());\n+    assert_eq!(check!(file.metadata()).len(), 10);\n+\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&path)).read_to_end(&mut v));\n+    assert_eq!(v, b\"foobar\\0\\0\\0\\0\".to_vec());\n+\n+    // Truncate to a smaller length, don't seek, and then write something.\n+    // Ensure that the intermediate zeroes are all filled in (we have `seek`ed\n+    // past the end of the file).\n+    check!(file.set_len(2));\n+    assert_eq!(check!(file.metadata()).len(), 2);\n+    check!(file.write(b\"wut\"));\n+    check!(file.sync_all());\n+    assert_eq!(check!(file.metadata()).len(), 9);\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&path)).read_to_end(&mut v));\n+    assert_eq!(v, b\"fo\\0\\0\\0\\0wut\".to_vec());\n+}\n+\n+#[test]\n+fn open_flavors() {\n+    use crate::fs::OpenOptions as OO;\n+    fn c<T: Clone>(t: &T) -> T {\n+        t.clone()\n+    }\n+\n+    let tmpdir = tmpdir();\n+\n+    let mut r = OO::new();\n+    r.read(true);\n+    let mut w = OO::new();\n+    w.write(true);\n+    let mut rw = OO::new();\n+    rw.read(true).write(true);\n+    let mut a = OO::new();\n+    a.append(true);\n+    let mut ra = OO::new();\n+    ra.read(true).append(true);\n+\n+    #[cfg(windows)]\n+    let invalid_options = 87; // ERROR_INVALID_PARAMETER\n+    #[cfg(all(unix, not(target_os = \"vxworks\")))]\n+    let invalid_options = \"Invalid argument\";\n+    #[cfg(target_os = \"vxworks\")]\n+    let invalid_options = \"invalid argument\";\n+\n+    // Test various combinations of creation modes and access modes.\n+    //\n+    // Allowed:\n+    // creation mode           | read  | write | read-write | append | read-append |\n+    // :-----------------------|:-----:|:-----:|:----------:|:------:|:-----------:|\n+    // not set (open existing) |   X   |   X   |     X      |   X    |      X      |\n+    // create                  |       |   X   |     X      |   X    |      X      |\n+    // truncate                |       |   X   |     X      |        |             |\n+    // create and truncate     |       |   X   |     X      |        |             |\n+    // create_new              |       |   X   |     X      |   X    |      X      |\n+    //\n+    // tested in reverse order, so 'create_new' creates the file, and 'open existing' opens it.\n+\n+    // write-only\n+    check!(c(&w).create_new(true).open(&tmpdir.join(\"a\")));\n+    check!(c(&w).create(true).truncate(true).open(&tmpdir.join(\"a\")));\n+    check!(c(&w).truncate(true).open(&tmpdir.join(\"a\")));\n+    check!(c(&w).create(true).open(&tmpdir.join(\"a\")));\n+    check!(c(&w).open(&tmpdir.join(\"a\")));\n+\n+    // read-only\n+    error!(c(&r).create_new(true).open(&tmpdir.join(\"b\")), invalid_options);\n+    error!(c(&r).create(true).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+    error!(c(&r).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+    error!(c(&r).create(true).open(&tmpdir.join(\"b\")), invalid_options);\n+    check!(c(&r).open(&tmpdir.join(\"a\"))); // try opening the file created with write_only\n+\n+    // read-write\n+    check!(c(&rw).create_new(true).open(&tmpdir.join(\"c\")));\n+    check!(c(&rw).create(true).truncate(true).open(&tmpdir.join(\"c\")));\n+    check!(c(&rw).truncate(true).open(&tmpdir.join(\"c\")));\n+    check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n+    check!(c(&rw).open(&tmpdir.join(\"c\")));\n+\n+    // append\n+    check!(c(&a).create_new(true).open(&tmpdir.join(\"d\")));\n+    error!(c(&a).create(true).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+    error!(c(&a).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+    check!(c(&a).create(true).open(&tmpdir.join(\"d\")));\n+    check!(c(&a).open(&tmpdir.join(\"d\")));\n+\n+    // read-append\n+    check!(c(&ra).create_new(true).open(&tmpdir.join(\"e\")));\n+    error!(c(&ra).create(true).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+    error!(c(&ra).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+    check!(c(&ra).create(true).open(&tmpdir.join(\"e\")));\n+    check!(c(&ra).open(&tmpdir.join(\"e\")));\n+\n+    // Test opening a file without setting an access mode\n+    let mut blank = OO::new();\n+    error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n+\n+    // Test write works\n+    check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n+\n+    // Test write fails for read-only\n+    check!(r.open(&tmpdir.join(\"h\")));\n+    {\n+        let mut f = check!(r.open(&tmpdir.join(\"h\")));\n+        assert!(f.write(\"wut\".as_bytes()).is_err());\n+    }\n+\n+    // Test write overwrites\n+    {\n+        let mut f = check!(c(&w).open(&tmpdir.join(\"h\")));\n+        check!(f.write(\"baz\".as_bytes()));\n+    }\n+    {\n+        let mut f = check!(c(&r).open(&tmpdir.join(\"h\")));\n+        let mut b = vec![0; 6];\n+        check!(f.read(&mut b));\n+        assert_eq!(b, \"bazbar\".as_bytes());\n+    }\n+\n+    // Test truncate works\n+    {\n+        let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n+        check!(f.write(\"foo\".as_bytes()));\n+    }\n+    assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+\n+    // Test append works\n+    assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+    {\n+        let mut f = check!(c(&a).open(&tmpdir.join(\"h\")));\n+        check!(f.write(\"bar\".as_bytes()));\n+    }\n+    assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 6);\n+\n+    // Test .append(true) equals .write(true).append(true)\n+    {\n+        let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+        check!(f.write(\"baz\".as_bytes()));\n+    }\n+    assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 9);\n+}\n+\n+#[test]\n+fn _assert_send_sync() {\n+    fn _assert_send_sync<T: Send + Sync>() {}\n+    _assert_send_sync::<OpenOptions>();\n+}\n+\n+#[test]\n+fn binary_file() {\n+    let mut bytes = [0; 1024];\n+    StdRng::from_entropy().fill_bytes(&mut bytes);\n+\n+    let tmpdir = tmpdir();\n+\n+    check!(check!(File::create(&tmpdir.join(\"test\"))).write(&bytes));\n+    let mut v = Vec::new();\n+    check!(check!(File::open(&tmpdir.join(\"test\"))).read_to_end(&mut v));\n+    assert!(v == &bytes[..]);\n+}\n+\n+#[test]\n+fn write_then_read() {\n+    let mut bytes = [0; 1024];\n+    StdRng::from_entropy().fill_bytes(&mut bytes);\n+\n+    let tmpdir = tmpdir();\n+\n+    check!(fs::write(&tmpdir.join(\"test\"), &bytes[..]));\n+    let v = check!(fs::read(&tmpdir.join(\"test\")));\n+    assert!(v == &bytes[..]);\n+\n+    check!(fs::write(&tmpdir.join(\"not-utf8\"), &[0xFF]));\n+    error_contains!(\n+        fs::read_to_string(&tmpdir.join(\"not-utf8\")),\n+        \"stream did not contain valid UTF-8\"\n+    );\n+\n+    let s = \"\ud800\udc41\ud800\udc13\ud800\udc20\ud800\udc34\ud800\udc0d\";\n+    check!(fs::write(&tmpdir.join(\"utf8\"), s.as_bytes()));\n+    let string = check!(fs::read_to_string(&tmpdir.join(\"utf8\")));\n+    assert_eq!(string, s);\n+}\n+\n+#[test]\n+fn file_try_clone() {\n+    let tmpdir = tmpdir();\n+\n+    let mut f1 =\n+        check!(OpenOptions::new().read(true).write(true).create(true).open(&tmpdir.join(\"test\")));\n+    let mut f2 = check!(f1.try_clone());\n+\n+    check!(f1.write_all(b\"hello world\"));\n+    check!(f1.seek(SeekFrom::Start(2)));\n+\n+    let mut buf = vec![];\n+    check!(f2.read_to_end(&mut buf));\n+    assert_eq!(buf, b\"llo world\");\n+    drop(f2);\n+\n+    check!(f1.write_all(b\"!\"));\n+}\n+\n+#[test]\n+#[cfg(not(windows))]\n+fn unlink_readonly() {\n+    let tmpdir = tmpdir();\n+    let path = tmpdir.join(\"file\");\n+    check!(File::create(&path));\n+    let mut perm = check!(fs::metadata(&path)).permissions();\n+    perm.set_readonly(true);\n+    check!(fs::set_permissions(&path, perm));\n+    check!(fs::remove_file(&path));\n+}\n+\n+#[test]\n+fn mkdir_trailing_slash() {\n+    let tmpdir = tmpdir();\n+    let path = tmpdir.join(\"file\");\n+    check!(fs::create_dir_all(&path.join(\"a/\")));\n+}\n+\n+#[test]\n+fn canonicalize_works_simple() {\n+    let tmpdir = tmpdir();\n+    let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+    let file = tmpdir.join(\"test\");\n+    File::create(&file).unwrap();\n+    assert_eq!(fs::canonicalize(&file).unwrap(), file);\n+}\n+\n+#[test]\n+fn realpath_works() {\n+    let tmpdir = tmpdir();\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+\n+    let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+    let file = tmpdir.join(\"test\");\n+    let dir = tmpdir.join(\"test2\");\n+    let link = dir.join(\"link\");\n+    let linkdir = tmpdir.join(\"test3\");\n+\n+    File::create(&file).unwrap();\n+    fs::create_dir(&dir).unwrap();\n+    symlink_file(&file, &link).unwrap();\n+    symlink_dir(&dir, &linkdir).unwrap();\n+\n+    assert!(link.symlink_metadata().unwrap().file_type().is_symlink());\n+\n+    assert_eq!(fs::canonicalize(&tmpdir).unwrap(), tmpdir);\n+    assert_eq!(fs::canonicalize(&file).unwrap(), file);\n+    assert_eq!(fs::canonicalize(&link).unwrap(), file);\n+    assert_eq!(fs::canonicalize(&linkdir).unwrap(), dir);\n+    assert_eq!(fs::canonicalize(&linkdir.join(\"link\")).unwrap(), file);\n+}\n+\n+#[test]\n+fn realpath_works_tricky() {\n+    let tmpdir = tmpdir();\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+\n+    let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n+    let a = tmpdir.join(\"a\");\n+    let b = a.join(\"b\");\n+    let c = b.join(\"c\");\n+    let d = a.join(\"d\");\n+    let e = d.join(\"e\");\n+    let f = a.join(\"f\");\n+\n+    fs::create_dir_all(&b).unwrap();\n+    fs::create_dir_all(&d).unwrap();\n+    File::create(&f).unwrap();\n+    if cfg!(not(windows)) {\n+        symlink_file(\"../d/e\", &c).unwrap();\n+        symlink_file(\"../f\", &e).unwrap();\n+    }\n+    if cfg!(windows) {\n+        symlink_file(r\"..\\d\\e\", &c).unwrap();\n+        symlink_file(r\"..\\f\", &e).unwrap();\n+    }\n+\n+    assert_eq!(fs::canonicalize(&c).unwrap(), f);\n+    assert_eq!(fs::canonicalize(&e).unwrap(), f);\n+}\n+\n+#[test]\n+fn dir_entry_methods() {\n+    let tmpdir = tmpdir();\n+\n+    fs::create_dir_all(&tmpdir.join(\"a\")).unwrap();\n+    File::create(&tmpdir.join(\"b\")).unwrap();\n+\n+    for file in tmpdir.path().read_dir().unwrap().map(|f| f.unwrap()) {\n+        let fname = file.file_name();\n+        match fname.to_str() {\n+            Some(\"a\") => {\n+                assert!(file.file_type().unwrap().is_dir());\n+                assert!(file.metadata().unwrap().is_dir());\n+            }\n+            Some(\"b\") => {\n+                assert!(file.file_type().unwrap().is_file());\n+                assert!(file.metadata().unwrap().is_file());\n+            }\n+            f => panic!(\"unknown file name: {:?}\", f),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn dir_entry_debug() {\n+    let tmpdir = tmpdir();\n+    File::create(&tmpdir.join(\"b\")).unwrap();\n+    let mut read_dir = tmpdir.path().read_dir().unwrap();\n+    let dir_entry = read_dir.next().unwrap().unwrap();\n+    let actual = format!(\"{:?}\", dir_entry);\n+    let expected = format!(\"DirEntry({:?})\", dir_entry.0.path());\n+    assert_eq!(actual, expected);\n+}\n+\n+#[test]\n+fn read_dir_not_found() {\n+    let res = fs::read_dir(\"/path/that/does/not/exist\");\n+    assert_eq!(res.err().unwrap().kind(), ErrorKind::NotFound);\n+}\n+\n+#[test]\n+fn create_dir_all_with_junctions() {\n+    let tmpdir = tmpdir();\n+    let target = tmpdir.join(\"target\");\n+\n+    let junction = tmpdir.join(\"junction\");\n+    let b = junction.join(\"a/b\");\n+\n+    let link = tmpdir.join(\"link\");\n+    let d = link.join(\"c/d\");\n+\n+    fs::create_dir(&target).unwrap();\n+\n+    check!(symlink_junction(&target, &junction));\n+    check!(fs::create_dir_all(&b));\n+    // the junction itself is not a directory, but `is_dir()` on a Path\n+    // follows links\n+    assert!(junction.is_dir());\n+    assert!(b.exists());\n+\n+    if !got_symlink_permission(&tmpdir) {\n+        return;\n+    };\n+    check!(symlink_dir(&target, &link));\n+    check!(fs::create_dir_all(&d));\n+    assert!(link.is_dir());\n+    assert!(d.exists());\n+}\n+\n+#[test]\n+fn metadata_access_times() {\n+    let tmpdir = tmpdir();\n+\n+    let b = tmpdir.join(\"b\");\n+    File::create(&b).unwrap();\n+\n+    let a = check!(fs::metadata(&tmpdir.path()));\n+    let b = check!(fs::metadata(&b));\n+\n+    assert_eq!(check!(a.accessed()), check!(a.accessed()));\n+    assert_eq!(check!(a.modified()), check!(a.modified()));\n+    assert_eq!(check!(b.accessed()), check!(b.modified()));\n+\n+    if cfg!(target_os = \"macos\") || cfg!(target_os = \"windows\") {\n+        check!(a.created());\n+        check!(b.created());\n+    }\n+\n+    if cfg!(target_os = \"linux\") {\n+        // Not always available\n+        match (a.created(), b.created()) {\n+            (Ok(t1), Ok(t2)) => assert!(t1 <= t2),\n+            (Err(e1), Err(e2))\n+                if e1.kind() == ErrorKind::Other && e2.kind() == ErrorKind::Other => {}\n+            (a, b) => {\n+                panic!(\"creation time must be always supported or not supported: {:?} {:?}\", a, b,)\n+            }\n+        }\n+    }\n+}"}, {"sha": "5ad8f8132e49c8b91ebb897673afad03abab54c5", "filename": "library/std/src/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 920, "changes": 923, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,5 +1,8 @@\n //! Buffering wrappers for I/O traits\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::io::prelude::*;\n \n use crate::cmp;\n@@ -1388,923 +1391,3 @@ where\n             .finish()\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::io::prelude::*;\n-    use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\n-    use crate::sync::atomic::{AtomicUsize, Ordering};\n-    use crate::thread;\n-\n-    /// A dummy reader intended at testing short-reads propagation.\n-    pub struct ShortReader {\n-        lengths: Vec<usize>,\n-    }\n-\n-    // FIXME: rustfmt and tidy disagree about the correct formatting of this\n-    // function. This leads to issues for users with editors configured to\n-    // rustfmt-on-save.\n-    impl Read for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader() {\n-        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n-        let mut reader = BufReader::with_capacity(2, inner);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(nread.unwrap(), 3);\n-        assert_eq!(buf, [5, 6, 7]);\n-        assert_eq!(reader.buffer(), []);\n-\n-        let mut buf = [0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(nread.unwrap(), 2);\n-        assert_eq!(buf, [0, 1]);\n-        assert_eq!(reader.buffer(), []);\n-\n-        let mut buf = [0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(nread.unwrap(), 1);\n-        assert_eq!(buf, [2]);\n-        assert_eq!(reader.buffer(), [3]);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(nread.unwrap(), 1);\n-        assert_eq!(buf, [3, 0, 0]);\n-        assert_eq!(reader.buffer(), []);\n-\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(nread.unwrap(), 1);\n-        assert_eq!(buf, [4, 0, 0]);\n-        assert_eq!(reader.buffer(), []);\n-\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_seek() {\n-        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n-        let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n-\n-        assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n-        assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(3));\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n-        assert_eq!(reader.seek(SeekFrom::Current(1)).ok(), Some(4));\n-        assert_eq!(reader.fill_buf().ok(), Some(&[1, 2][..]));\n-        reader.consume(1);\n-        assert_eq!(reader.seek(SeekFrom::Current(-2)).ok(), Some(3));\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_seek_relative() {\n-        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n-        let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n-\n-        assert!(reader.seek_relative(3).is_ok());\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n-        assert!(reader.seek_relative(0).is_ok());\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n-        assert!(reader.seek_relative(1).is_ok());\n-        assert_eq!(reader.fill_buf().ok(), Some(&[1][..]));\n-        assert!(reader.seek_relative(-1).is_ok());\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n-        assert!(reader.seek_relative(2).is_ok());\n-        assert_eq!(reader.fill_buf().ok(), Some(&[2, 3][..]));\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_invalidated_after_read() {\n-        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n-        let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n-\n-        assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n-        reader.consume(3);\n-\n-        let mut buffer = [0, 0, 0, 0, 0];\n-        assert_eq!(reader.read(&mut buffer).ok(), Some(5));\n-        assert_eq!(buffer, [0, 1, 2, 3, 4]);\n-\n-        assert!(reader.seek_relative(-2).is_ok());\n-        let mut buffer = [0, 0];\n-        assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n-        assert_eq!(buffer, [3, 4]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_invalidated_after_seek() {\n-        let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n-        let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n-\n-        assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n-        reader.consume(3);\n-\n-        assert!(reader.seek(SeekFrom::Current(5)).is_ok());\n-\n-        assert!(reader.seek_relative(-2).is_ok());\n-        let mut buffer = [0, 0];\n-        assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n-        assert_eq!(buffer, [3, 4]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_seek_underflow() {\n-        // gimmick reader that yields its position modulo 256 for each byte\n-        struct PositionReader {\n-            pos: u64,\n-        }\n-        impl Read for PositionReader {\n-            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-                let len = buf.len();\n-                for x in buf {\n-                    *x = self.pos as u8;\n-                    self.pos = self.pos.wrapping_add(1);\n-                }\n-                Ok(len)\n-            }\n-        }\n-        impl Seek for PositionReader {\n-            fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n-                match pos {\n-                    SeekFrom::Start(n) => {\n-                        self.pos = n;\n-                    }\n-                    SeekFrom::Current(n) => {\n-                        self.pos = self.pos.wrapping_add(n as u64);\n-                    }\n-                    SeekFrom::End(n) => {\n-                        self.pos = u64::MAX.wrapping_add(n as u64);\n-                    }\n-                }\n-                Ok(self.pos)\n-            }\n-        }\n-\n-        let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n-        assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n-        assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n-        // the following seek will require two underlying seeks\n-        let expected = 9223372036854775802;\n-        assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n-        assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n-        // seeking to 0 should empty the buffer.\n-        assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n-        assert_eq!(reader.get_ref().pos, expected);\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n-        // gimmick reader that returns Err after first seek\n-        struct ErrAfterFirstSeekReader {\n-            first_seek: bool,\n-        }\n-        impl Read for ErrAfterFirstSeekReader {\n-            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-                for x in &mut *buf {\n-                    *x = 0;\n-                }\n-                Ok(buf.len())\n-            }\n-        }\n-        impl Seek for ErrAfterFirstSeekReader {\n-            fn seek(&mut self, _: SeekFrom) -> io::Result<u64> {\n-                if self.first_seek {\n-                    self.first_seek = false;\n-                    Ok(0)\n-                } else {\n-                    Err(io::Error::new(io::ErrorKind::Other, \"oh no!\"))\n-                }\n-            }\n-        }\n-\n-        let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n-        assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n-\n-        // The following seek will require two underlying seeks.  The first will\n-        // succeed but the second will fail.  This should still invalidate the\n-        // buffer.\n-        assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n-        assert_eq!(reader.buffer().len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer() {\n-        let inner = Vec::new();\n-        let mut writer = BufWriter::with_capacity(2, inner);\n-\n-        writer.write(&[0, 1]).unwrap();\n-        assert_eq!(writer.buffer(), []);\n-        assert_eq!(*writer.get_ref(), [0, 1]);\n-\n-        writer.write(&[2]).unwrap();\n-        assert_eq!(writer.buffer(), [2]);\n-        assert_eq!(*writer.get_ref(), [0, 1]);\n-\n-        writer.write(&[3]).unwrap();\n-        assert_eq!(writer.buffer(), [2, 3]);\n-        assert_eq!(*writer.get_ref(), [0, 1]);\n-\n-        writer.flush().unwrap();\n-        assert_eq!(writer.buffer(), []);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n-\n-        writer.write(&[4]).unwrap();\n-        writer.write(&[5]).unwrap();\n-        assert_eq!(writer.buffer(), [4, 5]);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n-\n-        writer.write(&[6]).unwrap();\n-        assert_eq!(writer.buffer(), [6]);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n-\n-        writer.write(&[7, 8]).unwrap();\n-        assert_eq!(writer.buffer(), []);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n-\n-        writer.write(&[9, 10, 11]).unwrap();\n-        assert_eq!(writer.buffer(), []);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n-\n-        writer.flush().unwrap();\n-        assert_eq!(writer.buffer(), []);\n-        assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer_inner_flushes() {\n-        let mut w = BufWriter::with_capacity(3, Vec::new());\n-        w.write(&[0, 1]).unwrap();\n-        assert_eq!(*w.get_ref(), []);\n-        let w = w.into_inner().unwrap();\n-        assert_eq!(w, [0, 1]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer_seek() {\n-        let mut w = BufWriter::with_capacity(3, io::Cursor::new(Vec::new()));\n-        w.write_all(&[0, 1, 2, 3, 4, 5]).unwrap();\n-        w.write_all(&[6, 7]).unwrap();\n-        assert_eq!(w.seek(SeekFrom::Current(0)).ok(), Some(8));\n-        assert_eq!(&w.get_ref().get_ref()[..], &[0, 1, 2, 3, 4, 5, 6, 7][..]);\n-        assert_eq!(w.seek(SeekFrom::Start(2)).ok(), Some(2));\n-        w.write_all(&[8, 9]).unwrap();\n-        assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n-    }\n-\n-    #[test]\n-    fn test_read_until() {\n-        let inner: &[u8] = &[0, 1, 2, 1, 0];\n-        let mut reader = BufReader::with_capacity(2, inner);\n-        let mut v = Vec::new();\n-        reader.read_until(0, &mut v).unwrap();\n-        assert_eq!(v, [0]);\n-        v.truncate(0);\n-        reader.read_until(2, &mut v).unwrap();\n-        assert_eq!(v, [1, 2]);\n-        v.truncate(0);\n-        reader.read_until(1, &mut v).unwrap();\n-        assert_eq!(v, [1]);\n-        v.truncate(0);\n-        reader.read_until(8, &mut v).unwrap();\n-        assert_eq!(v, [0]);\n-        v.truncate(0);\n-        reader.read_until(9, &mut v).unwrap();\n-        assert_eq!(v, []);\n-    }\n-\n-    #[test]\n-    fn test_line_buffer() {\n-        let mut writer = LineWriter::new(Vec::new());\n-        writer.write(&[0]).unwrap();\n-        assert_eq!(*writer.get_ref(), []);\n-        writer.write(&[1]).unwrap();\n-        assert_eq!(*writer.get_ref(), []);\n-        writer.flush().unwrap();\n-        assert_eq!(*writer.get_ref(), [0, 1]);\n-        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n-        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n-        writer.flush().unwrap();\n-        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n-        writer.write(&[3, b'\\n']).unwrap();\n-        assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n-    }\n-\n-    #[test]\n-    fn test_read_line() {\n-        let in_buf: &[u8] = b\"a\\nb\\nc\";\n-        let mut reader = BufReader::with_capacity(2, in_buf);\n-        let mut s = String::new();\n-        reader.read_line(&mut s).unwrap();\n-        assert_eq!(s, \"a\\n\");\n-        s.truncate(0);\n-        reader.read_line(&mut s).unwrap();\n-        assert_eq!(s, \"b\\n\");\n-        s.truncate(0);\n-        reader.read_line(&mut s).unwrap();\n-        assert_eq!(s, \"c\");\n-        s.truncate(0);\n-        reader.read_line(&mut s).unwrap();\n-        assert_eq!(s, \"\");\n-    }\n-\n-    #[test]\n-    fn test_lines() {\n-        let in_buf: &[u8] = b\"a\\nb\\nc\";\n-        let reader = BufReader::with_capacity(2, in_buf);\n-        let mut it = reader.lines();\n-        assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n-        assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n-        assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n-        assert!(it.next().is_none());\n-    }\n-\n-    #[test]\n-    fn test_short_reads() {\n-        let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n-        let mut reader = BufReader::new(inner);\n-        let mut buf = [0, 0];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 2);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn dont_panic_in_drop_on_panicked_flush() {\n-        struct FailFlushWriter;\n-\n-        impl Write for FailFlushWriter {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-                Ok(buf.len())\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                Err(io::Error::last_os_error())\n-            }\n-        }\n-\n-        let writer = FailFlushWriter;\n-        let _writer = BufWriter::new(writer);\n-\n-        // If writer panics *again* due to the flush error then the process will\n-        // abort.\n-        panic!();\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn panic_in_write_doesnt_flush_in_drop() {\n-        static WRITES: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct PanicWriter;\n-\n-        impl Write for PanicWriter {\n-            fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n-                WRITES.fetch_add(1, Ordering::SeqCst);\n-                panic!();\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                Ok(())\n-            }\n-        }\n-\n-        thread::spawn(|| {\n-            let mut writer = BufWriter::new(PanicWriter);\n-            let _ = writer.write(b\"hello world\");\n-            let _ = writer.flush();\n-        })\n-        .join()\n-        .unwrap_err();\n-\n-        assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_reader(b: &mut test::Bencher) {\n-        b.iter(|| BufReader::new(io::empty()));\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_writer(b: &mut test::Bencher) {\n-        b.iter(|| BufWriter::new(io::sink()));\n-    }\n-\n-    /// A simple `Write` target, designed to be wrapped by `LineWriter` /\n-    /// `BufWriter` / etc, that can have its `write` & `flush` behavior\n-    /// configured\n-    #[derive(Default, Clone)]\n-    struct ProgrammableSink {\n-        // Writes append to this slice\n-        pub buffer: Vec<u8>,\n-\n-        // Flush sets this flag\n-        pub flushed: bool,\n-\n-        // If true, writes will always be an error\n-        pub always_write_error: bool,\n-\n-        // If true, flushes will always be an error\n-        pub always_flush_error: bool,\n-\n-        // If set, only up to this number of bytes will be written in a single\n-        // call to `write`\n-        pub accept_prefix: Option<usize>,\n-\n-        // If set, counts down with each write, and writes return an error\n-        // when it hits 0\n-        pub max_writes: Option<usize>,\n-\n-        // If set, attempting to write when max_writes == Some(0) will be an\n-        // error; otherwise, it will return Ok(0).\n-        pub error_after_max_writes: bool,\n-    }\n-\n-    impl Write for ProgrammableSink {\n-        fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-            if self.always_write_error {\n-                return Err(io::Error::new(io::ErrorKind::Other, \"test - always_write_error\"));\n-            }\n-\n-            match self.max_writes {\n-                Some(0) if self.error_after_max_writes => {\n-                    return Err(io::Error::new(io::ErrorKind::Other, \"test - max_writes\"));\n-                }\n-                Some(0) => return Ok(0),\n-                Some(ref mut count) => *count -= 1,\n-                None => {}\n-            }\n-\n-            let len = match self.accept_prefix {\n-                None => data.len(),\n-                Some(prefix) => data.len().min(prefix),\n-            };\n-\n-            let data = &data[..len];\n-            self.buffer.extend_from_slice(data);\n-\n-            Ok(len)\n-        }\n-\n-        fn flush(&mut self) -> io::Result<()> {\n-            if self.always_flush_error {\n-                Err(io::Error::new(io::ErrorKind::Other, \"test - always_flush_error\"))\n-            } else {\n-                self.flushed = true;\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    /// Previously the `LineWriter` could successfully write some bytes but\n-    /// then fail to report that it has done so. Additionally, an erroneous\n-    /// flush after a successful write was permanently ignored.\n-    ///\n-    /// Test that a line writer correctly reports the number of written bytes,\n-    /// and that it attempts to flush buffered lines from previous writes\n-    /// before processing new data\n-    ///\n-    /// Regression test for #37807\n-    #[test]\n-    fn erroneous_flush_retried() {\n-        let writer = ProgrammableSink {\n-            // Only write up to 4 bytes at a time\n-            accept_prefix: Some(4),\n-\n-            // Accept the first two writes, then error the others\n-            max_writes: Some(2),\n-            error_after_max_writes: true,\n-\n-            ..Default::default()\n-        };\n-\n-        // This should write the first 4 bytes. The rest will be buffered, out\n-        // to the last newline.\n-        let mut writer = LineWriter::new(writer);\n-        assert_eq!(writer.write(b\"a\\nb\\nc\\nd\\ne\").unwrap(), 8);\n-\n-        // This write should attempt to flush \"c\\nd\\n\", then buffer \"e\". No\n-        // errors should happen here because no further writes should be\n-        // attempted against `writer`.\n-        assert_eq!(writer.write(b\"e\").unwrap(), 1);\n-        assert_eq!(&writer.get_ref().buffer, b\"a\\nb\\nc\\nd\\n\");\n-    }\n-\n-    #[test]\n-    fn line_vectored() {\n-        let mut a = LineWriter::new(Vec::new());\n-        assert_eq!(\n-            a.write_vectored(&[\n-                IoSlice::new(&[]),\n-                IoSlice::new(b\"\\n\"),\n-                IoSlice::new(&[]),\n-                IoSlice::new(b\"a\"),\n-            ])\n-            .unwrap(),\n-            2,\n-        );\n-        assert_eq!(a.get_ref(), b\"\\n\");\n-\n-        assert_eq!(\n-            a.write_vectored(&[\n-                IoSlice::new(&[]),\n-                IoSlice::new(b\"b\"),\n-                IoSlice::new(&[]),\n-                IoSlice::new(b\"a\"),\n-                IoSlice::new(&[]),\n-                IoSlice::new(b\"c\"),\n-            ])\n-            .unwrap(),\n-            3,\n-        );\n-        assert_eq!(a.get_ref(), b\"\\n\");\n-        a.flush().unwrap();\n-        assert_eq!(a.get_ref(), b\"\\nabac\");\n-        assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n-        assert_eq!(\n-            a.write_vectored(&[\n-                IoSlice::new(&[]),\n-                IoSlice::new(&[]),\n-                IoSlice::new(&[]),\n-                IoSlice::new(&[]),\n-            ])\n-            .unwrap(),\n-            0,\n-        );\n-        assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n-        assert_eq!(a.get_ref(), b\"\\nabaca\\nb\");\n-    }\n-\n-    #[test]\n-    fn line_vectored_partial_and_errors() {\n-        use crate::collections::VecDeque;\n-\n-        enum Call {\n-            Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n-            Flush { output: io::Result<()> },\n-        }\n-\n-        #[derive(Default)]\n-        struct Writer {\n-            calls: VecDeque<Call>,\n-        }\n-\n-        impl Write for Writer {\n-            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-                self.write_vectored(&[IoSlice::new(buf)])\n-            }\n-\n-            fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n-                match self.calls.pop_front().expect(\"unexpected call to write\") {\n-                    Call::Write { inputs, output } => {\n-                        assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n-                        output\n-                    }\n-                    Call::Flush { .. } => panic!(\"unexpected call to write; expected a flush\"),\n-                }\n-            }\n-\n-            fn is_write_vectored(&self) -> bool {\n-                true\n-            }\n-\n-            fn flush(&mut self) -> io::Result<()> {\n-                match self.calls.pop_front().expect(\"Unexpected call to flush\") {\n-                    Call::Flush { output } => output,\n-                    Call::Write { .. } => panic!(\"unexpected call to flush; expected a write\"),\n-                }\n-            }\n-        }\n-\n-        impl Drop for Writer {\n-            fn drop(&mut self) {\n-                if !thread::panicking() {\n-                    assert_eq!(self.calls.len(), 0);\n-                }\n-            }\n-        }\n-\n-        // partial writes keep going\n-        let mut a = LineWriter::new(Writer::default());\n-        a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n-\n-        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"abc\"], output: Ok(1) });\n-        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"bc\"], output: Ok(2) });\n-        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\n\"], output: Ok(2) });\n-\n-        a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n-\n-        a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n-        a.flush().unwrap();\n-\n-        // erroneous writes stop and don't write more\n-        a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\na\"], output: Err(err()) });\n-        a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n-        assert!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).is_err());\n-        a.flush().unwrap();\n-\n-        fn err() -> io::Error {\n-            io::Error::new(io::ErrorKind::Other, \"x\")\n-        }\n-    }\n-\n-    /// Test that, in cases where vectored writing is not enabled, the\n-    /// LineWriter uses the normal `write` call, which more-correctly handles\n-    /// partial lines\n-    #[test]\n-    fn line_vectored_ignored() {\n-        let writer = ProgrammableSink::default();\n-        let mut writer = LineWriter::new(writer);\n-\n-        let content = [\n-            IoSlice::new(&[]),\n-            IoSlice::new(b\"Line 1\\nLine\"),\n-            IoSlice::new(b\" 2\\nLine 3\\nL\"),\n-            IoSlice::new(&[]),\n-            IoSlice::new(&[]),\n-            IoSlice::new(b\"ine 4\"),\n-            IoSlice::new(b\"\\nLine 5\\n\"),\n-        ];\n-\n-        let count = writer.write_vectored(&content).unwrap();\n-        assert_eq!(count, 11);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n-\n-        let count = writer.write_vectored(&content[2..]).unwrap();\n-        assert_eq!(count, 11);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n-\n-        let count = writer.write_vectored(&content[5..]).unwrap();\n-        assert_eq!(count, 5);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n-\n-        let count = writer.write_vectored(&content[6..]).unwrap();\n-        assert_eq!(count, 8);\n-        assert_eq!(\n-            writer.get_ref().buffer.as_slice(),\n-            b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\".as_ref()\n-        );\n-    }\n-\n-    /// Test that, given this input:\n-    ///\n-    /// Line 1\\n\n-    /// Line 2\\n\n-    /// Line 3\\n\n-    /// Line 4\n-    ///\n-    /// And given a result that only writes to midway through Line 2\n-    ///\n-    /// That only up to the end of Line 3 is buffered\n-    ///\n-    /// This behavior is desirable because it prevents flushing partial lines\n-    #[test]\n-    fn partial_write_buffers_line() {\n-        let writer = ProgrammableSink { accept_prefix: Some(13), ..Default::default() };\n-        let mut writer = LineWriter::new(writer);\n-\n-        assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\\nLine4\").unwrap(), 21);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\");\n-\n-        assert_eq!(writer.write(b\"Line 4\").unwrap(), 6);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n-    }\n-\n-    /// Test that, given this input:\n-    ///\n-    /// Line 1\\n\n-    /// Line 2\\n\n-    /// Line 3\n-    ///\n-    /// And given that the full write of lines 1 and 2 was successful\n-    /// That data up to Line 3 is buffered\n-    #[test]\n-    fn partial_line_buffered_after_line_write() {\n-        let writer = ProgrammableSink::default();\n-        let mut writer = LineWriter::new(writer);\n-\n-        assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\").unwrap(), 20);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\n\");\n-\n-        assert!(writer.flush().is_ok());\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n-    }\n-\n-    /// Test that, given a partial line that exceeds the length of\n-    /// LineBuffer's buffer (that is, without a trailing newline), that that\n-    /// line is written to the inner writer\n-    #[test]\n-    fn long_line_flushed() {\n-        let writer = ProgrammableSink::default();\n-        let mut writer = LineWriter::with_capacity(5, writer);\n-\n-        assert_eq!(writer.write(b\"0123456789\").unwrap(), 10);\n-        assert_eq!(&writer.get_ref().buffer, b\"0123456789\");\n-    }\n-\n-    /// Test that, given a very long partial line *after* successfully\n-    /// flushing a complete line, that that line is buffered unconditionally,\n-    /// and no additional writes take place. This assures the property that\n-    /// `write` should make at-most-one attempt to write new data.\n-    #[test]\n-    fn line_long_tail_not_flushed() {\n-        let writer = ProgrammableSink::default();\n-        let mut writer = LineWriter::with_capacity(5, writer);\n-\n-        // Assert that Line 1\\n is flushed, and 01234 is buffered\n-        assert_eq!(writer.write(b\"Line 1\\n0123456789\").unwrap(), 12);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n-\n-        // Because the buffer is full, this subsequent write will flush it\n-        assert_eq!(writer.write(b\"5\").unwrap(), 1);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n01234\");\n-    }\n-\n-    /// Test that, if an attempt to pre-flush buffered data returns Ok(0),\n-    /// this is propagated as an error.\n-    #[test]\n-    fn line_buffer_write0_error() {\n-        let writer = ProgrammableSink {\n-            // Accept one write, then return Ok(0) on subsequent ones\n-            max_writes: Some(1),\n-\n-            ..Default::default()\n-        };\n-        let mut writer = LineWriter::new(writer);\n-\n-        // This should write \"Line 1\\n\" and buffer \"Partial\"\n-        assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n-\n-        // This will attempt to flush \"partial\", which will return Ok(0), which\n-        // needs to be an error, because we've already informed the client\n-        // that we accepted the write.\n-        let err = writer.write(b\" Line End\\n\").unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::WriteZero);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n-    }\n-\n-    /// Test that, if a write returns Ok(0) after a successful pre-flush, this\n-    /// is propagated as Ok(0)\n-    #[test]\n-    fn line_buffer_write0_normal() {\n-        let writer = ProgrammableSink {\n-            // Accept two writes, then return Ok(0) on subsequent ones\n-            max_writes: Some(2),\n-\n-            ..Default::default()\n-        };\n-        let mut writer = LineWriter::new(writer);\n-\n-        // This should write \"Line 1\\n\" and buffer \"Partial\"\n-        assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n-\n-        // This will flush partial, which will succeed, but then return Ok(0)\n-        // when flushing \" Line End\\n\"\n-        assert_eq!(writer.write(b\" Line End\\n\").unwrap(), 0);\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nPartial\");\n-    }\n-\n-    /// LineWriter has a custom `write_all`; make sure it works correctly\n-    #[test]\n-    fn line_write_all() {\n-        let writer = ProgrammableSink {\n-            // Only write 5 bytes at a time\n-            accept_prefix: Some(5),\n-            ..Default::default()\n-        };\n-        let mut writer = LineWriter::new(writer);\n-\n-        writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\").unwrap();\n-        assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\n\");\n-        writer.write_all(b\" Line 5\\n\").unwrap();\n-        assert_eq!(\n-            writer.get_ref().buffer.as_slice(),\n-            b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial Line 5\\n\".as_ref(),\n-        );\n-    }\n-\n-    #[test]\n-    fn line_write_all_error() {\n-        let writer = ProgrammableSink {\n-            // Only accept up to 3 writes of up to 5 bytes each\n-            accept_prefix: Some(5),\n-            max_writes: Some(3),\n-            ..Default::default()\n-        };\n-\n-        let mut writer = LineWriter::new(writer);\n-        let res = writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\");\n-        assert!(res.is_err());\n-        // An error from write_all leaves everything in an indeterminate state,\n-        // so there's nothing else to test here\n-    }\n-\n-    /// Under certain circumstances, the old implementation of LineWriter\n-    /// would try to buffer \"to the last newline\" but be forced to buffer\n-    /// less than that, leading to inappropriate partial line writes.\n-    /// Regression test for that issue.\n-    #[test]\n-    fn partial_multiline_buffering() {\n-        let writer = ProgrammableSink {\n-            // Write only up to 5 bytes at a time\n-            accept_prefix: Some(5),\n-            ..Default::default()\n-        };\n-\n-        let mut writer = LineWriter::with_capacity(10, writer);\n-\n-        let content = b\"AAAAABBBBB\\nCCCCDDDDDD\\nEEE\";\n-\n-        // When content is written, LineWriter will try to write blocks A, B,\n-        // C, and D. Only block A will succeed. Under the old behavior, LineWriter\n-        // would then try to buffer B, C and D, but because its capacity is 10,\n-        // it will only be able to buffer B and C. We don't want to buffer\n-        // partial lines concurrent with whole lines, so the correct behavior\n-        // is to buffer only block B (out to the newline)\n-        assert_eq!(writer.write(content).unwrap(), 11);\n-        assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n-\n-        writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\\n\");\n-    }\n-\n-    /// Same as test_partial_multiline_buffering, but in the event NO full lines\n-    /// fit in the buffer, just buffer as much as possible\n-    #[test]\n-    fn partial_multiline_buffering_without_full_line() {\n-        let writer = ProgrammableSink {\n-            // Write only up to 5 bytes at a time\n-            accept_prefix: Some(5),\n-            ..Default::default()\n-        };\n-\n-        let mut writer = LineWriter::with_capacity(5, writer);\n-\n-        let content = b\"AAAAABBBBBBBBBB\\nCCCCC\\nDDDDD\";\n-\n-        // When content is written, LineWriter will try to write blocks A, B,\n-        // and C. Only block A will succeed. Under the old behavior, LineWriter\n-        // would then try to buffer B and C, but because its capacity is 5,\n-        // it will only be able to buffer part of B. Because it's not possible\n-        // for it to buffer any complete lines, it should buffer as much of B as\n-        // possible\n-        assert_eq!(writer.write(content).unwrap(), 10);\n-        assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n-\n-        writer.flush().unwrap();\n-        assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n-    }\n-\n-    #[derive(Debug, Clone, PartialEq, Eq)]\n-    enum RecordedEvent {\n-        Write(String),\n-        Flush,\n-    }\n-\n-    #[derive(Debug, Clone, Default)]\n-    struct WriteRecorder {\n-        pub events: Vec<RecordedEvent>,\n-    }\n-\n-    impl Write for WriteRecorder {\n-        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-            use crate::str::from_utf8;\n-\n-            self.events.push(RecordedEvent::Write(from_utf8(buf).unwrap().to_string()));\n-            Ok(buf.len())\n-        }\n-\n-        fn flush(&mut self) -> io::Result<()> {\n-            self.events.push(RecordedEvent::Flush);\n-            Ok(())\n-        }\n-    }\n-\n-    /// Test that a normal, formatted writeln only results in a single write\n-    /// call to the underlying writer. A naive implementation of\n-    /// LineWriter::write_all results in two writes: one of the buffered data,\n-    /// and another of the final substring in the formatted set\n-    #[test]\n-    fn single_formatted_write() {\n-        let writer = WriteRecorder::default();\n-        let mut writer = LineWriter::new(writer);\n-\n-        // Under a naive implementation of LineWriter, this will result in two\n-        // writes: \"hello, world\" and \"!\\n\", because write() has to flush the\n-        // buffer before attempting to write the last \"!\\n\". write_all shouldn't\n-        // have this limitation.\n-        writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n-        assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n-    }\n-}"}, {"sha": "1cd02ee299a9b37bfeb98cdc0eae0f1a44ad96f6", "filename": "library/std/src/io/buffered/tests.rs", "status": "added", "additions": 916, "deletions": 0, "changes": 916, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,916 @@\n+use crate::io::prelude::*;\n+use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::thread;\n+\n+/// A dummy reader intended at testing short-reads propagation.\n+pub struct ShortReader {\n+    lengths: Vec<usize>,\n+}\n+\n+// FIXME: rustfmt and tidy disagree about the correct formatting of this\n+// function. This leads to issues for users with editors configured to\n+// rustfmt-on-save.\n+impl Read for ShortReader {\n+    fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n+        if self.lengths.is_empty() { Ok(0) } else { Ok(self.lengths.remove(0)) }\n+    }\n+}\n+\n+#[test]\n+fn test_buffered_reader() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(2, inner);\n+\n+    let mut buf = [0, 0, 0];\n+    let nread = reader.read(&mut buf);\n+    assert_eq!(nread.unwrap(), 3);\n+    assert_eq!(buf, [5, 6, 7]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    let mut buf = [0, 0];\n+    let nread = reader.read(&mut buf);\n+    assert_eq!(nread.unwrap(), 2);\n+    assert_eq!(buf, [0, 1]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    let mut buf = [0];\n+    let nread = reader.read(&mut buf);\n+    assert_eq!(nread.unwrap(), 1);\n+    assert_eq!(buf, [2]);\n+    assert_eq!(reader.buffer(), [3]);\n+\n+    let mut buf = [0, 0, 0];\n+    let nread = reader.read(&mut buf);\n+    assert_eq!(nread.unwrap(), 1);\n+    assert_eq!(buf, [3, 0, 0]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    let nread = reader.read(&mut buf);\n+    assert_eq!(nread.unwrap(), 1);\n+    assert_eq!(buf, [4, 0, 0]);\n+    assert_eq!(reader.buffer(), []);\n+\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_buffered_reader_seek() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n+\n+    assert_eq!(reader.seek(SeekFrom::Start(3)).ok(), Some(3));\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n+    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(3));\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n+    assert_eq!(reader.seek(SeekFrom::Current(1)).ok(), Some(4));\n+    assert_eq!(reader.fill_buf().ok(), Some(&[1, 2][..]));\n+    reader.consume(1);\n+    assert_eq!(reader.seek(SeekFrom::Current(-2)).ok(), Some(3));\n+}\n+\n+#[test]\n+fn test_buffered_reader_seek_relative() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(2, io::Cursor::new(inner));\n+\n+    assert!(reader.seek_relative(3).is_ok());\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n+    assert!(reader.seek_relative(0).is_ok());\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n+    assert!(reader.seek_relative(1).is_ok());\n+    assert_eq!(reader.fill_buf().ok(), Some(&[1][..]));\n+    assert!(reader.seek_relative(-1).is_ok());\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1][..]));\n+    assert!(reader.seek_relative(2).is_ok());\n+    assert_eq!(reader.fill_buf().ok(), Some(&[2, 3][..]));\n+}\n+\n+#[test]\n+fn test_buffered_reader_invalidated_after_read() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n+\n+    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n+    reader.consume(3);\n+\n+    let mut buffer = [0, 0, 0, 0, 0];\n+    assert_eq!(reader.read(&mut buffer).ok(), Some(5));\n+    assert_eq!(buffer, [0, 1, 2, 3, 4]);\n+\n+    assert!(reader.seek_relative(-2).is_ok());\n+    let mut buffer = [0, 0];\n+    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n+    assert_eq!(buffer, [3, 4]);\n+}\n+\n+#[test]\n+fn test_buffered_reader_invalidated_after_seek() {\n+    let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n+    let mut reader = BufReader::with_capacity(3, io::Cursor::new(inner));\n+\n+    assert_eq!(reader.fill_buf().ok(), Some(&[5, 6, 7][..]));\n+    reader.consume(3);\n+\n+    assert!(reader.seek(SeekFrom::Current(5)).is_ok());\n+\n+    assert!(reader.seek_relative(-2).is_ok());\n+    let mut buffer = [0, 0];\n+    assert_eq!(reader.read(&mut buffer).ok(), Some(2));\n+    assert_eq!(buffer, [3, 4]);\n+}\n+\n+#[test]\n+fn test_buffered_reader_seek_underflow() {\n+    // gimmick reader that yields its position modulo 256 for each byte\n+    struct PositionReader {\n+        pos: u64,\n+    }\n+    impl Read for PositionReader {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = buf.len();\n+            for x in buf {\n+                *x = self.pos as u8;\n+                self.pos = self.pos.wrapping_add(1);\n+            }\n+            Ok(len)\n+        }\n+    }\n+    impl Seek for PositionReader {\n+        fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n+            match pos {\n+                SeekFrom::Start(n) => {\n+                    self.pos = n;\n+                }\n+                SeekFrom::Current(n) => {\n+                    self.pos = self.pos.wrapping_add(n as u64);\n+                }\n+                SeekFrom::End(n) => {\n+                    self.pos = u64::MAX.wrapping_add(n as u64);\n+                }\n+            }\n+            Ok(self.pos)\n+        }\n+    }\n+\n+    let mut reader = BufReader::with_capacity(5, PositionReader { pos: 0 });\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2, 3, 4][..]));\n+    assert_eq!(reader.seek(SeekFrom::End(-5)).ok(), Some(u64::MAX - 5));\n+    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n+    // the following seek will require two underlying seeks\n+    let expected = 9223372036854775802;\n+    assert_eq!(reader.seek(SeekFrom::Current(i64::MIN)).ok(), Some(expected));\n+    assert_eq!(reader.fill_buf().ok().map(|s| s.len()), Some(5));\n+    // seeking to 0 should empty the buffer.\n+    assert_eq!(reader.seek(SeekFrom::Current(0)).ok(), Some(expected));\n+    assert_eq!(reader.get_ref().pos, expected);\n+}\n+\n+#[test]\n+fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n+    // gimmick reader that returns Err after first seek\n+    struct ErrAfterFirstSeekReader {\n+        first_seek: bool,\n+    }\n+    impl Read for ErrAfterFirstSeekReader {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            for x in &mut *buf {\n+                *x = 0;\n+            }\n+            Ok(buf.len())\n+        }\n+    }\n+    impl Seek for ErrAfterFirstSeekReader {\n+        fn seek(&mut self, _: SeekFrom) -> io::Result<u64> {\n+            if self.first_seek {\n+                self.first_seek = false;\n+                Ok(0)\n+            } else {\n+                Err(io::Error::new(io::ErrorKind::Other, \"oh no!\"))\n+            }\n+        }\n+    }\n+\n+    let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n+\n+    // The following seek will require two underlying seeks.  The first will\n+    // succeed but the second will fail.  This should still invalidate the\n+    // buffer.\n+    assert!(reader.seek(SeekFrom::Current(i64::MIN)).is_err());\n+    assert_eq!(reader.buffer().len(), 0);\n+}\n+\n+#[test]\n+fn test_buffered_writer() {\n+    let inner = Vec::new();\n+    let mut writer = BufWriter::with_capacity(2, inner);\n+\n+    writer.write(&[0, 1]).unwrap();\n+    assert_eq!(writer.buffer(), []);\n+    assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+    writer.write(&[2]).unwrap();\n+    assert_eq!(writer.buffer(), [2]);\n+    assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+    writer.write(&[3]).unwrap();\n+    assert_eq!(writer.buffer(), [2, 3]);\n+    assert_eq!(*writer.get_ref(), [0, 1]);\n+\n+    writer.flush().unwrap();\n+    assert_eq!(writer.buffer(), []);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+    writer.write(&[4]).unwrap();\n+    writer.write(&[5]).unwrap();\n+    assert_eq!(writer.buffer(), [4, 5]);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3]);\n+\n+    writer.write(&[6]).unwrap();\n+    assert_eq!(writer.buffer(), [6]);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5]);\n+\n+    writer.write(&[7, 8]).unwrap();\n+    assert_eq!(writer.buffer(), []);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8]);\n+\n+    writer.write(&[9, 10, 11]).unwrap();\n+    assert_eq!(writer.buffer(), []);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+\n+    writer.flush().unwrap();\n+    assert_eq!(writer.buffer(), []);\n+    assert_eq!(*writer.get_ref(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n+}\n+\n+#[test]\n+fn test_buffered_writer_inner_flushes() {\n+    let mut w = BufWriter::with_capacity(3, Vec::new());\n+    w.write(&[0, 1]).unwrap();\n+    assert_eq!(*w.get_ref(), []);\n+    let w = w.into_inner().unwrap();\n+    assert_eq!(w, [0, 1]);\n+}\n+\n+#[test]\n+fn test_buffered_writer_seek() {\n+    let mut w = BufWriter::with_capacity(3, io::Cursor::new(Vec::new()));\n+    w.write_all(&[0, 1, 2, 3, 4, 5]).unwrap();\n+    w.write_all(&[6, 7]).unwrap();\n+    assert_eq!(w.seek(SeekFrom::Current(0)).ok(), Some(8));\n+    assert_eq!(&w.get_ref().get_ref()[..], &[0, 1, 2, 3, 4, 5, 6, 7][..]);\n+    assert_eq!(w.seek(SeekFrom::Start(2)).ok(), Some(2));\n+    w.write_all(&[8, 9]).unwrap();\n+    assert_eq!(&w.into_inner().unwrap().into_inner()[..], &[0, 1, 8, 9, 4, 5, 6, 7]);\n+}\n+\n+#[test]\n+fn test_read_until() {\n+    let inner: &[u8] = &[0, 1, 2, 1, 0];\n+    let mut reader = BufReader::with_capacity(2, inner);\n+    let mut v = Vec::new();\n+    reader.read_until(0, &mut v).unwrap();\n+    assert_eq!(v, [0]);\n+    v.truncate(0);\n+    reader.read_until(2, &mut v).unwrap();\n+    assert_eq!(v, [1, 2]);\n+    v.truncate(0);\n+    reader.read_until(1, &mut v).unwrap();\n+    assert_eq!(v, [1]);\n+    v.truncate(0);\n+    reader.read_until(8, &mut v).unwrap();\n+    assert_eq!(v, [0]);\n+    v.truncate(0);\n+    reader.read_until(9, &mut v).unwrap();\n+    assert_eq!(v, []);\n+}\n+\n+#[test]\n+fn test_line_buffer() {\n+    let mut writer = LineWriter::new(Vec::new());\n+    writer.write(&[0]).unwrap();\n+    assert_eq!(*writer.get_ref(), []);\n+    writer.write(&[1]).unwrap();\n+    assert_eq!(*writer.get_ref(), []);\n+    writer.flush().unwrap();\n+    assert_eq!(*writer.get_ref(), [0, 1]);\n+    writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n+    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n']);\n+    writer.flush().unwrap();\n+    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2]);\n+    writer.write(&[3, b'\\n']).unwrap();\n+    assert_eq!(*writer.get_ref(), [0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n']);\n+}\n+\n+#[test]\n+fn test_read_line() {\n+    let in_buf: &[u8] = b\"a\\nb\\nc\";\n+    let mut reader = BufReader::with_capacity(2, in_buf);\n+    let mut s = String::new();\n+    reader.read_line(&mut s).unwrap();\n+    assert_eq!(s, \"a\\n\");\n+    s.truncate(0);\n+    reader.read_line(&mut s).unwrap();\n+    assert_eq!(s, \"b\\n\");\n+    s.truncate(0);\n+    reader.read_line(&mut s).unwrap();\n+    assert_eq!(s, \"c\");\n+    s.truncate(0);\n+    reader.read_line(&mut s).unwrap();\n+    assert_eq!(s, \"\");\n+}\n+\n+#[test]\n+fn test_lines() {\n+    let in_buf: &[u8] = b\"a\\nb\\nc\";\n+    let reader = BufReader::with_capacity(2, in_buf);\n+    let mut it = reader.lines();\n+    assert_eq!(it.next().unwrap().unwrap(), \"a\".to_string());\n+    assert_eq!(it.next().unwrap().unwrap(), \"b\".to_string());\n+    assert_eq!(it.next().unwrap().unwrap(), \"c\".to_string());\n+    assert!(it.next().is_none());\n+}\n+\n+#[test]\n+fn test_short_reads() {\n+    let inner = ShortReader { lengths: vec![0, 1, 2, 0, 1, 0] };\n+    let mut reader = BufReader::new(inner);\n+    let mut buf = [0, 0];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 2);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn dont_panic_in_drop_on_panicked_flush() {\n+    struct FailFlushWriter;\n+\n+    impl Write for FailFlushWriter {\n+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+            Ok(buf.len())\n+        }\n+        fn flush(&mut self) -> io::Result<()> {\n+            Err(io::Error::last_os_error())\n+        }\n+    }\n+\n+    let writer = FailFlushWriter;\n+    let _writer = BufWriter::new(writer);\n+\n+    // If writer panics *again* due to the flush error then the process will\n+    // abort.\n+    panic!();\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn panic_in_write_doesnt_flush_in_drop() {\n+    static WRITES: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct PanicWriter;\n+\n+    impl Write for PanicWriter {\n+        fn write(&mut self, _: &[u8]) -> io::Result<usize> {\n+            WRITES.fetch_add(1, Ordering::SeqCst);\n+            panic!();\n+        }\n+        fn flush(&mut self) -> io::Result<()> {\n+            Ok(())\n+        }\n+    }\n+\n+    thread::spawn(|| {\n+        let mut writer = BufWriter::new(PanicWriter);\n+        let _ = writer.write(b\"hello world\");\n+        let _ = writer.flush();\n+    })\n+    .join()\n+    .unwrap_err();\n+\n+    assert_eq!(WRITES.load(Ordering::SeqCst), 1);\n+}\n+\n+#[bench]\n+fn bench_buffered_reader(b: &mut test::Bencher) {\n+    b.iter(|| BufReader::new(io::empty()));\n+}\n+\n+#[bench]\n+fn bench_buffered_writer(b: &mut test::Bencher) {\n+    b.iter(|| BufWriter::new(io::sink()));\n+}\n+\n+/// A simple `Write` target, designed to be wrapped by `LineWriter` /\n+/// `BufWriter` / etc, that can have its `write` & `flush` behavior\n+/// configured\n+#[derive(Default, Clone)]\n+struct ProgrammableSink {\n+    // Writes append to this slice\n+    pub buffer: Vec<u8>,\n+\n+    // Flush sets this flag\n+    pub flushed: bool,\n+\n+    // If true, writes will always be an error\n+    pub always_write_error: bool,\n+\n+    // If true, flushes will always be an error\n+    pub always_flush_error: bool,\n+\n+    // If set, only up to this number of bytes will be written in a single\n+    // call to `write`\n+    pub accept_prefix: Option<usize>,\n+\n+    // If set, counts down with each write, and writes return an error\n+    // when it hits 0\n+    pub max_writes: Option<usize>,\n+\n+    // If set, attempting to write when max_writes == Some(0) will be an\n+    // error; otherwise, it will return Ok(0).\n+    pub error_after_max_writes: bool,\n+}\n+\n+impl Write for ProgrammableSink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        if self.always_write_error {\n+            return Err(io::Error::new(io::ErrorKind::Other, \"test - always_write_error\"));\n+        }\n+\n+        match self.max_writes {\n+            Some(0) if self.error_after_max_writes => {\n+                return Err(io::Error::new(io::ErrorKind::Other, \"test - max_writes\"));\n+            }\n+            Some(0) => return Ok(0),\n+            Some(ref mut count) => *count -= 1,\n+            None => {}\n+        }\n+\n+        let len = match self.accept_prefix {\n+            None => data.len(),\n+            Some(prefix) => data.len().min(prefix),\n+        };\n+\n+        let data = &data[..len];\n+        self.buffer.extend_from_slice(data);\n+\n+        Ok(len)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        if self.always_flush_error {\n+            Err(io::Error::new(io::ErrorKind::Other, \"test - always_flush_error\"))\n+        } else {\n+            self.flushed = true;\n+            Ok(())\n+        }\n+    }\n+}\n+\n+/// Previously the `LineWriter` could successfully write some bytes but\n+/// then fail to report that it has done so. Additionally, an erroneous\n+/// flush after a successful write was permanently ignored.\n+///\n+/// Test that a line writer correctly reports the number of written bytes,\n+/// and that it attempts to flush buffered lines from previous writes\n+/// before processing new data\n+///\n+/// Regression test for #37807\n+#[test]\n+fn erroneous_flush_retried() {\n+    let writer = ProgrammableSink {\n+        // Only write up to 4 bytes at a time\n+        accept_prefix: Some(4),\n+\n+        // Accept the first two writes, then error the others\n+        max_writes: Some(2),\n+        error_after_max_writes: true,\n+\n+        ..Default::default()\n+    };\n+\n+    // This should write the first 4 bytes. The rest will be buffered, out\n+    // to the last newline.\n+    let mut writer = LineWriter::new(writer);\n+    assert_eq!(writer.write(b\"a\\nb\\nc\\nd\\ne\").unwrap(), 8);\n+\n+    // This write should attempt to flush \"c\\nd\\n\", then buffer \"e\". No\n+    // errors should happen here because no further writes should be\n+    // attempted against `writer`.\n+    assert_eq!(writer.write(b\"e\").unwrap(), 1);\n+    assert_eq!(&writer.get_ref().buffer, b\"a\\nb\\nc\\nd\\n\");\n+}\n+\n+#[test]\n+fn line_vectored() {\n+    let mut a = LineWriter::new(Vec::new());\n+    assert_eq!(\n+        a.write_vectored(&[\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"\\n\"),\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"a\"),\n+        ])\n+        .unwrap(),\n+        2,\n+    );\n+    assert_eq!(a.get_ref(), b\"\\n\");\n+\n+    assert_eq!(\n+        a.write_vectored(&[\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"b\"),\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"a\"),\n+            IoSlice::new(&[]),\n+            IoSlice::new(b\"c\"),\n+        ])\n+        .unwrap(),\n+        3,\n+    );\n+    assert_eq!(a.get_ref(), b\"\\n\");\n+    a.flush().unwrap();\n+    assert_eq!(a.get_ref(), b\"\\nabac\");\n+    assert_eq!(a.write_vectored(&[]).unwrap(), 0);\n+    assert_eq!(\n+        a.write_vectored(&[\n+            IoSlice::new(&[]),\n+            IoSlice::new(&[]),\n+            IoSlice::new(&[]),\n+            IoSlice::new(&[]),\n+        ])\n+        .unwrap(),\n+        0,\n+    );\n+    assert_eq!(a.write_vectored(&[IoSlice::new(b\"a\\nb\"),]).unwrap(), 3);\n+    assert_eq!(a.get_ref(), b\"\\nabaca\\nb\");\n+}\n+\n+#[test]\n+fn line_vectored_partial_and_errors() {\n+    use crate::collections::VecDeque;\n+\n+    enum Call {\n+        Write { inputs: Vec<&'static [u8]>, output: io::Result<usize> },\n+        Flush { output: io::Result<()> },\n+    }\n+\n+    #[derive(Default)]\n+    struct Writer {\n+        calls: VecDeque<Call>,\n+    }\n+\n+    impl Write for Writer {\n+        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+            self.write_vectored(&[IoSlice::new(buf)])\n+        }\n+\n+        fn write_vectored(&mut self, buf: &[IoSlice<'_>]) -> io::Result<usize> {\n+            match self.calls.pop_front().expect(\"unexpected call to write\") {\n+                Call::Write { inputs, output } => {\n+                    assert_eq!(inputs, buf.iter().map(|b| &**b).collect::<Vec<_>>());\n+                    output\n+                }\n+                Call::Flush { .. } => panic!(\"unexpected call to write; expected a flush\"),\n+            }\n+        }\n+\n+        fn is_write_vectored(&self) -> bool {\n+            true\n+        }\n+\n+        fn flush(&mut self) -> io::Result<()> {\n+            match self.calls.pop_front().expect(\"Unexpected call to flush\") {\n+                Call::Flush { output } => output,\n+                Call::Write { .. } => panic!(\"unexpected call to flush; expected a write\"),\n+            }\n+        }\n+    }\n+\n+    impl Drop for Writer {\n+        fn drop(&mut self) {\n+            if !thread::panicking() {\n+                assert_eq!(self.calls.len(), 0);\n+            }\n+        }\n+    }\n+\n+    // partial writes keep going\n+    let mut a = LineWriter::new(Writer::default());\n+    a.write_vectored(&[IoSlice::new(&[]), IoSlice::new(b\"abc\")]).unwrap();\n+\n+    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"abc\"], output: Ok(1) });\n+    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"bc\"], output: Ok(2) });\n+    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\n\"], output: Ok(2) });\n+\n+    a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\n\")]).unwrap();\n+\n+    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n+    a.flush().unwrap();\n+\n+    // erroneous writes stop and don't write more\n+    a.get_mut().calls.push_back(Call::Write { inputs: vec![b\"x\", b\"\\na\"], output: Err(err()) });\n+    a.get_mut().calls.push_back(Call::Flush { output: Ok(()) });\n+    assert!(a.write_vectored(&[IoSlice::new(b\"x\"), IoSlice::new(b\"\\na\")]).is_err());\n+    a.flush().unwrap();\n+\n+    fn err() -> io::Error {\n+        io::Error::new(io::ErrorKind::Other, \"x\")\n+    }\n+}\n+\n+/// Test that, in cases where vectored writing is not enabled, the\n+/// LineWriter uses the normal `write` call, which more-correctly handles\n+/// partial lines\n+#[test]\n+fn line_vectored_ignored() {\n+    let writer = ProgrammableSink::default();\n+    let mut writer = LineWriter::new(writer);\n+\n+    let content = [\n+        IoSlice::new(&[]),\n+        IoSlice::new(b\"Line 1\\nLine\"),\n+        IoSlice::new(b\" 2\\nLine 3\\nL\"),\n+        IoSlice::new(&[]),\n+        IoSlice::new(&[]),\n+        IoSlice::new(b\"ine 4\"),\n+        IoSlice::new(b\"\\nLine 5\\n\"),\n+    ];\n+\n+    let count = writer.write_vectored(&content).unwrap();\n+    assert_eq!(count, 11);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+    let count = writer.write_vectored(&content[2..]).unwrap();\n+    assert_eq!(count, 11);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+\n+    let count = writer.write_vectored(&content[5..]).unwrap();\n+    assert_eq!(count, 5);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+\n+    let count = writer.write_vectored(&content[6..]).unwrap();\n+    assert_eq!(count, 8);\n+    assert_eq!(\n+        writer.get_ref().buffer.as_slice(),\n+        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\n\".as_ref()\n+    );\n+}\n+\n+/// Test that, given this input:\n+///\n+/// Line 1\\n\n+/// Line 2\\n\n+/// Line 3\\n\n+/// Line 4\n+///\n+/// And given a result that only writes to midway through Line 2\n+///\n+/// That only up to the end of Line 3 is buffered\n+///\n+/// This behavior is desirable because it prevents flushing partial lines\n+#[test]\n+fn partial_write_buffers_line() {\n+    let writer = ProgrammableSink { accept_prefix: Some(13), ..Default::default() };\n+    let mut writer = LineWriter::new(writer);\n+\n+    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\\nLine4\").unwrap(), 21);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\");\n+\n+    assert_eq!(writer.write(b\"Line 4\").unwrap(), 6);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\n\");\n+}\n+\n+/// Test that, given this input:\n+///\n+/// Line 1\\n\n+/// Line 2\\n\n+/// Line 3\n+///\n+/// And given that the full write of lines 1 and 2 was successful\n+/// That data up to Line 3 is buffered\n+#[test]\n+fn partial_line_buffered_after_line_write() {\n+    let writer = ProgrammableSink::default();\n+    let mut writer = LineWriter::new(writer);\n+\n+    assert_eq!(writer.write(b\"Line 1\\nLine 2\\nLine 3\").unwrap(), 20);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\n\");\n+\n+    assert!(writer.flush().is_ok());\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n+}\n+\n+/// Test that, given a partial line that exceeds the length of\n+/// LineBuffer's buffer (that is, without a trailing newline), that that\n+/// line is written to the inner writer\n+#[test]\n+fn long_line_flushed() {\n+    let writer = ProgrammableSink::default();\n+    let mut writer = LineWriter::with_capacity(5, writer);\n+\n+    assert_eq!(writer.write(b\"0123456789\").unwrap(), 10);\n+    assert_eq!(&writer.get_ref().buffer, b\"0123456789\");\n+}\n+\n+/// Test that, given a very long partial line *after* successfully\n+/// flushing a complete line, that that line is buffered unconditionally,\n+/// and no additional writes take place. This assures the property that\n+/// `write` should make at-most-one attempt to write new data.\n+#[test]\n+fn line_long_tail_not_flushed() {\n+    let writer = ProgrammableSink::default();\n+    let mut writer = LineWriter::with_capacity(5, writer);\n+\n+    // Assert that Line 1\\n is flushed, and 01234 is buffered\n+    assert_eq!(writer.write(b\"Line 1\\n0123456789\").unwrap(), 12);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+    // Because the buffer is full, this subsequent write will flush it\n+    assert_eq!(writer.write(b\"5\").unwrap(), 1);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n01234\");\n+}\n+\n+/// Test that, if an attempt to pre-flush buffered data returns Ok(0),\n+/// this is propagated as an error.\n+#[test]\n+fn line_buffer_write0_error() {\n+    let writer = ProgrammableSink {\n+        // Accept one write, then return Ok(0) on subsequent ones\n+        max_writes: Some(1),\n+\n+        ..Default::default()\n+    };\n+    let mut writer = LineWriter::new(writer);\n+\n+    // This should write \"Line 1\\n\" and buffer \"Partial\"\n+    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+    // This will attempt to flush \"partial\", which will return Ok(0), which\n+    // needs to be an error, because we've already informed the client\n+    // that we accepted the write.\n+    let err = writer.write(b\" Line End\\n\").unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::WriteZero);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+}\n+\n+/// Test that, if a write returns Ok(0) after a successful pre-flush, this\n+/// is propagated as Ok(0)\n+#[test]\n+fn line_buffer_write0_normal() {\n+    let writer = ProgrammableSink {\n+        // Accept two writes, then return Ok(0) on subsequent ones\n+        max_writes: Some(2),\n+\n+        ..Default::default()\n+    };\n+    let mut writer = LineWriter::new(writer);\n+\n+    // This should write \"Line 1\\n\" and buffer \"Partial\"\n+    assert_eq!(writer.write(b\"Line 1\\nPartial\").unwrap(), 14);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\n\");\n+\n+    // This will flush partial, which will succeed, but then return Ok(0)\n+    // when flushing \" Line End\\n\"\n+    assert_eq!(writer.write(b\" Line End\\n\").unwrap(), 0);\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nPartial\");\n+}\n+\n+/// LineWriter has a custom `write_all`; make sure it works correctly\n+#[test]\n+fn line_write_all() {\n+    let writer = ProgrammableSink {\n+        // Only write 5 bytes at a time\n+        accept_prefix: Some(5),\n+        ..Default::default()\n+    };\n+    let mut writer = LineWriter::new(writer);\n+\n+    writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\").unwrap();\n+    assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\n\");\n+    writer.write_all(b\" Line 5\\n\").unwrap();\n+    assert_eq!(\n+        writer.get_ref().buffer.as_slice(),\n+        b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial Line 5\\n\".as_ref(),\n+    );\n+}\n+\n+#[test]\n+fn line_write_all_error() {\n+    let writer = ProgrammableSink {\n+        // Only accept up to 3 writes of up to 5 bytes each\n+        accept_prefix: Some(5),\n+        max_writes: Some(3),\n+        ..Default::default()\n+    };\n+\n+    let mut writer = LineWriter::new(writer);\n+    let res = writer.write_all(b\"Line 1\\nLine 2\\nLine 3\\nLine 4\\nPartial\");\n+    assert!(res.is_err());\n+    // An error from write_all leaves everything in an indeterminate state,\n+    // so there's nothing else to test here\n+}\n+\n+/// Under certain circumstances, the old implementation of LineWriter\n+/// would try to buffer \"to the last newline\" but be forced to buffer\n+/// less than that, leading to inappropriate partial line writes.\n+/// Regression test for that issue.\n+#[test]\n+fn partial_multiline_buffering() {\n+    let writer = ProgrammableSink {\n+        // Write only up to 5 bytes at a time\n+        accept_prefix: Some(5),\n+        ..Default::default()\n+    };\n+\n+    let mut writer = LineWriter::with_capacity(10, writer);\n+\n+    let content = b\"AAAAABBBBB\\nCCCCDDDDDD\\nEEE\";\n+\n+    // When content is written, LineWriter will try to write blocks A, B,\n+    // C, and D. Only block A will succeed. Under the old behavior, LineWriter\n+    // would then try to buffer B, C and D, but because its capacity is 10,\n+    // it will only be able to buffer B and C. We don't want to buffer\n+    // partial lines concurrent with whole lines, so the correct behavior\n+    // is to buffer only block B (out to the newline)\n+    assert_eq!(writer.write(content).unwrap(), 11);\n+    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n+\n+    writer.flush().unwrap();\n+    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\\n\");\n+}\n+\n+/// Same as test_partial_multiline_buffering, but in the event NO full lines\n+/// fit in the buffer, just buffer as much as possible\n+#[test]\n+fn partial_multiline_buffering_without_full_line() {\n+    let writer = ProgrammableSink {\n+        // Write only up to 5 bytes at a time\n+        accept_prefix: Some(5),\n+        ..Default::default()\n+    };\n+\n+    let mut writer = LineWriter::with_capacity(5, writer);\n+\n+    let content = b\"AAAAABBBBBBBBBB\\nCCCCC\\nDDDDD\";\n+\n+    // When content is written, LineWriter will try to write blocks A, B,\n+    // and C. Only block A will succeed. Under the old behavior, LineWriter\n+    // would then try to buffer B and C, but because its capacity is 5,\n+    // it will only be able to buffer part of B. Because it's not possible\n+    // for it to buffer any complete lines, it should buffer as much of B as\n+    // possible\n+    assert_eq!(writer.write(content).unwrap(), 10);\n+    assert_eq!(writer.get_ref().buffer, *b\"AAAAA\");\n+\n+    writer.flush().unwrap();\n+    assert_eq!(writer.get_ref().buffer, *b\"AAAAABBBBB\");\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum RecordedEvent {\n+    Write(String),\n+    Flush,\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct WriteRecorder {\n+    pub events: Vec<RecordedEvent>,\n+}\n+\n+impl Write for WriteRecorder {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        use crate::str::from_utf8;\n+\n+        self.events.push(RecordedEvent::Write(from_utf8(buf).unwrap().to_string()));\n+        Ok(buf.len())\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.events.push(RecordedEvent::Flush);\n+        Ok(())\n+    }\n+}\n+\n+/// Test that a normal, formatted writeln only results in a single write\n+/// call to the underlying writer. A naive implementation of\n+/// LineWriter::write_all results in two writes: one of the buffered data,\n+/// and another of the final substring in the formatted set\n+#[test]\n+fn single_formatted_write() {\n+    let writer = WriteRecorder::default();\n+    let mut writer = LineWriter::new(writer);\n+\n+    // Under a naive implementation of LineWriter, this will result in two\n+    // writes: \"hello, world\" and \"!\\n\", because write() has to flush the\n+    // buffer before attempting to write the last \"!\\n\". write_all shouldn't\n+    // have this limitation.\n+    writeln!(&mut writer, \"{}, {}!\", \"hello\", \"world\").unwrap();\n+    assert_eq!(writer.get_ref().events, [RecordedEvent::Write(\"hello, world!\\n\".to_string())]);\n+}"}, {"sha": "5733735dc4ab4be7369f8e03f83d7af07979edf5", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 3, "deletions": 528, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use crate::io::prelude::*;\n \n use crate::cmp;\n@@ -447,531 +450,3 @@ impl Write for Cursor<Box<[u8]>> {\n         Ok(())\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::io::prelude::*;\n-    use crate::io::{Cursor, IoSlice, IoSliceMut, SeekFrom};\n-\n-    #[test]\n-    fn test_vec_writer() {\n-        let mut writer = Vec::new();\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n-                .unwrap(),\n-            3\n-        );\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(writer, b);\n-    }\n-\n-    #[test]\n-    fn test_mem_writer() {\n-        let mut writer = Cursor::new(Vec::new());\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n-                .unwrap(),\n-            3\n-        );\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(&writer.get_ref()[..], b);\n-    }\n-\n-    #[test]\n-    fn test_mem_mut_writer() {\n-        let mut vec = Vec::new();\n-        let mut writer = Cursor::new(&mut vec);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n-                .unwrap(),\n-            3\n-        );\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(&writer.get_ref()[..], b);\n-    }\n-\n-    #[test]\n-    fn test_box_slice_writer() {\n-        let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n-        assert_eq!(writer.write(&[10]).unwrap(), 0);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(&**writer.get_ref(), b);\n-    }\n-\n-    #[test]\n-    fn test_box_slice_writer_vectored() {\n-        let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7]),])\n-                .unwrap(),\n-            7,\n-        );\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(&**writer.get_ref(), b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer() {\n-        let mut buf = [0 as u8; 9];\n-        {\n-            let mut writer = Cursor::new(&mut buf[..]);\n-            assert_eq!(writer.position(), 0);\n-            assert_eq!(writer.write(&[0]).unwrap(), 1);\n-            assert_eq!(writer.position(), 1);\n-            assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-            assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-            assert_eq!(writer.position(), 8);\n-            assert_eq!(writer.write(&[]).unwrap(), 0);\n-            assert_eq!(writer.position(), 8);\n-\n-            assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n-            assert_eq!(writer.write(&[10]).unwrap(), 0);\n-        }\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_vectored() {\n-        let mut buf = [0 as u8; 9];\n-        {\n-            let mut writer = Cursor::new(&mut buf[..]);\n-            assert_eq!(writer.position(), 0);\n-            assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n-            assert_eq!(writer.position(), 1);\n-            assert_eq!(\n-                writer\n-                    .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n-                    .unwrap(),\n-                7,\n-            );\n-            assert_eq!(writer.position(), 8);\n-            assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n-            assert_eq!(writer.position(), 8);\n-\n-            assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n-            assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n-        }\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_seek() {\n-        let mut buf = [0 as u8; 8];\n-        {\n-            let mut writer = Cursor::new(&mut buf[..]);\n-            assert_eq!(writer.position(), 0);\n-            assert_eq!(writer.write(&[1]).unwrap(), 1);\n-            assert_eq!(writer.position(), 1);\n-\n-            assert_eq!(writer.seek(SeekFrom::Start(2)).unwrap(), 2);\n-            assert_eq!(writer.position(), 2);\n-            assert_eq!(writer.write(&[2]).unwrap(), 1);\n-            assert_eq!(writer.position(), 3);\n-\n-            assert_eq!(writer.seek(SeekFrom::Current(-2)).unwrap(), 1);\n-            assert_eq!(writer.position(), 1);\n-            assert_eq!(writer.write(&[3]).unwrap(), 1);\n-            assert_eq!(writer.position(), 2);\n-\n-            assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n-            assert_eq!(writer.position(), 7);\n-            assert_eq!(writer.write(&[4]).unwrap(), 1);\n-            assert_eq!(writer.position(), 8);\n-        }\n-        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_error() {\n-        let mut buf = [0 as u8; 2];\n-        let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.write(&[0, 0]).unwrap(), 1);\n-        assert_eq!(writer.write(&[0, 0]).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_mem_reader() {\n-        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.position(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.position(), 1);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n-        assert_eq!(reader.position(), 5);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_mem_reader_vectored() {\n-        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n-        let mut buf = [];\n-        assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n-        assert_eq!(reader.position(), 0);\n-        let mut buf = [0];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),])\n-                .unwrap(),\n-            1,\n-        );\n-        assert_eq!(reader.position(), 1);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf1 = [0; 4];\n-        let mut buf2 = [0; 4];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2),])\n-                .unwrap(),\n-            7,\n-        );\n-        let b1: &[_] = &[1, 2, 3, 4];\n-        let b2: &[_] = &[5, 6, 7];\n-        assert_eq!(buf1, b1);\n-        assert_eq!(&buf2[..3], b2);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_boxed_slice_reader() {\n-        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.position(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.position(), 1);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n-        assert_eq!(reader.position(), 5);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_boxed_slice_reader_vectored() {\n-        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n-        let mut buf = [];\n-        assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n-        assert_eq!(reader.position(), 0);\n-        let mut buf = [0];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),])\n-                .unwrap(),\n-            1,\n-        );\n-        assert_eq!(reader.position(), 1);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf1 = [0; 4];\n-        let mut buf2 = [0; 4];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n-                .unwrap(),\n-            7,\n-        );\n-        let b1: &[_] = &[1, 2, 3, 4];\n-        let b2: &[_] = &[5, 6, 7];\n-        assert_eq!(buf1, b1);\n-        assert_eq!(&buf2[..3], b2);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn read_to_end() {\n-        let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n-        let mut v = Vec::new();\n-        reader.read_to_end(&mut v).unwrap();\n-        assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n-    }\n-\n-    #[test]\n-    fn test_slice_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let reader = &mut &in_buf[..];\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.len(), 7);\n-        let b: &[_] = &[0];\n-        assert_eq!(&buf[..], b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n-        assert_eq!(reader.len(), 3);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(&buf[..], b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_slice_reader_vectored() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let reader = &mut &in_buf[..];\n-        let mut buf = [];\n-        assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n-        let mut buf = [0];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),])\n-                .unwrap(),\n-            1,\n-        );\n-        assert_eq!(reader.len(), 7);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf1 = [0; 4];\n-        let mut buf2 = [0; 4];\n-        assert_eq!(\n-            reader\n-                .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n-                .unwrap(),\n-            7,\n-        );\n-        let b1: &[_] = &[1, 2, 3, 4];\n-        let b2: &[_] = &[5, 6, 7];\n-        assert_eq!(buf1, b1);\n-        assert_eq!(&buf2[..3], b2);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn test_read_exact() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let reader = &mut &in_buf[..];\n-        let mut buf = [];\n-        assert!(reader.read_exact(&mut buf).is_ok());\n-        let mut buf = [8];\n-        assert!(reader.read_exact(&mut buf).is_ok());\n-        assert_eq!(buf[0], 0);\n-        assert_eq!(reader.len(), 7);\n-        let mut buf = [0, 0, 0, 0, 0, 0, 0];\n-        assert!(reader.read_exact(&mut buf).is_ok());\n-        assert_eq!(buf, [1, 2, 3, 4, 5, 6, 7]);\n-        assert_eq!(reader.len(), 0);\n-        let mut buf = [0];\n-        assert!(reader.read_exact(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_buf_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = Cursor::new(&in_buf[..]);\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-        assert_eq!(reader.position(), 0);\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 1);\n-        assert_eq!(reader.position(), 1);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf).unwrap(), 4);\n-        assert_eq!(reader.position(), 5);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 3);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert_eq!(reader.read(&mut buf).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn seek_past_end() {\n-        let buf = [0xff];\n-        let mut r = Cursor::new(&buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n-        assert_eq!(r.read(&mut [0]).unwrap(), 0);\n-\n-        let mut r = Cursor::new(vec![10]);\n-        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n-        assert_eq!(r.read(&mut [0]).unwrap(), 0);\n-\n-        let mut buf = [0];\n-        let mut r = Cursor::new(&mut buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n-        assert_eq!(r.write(&[3]).unwrap(), 0);\n-\n-        let mut r = Cursor::new(vec![10].into_boxed_slice());\n-        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n-        assert_eq!(r.write(&[3]).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn seek_past_i64() {\n-        let buf = [0xff];\n-        let mut r = Cursor::new(&buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n-        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n-        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n-        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n-\n-        let mut r = Cursor::new(vec![10]);\n-        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n-        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n-        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n-        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n-\n-        let mut buf = [0];\n-        let mut r = Cursor::new(&mut buf[..]);\n-        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n-        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n-        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n-        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n-\n-        let mut r = Cursor::new(vec![10].into_boxed_slice());\n-        assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n-        assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n-        assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n-        assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n-        assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n-    }\n-\n-    #[test]\n-    fn seek_before_0() {\n-        let buf = [0xff];\n-        let mut r = Cursor::new(&buf[..]);\n-        assert!(r.seek(SeekFrom::End(-2)).is_err());\n-\n-        let mut r = Cursor::new(vec![10]);\n-        assert!(r.seek(SeekFrom::End(-2)).is_err());\n-\n-        let mut buf = [0];\n-        let mut r = Cursor::new(&mut buf[..]);\n-        assert!(r.seek(SeekFrom::End(-2)).is_err());\n-\n-        let mut r = Cursor::new(vec![10].into_boxed_slice());\n-        assert!(r.seek(SeekFrom::End(-2)).is_err());\n-    }\n-\n-    #[test]\n-    fn test_seekable_mem_writer() {\n-        let mut writer = Cursor::new(Vec::<u8>::new());\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(writer.position(), 8);\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        assert_eq!(writer.seek(SeekFrom::Start(0)).unwrap(), 0);\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[3, 4]).unwrap(), 2);\n-        let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        assert_eq!(writer.seek(SeekFrom::Current(1)).unwrap(), 3);\n-        assert_eq!(writer.write(&[0, 1]).unwrap(), 2);\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n-        assert_eq!(writer.write(&[1, 2]).unwrap(), 2);\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        assert_eq!(writer.seek(SeekFrom::End(1)).unwrap(), 10);\n-        assert_eq!(writer.write(&[1]).unwrap(), 1);\n-        let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n-        assert_eq!(&writer.get_ref()[..], b);\n-    }\n-\n-    #[test]\n-    fn vec_seek_past_end() {\n-        let mut r = Cursor::new(Vec::new());\n-        assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n-        assert_eq!(r.write(&[3]).unwrap(), 1);\n-    }\n-\n-    #[test]\n-    fn vec_seek_before_0() {\n-        let mut r = Cursor::new(Vec::new());\n-        assert!(r.seek(SeekFrom::End(-2)).is_err());\n-    }\n-\n-    #[test]\n-    #[cfg(target_pointer_width = \"32\")]\n-    fn vec_seek_and_write_past_usize_max() {\n-        let mut c = Cursor::new(Vec::new());\n-        c.set_position(usize::MAX as u64 + 1);\n-        assert!(c.write_all(&[1, 2, 3]).is_err());\n-    }\n-\n-    #[test]\n-    fn test_partial_eq() {\n-        assert_eq!(Cursor::new(Vec::<u8>::new()), Cursor::new(Vec::<u8>::new()));\n-    }\n-\n-    #[test]\n-    fn test_eq() {\n-        struct AssertEq<T: Eq>(pub T);\n-\n-        let _: AssertEq<Cursor<Vec<u8>>> = AssertEq(Cursor::new(Vec::new()));\n-    }\n-}"}, {"sha": "80d88ca66f66994627ca717a3021f25c33f4320c", "filename": "library/std/src/io/cursor/tests.rs", "status": "added", "additions": 516, "deletions": 0, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,516 @@\n+use crate::io::prelude::*;\n+use crate::io::{Cursor, IoSlice, IoSliceMut, SeekFrom};\n+\n+#[test]\n+fn test_vec_writer() {\n+    let mut writer = Vec::new();\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    assert_eq!(\n+        writer\n+            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n+            .unwrap(),\n+        3\n+    );\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(writer, b);\n+}\n+\n+#[test]\n+fn test_mem_writer() {\n+    let mut writer = Cursor::new(Vec::new());\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    assert_eq!(\n+        writer\n+            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n+            .unwrap(),\n+        3\n+    );\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(&writer.get_ref()[..], b);\n+}\n+\n+#[test]\n+fn test_mem_mut_writer() {\n+    let mut vec = Vec::new();\n+    let mut writer = Cursor::new(&mut vec);\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    assert_eq!(\n+        writer\n+            .write_vectored(&[IoSlice::new(&[]), IoSlice::new(&[8, 9]), IoSlice::new(&[10])],)\n+            .unwrap(),\n+        3\n+    );\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(&writer.get_ref()[..], b);\n+}\n+\n+#[test]\n+fn test_box_slice_writer() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    assert_eq!(writer.position(), 0);\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.position(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    assert_eq!(writer.position(), 8);\n+    assert_eq!(writer.write(&[]).unwrap(), 0);\n+    assert_eq!(writer.position(), 8);\n+\n+    assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n+    assert_eq!(writer.write(&[10]).unwrap(), 0);\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(&**writer.get_ref(), b);\n+}\n+\n+#[test]\n+fn test_box_slice_writer_vectored() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    assert_eq!(writer.position(), 0);\n+    assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n+    assert_eq!(writer.position(), 1);\n+    assert_eq!(\n+        writer.write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7]),]).unwrap(),\n+        7,\n+    );\n+    assert_eq!(writer.position(), 8);\n+    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+    assert_eq!(writer.position(), 8);\n+\n+    assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n+    assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(&**writer.get_ref(), b);\n+}\n+\n+#[test]\n+fn test_buf_writer() {\n+    let mut buf = [0 as u8; 9];\n+    {\n+        let mut writer = Cursor::new(&mut buf[..]);\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[0]).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+        assert_eq!(writer.position(), 8);\n+        assert_eq!(writer.write(&[]).unwrap(), 0);\n+        assert_eq!(writer.position(), 8);\n+\n+        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n+        assert_eq!(writer.write(&[10]).unwrap(), 0);\n+    }\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(buf, b);\n+}\n+\n+#[test]\n+fn test_buf_writer_vectored() {\n+    let mut buf = [0 as u8; 9];\n+    {\n+        let mut writer = Cursor::new(&mut buf[..]);\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(\n+            writer\n+                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n+                .unwrap(),\n+            7,\n+        );\n+        assert_eq!(writer.position(), 8);\n+        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+        assert_eq!(writer.position(), 8);\n+\n+        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n+        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n+    }\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    assert_eq!(buf, b);\n+}\n+\n+#[test]\n+fn test_buf_writer_seek() {\n+    let mut buf = [0 as u8; 8];\n+    {\n+        let mut writer = Cursor::new(&mut buf[..]);\n+        assert_eq!(writer.position(), 0);\n+        assert_eq!(writer.write(&[1]).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+\n+        assert_eq!(writer.seek(SeekFrom::Start(2)).unwrap(), 2);\n+        assert_eq!(writer.position(), 2);\n+        assert_eq!(writer.write(&[2]).unwrap(), 1);\n+        assert_eq!(writer.position(), 3);\n+\n+        assert_eq!(writer.seek(SeekFrom::Current(-2)).unwrap(), 1);\n+        assert_eq!(writer.position(), 1);\n+        assert_eq!(writer.write(&[3]).unwrap(), 1);\n+        assert_eq!(writer.position(), 2);\n+\n+        assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n+        assert_eq!(writer.position(), 7);\n+        assert_eq!(writer.write(&[4]).unwrap(), 1);\n+        assert_eq!(writer.position(), 8);\n+    }\n+    let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n+    assert_eq!(buf, b);\n+}\n+\n+#[test]\n+fn test_buf_writer_error() {\n+    let mut buf = [0 as u8; 2];\n+    let mut writer = Cursor::new(&mut buf[..]);\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[0, 0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[0, 0]).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_mem_reader() {\n+    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n+    let mut buf = [];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.position(), 0);\n+    let mut buf = [0];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.position(), 1);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf = [0; 4];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n+    assert_eq!(reader.position(), 5);\n+    let b: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(buf, b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n+    let b: &[_] = &[5, 6, 7];\n+    assert_eq!(&buf[..3], b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_mem_reader_vectored() {\n+    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n+    let mut buf = [];\n+    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n+    assert_eq!(reader.position(), 0);\n+    let mut buf = [0];\n+    assert_eq!(\n+        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n+        1,\n+    );\n+    assert_eq!(reader.position(), 1);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf1 = [0; 4];\n+    let mut buf2 = [0; 4];\n+    assert_eq!(\n+        reader\n+            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2),])\n+            .unwrap(),\n+        7,\n+    );\n+    let b1: &[_] = &[1, 2, 3, 4];\n+    let b2: &[_] = &[5, 6, 7];\n+    assert_eq!(buf1, b1);\n+    assert_eq!(&buf2[..3], b2);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_boxed_slice_reader() {\n+    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n+    let mut buf = [];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.position(), 0);\n+    let mut buf = [0];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.position(), 1);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf = [0; 4];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n+    assert_eq!(reader.position(), 5);\n+    let b: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(buf, b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n+    let b: &[_] = &[5, 6, 7];\n+    assert_eq!(&buf[..3], b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_boxed_slice_reader_vectored() {\n+    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7].into_boxed_slice());\n+    let mut buf = [];\n+    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n+    assert_eq!(reader.position(), 0);\n+    let mut buf = [0];\n+    assert_eq!(\n+        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n+        1,\n+    );\n+    assert_eq!(reader.position(), 1);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf1 = [0; 4];\n+    let mut buf2 = [0; 4];\n+    assert_eq!(\n+        reader\n+            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n+            .unwrap(),\n+        7,\n+    );\n+    let b1: &[_] = &[1, 2, 3, 4];\n+    let b2: &[_] = &[5, 6, 7];\n+    assert_eq!(buf1, b1);\n+    assert_eq!(&buf2[..3], b2);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn read_to_end() {\n+    let mut reader = Cursor::new(vec![0, 1, 2, 3, 4, 5, 6, 7]);\n+    let mut v = Vec::new();\n+    reader.read_to_end(&mut v).unwrap();\n+    assert_eq!(v, [0, 1, 2, 3, 4, 5, 6, 7]);\n+}\n+\n+#[test]\n+fn test_slice_reader() {\n+    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+    let reader = &mut &in_buf[..];\n+    let mut buf = [];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    let mut buf = [0];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.len(), 7);\n+    let b: &[_] = &[0];\n+    assert_eq!(&buf[..], b);\n+    let mut buf = [0; 4];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n+    assert_eq!(reader.len(), 3);\n+    let b: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(&buf[..], b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n+    let b: &[_] = &[5, 6, 7];\n+    assert_eq!(&buf[..3], b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_slice_reader_vectored() {\n+    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+    let reader = &mut &in_buf[..];\n+    let mut buf = [];\n+    assert_eq!(reader.read_vectored(&mut [IoSliceMut::new(&mut buf)]).unwrap(), 0);\n+    let mut buf = [0];\n+    assert_eq!(\n+        reader.read_vectored(&mut [IoSliceMut::new(&mut []), IoSliceMut::new(&mut buf),]).unwrap(),\n+        1,\n+    );\n+    assert_eq!(reader.len(), 7);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf1 = [0; 4];\n+    let mut buf2 = [0; 4];\n+    assert_eq!(\n+        reader\n+            .read_vectored(&mut [IoSliceMut::new(&mut buf1), IoSliceMut::new(&mut buf2)],)\n+            .unwrap(),\n+        7,\n+    );\n+    let b1: &[_] = &[1, 2, 3, 4];\n+    let b2: &[_] = &[5, 6, 7];\n+    assert_eq!(buf1, b1);\n+    assert_eq!(&buf2[..3], b2);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn test_read_exact() {\n+    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+    let reader = &mut &in_buf[..];\n+    let mut buf = [];\n+    assert!(reader.read_exact(&mut buf).is_ok());\n+    let mut buf = [8];\n+    assert!(reader.read_exact(&mut buf).is_ok());\n+    assert_eq!(buf[0], 0);\n+    assert_eq!(reader.len(), 7);\n+    let mut buf = [0, 0, 0, 0, 0, 0, 0];\n+    assert!(reader.read_exact(&mut buf).is_ok());\n+    assert_eq!(buf, [1, 2, 3, 4, 5, 6, 7]);\n+    assert_eq!(reader.len(), 0);\n+    let mut buf = [0];\n+    assert!(reader.read_exact(&mut buf).is_err());\n+}\n+\n+#[test]\n+fn test_buf_reader() {\n+    let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut reader = Cursor::new(&in_buf[..]);\n+    let mut buf = [];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+    assert_eq!(reader.position(), 0);\n+    let mut buf = [0];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 1);\n+    assert_eq!(reader.position(), 1);\n+    let b: &[_] = &[0];\n+    assert_eq!(buf, b);\n+    let mut buf = [0; 4];\n+    assert_eq!(reader.read(&mut buf).unwrap(), 4);\n+    assert_eq!(reader.position(), 5);\n+    let b: &[_] = &[1, 2, 3, 4];\n+    assert_eq!(buf, b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 3);\n+    let b: &[_] = &[5, 6, 7];\n+    assert_eq!(&buf[..3], b);\n+    assert_eq!(reader.read(&mut buf).unwrap(), 0);\n+}\n+\n+#[test]\n+fn seek_past_end() {\n+    let buf = [0xff];\n+    let mut r = Cursor::new(&buf[..]);\n+    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n+\n+    let mut r = Cursor::new(vec![10]);\n+    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+    assert_eq!(r.read(&mut [0]).unwrap(), 0);\n+\n+    let mut buf = [0];\n+    let mut r = Cursor::new(&mut buf[..]);\n+    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+    assert_eq!(r.write(&[3]).unwrap(), 0);\n+\n+    let mut r = Cursor::new(vec![10].into_boxed_slice());\n+    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+    assert_eq!(r.write(&[3]).unwrap(), 0);\n+}\n+\n+#[test]\n+fn seek_past_i64() {\n+    let buf = [0xff];\n+    let mut r = Cursor::new(&buf[..]);\n+    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+    let mut r = Cursor::new(vec![10]);\n+    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+    let mut buf = [0];\n+    let mut r = Cursor::new(&mut buf[..]);\n+    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+\n+    let mut r = Cursor::new(vec![10].into_boxed_slice());\n+    assert_eq!(r.seek(SeekFrom::Start(6)).unwrap(), 6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x7ffffffffffffff0)).unwrap(), 0x7ffffffffffffff6);\n+    assert_eq!(r.seek(SeekFrom::Current(0x10)).unwrap(), 0x8000000000000006);\n+    assert_eq!(r.seek(SeekFrom::Current(0)).unwrap(), 0x8000000000000006);\n+    assert!(r.seek(SeekFrom::Current(0x7ffffffffffffffd)).is_err());\n+    assert_eq!(r.seek(SeekFrom::Current(-0x8000000000000000)).unwrap(), 6);\n+}\n+\n+#[test]\n+fn seek_before_0() {\n+    let buf = [0xff];\n+    let mut r = Cursor::new(&buf[..]);\n+    assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+    let mut r = Cursor::new(vec![10]);\n+    assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+    let mut buf = [0];\n+    let mut r = Cursor::new(&mut buf[..]);\n+    assert!(r.seek(SeekFrom::End(-2)).is_err());\n+\n+    let mut r = Cursor::new(vec![10].into_boxed_slice());\n+    assert!(r.seek(SeekFrom::End(-2)).is_err());\n+}\n+\n+#[test]\n+fn test_seekable_mem_writer() {\n+    let mut writer = Cursor::new(Vec::<u8>::new());\n+    assert_eq!(writer.position(), 0);\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.position(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    assert_eq!(writer.position(), 8);\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+    assert_eq!(&writer.get_ref()[..], b);\n+\n+    assert_eq!(writer.seek(SeekFrom::Start(0)).unwrap(), 0);\n+    assert_eq!(writer.position(), 0);\n+    assert_eq!(writer.write(&[3, 4]).unwrap(), 2);\n+    let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n+    assert_eq!(&writer.get_ref()[..], b);\n+\n+    assert_eq!(writer.seek(SeekFrom::Current(1)).unwrap(), 3);\n+    assert_eq!(writer.write(&[0, 1]).unwrap(), 2);\n+    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n+    assert_eq!(&writer.get_ref()[..], b);\n+\n+    assert_eq!(writer.seek(SeekFrom::End(-1)).unwrap(), 7);\n+    assert_eq!(writer.write(&[1, 2]).unwrap(), 2);\n+    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n+    assert_eq!(&writer.get_ref()[..], b);\n+\n+    assert_eq!(writer.seek(SeekFrom::End(1)).unwrap(), 10);\n+    assert_eq!(writer.write(&[1]).unwrap(), 1);\n+    let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n+    assert_eq!(&writer.get_ref()[..], b);\n+}\n+\n+#[test]\n+fn vec_seek_past_end() {\n+    let mut r = Cursor::new(Vec::new());\n+    assert_eq!(r.seek(SeekFrom::Start(10)).unwrap(), 10);\n+    assert_eq!(r.write(&[3]).unwrap(), 1);\n+}\n+\n+#[test]\n+fn vec_seek_before_0() {\n+    let mut r = Cursor::new(Vec::new());\n+    assert!(r.seek(SeekFrom::End(-2)).is_err());\n+}\n+\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn vec_seek_and_write_past_usize_max() {\n+    let mut c = Cursor::new(Vec::new());\n+    c.set_position(usize::MAX as u64 + 1);\n+    assert!(c.write_all(&[1, 2, 3]).is_err());\n+}\n+\n+#[test]\n+fn test_partial_eq() {\n+    assert_eq!(Cursor::new(Vec::<u8>::new()), Cursor::new(Vec::<u8>::new()));\n+}\n+\n+#[test]\n+fn test_eq() {\n+    struct AssertEq<T: Eq>(pub T);\n+\n+    let _: AssertEq<Cursor<Vec<u8>>> = AssertEq(Cursor::new(Vec::new()));\n+}"}, {"sha": "ba0f0a0cd714aadfebb706fcd83909f17186a601", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use crate::convert::From;\n use crate::error;\n use crate::fmt;\n@@ -574,60 +577,3 @@ fn _assert_error_is_sync_send() {\n     fn _is_sync_send<T: Sync + Send>() {}\n     _is_sync_send::<Error>();\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use super::{Custom, Error, ErrorKind, Repr};\n-    use crate::error;\n-    use crate::fmt;\n-    use crate::sys::decode_error_kind;\n-    use crate::sys::os::error_string;\n-\n-    #[test]\n-    fn test_debug_error() {\n-        let code = 6;\n-        let msg = error_string(code);\n-        let kind = decode_error_kind(code);\n-        let err = Error {\n-            repr: Repr::Custom(box Custom {\n-                kind: ErrorKind::InvalidInput,\n-                error: box Error { repr: super::Repr::Os(code) },\n-            }),\n-        };\n-        let expected = format!(\n-            \"Custom {{ \\\n-             kind: InvalidInput, \\\n-             error: Os {{ \\\n-             code: {:?}, \\\n-             kind: {:?}, \\\n-             message: {:?} \\\n-             }} \\\n-             }}\",\n-            code, kind, msg\n-        );\n-        assert_eq!(format!(\"{:?}\", err), expected);\n-    }\n-\n-    #[test]\n-    fn test_downcasting() {\n-        #[derive(Debug)]\n-        struct TestError;\n-\n-        impl fmt::Display for TestError {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.write_str(\"asdf\")\n-            }\n-        }\n-\n-        impl error::Error for TestError {}\n-\n-        // we have to call all of these UFCS style right now since method\n-        // resolution won't implicitly drop the Send+Sync bounds\n-        let mut err = Error::new(ErrorKind::Other, TestError);\n-        assert!(err.get_ref().unwrap().is::<TestError>());\n-        assert_eq!(\"asdf\", err.get_ref().unwrap().to_string());\n-        assert!(err.get_mut().unwrap().is::<TestError>());\n-        let extracted = err.into_inner().unwrap();\n-        extracted.downcast::<TestError>().unwrap();\n-    }\n-}"}, {"sha": "0cce9368c80893df175deaee0146878e935e28d0", "filename": "library/std/src/io/error/tests.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,53 @@\n+use super::{Custom, Error, ErrorKind, Repr};\n+use crate::error;\n+use crate::fmt;\n+use crate::sys::decode_error_kind;\n+use crate::sys::os::error_string;\n+\n+#[test]\n+fn test_debug_error() {\n+    let code = 6;\n+    let msg = error_string(code);\n+    let kind = decode_error_kind(code);\n+    let err = Error {\n+        repr: Repr::Custom(box Custom {\n+            kind: ErrorKind::InvalidInput,\n+            error: box Error { repr: super::Repr::Os(code) },\n+        }),\n+    };\n+    let expected = format!(\n+        \"Custom {{ \\\n+         kind: InvalidInput, \\\n+         error: Os {{ \\\n+         code: {:?}, \\\n+         kind: {:?}, \\\n+         message: {:?} \\\n+         }} \\\n+         }}\",\n+        code, kind, msg\n+    );\n+    assert_eq!(format!(\"{:?}\", err), expected);\n+}\n+\n+#[test]\n+fn test_downcasting() {\n+    #[derive(Debug)]\n+    struct TestError;\n+\n+    impl fmt::Display for TestError {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.write_str(\"asdf\")\n+        }\n+    }\n+\n+    impl error::Error for TestError {}\n+\n+    // we have to call all of these UFCS style right now since method\n+    // resolution won't implicitly drop the Send+Sync bounds\n+    let mut err = Error::new(ErrorKind::Other, TestError);\n+    assert!(err.get_ref().unwrap().is::<TestError>());\n+    assert_eq!(\"asdf\", err.get_ref().unwrap().to_string());\n+    assert!(err.get_mut().unwrap().is::<TestError>());\n+    let extracted = err.into_inner().unwrap();\n+    extracted.downcast::<TestError>().unwrap();\n+}"}, {"sha": "e09e7ba978e867705b972fa8abc40e9b102535a3", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 3, "deletions": 61, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use crate::cmp;\n use crate::fmt;\n use crate::io::{\n@@ -397,64 +400,3 @@ impl Write for Vec<u8> {\n         Ok(())\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::io::prelude::*;\n-\n-    #[bench]\n-    fn bench_read_slice(b: &mut test::Bencher) {\n-        let buf = [5; 1024];\n-        let mut dst = [0; 128];\n-\n-        b.iter(|| {\n-            let mut rd = &buf[..];\n-            for _ in 0..8 {\n-                let _ = rd.read(&mut dst);\n-                test::black_box(&dst);\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_write_slice(b: &mut test::Bencher) {\n-        let mut buf = [0; 1024];\n-        let src = [5; 128];\n-\n-        b.iter(|| {\n-            let mut wr = &mut buf[..];\n-            for _ in 0..8 {\n-                let _ = wr.write_all(&src);\n-                test::black_box(&wr);\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_read_vec(b: &mut test::Bencher) {\n-        let buf = vec![5; 1024];\n-        let mut dst = [0; 128];\n-\n-        b.iter(|| {\n-            let mut rd = &buf[..];\n-            for _ in 0..8 {\n-                let _ = rd.read(&mut dst);\n-                test::black_box(&dst);\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_write_vec(b: &mut test::Bencher) {\n-        let mut buf = Vec::with_capacity(1024);\n-        let src = [5; 128];\n-\n-        b.iter(|| {\n-            let mut wr = &mut buf[..];\n-            for _ in 0..8 {\n-                let _ = wr.write_all(&src);\n-                test::black_box(&wr);\n-            }\n-        })\n-    }\n-}"}, {"sha": "d1cd84a67ada59cda67f721804b72b58f8a065d4", "filename": "library/std/src/io/impls/tests.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fimpls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fimpls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,57 @@\n+use crate::io::prelude::*;\n+\n+#[bench]\n+fn bench_read_slice(b: &mut test::Bencher) {\n+    let buf = [5; 1024];\n+    let mut dst = [0; 128];\n+\n+    b.iter(|| {\n+        let mut rd = &buf[..];\n+        for _ in 0..8 {\n+            let _ = rd.read(&mut dst);\n+            test::black_box(&dst);\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn bench_write_slice(b: &mut test::Bencher) {\n+    let mut buf = [0; 1024];\n+    let src = [5; 128];\n+\n+    b.iter(|| {\n+        let mut wr = &mut buf[..];\n+        for _ in 0..8 {\n+            let _ = wr.write_all(&src);\n+            test::black_box(&wr);\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn bench_read_vec(b: &mut test::Bencher) {\n+    let buf = vec![5; 1024];\n+    let mut dst = [0; 128];\n+\n+    b.iter(|| {\n+        let mut rd = &buf[..];\n+        for _ in 0..8 {\n+            let _ = rd.read(&mut dst);\n+            test::black_box(&dst);\n+        }\n+    })\n+}\n+\n+#[bench]\n+fn bench_write_vec(b: &mut test::Bencher) {\n+    let mut buf = Vec::with_capacity(1024);\n+    let src = [5; 128];\n+\n+    b.iter(|| {\n+        let mut wr = &mut buf[..];\n+        for _ in 0..8 {\n+            let _ = wr.write_all(&src);\n+            test::black_box(&wr);\n+        }\n+    })\n+}"}, {"sha": "adea8a804e3ca5754047adeba4c93bebed936381", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 3, "deletions": 498, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -249,6 +249,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::cmp;\n use crate::fmt;\n use crate::memchr;\n@@ -2481,501 +2484,3 @@ impl<B: BufRead> Iterator for Lines<B> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{repeat, Cursor, SeekFrom};\n-    use crate::cmp::{self, min};\n-    use crate::io::prelude::*;\n-    use crate::io::{self, IoSlice, IoSliceMut};\n-    use crate::ops::Deref;\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn read_until() {\n-        let mut buf = Cursor::new(&b\"12\"[..]);\n-        let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n-        assert_eq!(v, b\"12\");\n-\n-        let mut buf = Cursor::new(&b\"1233\"[..]);\n-        let mut v = Vec::new();\n-        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n-        assert_eq!(v, b\"123\");\n-        v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n-        assert_eq!(v, b\"3\");\n-        v.truncate(0);\n-        assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n-        assert_eq!(v, []);\n-    }\n-\n-    #[test]\n-    fn split() {\n-        let buf = Cursor::new(&b\"12\"[..]);\n-        let mut s = buf.split(b'3');\n-        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n-        assert!(s.next().is_none());\n-\n-        let buf = Cursor::new(&b\"1233\"[..]);\n-        let mut s = buf.split(b'3');\n-        assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n-        assert_eq!(s.next().unwrap().unwrap(), vec![]);\n-        assert!(s.next().is_none());\n-    }\n-\n-    #[test]\n-    fn read_line() {\n-        let mut buf = Cursor::new(&b\"12\"[..]);\n-        let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n-        assert_eq!(v, \"12\");\n-\n-        let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n-        let mut v = String::new();\n-        assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n-        assert_eq!(v, \"12\\n\");\n-        v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n-        assert_eq!(v, \"\\n\");\n-        v.truncate(0);\n-        assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n-        assert_eq!(v, \"\");\n-    }\n-\n-    #[test]\n-    fn lines() {\n-        let buf = Cursor::new(&b\"12\\r\"[..]);\n-        let mut s = buf.lines();\n-        assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n-        assert!(s.next().is_none());\n-\n-        let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n-        let mut s = buf.lines();\n-        assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n-        assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n-        assert!(s.next().is_none());\n-    }\n-\n-    #[test]\n-    fn read_to_end() {\n-        let mut c = Cursor::new(&b\"\"[..]);\n-        let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n-        assert_eq!(v, []);\n-\n-        let mut c = Cursor::new(&b\"1\"[..]);\n-        let mut v = Vec::new();\n-        assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n-        assert_eq!(v, b\"1\");\n-\n-        let cap = 1024 * 1024;\n-        let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n-        let mut v = Vec::new();\n-        let (a, b) = data.split_at(data.len() / 2);\n-        assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n-        assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n-        assert_eq!(v, data);\n-    }\n-\n-    #[test]\n-    fn read_to_string() {\n-        let mut c = Cursor::new(&b\"\"[..]);\n-        let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n-        assert_eq!(v, \"\");\n-\n-        let mut c = Cursor::new(&b\"1\"[..]);\n-        let mut v = String::new();\n-        assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n-        assert_eq!(v, \"1\");\n-\n-        let mut c = Cursor::new(&b\"\\xff\"[..]);\n-        let mut v = String::new();\n-        assert!(c.read_to_string(&mut v).is_err());\n-    }\n-\n-    #[test]\n-    fn read_exact() {\n-        let mut buf = [0; 4];\n-\n-        let mut c = Cursor::new(&b\"\"[..]);\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n-\n-        let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n-        c.read_exact(&mut buf).unwrap();\n-        assert_eq!(&buf, b\"1234\");\n-        c.read_exact(&mut buf).unwrap();\n-        assert_eq!(&buf, b\"5678\");\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n-    }\n-\n-    #[test]\n-    fn read_exact_slice() {\n-        let mut buf = [0; 4];\n-\n-        let mut c = &b\"\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n-\n-        let mut c = &b\"123\"[..];\n-        assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n-        // make sure the optimized (early returning) method is being used\n-        assert_eq!(&buf, &[0; 4]);\n-\n-        let mut c = &b\"1234\"[..];\n-        c.read_exact(&mut buf).unwrap();\n-        assert_eq!(&buf, b\"1234\");\n-\n-        let mut c = &b\"56789\"[..];\n-        c.read_exact(&mut buf).unwrap();\n-        assert_eq!(&buf, b\"5678\");\n-        assert_eq!(c, b\"9\");\n-    }\n-\n-    #[test]\n-    fn take_eof() {\n-        struct R;\n-\n-        impl Read for R {\n-            fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n-            }\n-        }\n-        impl BufRead for R {\n-            fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-                Err(io::Error::new(io::ErrorKind::Other, \"\"))\n-            }\n-            fn consume(&mut self, _amt: usize) {}\n-        }\n-\n-        let mut buf = [0; 1];\n-        assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n-        assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n-    }\n-\n-    fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n-        let mut cat = Vec::new();\n-        loop {\n-            let consume = {\n-                let buf1 = br1.fill_buf().unwrap();\n-                let buf2 = br2.fill_buf().unwrap();\n-                let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n-                assert_eq!(buf1[..minlen], buf2[..minlen]);\n-                cat.extend_from_slice(&buf1[..minlen]);\n-                minlen\n-            };\n-            if consume == 0 {\n-                break;\n-            }\n-            br1.consume(consume);\n-            br2.consume(consume);\n-        }\n-        assert_eq!(br1.fill_buf().unwrap().len(), 0);\n-        assert_eq!(br2.fill_buf().unwrap().len(), 0);\n-        assert_eq!(&cat[..], &exp[..])\n-    }\n-\n-    #[test]\n-    fn chain_bufread() {\n-        let testdata = b\"ABCDEFGHIJKL\";\n-        let chain1 =\n-            (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n-        let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n-        cmp_bufread(chain1, chain2, &testdata[..]);\n-    }\n-\n-    #[test]\n-    fn chain_zero_length_read_is_not_eof() {\n-        let a = b\"A\";\n-        let b = b\"B\";\n-        let mut s = String::new();\n-        let mut chain = (&a[..]).chain(&b[..]);\n-        chain.read(&mut []).unwrap();\n-        chain.read_to_string(&mut s).unwrap();\n-        assert_eq!(\"AB\", s);\n-    }\n-\n-    #[bench]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn bench_read_to_end(b: &mut test::Bencher) {\n-        b.iter(|| {\n-            let mut lr = repeat(1).take(10000000);\n-            let mut vec = Vec::with_capacity(1024);\n-            super::read_to_end(&mut lr, &mut vec)\n-        });\n-    }\n-\n-    #[test]\n-    fn seek_len() -> io::Result<()> {\n-        let mut c = Cursor::new(vec![0; 15]);\n-        assert_eq!(c.stream_len()?, 15);\n-\n-        c.seek(SeekFrom::End(0))?;\n-        let old_pos = c.stream_position()?;\n-        assert_eq!(c.stream_len()?, 15);\n-        assert_eq!(c.stream_position()?, old_pos);\n-\n-        c.seek(SeekFrom::Start(7))?;\n-        c.seek(SeekFrom::Current(2))?;\n-        let old_pos = c.stream_position()?;\n-        assert_eq!(c.stream_len()?, 15);\n-        assert_eq!(c.stream_position()?, old_pos);\n-\n-        Ok(())\n-    }\n-\n-    #[test]\n-    fn seek_position() -> io::Result<()> {\n-        // All `asserts` are duplicated here to make sure the method does not\n-        // change anything about the seek state.\n-        let mut c = Cursor::new(vec![0; 15]);\n-        assert_eq!(c.stream_position()?, 0);\n-        assert_eq!(c.stream_position()?, 0);\n-\n-        c.seek(SeekFrom::End(0))?;\n-        assert_eq!(c.stream_position()?, 15);\n-        assert_eq!(c.stream_position()?, 15);\n-\n-        c.seek(SeekFrom::Start(7))?;\n-        c.seek(SeekFrom::Current(2))?;\n-        assert_eq!(c.stream_position()?, 9);\n-        assert_eq!(c.stream_position()?, 9);\n-\n-        c.seek(SeekFrom::End(-3))?;\n-        c.seek(SeekFrom::Current(1))?;\n-        c.seek(SeekFrom::Current(-5))?;\n-        assert_eq!(c.stream_position()?, 8);\n-        assert_eq!(c.stream_position()?, 8);\n-\n-        Ok(())\n-    }\n-\n-    // A simple example reader which uses the default implementation of\n-    // read_to_end.\n-    struct ExampleSliceReader<'a> {\n-        slice: &'a [u8],\n-    }\n-\n-    impl<'a> Read for ExampleSliceReader<'a> {\n-        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-            let len = cmp::min(self.slice.len(), buf.len());\n-            buf[..len].copy_from_slice(&self.slice[..len]);\n-            self.slice = &self.slice[len..];\n-            Ok(len)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_to_end_capacity() -> io::Result<()> {\n-        let input = &b\"foo\"[..];\n-\n-        // read_to_end() generally needs to over-allocate, both for efficiency\n-        // and so that it can distinguish EOF. Assert that this is the case\n-        // with this simple ExampleSliceReader struct, which uses the default\n-        // implementation of read_to_end. Even though vec1 is allocated with\n-        // exactly enough capacity for the read, read_to_end will allocate more\n-        // space here.\n-        let mut vec1 = Vec::with_capacity(input.len());\n-        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n-        assert_eq!(vec1.len(), input.len());\n-        assert!(vec1.capacity() > input.len(), \"allocated more\");\n-\n-        // However, std::io::Take includes an implementation of read_to_end\n-        // that will not allocate when the limit has already been reached. In\n-        // this case, vec2 never grows.\n-        let mut vec2 = Vec::with_capacity(input.len());\n-        ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n-        assert_eq!(vec2.len(), input.len());\n-        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n-\n-        Ok(())\n-    }\n-\n-    #[test]\n-    fn io_slice_mut_advance() {\n-        let mut buf1 = [1; 8];\n-        let mut buf2 = [2; 16];\n-        let mut buf3 = [3; 8];\n-        let mut bufs = &mut [\n-            IoSliceMut::new(&mut buf1),\n-            IoSliceMut::new(&mut buf2),\n-            IoSliceMut::new(&mut buf3),\n-        ][..];\n-\n-        // Only in a single buffer..\n-        bufs = IoSliceMut::advance(bufs, 1);\n-        assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n-        assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n-        assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n-\n-        // Removing a buffer, leaving others as is.\n-        bufs = IoSliceMut::advance(bufs, 7);\n-        assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n-        assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n-\n-        // Removing a buffer and removing from the next buffer.\n-        bufs = IoSliceMut::advance(bufs, 18);\n-        assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n-    }\n-\n-    #[test]\n-    fn io_slice_mut_advance_empty_slice() {\n-        let empty_bufs = &mut [][..];\n-        // Shouldn't panic.\n-        IoSliceMut::advance(empty_bufs, 1);\n-    }\n-\n-    #[test]\n-    fn io_slice_mut_advance_beyond_total_length() {\n-        let mut buf1 = [1; 8];\n-        let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n-\n-        // Going beyond the total length should be ok.\n-        bufs = IoSliceMut::advance(bufs, 9);\n-        assert!(bufs.is_empty());\n-    }\n-\n-    #[test]\n-    fn io_slice_advance() {\n-        let buf1 = [1; 8];\n-        let buf2 = [2; 16];\n-        let buf3 = [3; 8];\n-        let mut bufs = &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n-\n-        // Only in a single buffer..\n-        bufs = IoSlice::advance(bufs, 1);\n-        assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n-        assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n-        assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n-\n-        // Removing a buffer, leaving others as is.\n-        bufs = IoSlice::advance(bufs, 7);\n-        assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n-        assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n-\n-        // Removing a buffer and removing from the next buffer.\n-        bufs = IoSlice::advance(bufs, 18);\n-        assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n-    }\n-\n-    #[test]\n-    fn io_slice_advance_empty_slice() {\n-        let empty_bufs = &mut [][..];\n-        // Shouldn't panic.\n-        IoSlice::advance(empty_bufs, 1);\n-    }\n-\n-    #[test]\n-    fn io_slice_advance_beyond_total_length() {\n-        let buf1 = [1; 8];\n-        let mut bufs = &mut [IoSlice::new(&buf1)][..];\n-\n-        // Going beyond the total length should be ok.\n-        bufs = IoSlice::advance(bufs, 9);\n-        assert!(bufs.is_empty());\n-    }\n-\n-    /// Create a new writer that reads from at most `n_bufs` and reads\n-    /// `per_call` bytes (in total) per call to write.\n-    fn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n-        TestWriter { n_bufs, per_call, written: Vec::new() }\n-    }\n-\n-    struct TestWriter {\n-        n_bufs: usize,\n-        per_call: usize,\n-        written: Vec<u8>,\n-    }\n-\n-    impl Write for TestWriter {\n-        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-            self.write_vectored(&[IoSlice::new(buf)])\n-        }\n-\n-        fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-            let mut left = self.per_call;\n-            let mut written = 0;\n-            for buf in bufs.iter().take(self.n_bufs) {\n-                let n = min(left, buf.len());\n-                self.written.extend_from_slice(&buf[0..n]);\n-                left -= n;\n-                written += n;\n-            }\n-            Ok(written)\n-        }\n-\n-        fn flush(&mut self) -> io::Result<()> {\n-            Ok(())\n-        }\n-    }\n-\n-    #[test]\n-    fn test_writer_read_from_one_buf() {\n-        let mut writer = test_writer(1, 2);\n-\n-        assert_eq!(writer.write(&[]).unwrap(), 0);\n-        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n-\n-        // Read at most 2 bytes.\n-        assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n-        let bufs = &[IoSlice::new(&[2, 2, 2])];\n-        assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n-\n-        // Only read from first buf.\n-        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n-        assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n-\n-        assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_writer_read_from_multiple_bufs() {\n-        let mut writer = test_writer(3, 3);\n-\n-        // Read at most 3 bytes from two buffers.\n-        let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n-        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n-\n-        // Read at most 3 bytes from three buffers.\n-        let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n-        assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n-\n-        assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n-    }\n-\n-    #[test]\n-    fn test_write_all_vectored() {\n-        #[rustfmt::skip] // Becomes unreadable otherwise.\n-        let tests: Vec<(_, &'static [u8])> = vec![\n-            (vec![], &[]),\n-            (vec![IoSlice::new(&[]), IoSlice::new(&[])], &[]),\n-            (vec![IoSlice::new(&[1])], &[1]),\n-            (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n-            (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n-            (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n-            (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n-            (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n-            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n-            (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n-            (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n-            (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n-            (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n-            (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n-        ];\n-\n-        let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n-\n-        for (n_bufs, per_call) in writer_configs.iter().copied() {\n-            for (mut input, wanted) in tests.clone().into_iter() {\n-                let mut writer = test_writer(n_bufs, per_call);\n-                assert!(writer.write_all_vectored(&mut *input).is_ok());\n-                assert_eq!(&*writer.written, &*wanted);\n-            }\n-        }\n-    }\n-}"}, {"sha": "9974b65f1e1645452c4ad04773f018540480f531", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,5 +1,8 @@\n #![cfg_attr(test, allow(unused))]\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::io::prelude::*;\n \n use crate::cell::RefCell;\n@@ -920,54 +923,3 @@ pub fn _eprint(args: fmt::Arguments<'_>) {\n \n #[cfg(test)]\n pub use realstd::io::{_eprint, _print};\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use crate::panic::{RefUnwindSafe, UnwindSafe};\n-    use crate::thread;\n-\n-    #[test]\n-    fn stdout_unwind_safe() {\n-        assert_unwind_safe::<Stdout>();\n-    }\n-    #[test]\n-    fn stdoutlock_unwind_safe() {\n-        assert_unwind_safe::<StdoutLock<'_>>();\n-        assert_unwind_safe::<StdoutLock<'static>>();\n-    }\n-    #[test]\n-    fn stderr_unwind_safe() {\n-        assert_unwind_safe::<Stderr>();\n-    }\n-    #[test]\n-    fn stderrlock_unwind_safe() {\n-        assert_unwind_safe::<StderrLock<'_>>();\n-        assert_unwind_safe::<StderrLock<'static>>();\n-    }\n-\n-    fn assert_unwind_safe<T: UnwindSafe + RefUnwindSafe>() {}\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn panic_doesnt_poison() {\n-        thread::spawn(|| {\n-            let _a = stdin();\n-            let _a = _a.lock();\n-            let _a = stdout();\n-            let _a = _a.lock();\n-            let _a = stderr();\n-            let _a = _a.lock();\n-            panic!();\n-        })\n-        .join()\n-        .unwrap_err();\n-\n-        let _a = stdin();\n-        let _a = _a.lock();\n-        let _a = stdout();\n-        let _a = _a.lock();\n-        let _a = stderr();\n-        let _a = _a.lock();\n-    }\n-}"}, {"sha": "04af500268f97ec8d38a570b1da2574774d5f982", "filename": "library/std/src/io/stdio/tests.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,47 @@\n+use super::*;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::thread;\n+\n+#[test]\n+fn stdout_unwind_safe() {\n+    assert_unwind_safe::<Stdout>();\n+}\n+#[test]\n+fn stdoutlock_unwind_safe() {\n+    assert_unwind_safe::<StdoutLock<'_>>();\n+    assert_unwind_safe::<StdoutLock<'static>>();\n+}\n+#[test]\n+fn stderr_unwind_safe() {\n+    assert_unwind_safe::<Stderr>();\n+}\n+#[test]\n+fn stderrlock_unwind_safe() {\n+    assert_unwind_safe::<StderrLock<'_>>();\n+    assert_unwind_safe::<StderrLock<'static>>();\n+}\n+\n+fn assert_unwind_safe<T: UnwindSafe + RefUnwindSafe>() {}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn panic_doesnt_poison() {\n+    thread::spawn(|| {\n+        let _a = stdin();\n+        let _a = _a.lock();\n+        let _a = stdout();\n+        let _a = _a.lock();\n+        let _a = stderr();\n+        let _a = _a.lock();\n+        panic!();\n+    })\n+    .join()\n+    .unwrap_err();\n+\n+    let _a = stdin();\n+    let _a = _a.lock();\n+    let _a = stdout();\n+    let _a = _a.lock();\n+    let _a = stderr();\n+    let _a = _a.lock();\n+}"}, {"sha": "913b28538b7c4d2c63329954006901b621dea6fd", "filename": "library/std/src/io/tests.rs", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,494 @@\n+use super::{repeat, Cursor, SeekFrom};\n+use crate::cmp::{self, min};\n+use crate::io::prelude::*;\n+use crate::io::{self, IoSlice, IoSliceMut};\n+use crate::ops::Deref;\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn read_until() {\n+    let mut buf = Cursor::new(&b\"12\"[..]);\n+    let mut v = Vec::new();\n+    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 2);\n+    assert_eq!(v, b\"12\");\n+\n+    let mut buf = Cursor::new(&b\"1233\"[..]);\n+    let mut v = Vec::new();\n+    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 3);\n+    assert_eq!(v, b\"123\");\n+    v.truncate(0);\n+    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 1);\n+    assert_eq!(v, b\"3\");\n+    v.truncate(0);\n+    assert_eq!(buf.read_until(b'3', &mut v).unwrap(), 0);\n+    assert_eq!(v, []);\n+}\n+\n+#[test]\n+fn split() {\n+    let buf = Cursor::new(&b\"12\"[..]);\n+    let mut s = buf.split(b'3');\n+    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n+    assert!(s.next().is_none());\n+\n+    let buf = Cursor::new(&b\"1233\"[..]);\n+    let mut s = buf.split(b'3');\n+    assert_eq!(s.next().unwrap().unwrap(), vec![b'1', b'2']);\n+    assert_eq!(s.next().unwrap().unwrap(), vec![]);\n+    assert!(s.next().is_none());\n+}\n+\n+#[test]\n+fn read_line() {\n+    let mut buf = Cursor::new(&b\"12\"[..]);\n+    let mut v = String::new();\n+    assert_eq!(buf.read_line(&mut v).unwrap(), 2);\n+    assert_eq!(v, \"12\");\n+\n+    let mut buf = Cursor::new(&b\"12\\n\\n\"[..]);\n+    let mut v = String::new();\n+    assert_eq!(buf.read_line(&mut v).unwrap(), 3);\n+    assert_eq!(v, \"12\\n\");\n+    v.truncate(0);\n+    assert_eq!(buf.read_line(&mut v).unwrap(), 1);\n+    assert_eq!(v, \"\\n\");\n+    v.truncate(0);\n+    assert_eq!(buf.read_line(&mut v).unwrap(), 0);\n+    assert_eq!(v, \"\");\n+}\n+\n+#[test]\n+fn lines() {\n+    let buf = Cursor::new(&b\"12\\r\"[..]);\n+    let mut s = buf.lines();\n+    assert_eq!(s.next().unwrap().unwrap(), \"12\\r\".to_string());\n+    assert!(s.next().is_none());\n+\n+    let buf = Cursor::new(&b\"12\\r\\n\\n\"[..]);\n+    let mut s = buf.lines();\n+    assert_eq!(s.next().unwrap().unwrap(), \"12\".to_string());\n+    assert_eq!(s.next().unwrap().unwrap(), \"\".to_string());\n+    assert!(s.next().is_none());\n+}\n+\n+#[test]\n+fn read_to_end() {\n+    let mut c = Cursor::new(&b\"\"[..]);\n+    let mut v = Vec::new();\n+    assert_eq!(c.read_to_end(&mut v).unwrap(), 0);\n+    assert_eq!(v, []);\n+\n+    let mut c = Cursor::new(&b\"1\"[..]);\n+    let mut v = Vec::new();\n+    assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n+    assert_eq!(v, b\"1\");\n+\n+    let cap = 1024 * 1024;\n+    let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n+    let mut v = Vec::new();\n+    let (a, b) = data.split_at(data.len() / 2);\n+    assert_eq!(Cursor::new(a).read_to_end(&mut v).unwrap(), a.len());\n+    assert_eq!(Cursor::new(b).read_to_end(&mut v).unwrap(), b.len());\n+    assert_eq!(v, data);\n+}\n+\n+#[test]\n+fn read_to_string() {\n+    let mut c = Cursor::new(&b\"\"[..]);\n+    let mut v = String::new();\n+    assert_eq!(c.read_to_string(&mut v).unwrap(), 0);\n+    assert_eq!(v, \"\");\n+\n+    let mut c = Cursor::new(&b\"1\"[..]);\n+    let mut v = String::new();\n+    assert_eq!(c.read_to_string(&mut v).unwrap(), 1);\n+    assert_eq!(v, \"1\");\n+\n+    let mut c = Cursor::new(&b\"\\xff\"[..]);\n+    let mut v = String::new();\n+    assert!(c.read_to_string(&mut v).is_err());\n+}\n+\n+#[test]\n+fn read_exact() {\n+    let mut buf = [0; 4];\n+\n+    let mut c = Cursor::new(&b\"\"[..]);\n+    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+\n+    let mut c = Cursor::new(&b\"123\"[..]).chain(Cursor::new(&b\"456789\"[..]));\n+    c.read_exact(&mut buf).unwrap();\n+    assert_eq!(&buf, b\"1234\");\n+    c.read_exact(&mut buf).unwrap();\n+    assert_eq!(&buf, b\"5678\");\n+    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+}\n+\n+#[test]\n+fn read_exact_slice() {\n+    let mut buf = [0; 4];\n+\n+    let mut c = &b\"\"[..];\n+    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+\n+    let mut c = &b\"123\"[..];\n+    assert_eq!(c.read_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    // make sure the optimized (early returning) method is being used\n+    assert_eq!(&buf, &[0; 4]);\n+\n+    let mut c = &b\"1234\"[..];\n+    c.read_exact(&mut buf).unwrap();\n+    assert_eq!(&buf, b\"1234\");\n+\n+    let mut c = &b\"56789\"[..];\n+    c.read_exact(&mut buf).unwrap();\n+    assert_eq!(&buf, b\"5678\");\n+    assert_eq!(c, b\"9\");\n+}\n+\n+#[test]\n+fn take_eof() {\n+    struct R;\n+\n+    impl Read for R {\n+        fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n+            Err(io::Error::new(io::ErrorKind::Other, \"\"))\n+        }\n+    }\n+    impl BufRead for R {\n+        fn fill_buf(&mut self) -> io::Result<&[u8]> {\n+            Err(io::Error::new(io::ErrorKind::Other, \"\"))\n+        }\n+        fn consume(&mut self, _amt: usize) {}\n+    }\n+\n+    let mut buf = [0; 1];\n+    assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n+    assert_eq!(b\"\", R.take(0).fill_buf().unwrap());\n+}\n+\n+fn cmp_bufread<Br1: BufRead, Br2: BufRead>(mut br1: Br1, mut br2: Br2, exp: &[u8]) {\n+    let mut cat = Vec::new();\n+    loop {\n+        let consume = {\n+            let buf1 = br1.fill_buf().unwrap();\n+            let buf2 = br2.fill_buf().unwrap();\n+            let minlen = if buf1.len() < buf2.len() { buf1.len() } else { buf2.len() };\n+            assert_eq!(buf1[..minlen], buf2[..minlen]);\n+            cat.extend_from_slice(&buf1[..minlen]);\n+            minlen\n+        };\n+        if consume == 0 {\n+            break;\n+        }\n+        br1.consume(consume);\n+        br2.consume(consume);\n+    }\n+    assert_eq!(br1.fill_buf().unwrap().len(), 0);\n+    assert_eq!(br2.fill_buf().unwrap().len(), 0);\n+    assert_eq!(&cat[..], &exp[..])\n+}\n+\n+#[test]\n+fn chain_bufread() {\n+    let testdata = b\"ABCDEFGHIJKL\";\n+    let chain1 =\n+        (&testdata[..3]).chain(&testdata[3..6]).chain(&testdata[6..9]).chain(&testdata[9..]);\n+    let chain2 = (&testdata[..4]).chain(&testdata[4..8]).chain(&testdata[8..]);\n+    cmp_bufread(chain1, chain2, &testdata[..]);\n+}\n+\n+#[test]\n+fn chain_zero_length_read_is_not_eof() {\n+    let a = b\"A\";\n+    let b = b\"B\";\n+    let mut s = String::new();\n+    let mut chain = (&a[..]).chain(&b[..]);\n+    chain.read(&mut []).unwrap();\n+    chain.read_to_string(&mut s).unwrap();\n+    assert_eq!(\"AB\", s);\n+}\n+\n+#[bench]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn bench_read_to_end(b: &mut test::Bencher) {\n+    b.iter(|| {\n+        let mut lr = repeat(1).take(10000000);\n+        let mut vec = Vec::with_capacity(1024);\n+        super::read_to_end(&mut lr, &mut vec)\n+    });\n+}\n+\n+#[test]\n+fn seek_len() -> io::Result<()> {\n+    let mut c = Cursor::new(vec![0; 15]);\n+    assert_eq!(c.stream_len()?, 15);\n+\n+    c.seek(SeekFrom::End(0))?;\n+    let old_pos = c.stream_position()?;\n+    assert_eq!(c.stream_len()?, 15);\n+    assert_eq!(c.stream_position()?, old_pos);\n+\n+    c.seek(SeekFrom::Start(7))?;\n+    c.seek(SeekFrom::Current(2))?;\n+    let old_pos = c.stream_position()?;\n+    assert_eq!(c.stream_len()?, 15);\n+    assert_eq!(c.stream_position()?, old_pos);\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn seek_position() -> io::Result<()> {\n+    // All `asserts` are duplicated here to make sure the method does not\n+    // change anything about the seek state.\n+    let mut c = Cursor::new(vec![0; 15]);\n+    assert_eq!(c.stream_position()?, 0);\n+    assert_eq!(c.stream_position()?, 0);\n+\n+    c.seek(SeekFrom::End(0))?;\n+    assert_eq!(c.stream_position()?, 15);\n+    assert_eq!(c.stream_position()?, 15);\n+\n+    c.seek(SeekFrom::Start(7))?;\n+    c.seek(SeekFrom::Current(2))?;\n+    assert_eq!(c.stream_position()?, 9);\n+    assert_eq!(c.stream_position()?, 9);\n+\n+    c.seek(SeekFrom::End(-3))?;\n+    c.seek(SeekFrom::Current(1))?;\n+    c.seek(SeekFrom::Current(-5))?;\n+    assert_eq!(c.stream_position()?, 8);\n+    assert_eq!(c.stream_position()?, 8);\n+\n+    Ok(())\n+}\n+\n+// A simple example reader which uses the default implementation of\n+// read_to_end.\n+struct ExampleSliceReader<'a> {\n+    slice: &'a [u8],\n+}\n+\n+impl<'a> Read for ExampleSliceReader<'a> {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        let len = cmp::min(self.slice.len(), buf.len());\n+        buf[..len].copy_from_slice(&self.slice[..len]);\n+        self.slice = &self.slice[len..];\n+        Ok(len)\n+    }\n+}\n+\n+#[test]\n+fn test_read_to_end_capacity() -> io::Result<()> {\n+    let input = &b\"foo\"[..];\n+\n+    // read_to_end() generally needs to over-allocate, both for efficiency\n+    // and so that it can distinguish EOF. Assert that this is the case\n+    // with this simple ExampleSliceReader struct, which uses the default\n+    // implementation of read_to_end. Even though vec1 is allocated with\n+    // exactly enough capacity for the read, read_to_end will allocate more\n+    // space here.\n+    let mut vec1 = Vec::with_capacity(input.len());\n+    ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+    assert_eq!(vec1.len(), input.len());\n+    assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+    // However, std::io::Take includes an implementation of read_to_end\n+    // that will not allocate when the limit has already been reached. In\n+    // this case, vec2 never grows.\n+    let mut vec2 = Vec::with_capacity(input.len());\n+    ExampleSliceReader { slice: input }.take(input.len() as u64).read_to_end(&mut vec2)?;\n+    assert_eq!(vec2.len(), input.len());\n+    assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn io_slice_mut_advance() {\n+    let mut buf1 = [1; 8];\n+    let mut buf2 = [2; 16];\n+    let mut buf3 = [3; 8];\n+    let mut bufs = &mut [\n+        IoSliceMut::new(&mut buf1),\n+        IoSliceMut::new(&mut buf2),\n+        IoSliceMut::new(&mut buf3),\n+    ][..];\n+\n+    // Only in a single buffer..\n+    bufs = IoSliceMut::advance(bufs, 1);\n+    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n+    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n+    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n+\n+    // Removing a buffer, leaving others as is.\n+    bufs = IoSliceMut::advance(bufs, 7);\n+    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n+    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+\n+    // Removing a buffer and removing from the next buffer.\n+    bufs = IoSliceMut::advance(bufs, 18);\n+    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n+}\n+\n+#[test]\n+fn io_slice_mut_advance_empty_slice() {\n+    let empty_bufs = &mut [][..];\n+    // Shouldn't panic.\n+    IoSliceMut::advance(empty_bufs, 1);\n+}\n+\n+#[test]\n+fn io_slice_mut_advance_beyond_total_length() {\n+    let mut buf1 = [1; 8];\n+    let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n+\n+    // Going beyond the total length should be ok.\n+    bufs = IoSliceMut::advance(bufs, 9);\n+    assert!(bufs.is_empty());\n+}\n+\n+#[test]\n+fn io_slice_advance() {\n+    let buf1 = [1; 8];\n+    let buf2 = [2; 16];\n+    let buf3 = [3; 8];\n+    let mut bufs = &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n+\n+    // Only in a single buffer..\n+    bufs = IoSlice::advance(bufs, 1);\n+    assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n+    assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n+    assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n+\n+    // Removing a buffer, leaving others as is.\n+    bufs = IoSlice::advance(bufs, 7);\n+    assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n+    assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n+\n+    // Removing a buffer and removing from the next buffer.\n+    bufs = IoSlice::advance(bufs, 18);\n+    assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n+}\n+\n+#[test]\n+fn io_slice_advance_empty_slice() {\n+    let empty_bufs = &mut [][..];\n+    // Shouldn't panic.\n+    IoSlice::advance(empty_bufs, 1);\n+}\n+\n+#[test]\n+fn io_slice_advance_beyond_total_length() {\n+    let buf1 = [1; 8];\n+    let mut bufs = &mut [IoSlice::new(&buf1)][..];\n+\n+    // Going beyond the total length should be ok.\n+    bufs = IoSlice::advance(bufs, 9);\n+    assert!(bufs.is_empty());\n+}\n+\n+/// Create a new writer that reads from at most `n_bufs` and reads\n+/// `per_call` bytes (in total) per call to write.\n+fn test_writer(n_bufs: usize, per_call: usize) -> TestWriter {\n+    TestWriter { n_bufs, per_call, written: Vec::new() }\n+}\n+\n+struct TestWriter {\n+    n_bufs: usize,\n+    per_call: usize,\n+    written: Vec<u8>,\n+}\n+\n+impl Write for TestWriter {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.write_vectored(&[IoSlice::new(buf)])\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let mut left = self.per_call;\n+        let mut written = 0;\n+        for buf in bufs.iter().take(self.n_bufs) {\n+            let n = min(left, buf.len());\n+            self.written.extend_from_slice(&buf[0..n]);\n+            left -= n;\n+            written += n;\n+        }\n+        Ok(written)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[test]\n+fn test_writer_read_from_one_buf() {\n+    let mut writer = test_writer(1, 2);\n+\n+    assert_eq!(writer.write(&[]).unwrap(), 0);\n+    assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n+\n+    // Read at most 2 bytes.\n+    assert_eq!(writer.write(&[1, 1, 1]).unwrap(), 2);\n+    let bufs = &[IoSlice::new(&[2, 2, 2])];\n+    assert_eq!(writer.write_vectored(bufs).unwrap(), 2);\n+\n+    // Only read from first buf.\n+    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4, 4])];\n+    assert_eq!(writer.write_vectored(bufs).unwrap(), 1);\n+\n+    assert_eq!(writer.written, &[1, 1, 2, 2, 3]);\n+}\n+\n+#[test]\n+fn test_writer_read_from_multiple_bufs() {\n+    let mut writer = test_writer(3, 3);\n+\n+    // Read at most 3 bytes from two buffers.\n+    let bufs = &[IoSlice::new(&[1]), IoSlice::new(&[2, 2, 2])];\n+    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+    // Read at most 3 bytes from three buffers.\n+    let bufs = &[IoSlice::new(&[3]), IoSlice::new(&[4]), IoSlice::new(&[5, 5])];\n+    assert_eq!(writer.write_vectored(bufs).unwrap(), 3);\n+\n+    assert_eq!(writer.written, &[1, 2, 2, 3, 4, 5]);\n+}\n+\n+#[test]\n+fn test_write_all_vectored() {\n+    #[rustfmt::skip] // Becomes unreadable otherwise.\n+    let tests: Vec<(_, &'static [u8])> = vec![\n+        (vec![], &[]),\n+        (vec![IoSlice::new(&[]), IoSlice::new(&[])], &[]),\n+        (vec![IoSlice::new(&[1])], &[1]),\n+        (vec![IoSlice::new(&[1, 2])], &[1, 2]),\n+        (vec![IoSlice::new(&[1, 2, 3])], &[1, 2, 3]),\n+        (vec![IoSlice::new(&[1, 2, 3, 4])], &[1, 2, 3, 4]),\n+        (vec![IoSlice::new(&[1, 2, 3, 4, 5])], &[1, 2, 3, 4, 5]),\n+        (vec![IoSlice::new(&[1]), IoSlice::new(&[2])], &[1, 2]),\n+        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2])], &[1, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2])], &[1, 1, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 2, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2])], &[1, 1, 1, 2, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 2, 2, 2, 2]),\n+        (vec![IoSlice::new(&[1, 1, 1, 1]), IoSlice::new(&[2, 2, 2, 2])], &[1, 1, 1, 1, 2, 2, 2, 2]),\n+        (vec![IoSlice::new(&[1]), IoSlice::new(&[2]), IoSlice::new(&[3])], &[1, 2, 3]),\n+        (vec![IoSlice::new(&[1, 1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3])], &[1, 1, 2, 2, 3, 3]),\n+        (vec![IoSlice::new(&[1]), IoSlice::new(&[2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 2, 2, 3, 3, 3]),\n+        (vec![IoSlice::new(&[1, 1, 1]), IoSlice::new(&[2, 2, 2]), IoSlice::new(&[3, 3, 3])], &[1, 1, 1, 2, 2, 2, 3, 3, 3]),\n+    ];\n+\n+    let writer_configs = &[(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)];\n+\n+    for (n_bufs, per_call) in writer_configs.iter().copied() {\n+        for (mut input, wanted) in tests.clone().into_iter() {\n+            let mut writer = test_writer(n_bufs, per_call);\n+            assert!(writer.write_all_vectored(&mut *input).is_ok());\n+            assert_eq!(&*writer.written, &*wanted);\n+        }\n+    }\n+}"}, {"sha": "bf289fe040edfb5de6970ac20ec9f82ed38948a0", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,5 +1,8 @@\n #![allow(missing_copy_implementations)]\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::fmt;\n use crate::io::{self, BufRead, ErrorKind, Initializer, IoSlice, IoSliceMut, Read, Write};\n use crate::mem::MaybeUninit;\n@@ -254,52 +257,3 @@ impl fmt::Debug for Sink {\n         f.pad(\"Sink { .. }\")\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::io::prelude::*;\n-    use crate::io::{copy, empty, repeat, sink};\n-\n-    #[test]\n-    fn copy_copies() {\n-        let mut r = repeat(0).take(4);\n-        let mut w = sink();\n-        assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n-\n-        let mut r = repeat(0).take(1 << 17);\n-        assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n-    }\n-\n-    #[test]\n-    fn sink_sinks() {\n-        let mut s = sink();\n-        assert_eq!(s.write(&[]).unwrap(), 0);\n-        assert_eq!(s.write(&[0]).unwrap(), 1);\n-        assert_eq!(s.write(&[0; 1024]).unwrap(), 1024);\n-        assert_eq!(s.by_ref().write(&[0; 1024]).unwrap(), 1024);\n-    }\n-\n-    #[test]\n-    fn empty_reads() {\n-        let mut e = empty();\n-        assert_eq!(e.read(&mut []).unwrap(), 0);\n-        assert_eq!(e.read(&mut [0]).unwrap(), 0);\n-        assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n-        assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n-    }\n-\n-    #[test]\n-    fn repeat_repeats() {\n-        let mut r = repeat(4);\n-        let mut b = [0; 1024];\n-        assert_eq!(r.read(&mut b).unwrap(), 1024);\n-        assert!(b.iter().all(|b| *b == 4));\n-    }\n-\n-    #[test]\n-    fn take_some_bytes() {\n-        assert_eq!(repeat(4).take(100).bytes().count(), 100);\n-        assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n-        assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n-    }\n-}"}, {"sha": "e5e32ecb40531fee4e60fb51396b27fb5091f142", "filename": "library/std/src/io/util/tests.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,45 @@\n+use crate::io::prelude::*;\n+use crate::io::{copy, empty, repeat, sink};\n+\n+#[test]\n+fn copy_copies() {\n+    let mut r = repeat(0).take(4);\n+    let mut w = sink();\n+    assert_eq!(copy(&mut r, &mut w).unwrap(), 4);\n+\n+    let mut r = repeat(0).take(1 << 17);\n+    assert_eq!(copy(&mut r as &mut dyn Read, &mut w as &mut dyn Write).unwrap(), 1 << 17);\n+}\n+\n+#[test]\n+fn sink_sinks() {\n+    let mut s = sink();\n+    assert_eq!(s.write(&[]).unwrap(), 0);\n+    assert_eq!(s.write(&[0]).unwrap(), 1);\n+    assert_eq!(s.write(&[0; 1024]).unwrap(), 1024);\n+    assert_eq!(s.by_ref().write(&[0; 1024]).unwrap(), 1024);\n+}\n+\n+#[test]\n+fn empty_reads() {\n+    let mut e = empty();\n+    assert_eq!(e.read(&mut []).unwrap(), 0);\n+    assert_eq!(e.read(&mut [0]).unwrap(), 0);\n+    assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n+    assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n+}\n+\n+#[test]\n+fn repeat_repeats() {\n+    let mut r = repeat(4);\n+    let mut b = [0; 1024];\n+    assert_eq!(r.read(&mut b).unwrap(), 1024);\n+    assert!(b.iter().all(|b| *b == 4));\n+}\n+\n+#[test]\n+fn take_some_bytes() {\n+    assert_eq!(repeat(4).take(100).bytes().count(), 100);\n+    assert_eq!(repeat(4).take(100).bytes().next().unwrap().unwrap(), 4);\n+    assert_eq!(repeat(1).take(10).chain(repeat(2).take(10)).bytes().count(), 20);\n+}"}, {"sha": "1129f29e949410fca975c6d15b269e17c23d262d", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 3, "deletions": 330, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,5 +1,8 @@\n //! Lazy values and one-time initialization of static data.\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::{\n     cell::{Cell, UnsafeCell},\n     fmt,\n@@ -506,333 +509,3 @@ impl<T: Default> Default for SyncLazy<T> {\n         SyncLazy::new(T::default)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::{\n-        lazy::{Lazy, SyncLazy, SyncOnceCell},\n-        panic,\n-        sync::{\n-            atomic::{AtomicUsize, Ordering::SeqCst},\n-            mpsc::channel,\n-            Mutex,\n-        },\n-        thread,\n-    };\n-\n-    #[test]\n-    fn lazy_default() {\n-        static CALLED: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct Foo(u8);\n-        impl Default for Foo {\n-            fn default() -> Self {\n-                CALLED.fetch_add(1, SeqCst);\n-                Foo(42)\n-            }\n-        }\n-\n-        let lazy: Lazy<Mutex<Foo>> = <_>::default();\n-\n-        assert_eq!(CALLED.load(SeqCst), 0);\n-\n-        assert_eq!(lazy.lock().unwrap().0, 42);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-\n-        lazy.lock().unwrap().0 = 21;\n-\n-        assert_eq!(lazy.lock().unwrap().0, 21);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-    }\n-\n-    #[test]\n-    fn lazy_poisoning() {\n-        let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n-        for _ in 0..2 {\n-            let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n-        thread::spawn(f).join().unwrap()\n-    }\n-\n-    #[test]\n-    fn sync_once_cell() {\n-        static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n-\n-        assert!(ONCE_CELL.get().is_none());\n-\n-        spawn_and_wait(|| {\n-            ONCE_CELL.get_or_init(|| 92);\n-            assert_eq!(ONCE_CELL.get(), Some(&92));\n-        });\n-\n-        ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n-        assert_eq!(ONCE_CELL.get(), Some(&92));\n-    }\n-\n-    #[test]\n-    fn sync_once_cell_get_mut() {\n-        let mut c = SyncOnceCell::new();\n-        assert!(c.get_mut().is_none());\n-        c.set(90).unwrap();\n-        *c.get_mut().unwrap() += 2;\n-        assert_eq!(c.get_mut(), Some(&mut 92));\n-    }\n-\n-    #[test]\n-    fn sync_once_cell_get_unchecked() {\n-        let c = SyncOnceCell::new();\n-        c.set(92).unwrap();\n-        unsafe {\n-            assert_eq!(c.get_unchecked(), &92);\n-        }\n-    }\n-\n-    #[test]\n-    fn sync_once_cell_drop() {\n-        static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n-        struct Dropper;\n-        impl Drop for Dropper {\n-            fn drop(&mut self) {\n-                DROP_CNT.fetch_add(1, SeqCst);\n-            }\n-        }\n-\n-        let x = SyncOnceCell::new();\n-        spawn_and_wait(move || {\n-            x.get_or_init(|| Dropper);\n-            assert_eq!(DROP_CNT.load(SeqCst), 0);\n-            drop(x);\n-        });\n-\n-        assert_eq!(DROP_CNT.load(SeqCst), 1);\n-    }\n-\n-    #[test]\n-    fn sync_once_cell_drop_empty() {\n-        let x = SyncOnceCell::<String>::new();\n-        drop(x);\n-    }\n-\n-    #[test]\n-    fn clone() {\n-        let s = SyncOnceCell::new();\n-        let c = s.clone();\n-        assert!(c.get().is_none());\n-\n-        s.set(\"hello\".to_string()).unwrap();\n-        let c = s.clone();\n-        assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n-    }\n-\n-    #[test]\n-    fn get_or_try_init() {\n-        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n-        assert!(cell.get().is_none());\n-\n-        let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n-        assert!(res.is_err());\n-        assert!(!cell.is_initialized());\n-        assert!(cell.get().is_none());\n-\n-        assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n-\n-        assert_eq!(\n-            cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())),\n-            Ok(&\"hello\".to_string())\n-        );\n-        assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n-    }\n-\n-    #[test]\n-    fn from_impl() {\n-        assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n-        assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n-    }\n-\n-    #[test]\n-    fn partialeq_impl() {\n-        assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n-        assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n-\n-        assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n-        assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n-    }\n-\n-    #[test]\n-    fn into_inner() {\n-        let cell: SyncOnceCell<String> = SyncOnceCell::new();\n-        assert_eq!(cell.into_inner(), None);\n-        let cell = SyncOnceCell::new();\n-        cell.set(\"hello\".to_string()).unwrap();\n-        assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n-    }\n-\n-    #[test]\n-    fn sync_lazy_new() {\n-        static CALLED: AtomicUsize = AtomicUsize::new(0);\n-        static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n-            CALLED.fetch_add(1, SeqCst);\n-            92\n-        });\n-\n-        assert_eq!(CALLED.load(SeqCst), 0);\n-\n-        spawn_and_wait(|| {\n-            let y = *SYNC_LAZY - 30;\n-            assert_eq!(y, 62);\n-            assert_eq!(CALLED.load(SeqCst), 1);\n-        });\n-\n-        let y = *SYNC_LAZY - 30;\n-        assert_eq!(y, 62);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-    }\n-\n-    #[test]\n-    fn sync_lazy_default() {\n-        static CALLED: AtomicUsize = AtomicUsize::new(0);\n-\n-        struct Foo(u8);\n-        impl Default for Foo {\n-            fn default() -> Self {\n-                CALLED.fetch_add(1, SeqCst);\n-                Foo(42)\n-            }\n-        }\n-\n-        let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n-\n-        assert_eq!(CALLED.load(SeqCst), 0);\n-\n-        assert_eq!(lazy.lock().unwrap().0, 42);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-\n-        lazy.lock().unwrap().0 = 21;\n-\n-        assert_eq!(lazy.lock().unwrap().0, 21);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-    }\n-\n-    #[test]\n-    fn static_sync_lazy() {\n-        static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n-            let mut xs = Vec::new();\n-            xs.push(1);\n-            xs.push(2);\n-            xs.push(3);\n-            xs\n-        });\n-\n-        spawn_and_wait(|| {\n-            assert_eq!(&*XS, &vec![1, 2, 3]);\n-        });\n-\n-        assert_eq!(&*XS, &vec![1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn static_sync_lazy_via_fn() {\n-        fn xs() -> &'static Vec<i32> {\n-            static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n-            XS.get_or_init(|| {\n-                let mut xs = Vec::new();\n-                xs.push(1);\n-                xs.push(2);\n-                xs.push(3);\n-                xs\n-            })\n-        }\n-        assert_eq!(xs(), &vec![1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn sync_lazy_poisoning() {\n-        let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n-        for _ in 0..2 {\n-            let res = panic::catch_unwind(|| x.len());\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn is_sync_send() {\n-        fn assert_traits<T: Send + Sync>() {}\n-        assert_traits::<SyncOnceCell<String>>();\n-        assert_traits::<SyncLazy<String>>();\n-    }\n-\n-    #[test]\n-    fn eval_once_macro() {\n-        macro_rules! eval_once {\n-            (|| -> $ty:ty {\n-                $($body:tt)*\n-            }) => {{\n-                static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n-                fn init() -> $ty {\n-                    $($body)*\n-                }\n-                ONCE_CELL.get_or_init(init)\n-            }};\n-        }\n-\n-        let fib: &'static Vec<i32> = eval_once! {\n-            || -> Vec<i32> {\n-                let mut res = vec![1, 1];\n-                for i in 0..10 {\n-                    let next = res[i] + res[i + 1];\n-                    res.push(next);\n-                }\n-                res\n-            }\n-        };\n-        assert_eq!(fib[5], 8)\n-    }\n-\n-    #[test]\n-    fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n-        static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n-\n-        let n_readers = 10;\n-        let n_writers = 3;\n-        const MSG: &str = \"Hello, World\";\n-\n-        let (tx, rx) = channel();\n-\n-        for _ in 0..n_readers {\n-            let tx = tx.clone();\n-            thread::spawn(move || {\n-                loop {\n-                    if let Some(msg) = ONCE_CELL.get() {\n-                        tx.send(msg).unwrap();\n-                        break;\n-                    }\n-                    #[cfg(target_env = \"sgx\")]\n-                    crate::thread::yield_now();\n-                }\n-            });\n-        }\n-        for _ in 0..n_writers {\n-            thread::spawn(move || {\n-                let _ = ONCE_CELL.set(MSG.to_owned());\n-            });\n-        }\n-\n-        for _ in 0..n_readers {\n-            let msg = rx.recv().unwrap();\n-            assert_eq!(msg, MSG);\n-        }\n-    }\n-\n-    #[test]\n-    fn dropck() {\n-        let cell = SyncOnceCell::new();\n-        {\n-            let s = String::new();\n-            cell.set(&s).unwrap();\n-        }\n-    }\n-}"}, {"sha": "a170edbd997ddb9287723433d931813c9ecdbfd6", "filename": "library/std/src/lazy/tests.rs", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,323 @@\n+use crate::{\n+    lazy::{Lazy, SyncLazy, SyncOnceCell},\n+    panic,\n+    sync::{\n+        atomic::{AtomicUsize, Ordering::SeqCst},\n+        mpsc::channel,\n+        Mutex,\n+    },\n+    thread,\n+};\n+\n+#[test]\n+fn lazy_default() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct Foo(u8);\n+    impl Default for Foo {\n+        fn default() -> Self {\n+            CALLED.fetch_add(1, SeqCst);\n+            Foo(42)\n+        }\n+    }\n+\n+    let lazy: Lazy<Mutex<Foo>> = <_>::default();\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    assert_eq!(lazy.lock().unwrap().0, 42);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+\n+    lazy.lock().unwrap().0 = 21;\n+\n+    assert_eq!(lazy.lock().unwrap().0, 21);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn lazy_poisoning() {\n+    let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n+    for _ in 0..2 {\n+        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n+        assert!(res.is_err());\n+    }\n+}\n+\n+fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+    thread::spawn(f).join().unwrap()\n+}\n+\n+#[test]\n+fn sync_once_cell() {\n+    static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+\n+    assert!(ONCE_CELL.get().is_none());\n+\n+    spawn_and_wait(|| {\n+        ONCE_CELL.get_or_init(|| 92);\n+        assert_eq!(ONCE_CELL.get(), Some(&92));\n+    });\n+\n+    ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n+    assert_eq!(ONCE_CELL.get(), Some(&92));\n+}\n+\n+#[test]\n+fn sync_once_cell_get_mut() {\n+    let mut c = SyncOnceCell::new();\n+    assert!(c.get_mut().is_none());\n+    c.set(90).unwrap();\n+    *c.get_mut().unwrap() += 2;\n+    assert_eq!(c.get_mut(), Some(&mut 92));\n+}\n+\n+#[test]\n+fn sync_once_cell_get_unchecked() {\n+    let c = SyncOnceCell::new();\n+    c.set(92).unwrap();\n+    unsafe {\n+        assert_eq!(c.get_unchecked(), &92);\n+    }\n+}\n+\n+#[test]\n+fn sync_once_cell_drop() {\n+    static DROP_CNT: AtomicUsize = AtomicUsize::new(0);\n+    struct Dropper;\n+    impl Drop for Dropper {\n+        fn drop(&mut self) {\n+            DROP_CNT.fetch_add(1, SeqCst);\n+        }\n+    }\n+\n+    let x = SyncOnceCell::new();\n+    spawn_and_wait(move || {\n+        x.get_or_init(|| Dropper);\n+        assert_eq!(DROP_CNT.load(SeqCst), 0);\n+        drop(x);\n+    });\n+\n+    assert_eq!(DROP_CNT.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn sync_once_cell_drop_empty() {\n+    let x = SyncOnceCell::<String>::new();\n+    drop(x);\n+}\n+\n+#[test]\n+fn clone() {\n+    let s = SyncOnceCell::new();\n+    let c = s.clone();\n+    assert!(c.get().is_none());\n+\n+    s.set(\"hello\".to_string()).unwrap();\n+    let c = s.clone();\n+    assert_eq!(c.get().map(String::as_str), Some(\"hello\"));\n+}\n+\n+#[test]\n+fn get_or_try_init() {\n+    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    assert!(cell.get().is_none());\n+\n+    let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n+    assert!(res.is_err());\n+    assert!(!cell.is_initialized());\n+    assert!(cell.get().is_none());\n+\n+    assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+\n+    assert_eq!(cell.get_or_try_init(|| Ok::<_, ()>(\"hello\".to_string())), Ok(&\"hello\".to_string()));\n+    assert_eq!(cell.get(), Some(&\"hello\".to_string()));\n+}\n+\n+#[test]\n+fn from_impl() {\n+    assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n+    assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+}\n+\n+#[test]\n+fn partialeq_impl() {\n+    assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n+    assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n+\n+    assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n+    assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n+}\n+\n+#[test]\n+fn into_inner() {\n+    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    assert_eq!(cell.into_inner(), None);\n+    let cell = SyncOnceCell::new();\n+    cell.set(\"hello\".to_string()).unwrap();\n+    assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+}\n+\n+#[test]\n+fn sync_lazy_new() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+    static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n+        CALLED.fetch_add(1, SeqCst);\n+        92\n+    });\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    spawn_and_wait(|| {\n+        let y = *SYNC_LAZY - 30;\n+        assert_eq!(y, 62);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    });\n+\n+    let y = *SYNC_LAZY - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn sync_lazy_default() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct Foo(u8);\n+    impl Default for Foo {\n+        fn default() -> Self {\n+            CALLED.fetch_add(1, SeqCst);\n+            Foo(42)\n+        }\n+    }\n+\n+    let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    assert_eq!(lazy.lock().unwrap().0, 42);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+\n+    lazy.lock().unwrap().0 = 21;\n+\n+    assert_eq!(lazy.lock().unwrap().0, 21);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn static_sync_lazy() {\n+    static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n+        let mut xs = Vec::new();\n+        xs.push(1);\n+        xs.push(2);\n+        xs.push(3);\n+        xs\n+    });\n+\n+    spawn_and_wait(|| {\n+        assert_eq!(&*XS, &vec![1, 2, 3]);\n+    });\n+\n+    assert_eq!(&*XS, &vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn static_sync_lazy_via_fn() {\n+    fn xs() -> &'static Vec<i32> {\n+        static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n+        XS.get_or_init(|| {\n+            let mut xs = Vec::new();\n+            xs.push(1);\n+            xs.push(2);\n+            xs.push(3);\n+            xs\n+        })\n+    }\n+    assert_eq!(xs(), &vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn sync_lazy_poisoning() {\n+    let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n+    for _ in 0..2 {\n+        let res = panic::catch_unwind(|| x.len());\n+        assert!(res.is_err());\n+    }\n+}\n+\n+#[test]\n+fn is_sync_send() {\n+    fn assert_traits<T: Send + Sync>() {}\n+    assert_traits::<SyncOnceCell<String>>();\n+    assert_traits::<SyncLazy<String>>();\n+}\n+\n+#[test]\n+fn eval_once_macro() {\n+    macro_rules! eval_once {\n+        (|| -> $ty:ty {\n+            $($body:tt)*\n+        }) => {{\n+            static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n+            fn init() -> $ty {\n+                $($body)*\n+            }\n+            ONCE_CELL.get_or_init(init)\n+        }};\n+    }\n+\n+    let fib: &'static Vec<i32> = eval_once! {\n+        || -> Vec<i32> {\n+            let mut res = vec![1, 1];\n+            for i in 0..10 {\n+                let next = res[i] + res[i + 1];\n+                res.push(next);\n+            }\n+            res\n+        }\n+    };\n+    assert_eq!(fib[5], 8)\n+}\n+\n+#[test]\n+fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n+    static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+\n+    let n_readers = 10;\n+    let n_writers = 3;\n+    const MSG: &str = \"Hello, World\";\n+\n+    let (tx, rx) = channel();\n+\n+    for _ in 0..n_readers {\n+        let tx = tx.clone();\n+        thread::spawn(move || {\n+            loop {\n+                if let Some(msg) = ONCE_CELL.get() {\n+                    tx.send(msg).unwrap();\n+                    break;\n+                }\n+                #[cfg(target_env = \"sgx\")]\n+                crate::thread::yield_now();\n+            }\n+        });\n+    }\n+    for _ in 0..n_writers {\n+        thread::spawn(move || {\n+            let _ = ONCE_CELL.set(MSG.to_owned());\n+        });\n+    }\n+\n+    for _ in 0..n_readers {\n+        let msg = rx.recv().unwrap();\n+        assert_eq!(msg, MSG);\n+    }\n+}\n+\n+#[test]\n+fn dropck() {\n+    let cell = SyncOnceCell::new();\n+    {\n+        let s = String::new();\n+        cell.set(&s).unwrap();\n+    }\n+}"}, {"sha": "86a08f75a8d4805e65a1edb976fa19c3cf54ffc0", "filename": "library/std/src/memchr.rs", "status": "modified", "additions": 3, "deletions": 87, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmemchr.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,6 +1,9 @@\n // Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A safe interface to `memchr`.\n ///\n /// Returns the index corresponding to the first occurrence of `needle` in\n@@ -44,90 +47,3 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n     crate::sys::memchr::memrchr(needle, haystack)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    // test the implementations for the current platform\n-    use super::{memchr, memrchr};\n-\n-    #[test]\n-    fn matches_one() {\n-        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin() {\n-        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end() {\n-        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul() {\n-        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul() {\n-        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty() {\n-        assert_eq!(None, memchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match() {\n-        assert_eq!(None, memchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn matches_one_reversed() {\n-        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin_reversed() {\n-        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul_reversed() {\n-        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn each_alignment() {\n-        let mut data = [1u8; 64];\n-        let needle = 2;\n-        let pos = 40;\n-        data[pos] = needle;\n-        for start in 0..16 {\n-            assert_eq!(Some(pos - start), memchr(needle, &data[start..]));\n-        }\n-    }\n-}"}, {"sha": "557d749c7f63e2f2c3e0976f8b7abb610764bfc3", "filename": "library/std/src/memchr/tests.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fmemchr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fmemchr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmemchr%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,86 @@\n+// Original implementation taken from rust-memchr.\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+// test the implementations for the current platform\n+use super::{memchr, memrchr};\n+\n+#[test]\n+fn matches_one() {\n+    assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+}\n+\n+#[test]\n+fn matches_begin() {\n+    assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+}\n+\n+#[test]\n+fn matches_end() {\n+    assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+}\n+\n+#[test]\n+fn matches_nul() {\n+    assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+}\n+\n+#[test]\n+fn matches_past_nul() {\n+    assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+}\n+\n+#[test]\n+fn no_match_empty() {\n+    assert_eq!(None, memchr(b'a', b\"\"));\n+}\n+\n+#[test]\n+fn no_match() {\n+    assert_eq!(None, memchr(b'a', b\"xyz\"));\n+}\n+\n+#[test]\n+fn matches_one_reversed() {\n+    assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+}\n+\n+#[test]\n+fn matches_begin_reversed() {\n+    assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+}\n+\n+#[test]\n+fn matches_end_reversed() {\n+    assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+}\n+\n+#[test]\n+fn matches_nul_reversed() {\n+    assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+}\n+\n+#[test]\n+fn matches_past_nul_reversed() {\n+    assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+}\n+\n+#[test]\n+fn no_match_empty_reversed() {\n+    assert_eq!(None, memrchr(b'a', b\"\"));\n+}\n+\n+#[test]\n+fn no_match_reversed() {\n+    assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+}\n+\n+#[test]\n+fn each_alignment() {\n+    let mut data = [1u8; 64];\n+    let needle = 2;\n+    let pos = 40;\n+    data[pos] = needle;\n+    for start in 0..16 {\n+        assert_eq!(Some(pos - start), memchr(needle, &data[start..]));\n+    }\n+}"}, {"sha": "1ba243804fec7b3d790c0b08266a9e9c6f64ac0e", "filename": "library/std/src/net/addr.rs", "status": "modified", "additions": 3, "deletions": 233, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests;\n+\n use crate::cmp::Ordering;\n use crate::convert::TryInto;\n use crate::fmt;\n@@ -991,236 +994,3 @@ impl ToSocketAddrs for String {\n         (&**self).to_socket_addrs()\n     }\n }\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use crate::net::test::{sa4, sa6, tsa};\n-    use crate::net::*;\n-\n-    #[test]\n-    fn to_socket_addr_ipaddr_u16() {\n-        let a = Ipv4Addr::new(77, 88, 21, 11);\n-        let p = 12345;\n-        let e = SocketAddr::V4(SocketAddrV4::new(a, p));\n-        assert_eq!(Ok(vec![e]), tsa((a, p)));\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str_u16() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n-        assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352)));\n-\n-        let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n-        assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n-\n-        let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n-        #[cfg(not(target_env = \"sgx\"))]\n-        assert!(tsa((\"localhost\", 23924)).unwrap().contains(&a));\n-        #[cfg(target_env = \"sgx\")]\n-        let _ = a;\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n-        assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n-\n-        let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n-        assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n-\n-        let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n-        #[cfg(not(target_env = \"sgx\"))]\n-        assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n-        #[cfg(target_env = \"sgx\")]\n-        let _ = a;\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_string() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n-        assert_eq!(Ok(vec![a]), tsa(&*format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n-        assert_eq!(Ok(vec![a]), tsa(&format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n-        assert_eq!(Ok(vec![a]), tsa(format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n-\n-        let s = format!(\"{}:{}\", \"77.88.21.11\", \"24352\");\n-        assert_eq!(Ok(vec![a]), tsa(s));\n-        // s has been moved into the tsa call\n-    }\n-\n-    #[test]\n-    fn bind_udp_socket_bad() {\n-        // rust-lang/rust#53957: This is a regression test for a parsing problem\n-        // discovered as part of issue rust-lang/rust#23076, where we were\n-        // incorrectly parsing invalid input and then that would result in a\n-        // successful `UdpSocket` binding when we would expect failure.\n-        //\n-        // At one time, this test was written as a call to `tsa` with\n-        // INPUT_23076. However, that structure yields an unreliable test,\n-        // because it ends up passing junk input to the DNS server, and some DNS\n-        // servers will respond with `Ok` to such input, with the ip address of\n-        // the DNS server itself.\n-        //\n-        // This form of the test is more robust: even when the DNS server\n-        // returns its own address, it is still an error to bind a UDP socket to\n-        // a non-local address, and so we still get an error here in that case.\n-\n-        const INPUT_23076: &'static str = \"1200::AB00:1234::2552:7777:1313:34300\";\n-\n-        assert!(crate::net::UdpSocket::bind(INPUT_23076).is_err())\n-    }\n-\n-    #[test]\n-    fn set_ip() {\n-        fn ip4(low: u8) -> Ipv4Addr {\n-            Ipv4Addr::new(77, 88, 21, low)\n-        }\n-        fn ip6(low: u16) -> Ipv6Addr {\n-            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n-        }\n-\n-        let mut v4 = SocketAddrV4::new(ip4(11), 80);\n-        assert_eq!(v4.ip(), &ip4(11));\n-        v4.set_ip(ip4(12));\n-        assert_eq!(v4.ip(), &ip4(12));\n-\n-        let mut addr = SocketAddr::V4(v4);\n-        assert_eq!(addr.ip(), IpAddr::V4(ip4(12)));\n-        addr.set_ip(IpAddr::V4(ip4(13)));\n-        assert_eq!(addr.ip(), IpAddr::V4(ip4(13)));\n-        addr.set_ip(IpAddr::V6(ip6(14)));\n-        assert_eq!(addr.ip(), IpAddr::V6(ip6(14)));\n-\n-        let mut v6 = SocketAddrV6::new(ip6(1), 80, 0, 0);\n-        assert_eq!(v6.ip(), &ip6(1));\n-        v6.set_ip(ip6(2));\n-        assert_eq!(v6.ip(), &ip6(2));\n-\n-        let mut addr = SocketAddr::V6(v6);\n-        assert_eq!(addr.ip(), IpAddr::V6(ip6(2)));\n-        addr.set_ip(IpAddr::V6(ip6(3)));\n-        assert_eq!(addr.ip(), IpAddr::V6(ip6(3)));\n-        addr.set_ip(IpAddr::V4(ip4(4)));\n-        assert_eq!(addr.ip(), IpAddr::V4(ip4(4)));\n-    }\n-\n-    #[test]\n-    fn set_port() {\n-        let mut v4 = SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80);\n-        assert_eq!(v4.port(), 80);\n-        v4.set_port(443);\n-        assert_eq!(v4.port(), 443);\n-\n-        let mut addr = SocketAddr::V4(v4);\n-        assert_eq!(addr.port(), 443);\n-        addr.set_port(8080);\n-        assert_eq!(addr.port(), 8080);\n-\n-        let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 0);\n-        assert_eq!(v6.port(), 80);\n-        v6.set_port(443);\n-        assert_eq!(v6.port(), 443);\n-\n-        let mut addr = SocketAddr::V6(v6);\n-        assert_eq!(addr.port(), 443);\n-        addr.set_port(8080);\n-        assert_eq!(addr.port(), 8080);\n-    }\n-\n-    #[test]\n-    fn set_flowinfo() {\n-        let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0);\n-        assert_eq!(v6.flowinfo(), 10);\n-        v6.set_flowinfo(20);\n-        assert_eq!(v6.flowinfo(), 20);\n-    }\n-\n-    #[test]\n-    fn set_scope_id() {\n-        let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 10);\n-        assert_eq!(v6.scope_id(), 10);\n-        v6.set_scope_id(20);\n-        assert_eq!(v6.scope_id(), 20);\n-    }\n-\n-    #[test]\n-    fn is_v4() {\n-        let v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80));\n-        assert!(v4.is_ipv4());\n-        assert!(!v4.is_ipv6());\n-    }\n-\n-    #[test]\n-    fn is_v6() {\n-        let v6 = SocketAddr::V6(SocketAddrV6::new(\n-            Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n-            80,\n-            10,\n-            0,\n-        ));\n-        assert!(!v6.is_ipv4());\n-        assert!(v6.is_ipv6());\n-    }\n-\n-    #[test]\n-    fn socket_v4_to_str() {\n-        let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n-\n-        assert_eq!(format!(\"{}\", socket), \"192.168.0.1:8080\");\n-        assert_eq!(format!(\"{:<20}\", socket), \"192.168.0.1:8080    \");\n-        assert_eq!(format!(\"{:>20}\", socket), \"    192.168.0.1:8080\");\n-        assert_eq!(format!(\"{:^20}\", socket), \"  192.168.0.1:8080  \");\n-        assert_eq!(format!(\"{:.10}\", socket), \"192.168.0.\");\n-    }\n-\n-    #[test]\n-    fn socket_v6_to_str() {\n-        let socket: SocketAddrV6 = \"[2a02:6b8:0:1::1]:53\".parse().unwrap();\n-\n-        assert_eq!(format!(\"{}\", socket), \"[2a02:6b8:0:1::1]:53\");\n-        assert_eq!(format!(\"{:<24}\", socket), \"[2a02:6b8:0:1::1]:53    \");\n-        assert_eq!(format!(\"{:>24}\", socket), \"    [2a02:6b8:0:1::1]:53\");\n-        assert_eq!(format!(\"{:^24}\", socket), \"  [2a02:6b8:0:1::1]:53  \");\n-        assert_eq!(format!(\"{:.15}\", socket), \"[2a02:6b8:0:1::\");\n-    }\n-\n-    #[test]\n-    fn compare() {\n-        let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();\n-        let v4_2 = \"224.210.103.5:12345\".parse::<SocketAddrV4>().unwrap();\n-        let v4_3 = \"224.210.103.5:23456\".parse::<SocketAddrV4>().unwrap();\n-        let v6_1 = \"[2001:db8:f00::1002]:23456\".parse::<SocketAddrV6>().unwrap();\n-        let v6_2 = \"[2001:db8:f00::2001]:12345\".parse::<SocketAddrV6>().unwrap();\n-        let v6_3 = \"[2001:db8:f00::2001]:23456\".parse::<SocketAddrV6>().unwrap();\n-\n-        // equality\n-        assert_eq!(v4_1, v4_1);\n-        assert_eq!(v6_1, v6_1);\n-        assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n-        assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n-        assert!(v4_1 != v4_2);\n-        assert!(v6_1 != v6_2);\n-\n-        // compare different addresses\n-        assert!(v4_1 < v4_2);\n-        assert!(v6_1 < v6_2);\n-        assert!(v4_2 > v4_1);\n-        assert!(v6_2 > v6_1);\n-\n-        // compare the same address with different ports\n-        assert!(v4_2 < v4_3);\n-        assert!(v6_2 < v6_3);\n-        assert!(v4_3 > v4_2);\n-        assert!(v6_3 > v6_2);\n-\n-        // compare different addresses with the same port\n-        assert!(v4_1 < v4_3);\n-        assert!(v6_1 < v6_3);\n-        assert!(v4_3 > v4_1);\n-        assert!(v6_3 > v6_1);\n-\n-        // compare with an inferred right-hand side\n-        assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n-        assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n-        assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n-    }\n-}"}, {"sha": "cee9087e13b32a24b536f950c0b8a1969dddf203", "filename": "library/std/src/net/addr/tests.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,229 @@\n+use crate::net::test::{sa4, sa6, tsa};\n+use crate::net::*;\n+\n+#[test]\n+fn to_socket_addr_ipaddr_u16() {\n+    let a = Ipv4Addr::new(77, 88, 21, 11);\n+    let p = 12345;\n+    let e = SocketAddr::V4(SocketAddrV4::new(a, p));\n+    assert_eq!(Ok(vec![e]), tsa((a, p)));\n+}\n+\n+#[test]\n+fn to_socket_addr_str_u16() {\n+    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n+    assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352)));\n+\n+    let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+    assert_eq!(Ok(vec![a]), tsa((\"2a02:6b8:0:1::1\", 53)));\n+\n+    let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n+    #[cfg(not(target_env = \"sgx\"))]\n+    assert!(tsa((\"localhost\", 23924)).unwrap().contains(&a));\n+    #[cfg(target_env = \"sgx\")]\n+    let _ = a;\n+}\n+\n+#[test]\n+fn to_socket_addr_str() {\n+    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n+    assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n+\n+    let a = sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53);\n+    assert_eq!(Ok(vec![a]), tsa(\"[2a02:6b8:0:1::1]:53\"));\n+\n+    let a = sa4(Ipv4Addr::new(127, 0, 0, 1), 23924);\n+    #[cfg(not(target_env = \"sgx\"))]\n+    assert!(tsa(\"localhost:23924\").unwrap().contains(&a));\n+    #[cfg(target_env = \"sgx\")]\n+    let _ = a;\n+}\n+\n+#[test]\n+fn to_socket_addr_string() {\n+    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n+    assert_eq!(Ok(vec![a]), tsa(&*format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n+    assert_eq!(Ok(vec![a]), tsa(&format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n+    assert_eq!(Ok(vec![a]), tsa(format!(\"{}:{}\", \"77.88.21.11\", \"24352\")));\n+\n+    let s = format!(\"{}:{}\", \"77.88.21.11\", \"24352\");\n+    assert_eq!(Ok(vec![a]), tsa(s));\n+    // s has been moved into the tsa call\n+}\n+\n+#[test]\n+fn bind_udp_socket_bad() {\n+    // rust-lang/rust#53957: This is a regression test for a parsing problem\n+    // discovered as part of issue rust-lang/rust#23076, where we were\n+    // incorrectly parsing invalid input and then that would result in a\n+    // successful `UdpSocket` binding when we would expect failure.\n+    //\n+    // At one time, this test was written as a call to `tsa` with\n+    // INPUT_23076. However, that structure yields an unreliable test,\n+    // because it ends up passing junk input to the DNS server, and some DNS\n+    // servers will respond with `Ok` to such input, with the ip address of\n+    // the DNS server itself.\n+    //\n+    // This form of the test is more robust: even when the DNS server\n+    // returns its own address, it is still an error to bind a UDP socket to\n+    // a non-local address, and so we still get an error here in that case.\n+\n+    const INPUT_23076: &'static str = \"1200::AB00:1234::2552:7777:1313:34300\";\n+\n+    assert!(crate::net::UdpSocket::bind(INPUT_23076).is_err())\n+}\n+\n+#[test]\n+fn set_ip() {\n+    fn ip4(low: u8) -> Ipv4Addr {\n+        Ipv4Addr::new(77, 88, 21, low)\n+    }\n+    fn ip6(low: u16) -> Ipv6Addr {\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, low)\n+    }\n+\n+    let mut v4 = SocketAddrV4::new(ip4(11), 80);\n+    assert_eq!(v4.ip(), &ip4(11));\n+    v4.set_ip(ip4(12));\n+    assert_eq!(v4.ip(), &ip4(12));\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(12)));\n+    addr.set_ip(IpAddr::V4(ip4(13)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(13)));\n+    addr.set_ip(IpAddr::V6(ip6(14)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(14)));\n+\n+    let mut v6 = SocketAddrV6::new(ip6(1), 80, 0, 0);\n+    assert_eq!(v6.ip(), &ip6(1));\n+    v6.set_ip(ip6(2));\n+    assert_eq!(v6.ip(), &ip6(2));\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(2)));\n+    addr.set_ip(IpAddr::V6(ip6(3)));\n+    assert_eq!(addr.ip(), IpAddr::V6(ip6(3)));\n+    addr.set_ip(IpAddr::V4(ip4(4)));\n+    assert_eq!(addr.ip(), IpAddr::V4(ip4(4)));\n+}\n+\n+#[test]\n+fn set_port() {\n+    let mut v4 = SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80);\n+    assert_eq!(v4.port(), 80);\n+    v4.set_port(443);\n+    assert_eq!(v4.port(), 443);\n+\n+    let mut addr = SocketAddr::V4(v4);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 0);\n+    assert_eq!(v6.port(), 80);\n+    v6.set_port(443);\n+    assert_eq!(v6.port(), 443);\n+\n+    let mut addr = SocketAddr::V6(v6);\n+    assert_eq!(addr.port(), 443);\n+    addr.set_port(8080);\n+    assert_eq!(addr.port(), 8080);\n+}\n+\n+#[test]\n+fn set_flowinfo() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 10, 0);\n+    assert_eq!(v6.flowinfo(), 10);\n+    v6.set_flowinfo(20);\n+    assert_eq!(v6.flowinfo(), 20);\n+}\n+\n+#[test]\n+fn set_scope_id() {\n+    let mut v6 = SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 80, 0, 10);\n+    assert_eq!(v6.scope_id(), 10);\n+    v6.set_scope_id(20);\n+    assert_eq!(v6.scope_id(), 20);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let v4 = SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80));\n+    assert!(v4.is_ipv4());\n+    assert!(!v4.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let v6 = SocketAddr::V6(SocketAddrV6::new(\n+        Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1),\n+        80,\n+        10,\n+        0,\n+    ));\n+    assert!(!v6.is_ipv4());\n+    assert!(v6.is_ipv6());\n+}\n+\n+#[test]\n+fn socket_v4_to_str() {\n+    let socket = SocketAddrV4::new(Ipv4Addr::new(192, 168, 0, 1), 8080);\n+\n+    assert_eq!(format!(\"{}\", socket), \"192.168.0.1:8080\");\n+    assert_eq!(format!(\"{:<20}\", socket), \"192.168.0.1:8080    \");\n+    assert_eq!(format!(\"{:>20}\", socket), \"    192.168.0.1:8080\");\n+    assert_eq!(format!(\"{:^20}\", socket), \"  192.168.0.1:8080  \");\n+    assert_eq!(format!(\"{:.10}\", socket), \"192.168.0.\");\n+}\n+\n+#[test]\n+fn socket_v6_to_str() {\n+    let socket: SocketAddrV6 = \"[2a02:6b8:0:1::1]:53\".parse().unwrap();\n+\n+    assert_eq!(format!(\"{}\", socket), \"[2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{:<24}\", socket), \"[2a02:6b8:0:1::1]:53    \");\n+    assert_eq!(format!(\"{:>24}\", socket), \"    [2a02:6b8:0:1::1]:53\");\n+    assert_eq!(format!(\"{:^24}\", socket), \"  [2a02:6b8:0:1::1]:53  \");\n+    assert_eq!(format!(\"{:.15}\", socket), \"[2a02:6b8:0:1::\");\n+}\n+\n+#[test]\n+fn compare() {\n+    let v4_1 = \"224.120.45.1:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v4_2 = \"224.210.103.5:12345\".parse::<SocketAddrV4>().unwrap();\n+    let v4_3 = \"224.210.103.5:23456\".parse::<SocketAddrV4>().unwrap();\n+    let v6_1 = \"[2001:db8:f00::1002]:23456\".parse::<SocketAddrV6>().unwrap();\n+    let v6_2 = \"[2001:db8:f00::2001]:12345\".parse::<SocketAddrV6>().unwrap();\n+    let v6_3 = \"[2001:db8:f00::2001]:23456\".parse::<SocketAddrV6>().unwrap();\n+\n+    // equality\n+    assert_eq!(v4_1, v4_1);\n+    assert_eq!(v6_1, v6_1);\n+    assert_eq!(SocketAddr::V4(v4_1), SocketAddr::V4(v4_1));\n+    assert_eq!(SocketAddr::V6(v6_1), SocketAddr::V6(v6_1));\n+    assert!(v4_1 != v4_2);\n+    assert!(v6_1 != v6_2);\n+\n+    // compare different addresses\n+    assert!(v4_1 < v4_2);\n+    assert!(v6_1 < v6_2);\n+    assert!(v4_2 > v4_1);\n+    assert!(v6_2 > v6_1);\n+\n+    // compare the same address with different ports\n+    assert!(v4_2 < v4_3);\n+    assert!(v6_2 < v6_3);\n+    assert!(v4_3 > v4_2);\n+    assert!(v6_3 > v6_2);\n+\n+    // compare different addresses with the same port\n+    assert!(v4_1 < v4_3);\n+    assert!(v6_1 < v6_3);\n+    assert!(v4_3 > v4_1);\n+    assert!(v6_3 > v6_1);\n+\n+    // compare with an inferred right-hand side\n+    assert_eq!(v4_1, \"224.120.45.1:23456\".parse().unwrap());\n+    assert_eq!(v6_1, \"[2001:db8:f00::1002]:23456\".parse().unwrap());\n+    assert_eq!(SocketAddr::V4(v4_1), \"224.120.45.1:23456\".parse().unwrap());\n+}"}, {"sha": "10676b49d43753547b443aa6c4d2a1f6c3613d35", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 4, "deletions": 859, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -6,6 +6,10 @@\n     issue = \"27709\"\n )]\n \n+// Tests for this module\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests;\n+\n use crate::cmp::Ordering;\n use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n@@ -1895,862 +1899,3 @@ impl From<[u16; 8]> for IpAddr {\n         IpAddr::V6(Ipv6Addr::from(segments))\n     }\n }\n-\n-// Tests for this module\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use crate::net::test::{sa4, sa6, tsa};\n-    use crate::net::*;\n-    use crate::str::FromStr;\n-\n-    #[test]\n-    fn test_from_str_ipv4() {\n-        assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-        assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-        // out of range\n-        let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n-        assert_eq!(None, none);\n-        // no number between dots\n-        let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-        assert_eq!(\n-            Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-            \"2a02:6b8::11:11\".parse()\n-        );\n-\n-        // too long group\n-        let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-        assert_eq!(None, none);\n-        // triple colon\n-        let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-        // two double colons\n-        let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n-        assert_eq!(None, none);\n-        // `::` indicating zero groups of zeros\n-        let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n-        assert_eq!(\n-            Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-            \"::FFFF:192.0.2.33\".parse()\n-        );\n-        assert_eq!(\n-            Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-            \"64:ff9b::192.0.2.33\".parse()\n-        );\n-        assert_eq!(\n-            Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-            \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n-        );\n-\n-        // colon after v4\n-        let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // not enough groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too many groups\n-        let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n-        assert_eq!(\n-            Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)),\n-            \"77.88.21.11:80\".parse()\n-        );\n-        assert_eq!(\n-            Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n-            \"[2a02:6b8:0:1::1]:53\".parse()\n-        );\n-        assert_eq!(\n-            Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n-            \"[2a02:6b8:0:1::1]:53\".parse()\n-        );\n-        assert_eq!(\n-            Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)),\n-            \"[::127.0.0.1]:22\".parse()\n-        );\n-        assert_eq!(\n-            Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n-            \"[::127.0.0.1]:22\".parse()\n-        );\n-\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // wrong brackets around v4\n-        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-        assert_eq!(None, none);\n-        // port out of range\n-        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn ipv4_addr_to_string() {\n-        assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n-        // Short address\n-        assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n-        // Long address\n-        assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n-\n-        // Test padding\n-        assert_eq!(&format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n-        assert_eq!(&format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n-    }\n-\n-    #[test]\n-    fn ipv6_addr_to_string() {\n-        // ipv4-mapped address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n-\n-        // ipv4-compatible address\n-        let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n-        assert_eq!(a1.to_string(), \"::192.0.2.128\");\n-\n-        // v6 address with no zero segments\n-        assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n-\n-        // longest possible IPv6 length\n-        assert_eq!(\n-            Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888)\n-                .to_string(),\n-            \"1111:2222:3333:4444:5555:6666:7777:8888\"\n-        );\n-        // padding\n-        assert_eq!(\n-            &format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)),\n-            \"1:2:3:4:5:6:7:8     \"\n-        );\n-        assert_eq!(\n-            &format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)),\n-            \"     1:2:3:4:5:6:7:8\"\n-        );\n-\n-        // reduce a single run of zeros\n-        assert_eq!(\n-            \"ae::ffff:102:304\",\n-            Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n-        );\n-\n-        // don't reduce just a single zero segment\n-        assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n-\n-        // 'any' address\n-        assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // loopback address\n-        assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n-\n-        // ends in zeros\n-        assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n-\n-        // two runs of zeros, second one is longer\n-        assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n-\n-        // two runs of zeros, equal length\n-        assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n-    }\n-\n-    #[test]\n-    fn ipv4_to_ipv6() {\n-        assert_eq!(\n-            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n-            Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n-        );\n-        assert_eq!(\n-            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n-            Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n-        );\n-    }\n-\n-    #[test]\n-    fn ipv6_to_ipv4_mapped() {\n-        assert_eq!(\n-            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n-            Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-        );\n-        assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n-    }\n-\n-    #[test]\n-    fn ipv6_to_ipv4() {\n-        assert_eq!(\n-            Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n-            Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-        );\n-        assert_eq!(\n-            Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n-            Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n-        );\n-        assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n-    }\n-\n-    #[test]\n-    fn ip_properties() {\n-        macro_rules! ip {\n-            ($s:expr) => {\n-                IpAddr::from_str($s).unwrap()\n-            };\n-        }\n-\n-        macro_rules! check {\n-            ($s:expr) => {\n-                check!($s, 0);\n-            };\n-\n-            ($s:expr, $mask:expr) => {{\n-                let unspec: u8 = 1 << 0;\n-                let loopback: u8 = 1 << 1;\n-                let global: u8 = 1 << 2;\n-                let multicast: u8 = 1 << 3;\n-                let doc: u8 = 1 << 4;\n-\n-                if ($mask & unspec) == unspec {\n-                    assert!(ip!($s).is_unspecified());\n-                } else {\n-                    assert!(!ip!($s).is_unspecified());\n-                }\n-\n-                if ($mask & loopback) == loopback {\n-                    assert!(ip!($s).is_loopback());\n-                } else {\n-                    assert!(!ip!($s).is_loopback());\n-                }\n-\n-                if ($mask & global) == global {\n-                    assert!(ip!($s).is_global());\n-                } else {\n-                    assert!(!ip!($s).is_global());\n-                }\n-\n-                if ($mask & multicast) == multicast {\n-                    assert!(ip!($s).is_multicast());\n-                } else {\n-                    assert!(!ip!($s).is_multicast());\n-                }\n-\n-                if ($mask & doc) == doc {\n-                    assert!(ip!($s).is_documentation());\n-                } else {\n-                    assert!(!ip!($s).is_documentation());\n-                }\n-            }};\n-        }\n-\n-        let unspec: u8 = 1 << 0;\n-        let loopback: u8 = 1 << 1;\n-        let global: u8 = 1 << 2;\n-        let multicast: u8 = 1 << 3;\n-        let doc: u8 = 1 << 4;\n-\n-        check!(\"0.0.0.0\", unspec);\n-        check!(\"0.0.0.1\");\n-        check!(\"0.1.0.0\");\n-        check!(\"10.9.8.7\");\n-        check!(\"127.1.2.3\", loopback);\n-        check!(\"172.31.254.253\");\n-        check!(\"169.254.253.242\");\n-        check!(\"192.0.2.183\", doc);\n-        check!(\"192.1.2.183\", global);\n-        check!(\"192.168.254.253\");\n-        check!(\"198.51.100.0\", doc);\n-        check!(\"203.0.113.0\", doc);\n-        check!(\"203.2.113.0\", global);\n-        check!(\"224.0.0.0\", global | multicast);\n-        check!(\"239.255.255.255\", global | multicast);\n-        check!(\"255.255.255.255\");\n-        // make sure benchmarking addresses are not global\n-        check!(\"198.18.0.0\");\n-        check!(\"198.18.54.2\");\n-        check!(\"198.19.255.255\");\n-        // make sure addresses reserved for protocol assignment are not global\n-        check!(\"192.0.0.0\");\n-        check!(\"192.0.0.255\");\n-        check!(\"192.0.0.100\");\n-        // make sure reserved addresses are not global\n-        check!(\"240.0.0.0\");\n-        check!(\"251.54.1.76\");\n-        check!(\"254.255.255.255\");\n-        // make sure shared addresses are not global\n-        check!(\"100.64.0.0\");\n-        check!(\"100.127.255.255\");\n-        check!(\"100.100.100.0\");\n-\n-        check!(\"::\", unspec);\n-        check!(\"::1\", loopback);\n-        check!(\"::0.0.0.2\", global);\n-        check!(\"1::\", global);\n-        check!(\"fc00::\");\n-        check!(\"fdff:ffff::\");\n-        check!(\"fe80:ffff::\");\n-        check!(\"febf:ffff::\");\n-        check!(\"fec0::\", global);\n-        check!(\"ff01::\", multicast);\n-        check!(\"ff02::\", multicast);\n-        check!(\"ff03::\", multicast);\n-        check!(\"ff04::\", multicast);\n-        check!(\"ff05::\", multicast);\n-        check!(\"ff08::\", multicast);\n-        check!(\"ff0e::\", global | multicast);\n-        check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n-        check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n-    }\n-\n-    #[test]\n-    fn ipv4_properties() {\n-        macro_rules! ip {\n-            ($s:expr) => {\n-                Ipv4Addr::from_str($s).unwrap()\n-            };\n-        }\n-\n-        macro_rules! check {\n-            ($s:expr) => {\n-                check!($s, 0);\n-            };\n-\n-            ($s:expr, $mask:expr) => {{\n-                let unspec: u16 = 1 << 0;\n-                let loopback: u16 = 1 << 1;\n-                let private: u16 = 1 << 2;\n-                let link_local: u16 = 1 << 3;\n-                let global: u16 = 1 << 4;\n-                let multicast: u16 = 1 << 5;\n-                let broadcast: u16 = 1 << 6;\n-                let documentation: u16 = 1 << 7;\n-                let benchmarking: u16 = 1 << 8;\n-                let ietf_protocol_assignment: u16 = 1 << 9;\n-                let reserved: u16 = 1 << 10;\n-                let shared: u16 = 1 << 11;\n-\n-                if ($mask & unspec) == unspec {\n-                    assert!(ip!($s).is_unspecified());\n-                } else {\n-                    assert!(!ip!($s).is_unspecified());\n-                }\n-\n-                if ($mask & loopback) == loopback {\n-                    assert!(ip!($s).is_loopback());\n-                } else {\n-                    assert!(!ip!($s).is_loopback());\n-                }\n-\n-                if ($mask & private) == private {\n-                    assert!(ip!($s).is_private());\n-                } else {\n-                    assert!(!ip!($s).is_private());\n-                }\n-\n-                if ($mask & link_local) == link_local {\n-                    assert!(ip!($s).is_link_local());\n-                } else {\n-                    assert!(!ip!($s).is_link_local());\n-                }\n-\n-                if ($mask & global) == global {\n-                    assert!(ip!($s).is_global());\n-                } else {\n-                    assert!(!ip!($s).is_global());\n-                }\n-\n-                if ($mask & multicast) == multicast {\n-                    assert!(ip!($s).is_multicast());\n-                } else {\n-                    assert!(!ip!($s).is_multicast());\n-                }\n-\n-                if ($mask & broadcast) == broadcast {\n-                    assert!(ip!($s).is_broadcast());\n-                } else {\n-                    assert!(!ip!($s).is_broadcast());\n-                }\n-\n-                if ($mask & documentation) == documentation {\n-                    assert!(ip!($s).is_documentation());\n-                } else {\n-                    assert!(!ip!($s).is_documentation());\n-                }\n-\n-                if ($mask & benchmarking) == benchmarking {\n-                    assert!(ip!($s).is_benchmarking());\n-                } else {\n-                    assert!(!ip!($s).is_benchmarking());\n-                }\n-\n-                if ($mask & ietf_protocol_assignment) == ietf_protocol_assignment {\n-                    assert!(ip!($s).is_ietf_protocol_assignment());\n-                } else {\n-                    assert!(!ip!($s).is_ietf_protocol_assignment());\n-                }\n-\n-                if ($mask & reserved) == reserved {\n-                    assert!(ip!($s).is_reserved());\n-                } else {\n-                    assert!(!ip!($s).is_reserved());\n-                }\n-\n-                if ($mask & shared) == shared {\n-                    assert!(ip!($s).is_shared());\n-                } else {\n-                    assert!(!ip!($s).is_shared());\n-                }\n-            }};\n-        }\n-\n-        let unspec: u16 = 1 << 0;\n-        let loopback: u16 = 1 << 1;\n-        let private: u16 = 1 << 2;\n-        let link_local: u16 = 1 << 3;\n-        let global: u16 = 1 << 4;\n-        let multicast: u16 = 1 << 5;\n-        let broadcast: u16 = 1 << 6;\n-        let documentation: u16 = 1 << 7;\n-        let benchmarking: u16 = 1 << 8;\n-        let ietf_protocol_assignment: u16 = 1 << 9;\n-        let reserved: u16 = 1 << 10;\n-        let shared: u16 = 1 << 11;\n-\n-        check!(\"0.0.0.0\", unspec);\n-        check!(\"0.0.0.1\");\n-        check!(\"0.1.0.0\");\n-        check!(\"10.9.8.7\", private);\n-        check!(\"127.1.2.3\", loopback);\n-        check!(\"172.31.254.253\", private);\n-        check!(\"169.254.253.242\", link_local);\n-        check!(\"192.0.2.183\", documentation);\n-        check!(\"192.1.2.183\", global);\n-        check!(\"192.168.254.253\", private);\n-        check!(\"198.51.100.0\", documentation);\n-        check!(\"203.0.113.0\", documentation);\n-        check!(\"203.2.113.0\", global);\n-        check!(\"224.0.0.0\", global | multicast);\n-        check!(\"239.255.255.255\", global | multicast);\n-        check!(\"255.255.255.255\", broadcast);\n-        check!(\"198.18.0.0\", benchmarking);\n-        check!(\"198.18.54.2\", benchmarking);\n-        check!(\"198.19.255.255\", benchmarking);\n-        check!(\"192.0.0.0\", ietf_protocol_assignment);\n-        check!(\"192.0.0.255\", ietf_protocol_assignment);\n-        check!(\"192.0.0.100\", ietf_protocol_assignment);\n-        check!(\"240.0.0.0\", reserved);\n-        check!(\"251.54.1.76\", reserved);\n-        check!(\"254.255.255.255\", reserved);\n-        check!(\"100.64.0.0\", shared);\n-        check!(\"100.127.255.255\", shared);\n-        check!(\"100.100.100.0\", shared);\n-    }\n-\n-    #[test]\n-    fn ipv6_properties() {\n-        macro_rules! ip {\n-            ($s:expr) => {\n-                Ipv6Addr::from_str($s).unwrap()\n-            };\n-        }\n-\n-        macro_rules! check {\n-            ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n-                assert_eq!($s, ip!($s).to_string());\n-                let octets = &[$($octet),*];\n-                assert_eq!(&ip!($s).octets(), octets);\n-                assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n-\n-                let unspecified: u16 = 1 << 0;\n-                let loopback: u16 = 1 << 1;\n-                let unique_local: u16 = 1 << 2;\n-                let global: u16 = 1 << 3;\n-                let unicast_link_local: u16 = 1 << 4;\n-                let unicast_link_local_strict: u16 = 1 << 5;\n-                let unicast_site_local: u16 = 1 << 6;\n-                let unicast_global: u16 = 1 << 7;\n-                let documentation: u16 = 1 << 8;\n-                let multicast_interface_local: u16 = 1 << 9;\n-                let multicast_link_local: u16 = 1 << 10;\n-                let multicast_realm_local: u16 = 1 << 11;\n-                let multicast_admin_local: u16 = 1 << 12;\n-                let multicast_site_local: u16 = 1 << 13;\n-                let multicast_organization_local: u16 = 1 << 14;\n-                let multicast_global: u16 = 1 << 15;\n-                let multicast: u16 = multicast_interface_local\n-                    | multicast_admin_local\n-                    | multicast_global\n-                    | multicast_link_local\n-                    | multicast_realm_local\n-                    | multicast_site_local\n-                    | multicast_organization_local;\n-\n-                if ($mask & unspecified) == unspecified {\n-                    assert!(ip!($s).is_unspecified());\n-                } else {\n-                    assert!(!ip!($s).is_unspecified());\n-                }\n-                if ($mask & loopback) == loopback {\n-                    assert!(ip!($s).is_loopback());\n-                } else {\n-                    assert!(!ip!($s).is_loopback());\n-                }\n-                if ($mask & unique_local) == unique_local {\n-                    assert!(ip!($s).is_unique_local());\n-                } else {\n-                    assert!(!ip!($s).is_unique_local());\n-                }\n-                if ($mask & global) == global {\n-                    assert!(ip!($s).is_global());\n-                } else {\n-                    assert!(!ip!($s).is_global());\n-                }\n-                if ($mask & unicast_link_local) == unicast_link_local {\n-                    assert!(ip!($s).is_unicast_link_local());\n-                } else {\n-                    assert!(!ip!($s).is_unicast_link_local());\n-                }\n-                if ($mask & unicast_link_local_strict) == unicast_link_local_strict {\n-                    assert!(ip!($s).is_unicast_link_local_strict());\n-                } else {\n-                    assert!(!ip!($s).is_unicast_link_local_strict());\n-                }\n-                if ($mask & unicast_site_local) == unicast_site_local {\n-                    assert!(ip!($s).is_unicast_site_local());\n-                } else {\n-                    assert!(!ip!($s).is_unicast_site_local());\n-                }\n-                if ($mask & unicast_global) == unicast_global {\n-                    assert!(ip!($s).is_unicast_global());\n-                } else {\n-                    assert!(!ip!($s).is_unicast_global());\n-                }\n-                if ($mask & documentation) == documentation {\n-                    assert!(ip!($s).is_documentation());\n-                } else {\n-                    assert!(!ip!($s).is_documentation());\n-                }\n-                if ($mask & multicast) != 0 {\n-                    assert!(ip!($s).multicast_scope().is_some());\n-                    assert!(ip!($s).is_multicast());\n-                } else {\n-                    assert!(ip!($s).multicast_scope().is_none());\n-                    assert!(!ip!($s).is_multicast());\n-                }\n-                if ($mask & multicast_interface_local) == multicast_interface_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::InterfaceLocal);\n-                }\n-                if ($mask & multicast_link_local) == multicast_link_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::LinkLocal);\n-                }\n-                if ($mask & multicast_realm_local) == multicast_realm_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::RealmLocal);\n-                }\n-                if ($mask & multicast_admin_local) == multicast_admin_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::AdminLocal);\n-                }\n-                if ($mask & multicast_site_local) == multicast_site_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::SiteLocal);\n-                }\n-                if ($mask & multicast_organization_local) == multicast_organization_local {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::OrganizationLocal);\n-                }\n-                if ($mask & multicast_global) == multicast_global {\n-                    assert_eq!(ip!($s).multicast_scope().unwrap(),\n-                               Ipv6MulticastScope::Global);\n-                }\n-            }\n-        }\n-\n-        let unspecified: u16 = 1 << 0;\n-        let loopback: u16 = 1 << 1;\n-        let unique_local: u16 = 1 << 2;\n-        let global: u16 = 1 << 3;\n-        let unicast_link_local: u16 = 1 << 4;\n-        let unicast_link_local_strict: u16 = 1 << 5;\n-        let unicast_site_local: u16 = 1 << 6;\n-        let unicast_global: u16 = 1 << 7;\n-        let documentation: u16 = 1 << 8;\n-        let multicast_interface_local: u16 = 1 << 9;\n-        let multicast_link_local: u16 = 1 << 10;\n-        let multicast_realm_local: u16 = 1 << 11;\n-        let multicast_admin_local: u16 = 1 << 12;\n-        let multicast_site_local: u16 = 1 << 13;\n-        let multicast_organization_local: u16 = 1 << 14;\n-        let multicast_global: u16 = 1 << 15;\n-\n-        check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n-\n-        check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n-\n-        check!(\n-            \"::0.0.0.2\",\n-            &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2],\n-            global | unicast_global\n-        );\n-\n-        check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n-\n-        check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n-\n-        check!(\n-            \"fdff:ffff::\",\n-            &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unique_local\n-        );\n-\n-        check!(\n-            \"fe80:ffff::\",\n-            &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_link_local\n-        );\n-\n-        check!(\n-            \"fe80::\",\n-            &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_link_local | unicast_link_local_strict\n-        );\n-\n-        check!(\n-            \"febf:ffff::\",\n-            &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_link_local\n-        );\n-\n-        check!(\n-            \"febf::\",\n-            &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_link_local\n-        );\n-\n-        check!(\n-            \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n-            &[\n-                0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-                0xff, 0xff\n-            ],\n-            unicast_link_local\n-        );\n-\n-        check!(\n-            \"fe80::ffff:ffff:ffff:ffff\",\n-            &[\n-                0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n-                0xff, 0xff\n-            ],\n-            unicast_link_local | unicast_link_local_strict\n-        );\n-\n-        check!(\n-            \"fe80:0:0:1::\",\n-            &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_link_local\n-        );\n-\n-        check!(\n-            \"fec0::\",\n-            &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            unicast_site_local | unicast_global | global\n-        );\n-\n-        check!(\n-            \"ff01::\",\n-            &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_interface_local\n-        );\n-\n-        check!(\n-            \"ff02::\",\n-            &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_link_local\n-        );\n-\n-        check!(\n-            \"ff03::\",\n-            &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_realm_local\n-        );\n-\n-        check!(\n-            \"ff04::\",\n-            &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_admin_local\n-        );\n-\n-        check!(\n-            \"ff05::\",\n-            &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_site_local\n-        );\n-\n-        check!(\n-            \"ff08::\",\n-            &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_organization_local\n-        );\n-\n-        check!(\n-            \"ff0e::\",\n-            &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n-            multicast_global | global\n-        );\n-\n-        check!(\n-            \"2001:db8:85a3::8a2e:370:7334\",\n-            &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n-            documentation\n-        );\n-\n-        check!(\n-            \"102:304:506:708:90a:b0c:d0e:f10\",\n-            &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n-            global | unicast_global\n-        );\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_socketaddr() {\n-        let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n-        assert_eq!(Ok(vec![a]), tsa(a));\n-    }\n-\n-    #[test]\n-    fn test_ipv4_to_int() {\n-        let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-        assert_eq!(u32::from(a), 0x11223344);\n-    }\n-\n-    #[test]\n-    fn test_int_to_ipv4() {\n-        let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n-        assert_eq!(Ipv4Addr::from(0x11223344), a);\n-    }\n-\n-    #[test]\n-    fn test_ipv6_to_int() {\n-        let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-        assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n-    }\n-\n-    #[test]\n-    fn test_int_to_ipv6() {\n-        let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n-        assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n-    }\n-\n-    #[test]\n-    fn ipv4_from_constructors() {\n-        assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n-        assert!(Ipv4Addr::LOCALHOST.is_loopback());\n-        assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n-        assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n-        assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n-        assert!(Ipv4Addr::BROADCAST.is_broadcast());\n-    }\n-\n-    #[test]\n-    fn ipv6_from_contructors() {\n-        assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-        assert!(Ipv6Addr::LOCALHOST.is_loopback());\n-        assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-        assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n-    }\n-\n-    #[test]\n-    fn ipv4_from_octets() {\n-        assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n-    }\n-\n-    #[test]\n-    fn ipv6_from_segments() {\n-        let from_u16s =\n-            Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-        let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n-        assert_eq!(new, from_u16s);\n-    }\n-\n-    #[test]\n-    fn ipv6_from_octets() {\n-        let from_u16s =\n-            Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n-        let from_u8s = Ipv6Addr::from([\n-            0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd,\n-            0xee, 0xff,\n-        ]);\n-        assert_eq!(from_u16s, from_u8s);\n-    }\n-\n-    #[test]\n-    fn cmp() {\n-        let v41 = Ipv4Addr::new(100, 64, 3, 3);\n-        let v42 = Ipv4Addr::new(192, 0, 2, 2);\n-        let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n-        let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n-        assert!(v41 < v42);\n-        assert!(v61 < v62);\n-\n-        assert_eq!(v41, IpAddr::V4(v41));\n-        assert_eq!(v61, IpAddr::V6(v61));\n-        assert!(v41 != IpAddr::V4(v42));\n-        assert!(v61 != IpAddr::V6(v62));\n-\n-        assert!(v41 < IpAddr::V4(v42));\n-        assert!(v61 < IpAddr::V6(v62));\n-        assert!(IpAddr::V4(v41) < v42);\n-        assert!(IpAddr::V6(v61) < v62);\n-\n-        assert!(v41 < IpAddr::V6(v61));\n-        assert!(IpAddr::V4(v41) < v61);\n-    }\n-\n-    #[test]\n-    fn is_v4() {\n-        let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n-        assert!(ip.is_ipv4());\n-        assert!(!ip.is_ipv6());\n-    }\n-\n-    #[test]\n-    fn is_v6() {\n-        let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n-        assert!(!ip.is_ipv4());\n-        assert!(ip.is_ipv6());\n-    }\n-}"}, {"sha": "a2fba4b4cca95794b849c19fd433d6b3c09bb1a5", "filename": "library/std/src/net/ip/tests.rs", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,811 @@\n+use crate::net::test::{sa4, sa6, tsa};\n+use crate::net::*;\n+use crate::str::FromStr;\n+\n+#[test]\n+fn test_from_str_ipv4() {\n+    assert_eq!(Ok(Ipv4Addr::new(127, 0, 0, 1)), \"127.0.0.1\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(255, 255, 255, 255)), \"255.255.255.255\".parse());\n+    assert_eq!(Ok(Ipv4Addr::new(0, 0, 0, 0)), \"0.0.0.0\".parse());\n+\n+    // out of range\n+    let none: Option<Ipv4Addr> = \"256.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv4Addr> = \"255.0.0\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv4Addr> = \"255.0.0.1.2\".parse().ok();\n+    assert_eq!(None, none);\n+    // no number between dots\n+    let none: Option<Ipv4Addr> = \"255.0..1\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n+\n+    assert_eq!(Ok(Ipv6Addr::new(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)), \"2a02:6b8::11:11\".parse());\n+\n+    // too long group\n+    let none: Option<Ipv6Addr> = \"::00000\".parse().ok();\n+    assert_eq!(None, none);\n+    // too short\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7\".parse().ok();\n+    assert_eq!(None, none);\n+    // too long\n+    let none: Option<Ipv6Addr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n+    assert_eq!(None, none);\n+    // triple colon\n+    let none: Option<Ipv6Addr> = \"1:2:::6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+    // two double colons\n+    let none: Option<Ipv6Addr> = \"1:2::6::8\".parse().ok();\n+    assert_eq!(None, none);\n+    // `::` indicating zero groups of zeros\n+    let none: Option<Ipv6Addr> = \"1:2:3:4::5:6:7:8\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_ipv4_in_ipv6() {\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 49152, 545)), \"::192.0.2.33\".parse());\n+    assert_eq!(Ok(Ipv6Addr::new(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)), \"::FFFF:192.0.2.33\".parse());\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+        \"64:ff9b::192.0.2.33\".parse()\n+    );\n+    assert_eq!(\n+        Ok(Ipv6Addr::new(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+        \"2001:db8:122:c000:2:2100:192.0.2.33\".parse()\n+    );\n+\n+    // colon after v4\n+    let none: Option<Ipv4Addr> = \"::127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // not enough groups\n+    let none: Option<Ipv6Addr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // too many groups\n+    let none: Option<Ipv6Addr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn test_from_str_socket_addr() {\n+    assert_eq!(Ok(sa4(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(Ok(SocketAddrV4::new(Ipv4Addr::new(77, 88, 21, 11), 80)), \"77.88.21.11:80\".parse());\n+    assert_eq!(\n+        Ok(sa6(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), 53, 0, 0)),\n+        \"[2a02:6b8:0:1::1]:53\".parse()\n+    );\n+    assert_eq!(Ok(sa6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22)), \"[::127.0.0.1]:22\".parse());\n+    assert_eq!(\n+        Ok(SocketAddrV6::new(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x7F00, 1), 22, 0, 0)),\n+        \"[::127.0.0.1]:22\".parse()\n+    );\n+\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n+    assert_eq!(None, none);\n+    // without port\n+    let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n+    assert_eq!(None, none);\n+    // wrong brackets around v4\n+    let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n+    assert_eq!(None, none);\n+    // port out of range\n+    let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n+    assert_eq!(None, none);\n+}\n+\n+#[test]\n+fn ipv4_addr_to_string() {\n+    assert_eq!(Ipv4Addr::new(127, 0, 0, 1).to_string(), \"127.0.0.1\");\n+    // Short address\n+    assert_eq!(Ipv4Addr::new(1, 1, 1, 1).to_string(), \"1.1.1.1\");\n+    // Long address\n+    assert_eq!(Ipv4Addr::new(127, 127, 127, 127).to_string(), \"127.127.127.127\");\n+\n+    // Test padding\n+    assert_eq!(&format!(\"{:16}\", Ipv4Addr::new(1, 1, 1, 1)), \"1.1.1.1         \");\n+    assert_eq!(&format!(\"{:>16}\", Ipv4Addr::new(1, 1, 1, 1)), \"         1.1.1.1\");\n+}\n+\n+#[test]\n+fn ipv6_addr_to_string() {\n+    // ipv4-mapped address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::ffff:192.0.2.128\");\n+\n+    // ipv4-compatible address\n+    let a1 = Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc000, 0x280);\n+    assert_eq!(a1.to_string(), \"::192.0.2.128\");\n+\n+    // v6 address with no zero segments\n+    assert_eq!(Ipv6Addr::new(8, 9, 10, 11, 12, 13, 14, 15).to_string(), \"8:9:a:b:c:d:e:f\");\n+\n+    // longest possible IPv6 length\n+    assert_eq!(\n+        Ipv6Addr::new(0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888).to_string(),\n+        \"1111:2222:3333:4444:5555:6666:7777:8888\"\n+    );\n+    // padding\n+    assert_eq!(&format!(\"{:20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"1:2:3:4:5:6:7:8     \");\n+    assert_eq!(&format!(\"{:>20}\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8)), \"     1:2:3:4:5:6:7:8\");\n+\n+    // reduce a single run of zeros\n+    assert_eq!(\n+        \"ae::ffff:102:304\",\n+        Ipv6Addr::new(0xae, 0, 0, 0, 0, 0xffff, 0x0102, 0x0304).to_string()\n+    );\n+\n+    // don't reduce just a single zero segment\n+    assert_eq!(\"1:2:3:4:5:6:0:8\", Ipv6Addr::new(1, 2, 3, 4, 5, 6, 0, 8).to_string());\n+\n+    // 'any' address\n+    assert_eq!(\"::\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // loopback address\n+    assert_eq!(\"::1\", Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1).to_string());\n+\n+    // ends in zeros\n+    assert_eq!(\"1::\", Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0).to_string());\n+\n+    // two runs of zeros, second one is longer\n+    assert_eq!(\"1:0:0:4::8\", Ipv6Addr::new(1, 0, 0, 4, 0, 0, 0, 8).to_string());\n+\n+    // two runs of zeros, equal length\n+    assert_eq!(\"1::4:5:0:0:8\", Ipv6Addr::new(1, 0, 0, 4, 5, 0, 0, 8).to_string());\n+}\n+\n+#[test]\n+fn ipv4_to_ipv6() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_mapped()\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678),\n+        Ipv4Addr::new(0x12, 0x34, 0x56, 0x78).to_ipv6_compatible()\n+    );\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4_mapped() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4_mapped(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4_mapped(), None);\n+}\n+\n+#[test]\n+fn ipv6_to_ipv4() {\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(\n+        Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0x1234, 0x5678).to_ipv4(),\n+        Some(Ipv4Addr::new(0x12, 0x34, 0x56, 0x78))\n+    );\n+    assert_eq!(Ipv6Addr::new(0, 0, 1, 0, 0, 0, 0x1234, 0x5678).to_ipv4(), None);\n+}\n+\n+#[test]\n+fn ip_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            IpAddr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u8 = 1 << 0;\n+            let loopback: u8 = 1 << 1;\n+            let global: u8 = 1 << 2;\n+            let multicast: u8 = 1 << 3;\n+            let doc: u8 = 1 << 4;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & doc) == doc {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u8 = 1 << 0;\n+    let loopback: u8 = 1 << 1;\n+    let global: u8 = 1 << 2;\n+    let multicast: u8 = 1 << 3;\n+    let doc: u8 = 1 << 4;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\");\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\");\n+    check!(\"169.254.253.242\");\n+    check!(\"192.0.2.183\", doc);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\");\n+    check!(\"198.51.100.0\", doc);\n+    check!(\"203.0.113.0\", doc);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\");\n+    // make sure benchmarking addresses are not global\n+    check!(\"198.18.0.0\");\n+    check!(\"198.18.54.2\");\n+    check!(\"198.19.255.255\");\n+    // make sure addresses reserved for protocol assignment are not global\n+    check!(\"192.0.0.0\");\n+    check!(\"192.0.0.255\");\n+    check!(\"192.0.0.100\");\n+    // make sure reserved addresses are not global\n+    check!(\"240.0.0.0\");\n+    check!(\"251.54.1.76\");\n+    check!(\"254.255.255.255\");\n+    // make sure shared addresses are not global\n+    check!(\"100.64.0.0\");\n+    check!(\"100.127.255.255\");\n+    check!(\"100.100.100.0\");\n+\n+    check!(\"::\", unspec);\n+    check!(\"::1\", loopback);\n+    check!(\"::0.0.0.2\", global);\n+    check!(\"1::\", global);\n+    check!(\"fc00::\");\n+    check!(\"fdff:ffff::\");\n+    check!(\"fe80:ffff::\");\n+    check!(\"febf:ffff::\");\n+    check!(\"fec0::\", global);\n+    check!(\"ff01::\", multicast);\n+    check!(\"ff02::\", multicast);\n+    check!(\"ff03::\", multicast);\n+    check!(\"ff04::\", multicast);\n+    check!(\"ff05::\", multicast);\n+    check!(\"ff08::\", multicast);\n+    check!(\"ff0e::\", global | multicast);\n+    check!(\"2001:db8:85a3::8a2e:370:7334\", doc);\n+    check!(\"102:304:506:708:90a:b0c:d0e:f10\", global);\n+}\n+\n+#[test]\n+fn ipv4_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv4Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr) => {\n+            check!($s, 0);\n+        };\n+\n+        ($s:expr, $mask:expr) => {{\n+            let unspec: u16 = 1 << 0;\n+            let loopback: u16 = 1 << 1;\n+            let private: u16 = 1 << 2;\n+            let link_local: u16 = 1 << 3;\n+            let global: u16 = 1 << 4;\n+            let multicast: u16 = 1 << 5;\n+            let broadcast: u16 = 1 << 6;\n+            let documentation: u16 = 1 << 7;\n+            let benchmarking: u16 = 1 << 8;\n+            let ietf_protocol_assignment: u16 = 1 << 9;\n+            let reserved: u16 = 1 << 10;\n+            let shared: u16 = 1 << 11;\n+\n+            if ($mask & unspec) == unspec {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+\n+            if ($mask & private) == private {\n+                assert!(ip!($s).is_private());\n+            } else {\n+                assert!(!ip!($s).is_private());\n+            }\n+\n+            if ($mask & link_local) == link_local {\n+                assert!(ip!($s).is_link_local());\n+            } else {\n+                assert!(!ip!($s).is_link_local());\n+            }\n+\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+\n+            if ($mask & multicast) == multicast {\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(!ip!($s).is_multicast());\n+            }\n+\n+            if ($mask & broadcast) == broadcast {\n+                assert!(ip!($s).is_broadcast());\n+            } else {\n+                assert!(!ip!($s).is_broadcast());\n+            }\n+\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+\n+            if ($mask & benchmarking) == benchmarking {\n+                assert!(ip!($s).is_benchmarking());\n+            } else {\n+                assert!(!ip!($s).is_benchmarking());\n+            }\n+\n+            if ($mask & ietf_protocol_assignment) == ietf_protocol_assignment {\n+                assert!(ip!($s).is_ietf_protocol_assignment());\n+            } else {\n+                assert!(!ip!($s).is_ietf_protocol_assignment());\n+            }\n+\n+            if ($mask & reserved) == reserved {\n+                assert!(ip!($s).is_reserved());\n+            } else {\n+                assert!(!ip!($s).is_reserved());\n+            }\n+\n+            if ($mask & shared) == shared {\n+                assert!(ip!($s).is_shared());\n+            } else {\n+                assert!(!ip!($s).is_shared());\n+            }\n+        }};\n+    }\n+\n+    let unspec: u16 = 1 << 0;\n+    let loopback: u16 = 1 << 1;\n+    let private: u16 = 1 << 2;\n+    let link_local: u16 = 1 << 3;\n+    let global: u16 = 1 << 4;\n+    let multicast: u16 = 1 << 5;\n+    let broadcast: u16 = 1 << 6;\n+    let documentation: u16 = 1 << 7;\n+    let benchmarking: u16 = 1 << 8;\n+    let ietf_protocol_assignment: u16 = 1 << 9;\n+    let reserved: u16 = 1 << 10;\n+    let shared: u16 = 1 << 11;\n+\n+    check!(\"0.0.0.0\", unspec);\n+    check!(\"0.0.0.1\");\n+    check!(\"0.1.0.0\");\n+    check!(\"10.9.8.7\", private);\n+    check!(\"127.1.2.3\", loopback);\n+    check!(\"172.31.254.253\", private);\n+    check!(\"169.254.253.242\", link_local);\n+    check!(\"192.0.2.183\", documentation);\n+    check!(\"192.1.2.183\", global);\n+    check!(\"192.168.254.253\", private);\n+    check!(\"198.51.100.0\", documentation);\n+    check!(\"203.0.113.0\", documentation);\n+    check!(\"203.2.113.0\", global);\n+    check!(\"224.0.0.0\", global | multicast);\n+    check!(\"239.255.255.255\", global | multicast);\n+    check!(\"255.255.255.255\", broadcast);\n+    check!(\"198.18.0.0\", benchmarking);\n+    check!(\"198.18.54.2\", benchmarking);\n+    check!(\"198.19.255.255\", benchmarking);\n+    check!(\"192.0.0.0\", ietf_protocol_assignment);\n+    check!(\"192.0.0.255\", ietf_protocol_assignment);\n+    check!(\"192.0.0.100\", ietf_protocol_assignment);\n+    check!(\"240.0.0.0\", reserved);\n+    check!(\"251.54.1.76\", reserved);\n+    check!(\"254.255.255.255\", reserved);\n+    check!(\"100.64.0.0\", shared);\n+    check!(\"100.127.255.255\", shared);\n+    check!(\"100.100.100.0\", shared);\n+}\n+\n+#[test]\n+fn ipv6_properties() {\n+    macro_rules! ip {\n+        ($s:expr) => {\n+            Ipv6Addr::from_str($s).unwrap()\n+        };\n+    }\n+\n+    macro_rules! check {\n+        ($s:expr, &[$($octet:expr),*], $mask:expr) => {\n+            assert_eq!($s, ip!($s).to_string());\n+            let octets = &[$($octet),*];\n+            assert_eq!(&ip!($s).octets(), octets);\n+            assert_eq!(Ipv6Addr::from(*octets), ip!($s));\n+\n+            let unspecified: u16 = 1 << 0;\n+            let loopback: u16 = 1 << 1;\n+            let unique_local: u16 = 1 << 2;\n+            let global: u16 = 1 << 3;\n+            let unicast_link_local: u16 = 1 << 4;\n+            let unicast_link_local_strict: u16 = 1 << 5;\n+            let unicast_site_local: u16 = 1 << 6;\n+            let unicast_global: u16 = 1 << 7;\n+            let documentation: u16 = 1 << 8;\n+            let multicast_interface_local: u16 = 1 << 9;\n+            let multicast_link_local: u16 = 1 << 10;\n+            let multicast_realm_local: u16 = 1 << 11;\n+            let multicast_admin_local: u16 = 1 << 12;\n+            let multicast_site_local: u16 = 1 << 13;\n+            let multicast_organization_local: u16 = 1 << 14;\n+            let multicast_global: u16 = 1 << 15;\n+            let multicast: u16 = multicast_interface_local\n+                | multicast_admin_local\n+                | multicast_global\n+                | multicast_link_local\n+                | multicast_realm_local\n+                | multicast_site_local\n+                | multicast_organization_local;\n+\n+            if ($mask & unspecified) == unspecified {\n+                assert!(ip!($s).is_unspecified());\n+            } else {\n+                assert!(!ip!($s).is_unspecified());\n+            }\n+            if ($mask & loopback) == loopback {\n+                assert!(ip!($s).is_loopback());\n+            } else {\n+                assert!(!ip!($s).is_loopback());\n+            }\n+            if ($mask & unique_local) == unique_local {\n+                assert!(ip!($s).is_unique_local());\n+            } else {\n+                assert!(!ip!($s).is_unique_local());\n+            }\n+            if ($mask & global) == global {\n+                assert!(ip!($s).is_global());\n+            } else {\n+                assert!(!ip!($s).is_global());\n+            }\n+            if ($mask & unicast_link_local) == unicast_link_local {\n+                assert!(ip!($s).is_unicast_link_local());\n+            } else {\n+                assert!(!ip!($s).is_unicast_link_local());\n+            }\n+            if ($mask & unicast_link_local_strict) == unicast_link_local_strict {\n+                assert!(ip!($s).is_unicast_link_local_strict());\n+            } else {\n+                assert!(!ip!($s).is_unicast_link_local_strict());\n+            }\n+            if ($mask & unicast_site_local) == unicast_site_local {\n+                assert!(ip!($s).is_unicast_site_local());\n+            } else {\n+                assert!(!ip!($s).is_unicast_site_local());\n+            }\n+            if ($mask & unicast_global) == unicast_global {\n+                assert!(ip!($s).is_unicast_global());\n+            } else {\n+                assert!(!ip!($s).is_unicast_global());\n+            }\n+            if ($mask & documentation) == documentation {\n+                assert!(ip!($s).is_documentation());\n+            } else {\n+                assert!(!ip!($s).is_documentation());\n+            }\n+            if ($mask & multicast) != 0 {\n+                assert!(ip!($s).multicast_scope().is_some());\n+                assert!(ip!($s).is_multicast());\n+            } else {\n+                assert!(ip!($s).multicast_scope().is_none());\n+                assert!(!ip!($s).is_multicast());\n+            }\n+            if ($mask & multicast_interface_local) == multicast_interface_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::InterfaceLocal);\n+            }\n+            if ($mask & multicast_link_local) == multicast_link_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::LinkLocal);\n+            }\n+            if ($mask & multicast_realm_local) == multicast_realm_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::RealmLocal);\n+            }\n+            if ($mask & multicast_admin_local) == multicast_admin_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::AdminLocal);\n+            }\n+            if ($mask & multicast_site_local) == multicast_site_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::SiteLocal);\n+            }\n+            if ($mask & multicast_organization_local) == multicast_organization_local {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::OrganizationLocal);\n+            }\n+            if ($mask & multicast_global) == multicast_global {\n+                assert_eq!(ip!($s).multicast_scope().unwrap(),\n+                           Ipv6MulticastScope::Global);\n+            }\n+        }\n+    }\n+\n+    let unspecified: u16 = 1 << 0;\n+    let loopback: u16 = 1 << 1;\n+    let unique_local: u16 = 1 << 2;\n+    let global: u16 = 1 << 3;\n+    let unicast_link_local: u16 = 1 << 4;\n+    let unicast_link_local_strict: u16 = 1 << 5;\n+    let unicast_site_local: u16 = 1 << 6;\n+    let unicast_global: u16 = 1 << 7;\n+    let documentation: u16 = 1 << 8;\n+    let multicast_interface_local: u16 = 1 << 9;\n+    let multicast_link_local: u16 = 1 << 10;\n+    let multicast_realm_local: u16 = 1 << 11;\n+    let multicast_admin_local: u16 = 1 << 12;\n+    let multicast_site_local: u16 = 1 << 13;\n+    let multicast_organization_local: u16 = 1 << 14;\n+    let multicast_global: u16 = 1 << 15;\n+\n+    check!(\"::\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unspecified);\n+\n+    check!(\"::1\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], loopback);\n+\n+    check!(\"::0.0.0.2\", &[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], global | unicast_global);\n+\n+    check!(\"1::\", &[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], global | unicast_global);\n+\n+    check!(\"fc00::\", &[0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unique_local);\n+\n+    check!(\n+        \"fdff:ffff::\",\n+        &[0xfd, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unique_local\n+    );\n+\n+    check!(\n+        \"fe80:ffff::\",\n+        &[0xfe, 0x80, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80::\",\n+        &[0xfe, 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local | unicast_link_local_strict\n+    );\n+\n+    check!(\n+        \"febf:ffff::\",\n+        &[0xfe, 0xbf, 0xff, 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\"febf::\", &[0xfe, 0xbf, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], unicast_link_local);\n+\n+    check!(\n+        \"febf:ffff:ffff:ffff:ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fe80::ffff:ffff:ffff:ffff\",\n+        &[\n+            0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+            0xff, 0xff\n+        ],\n+        unicast_link_local | unicast_link_local_strict\n+    );\n+\n+    check!(\n+        \"fe80:0:0:1::\",\n+        &[0xfe, 0x80, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_link_local\n+    );\n+\n+    check!(\n+        \"fec0::\",\n+        &[0xfe, 0xc0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        unicast_site_local | unicast_global | global\n+    );\n+\n+    check!(\n+        \"ff01::\",\n+        &[0xff, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_interface_local\n+    );\n+\n+    check!(\"ff02::\", &[0xff, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_link_local);\n+\n+    check!(\"ff03::\", &[0xff, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_realm_local);\n+\n+    check!(\"ff04::\", &[0xff, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_admin_local);\n+\n+    check!(\"ff05::\", &[0xff, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], multicast_site_local);\n+\n+    check!(\n+        \"ff08::\",\n+        &[0xff, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_organization_local\n+    );\n+\n+    check!(\n+        \"ff0e::\",\n+        &[0xff, 0xe, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        multicast_global | global\n+    );\n+\n+    check!(\n+        \"2001:db8:85a3::8a2e:370:7334\",\n+        &[0x20, 1, 0xd, 0xb8, 0x85, 0xa3, 0, 0, 0, 0, 0x8a, 0x2e, 3, 0x70, 0x73, 0x34],\n+        documentation\n+    );\n+\n+    check!(\n+        \"102:304:506:708:90a:b0c:d0e:f10\",\n+        &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n+        global | unicast_global\n+    );\n+}\n+\n+#[test]\n+fn to_socket_addr_socketaddr() {\n+    let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n+    assert_eq!(Ok(vec![a]), tsa(a));\n+}\n+\n+#[test]\n+fn test_ipv4_to_int() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(u32::from(a), 0x11223344);\n+}\n+\n+#[test]\n+fn test_int_to_ipv4() {\n+    let a = Ipv4Addr::new(0x11, 0x22, 0x33, 0x44);\n+    assert_eq!(Ipv4Addr::from(0x11223344), a);\n+}\n+\n+#[test]\n+fn test_ipv6_to_int() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(u128::from(a), 0x112233445566778899aabbccddeeff11u128);\n+}\n+\n+#[test]\n+fn test_int_to_ipv6() {\n+    let a = Ipv6Addr::new(0x1122, 0x3344, 0x5566, 0x7788, 0x99aa, 0xbbcc, 0xddee, 0xff11);\n+    assert_eq!(Ipv6Addr::from(0x112233445566778899aabbccddeeff11u128), a);\n+}\n+\n+#[test]\n+fn ipv4_from_constructors() {\n+    assert_eq!(Ipv4Addr::LOCALHOST, Ipv4Addr::new(127, 0, 0, 1));\n+    assert!(Ipv4Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv4Addr::UNSPECIFIED, Ipv4Addr::new(0, 0, 0, 0));\n+    assert!(Ipv4Addr::UNSPECIFIED.is_unspecified());\n+    assert_eq!(Ipv4Addr::BROADCAST, Ipv4Addr::new(255, 255, 255, 255));\n+    assert!(Ipv4Addr::BROADCAST.is_broadcast());\n+}\n+\n+#[test]\n+fn ipv6_from_contructors() {\n+    assert_eq!(Ipv6Addr::LOCALHOST, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+    assert!(Ipv6Addr::LOCALHOST.is_loopback());\n+    assert_eq!(Ipv6Addr::UNSPECIFIED, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+    assert!(Ipv6Addr::UNSPECIFIED.is_unspecified());\n+}\n+\n+#[test]\n+fn ipv4_from_octets() {\n+    assert_eq!(Ipv4Addr::from([127, 0, 0, 1]), Ipv4Addr::new(127, 0, 0, 1))\n+}\n+\n+#[test]\n+fn ipv6_from_segments() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let new = Ipv6Addr::new(0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff);\n+    assert_eq!(new, from_u16s);\n+}\n+\n+#[test]\n+fn ipv6_from_octets() {\n+    let from_u16s =\n+        Ipv6Addr::from([0x0011, 0x2233, 0x4455, 0x6677, 0x8899, 0xaabb, 0xccdd, 0xeeff]);\n+    let from_u8s = Ipv6Addr::from([\n+        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee,\n+        0xff,\n+    ]);\n+    assert_eq!(from_u16s, from_u8s);\n+}\n+\n+#[test]\n+fn cmp() {\n+    let v41 = Ipv4Addr::new(100, 64, 3, 3);\n+    let v42 = Ipv4Addr::new(192, 0, 2, 2);\n+    let v61 = \"2001:db8:f00::1002\".parse::<Ipv6Addr>().unwrap();\n+    let v62 = \"2001:db8:f00::2001\".parse::<Ipv6Addr>().unwrap();\n+    assert!(v41 < v42);\n+    assert!(v61 < v62);\n+\n+    assert_eq!(v41, IpAddr::V4(v41));\n+    assert_eq!(v61, IpAddr::V6(v61));\n+    assert!(v41 != IpAddr::V4(v42));\n+    assert!(v61 != IpAddr::V6(v62));\n+\n+    assert!(v41 < IpAddr::V4(v42));\n+    assert!(v61 < IpAddr::V6(v62));\n+    assert!(IpAddr::V4(v41) < v42);\n+    assert!(IpAddr::V6(v61) < v62);\n+\n+    assert!(v41 < IpAddr::V6(v61));\n+    assert!(IpAddr::V4(v41) < v61);\n+}\n+\n+#[test]\n+fn is_v4() {\n+    let ip = IpAddr::V4(Ipv4Addr::new(100, 64, 3, 3));\n+    assert!(ip.is_ipv4());\n+    assert!(!ip.is_ipv6());\n+}\n+\n+#[test]\n+fn is_v6() {\n+    let ip = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0xffff, 0x1234, 0x5678));\n+    assert!(!ip.is_ipv4());\n+    assert!(ip.is_ipv6());\n+}"}, {"sha": "0570a7c41bfe60b62390d4fac0b3124e629779c2", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 3, "deletions": 143, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -3,6 +3,9 @@\n //! This module is \"publicly exported\" through the `FromStr` implementations\n //! below.\n \n+#[cfg(test)]\n+mod tests;\n+\n use crate::error::Error;\n use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n@@ -321,146 +324,3 @@ impl Error for AddrParseError {\n         \"invalid IP address syntax\"\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    // FIXME: These tests are all excellent candidates for AFL fuzz testing\n-    use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n-    use crate::str::FromStr;\n-\n-    const PORT: u16 = 8080;\n-\n-    const IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\n-    const IPV4_STR: &str = \"192.168.0.1\";\n-    const IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\n-\n-    const IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\n-    const IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\n-    const IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\n-    const IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\n-    const IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\n-\n-    #[test]\n-    fn parse_ipv4() {\n-        let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n-        assert_eq!(result, IPV4);\n-\n-        assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n-        assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n-        assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n-        assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n-        assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n-    }\n-\n-    #[test]\n-    fn parse_ipv6() {\n-        let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n-        assert_eq!(result, IPV6);\n-\n-        let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n-        assert_eq!(result, IPV6);\n-\n-        let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n-        assert_eq!(result, IPV6);\n-\n-        assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n-        assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n-        assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n-    }\n-\n-    #[test]\n-    fn parse_ip() {\n-        let result: IpAddr = IPV4_STR.parse().unwrap();\n-        assert_eq!(result, IpAddr::from(IPV4));\n-\n-        let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n-        assert_eq!(result, IpAddr::from(IPV6));\n-\n-        let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n-        assert_eq!(result, IpAddr::from(IPV6));\n-\n-        let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n-        assert_eq!(result, IpAddr::from(IPV6));\n-\n-        assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n-        assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n-    }\n-\n-    #[test]\n-    fn parse_socket_v4() {\n-        let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n-        assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n-\n-        assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n-        assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n-        assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n-        assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n-        assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n-    }\n-\n-    #[test]\n-    fn parse_socket_v6() {\n-        let result: SocketAddrV6 = IPV6_STR_PORT.parse().unwrap();\n-        assert_eq!(result, SocketAddrV6::new(IPV6, PORT, 0, 0));\n-\n-        assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n-        assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n-        assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n-        assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n-        assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n-    }\n-\n-    #[test]\n-    fn parse_socket() {\n-        let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n-        assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n-\n-        let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n-        assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n-\n-        assert!(SocketAddr::from_str(IPV4_STR).is_err());\n-        assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n-        assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n-        assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n-    }\n-\n-    #[test]\n-    fn ipv6_corner_cases() {\n-        let result: Ipv6Addr = \"1::\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n-\n-        let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n-\n-        let result: Ipv6Addr = \"::1\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n-\n-        let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n-\n-        let result: Ipv6Addr = \"::\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n-\n-        let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n-\n-        let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n-\n-        let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n-        assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n-    }\n-\n-    // Things that might not seem like failures but are\n-    #[test]\n-    fn ipv6_corner_failures() {\n-        // No IP address before the ::\n-        assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n-\n-        // :: must have at least 1 set of zeroes\n-        assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n-\n-        // Need brackets for a port\n-        assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n-    }\n-}"}, {"sha": "ecf5a782c0c23c8a9635a3c92838941c9bb22638", "filename": "library/std/src/net/parser/tests.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fparser%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fparser%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,139 @@\n+// FIXME: These tests are all excellent candidates for AFL fuzz testing\n+use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+use crate::str::FromStr;\n+\n+const PORT: u16 = 8080;\n+\n+const IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\n+const IPV4_STR: &str = \"192.168.0.1\";\n+const IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\n+\n+const IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\n+const IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\n+const IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\n+const IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\n+const IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\n+\n+#[test]\n+fn parse_ipv4() {\n+    let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n+    assert_eq!(result, IPV4);\n+\n+    assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n+    assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n+    assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n+    assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n+    assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n+}\n+\n+#[test]\n+fn parse_ipv6() {\n+    let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n+    assert_eq!(result, IPV6);\n+\n+    let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n+    assert_eq!(result, IPV6);\n+\n+    let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n+    assert_eq!(result, IPV6);\n+\n+    assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n+    assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n+    assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n+}\n+\n+#[test]\n+fn parse_ip() {\n+    let result: IpAddr = IPV4_STR.parse().unwrap();\n+    assert_eq!(result, IpAddr::from(IPV4));\n+\n+    let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n+    assert_eq!(result, IpAddr::from(IPV6));\n+\n+    let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n+    assert_eq!(result, IpAddr::from(IPV6));\n+\n+    let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n+    assert_eq!(result, IpAddr::from(IPV6));\n+\n+    assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n+    assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n+}\n+\n+#[test]\n+fn parse_socket_v4() {\n+    let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n+    assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n+\n+    assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n+    assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n+    assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n+    assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n+    assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n+}\n+\n+#[test]\n+fn parse_socket_v6() {\n+    let result: SocketAddrV6 = IPV6_STR_PORT.parse().unwrap();\n+    assert_eq!(result, SocketAddrV6::new(IPV6, PORT, 0, 0));\n+\n+    assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n+    assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n+    assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n+    assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n+    assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n+}\n+\n+#[test]\n+fn parse_socket() {\n+    let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n+    assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n+\n+    let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n+    assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n+\n+    assert!(SocketAddr::from_str(IPV4_STR).is_err());\n+    assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n+    assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n+    assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n+}\n+\n+#[test]\n+fn ipv6_corner_cases() {\n+    let result: Ipv6Addr = \"1::\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n+\n+    let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n+\n+    let result: Ipv6Addr = \"::1\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+\n+    let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n+\n+    let result: Ipv6Addr = \"::\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+\n+    let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n+\n+    let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n+\n+    let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n+    assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n+}\n+\n+// Things that might not seem like failures but are\n+#[test]\n+fn ipv6_corner_failures() {\n+    // No IP address before the ::\n+    assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n+\n+    // :: must have at least 1 set of zeroes\n+    assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n+\n+    // Need brackets for a port\n+    assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n+}"}, {"sha": "58c6343ea34ae9f89ffdaa2b1b15373ee7594d0f", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 866, "changes": 870, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,4 +1,8 @@\n #![deny(unsafe_op_in_unsafe_fn)]\n+\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n+mod tests;\n+\n use crate::io::prelude::*;\n \n use crate::fmt;\n@@ -936,869 +940,3 @@ impl fmt::Debug for TcpListener {\n         self.0.fmt(f)\n     }\n }\n-\n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n-mod tests {\n-    use crate::fmt;\n-    use crate::io::prelude::*;\n-    use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n-    use crate::net::test::{next_test_ip4, next_test_ip6};\n-    use crate::net::*;\n-    use crate::sync::mpsc::channel;\n-    use crate::thread;\n-    use crate::time::{Duration, Instant};\n-\n-    fn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n-        f(next_test_ip4());\n-        f(next_test_ip6());\n-    }\n-\n-    macro_rules! t {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn bind_error() {\n-        match TcpListener::bind(\"1.1.1.1:9999\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        match TcpStream::connect(\"0.0.0.0:1\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert!(\n-                e.kind() == ErrorKind::ConnectionRefused\n-                    || e.kind() == ErrorKind::InvalidInput\n-                    || e.kind() == ErrorKind::AddrInUse\n-                    || e.kind() == ErrorKind::AddrNotAvailable,\n-                \"bad error: {} {:?}\",\n-                e,\n-                e.kind()\n-            ),\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_localhost() {\n-        let socket_addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&socket_addr));\n-\n-        let _t = thread::spawn(move || {\n-            let mut stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n-            t!(stream.write(&[144]));\n-        });\n-\n-        let mut stream = t!(listener.accept()).0;\n-        let mut buf = [0];\n-        t!(stream.read(&mut buf));\n-        assert!(buf[0] == 144);\n-    }\n-\n-    #[test]\n-    fn connect_loopback() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                let host = match addr {\n-                    SocketAddr::V4(..) => \"127.0.0.1\",\n-                    SocketAddr::V6(..) => \"::1\",\n-                };\n-                let mut stream = t!(TcpStream::connect(&(host, addr.port())));\n-                t!(stream.write(&[66]));\n-            });\n-\n-            let mut stream = t!(acceptor.accept()).0;\n-            let mut buf = [0];\n-            t!(stream.read(&mut buf));\n-            assert!(buf[0] == 66);\n-        })\n-    }\n-\n-    #[test]\n-    fn smoke_test() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let (tx, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut stream = t!(TcpStream::connect(&addr));\n-                t!(stream.write(&[99]));\n-                tx.send(t!(stream.local_addr())).unwrap();\n-            });\n-\n-            let (mut stream, addr) = t!(acceptor.accept());\n-            let mut buf = [0];\n-            t!(stream.read(&mut buf));\n-            assert!(buf[0] == 99);\n-            assert_eq!(addr, t!(rx.recv()));\n-        })\n-    }\n-\n-    #[test]\n-    fn read_eof() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                let _stream = t!(TcpStream::connect(&addr));\n-                // Close\n-            });\n-\n-            let mut stream = t!(acceptor.accept()).0;\n-            let mut buf = [0];\n-            let nread = t!(stream.read(&mut buf));\n-            assert_eq!(nread, 0);\n-            let nread = t!(stream.read(&mut buf));\n-            assert_eq!(nread, 0);\n-        })\n-    }\n-\n-    #[test]\n-    fn write_close() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let (tx, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                drop(t!(TcpStream::connect(&addr)));\n-                tx.send(()).unwrap();\n-            });\n-\n-            let mut stream = t!(acceptor.accept()).0;\n-            rx.recv().unwrap();\n-            let buf = [0];\n-            match stream.write(&buf) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    assert!(\n-                        e.kind() == ErrorKind::ConnectionReset\n-                            || e.kind() == ErrorKind::BrokenPipe\n-                            || e.kind() == ErrorKind::ConnectionAborted,\n-                        \"unknown error: {}\",\n-                        e\n-                    );\n-                }\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn multiple_connect_serial() {\n-        each_ip(&mut |addr| {\n-            let max = 10;\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                for _ in 0..max {\n-                    let mut stream = t!(TcpStream::connect(&addr));\n-                    t!(stream.write(&[99]));\n-                }\n-            });\n-\n-            for stream in acceptor.incoming().take(max) {\n-                let mut stream = t!(stream);\n-                let mut buf = [0];\n-                t!(stream.read(&mut buf));\n-                assert_eq!(buf[0], 99);\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule() {\n-        const MAX: usize = 10;\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                let acceptor = acceptor;\n-                for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n-                    // Start another thread to handle the connection\n-                    let _t = thread::spawn(move || {\n-                        let mut stream = t!(stream);\n-                        let mut buf = [0];\n-                        t!(stream.read(&mut buf));\n-                        assert!(buf[0] == i as u8);\n-                    });\n-                }\n-            });\n-\n-            connect(0, addr);\n-        });\n-\n-        fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX {\n-                return;\n-            }\n-\n-            let t = thread::spawn(move || {\n-                let mut stream = t!(TcpStream::connect(&addr));\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                t!(stream.write(&[i as u8]));\n-            });\n-            t.join().ok().expect(\"thread panicked\");\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule() {\n-        const MAX: usize = 10;\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                for stream in acceptor.incoming().take(MAX) {\n-                    // Start another thread to handle the connection\n-                    let _t = thread::spawn(move || {\n-                        let mut stream = t!(stream);\n-                        let mut buf = [0];\n-                        t!(stream.read(&mut buf));\n-                        assert!(buf[0] == 99);\n-                    });\n-                }\n-            });\n-\n-            connect(0, addr);\n-        });\n-\n-        fn connect(i: usize, addr: SocketAddr) {\n-            if i == MAX {\n-                return;\n-            }\n-\n-            let t = thread::spawn(move || {\n-                let mut stream = t!(TcpStream::connect(&addr));\n-                connect(i + 1, addr);\n-                t!(stream.write(&[99]));\n-            });\n-            t.join().ok().expect(\"thread panicked\");\n-        }\n-    }\n-\n-    #[test]\n-    fn socket_and_peer_name() {\n-        each_ip(&mut |addr| {\n-            let listener = t!(TcpListener::bind(&addr));\n-            let so_name = t!(listener.local_addr());\n-            assert_eq!(addr, so_name);\n-            let _t = thread::spawn(move || {\n-                t!(listener.accept());\n-            });\n-\n-            let stream = t!(TcpStream::connect(&addr));\n-            assert_eq!(addr, t!(stream.peer_addr()));\n-        })\n-    }\n-\n-    #[test]\n-    fn partial_read() {\n-        each_ip(&mut |addr| {\n-            let (tx, rx) = channel();\n-            let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move || {\n-                let mut cl = t!(srv.accept()).0;\n-                cl.write(&[10]).unwrap();\n-                let mut b = [0];\n-                t!(cl.read(&mut b));\n-                tx.send(()).unwrap();\n-            });\n-\n-            let mut c = t!(TcpStream::connect(&addr));\n-            let mut b = [0; 10];\n-            assert_eq!(c.read(&mut b).unwrap(), 1);\n-            t!(c.write(&[1]));\n-            rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn read_vectored() {\n-        each_ip(&mut |addr| {\n-            let srv = t!(TcpListener::bind(&addr));\n-            let mut s1 = t!(TcpStream::connect(&addr));\n-            let mut s2 = t!(srv.accept()).0;\n-\n-            let len = s1.write(&[10, 11, 12]).unwrap();\n-            assert_eq!(len, 3);\n-\n-            let mut a = [];\n-            let mut b = [0];\n-            let mut c = [0; 3];\n-            let len = t!(s2.read_vectored(&mut [\n-                IoSliceMut::new(&mut a),\n-                IoSliceMut::new(&mut b),\n-                IoSliceMut::new(&mut c)\n-            ],));\n-            assert!(len > 0);\n-            assert_eq!(b, [10]);\n-            // some implementations don't support readv, so we may only fill the first buffer\n-            assert!(len == 1 || c == [11, 12, 0]);\n-        })\n-    }\n-\n-    #[test]\n-    fn write_vectored() {\n-        each_ip(&mut |addr| {\n-            let srv = t!(TcpListener::bind(&addr));\n-            let mut s1 = t!(TcpStream::connect(&addr));\n-            let mut s2 = t!(srv.accept()).0;\n-\n-            let a = [];\n-            let b = [10];\n-            let c = [11, 12];\n-            t!(s1.write_vectored(&[IoSlice::new(&a), IoSlice::new(&b), IoSlice::new(&c)]));\n-\n-            let mut buf = [0; 4];\n-            let len = t!(s2.read(&mut buf));\n-            // some implementations don't support writev, so we may only write the first buffer\n-            if len == 1 {\n-                assert_eq!(buf, [10, 0, 0, 0]);\n-            } else {\n-                assert_eq!(len, 3);\n-                assert_eq!(buf, [10, 11, 12, 0]);\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn double_bind() {\n-        each_ip(&mut |addr| {\n-            let listener1 = t!(TcpListener::bind(&addr));\n-            match TcpListener::bind(&addr) {\n-                Ok(listener2) => panic!(\n-                    \"This system (perhaps due to options set by TcpListener::bind) \\\n-                     permits double binding: {:?} and {:?}\",\n-                    listener1, listener2\n-                ),\n-                Err(e) => {\n-                    assert!(\n-                        e.kind() == ErrorKind::ConnectionRefused\n-                            || e.kind() == ErrorKind::Other\n-                            || e.kind() == ErrorKind::AddrInUse,\n-                        \"unknown error: {} {:?}\",\n-                        e,\n-                        e.kind()\n-                    );\n-                }\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn tcp_clone_smoke() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                let mut s = t!(TcpStream::connect(&addr));\n-                let mut buf = [0, 0];\n-                assert_eq!(s.read(&mut buf).unwrap(), 1);\n-                assert_eq!(buf[0], 1);\n-                t!(s.write(&[2]));\n-            });\n-\n-            let mut s1 = t!(acceptor.accept()).0;\n-            let s2 = t!(s1.try_clone());\n-\n-            let (tx1, rx1) = channel();\n-            let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut s2 = s2;\n-                rx1.recv().unwrap();\n-                t!(s2.write(&[1]));\n-                tx2.send(()).unwrap();\n-            });\n-            tx1.send(()).unwrap();\n-            let mut buf = [0, 0];\n-            assert_eq!(s1.read(&mut buf).unwrap(), 1);\n-            rx2.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_read() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-            let (tx1, rx) = channel();\n-            let tx2 = tx1.clone();\n-\n-            let _t = thread::spawn(move || {\n-                let mut s = t!(TcpStream::connect(&addr));\n-                t!(s.write(&[1]));\n-                rx.recv().unwrap();\n-                t!(s.write(&[2]));\n-                rx.recv().unwrap();\n-            });\n-\n-            let mut s1 = t!(acceptor.accept()).0;\n-            let s2 = t!(s1.try_clone());\n-\n-            let (done, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut s2 = s2;\n-                let mut buf = [0, 0];\n-                t!(s2.read(&mut buf));\n-                tx2.send(()).unwrap();\n-                done.send(()).unwrap();\n-            });\n-            let mut buf = [0, 0];\n-            t!(s1.read(&mut buf));\n-            tx1.send(()).unwrap();\n-\n-            rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_write() {\n-        each_ip(&mut |addr| {\n-            let acceptor = t!(TcpListener::bind(&addr));\n-\n-            let _t = thread::spawn(move || {\n-                let mut s = t!(TcpStream::connect(&addr));\n-                let mut buf = [0, 1];\n-                t!(s.read(&mut buf));\n-                t!(s.read(&mut buf));\n-            });\n-\n-            let mut s1 = t!(acceptor.accept()).0;\n-            let s2 = t!(s1.try_clone());\n-\n-            let (done, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut s2 = s2;\n-                t!(s2.write(&[1]));\n-                done.send(()).unwrap();\n-            });\n-            t!(s1.write(&[2]));\n-\n-            rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n-    #[cfg_attr(target_env = \"sgx\", ignore)]\n-    fn shutdown_smoke() {\n-        each_ip(&mut |addr| {\n-            let a = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move || {\n-                let mut c = t!(a.accept()).0;\n-                let mut b = [0];\n-                assert_eq!(c.read(&mut b).unwrap(), 0);\n-                t!(c.write(&[1]));\n-            });\n-\n-            let mut s = t!(TcpStream::connect(&addr));\n-            t!(s.shutdown(Shutdown::Write));\n-            assert!(s.write(&[1]).is_err());\n-            let mut b = [0, 0];\n-            assert_eq!(t!(s.read(&mut b)), 1);\n-            assert_eq!(b[0], 1);\n-        })\n-    }\n-\n-    #[test]\n-    // FIXME: https://github.com/fortanix/rust-sgx/issues/110\n-    #[cfg_attr(target_env = \"sgx\", ignore)]\n-    fn close_readwrite_smoke() {\n-        each_ip(&mut |addr| {\n-            let a = t!(TcpListener::bind(&addr));\n-            let (tx, rx) = channel::<()>();\n-            let _t = thread::spawn(move || {\n-                let _s = t!(a.accept());\n-                let _ = rx.recv();\n-            });\n-\n-            let mut b = [0];\n-            let mut s = t!(TcpStream::connect(&addr));\n-            let mut s2 = t!(s.try_clone());\n-\n-            // closing should prevent reads/writes\n-            t!(s.shutdown(Shutdown::Write));\n-            assert!(s.write(&[0]).is_err());\n-            t!(s.shutdown(Shutdown::Read));\n-            assert_eq!(s.read(&mut b).unwrap(), 0);\n-\n-            // closing should affect previous handles\n-            assert!(s2.write(&[0]).is_err());\n-            assert_eq!(s2.read(&mut b).unwrap(), 0);\n-\n-            // closing should affect new handles\n-            let mut s3 = t!(s.try_clone());\n-            assert!(s3.write(&[0]).is_err());\n-            assert_eq!(s3.read(&mut b).unwrap(), 0);\n-\n-            // make sure these don't die\n-            let _ = s2.shutdown(Shutdown::Read);\n-            let _ = s2.shutdown(Shutdown::Write);\n-            let _ = s3.shutdown(Shutdown::Read);\n-            let _ = s3.shutdown(Shutdown::Write);\n-            drop(tx);\n-        })\n-    }\n-\n-    #[test]\n-    #[cfg(unix)] // test doesn't work on Windows, see #31657\n-    fn close_read_wakes_up() {\n-        each_ip(&mut |addr| {\n-            let a = t!(TcpListener::bind(&addr));\n-            let (tx1, rx) = channel::<()>();\n-            let _t = thread::spawn(move || {\n-                let _s = t!(a.accept());\n-                let _ = rx.recv();\n-            });\n-\n-            let s = t!(TcpStream::connect(&addr));\n-            let s2 = t!(s.try_clone());\n-            let (tx, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut s2 = s2;\n-                assert_eq!(t!(s2.read(&mut [0])), 0);\n-                tx.send(()).unwrap();\n-            });\n-            // this should wake up the child thread\n-            t!(s.shutdown(Shutdown::Read));\n-\n-            // this test will never finish if the child doesn't wake up\n-            rx.recv().unwrap();\n-            drop(tx1);\n-        })\n-    }\n-\n-    #[test]\n-    fn clone_while_reading() {\n-        each_ip(&mut |addr| {\n-            let accept = t!(TcpListener::bind(&addr));\n-\n-            // Enqueue a thread to write to a socket\n-            let (tx, rx) = channel();\n-            let (txdone, rxdone) = channel();\n-            let txdone2 = txdone.clone();\n-            let _t = thread::spawn(move || {\n-                let mut tcp = t!(TcpStream::connect(&addr));\n-                rx.recv().unwrap();\n-                t!(tcp.write(&[0]));\n-                txdone2.send(()).unwrap();\n-            });\n-\n-            // Spawn off a reading clone\n-            let tcp = t!(accept.accept()).0;\n-            let tcp2 = t!(tcp.try_clone());\n-            let txdone3 = txdone.clone();\n-            let _t = thread::spawn(move || {\n-                let mut tcp2 = tcp2;\n-                t!(tcp2.read(&mut [0]));\n-                txdone3.send(()).unwrap();\n-            });\n-\n-            // Try to ensure that the reading clone is indeed reading\n-            for _ in 0..50 {\n-                thread::yield_now();\n-            }\n-\n-            // clone the handle again while it's reading, then let it finish the\n-            // read.\n-            let _ = t!(tcp.try_clone());\n-            tx.send(()).unwrap();\n-            rxdone.recv().unwrap();\n-            rxdone.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn clone_accept_smoke() {\n-        each_ip(&mut |addr| {\n-            let a = t!(TcpListener::bind(&addr));\n-            let a2 = t!(a.try_clone());\n-\n-            let _t = thread::spawn(move || {\n-                let _ = TcpStream::connect(&addr);\n-            });\n-            let _t = thread::spawn(move || {\n-                let _ = TcpStream::connect(&addr);\n-            });\n-\n-            t!(a.accept());\n-            t!(a2.accept());\n-        })\n-    }\n-\n-    #[test]\n-    fn clone_accept_concurrent() {\n-        each_ip(&mut |addr| {\n-            let a = t!(TcpListener::bind(&addr));\n-            let a2 = t!(a.try_clone());\n-\n-            let (tx, rx) = channel();\n-            let tx2 = tx.clone();\n-\n-            let _t = thread::spawn(move || {\n-                tx.send(t!(a.accept())).unwrap();\n-            });\n-            let _t = thread::spawn(move || {\n-                tx2.send(t!(a2.accept())).unwrap();\n-            });\n-\n-            let _t = thread::spawn(move || {\n-                let _ = TcpStream::connect(&addr);\n-            });\n-            let _t = thread::spawn(move || {\n-                let _ = TcpStream::connect(&addr);\n-            });\n-\n-            rx.recv().unwrap();\n-            rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn debug() {\n-        #[cfg(not(target_env = \"sgx\"))]\n-        fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n-            addr\n-        }\n-        #[cfg(target_env = \"sgx\")]\n-        fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n-            addr.to_string()\n-        }\n-\n-        #[cfg(target_env = \"sgx\")]\n-        use crate::os::fortanix_sgx::io::AsRawFd;\n-        #[cfg(unix)]\n-        use crate::os::unix::io::AsRawFd;\n-        #[cfg(not(windows))]\n-        fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n-            addr.as_raw_fd()\n-        }\n-        #[cfg(windows)]\n-        fn render_inner(addr: &dyn crate::os::windows::io::AsRawSocket) -> impl fmt::Debug {\n-            addr.as_raw_socket()\n-        }\n-\n-        let inner_name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n-        let socket_addr = next_test_ip4();\n-\n-        let listener = t!(TcpListener::bind(&socket_addr));\n-        let compare = format!(\n-            \"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n-            render_socket_addr(&socket_addr),\n-            inner_name,\n-            render_inner(&listener)\n-        );\n-        assert_eq!(format!(\"{:?}\", listener), compare);\n-\n-        let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n-        let compare = format!(\n-            \"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n-            render_socket_addr(&stream.local_addr().unwrap()),\n-            render_socket_addr(&stream.peer_addr().unwrap()),\n-            inner_name,\n-            render_inner(&stream)\n-        );\n-        assert_eq!(format!(\"{:?}\", stream), compare);\n-    }\n-\n-    // FIXME: re-enabled openbsd tests once their socket timeout code\n-    //        no longer has rounding errors.\n-    // VxWorks ignores SO_SNDTIMEO.\n-    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    #[test]\n-    fn timeouts() {\n-        let addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&addr));\n-\n-        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-        let dur = Duration::new(15410, 0);\n-\n-        assert_eq!(None, t!(stream.read_timeout()));\n-\n-        t!(stream.set_read_timeout(Some(dur)));\n-        assert_eq!(Some(dur), t!(stream.read_timeout()));\n-\n-        assert_eq!(None, t!(stream.write_timeout()));\n-\n-        t!(stream.set_write_timeout(Some(dur)));\n-        assert_eq!(Some(dur), t!(stream.write_timeout()));\n-\n-        t!(stream.set_read_timeout(None));\n-        assert_eq!(None, t!(stream.read_timeout()));\n-\n-        t!(stream.set_write_timeout(None));\n-        assert_eq!(None, t!(stream.write_timeout()));\n-        drop(listener);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn test_read_timeout() {\n-        let addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&addr));\n-\n-        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-        t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut buf = [0; 10];\n-        let start = Instant::now();\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(\n-            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-            \"unexpected_error: {:?}\",\n-            kind\n-        );\n-        assert!(start.elapsed() > Duration::from_millis(400));\n-        drop(listener);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn test_read_with_timeout() {\n-        let addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&addr));\n-\n-        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-        t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut other_end = t!(listener.accept()).0;\n-        t!(other_end.write_all(b\"hello world\"));\n-\n-        let mut buf = [0; 11];\n-        t!(stream.read(&mut buf));\n-        assert_eq!(b\"hello world\", &buf[..]);\n-\n-        let start = Instant::now();\n-        let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n-        assert!(\n-            kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-            \"unexpected_error: {:?}\",\n-            kind\n-        );\n-        assert!(start.elapsed() > Duration::from_millis(400));\n-        drop(listener);\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_timeout_zero_duration() {\n-        let addr = next_test_ip4();\n-\n-        let listener = t!(TcpListener::bind(&addr));\n-        let stream = t!(TcpStream::connect(&addr));\n-\n-        let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        drop(listener);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)]\n-    fn nodelay() {\n-        let addr = next_test_ip4();\n-        let _listener = t!(TcpListener::bind(&addr));\n-\n-        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-\n-        assert_eq!(false, t!(stream.nodelay()));\n-        t!(stream.set_nodelay(true));\n-        assert_eq!(true, t!(stream.nodelay()));\n-        t!(stream.set_nodelay(false));\n-        assert_eq!(false, t!(stream.nodelay()));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)]\n-    fn ttl() {\n-        let ttl = 100;\n-\n-        let addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&addr));\n-\n-        t!(listener.set_ttl(ttl));\n-        assert_eq!(ttl, t!(listener.ttl()));\n-\n-        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-\n-        t!(stream.set_ttl(ttl));\n-        assert_eq!(ttl, t!(stream.ttl()));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)]\n-    fn set_nonblocking() {\n-        let addr = next_test_ip4();\n-        let listener = t!(TcpListener::bind(&addr));\n-\n-        t!(listener.set_nonblocking(true));\n-        t!(listener.set_nonblocking(false));\n-\n-        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n-\n-        t!(stream.set_nonblocking(false));\n-        t!(stream.set_nonblocking(true));\n-\n-        let mut buf = [0];\n-        match stream.read(&mut buf) {\n-            Ok(_) => panic!(\"expected error\"),\n-            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n-            Err(e) => panic!(\"unexpected error {}\", e),\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn peek() {\n-        each_ip(&mut |addr| {\n-            let (txdone, rxdone) = channel();\n-\n-            let srv = t!(TcpListener::bind(&addr));\n-            let _t = thread::spawn(move || {\n-                let mut cl = t!(srv.accept()).0;\n-                cl.write(&[1, 3, 3, 7]).unwrap();\n-                t!(rxdone.recv());\n-            });\n-\n-            let mut c = t!(TcpStream::connect(&addr));\n-            let mut b = [0; 10];\n-            for _ in 1..3 {\n-                let len = c.peek(&mut b).unwrap();\n-                assert_eq!(len, 4);\n-            }\n-            let len = c.read(&mut b).unwrap();\n-            assert_eq!(len, 4);\n-\n-            t!(c.set_nonblocking(true));\n-            match c.peek(&mut b) {\n-                Ok(_) => panic!(\"expected error\"),\n-                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n-                Err(e) => panic!(\"unexpected error {}\", e),\n-            }\n-            t!(txdone.send(()));\n-        })\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n-    fn connect_timeout_valid() {\n-        let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n-        let addr = listener.local_addr().unwrap();\n-        TcpStream::connect_timeout(&addr, Duration::from_secs(2)).unwrap();\n-    }\n-}"}, {"sha": "abe9bc24cecb061fe571131575d8af206ddbe970", "filename": "library/std/src/net/tcp/tests.rs", "status": "added", "additions": 862, "deletions": 0, "changes": 862, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,862 @@\n+use crate::fmt;\n+use crate::io::prelude::*;\n+use crate::io::{ErrorKind, IoSlice, IoSliceMut};\n+use crate::net::test::{next_test_ip4, next_test_ip6};\n+use crate::net::*;\n+use crate::sync::mpsc::channel;\n+use crate::thread;\n+use crate::time::{Duration, Instant};\n+\n+fn each_ip(f: &mut dyn FnMut(SocketAddr)) {\n+    f(next_test_ip4());\n+    f(next_test_ip6());\n+}\n+\n+macro_rules! t {\n+    ($e:expr) => {\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+        }\n+    };\n+}\n+\n+#[test]\n+fn bind_error() {\n+    match TcpListener::bind(\"1.1.1.1:9999\") {\n+        Ok(..) => panic!(),\n+        Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n+    }\n+}\n+\n+#[test]\n+fn connect_error() {\n+    match TcpStream::connect(\"0.0.0.0:1\") {\n+        Ok(..) => panic!(),\n+        Err(e) => assert!(\n+            e.kind() == ErrorKind::ConnectionRefused\n+                || e.kind() == ErrorKind::InvalidInput\n+                || e.kind() == ErrorKind::AddrInUse\n+                || e.kind() == ErrorKind::AddrNotAvailable,\n+            \"bad error: {} {:?}\",\n+            e,\n+            e.kind()\n+        ),\n+    }\n+}\n+\n+#[test]\n+fn listen_localhost() {\n+    let socket_addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&socket_addr));\n+\n+    let _t = thread::spawn(move || {\n+        let mut stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n+        t!(stream.write(&[144]));\n+    });\n+\n+    let mut stream = t!(listener.accept()).0;\n+    let mut buf = [0];\n+    t!(stream.read(&mut buf));\n+    assert!(buf[0] == 144);\n+}\n+\n+#[test]\n+fn connect_loopback() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            let host = match addr {\n+                SocketAddr::V4(..) => \"127.0.0.1\",\n+                SocketAddr::V6(..) => \"::1\",\n+            };\n+            let mut stream = t!(TcpStream::connect(&(host, addr.port())));\n+            t!(stream.write(&[66]));\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 66);\n+    })\n+}\n+\n+#[test]\n+fn smoke_test() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let (tx, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut stream = t!(TcpStream::connect(&addr));\n+            t!(stream.write(&[99]));\n+            tx.send(t!(stream.local_addr())).unwrap();\n+        });\n+\n+        let (mut stream, addr) = t!(acceptor.accept());\n+        let mut buf = [0];\n+        t!(stream.read(&mut buf));\n+        assert!(buf[0] == 99);\n+        assert_eq!(addr, t!(rx.recv()));\n+    })\n+}\n+\n+#[test]\n+fn read_eof() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            let _stream = t!(TcpStream::connect(&addr));\n+            // Close\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        let mut buf = [0];\n+        let nread = t!(stream.read(&mut buf));\n+        assert_eq!(nread, 0);\n+        let nread = t!(stream.read(&mut buf));\n+        assert_eq!(nread, 0);\n+    })\n+}\n+\n+#[test]\n+fn write_close() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let (tx, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            drop(t!(TcpStream::connect(&addr)));\n+            tx.send(()).unwrap();\n+        });\n+\n+        let mut stream = t!(acceptor.accept()).0;\n+        rx.recv().unwrap();\n+        let buf = [0];\n+        match stream.write(&buf) {\n+            Ok(..) => {}\n+            Err(e) => {\n+                assert!(\n+                    e.kind() == ErrorKind::ConnectionReset\n+                        || e.kind() == ErrorKind::BrokenPipe\n+                        || e.kind() == ErrorKind::ConnectionAborted,\n+                    \"unknown error: {}\",\n+                    e\n+                );\n+            }\n+        }\n+    })\n+}\n+\n+#[test]\n+fn multiple_connect_serial() {\n+    each_ip(&mut |addr| {\n+        let max = 10;\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            for _ in 0..max {\n+                let mut stream = t!(TcpStream::connect(&addr));\n+                t!(stream.write(&[99]));\n+            }\n+        });\n+\n+        for stream in acceptor.incoming().take(max) {\n+            let mut stream = t!(stream);\n+            let mut buf = [0];\n+            t!(stream.read(&mut buf));\n+            assert_eq!(buf[0], 99);\n+        }\n+    })\n+}\n+\n+#[test]\n+fn multiple_connect_interleaved_greedy_schedule() {\n+    const MAX: usize = 10;\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            let acceptor = acceptor;\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n+                // Start another thread to handle the connection\n+                let _t = thread::spawn(move || {\n+                    let mut stream = t!(stream);\n+                    let mut buf = [0];\n+                    t!(stream.read(&mut buf));\n+                    assert!(buf[0] == i as u8);\n+                });\n+            }\n+        });\n+\n+        connect(0, addr);\n+    });\n+\n+    fn connect(i: usize, addr: SocketAddr) {\n+        if i == MAX {\n+            return;\n+        }\n+\n+        let t = thread::spawn(move || {\n+            let mut stream = t!(TcpStream::connect(&addr));\n+            // Connect again before writing\n+            connect(i + 1, addr);\n+            t!(stream.write(&[i as u8]));\n+        });\n+        t.join().ok().expect(\"thread panicked\");\n+    }\n+}\n+\n+#[test]\n+fn multiple_connect_interleaved_lazy_schedule() {\n+    const MAX: usize = 10;\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            for stream in acceptor.incoming().take(MAX) {\n+                // Start another thread to handle the connection\n+                let _t = thread::spawn(move || {\n+                    let mut stream = t!(stream);\n+                    let mut buf = [0];\n+                    t!(stream.read(&mut buf));\n+                    assert!(buf[0] == 99);\n+                });\n+            }\n+        });\n+\n+        connect(0, addr);\n+    });\n+\n+    fn connect(i: usize, addr: SocketAddr) {\n+        if i == MAX {\n+            return;\n+        }\n+\n+        let t = thread::spawn(move || {\n+            let mut stream = t!(TcpStream::connect(&addr));\n+            connect(i + 1, addr);\n+            t!(stream.write(&[99]));\n+        });\n+        t.join().ok().expect(\"thread panicked\");\n+    }\n+}\n+\n+#[test]\n+fn socket_and_peer_name() {\n+    each_ip(&mut |addr| {\n+        let listener = t!(TcpListener::bind(&addr));\n+        let so_name = t!(listener.local_addr());\n+        assert_eq!(addr, so_name);\n+        let _t = thread::spawn(move || {\n+            t!(listener.accept());\n+        });\n+\n+        let stream = t!(TcpStream::connect(&addr));\n+        assert_eq!(addr, t!(stream.peer_addr()));\n+    })\n+}\n+\n+#[test]\n+fn partial_read() {\n+    each_ip(&mut |addr| {\n+        let (tx, rx) = channel();\n+        let srv = t!(TcpListener::bind(&addr));\n+        let _t = thread::spawn(move || {\n+            let mut cl = t!(srv.accept()).0;\n+            cl.write(&[10]).unwrap();\n+            let mut b = [0];\n+            t!(cl.read(&mut b));\n+            tx.send(()).unwrap();\n+        });\n+\n+        let mut c = t!(TcpStream::connect(&addr));\n+        let mut b = [0; 10];\n+        assert_eq!(c.read(&mut b).unwrap(), 1);\n+        t!(c.write(&[1]));\n+        rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn read_vectored() {\n+    each_ip(&mut |addr| {\n+        let srv = t!(TcpListener::bind(&addr));\n+        let mut s1 = t!(TcpStream::connect(&addr));\n+        let mut s2 = t!(srv.accept()).0;\n+\n+        let len = s1.write(&[10, 11, 12]).unwrap();\n+        assert_eq!(len, 3);\n+\n+        let mut a = [];\n+        let mut b = [0];\n+        let mut c = [0; 3];\n+        let len = t!(s2.read_vectored(&mut [\n+            IoSliceMut::new(&mut a),\n+            IoSliceMut::new(&mut b),\n+            IoSliceMut::new(&mut c)\n+        ],));\n+        assert!(len > 0);\n+        assert_eq!(b, [10]);\n+        // some implementations don't support readv, so we may only fill the first buffer\n+        assert!(len == 1 || c == [11, 12, 0]);\n+    })\n+}\n+\n+#[test]\n+fn write_vectored() {\n+    each_ip(&mut |addr| {\n+        let srv = t!(TcpListener::bind(&addr));\n+        let mut s1 = t!(TcpStream::connect(&addr));\n+        let mut s2 = t!(srv.accept()).0;\n+\n+        let a = [];\n+        let b = [10];\n+        let c = [11, 12];\n+        t!(s1.write_vectored(&[IoSlice::new(&a), IoSlice::new(&b), IoSlice::new(&c)]));\n+\n+        let mut buf = [0; 4];\n+        let len = t!(s2.read(&mut buf));\n+        // some implementations don't support writev, so we may only write the first buffer\n+        if len == 1 {\n+            assert_eq!(buf, [10, 0, 0, 0]);\n+        } else {\n+            assert_eq!(len, 3);\n+            assert_eq!(buf, [10, 11, 12, 0]);\n+        }\n+    })\n+}\n+\n+#[test]\n+fn double_bind() {\n+    each_ip(&mut |addr| {\n+        let listener1 = t!(TcpListener::bind(&addr));\n+        match TcpListener::bind(&addr) {\n+            Ok(listener2) => panic!(\n+                \"This system (perhaps due to options set by TcpListener::bind) \\\n+                 permits double binding: {:?} and {:?}\",\n+                listener1, listener2\n+            ),\n+            Err(e) => {\n+                assert!(\n+                    e.kind() == ErrorKind::ConnectionRefused\n+                        || e.kind() == ErrorKind::Other\n+                        || e.kind() == ErrorKind::AddrInUse,\n+                    \"unknown error: {} {:?}\",\n+                    e,\n+                    e.kind()\n+                );\n+            }\n+        }\n+    })\n+}\n+\n+#[test]\n+fn tcp_clone_smoke() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            let mut s = t!(TcpStream::connect(&addr));\n+            let mut buf = [0, 0];\n+            assert_eq!(s.read(&mut buf).unwrap(), 1);\n+            assert_eq!(buf[0], 1);\n+            t!(s.write(&[2]));\n+        });\n+\n+        let mut s1 = t!(acceptor.accept()).0;\n+        let s2 = t!(s1.try_clone());\n+\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut s2 = s2;\n+            rx1.recv().unwrap();\n+            t!(s2.write(&[1]));\n+            tx2.send(()).unwrap();\n+        });\n+        tx1.send(()).unwrap();\n+        let mut buf = [0, 0];\n+        assert_eq!(s1.read(&mut buf).unwrap(), 1);\n+        rx2.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn tcp_clone_two_read() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+        let (tx1, rx) = channel();\n+        let tx2 = tx1.clone();\n+\n+        let _t = thread::spawn(move || {\n+            let mut s = t!(TcpStream::connect(&addr));\n+            t!(s.write(&[1]));\n+            rx.recv().unwrap();\n+            t!(s.write(&[2]));\n+            rx.recv().unwrap();\n+        });\n+\n+        let mut s1 = t!(acceptor.accept()).0;\n+        let s2 = t!(s1.try_clone());\n+\n+        let (done, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut s2 = s2;\n+            let mut buf = [0, 0];\n+            t!(s2.read(&mut buf));\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n+        });\n+        let mut buf = [0, 0];\n+        t!(s1.read(&mut buf));\n+        tx1.send(()).unwrap();\n+\n+        rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn tcp_clone_two_write() {\n+    each_ip(&mut |addr| {\n+        let acceptor = t!(TcpListener::bind(&addr));\n+\n+        let _t = thread::spawn(move || {\n+            let mut s = t!(TcpStream::connect(&addr));\n+            let mut buf = [0, 1];\n+            t!(s.read(&mut buf));\n+            t!(s.read(&mut buf));\n+        });\n+\n+        let mut s1 = t!(acceptor.accept()).0;\n+        let s2 = t!(s1.try_clone());\n+\n+        let (done, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut s2 = s2;\n+            t!(s2.write(&[1]));\n+            done.send(()).unwrap();\n+        });\n+        t!(s1.write(&[2]));\n+\n+        rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+// FIXME: https://github.com/fortanix/rust-sgx/issues/110\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn shutdown_smoke() {\n+    each_ip(&mut |addr| {\n+        let a = t!(TcpListener::bind(&addr));\n+        let _t = thread::spawn(move || {\n+            let mut c = t!(a.accept()).0;\n+            let mut b = [0];\n+            assert_eq!(c.read(&mut b).unwrap(), 0);\n+            t!(c.write(&[1]));\n+        });\n+\n+        let mut s = t!(TcpStream::connect(&addr));\n+        t!(s.shutdown(Shutdown::Write));\n+        assert!(s.write(&[1]).is_err());\n+        let mut b = [0, 0];\n+        assert_eq!(t!(s.read(&mut b)), 1);\n+        assert_eq!(b[0], 1);\n+    })\n+}\n+\n+#[test]\n+// FIXME: https://github.com/fortanix/rust-sgx/issues/110\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn close_readwrite_smoke() {\n+    each_ip(&mut |addr| {\n+        let a = t!(TcpListener::bind(&addr));\n+        let (tx, rx) = channel::<()>();\n+        let _t = thread::spawn(move || {\n+            let _s = t!(a.accept());\n+            let _ = rx.recv();\n+        });\n+\n+        let mut b = [0];\n+        let mut s = t!(TcpStream::connect(&addr));\n+        let mut s2 = t!(s.try_clone());\n+\n+        // closing should prevent reads/writes\n+        t!(s.shutdown(Shutdown::Write));\n+        assert!(s.write(&[0]).is_err());\n+        t!(s.shutdown(Shutdown::Read));\n+        assert_eq!(s.read(&mut b).unwrap(), 0);\n+\n+        // closing should affect previous handles\n+        assert!(s2.write(&[0]).is_err());\n+        assert_eq!(s2.read(&mut b).unwrap(), 0);\n+\n+        // closing should affect new handles\n+        let mut s3 = t!(s.try_clone());\n+        assert!(s3.write(&[0]).is_err());\n+        assert_eq!(s3.read(&mut b).unwrap(), 0);\n+\n+        // make sure these don't die\n+        let _ = s2.shutdown(Shutdown::Read);\n+        let _ = s2.shutdown(Shutdown::Write);\n+        let _ = s3.shutdown(Shutdown::Read);\n+        let _ = s3.shutdown(Shutdown::Write);\n+        drop(tx);\n+    })\n+}\n+\n+#[test]\n+#[cfg(unix)] // test doesn't work on Windows, see #31657\n+fn close_read_wakes_up() {\n+    each_ip(&mut |addr| {\n+        let a = t!(TcpListener::bind(&addr));\n+        let (tx1, rx) = channel::<()>();\n+        let _t = thread::spawn(move || {\n+            let _s = t!(a.accept());\n+            let _ = rx.recv();\n+        });\n+\n+        let s = t!(TcpStream::connect(&addr));\n+        let s2 = t!(s.try_clone());\n+        let (tx, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut s2 = s2;\n+            assert_eq!(t!(s2.read(&mut [0])), 0);\n+            tx.send(()).unwrap();\n+        });\n+        // this should wake up the child thread\n+        t!(s.shutdown(Shutdown::Read));\n+\n+        // this test will never finish if the child doesn't wake up\n+        rx.recv().unwrap();\n+        drop(tx1);\n+    })\n+}\n+\n+#[test]\n+fn clone_while_reading() {\n+    each_ip(&mut |addr| {\n+        let accept = t!(TcpListener::bind(&addr));\n+\n+        // Enqueue a thread to write to a socket\n+        let (tx, rx) = channel();\n+        let (txdone, rxdone) = channel();\n+        let txdone2 = txdone.clone();\n+        let _t = thread::spawn(move || {\n+            let mut tcp = t!(TcpStream::connect(&addr));\n+            rx.recv().unwrap();\n+            t!(tcp.write(&[0]));\n+            txdone2.send(()).unwrap();\n+        });\n+\n+        // Spawn off a reading clone\n+        let tcp = t!(accept.accept()).0;\n+        let tcp2 = t!(tcp.try_clone());\n+        let txdone3 = txdone.clone();\n+        let _t = thread::spawn(move || {\n+            let mut tcp2 = tcp2;\n+            t!(tcp2.read(&mut [0]));\n+            txdone3.send(()).unwrap();\n+        });\n+\n+        // Try to ensure that the reading clone is indeed reading\n+        for _ in 0..50 {\n+            thread::yield_now();\n+        }\n+\n+        // clone the handle again while it's reading, then let it finish the\n+        // read.\n+        let _ = t!(tcp.try_clone());\n+        tx.send(()).unwrap();\n+        rxdone.recv().unwrap();\n+        rxdone.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn clone_accept_smoke() {\n+    each_ip(&mut |addr| {\n+        let a = t!(TcpListener::bind(&addr));\n+        let a2 = t!(a.try_clone());\n+\n+        let _t = thread::spawn(move || {\n+            let _ = TcpStream::connect(&addr);\n+        });\n+        let _t = thread::spawn(move || {\n+            let _ = TcpStream::connect(&addr);\n+        });\n+\n+        t!(a.accept());\n+        t!(a2.accept());\n+    })\n+}\n+\n+#[test]\n+fn clone_accept_concurrent() {\n+    each_ip(&mut |addr| {\n+        let a = t!(TcpListener::bind(&addr));\n+        let a2 = t!(a.try_clone());\n+\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+\n+        let _t = thread::spawn(move || {\n+            tx.send(t!(a.accept())).unwrap();\n+        });\n+        let _t = thread::spawn(move || {\n+            tx2.send(t!(a2.accept())).unwrap();\n+        });\n+\n+        let _t = thread::spawn(move || {\n+            let _ = TcpStream::connect(&addr);\n+        });\n+        let _t = thread::spawn(move || {\n+            let _ = TcpStream::connect(&addr);\n+        });\n+\n+        rx.recv().unwrap();\n+        rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn debug() {\n+    #[cfg(not(target_env = \"sgx\"))]\n+    fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n+        addr\n+    }\n+    #[cfg(target_env = \"sgx\")]\n+    fn render_socket_addr<'a>(addr: &'a SocketAddr) -> impl fmt::Debug + 'a {\n+        addr.to_string()\n+    }\n+\n+    #[cfg(target_env = \"sgx\")]\n+    use crate::os::fortanix_sgx::io::AsRawFd;\n+    #[cfg(unix)]\n+    use crate::os::unix::io::AsRawFd;\n+    #[cfg(not(windows))]\n+    fn render_inner(addr: &dyn AsRawFd) -> impl fmt::Debug {\n+        addr.as_raw_fd()\n+    }\n+    #[cfg(windows)]\n+    fn render_inner(addr: &dyn crate::os::windows::io::AsRawSocket) -> impl fmt::Debug {\n+        addr.as_raw_socket()\n+    }\n+\n+    let inner_name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n+    let socket_addr = next_test_ip4();\n+\n+    let listener = t!(TcpListener::bind(&socket_addr));\n+    let compare = format!(\n+        \"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n+        render_socket_addr(&socket_addr),\n+        inner_name,\n+        render_inner(&listener)\n+    );\n+    assert_eq!(format!(\"{:?}\", listener), compare);\n+\n+    let stream = t!(TcpStream::connect(&(\"localhost\", socket_addr.port())));\n+    let compare = format!(\n+        \"TcpStream {{ addr: {:?}, peer: {:?}, {}: {:?} }}\",\n+        render_socket_addr(&stream.local_addr().unwrap()),\n+        render_socket_addr(&stream.peer_addr().unwrap()),\n+        inner_name,\n+        render_inner(&stream)\n+    );\n+    assert_eq!(format!(\"{:?}\", stream), compare);\n+}\n+\n+// FIXME: re-enabled openbsd tests once their socket timeout code\n+//        no longer has rounding errors.\n+// VxWorks ignores SO_SNDTIMEO.\n+#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n+#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+#[test]\n+fn timeouts() {\n+    let addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&addr));\n+\n+    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+    let dur = Duration::new(15410, 0);\n+\n+    assert_eq!(None, t!(stream.read_timeout()));\n+\n+    t!(stream.set_read_timeout(Some(dur)));\n+    assert_eq!(Some(dur), t!(stream.read_timeout()));\n+\n+    assert_eq!(None, t!(stream.write_timeout()));\n+\n+    t!(stream.set_write_timeout(Some(dur)));\n+    assert_eq!(Some(dur), t!(stream.write_timeout()));\n+\n+    t!(stream.set_read_timeout(None));\n+    assert_eq!(None, t!(stream.read_timeout()));\n+\n+    t!(stream.set_write_timeout(None));\n+    assert_eq!(None, t!(stream.write_timeout()));\n+    drop(listener);\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+fn test_read_timeout() {\n+    let addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&addr));\n+\n+    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    let mut buf = [0; 10];\n+    let start = Instant::now();\n+    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+    assert!(\n+        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+        \"unexpected_error: {:?}\",\n+        kind\n+    );\n+    assert!(start.elapsed() > Duration::from_millis(400));\n+    drop(listener);\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+fn test_read_with_timeout() {\n+    let addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&addr));\n+\n+    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    let mut other_end = t!(listener.accept()).0;\n+    t!(other_end.write_all(b\"hello world\"));\n+\n+    let mut buf = [0; 11];\n+    t!(stream.read(&mut buf));\n+    assert_eq!(b\"hello world\", &buf[..]);\n+\n+    let start = Instant::now();\n+    let kind = stream.read_exact(&mut buf).err().expect(\"expected error\").kind();\n+    assert!(\n+        kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+        \"unexpected_error: {:?}\",\n+        kind\n+    );\n+    assert!(start.elapsed() > Duration::from_millis(400));\n+    drop(listener);\n+}\n+\n+// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+// when passed zero Durations\n+#[test]\n+fn test_timeout_zero_duration() {\n+    let addr = next_test_ip4();\n+\n+    let listener = t!(TcpListener::bind(&addr));\n+    let stream = t!(TcpStream::connect(&addr));\n+\n+    let result = stream.set_write_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    let result = stream.set_read_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    drop(listener);\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn nodelay() {\n+    let addr = next_test_ip4();\n+    let _listener = t!(TcpListener::bind(&addr));\n+\n+    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+    assert_eq!(false, t!(stream.nodelay()));\n+    t!(stream.set_nodelay(true));\n+    assert_eq!(true, t!(stream.nodelay()));\n+    t!(stream.set_nodelay(false));\n+    assert_eq!(false, t!(stream.nodelay()));\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn ttl() {\n+    let ttl = 100;\n+\n+    let addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&addr));\n+\n+    t!(listener.set_ttl(ttl));\n+    assert_eq!(ttl, t!(listener.ttl()));\n+\n+    let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+    t!(stream.set_ttl(ttl));\n+    assert_eq!(ttl, t!(stream.ttl()));\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)]\n+fn set_nonblocking() {\n+    let addr = next_test_ip4();\n+    let listener = t!(TcpListener::bind(&addr));\n+\n+    t!(listener.set_nonblocking(true));\n+    t!(listener.set_nonblocking(false));\n+\n+    let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+    t!(stream.set_nonblocking(false));\n+    t!(stream.set_nonblocking(true));\n+\n+    let mut buf = [0];\n+    match stream.read(&mut buf) {\n+        Ok(_) => panic!(\"expected error\"),\n+        Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+    }\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+fn peek() {\n+    each_ip(&mut |addr| {\n+        let (txdone, rxdone) = channel();\n+\n+        let srv = t!(TcpListener::bind(&addr));\n+        let _t = thread::spawn(move || {\n+            let mut cl = t!(srv.accept()).0;\n+            cl.write(&[1, 3, 3, 7]).unwrap();\n+            t!(rxdone.recv());\n+        });\n+\n+        let mut c = t!(TcpStream::connect(&addr));\n+        let mut b = [0; 10];\n+        for _ in 1..3 {\n+            let len = c.peek(&mut b).unwrap();\n+            assert_eq!(len, 4);\n+        }\n+        let len = c.read(&mut b).unwrap();\n+        assert_eq!(len, 4);\n+\n+        t!(c.set_nonblocking(true));\n+        match c.peek(&mut b) {\n+            Ok(_) => panic!(\"expected error\"),\n+            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+        }\n+        t!(txdone.send(()));\n+    })\n+}\n+\n+#[test]\n+#[cfg_attr(target_env = \"sgx\", ignore)] // FIXME: https://github.com/fortanix/rust-sgx/issues/31\n+fn connect_timeout_valid() {\n+    let listener = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n+    let addr = listener.local_addr().unwrap();\n+    TcpStream::connect_timeout(&addr, Duration::from_secs(2)).unwrap();\n+}"}, {"sha": "17e3e4497c4a811f59d19de582845ffd4b95c85e", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 3, "deletions": 377, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n+mod tests;\n+\n use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::net::{Ipv4Addr, Ipv6Addr, SocketAddr, ToSocketAddrs};\n@@ -798,380 +801,3 @@ impl fmt::Debug for UdpSocket {\n         self.0.fmt(f)\n     }\n }\n-\n-#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\", target_env = \"sgx\"))))]\n-mod tests {\n-    use crate::io::ErrorKind;\n-    use crate::net::test::{next_test_ip4, next_test_ip6};\n-    use crate::net::*;\n-    use crate::sync::mpsc::channel;\n-    use crate::sys_common::AsInner;\n-    use crate::thread;\n-    use crate::time::{Duration, Instant};\n-\n-    fn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n-        f(next_test_ip4(), next_test_ip4());\n-        f(next_test_ip6(), next_test_ip6());\n-    }\n-\n-    macro_rules! t {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n-            }\n-        };\n-    }\n-\n-    #[test]\n-    fn bind_error() {\n-        match UdpSocket::bind(\"1.1.1.1:9999\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n-        }\n-    }\n-\n-    #[test]\n-    fn socket_smoke_test_ip4() {\n-        each_ip(&mut |server_ip, client_ip| {\n-            let (tx1, rx1) = channel();\n-            let (tx2, rx2) = channel();\n-\n-            let _t = thread::spawn(move || {\n-                let client = t!(UdpSocket::bind(&client_ip));\n-                rx1.recv().unwrap();\n-                t!(client.send_to(&[99], &server_ip));\n-                tx2.send(()).unwrap();\n-            });\n-\n-            let server = t!(UdpSocket::bind(&server_ip));\n-            tx1.send(()).unwrap();\n-            let mut buf = [0];\n-            let (nread, src) = t!(server.recv_from(&mut buf));\n-            assert_eq!(nread, 1);\n-            assert_eq!(buf[0], 99);\n-            assert_eq!(src, client_ip);\n-            rx2.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn socket_name() {\n-        each_ip(&mut |addr, _| {\n-            let server = t!(UdpSocket::bind(&addr));\n-            assert_eq!(addr, t!(server.local_addr()));\n-        })\n-    }\n-\n-    #[test]\n-    fn socket_peer() {\n-        each_ip(&mut |addr1, addr2| {\n-            let server = t!(UdpSocket::bind(&addr1));\n-            assert_eq!(server.peer_addr().unwrap_err().kind(), ErrorKind::NotConnected);\n-            t!(server.connect(&addr2));\n-            assert_eq!(addr2, t!(server.peer_addr()));\n-        })\n-    }\n-\n-    #[test]\n-    fn udp_clone_smoke() {\n-        each_ip(&mut |addr1, addr2| {\n-            let sock1 = t!(UdpSocket::bind(&addr1));\n-            let sock2 = t!(UdpSocket::bind(&addr2));\n-\n-            let _t = thread::spawn(move || {\n-                let mut buf = [0, 0];\n-                assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n-                assert_eq!(buf[0], 1);\n-                t!(sock2.send_to(&[2], &addr1));\n-            });\n-\n-            let sock3 = t!(sock1.try_clone());\n-\n-            let (tx1, rx1) = channel();\n-            let (tx2, rx2) = channel();\n-            let _t = thread::spawn(move || {\n-                rx1.recv().unwrap();\n-                t!(sock3.send_to(&[1], &addr2));\n-                tx2.send(()).unwrap();\n-            });\n-            tx1.send(()).unwrap();\n-            let mut buf = [0, 0];\n-            assert_eq!(sock1.recv_from(&mut buf).unwrap(), (1, addr2));\n-            rx2.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_read() {\n-        each_ip(&mut |addr1, addr2| {\n-            let sock1 = t!(UdpSocket::bind(&addr1));\n-            let sock2 = t!(UdpSocket::bind(&addr2));\n-            let (tx1, rx) = channel();\n-            let tx2 = tx1.clone();\n-\n-            let _t = thread::spawn(move || {\n-                t!(sock2.send_to(&[1], &addr1));\n-                rx.recv().unwrap();\n-                t!(sock2.send_to(&[2], &addr1));\n-                rx.recv().unwrap();\n-            });\n-\n-            let sock3 = t!(sock1.try_clone());\n-\n-            let (done, rx) = channel();\n-            let _t = thread::spawn(move || {\n-                let mut buf = [0, 0];\n-                t!(sock3.recv_from(&mut buf));\n-                tx2.send(()).unwrap();\n-                done.send(()).unwrap();\n-            });\n-            let mut buf = [0, 0];\n-            t!(sock1.recv_from(&mut buf));\n-            tx1.send(()).unwrap();\n-\n-            rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_write() {\n-        each_ip(&mut |addr1, addr2| {\n-            let sock1 = t!(UdpSocket::bind(&addr1));\n-            let sock2 = t!(UdpSocket::bind(&addr2));\n-\n-            let (tx, rx) = channel();\n-            let (serv_tx, serv_rx) = channel();\n-\n-            let _t = thread::spawn(move || {\n-                let mut buf = [0, 1];\n-                rx.recv().unwrap();\n-                t!(sock2.recv_from(&mut buf));\n-                serv_tx.send(()).unwrap();\n-            });\n-\n-            let sock3 = t!(sock1.try_clone());\n-\n-            let (done, rx) = channel();\n-            let tx2 = tx.clone();\n-            let _t = thread::spawn(move || {\n-                match sock3.send_to(&[1], &addr2) {\n-                    Ok(..) => {\n-                        let _ = tx2.send(());\n-                    }\n-                    Err(..) => {}\n-                }\n-                done.send(()).unwrap();\n-            });\n-            match sock1.send_to(&[2], &addr2) {\n-                Ok(..) => {\n-                    let _ = tx.send(());\n-                }\n-                Err(..) => {}\n-            }\n-            drop(tx);\n-\n-            rx.recv().unwrap();\n-            serv_rx.recv().unwrap();\n-        })\n-    }\n-\n-    #[test]\n-    fn debug() {\n-        let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n-        let socket_addr = next_test_ip4();\n-\n-        let udpsock = t!(UdpSocket::bind(&socket_addr));\n-        let udpsock_inner = udpsock.0.socket().as_inner();\n-        let compare =\n-            format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n-        assert_eq!(format!(\"{:?}\", udpsock), compare);\n-    }\n-\n-    // FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n-    //        no longer has rounding errors.\n-    // VxWorks ignores SO_SNDTIMEO.\n-    #[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n-    #[test]\n-    fn timeouts() {\n-        let addr = next_test_ip4();\n-\n-        let stream = t!(UdpSocket::bind(&addr));\n-        let dur = Duration::new(15410, 0);\n-\n-        assert_eq!(None, t!(stream.read_timeout()));\n-\n-        t!(stream.set_read_timeout(Some(dur)));\n-        assert_eq!(Some(dur), t!(stream.read_timeout()));\n-\n-        assert_eq!(None, t!(stream.write_timeout()));\n-\n-        t!(stream.set_write_timeout(Some(dur)));\n-        assert_eq!(Some(dur), t!(stream.write_timeout()));\n-\n-        t!(stream.set_read_timeout(None));\n-        assert_eq!(None, t!(stream.read_timeout()));\n-\n-        t!(stream.set_write_timeout(None));\n-        assert_eq!(None, t!(stream.write_timeout()));\n-    }\n-\n-    #[test]\n-    fn test_read_timeout() {\n-        let addr = next_test_ip4();\n-\n-        let stream = t!(UdpSocket::bind(&addr));\n-        t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        let mut buf = [0; 10];\n-\n-        let start = Instant::now();\n-        loop {\n-            let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n-            if kind != ErrorKind::Interrupted {\n-                assert!(\n-                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                    \"unexpected_error: {:?}\",\n-                    kind\n-                );\n-                break;\n-            }\n-        }\n-        assert!(start.elapsed() > Duration::from_millis(400));\n-    }\n-\n-    #[test]\n-    fn test_read_with_timeout() {\n-        let addr = next_test_ip4();\n-\n-        let stream = t!(UdpSocket::bind(&addr));\n-        t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n-\n-        t!(stream.send_to(b\"hello world\", &addr));\n-\n-        let mut buf = [0; 11];\n-        t!(stream.recv_from(&mut buf));\n-        assert_eq!(b\"hello world\", &buf[..]);\n-\n-        let start = Instant::now();\n-        loop {\n-            let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n-            if kind != ErrorKind::Interrupted {\n-                assert!(\n-                    kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n-                    \"unexpected_error: {:?}\",\n-                    kind\n-                );\n-                break;\n-            }\n-        }\n-        assert!(start.elapsed() > Duration::from_millis(400));\n-    }\n-\n-    // Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n-    // when passed zero Durations\n-    #[test]\n-    fn test_timeout_zero_duration() {\n-        let addr = next_test_ip4();\n-\n-        let socket = t!(UdpSocket::bind(&addr));\n-\n-        let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-\n-        let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-        let err = result.unwrap_err();\n-        assert_eq!(err.kind(), ErrorKind::InvalidInput);\n-    }\n-\n-    #[test]\n-    fn connect_send_recv() {\n-        let addr = next_test_ip4();\n-\n-        let socket = t!(UdpSocket::bind(&addr));\n-        t!(socket.connect(addr));\n-\n-        t!(socket.send(b\"hello world\"));\n-\n-        let mut buf = [0; 11];\n-        t!(socket.recv(&mut buf));\n-        assert_eq!(b\"hello world\", &buf[..]);\n-    }\n-\n-    #[test]\n-    fn connect_send_peek_recv() {\n-        each_ip(&mut |addr, _| {\n-            let socket = t!(UdpSocket::bind(&addr));\n-            t!(socket.connect(addr));\n-\n-            t!(socket.send(b\"hello world\"));\n-\n-            for _ in 1..3 {\n-                let mut buf = [0; 11];\n-                let size = t!(socket.peek(&mut buf));\n-                assert_eq!(b\"hello world\", &buf[..]);\n-                assert_eq!(size, 11);\n-            }\n-\n-            let mut buf = [0; 11];\n-            let size = t!(socket.recv(&mut buf));\n-            assert_eq!(b\"hello world\", &buf[..]);\n-            assert_eq!(size, 11);\n-        })\n-    }\n-\n-    #[test]\n-    fn peek_from() {\n-        each_ip(&mut |addr, _| {\n-            let socket = t!(UdpSocket::bind(&addr));\n-            t!(socket.send_to(b\"hello world\", &addr));\n-\n-            for _ in 1..3 {\n-                let mut buf = [0; 11];\n-                let (size, _) = t!(socket.peek_from(&mut buf));\n-                assert_eq!(b\"hello world\", &buf[..]);\n-                assert_eq!(size, 11);\n-            }\n-\n-            let mut buf = [0; 11];\n-            let (size, _) = t!(socket.recv_from(&mut buf));\n-            assert_eq!(b\"hello world\", &buf[..]);\n-            assert_eq!(size, 11);\n-        })\n-    }\n-\n-    #[test]\n-    fn ttl() {\n-        let ttl = 100;\n-\n-        let addr = next_test_ip4();\n-\n-        let stream = t!(UdpSocket::bind(&addr));\n-\n-        t!(stream.set_ttl(ttl));\n-        assert_eq!(ttl, t!(stream.ttl()));\n-    }\n-\n-    #[test]\n-    fn set_nonblocking() {\n-        each_ip(&mut |addr, _| {\n-            let socket = t!(UdpSocket::bind(&addr));\n-\n-            t!(socket.set_nonblocking(true));\n-            t!(socket.set_nonblocking(false));\n-\n-            t!(socket.connect(addr));\n-\n-            t!(socket.set_nonblocking(false));\n-            t!(socket.set_nonblocking(true));\n-\n-            let mut buf = [0];\n-            match socket.recv(&mut buf) {\n-                Ok(_) => panic!(\"expected error\"),\n-                Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n-                Err(e) => panic!(\"unexpected error {}\", e),\n-            }\n-        })\n-    }\n-}"}, {"sha": "658369f79aa7569bc50503c2b247380ece2500d2", "filename": "library/std/src/net/udp/tests.rs", "status": "added", "additions": 372, "deletions": 0, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb", "patch": "@@ -0,0 +1,372 @@\n+use crate::io::ErrorKind;\n+use crate::net::test::{next_test_ip4, next_test_ip6};\n+use crate::net::*;\n+use crate::sync::mpsc::channel;\n+use crate::sys_common::AsInner;\n+use crate::thread;\n+use crate::time::{Duration, Instant};\n+\n+fn each_ip(f: &mut dyn FnMut(SocketAddr, SocketAddr)) {\n+    f(next_test_ip4(), next_test_ip4());\n+    f(next_test_ip6(), next_test_ip6());\n+}\n+\n+macro_rules! t {\n+    ($e:expr) => {\n+        match $e {\n+            Ok(t) => t,\n+            Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n+        }\n+    };\n+}\n+\n+#[test]\n+fn bind_error() {\n+    match UdpSocket::bind(\"1.1.1.1:9999\") {\n+        Ok(..) => panic!(),\n+        Err(e) => assert_eq!(e.kind(), ErrorKind::AddrNotAvailable),\n+    }\n+}\n+\n+#[test]\n+fn socket_smoke_test_ip4() {\n+    each_ip(&mut |server_ip, client_ip| {\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+\n+        let _t = thread::spawn(move || {\n+            let client = t!(UdpSocket::bind(&client_ip));\n+            rx1.recv().unwrap();\n+            t!(client.send_to(&[99], &server_ip));\n+            tx2.send(()).unwrap();\n+        });\n+\n+        let server = t!(UdpSocket::bind(&server_ip));\n+        tx1.send(()).unwrap();\n+        let mut buf = [0];\n+        let (nread, src) = t!(server.recv_from(&mut buf));\n+        assert_eq!(nread, 1);\n+        assert_eq!(buf[0], 99);\n+        assert_eq!(src, client_ip);\n+        rx2.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn socket_name() {\n+    each_ip(&mut |addr, _| {\n+        let server = t!(UdpSocket::bind(&addr));\n+        assert_eq!(addr, t!(server.local_addr()));\n+    })\n+}\n+\n+#[test]\n+fn socket_peer() {\n+    each_ip(&mut |addr1, addr2| {\n+        let server = t!(UdpSocket::bind(&addr1));\n+        assert_eq!(server.peer_addr().unwrap_err().kind(), ErrorKind::NotConnected);\n+        t!(server.connect(&addr2));\n+        assert_eq!(addr2, t!(server.peer_addr()));\n+    })\n+}\n+\n+#[test]\n+fn udp_clone_smoke() {\n+    each_ip(&mut |addr1, addr2| {\n+        let sock1 = t!(UdpSocket::bind(&addr1));\n+        let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+        let _t = thread::spawn(move || {\n+            let mut buf = [0, 0];\n+            assert_eq!(sock2.recv_from(&mut buf).unwrap(), (1, addr1));\n+            assert_eq!(buf[0], 1);\n+            t!(sock2.send_to(&[2], &addr1));\n+        });\n+\n+        let sock3 = t!(sock1.try_clone());\n+\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        let _t = thread::spawn(move || {\n+            rx1.recv().unwrap();\n+            t!(sock3.send_to(&[1], &addr2));\n+            tx2.send(()).unwrap();\n+        });\n+        tx1.send(()).unwrap();\n+        let mut buf = [0, 0];\n+        assert_eq!(sock1.recv_from(&mut buf).unwrap(), (1, addr2));\n+        rx2.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn udp_clone_two_read() {\n+    each_ip(&mut |addr1, addr2| {\n+        let sock1 = t!(UdpSocket::bind(&addr1));\n+        let sock2 = t!(UdpSocket::bind(&addr2));\n+        let (tx1, rx) = channel();\n+        let tx2 = tx1.clone();\n+\n+        let _t = thread::spawn(move || {\n+            t!(sock2.send_to(&[1], &addr1));\n+            rx.recv().unwrap();\n+            t!(sock2.send_to(&[2], &addr1));\n+            rx.recv().unwrap();\n+        });\n+\n+        let sock3 = t!(sock1.try_clone());\n+\n+        let (done, rx) = channel();\n+        let _t = thread::spawn(move || {\n+            let mut buf = [0, 0];\n+            t!(sock3.recv_from(&mut buf));\n+            tx2.send(()).unwrap();\n+            done.send(()).unwrap();\n+        });\n+        let mut buf = [0, 0];\n+        t!(sock1.recv_from(&mut buf));\n+        tx1.send(()).unwrap();\n+\n+        rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn udp_clone_two_write() {\n+    each_ip(&mut |addr1, addr2| {\n+        let sock1 = t!(UdpSocket::bind(&addr1));\n+        let sock2 = t!(UdpSocket::bind(&addr2));\n+\n+        let (tx, rx) = channel();\n+        let (serv_tx, serv_rx) = channel();\n+\n+        let _t = thread::spawn(move || {\n+            let mut buf = [0, 1];\n+            rx.recv().unwrap();\n+            t!(sock2.recv_from(&mut buf));\n+            serv_tx.send(()).unwrap();\n+        });\n+\n+        let sock3 = t!(sock1.try_clone());\n+\n+        let (done, rx) = channel();\n+        let tx2 = tx.clone();\n+        let _t = thread::spawn(move || {\n+            match sock3.send_to(&[1], &addr2) {\n+                Ok(..) => {\n+                    let _ = tx2.send(());\n+                }\n+                Err(..) => {}\n+            }\n+            done.send(()).unwrap();\n+        });\n+        match sock1.send_to(&[2], &addr2) {\n+            Ok(..) => {\n+                let _ = tx.send(());\n+            }\n+            Err(..) => {}\n+        }\n+        drop(tx);\n+\n+        rx.recv().unwrap();\n+        serv_rx.recv().unwrap();\n+    })\n+}\n+\n+#[test]\n+fn debug() {\n+    let name = if cfg!(windows) { \"socket\" } else { \"fd\" };\n+    let socket_addr = next_test_ip4();\n+\n+    let udpsock = t!(UdpSocket::bind(&socket_addr));\n+    let udpsock_inner = udpsock.0.socket().as_inner();\n+    let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\", socket_addr, name, udpsock_inner);\n+    assert_eq!(format!(\"{:?}\", udpsock), compare);\n+}\n+\n+// FIXME: re-enabled openbsd/netbsd tests once their socket timeout code\n+//        no longer has rounding errors.\n+// VxWorks ignores SO_SNDTIMEO.\n+#[cfg_attr(any(target_os = \"netbsd\", target_os = \"openbsd\", target_os = \"vxworks\"), ignore)]\n+#[test]\n+fn timeouts() {\n+    let addr = next_test_ip4();\n+\n+    let stream = t!(UdpSocket::bind(&addr));\n+    let dur = Duration::new(15410, 0);\n+\n+    assert_eq!(None, t!(stream.read_timeout()));\n+\n+    t!(stream.set_read_timeout(Some(dur)));\n+    assert_eq!(Some(dur), t!(stream.read_timeout()));\n+\n+    assert_eq!(None, t!(stream.write_timeout()));\n+\n+    t!(stream.set_write_timeout(Some(dur)));\n+    assert_eq!(Some(dur), t!(stream.write_timeout()));\n+\n+    t!(stream.set_read_timeout(None));\n+    assert_eq!(None, t!(stream.read_timeout()));\n+\n+    t!(stream.set_write_timeout(None));\n+    assert_eq!(None, t!(stream.write_timeout()));\n+}\n+\n+#[test]\n+fn test_read_timeout() {\n+    let addr = next_test_ip4();\n+\n+    let stream = t!(UdpSocket::bind(&addr));\n+    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    let mut buf = [0; 10];\n+\n+    let start = Instant::now();\n+    loop {\n+        let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n+        if kind != ErrorKind::Interrupted {\n+            assert!(\n+                kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                \"unexpected_error: {:?}\",\n+                kind\n+            );\n+            break;\n+        }\n+    }\n+    assert!(start.elapsed() > Duration::from_millis(400));\n+}\n+\n+#[test]\n+fn test_read_with_timeout() {\n+    let addr = next_test_ip4();\n+\n+    let stream = t!(UdpSocket::bind(&addr));\n+    t!(stream.set_read_timeout(Some(Duration::from_millis(1000))));\n+\n+    t!(stream.send_to(b\"hello world\", &addr));\n+\n+    let mut buf = [0; 11];\n+    t!(stream.recv_from(&mut buf));\n+    assert_eq!(b\"hello world\", &buf[..]);\n+\n+    let start = Instant::now();\n+    loop {\n+        let kind = stream.recv_from(&mut buf).err().expect(\"expected error\").kind();\n+        if kind != ErrorKind::Interrupted {\n+            assert!(\n+                kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut,\n+                \"unexpected_error: {:?}\",\n+                kind\n+            );\n+            break;\n+        }\n+    }\n+    assert!(start.elapsed() > Duration::from_millis(400));\n+}\n+\n+// Ensure the `set_read_timeout` and `set_write_timeout` calls return errors\n+// when passed zero Durations\n+#[test]\n+fn test_timeout_zero_duration() {\n+    let addr = next_test_ip4();\n+\n+    let socket = t!(UdpSocket::bind(&addr));\n+\n+    let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+\n+    let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    let err = result.unwrap_err();\n+    assert_eq!(err.kind(), ErrorKind::InvalidInput);\n+}\n+\n+#[test]\n+fn connect_send_recv() {\n+    let addr = next_test_ip4();\n+\n+    let socket = t!(UdpSocket::bind(&addr));\n+    t!(socket.connect(addr));\n+\n+    t!(socket.send(b\"hello world\"));\n+\n+    let mut buf = [0; 11];\n+    t!(socket.recv(&mut buf));\n+    assert_eq!(b\"hello world\", &buf[..]);\n+}\n+\n+#[test]\n+fn connect_send_peek_recv() {\n+    each_ip(&mut |addr, _| {\n+        let socket = t!(UdpSocket::bind(&addr));\n+        t!(socket.connect(addr));\n+\n+        t!(socket.send(b\"hello world\"));\n+\n+        for _ in 1..3 {\n+            let mut buf = [0; 11];\n+            let size = t!(socket.peek(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        }\n+\n+        let mut buf = [0; 11];\n+        let size = t!(socket.recv(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+        assert_eq!(size, 11);\n+    })\n+}\n+\n+#[test]\n+fn peek_from() {\n+    each_ip(&mut |addr, _| {\n+        let socket = t!(UdpSocket::bind(&addr));\n+        t!(socket.send_to(b\"hello world\", &addr));\n+\n+        for _ in 1..3 {\n+            let mut buf = [0; 11];\n+            let (size, _) = t!(socket.peek_from(&mut buf));\n+            assert_eq!(b\"hello world\", &buf[..]);\n+            assert_eq!(size, 11);\n+        }\n+\n+        let mut buf = [0; 11];\n+        let (size, _) = t!(socket.recv_from(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+        assert_eq!(size, 11);\n+    })\n+}\n+\n+#[test]\n+fn ttl() {\n+    let ttl = 100;\n+\n+    let addr = next_test_ip4();\n+\n+    let stream = t!(UdpSocket::bind(&addr));\n+\n+    t!(stream.set_ttl(ttl));\n+    assert_eq!(ttl, t!(stream.ttl()));\n+}\n+\n+#[test]\n+fn set_nonblocking() {\n+    each_ip(&mut |addr, _| {\n+        let socket = t!(UdpSocket::bind(&addr));\n+\n+        t!(socket.set_nonblocking(true));\n+        t!(socket.set_nonblocking(false));\n+\n+        t!(socket.connect(addr));\n+\n+        t!(socket.set_nonblocking(false));\n+        t!(socket.set_nonblocking(true));\n+\n+        let mut buf = [0];\n+        match socket.recv(&mut buf) {\n+            Ok(_) => panic!(\"expected error\"),\n+            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+        }\n+    })\n+}"}, {"sha": "0f1c59626859411ee501d47abe7715d19c63ff02", "filename": "library/std/src/num.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnum.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "233ea0506c00a362aba2ce2ed1fbbb039ff5889a", "filename": "library/std/src/num/benches.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum%2Fbenches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum%2Fbenches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnum%2Fbenches.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "2f50b73f4907f9186ae2240cc35d99941a9ef6e9", "filename": "library/std/src/num/tests.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fnum%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnum%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "1fe27a34600003730ef69419aec1c74b70a7eec9", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e808faf81d657bb307dc9e7ff13caf2209aee5ae", "filename": "library/std/src/os/raw/tests.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "d71e89d0eee682f7d7ab15d61eef35840d80fa34", "filename": "library/std/src/path.rs", "status": "modified", "additions": 3, "deletions": 1400, "changes": 1403, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "ff94fda5a227b813e64e7cf621c22407f734dd87", "filename": "library/std/src/path/tests.rs", "status": "added", "additions": 1394, "deletions": 0, "changes": 1394, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "d1960a049d9062cb01e32b642b2a88e66cfda7fb", "filename": "library/std/src/process.rs", "status": "modified", "additions": 3, "deletions": 408, "changes": 411, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "05e093434be1bf57f306e34bdbd96b5a76bad9df", "filename": "library/std/src/process/tests.rs", "status": "added", "additions": 401, "deletions": 0, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "5d434791e9afb342c40ba9e90e97d38c639482cc", "filename": "library/std/src/sync/barrier.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fbarrier.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "834a3e75158a74a9fd72c9cbe54e143f9b44dfc7", "filename": "library/std/src/sync/barrier/tests.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fbarrier%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fbarrier%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fbarrier%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "651f813b3e2271e71e91399cd34f2aae17a3915e", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 215, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "86d099ee3a19c8bc71b1e46785184417037d12d9", "filename": "library/std/src/sync/condvar/tests.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "073f969bbe25b5cb8df7d29721e9ab33c157fd4d", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 6, "deletions": 1361, "changes": 1367, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "42bc639dc252784fc8f864bafa91696c2cb82af8", "filename": "library/std/src/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "348b83424b0137d6af1445f02602422bb4cbd2a9", "filename": "library/std/src/sync/mpsc/mpsc_queue/tests.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "9bf99f193ca3ae0707212defb1d0a241de1c04bd", "filename": "library/std/src/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 105, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e4fd15cbbdef325bcd25a28e22e2cf99f91c59cd", "filename": "library/std/src/sync/mpsc/spsc_queue/tests.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "0052a38f7bb751d80e2eb9c509059265e48bcd70", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "184ce193cbed9c0c92e27a560d684e87183cc468", "filename": "library/std/src/sync/mpsc/tests.rs", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "0de717938348d3bdc2599675d95cfb311158db9c", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 3, "deletions": 242, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "a1b5aeddcb66a7740fb2c0e9e20dd9f47a45940c", "filename": "library/std/src/sync/mutex/tests.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fmutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "8fed369bffc27dd6ee5003c8e0c408e3c1a20225", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 3, "deletions": 120, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "fae2752526e587752b88cc0f537239fc7a269625", "filename": "library/std/src/sync/once/tests.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fonce%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Fonce%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "2d219c2c7dd2aebdaec788a226c231c654e0d707", "filename": "library/std/src/sync/rwlock.rs", "status": "modified", "additions": 3, "deletions": 251, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e9b74fb3ecc866dd0f50c94fdf38b242a517d4e5", "filename": "library/std/src/sync/rwlock/tests.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "0d8952b2f273b2ddea95453fc09e56a3bc35194a", "filename": "library/std/src/sys/sgx/abi/tls.rs", "status": "modified", "additions": 2, "deletions": 114, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "4eeff8f6ef7736f93bb14d8963327f8d30704e43", "filename": "library/std/src/sys/sgx/abi/tls/sync_bitset.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "d7eb2e139d01125693437f0f05fa3dd12ece921b", "filename": "library/std/src/sys/sgx/abi/tls/sync_bitset/tests.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Ftls%2Fsync_bitset%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "3bf2a7d8fb46c3df0f81230768f1289f01b8762d", "filename": "library/std/src/sys/sgx/rwlock.rs", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "05b36c633f8618e4a50e7a764ad1f11ab0b507a0", "filename": "library/std/src/sys/sgx/rwlock/tests.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Frwlock%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e464dc3ee9d40139a348c7847112e956de07cb54", "filename": "library/std/src/sys/sgx/waitqueue.rs", "status": "modified", "additions": 12, "deletions": 386, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "d99ce895da59421b701533dccfedba2387cd319f", "filename": "library/std/src/sys/sgx/waitqueue/spin_mutex.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "4c5994bea61f723ec6c52078afd13cde2990a7fd", "filename": "library/std/src/sys/sgx/waitqueue/spin_mutex/tests.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Fspin_mutex%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "bf91fdd08ed54529c171b0ba5b3a8bf52ed8b198", "filename": "library/std/src/sys/sgx/waitqueue/tests.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "7a2465427396d9b7c919d640ac87fa66becf8f07", "filename": "library/std/src/sys/sgx/waitqueue/unsafe_list.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "1f031ed1959cff8bf3854ce600199f2161113dd0", "filename": "library/std/src/sys/sgx/waitqueue/unsafe_list/tests.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fwaitqueue%2Funsafe_list%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "0e07106f5ce5cdbdd7d80e3c82acecdea8706d71", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "modified", "additions": 3, "deletions": 379, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "be98766f0f3aa3094fb28e1e94d05c8ad1239b16", "filename": "library/std/src/sys/unix/ext/net/tests.rs", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "b2f15eda9d7b093ccc69c5028ecb51ccd2d893c1", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "a932043cbc62b6d54d6aa75376e87cd42f9cb2c2", "filename": "library/std/src/sys/unix/fd/tests.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "4aa61fc5bf68768c33e289d8999182eef6d1ca52", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "0e1dcb390a07af619bdc8fe70a1245fb81cbe714", "filename": "library/std/src/sys/unix/os/tests.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "f8666485eeccb71fab09c44bae17fd1de9d79370", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 3, "deletions": 68, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e72fbf0beb4a55b59a530df11c1b1c22dd1877e4", "filename": "library/std/src/sys/unix/process/process_common/tests.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "7613fbec46f397c454bab142949fdc58159486c8", "filename": "library/std/src/sys/vxworks/net.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e7c6e348f8e5a44f8cdab12430ad3814ed164313", "filename": "library/std/src/sys/vxworks/net/tests.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "bcc2ea9ae00f02f5cffb7515f07133a4a902d192", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 3, "deletions": 66, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "756a4361ea3de31eb0327389591b5e49d9708a93", "filename": "library/std/src/sys/windows/args/tests.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "77c378a66afd78724215dace7d45702a845fbf65", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "458d6e11c20982d23ea7baaeb798b8725e6dc629", "filename": "library/std/src/sys/windows/os/tests.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "e18521bb30d91fd29cc7809082457a069805fd4c", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "81627ad139bb9035541c5a226c8ea7e49ed77b3a", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "97fba60c27109e3773cccf77c7ef9708be5cc084", "filename": "library/std/src/sys_common/bytestring.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "1685f087d183e49f81d35ced27e8f480c9cada81", "filename": "library/std/src/sys_common/bytestring/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbytestring%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "28cdfefb12a08b76742746c3582e89efe56edd2d", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "48ba4ddfc0b2c8e64ec731af7ec0aafe5ab38792", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "7d45621e09ae470ec12b7f3785a6e34fa7f06d64", "filename": "library/std/src/sys_common/net/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "360337c030be487728a6386aaa04773cd57feb1b", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 3, "deletions": 76, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "9c686e579d7359814163ba5a7b49329f03d981b3", "filename": "library/std/src/sys_common/remutex/tests.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "1b6446db52d4ba695b57b0defeb0c0a4a7f631d4", "filename": "library/std/src/sys_common/tests.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "3a2218854a7300c71e802a1db195170f2da81524", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "968738a418080d3e28eae59de99fec9a3dba327a", "filename": "library/std/src/sys_common/thread_local_key/tests.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "7d4b0d5283199012a23425cd3afd50d7591e0ba7", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 3, "deletions": 404, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "385e01f92fa14388af2a3f874dd015b28d20c49b", "filename": "library/std/src/sys_common/wtf8/tests.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "9d8c6f1815eeb38963decadd4bbb98d13a23a821", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 6, "deletions": 200, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "dd18004164824fd33bc76b573f8b53477ce09500", "filename": "library/std/src/thread/local/dynamic_tests.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Fdynamic_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Fdynamic_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Fdynamic_tests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "4fb0a0890826ebed02b802a0552d0741fcd15f28", "filename": "library/std/src/thread/local/tests.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "6d6be8560aa3647589d032fb8825cf1eaee2824d", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 270, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "16ad366fc126a3ece82d309c2b36873273ac3228", "filename": "library/std/src/thread/tests.rs", "status": "added", "additions": 262, "deletions": 0, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "73c0a7b403a7bed8382bbd9d693efa1bb259b297", "filename": "library/std/src/time.rs", "status": "modified", "additions": 3, "deletions": 169, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}, {"sha": "783bf49f315445dd4f38d02ab1c5ec84ad84019b", "filename": "library/std/src/time/tests.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e926daeeaedc9178846711daf1f4cb6ce505fb/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=a4e926daeeaedc9178846711daf1f4cb6ce505fb"}]}