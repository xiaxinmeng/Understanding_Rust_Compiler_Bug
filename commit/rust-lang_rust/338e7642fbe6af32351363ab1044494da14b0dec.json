{"sha": "338e7642fbe6af32351363ab1044494da14b0dec", "node_id": "C_kwDOAAsO6NoAKDMzOGU3NjQyZmJlNmFmMzIzNTEzNjNhYjEwNDQ0OTRkYTE0YjBkZWM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-04T19:39:20Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-15T16:40:42Z"}, "message": "Combine TypeGeneralizer and Generalizer", "tree": {"sha": "8589123c7934a08937eb5735a52b627d672d9a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8589123c7934a08937eb5735a52b627d672d9a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/338e7642fbe6af32351363ab1044494da14b0dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/338e7642fbe6af32351363ab1044494da14b0dec", "html_url": "https://github.com/rust-lang/rust/commit/338e7642fbe6af32351363ab1044494da14b0dec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/338e7642fbe6af32351363ab1044494da14b0dec/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2913ad6db0f72fed5139253faed73200c7af3535", "url": "https://api.github.com/repos/rust-lang/rust/commits/2913ad6db0f72fed5139253faed73200c7af3535", "html_url": "https://github.com/rust-lang/rust/commit/2913ad6db0f72fed5139253faed73200c7af3535"}], "stats": {"total": 1055, "additions": 467, "deletions": 588}, "files": [{"sha": "a5d7641504d3b42c6b7e6a5e43c9faa5ad6b394d", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 333, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=338e7642fbe6af32351363ab1044494da14b0dec", "patch": "@@ -28,16 +28,13 @@ use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::{DefineOpaqueTypes, InferCtxt, MiscVariable, TypeTrace};\n+use crate::infer::generalize::{Generalization, Generalizer};\n use crate::traits::{Obligation, PredicateObligations};\n-use rustc_data_structures::sso::SsoHashMap;\n-use rustc_hir::def_id::DefId;\n use rustc_middle::infer::canonical::OriginalQueryValues;\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n use rustc_middle::ty::{\n     self, AliasKind, FallibleTypeFolder, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable,\n     TypeSuperFoldable, TypeVisitableExt,\n@@ -412,7 +409,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let Generalization { ty: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n+        let Generalization { value: b_ty, needs_wf } = self.generalize(a_ty, b_vid, dir)?;\n         debug!(?b_ty);\n         self.infcx.inner.borrow_mut().type_variables().instantiate(b_vid, b_ty);\n \n@@ -456,11 +453,11 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// - `for_vid` is a \"root vid\"\n     #[instrument(skip(self), level = \"trace\", ret)]\n     fn generalize(\n-        &self,\n+        &mut self,\n         ty: Ty<'tcx>,\n         for_vid: ty::TyVid,\n         dir: RelationDir,\n-    ) -> RelateResult<'tcx, Generalization<'tcx>> {\n+    ) -> RelateResult<'tcx, Generalization<Ty<'tcx>>> {\n         // Determine the ambient variance within which `ty` appears.\n         // The surrounding equation is:\n         //\n@@ -476,31 +473,23 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         trace!(?ambient_variance);\n \n-        let for_universe = match self.infcx.inner.borrow_mut().type_variables().probe(for_vid) {\n-            v @ TypeVariableValue::Known { .. } => {\n-                bug!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n-            }\n-            TypeVariableValue::Unknown { universe } => universe,\n-        };\n+        let for_universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+        let for_vid_sub_root = self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid);\n \n         trace!(?for_universe);\n         trace!(?self.trace);\n \n-        let mut generalize = Generalizer {\n+        Generalizer {\n             infcx: self.infcx,\n-            cause: &self.trace.cause,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n-            for_universe,\n+            delegate: self,\n             ambient_variance,\n-            needs_wf: false,\n+            for_universe,\n+            for_vid_sub_root,\n             root_ty: ty,\n-            param_env: self.param_env,\n-            cache: SsoHashMap::new(),\n-        };\n-\n-        let ty = generalize.relate(ty, ty)?;\n-        let needs_wf = generalize.needs_wf;\n-        Ok(Generalization { ty, needs_wf })\n+            cache: Default::default(),\n+            needs_wf: false,\n+        }\n+        .generalize(ty)\n     }\n \n     pub fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n@@ -514,313 +503,6 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n-\n-    /// The span, used when creating new type variables and things.\n-    cause: &'cx ObligationCause<'tcx>,\n-\n-    /// The vid of the type variable that is in the process of being\n-    /// instantiated; if we find this within the type we are folding,\n-    /// that means we would have created a cyclic type.\n-    for_vid_sub_root: ty::TyVid,\n-\n-    /// The universe of the type variable that is in the process of\n-    /// being instantiated. Any fresh variables that we create in this\n-    /// process should be in that same universe.\n-    for_universe: ty::UniverseIndex,\n-\n-    /// Track the variance as we descend into the type.\n-    ambient_variance: ty::Variance,\n-\n-    /// See the field `needs_wf` in `Generalization`.\n-    needs_wf: bool,\n-\n-    /// The root type that we are generalizing. Used when reporting cycles.\n-    root_ty: Ty<'tcx>,\n-\n-    param_env: ty::ParamEnv<'tcx>,\n-\n-    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n-}\n-\n-/// Result from a generalization operation. This includes\n-/// not only the generalized type, but also a bool flag\n-/// indicating whether further WF checks are needed.\n-#[derive(Debug)]\n-struct Generalization<'tcx> {\n-    ty: Ty<'tcx>,\n-\n-    /// If true, then the generalized type may not be well-formed,\n-    /// even if the source type is well-formed, so we should add an\n-    /// additional check to enforce that it is. This arises in\n-    /// particular around 'bivariant' type parameters that are only\n-    /// constrained by a where-clause. As an example, imagine a type:\n-    ///\n-    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n-    ///         data: A\n-    ///     }\n-    ///\n-    /// here, `A` will be covariant, but `B` is\n-    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n-    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n-    /// then after generalization we will wind up with a type like\n-    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n-    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n-    /// <: ?C`, but no particular relationship between `?B` and `?D`\n-    /// (after all, we do not know the variance of the normalized form\n-    /// of `A::Item` with respect to `A`). If we do nothing else, this\n-    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n-    /// this scenario where we create a new type variable in a\n-    /// bivariant context, we set the `needs_wf` flag to true. This\n-    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n-    /// holds, which in turn implies that `?C::Item == ?D`. So once\n-    /// `?C` is constrained, that should suffice to restrict `?D`.\n-    needs_wf: bool,\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"Generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n-    }\n-\n-    fn relate_item_substs(\n-        &mut self,\n-        item_def_id: DefId,\n-        a_subst: SubstsRef<'tcx>,\n-        b_subst: SubstsRef<'tcx>,\n-    ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n-        if self.ambient_variance == ty::Variance::Invariant {\n-            // Avoid fetching the variance if we are in an invariant\n-            // context; no need, and it can induce dependency cycles\n-            // (e.g., #41849).\n-            relate::relate_substs(self, a_subst, b_subst)\n-        } else {\n-            let tcx = self.tcx();\n-            let opt_variances = tcx.variances_of(item_def_id);\n-            relate::relate_substs_with_variances(\n-                self,\n-                item_def_id,\n-                &opt_variances,\n-                a_subst,\n-                b_subst,\n-                true,\n-            )\n-        }\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        let result = self.relate(a, b);\n-        self.ambient_variance = old_ambient_variance;\n-        result\n-    }\n-\n-    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        if let Some(&result) = self.cache.get(&t) {\n-            return Ok(result);\n-        }\n-        debug!(\"generalize: t={:?}\", t);\n-\n-        // Check to see whether the type we are generalizing references\n-        // any other type variable related to `vid` via\n-        // subtyping. This is basically our \"occurs check\", preventing\n-        // us from creating infinitely sized types.\n-        let result = match *t.kind() {\n-            ty::Infer(ty::TyVar(vid)) => {\n-                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n-                let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n-                if sub_vid == self.for_vid_sub_root {\n-                    // If sub-roots are equal, then `for_vid` and\n-                    // `vid` are related via subtyping.\n-                    Err(TypeError::CyclicTy(self.root_ty))\n-                } else {\n-                    let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n-                    match probe {\n-                        TypeVariableValue::Known { value: u } => {\n-                            debug!(\"generalize: known value {:?}\", u);\n-                            self.relate(u, u)\n-                        }\n-                        TypeVariableValue::Unknown { universe } => {\n-                            match self.ambient_variance {\n-                                // Invariant: no need to make a fresh type variable.\n-                                ty::Invariant => {\n-                                    if self.for_universe.can_name(universe) {\n-                                        return Ok(t);\n-                                    }\n-                                }\n-\n-                                // Bivariant: make a fresh var, but we\n-                                // may need a WF predicate. See\n-                                // comment on `needs_wf` field for\n-                                // more info.\n-                                ty::Bivariant => self.needs_wf = true,\n-\n-                                // Co/contravariant: this will be\n-                                // sufficiently constrained later on.\n-                                ty::Covariant | ty::Contravariant => (),\n-                            }\n-\n-                            let origin =\n-                                *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n-                            let new_var_id = self\n-                                .infcx\n-                                .inner\n-                                .borrow_mut()\n-                                .type_variables()\n-                                .new_var(self.for_universe, origin);\n-                            let u = self.tcx().mk_ty_var(new_var_id);\n-\n-                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n-                            // operation. This is needed to detect cyclic types. To see why, see the\n-                            // docs in the `type_variables` module.\n-                            self.infcx.inner.borrow_mut().type_variables().sub(vid, new_var_id);\n-                            debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n-                            Ok(u)\n-                        }\n-                    }\n-                }\n-            }\n-            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n-                // No matter what mode we are in,\n-                // integer/floating-point types must be equal to be\n-                // relatable.\n-                Ok(t)\n-            }\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                let s = self.relate(substs, substs)?;\n-                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n-            }\n-            _ => relate::super_relate_tys(self, t, t),\n-        }?;\n-\n-        self.cache.insert(t, result);\n-        Ok(result)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        r: ty::Region<'tcx>,\n-        r2: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        assert_eq!(r, r2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        debug!(\"generalize: regions r={:?}\", r);\n-\n-        match *r {\n-            // Never make variables for regions bound within the type itself,\n-            // nor for erased regions.\n-            ty::ReLateBound(..) | ty::ReErased => {\n-                return Ok(r);\n-            }\n-\n-            ty::ReError(_) => {\n-                return Ok(r);\n-            }\n-\n-            ty::RePlaceholder(..)\n-            | ty::ReVar(..)\n-            | ty::ReStatic\n-            | ty::ReEarlyBound(..)\n-            | ty::ReFree(..) => {\n-                // see common code below\n-            }\n-        }\n-\n-        // If we are in an invariant context, we can re-use the region\n-        // as is, unless it happens to be in some universe that we\n-        // can't name. (In the case of a region *variable*, we could\n-        // use it if we promoted it into our universe, but we don't\n-        // bother.)\n-        if let ty::Invariant = self.ambient_variance {\n-            let r_universe = self.infcx.universe_of_region(r);\n-            if self.for_universe.can_name(r_universe) {\n-                return Ok(r);\n-            }\n-        }\n-\n-        // FIXME: This is non-ideal because we don't give a\n-        // very descriptive origin for this region variable.\n-        Ok(self.infcx.next_region_var_in_universe(MiscVariable(self.cause.span), self.for_universe))\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        c: ty::Const<'tcx>,\n-        c2: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n-\n-        match c.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variable_table = &mut inner.const_unification_table();\n-                let var_value = variable_table.probe_value(vid);\n-                match var_value.val {\n-                    ConstVariableValue::Known { value: u } => {\n-                        drop(inner);\n-                        self.relate(u, u)\n-                    }\n-                    ConstVariableValue::Unknown { universe } => {\n-                        if self.for_universe.can_name(universe) {\n-                            Ok(c)\n-                        } else {\n-                            let new_var_id = variable_table.new_key(ConstVarValue {\n-                                origin: var_value.origin,\n-                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n-                            });\n-                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n-                        }\n-                    }\n-                }\n-            }\n-            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n-                let substs = self.relate_with_variance(\n-                    ty::Variance::Invariant,\n-                    ty::VarianceDiagInfo::default(),\n-                    substs,\n-                    substs,\n-                )?;\n-                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n-            }\n-            _ => relate::super_relate_consts(self, c, c),\n-        }\n-    }\n-}\n-\n pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n     /// Register obligations that must hold in order for this relation to hold\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>);"}, {"sha": "8913f5c8a43e0c943f3e89756ccd74dd14ffb396", "filename": "compiler/rustc_infer/src/infer/generalize.rs", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fgeneralize.rs?ref=338e7642fbe6af32351363ab1044494da14b0dec", "patch": "@@ -0,0 +1,431 @@\n+use rustc_data_structures::sso::SsoHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n+use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::{self, InferConst, Ty, TyCtxt, TypeVisitableExt};\n+\n+use crate::infer::combine::CombineFields;\n+use crate::infer::nll_relate::TypeRelatingDelegate;\n+use crate::infer::type_variable::TypeVariableValue;\n+use crate::infer::{InferCtxt, RegionVariableOrigin};\n+\n+pub trait GeneralizerDelegate<'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx>;\n+\n+    fn forbid_inference_vars() -> bool;\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n+}\n+\n+impl<'tcx> GeneralizerDelegate<'tcx> for CombineFields<'_, 'tcx> {\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        false\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var_in_universe(\n+            RegionVariableOrigin::MiscVariable(self.trace.span()),\n+            universe,\n+        )\n+    }\n+}\n+\n+impl<'tcx, T> GeneralizerDelegate<'tcx> for T\n+where\n+    T: TypeRelatingDelegate<'tcx>,\n+{\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        <Self as TypeRelatingDelegate<'tcx>>::param_env(self)\n+    }\n+\n+    fn forbid_inference_vars() -> bool {\n+        <Self as TypeRelatingDelegate<'tcx>>::forbid_inference_vars()\n+    }\n+\n+    fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n+        <Self as TypeRelatingDelegate<'tcx>>::generalize_existential(self, universe)\n+    }\n+}\n+\n+/// The \"type generalizer\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+pub(super) struct Generalizer<'me, 'tcx, D>\n+where\n+    D: GeneralizerDelegate<'tcx>,\n+{\n+    pub infcx: &'me InferCtxt<'tcx>,\n+\n+    // An delegate used to abstract the behaviors of the three previous\n+    // generalizer-like implementations.\n+    pub delegate: &'me mut D,\n+\n+    /// After we generalize this type, we are going to relate it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    /// The vid of the type variable that is in the process of being\n+    /// instantiated. If we find this within the value we are folding,\n+    /// that means we would have created a cyclic value.\n+    pub for_vid_sub_root: ty::TyVid,\n+\n+    /// The universe of the type variable that is in the process of being\n+    /// instantiated. If we find anything that this universe cannot name,\n+    /// we reject the relation.\n+    for_universe: ty::UniverseIndex,\n+\n+    pub root_ty: Ty<'tcx>,\n+\n+    cache: SsoHashMap<Ty<'tcx>, Ty<'tcx>>,\n+\n+    /// See the field `needs_wf` in `Generalization`.\n+    needs_wf: bool,\n+}\n+\n+impl<'tcx, D: GeneralizerDelegate<'tcx>> Generalizer<'_, 'tcx, D> {\n+    pub fn generalize<T>(mut self, value: T) -> RelateResult<'tcx, Generalization<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        assert!(!value.has_escaping_bound_vars());\n+        let value = self.relate(value, value)?;\n+        let needs_wf = self.needs_wf;\n+        Ok(Generalization { value, needs_wf })\n+    }\n+}\n+\n+impl<'tcx, D> TypeRelation<'tcx> for Generalizer<'_, 'tcx, D>\n+where\n+    D: GeneralizerDelegate<'tcx>,\n+{\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.delegate.param_env()\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"Generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_item_substs(\n+        &mut self,\n+        item_def_id: DefId,\n+        a_subst: ty::SubstsRef<'tcx>,\n+        b_subst: ty::SubstsRef<'tcx>,\n+    ) -> RelateResult<'tcx, ty::SubstsRef<'tcx>> {\n+        if self.ambient_variance == ty::Variance::Invariant {\n+            // Avoid fetching the variance if we are in an invariant\n+            // context; no need, and it can induce dependency cycles\n+            // (e.g., #41849).\n+            relate::relate_substs(self, a_subst, b_subst)\n+        } else {\n+            let tcx = self.tcx();\n+            let opt_variances = tcx.variances_of(item_def_id);\n+            relate::relate_substs_with_variances(\n+                self,\n+                item_def_id,\n+                &opt_variances,\n+                a_subst,\n+                b_subst,\n+                true,\n+            )\n+        }\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+        a: T,\n+        b: T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\"Generalizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\"Generalizer::relate_with_variance: ambient_variance = {:?}\", self.ambient_variance);\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"Generalizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        assert_eq!(t, t2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        if let Some(&result) = self.cache.get(&t) {\n+            return Ok(result);\n+        }\n+        debug!(\"generalize: t={:?}\", t);\n+\n+        // Check to see whether the type we are generalizing references\n+        // any other type variable related to `vid` via\n+        // subtyping. This is basically our \"occurs check\", preventing\n+        // us from creating infinitely sized types.\n+        let g = match *t.kind() {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n+                if D::forbid_inference_vars() =>\n+            {\n+                bug!(\"unexpected inference variable encountered in NLL generalization: {t}\");\n+            }\n+\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"unexpected infer type: {t}\")\n+            }\n+\n+            ty::Infer(ty::TyVar(vid)) => {\n+                let vid = self.infcx.inner.borrow_mut().type_variables().root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables().sub_root_var(vid);\n+                if sub_vid == self.for_vid_sub_root {\n+                    // If sub-roots are equal, then `for_vid` and\n+                    // `vid` are related via subtyping.\n+                    Err(TypeError::CyclicTy(self.root_ty))\n+                } else {\n+                    let probe = self.infcx.inner.borrow_mut().type_variables().probe(vid);\n+                    match probe {\n+                        TypeVariableValue::Known { value: u } => {\n+                            debug!(\"generalize: known value {:?}\", u);\n+                            self.relate(u, u)\n+                        }\n+                        TypeVariableValue::Unknown { universe } => {\n+                            match self.ambient_variance {\n+                                // Invariant: no need to make a fresh type variable.\n+                                ty::Invariant => {\n+                                    if self.for_universe.can_name(universe) {\n+                                        return Ok(t);\n+                                    }\n+                                }\n+\n+                                // Bivariant: make a fresh var, but we\n+                                // may need a WF predicate. See\n+                                // comment on `needs_wf` field for\n+                                // more info.\n+                                ty::Bivariant => self.needs_wf = true,\n+\n+                                // Co/contravariant: this will be\n+                                // sufficiently constrained later on.\n+                                ty::Covariant | ty::Contravariant => (),\n+                            }\n+\n+                            let origin =\n+                                *self.infcx.inner.borrow_mut().type_variables().var_origin(vid);\n+                            let new_var_id = self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables()\n+                                .new_var(self.for_universe, origin);\n+                            let u = self.tcx().mk_ty_var(new_var_id);\n+\n+                            // Record that we replaced `vid` with `new_var_id` as part of a generalization\n+                            // operation. This is needed to detect cyclic types. To see why, see the\n+                            // docs in the `type_variables` module.\n+                            self.infcx.inner.borrow_mut().type_variables().sub(vid, new_var_id);\n+                            debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n+                            Ok(u)\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(t)\n+            }\n+\n+            ty::Placeholder(placeholder) => {\n+                if self.for_universe.cannot_name(placeholder.universe) {\n+                    debug!(\n+                        \"Generalizer::tys: root universe {:?} cannot name\\\n+                         placeholder in universe {:?}\",\n+                        self.for_universe, placeholder.universe\n+                    );\n+                    Err(TypeError::Mismatch)\n+                } else {\n+                    Ok(t)\n+                }\n+            }\n+\n+            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                let s = self.relate(substs, substs)?;\n+                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n+            }\n+            _ => relate::super_relate_tys(self, t, t),\n+        }?;\n+\n+        self.cache.insert(t, g);\n+        Ok(g)\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        r: ty::Region<'tcx>,\n+        r2: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        assert_eq!(r, r2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        debug!(\"generalize: regions r={:?}\", r);\n+\n+        match *r {\n+            // Never make variables for regions bound within the type itself,\n+            // nor for erased regions.\n+            ty::ReLateBound(..) | ty::ReErased => {\n+                return Ok(r);\n+            }\n+\n+            ty::ReError(_) => {\n+                return Ok(r);\n+            }\n+\n+            ty::RePlaceholder(..)\n+            | ty::ReVar(..)\n+            | ty::ReStatic\n+            | ty::ReEarlyBound(..)\n+            | ty::ReFree(..) => {\n+                // see common code below\n+            }\n+        }\n+\n+        // If we are in an invariant context, we can re-use the region\n+        // as is, unless it happens to be in some universe that we\n+        // can't name.\n+        if let ty::Invariant = self.ambient_variance {\n+            let r_universe = self.infcx.universe_of_region(r);\n+            if self.for_universe.can_name(r_universe) {\n+                return Ok(r);\n+            }\n+        }\n+\n+        // FIXME: This is non-ideal because we don't give a\n+        // very descriptive origin for this region variable.\n+        let replacement_region_vid = self.delegate.generalize_existential(self.for_universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        c: ty::Const<'tcx>,\n+        c2: ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n+        assert_eq!(c, c2); // we are misusing TypeRelation here; both LHS and RHS ought to be ==\n+\n+        match c.kind() {\n+            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n+                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", c);\n+            }\n+            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n+                let mut inner = self.infcx.inner.borrow_mut();\n+                let variable_table = &mut inner.const_unification_table();\n+                let var_value = variable_table.probe_value(vid);\n+                match var_value.val {\n+                    ConstVariableValue::Known { value: u } => {\n+                        drop(inner);\n+                        self.relate(u, u)\n+                    }\n+                    ConstVariableValue::Unknown { universe } => {\n+                        if self.for_universe.can_name(universe) {\n+                            Ok(c)\n+                        } else {\n+                            let new_var_id = variable_table.new_key(ConstVarValue {\n+                                origin: var_value.origin,\n+                                val: ConstVariableValue::Unknown { universe: self.for_universe },\n+                            });\n+                            Ok(self.tcx().mk_const(new_var_id, c.ty()))\n+                        }\n+                    }\n+                }\n+            }\n+            // FIXME: remove this branch once `structurally_relate_consts` is fully\n+            // structural.\n+            ty::ConstKind::Unevaluated(ty::UnevaluatedConst { def, substs }) => {\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n+                Ok(self.tcx().mk_const(ty::UnevaluatedConst { def, substs }, c.ty()))\n+            }\n+            _ => relate::super_relate_consts(self, c, c),\n+        }\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: ty::Binder<'tcx, T>,\n+        _: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"Generalizer::binders(a={:?})\", a);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        Ok(a.rebind(result))\n+    }\n+}\n+\n+/// Result from a generalization operation. This includes\n+/// not only the generalized type, but also a bool flag\n+/// indicating whether further WF checks are needed.\n+#[derive(Debug)]\n+pub struct Generalization<T> {\n+    pub value: T,\n+\n+    /// If true, then the generalized type may not be well-formed,\n+    /// even if the source type is well-formed, so we should add an\n+    /// additional check to enforce that it is. This arises in\n+    /// particular around 'bivariant' type parameters that are only\n+    /// constrained by a where-clause. As an example, imagine a type:\n+    ///\n+    ///     struct Foo<A, B> where A: Iterator<Item = B> {\n+    ///         data: A\n+    ///     }\n+    ///\n+    /// here, `A` will be covariant, but `B` is\n+    /// unconstrained. However, whatever it is, for `Foo` to be WF, it\n+    /// must be equal to `A::Item`. If we have an input `Foo<?A, ?B>`,\n+    /// then after generalization we will wind up with a type like\n+    /// `Foo<?C, ?D>`. When we enforce that `Foo<?A, ?B> <: Foo<?C,\n+    /// ?D>` (or `>:`), we will wind up with the requirement that `?A\n+    /// <: ?C`, but no particular relationship between `?B` and `?D`\n+    /// (after all, we do not know the variance of the normalized form\n+    /// of `A::Item` with respect to `A`). If we do nothing else, this\n+    /// may mean that `?D` goes unconstrained (as in #41677). So, in\n+    /// this scenario where we create a new type variable in a\n+    /// bivariant context, we set the `needs_wf` flag to true. This\n+    /// will force the calling code to check that `WF(Foo<?C, ?D>)`\n+    /// holds, which in turn implies that `?C::Item == ?D`. So once\n+    /// `?C` is constrained, that should suffice to restrict `?D`.\n+    pub needs_wf: bool,\n+}"}, {"sha": "e53319e3b86be7102b0233fae0be1547859034b4", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=338e7642fbe6af32351363ab1044494da14b0dec", "patch": "@@ -58,6 +58,7 @@ pub mod error_reporting;\n pub mod free_regions;\n mod freshen;\n mod fudge;\n+mod generalize;\n mod glb;\n mod higher_ranked;\n pub mod lattice;"}, {"sha": "f479dbdc43cb5c3e55126b2fc7d4b308b3ba0e21", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 20, "deletions": 255, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/338e7642fbe6af32351363ab1044494da14b0dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=338e7642fbe6af32351363ab1044494da14b0dec", "patch": "@@ -21,21 +21,20 @@\n //!   thing we relate in chalk are basically domain goals and their\n //!   constituents)\n \n-use crate::infer::InferCtxt;\n-use crate::infer::{ConstVarValue, ConstVariableValue};\n-use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::FnMutDelegate;\n-use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_span::{Span, Symbol};\n use std::fmt::Debug;\n \n-use super::combine::ObligationEmittingRelation;\n+use crate::infer::combine::ObligationEmittingRelation;\n+use crate::infer::generalize::{Generalization, Generalizer};\n+use crate::infer::InferCtxt;\n+use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::traits::{Obligation, PredicateObligations};\n \n pub struct TypeRelating<'me, 'tcx, D>\n where\n@@ -198,7 +197,7 @@ where\n             _ => (),\n         }\n \n-        let generalized_ty = self.generalize_value(value_ty, vid)?;\n+        let generalized_ty = self.generalize(value_ty, vid)?;\n         debug!(\"relate_ty_var: generalized_ty = {:?}\", generalized_ty);\n \n         if D::forbid_inference_vars() {\n@@ -217,26 +216,24 @@ where\n         result\n     }\n \n-    fn generalize_value<T: Relate<'tcx>>(\n-        &mut self,\n-        value: T,\n-        for_vid: ty::TyVid,\n-    ) -> RelateResult<'tcx, T> {\n-        let universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+    fn generalize(&mut self, ty: Ty<'tcx>, for_vid: ty::TyVid) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let for_universe = self.infcx.probe_ty_var(for_vid).unwrap_err();\n+        let for_vid_sub_root = self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid);\n \n-        if value.has_escaping_bound_vars() {\n-            bug!(\"trying to instantiate {for_vid:?} with escaping bound vars: {value:?}\");\n-        }\n-\n-        let mut generalizer = TypeGeneralizer {\n+        // FIXME: we may need a WF predicate (related to #54105).\n+        let Generalization { value, needs_wf: _ } = Generalizer {\n             infcx: self.infcx,\n             delegate: &mut self.delegate,\n             ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables().sub_root_var(for_vid),\n-            universe,\n-        };\n+            for_vid_sub_root,\n+            for_universe,\n+            root_ty: ty,\n+            needs_wf: false,\n+            cache: Default::default(),\n+        }\n+        .generalize(ty)?;\n \n-        generalizer.relate(value, value)\n+        Ok(value)\n     }\n \n     fn relate_opaques(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n@@ -716,235 +713,3 @@ where\n         })]);\n     }\n }\n-\n-/// The \"type generalizer\" is used when handling inference variables.\n-///\n-/// The basic strategy for handling a constraint like `?A <: B` is to\n-/// apply a \"generalization strategy\" to the type `B` -- this replaces\n-/// all the lifetimes in the type `B` with fresh inference\n-/// variables. (You can read more about the strategy in this [blog\n-/// post].)\n-///\n-/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n-/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n-/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n-/// establishes `'0: 'x` as a constraint.\n-///\n-/// [blog post]: https://is.gd/0hKvIr\n-struct TypeGeneralizer<'me, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    infcx: &'me InferCtxt<'tcx>,\n-\n-    delegate: &'me mut D,\n-\n-    /// After we generalize this type, we are going to relate it to\n-    /// some other type. What will be the variance at this point?\n-    ambient_variance: ty::Variance,\n-\n-    /// The vid of the type variable that is in the process of being\n-    /// instantiated. If we find this within the value we are folding,\n-    /// that means we would have created a cyclic value.\n-    for_vid_sub_root: ty::TyVid,\n-\n-    /// The universe of the type variable that is in the process of being\n-    /// instantiated. If we find anything that this universe cannot name,\n-    /// we reject the relation.\n-    universe: ty::UniverseIndex,\n-}\n-\n-impl<'tcx, D> TypeRelation<'tcx> for TypeGeneralizer<'_, 'tcx, D>\n-where\n-    D: TypeRelatingDelegate<'tcx>,\n-{\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.delegate.param_env()\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"nll::generalizer\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        variance: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n-            variance, a, b\n-        );\n-\n-        let old_ambient_variance = self.ambient_variance;\n-        self.ambient_variance = self.ambient_variance.xform(variance);\n-\n-        debug!(\n-            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n-            self.ambient_variance\n-        );\n-\n-        let r = self.relate(a, b)?;\n-\n-        self.ambient_variance = old_ambient_variance;\n-\n-        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n-\n-        Ok(r)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        use crate::infer::type_variable::TypeVariableValue;\n-\n-        debug!(\"TypeGeneralizer::tys(a={:?})\", a);\n-\n-        match *a.kind() {\n-            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_))\n-                if D::forbid_inference_vars() =>\n-            {\n-                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n-            }\n-\n-            ty::Infer(ty::TyVar(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variables = &mut inner.type_variables();\n-                let vid = variables.root_var(vid);\n-                let sub_vid = variables.sub_root_var(vid);\n-                if sub_vid == self.for_vid_sub_root {\n-                    // If sub-roots are equal, then `for_vid` and\n-                    // `vid` are related via subtyping.\n-                    debug!(\"TypeGeneralizer::tys: occurs check failed\");\n-                    Err(TypeError::Mismatch)\n-                } else {\n-                    match variables.probe(vid) {\n-                        TypeVariableValue::Known { value: u } => {\n-                            drop(inner);\n-                            self.relate(u, u)\n-                        }\n-                        TypeVariableValue::Unknown { universe: _universe } => {\n-                            if self.ambient_variance == ty::Bivariant {\n-                                // FIXME: we may need a WF predicate (related to #54105).\n-                            }\n-\n-                            let origin = *variables.var_origin(vid);\n-\n-                            // Replacing with a new variable in the universe `self.universe`,\n-                            // it will be unified later with the original type variable in\n-                            // the universe `_universe`.\n-                            let new_var_id = variables.new_var(self.universe, origin);\n-\n-                            let u = self.tcx().mk_ty_var(new_var_id);\n-                            debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n-                            Ok(u)\n-                        }\n-                    }\n-                }\n-            }\n-\n-            ty::Infer(ty::IntVar(_) | ty::FloatVar(_)) => {\n-                // No matter what mode we are in,\n-                // integer/floating-point types must be equal to be\n-                // relatable.\n-                Ok(a)\n-            }\n-\n-            ty::Placeholder(placeholder) => {\n-                if self.universe.cannot_name(placeholder.universe) {\n-                    debug!(\n-                        \"TypeGeneralizer::tys: root universe {:?} cannot name\\\n-                         placeholder in universe {:?}\",\n-                        self.universe, placeholder.universe\n-                    );\n-                    Err(TypeError::Mismatch)\n-                } else {\n-                    Ok(a)\n-                }\n-            }\n-\n-            _ => relate::super_relate_tys(self, a, a),\n-        }\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        _: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"TypeGeneralizer::regions(a={:?})\", a);\n-\n-        if let ty::ReLateBound(..) = *a {\n-            return Ok(a);\n-        }\n-\n-        // For now, we just always create a fresh region variable to\n-        // replace all the regions in the source type. In the main\n-        // type checker, we special case the case where the ambient\n-        // variance is `Invariant` and try to avoid creating a fresh\n-        // region variable, but since this comes up so much less in\n-        // NLL (only when users use `_` etc) it is much less\n-        // important.\n-        //\n-        // As an aside, since these new variables are created in\n-        // `self.universe` universe, this also serves to enforce the\n-        // universe scoping rules.\n-        //\n-        // FIXME(#54105) -- if the ambient variance is bivariant,\n-        // though, we may however need to check well-formedness or\n-        // risk a problem like #41677 again.\n-        let replacement_region_vid = self.delegate.generalize_existential(self.universe);\n-\n-        Ok(replacement_region_vid)\n-    }\n-\n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        _: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        match a.kind() {\n-            ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n-                bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n-            }\n-            ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut inner = self.infcx.inner.borrow_mut();\n-                let variable_table = &mut inner.const_unification_table();\n-                let var_value = variable_table.probe_value(vid);\n-                match var_value.val.known() {\n-                    Some(u) => self.relate(u, u),\n-                    None => {\n-                        let new_var_id = variable_table.new_key(ConstVarValue {\n-                            origin: var_value.origin,\n-                            val: ConstVariableValue::Unknown { universe: self.universe },\n-                        });\n-                        Ok(self.tcx().mk_const(new_var_id, a.ty()))\n-                    }\n-                }\n-            }\n-            ty::ConstKind::Unevaluated(..) if self.tcx().lazy_normalization() => Ok(a),\n-            _ => relate::super_relate_consts(self, a, a),\n-        }\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        _: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"TypeGeneralizer::binders(a={:?})\", a);\n-        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n-        Ok(a.rebind(result))\n-    }\n-}"}]}