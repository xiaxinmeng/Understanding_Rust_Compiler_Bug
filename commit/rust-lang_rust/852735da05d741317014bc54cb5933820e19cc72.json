{"sha": "852735da05d741317014bc54cb5933820e19cc72", "node_id": "C_kwDOAAsO6NoAKDg1MjczNWRhMDVkNzQxMzE3MDE0YmM1NGNiNTkzMzgyMGUxOWNjNzI", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-05-03T21:47:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-03T21:47:03Z"}, "message": "Merge pull request #171 from GuillaumeGomez/update-intrinsics\n\nUpdate intrinsics conversion generation", "tree": {"sha": "8887dad15a67d6c1fd7391efab318e4138b16f4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8887dad15a67d6c1fd7391efab318e4138b16f4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/852735da05d741317014bc54cb5933820e19cc72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJicaLXCRBK7hj4Ov3rIwAAOoIIADG8qxZBu3IbPVs3dwzSBc8P\ng4GmrES6WlqHQePNRlUlsgysOsV2ymp76ADqC5vTwRZdmYzFpKTvYUd/wkuvvtOr\nETyRdejyVYcUAzlbl7PrBnK1JjnyVLQ3xe62j76T4WcHTxdxs/rn+mpiTLbyYEbE\njceZSlU63/zI7MjSaYn44eQXcbK3yyV6z97Tpwtgs7JNesR1nYzbItG55oZ4xyQt\nLHzJOYyT0OPjGmlTIe2BoQVHW5VLrnjbVhSTZqcQwBwKI7qKvnLcUiXEMAo6IkeO\n4WAVlES2oK8P7Y7qTA9xzcseTKSOVTXrQ1GahFzOTRU/R82EGg8PLZ6TCj5huxQ=\n=tfKi\n-----END PGP SIGNATURE-----\n", "payload": "tree 8887dad15a67d6c1fd7391efab318e4138b16f4b\nparent 37892fc51138fe55bdf7f31fa3cbbd573d8ab7c4\nparent 6e1bf49273a2011aa3fb26e641e410ca42d924af\nauthor antoyo <antoyo@users.noreply.github.com> 1651614423 -0400\ncommitter GitHub <noreply@github.com> 1651614423 -0400\n\nMerge pull request #171 from GuillaumeGomez/update-intrinsics\n\nUpdate intrinsics conversion generation"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/852735da05d741317014bc54cb5933820e19cc72", "html_url": "https://github.com/rust-lang/rust/commit/852735da05d741317014bc54cb5933820e19cc72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/852735da05d741317014bc54cb5933820e19cc72/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37892fc51138fe55bdf7f31fa3cbbd573d8ab7c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/37892fc51138fe55bdf7f31fa3cbbd573d8ab7c4", "html_url": "https://github.com/rust-lang/rust/commit/37892fc51138fe55bdf7f31fa3cbbd573d8ab7c4"}, {"sha": "6e1bf49273a2011aa3fb26e641e410ca42d924af", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1bf49273a2011aa3fb26e641e410ca42d924af", "html_url": "https://github.com/rust-lang/rust/commit/6e1bf49273a2011aa3fb26e641e410ca42d924af"}], "stats": {"total": 1567, "additions": 1556, "deletions": 11}, "files": [{"sha": "ffd36ddb7db0e80baba481a90435cc24868d13ce", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/852735da05d741317014bc54cb5933820e19cc72/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/852735da05d741317014bc54cb5933820e19cc72/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=852735da05d741317014bc54cb5933820e19cc72", "patch": "@@ -20,3 +20,5 @@ res\n test-backend\n gcc_path\n benchmarks\n+tools/llvm-project\n+tools/llvmint"}, {"sha": "bfeb30f2913d3edb5f155c13810b0216bfe352a4", "filename": "src/intrinsic/archs.rs", "status": "modified", "additions": 1325, "deletions": 11, "changes": 1336, "blob_url": "https://github.com/rust-lang/rust/blob/852735da05d741317014bc54cb5933820e19cc72/src%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852735da05d741317014bc54cb5933820e19cc72/src%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Farchs.rs?ref=852735da05d741317014bc54cb5933820e19cc72"}, {"sha": "a1e28c3181c9b39bf765266de740c705f50eed09", "filename": "tools/generate_intrinsics.py", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/852735da05d741317014bc54cb5933820e19cc72/tools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/852735da05d741317014bc54cb5933820e19cc72/tools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tools%2Fgenerate_intrinsics.py?ref=852735da05d741317014bc54cb5933820e19cc72", "patch": "@@ -0,0 +1,229 @@\n+import json\n+import os\n+import re\n+import sys\n+import subprocess\n+from os import walk\n+\n+\n+def run_command(command, cwd=None):\n+    p = subprocess.Popen(command, cwd=cwd)\n+    if p.wait() != 0:\n+        print(\"command `{}` failed...\".format(\" \".join(command)))\n+        sys.exit(1)\n+\n+\n+def clone_repository(repo_name, path, repo_url, sub_path=None):\n+    if os.path.exists(path):\n+        while True:\n+            choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(repo_name))\n+            if choice == \"\" or choice.lower() == \"n\":\n+                print(\"Skipping repository update.\")\n+                return\n+            elif choice.lower() == \"y\":\n+                print(\"Updating repository...\")\n+                run_command([\"git\", \"pull\", \"origin\"], cwd=path)\n+                return\n+            else:\n+                print(\"Didn't understand answer...\")\n+    print(\"Cloning {} repository...\".format(repo_name))\n+    if sub_path is None:\n+        run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n+    else:\n+        run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n+        run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"checkout\"], cwd=path)\n+\n+\n+def append_intrinsic(array, intrinsic_name, translation):\n+    array.append((intrinsic_name, translation))\n+\n+\n+def extract_instrinsics(intrinsics, file):\n+    print(\"Extracting intrinsics from `{}`...\".format(file))\n+    with open(file, \"r\", encoding=\"utf8\") as f:\n+        content = f.read()\n+\n+    lines = content.splitlines()\n+    pos = 0\n+    current_arch = None\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        if line.startswith(\"let TargetPrefix =\"):\n+            current_arch = line.split('\"')[1].strip()\n+            if len(current_arch) == 0:\n+                current_arch = None\n+        elif current_arch is None:\n+            pass\n+        elif line == \"}\":\n+            current_arch = None\n+        elif line.startswith(\"def \"):\n+            content = \"\"\n+            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n+                line = lines[pos].split(\" // \")[0].strip()\n+                content += line\n+                pos += 1\n+            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n+            if len(entries) > 0:\n+                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n+                intrinsic = intrinsic.split(\"_\")\n+                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                    continue\n+                intrinsic[0] = \"llvm\"\n+                intrinsic = \".\".join(intrinsic)\n+                if current_arch not in intrinsics:\n+                    intrinsics[current_arch] = []\n+                for entry in entries:\n+                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+            continue\n+        pos += 1\n+        continue\n+    print(\"Done!\")\n+\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    files = []\n+    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n+    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n+        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n+\n+    for file in files:\n+        extract_instrinsics(intrinsics, file)\n+\n+\n+def append_translation(json_data, p, array):\n+    it = json_data[\"index\"][p]\n+    content = it[\"docs\"].split('`')\n+    if len(content) != 5:\n+        return\n+    append_intrinsic(array, content[1], content[3])\n+\n+\n+def extract_instrinsics_from_llvmint(llvmint, intrinsics):\n+    archs = [\n+        \"AMDGPU\",\n+        \"aarch64\",\n+        \"arm\",\n+        \"cuda\",\n+        \"hexagon\",\n+        \"mips\",\n+        \"nvvm\",\n+        \"ppc\",\n+        \"ptx\",\n+        \"x86\",\n+        \"xcore\",\n+    ]\n+\n+    json_file = os.path.join(llvmint, \"target/doc/llvmint.json\")\n+    if not os.path.exists(json_file):\n+        # We need to regenerate the documentation!\n+        run_command(\n+            [\"cargo\", \"rustdoc\", \"--\", \"-Zunstable-options\", \"--output-format\", \"json\"],\n+            cwd=llvmint,\n+        )\n+    with open(json_file, \"r\", encoding=\"utf8\") as f:\n+        json_data = json.loads(f.read())\n+    for p in json_data[\"paths\"]:\n+        it = json_data[\"paths\"][p]\n+        if it[\"crate_id\"] != 0:\n+            # This is from an external crate.\n+            continue\n+        if it[\"kind\"] != \"function\":\n+            # We're only looking for functions.\n+            continue\n+        # if len(it[\"path\"]) == 2:\n+        #   # This is a \"general\" intrinsic, not bound to a specific arch.\n+        #   append_translation(json_data, p, general)\n+        #   continue\n+        if len(it[\"path\"]) != 3 or it[\"path\"][1] not in archs:\n+            continue\n+        arch = it[\"path\"][1]\n+        if arch not in intrinsics:\n+            intrinsics[arch] = []\n+        append_translation(json_data, p, intrinsics[arch])\n+\n+\n+def fill_intrinsics(intrinsics, from_intrinsics, all_intrinsics):\n+    for arch in from_intrinsics:\n+        if arch not in intrinsics:\n+            intrinsics[arch] = []\n+        for entry in from_intrinsics[arch]:\n+            if entry[0] in all_intrinsics:\n+                if all_intrinsics[entry[0]] == entry[1]:\n+                    # This is a \"full\" duplicate, both the LLVM instruction and the GCC\n+                    # translation are the same.\n+                    continue\n+                intrinsics[arch].append((entry[0], entry[1], True))\n+            else:\n+                intrinsics[arch].append((entry[0], entry[1], False))\n+                all_intrinsics[entry[0]] = entry[1]\n+\n+\n+def update_intrinsics(llvm_path, llvmint):\n+    intrinsics_llvm = {}\n+    intrinsics_llvmint = {}\n+    all_intrinsics = {}\n+\n+    extract_instrinsics_from_llvm(llvm_path, intrinsics_llvm)\n+    extract_instrinsics_from_llvmint(llvmint, intrinsics_llvmint)\n+\n+    intrinsics = {}\n+    # We give priority to translations from LLVM over the ones from llvmint.\n+    fill_intrinsics(intrinsics, intrinsics_llvm, all_intrinsics)\n+    fill_intrinsics(intrinsics, intrinsics_llvmint, all_intrinsics)\n+\n+    archs = [arch for arch in intrinsics]\n+    archs.sort()\n+\n+    output_file = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"../src/intrinsic/archs.rs\",\n+    )\n+    print(\"Updating content of `{}`...\".format(output_file))\n+    with open(output_file, \"w\", encoding=\"utf8\") as out:\n+        out.write(\"// File generated by `rustc_codegen_gcc/tools/generate_intrinsics.py`\\n\")\n+        out.write(\"// DO NOT EDIT IT!\\n\")\n+        out.write(\"match name {\\n\")\n+        for arch in archs:\n+            if len(intrinsics[arch]) == 0:\n+                continue\n+            intrinsics[arch].sort(key=lambda x: (x[0], x[2]))\n+            out.write('    // {}\\n'.format(arch))\n+            for entry in intrinsics[arch]:\n+                if entry[2] == True: # if it is a duplicate\n+                    out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                else:\n+                    out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+        out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n+        out.write(\"}\\n\")\n+    print(\"Done!\")\n+\n+\n+def main():\n+    llvm_path = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"llvm-project\",\n+    )\n+    llvmint_path = os.path.join(\n+        os.path.dirname(os.path.abspath(__file__)),\n+        \"llvmint\",\n+    )\n+\n+    # First, we clone the LLVM repository if it's not already here.\n+    clone_repository(\n+        \"llvm-project\",\n+        llvm_path,\n+        \"https://github.com/llvm/llvm-project\",\n+        sub_path=\"llvm/include/llvm/IR\",\n+    )\n+    clone_repository(\n+        \"llvmint\",\n+        llvmint_path,\n+        \"https://github.com/GuillaumeGomez/llvmint\",\n+    )\n+    update_intrinsics(llvm_path, llvmint_path)\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())"}]}