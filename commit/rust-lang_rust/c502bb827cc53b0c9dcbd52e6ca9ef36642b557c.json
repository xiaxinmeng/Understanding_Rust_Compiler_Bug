{"sha": "c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDJiYjgyN2NjNTNiMGM5ZGNiZDUyZTZjYTllZjM2NjQyYjU1N2M=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-24T10:05:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-24T10:05:41Z"}, "message": "Merge pull request #142 from oli-obk/memleak\n\nMemleak", "tree": {"sha": "58bdc9004293ea16ed749e3778b7d106f90c773c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58bdc9004293ea16ed749e3778b7d106f90c773c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "html_url": "https://github.com/rust-lang/rust/commit/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd2f34ab26be97dcd0f144c0683ff11866ffe29e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd2f34ab26be97dcd0f144c0683ff11866ffe29e", "html_url": "https://github.com/rust-lang/rust/commit/cd2f34ab26be97dcd0f144c0683ff11866ffe29e"}, {"sha": "31c81ac3227e8f4aa4a16f88ebf5af6414ee9d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/31c81ac3227e8f4aa4a16f88ebf5af6414ee9d0e", "html_url": "https://github.com/rust-lang/rust/commit/31c81ac3227e8f4aa4a16f88ebf5af6414ee9d0e"}], "stats": {"total": 105, "additions": 62, "deletions": 43}, "files": [{"sha": "0ab6e85e389d0563fc761b5e939ccfc92f3aa7e6", "filename": "src/eval_context.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -81,8 +81,8 @@ pub struct Frame<'tcx> {\n     /// Temporary allocations introduced to save stackframes\n     /// This is pure interpreter magic and has nothing to do with how rustc does it\n     /// An example is calling an FnMut closure that has been converted to a FnOnce closure\n-    /// The memory will be freed when the stackframe finishes\n-    pub interpreter_temporaries: Vec<Pointer>,\n+    /// The value's destructor will be called and the memory freed when the stackframe finishes\n+    pub interpreter_temporaries: Vec<(Pointer, Ty<'tcx>)>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         return_lvalue: Lvalue<'tcx>,\n         return_to_block: StackPopCleanup,\n-        temporaries: Vec<Pointer>,\n+        temporaries: Vec<(Pointer, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n@@ -347,11 +347,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n             }\n         }\n-        // deallocate all temporary allocations\n-        for ptr in frame.interpreter_temporaries {\n-            trace!(\"deallocating temporary allocation\");\n-            self.memory.dump_alloc(ptr.alloc_id);\n-            self.memory.deallocate(ptr)?;\n+        // drop and deallocate all temporary allocations\n+        for (ptr, ty) in frame.interpreter_temporaries {\n+            trace!(\"dropping temporary allocation\");\n+            let mut drops = Vec::new();\n+            self.drop(Lvalue::from_ptr(ptr), ty, &mut drops)?;\n+            self.eval_drop_impls(drops, frame.span)?;\n         }\n         Ok(())\n     }\n@@ -928,26 +929,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         val: PrimVal,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        match dest {\n-            Lvalue::Ptr { ptr, extra } => {\n-                assert_eq!(extra, LvalueExtra::None);\n-                let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n-                self.memory.write_primval(ptr, val, size)\n-            }\n-            Lvalue::Local { frame, local, field } => {\n-                self.stack[frame].set_local(local, field.map(|(i, _)| i), Value::ByVal(val));\n-                Ok(())\n-            }\n-            Lvalue::Global(cid) => {\n-                let global_val = self.globals.get_mut(&cid).expect(\"global not cached\");\n-                if global_val.mutable {\n-                    global_val.value = Value::ByVal(val);\n-                    Ok(())\n-                } else {\n-                    Err(EvalError::ModifiedConstantMemory)\n-                }\n-            }\n-        }\n+        self.write_value(Value::ByVal(val), dest, dest_ty)\n     }\n \n     pub(super) fn write_value(\n@@ -1509,7 +1491,13 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     loop {\n         match ecx.step() {\n             Ok(true) => {}\n-            Ok(false) => return,\n+            Ok(false) => {\n+                let leaks = ecx.memory.leak_report();\n+                if leaks != 0 {\n+                    tcx.sess.err(\"the evaluated program leaked memory\");\n+                }\n+                return;\n+            }\n             Err(e) => {\n                 report(tcx, &ecx, e);\n                 return;"}, {"sha": "459a9bed4128fc6cbb7314578ab798d6413f806f", "filename": "src/memory.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -585,6 +585,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn leak_report(&self) -> usize {\n+        trace!(\"### LEAK REPORT ###\");\n+        let leaks: Vec<_> = self.alloc_map\n+            .iter()\n+            .filter_map(|(&key, val)| {\n+                if val.static_kind == StaticKind::NotStatic {\n+                    Some(key)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+        let n = leaks.len();\n+        self.dump_allocs(leaks);\n+        n\n+    }\n }\n \n fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {"}, {"sha": "a46d6096dfc952095402abed38baccc54e0049e6", "filename": "src/traits.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         args: &mut Vec<(Value, Ty<'tcx>)>,\n-    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<Pointer>)> {\n+    ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Vec<(Pointer, Ty<'tcx>)>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n \n@@ -72,16 +72,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let ptr = self.alloc_ptr(args[0].1)?;\n                                 let size = self.type_size(args[0].1)?.expect(\"closures are sized\");\n                                 self.memory.write_primval(ptr, primval, size)?;\n-                                temporaries.push(ptr);\n                                 ptr\n                             },\n                             Value::ByValPair(a, b) => {\n                                 let ptr = self.alloc_ptr(args[0].1)?;\n                                 self.write_pair_to_ptr(a, b, ptr, args[0].1)?;\n-                                temporaries.push(ptr);\n                                 ptr\n                             },\n                         };\n+                        temporaries.push((ptr, args[0].1));\n                         args[0].0 = Value::ByVal(PrimVal::Ptr(ptr));\n                         args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }"}, {"sha": "71b4e2f442f31db02b4d710d3ede9917c51f9dcc", "filename": "tests/compile-fail/memleak.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Fcompile-fail%2Fmemleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Fcompile-fail%2Fmemleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -0,0 +1,5 @@\n+//error-pattern: the evaluated program leaked memory\n+\n+fn main() {\n+    std::mem::forget(Box::new(42));\n+}"}, {"sha": "b2bc6722afb04fd22c6a0bc4b546ecab3fe1e5ac", "filename": "tests/compile-fail/memleak_rc.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Fcompile-fail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Fcompile-fail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmemleak_rc.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -0,0 +1,12 @@\n+//error-pattern: the evaluated program leaked memory\n+\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+\n+struct Dummy(Rc<RefCell<Option<Dummy>>>);\n+\n+fn main() {\n+    let x = Dummy(Rc::new(RefCell::new(None)));\n+    let y = Dummy(x.0.clone());\n+    *x.0.borrow_mut() = Some(y);\n+}"}, {"sha": "f1bdafaeb1354a2619e2ed38ad5d810786010a86", "filename": "tests/run-pass/closure-drop.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Frun-pass%2Fclosure-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Frun-pass%2Fclosure-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fclosure-drop.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -13,17 +13,12 @@ fn f<T: FnOnce()>(t: T) {\n fn main() {\n     let mut ran_drop = false;\n     {\n-        // FIXME: v is a temporary hack to force the below closure to be a FnOnce-only closure\n-        // (with sig fn(self)). Without it, the closure sig would be fn(&self) which requires a\n-        // shim to call via FnOnce::call_once, and Miri's current shim doesn't correctly call\n-        // destructors.\n-        let v = vec![1];\n         let x = Foo(&mut ran_drop);\n-        let g = move || {\n-            let _ = x;\n-            drop(v); // Force the closure to be FnOnce-only by using a capture by-value.\n-        };\n-        f(g);\n+        // this closure never by val uses its captures\n+        // so it's basically a fn(&self)\n+        // the shim used to not drop the `x`\n+        let x = move || { let _ = x; };\n+        f(x);\n     }\n     assert!(ran_drop);\n }"}, {"sha": "0786db1ef895a431857758969dc03910e4de1c9b", "filename": "tests/run-pass/option_box_transmute_ptr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c502bb827cc53b0c9dcbd52e6ca9ef36642b557c/tests%2Frun-pass%2Foption_box_transmute_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Foption_box_transmute_ptr.rs?ref=c502bb827cc53b0c9dcbd52e6ca9ef36642b557c", "patch": "@@ -3,7 +3,10 @@ fn option_box_deref() -> i32 {\n     let val = Some(Box::new(42));\n     unsafe {\n         let ptr: *const i32 = std::mem::transmute::<Option<Box<i32>>, *const i32>(val);\n-        *ptr\n+        let ret = *ptr;\n+        // unleak memory\n+        std::mem::transmute::<*const i32, Option<Box<i32>>>(ptr);\n+        ret\n     }\n }\n "}]}