{"sha": "9405e05d8380dd3d6793e515fe62db6f4fcf8a9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MDVlMDVkODM4MGRkM2Q2NzkzZTUxNWZlNjJkYjZmNGZjZjhhOWM=", "commit": {"author": {"name": "David Alber", "email": "alber.david@gmail.com", "date": "2017-12-23T19:01:00Z"}, "committer": {"name": "David Alber", "email": "alber.david@gmail.com", "date": "2017-12-23T19:40:37Z"}, "message": "Adding ability to recursively find test files\n\nPart of #1492.", "tree": {"sha": "06a75cbea900cdb46c6433ee2378a146ad60783c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06a75cbea900cdb46c6433ee2378a146ad60783c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c", "html_url": "https://github.com/rust-lang/rust/commit/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c/comments", "author": {"login": "davidalber", "id": 933552, "node_id": "MDQ6VXNlcjkzMzU1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/933552?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidalber", "html_url": "https://github.com/davidalber", "followers_url": "https://api.github.com/users/davidalber/followers", "following_url": "https://api.github.com/users/davidalber/following{/other_user}", "gists_url": "https://api.github.com/users/davidalber/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidalber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidalber/subscriptions", "organizations_url": "https://api.github.com/users/davidalber/orgs", "repos_url": "https://api.github.com/users/davidalber/repos", "events_url": "https://api.github.com/users/davidalber/events{/privacy}", "received_events_url": "https://api.github.com/users/davidalber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidalber", "id": 933552, "node_id": "MDQ6VXNlcjkzMzU1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/933552?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidalber", "html_url": "https://github.com/davidalber", "followers_url": "https://api.github.com/users/davidalber/followers", "following_url": "https://api.github.com/users/davidalber/following{/other_user}", "gists_url": "https://api.github.com/users/davidalber/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidalber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidalber/subscriptions", "organizations_url": "https://api.github.com/users/davidalber/orgs", "repos_url": "https://api.github.com/users/davidalber/repos", "events_url": "https://api.github.com/users/davidalber/events{/privacy}", "received_events_url": "https://api.github.com/users/davidalber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939a6c58202f775a63e46fbde4e0d6b3b04cf8aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/939a6c58202f775a63e46fbde4e0d6b3b04cf8aa", "html_url": "https://github.com/rust-lang/rust/commit/939a6c58202f775a63e46fbde4e0d6b3b04cf8aa"}], "stats": {"total": 49, "additions": 26, "deletions": 23}, "files": [{"sha": "569057569d7a3d9a5ba385b3f94b2e44b2a36b49", "filename": "tests/system.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9405e05d8380dd3d6793e515fe62db6f4fcf8a9c/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=9405e05d8380dd3d6793e515fe62db6f4fcf8a9c", "patch": "@@ -30,8 +30,23 @@ use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n \n-fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> PathBuf {\n-    dir_entry.expect(\"Couldn't get DirEntry\").path().to_owned()\n+// Returns a `Vec` containing `PathBuf`s of files with a rs extension in the\n+// given path. The `recursive` argument controls if files from subdirectories\n+// are also returned.\n+fn get_test_files(path: &Path, recursive: bool) -> Vec<PathBuf> {\n+    let mut files = vec![];\n+    if path.is_dir() {\n+        for entry in fs::read_dir(path).expect(\"Couldn't read source dir\") {\n+            let entry = entry.expect(\"Couldn't get DirEntry\");\n+            let path = entry.path();\n+            if path.is_dir() && recursive {\n+                files.append(&mut get_test_files(&path, recursive));\n+            } else if path.extension().map_or(false, |f| f == \"rs\") {\n+                files.push(path);\n+            }\n+        }\n+    }\n+    files\n }\n \n // Integration tests. The files in the tests/source are formatted and compared\n@@ -41,10 +56,7 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> PathBuf {\n #[test]\n fn system_tests() {\n     // Get all files in the tests/source directory.\n-    let files = fs::read_dir(\"tests/source\").expect(\"Couldn't read source dir\");\n-    // Turn a DirEntry into a String that represents the relative path to the\n-    // file.\n-    let files = files.map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/source\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n@@ -56,8 +68,7 @@ fn system_tests() {\n // the only difference is the coverage mode\n #[test]\n fn coverage_tests() {\n-    let files = fs::read_dir(\"tests/coverage/source\").expect(\"Couldn't read source dir\");\n-    let files = files.map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/coverage/source\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     println!(\"Ran {} tests in coverage mode.\", count);\n@@ -102,9 +113,7 @@ fn assert_output(source: &Path, expected_filename: &Path) {\n #[test]\n fn idempotence_tests() {\n     // Get all files in the tests/target directory.\n-    let files = fs::read_dir(\"tests/target\")\n-        .expect(\"Couldn't read target dir\")\n-        .map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/target\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n@@ -116,13 +125,10 @@ fn idempotence_tests() {\n // no warnings are emitted.\n #[test]\n fn self_tests() {\n-    let files = fs::read_dir(\"src/bin\")\n-        .expect(\"Couldn't read src dir\")\n-        .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n-        .map(get_path_string);\n-    // Hack because there's no `IntoIterator` impl for `[T; N]`.\n-    let files = files.chain(Some(PathBuf::from(\"src/lib.rs\")).into_iter());\n-    let files = files.chain(Some(PathBuf::from(\"build.rs\")).into_iter());\n+    let mut files = get_test_files(Path::new(\"src/bin\"), false);\n+    files.append(&mut get_test_files(Path::new(\"tests\"), false));\n+    files.push(PathBuf::from(\"src/lib.rs\"));\n+    files.push(PathBuf::from(\"build.rs\"));\n \n     let (reports, count, fails) = check_files(files);\n     let mut warnings = 0;\n@@ -197,15 +203,12 @@ fn format_lines_errors_are_reported() {\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n-where\n-    I: Iterator<Item = PathBuf>,\n-{\n+fn check_files(files: Vec<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n     let mut count = 0;\n     let mut fails = 0;\n     let mut reports = vec![];\n \n-    for file_name in files.filter(|f| f.extension().map_or(false, |f| f == \"rs\")) {\n+    for file_name in files {\n         debug!(\"Testing '{}'...\", file_name.display());\n \n         match idempotent_check(file_name) {"}]}