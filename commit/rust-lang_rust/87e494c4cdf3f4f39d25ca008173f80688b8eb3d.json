{"sha": "87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZTQ5NGM0Y2RmM2Y0ZjM5ZDI1Y2EwMDgxNzNmODA2ODhiOGViM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-22T03:54:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-22T03:54:50Z"}, "message": "Auto merge of #67330 - golddranks:split_inclusive, r=kodraus\n\nImplement split_inclusive for slice and str\n\n# Overview\n* Implement `split_inclusive` for `slice` and `str` and `split_inclusive_mut` for `slice`\n* `split_inclusive` is a substring/subslice splitting iterator that includes the matched part in the iterated substrings as a terminator.\n* EDIT: The behaviour has now changed, as per @KodrAus 's input, to the same semantics with the `split_terminator` function. I updated the examples below.\n* Two examples below:\n```Rust\n    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n    let split: Vec<&str> = data.split_inclusive('\\n').collect();\n    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\"]);\n```\n\n```Rust\n    let uppercase_separated = \"SheePSharKTurtlECaT\";\n    let mut first_char = true;\n    let split: Vec<&str> = uppercase_separated.split_inclusive(|c: char| {\n        let split = !first_char && c.is_uppercase();\n        first_char = split;\n        split\n    }).collect();\n    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\"]);\n```\n\n# Justification for the API\n* I was surprised to find that stdlib currently only has splitting iterators that leave out the matched part. In my experience, wanting to leave a substring terminator as a part of the substring is a pretty common usecase.\n* This API is strictly more expressive than the standard `split` API: it's easy to get the behaviour of `split` by mapping a subslicing operation that drops the terminator. On the other hand it's impossible to derive this behaviour from `split` without using hacky and brittle `unsafe` code. The normal way to achieve this functionality would be implementing the iterator yourself.\n* Especially when dealing with mutable slices, the only way currently is to use `split_at_mut`. This API provides an ergonomic alternative that plays to the strengths of the iterating capabilities of Rust. (Using `split_at_mut` iteratively used to be a real pain before NLL, fortunately the situation is a bit better now.)\n\n# Discussion items\n* <s>Does it make sense to mimic `split_terminator` in that the final empty slice would be left off in case of the string/slice ending with a terminator? It might do, as this use case is naturally geared towards considering the matching part as a terminator instead of a separator.</s>\n  * EDIT: The behaviour was changed to mimic `split_terminator`.\n* Does it make sense to have `split_inclusive_mut` for `&mut str`?", "tree": {"sha": "9fe72e67de8fbb771a2a7c7105397adf59ba70d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fe72e67de8fbb771a2a7c7105397adf59ba70d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "html_url": "https://github.com/rust-lang/rust/commit/87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d735ede6ebfbdf6355d2857912b169bcecef3307", "url": "https://api.github.com/repos/rust-lang/rust/commits/d735ede6ebfbdf6355d2857912b169bcecef3307", "html_url": "https://github.com/rust-lang/rust/commit/d735ede6ebfbdf6355d2857912b169bcecef3307"}, {"sha": "5c9dc57cb587761561e85574c821a6f9c0c7cc67", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9dc57cb587761561e85574c821a6f9c0c7cc67", "html_url": "https://github.com/rust-lang/rust/commit/5c9dc57cb587761561e85574c821a6f9c0c7cc67"}], "stats": {"total": 546, "additions": 545, "deletions": 1}, "files": [{"sha": "ea75f8903c3685fdd73203a18a810889c2e49615", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "patch": "@@ -12,6 +12,7 @@\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n #![feature(vec_remove_item)]\n+#![feature(split_inclusive)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "3d6b4bff5e06046fff2321769cda7c812bdb80ea", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "patch": "@@ -851,6 +851,86 @@ fn test_splitator() {\n     assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n }\n \n+#[test]\n+fn test_splitator_inclusive() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n+    assert_eq!(xs.split_inclusive(|_| true).collect::<Vec<&[i32]>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_inclusive_reverse() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive_reverse() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n #[test]\n fn test_splitnator() {\n     let xs = &[1, 2, 3, 4, 5];"}, {"sha": "b703df6f3cb7de00a6d1974b418482ae2919a676", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "patch": "@@ -1247,6 +1247,49 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_split_char_iterator_inclusive() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').collect();\n+    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\"]);\n+\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut first_char = true;\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = !first_char && c.is_uppercase();\n+            first_char = split;\n+            split\n+        })\n+        .collect();\n+    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\"]);\n+}\n+\n+#[test]\n+fn test_split_char_iterator_inclusive_rev() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').rev().collect();\n+    assert_eq!(split, [\"Little l\u00e4mb\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"\\n\"]);\n+\n+    // Note that the predicate is stateful and thus dependent\n+    // on the iteration order.\n+    // (A different predicate is needed for reverse iterator vs normal iterator.)\n+    // Not sure if anything can be done though.\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut term_char = true;\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = term_char && c.is_uppercase();\n+            term_char = c.is_uppercase();\n+            split\n+        })\n+        .rev()\n+        .collect();\n+    assert_eq!(split, [\"CaT\", \"TurtlE\", \"SharK\", \"SheeP\"]);\n+}\n+\n #[test]\n fn test_rsplit() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "7c65f595790189f38d2aa7cccb94ac2b9a380eba", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 271, "deletions": 1, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "patch": "@@ -1155,6 +1155,69 @@ impl<T> [T] {\n         SplitMut { v: self, pred, finished: false }\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`. The matched element is contained in the end of the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the last element of the slice is matched,\n+    /// that element will be considered the terminator of the preceding slice.\n+    /// That slice will be the last item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [3, 10, 40, 33];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[3]);\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive<F>(&self, pred: F) -> SplitInclusive<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        SplitInclusive { v: self, pred, finished: false }\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`. The matched element is contained in the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_inclusive_mut(|num| *num % 3 == 0) {\n+    ///     let terminator_idx = group.len()-1;\n+    ///     group[terminator_idx] = 1;\n+    /// }\n+    /// assert_eq!(v, [10, 40, 1, 20, 1, 1]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive_mut<F>(&mut self, pred: F) -> SplitInclusiveMut<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        SplitInclusiveMut { v: self, pred, finished: false }\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, starting at the end of the slice and working backwards.\n     /// The matched element is not contained in the subslices.\n@@ -3675,7 +3738,106 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n \n-/// An iterator over the subslices of the vector which are separated\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function. Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [slices].\n+///\n+/// [`split_inclusive`]: ../../std/primitive.slice.html#method.split_inclusive\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusive<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> Clone for SplitInclusive<'_, T, P>\n+where\n+    P: Clone + FnMut(&T) -> bool,\n+{\n+    fn clone(&self) -> Self {\n+        SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx =\n+            self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[..idx]);\n+        self.v = &self.v[idx..];\n+        ret\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        // The last index of self.v is already checked and found to match\n+        // by the last iteration, so we start searching a new match\n+        // one index to the left.\n+        let remainder = if self.v.len() == 0 { &[] } else { &self.v[..(self.v.len() - 1)] };\n+        let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[idx..]);\n+        self.v = &self.v[..idx];\n+        ret\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the mutable subslices of the vector which are separated\n /// by elements that match `pred`.\n ///\n /// This struct is created by the [`split_mut`] method on [slices].\n@@ -3789,6 +3951,114 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over the mutable subslices of the vector which are separated\n+/// by elements that match `pred`. Unlike `SplitMut`, it contains the matched\n+/// parts in the ends of the subslices.\n+///\n+/// This struct is created by the [`split_inclusive_mut`] method on [slices].\n+///\n+/// [`split_inclusive_mut`]: ../../std/primitive.slice.html#method.split_inclusive_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusiveMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusiveMut\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = tail;\n+        Some(head)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let idx_opt = if self.v.len() == 0 {\n+            None\n+        } else {\n+            // work around borrowck limitations\n+            let pred = &mut self.pred;\n+\n+            // The last index of self.v is already checked and found to match\n+            // by the last iteration, so we start searching a new match\n+            // one index to the left.\n+            let remainder = &self.v[..(self.v.len() - 1)];\n+            remainder.iter().rposition(|x| (*pred)(x))\n+        };\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = head;\n+        Some(tail)\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An iterator over subslices separated by elements that match a predicate\n /// function, starting from the end of the slice.\n ///"}, {"sha": "668b3ff3a367f7dfa5b28f54ce93c02b01827ccb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e494c4cdf3f4f39d25ca008173f80688b8eb3d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=87e494c4cdf3f4f39d25ca008173f80688b8eb3d", "patch": "@@ -1132,6 +1132,26 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n         }\n     }\n \n+    #[inline]\n+    fn next_inclusive(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.start is either the start of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..b);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str>\n     where\n@@ -1168,6 +1188,49 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n             },\n         }\n     }\n+\n+    #[inline]\n+    fn next_back_inclusive(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back_inclusive() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = b;\n+                Some(elt)\n+            },\n+            // SAFETY: self.start is either the start of the original string,\n+            // or start of a substring that represents the part of the string that hasn't\n+            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n+            // self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n }\n \n generate_pattern_iterators! {\n@@ -3213,6 +3276,42 @@ impl str {\n         })\n     }\n \n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern. Differs from the iterator produced by\n+    /// `split` in that `split_inclusive` leaves the matched part as the\n+    /// terminator of the substring.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n+    /// ```\n+    ///\n+    /// If the last element of the string is matched,\n+    /// that element will be considered the terminator of the preceding substring.\n+    /// That substring will be the last item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+    #[inline]\n+    pub fn split_inclusive<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitInclusive<'a, P> {\n+        SplitInclusive(SplitInternal {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_trailing_empty: false,\n+            finished: false,\n+        })\n+    }\n+\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n@@ -4406,6 +4505,19 @@ pub struct SplitAsciiWhitespace<'a> {\n     inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n+/// An iterator over the substrings of a string,\n+/// terminated by a substring matching to a predicate function\n+/// Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_inclusive`]: ../../std/primitive.str.html#method.split_inclusive\n+/// [`str`]: ../../std/primitive.str.html\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n+\n impl_fn_for_zst! {\n     #[derive(Clone)]\n     struct IsWhitespace impl Fn = |c: char| -> bool {\n@@ -4496,6 +4608,44 @@ impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n impl FusedIterator for SplitAsciiWhitespace<'_> {}\n \n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n+    fn clone(&self) -> Self {\n+        SplitInclusive(self.0.clone())\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n+    for SplitInclusive<'a, P>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// [`u16`]: ../../std/primitive.u16.html"}]}