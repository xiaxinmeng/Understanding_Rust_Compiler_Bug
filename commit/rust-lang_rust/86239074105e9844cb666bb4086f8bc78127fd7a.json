{"sha": "86239074105e9844cb666bb4086f8bc78127fd7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MjM5MDc0MTA1ZTk4NDRjYjY2NmJiNDA4NmY4YmM3ODEyN2ZkN2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-30T01:26:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-30T01:26:21Z"}, "message": "Rollup merge of #38622 - alexcrichton:read-lengths, r=sfackler\n\nstd: Clamp max read/write sizes on Unix\n\nTurns out that even though all these functions take a `size_t` they don't\nactually work that well with anything larger than the maximum value of\n`ssize_t`, the return value. Furthermore it looks like OSX rejects any\nread/write requests larger than `INT_MAX - 1`. Handle all these cases by just\nclamping the maximum size of a read/write on Unix to a platform-specific value.\n\nCloses #38590", "tree": {"sha": "641c80a90101819bd261f48105043cd8a076a4ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/641c80a90101819bd261f48105043cd8a076a4ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86239074105e9844cb666bb4086f8bc78127fd7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86239074105e9844cb666bb4086f8bc78127fd7a", "html_url": "https://github.com/rust-lang/rust/commit/86239074105e9844cb666bb4086f8bc78127fd7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86239074105e9844cb666bb4086f8bc78127fd7a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41b601ecdda41e86632dc1497c13a662de133888", "url": "https://api.github.com/repos/rust-lang/rust/commits/41b601ecdda41e86632dc1497c13a662de133888", "html_url": "https://github.com/rust-lang/rust/commit/41b601ecdda41e86632dc1497c13a662de133888"}, {"sha": "917a9affc114b68ef4985511bdee106429bbf2ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/917a9affc114b68ef4985511bdee106429bbf2ac", "html_url": "https://github.com/rust-lang/rust/commit/917a9affc114b68ef4985511bdee106429bbf2ac"}], "stats": {"total": 36, "additions": 24, "deletions": 12}, "files": [{"sha": "dcab30aad8385b9c9ed38929c3531007a1740b6d", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/86239074105e9844cb666bb4086f8bc78127fd7a/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86239074105e9844cb666bb4086f8bc78127fd7a/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=86239074105e9844cb666bb4086f8bc78127fd7a", "patch": "@@ -10,8 +10,9 @@\n \n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n+use cmp;\n use io::{self, Read};\n-use libc::{self, c_int, c_void};\n+use libc::{self, c_int, c_void, ssize_t};\n use mem;\n use sync::atomic::{AtomicBool, Ordering};\n use sys::cvt;\n@@ -23,6 +24,22 @@ pub struct FileDesc {\n     fd: c_int,\n }\n \n+fn max_len() -> usize {\n+    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n+    // with the man page quoting that if the count of bytes to read is\n+    // greater than `SSIZE_MAX` the result is \"unspecified\".\n+    //\n+    // On OSX, however, apparently the 64-bit libc is either buggy or\n+    // intentionally showing odd behavior by rejecting any read with a size\n+    // larger than or equal to INT_MAX. To handle both of these the read\n+    // size is capped on both platforms.\n+    if cfg!(target_os = \"macos\") {\n+        <c_int>::max_value() as usize - 1\n+    } else {\n+        <ssize_t>::max_value() as usize\n+    }\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd: fd }\n@@ -41,7 +58,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::read(self.fd,\n                        buf.as_mut_ptr() as *mut c_void,\n-                       buf.len())\n+                       cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -69,7 +86,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pread64(self.fd,\n                         buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n+                        cmp::min(buf.len(), max_len()),\n                         offset as i64)\n                 .map(|n| n as usize)\n         }\n@@ -79,7 +96,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::write(self.fd,\n                         buf.as_ptr() as *const c_void,\n-                        buf.len())\n+                        cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -102,7 +119,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pwrite64(self.fd,\n                          buf.as_ptr() as *const c_void,\n-                         buf.len(),\n+                         cmp::min(buf.len(), max_len()),\n                          offset as i64)\n                 .map(|n| n as usize)\n         }"}, {"sha": "fdb9483fe1c8b0ed0aab3d708b194460591486ca", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86239074105e9844cb666bb4086f8bc78127fd7a/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86239074105e9844cb666bb4086f8bc78127fd7a/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=86239074105e9844cb666bb4086f8bc78127fd7a", "patch": "@@ -19,7 +19,6 @@ use ptr;\n use sys::c;\n use sys::cvt;\n use sys_common::io::read_to_end_uninitialized;\n-use u32;\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n ///\n@@ -83,9 +82,7 @@ impl RawHandle {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n-        // ReadFile takes a DWORD (u32) for the length so it only supports\n-        // reading u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n                         len, &mut read, ptr::null_mut())\n@@ -181,9 +178,7 @@ impl RawHandle {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n-        // WriteFile takes a DWORD (u32) for the length so it only supports\n-        // writing u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         cvt(unsafe {\n             c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n                          len, &mut amt, ptr::null_mut())"}]}