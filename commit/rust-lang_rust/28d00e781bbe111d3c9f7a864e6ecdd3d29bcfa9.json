{"sha": "28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZDAwZTc4MWJiZTExMWQzYzlmN2E4NjRlNmVjZGQzZDI5YmNmYTk=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-14T14:27:59Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:50Z"}, "message": "Remove cleanup scope from FunctionContext", "tree": {"sha": "32f8091576765783cdbbf11e05123639ad490dff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32f8091576765783cdbbf11e05123639ad490dff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "html_url": "https://github.com/rust-lang/rust/commit/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51dfba1185104a64157235dc771953c21d89a284", "url": "https://api.github.com/repos/rust-lang/rust/commits/51dfba1185104a64157235dc771953c21d89a284", "html_url": "https://github.com/rust-lang/rust/commit/51dfba1185104a64157235dc771953c21d89a284"}], "stats": {"total": 252, "additions": 154, "deletions": 98}, "files": [{"sha": "3cbc3935cfc7266cbbb28a2f89d920fe2130fc2b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "patch": "@@ -765,7 +765,6 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             funclet_arena: TypedArena::new(),\n             ccx: ccx,\n             debug_context: debug_context,\n-            cleanup_scope: RefCell::new(None),\n         }\n     }\n "}, {"sha": "1a4afb4b02e6b317007ec2eea9f8d8592a315f2f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 64, "deletions": 17, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "patch": "@@ -27,6 +27,7 @@ use base::*;\n use common::{\n     self, BlockAndBuilder, CrateContext, FunctionContext, SharedCrateContext\n };\n+use cleanup::CleanupScope;\n use consts;\n use declare;\n use value::Value;\n@@ -389,10 +390,10 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n-\n-    let bcx = callee.call(bcx, &llargs[self_idx..], dest, None).0;\n-    fcx.pop_and_trans_custom_cleanup_scope(&bcx, self_scope);\n+    let mut self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n+    let bcx = trans_call_fn_once_adapter_shim(\n+        bcx, callee, &llargs[self_idx..], dest, &mut self_scope);\n+    fcx.trans_scope(&bcx, self_scope);\n     fcx.finish(&bcx);\n \n     ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n@@ -685,23 +686,69 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     };\n \n     let _icx = push_ctxt(\"invoke_\");\n-    let (llret, bcx) = if bcx.fcx().needs_invoke(lpad.is_some()) {\n-        debug!(\"invoking {:?} at {:?}\", Value(llfn), bcx.llbb());\n-        for &llarg in &llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n+    let llret = bcx.call(llfn, &llargs[..], lpad);\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    // If the function we just called does not use an outpointer,\n+    // store the result into the rust outpointer. Cast the outpointer\n+    // type to match because some ABIs will use a different type than\n+    // the Rust type. e.g., a {u32,u32} struct could be returned as\n+    // u64.\n+    if !fn_ty.ret.is_indirect() {\n+        if let Some(llretslot) = opt_llretslot {\n+            fn_ty.ret.store(&bcx, llret, llretslot);\n+        }\n+    }\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n+\n+    (bcx, llret)\n+}\n+\n+// This is a cleaned up version of trans_call_inner.\n+fn trans_call_fn_once_adapter_shim<'a, 'blk, 'tcx>(\n+    bcx: BlockAndBuilder<'blk, 'tcx>,\n+    callee: Callee<'tcx>,\n+    args: &[ValueRef],\n+    opt_llretslot: Option<ValueRef>,\n+    cleanup_scope: &mut Option<CleanupScope<'tcx>>,\n+) -> BlockAndBuilder<'blk, 'tcx> {\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n+\n+    // If there no destination, return must be direct, with no cast.\n+    if opt_llretslot.is_none() {\n+        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n+    }\n+\n+    let mut llargs = Vec::new();\n+\n+    if fn_ty.ret.is_indirect() {\n+        let mut llretslot = opt_llretslot.unwrap();\n+        if let Some(ty) = fn_ty.ret.cast {\n+            llretslot = bcx.pointercast(llretslot, ty.ptr_to());\n         }\n+        llargs.push(llretslot);\n+    }\n+\n+    llargs.extend_from_slice(args);\n+\n+    let llfn = match callee.data {\n+        Fn(f) => f,\n+        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n+    };\n+\n+    let _icx = push_ctxt(\"invoke_\");\n+    let (llret, bcx) = if cleanup_scope.is_some() && !bcx.sess().no_landing_pads() {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad();\n+        let landing_pad = bcx.fcx().get_landing_pad(cleanup_scope);\n \n-        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, lpad);\n+        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         (llresult, normal_bcx)\n     } else {\n-        debug!(\"calling {:?} at {:?}\", Value(llfn), bcx.llbb());\n-        for &llarg in &llargs {\n-            debug!(\"arg: {:?}\", Value(llarg));\n-        }\n-\n-        let llresult = bcx.call(llfn, &llargs[..], lpad);\n+        let llresult = bcx.call(llfn, &llargs[..], None);\n         (llresult, bcx)\n     };\n     fn_ty.apply_attrs_callsite(llret);\n@@ -721,5 +768,5 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         bcx.unreachable();\n     }\n \n-    (bcx, llret)\n+    bcx\n }"}, {"sha": "d9e8b795cb16d05ffb8921cbc2901bea041eeaaa", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 30, "deletions": 71, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "patch": "@@ -149,24 +149,19 @@ struct CachedEarlyExit {\n }\n \n impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n-    /// Removes the top cleanup scope from the stack, which must be a temporary scope, and\n-    /// generates the code to do its cleanups for normal exit.\n-    pub fn pop_and_trans_custom_cleanup_scope(&self,\n-                                              bcx: &BlockAndBuilder<'blk, 'tcx>,\n-                                              custom_scope: Option<()>) {\n-        debug!(\"pop_and_trans_custom_cleanup_scope({:?})\", custom_scope);\n-\n-        if custom_scope.is_none() {\n-            return;\n+    pub fn trans_scope(\n+        &self,\n+        bcx: &BlockAndBuilder<'blk, 'tcx>,\n+        custom_scope: Option<CleanupScope<'tcx>>\n+    ) {\n+        if let Some(scope) = custom_scope {\n+            scope.cleanup.trans(bcx.funclet(), &bcx);\n         }\n-\n-        let scope = self.pop_scope();\n-        scope.cleanup.trans(bcx.funclet(), &bcx);\n     }\n \n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of\n     /// `ty`\n-    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<()> {\n+    pub fn schedule_drop_mem(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<CleanupScope<'tcx>> {\n         if !self.type_needs_drop(ty) { return None; }\n         let drop = DropValue {\n             val: val,\n@@ -176,15 +171,16 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n \n         debug!(\"schedule_drop_mem(val={:?}, ty={:?}) skip_dtor={}\", Value(val), ty, drop.skip_dtor);\n \n-        Some(self.set_scope(CleanupScope::new(drop)))\n+        Some(CleanupScope::new(drop))\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>) -> Option<()> {\n+    pub fn schedule_drop_adt_contents(&self, val: ValueRef, ty: Ty<'tcx>)\n+        -> Option<CleanupScope<'tcx>> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.type_needs_drop(ty) { return None; }\n@@ -200,16 +196,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n                ty,\n                drop.skip_dtor);\n \n-        Some(self.set_scope(CleanupScope::new(drop)))\n-    }\n-\n-    /// Returns true if there are pending cleanups that should execute on panic.\n-    pub fn needs_invoke(&self, lpad_present: bool) -> bool {\n-        if self.ccx.sess().no_landing_pads() || lpad_present {\n-            false\n-        } else {\n-            self.has_scope()\n-        }\n+        Some(CleanupScope::new(drop))\n     }\n \n     /// Creates a landing pad for the top scope, if one does not exist. The\n@@ -220,22 +207,21 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     ///\n     /// (The cleanups and resume instruction are created by\n     /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n-    pub fn get_landing_pad(&'blk self) -> BasicBlockRef {\n-        let mut pad_bcx;\n+    pub fn get_landing_pad(&'blk self, scope: &mut Option<CleanupScope<'tcx>>) -> BasicBlockRef {\n+        // TODO: Factor out and take a CleanupScope.\n+        assert!(scope.is_some());\n \n         debug!(\"get_landing_pad\");\n \n         // Check if a landing pad block exists; if not, create one.\n-        {\n-            let mut last_scope = self.cleanup_scope.borrow_mut();\n-            let mut last_scope = last_scope.as_mut().unwrap();\n-            match last_scope.cached_landing_pad {\n-                Some(llbb) => return llbb,\n-                None => {\n-                    let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.build_new_block(&name[..]);\n-                    last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n-                }\n+        let mut scope = scope.as_mut().unwrap();\n+        let mut pad_bcx = match scope.cached_landing_pad {\n+            Some(llbb) => return llbb,\n+            None => {\n+                let name = scope.block_name(\"unwind\");\n+                let pad_bcx = self.build_new_block(&name[..]);\n+                scope.cached_landing_pad = Some(pad_bcx.llbb());\n+                pad_bcx\n             }\n         };\n \n@@ -278,30 +264,12 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         };\n \n         // Generate the cleanup block and branch to it.\n-        let cleanup_llbb = self.trans_cleanups_to_exit_scope(val);\n+        let cleanup_llbb = self.trans_cleanups_to_exit_scope(val, scope);\n         val.branch(&mut pad_bcx, cleanup_llbb);\n \n         return pad_bcx.llbb();\n     }\n \n-    fn has_scope(&self) -> bool {\n-        self.cleanup_scope.borrow().is_some()\n-    }\n-\n-    fn set_scope(&self, scope: CleanupScope<'tcx>) {\n-        assert!(self.cleanup_scope.borrow().is_none());\n-        *self.cleanup_scope.borrow_mut() = Some(scope);\n-    }\n-\n-    fn pop_scope(&self) -> CleanupScope<'tcx> {\n-        debug!(\"took cleanup scope {}\", self.top_scope(|s| s.block_name(\"\")));\n-        self.cleanup_scope.borrow_mut().take().unwrap()\n-    }\n-\n-    fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'tcx>) -> R {\n-        f(self.cleanup_scope.borrow().as_ref().unwrap())\n-    }\n-\n     fn generate_resume_block(&self, label: UnwindKind) -> BasicBlockRef {\n         // Generate a block that will resume unwinding to the calling function\n         let bcx = self.build_new_block(\"resume\");\n@@ -328,18 +296,12 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n     /// break, continue, or unwind. This function will generate all cleanups\n     /// between the top of the stack and the exit `label` and return a basic\n     /// block that the caller can branch to.\n-    fn trans_cleanups_to_exit_scope(&'blk self, label: UnwindKind) -> BasicBlockRef {\n-        debug!(\"trans_cleanups_to_exit_scope label={:?} has_scope={}\", label, self.has_scope());\n-\n-        // If there is no current scope, then there are no cleanups to run, so we should\n-        // simply generate a resume block which will branch to the label.\n-        if !self.has_scope() {\n-            debug!(\"trans_cleanups_to_exit_scope: returning new block scope\");\n-            return self.generate_resume_block(label);\n-        }\n-\n-        // Pop off the scope, since we may be generating unwinding code for it.\n-        let mut scope = self.pop_scope();\n+    fn trans_cleanups_to_exit_scope(\n+        &'blk self,\n+        label: UnwindKind,\n+        scope: &mut CleanupScope<'tcx>\n+    ) -> BasicBlockRef {\n+        debug!(\"trans_cleanups_to_exit_scope label={:?}`\", label);\n         let cached_exit = scope.cached_early_exit(label);\n \n         // Check if we have already cached the unwinding of this\n@@ -361,9 +323,6 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         // FIXME: Can this get called more than once per scope? If not, no need to cache.\n         scope.add_cached_early_exit(label, cleanup.llbb());\n \n-        // Put the scope back\n-        self.set_scope(scope);\n-\n         debug!(\"trans_cleanups_to_exit_scope: llbb={:?}\", cleanup.llbb());\n \n         cleanup.llbb()"}, {"sha": "8637bb322ca16ef6cc7369153fe018b58e9fc6b7", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "patch": "@@ -28,7 +28,6 @@ use abi::{Abi, FnType};\n use base;\n use builder::Builder;\n use callee::Callee;\n-use cleanup;\n use consts;\n use debuginfo;\n use declare;\n@@ -48,7 +47,7 @@ use std::borrow::Cow;\n use std::iter;\n use std::ops::Deref;\n use std::ffi::CString;\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, Ref};\n \n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n@@ -315,9 +314,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // Used and maintained by the debuginfo module.\n     pub debug_context: debuginfo::FunctionDebugContext,\n-\n-    // Cleanup scopes.\n-    pub cleanup_scope: RefCell<Option<cleanup::CleanupScope<'tcx>>>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {"}, {"sha": "dc3f75d52b98f2aa2d86dbafb2f6295eb9c1c3e8", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=28d00e781bbe111d3c9f7a864e6ecdd3d29bcfa9", "patch": "@@ -22,7 +22,9 @@ use rustc::traits;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use adt;\n use base::*;\n-use callee::{Callee};\n+use callee::{Callee, CalleeData};\n+use cleanup::CleanupScope;\n+use meth;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -241,7 +243,7 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     // might well consider changing below to more direct code.\n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    let contents_scope = if !shallow_drop {\n+    let mut contents_scope = if !shallow_drop {\n         bcx.fcx().schedule_drop_adt_contents(v0, t)\n     } else {\n         None\n@@ -269,8 +271,61 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n         _ => bug!(\"dtor for {:?} is not an impl???\", t)\n     };\n     let dtor_did = def.destructor().unwrap();\n-    let bcx = Callee::def(bcx.ccx(), dtor_did, vtbl.substs).call(bcx, args, None, None).0;\n-    bcx.fcx().pop_and_trans_custom_cleanup_scope(&bcx, contents_scope);\n+    let callee = Callee::def(bcx.ccx(), dtor_did, vtbl.substs);\n+    let bcx = trans_call_custom_dtor(bcx, callee, args, &mut contents_scope);\n+    bcx.fcx().trans_scope(&bcx, contents_scope);\n+    bcx\n+}\n+\n+// Inlined and simplified version of callee::trans_call_inner\n+fn trans_call_custom_dtor<'a, 'blk, 'tcx>(\n+    bcx: BlockAndBuilder<'blk, 'tcx>,\n+    callee: Callee<'tcx>,\n+    args: &[ValueRef],\n+    cleanup_scope: &mut Option<CleanupScope<'tcx>>,\n+) -> BlockAndBuilder<'blk, 'tcx> {\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n+\n+    // Return must be direct, with no cast.\n+    assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n+\n+    let mut llargs = Vec::new();\n+\n+    let llfn = match callee.data {\n+        CalleeData::Virtual(idx) => {\n+            llargs.push(args[0]);\n+\n+            let fn_ptr = meth::get_virtual_method(&bcx, args[1], idx);\n+            let llty = fn_ty.llvm_type(&bcx.ccx()).ptr_to();\n+            let llfn = bcx.pointercast(fn_ptr, llty);\n+            llargs.extend_from_slice(&args[2..]);\n+            llfn\n+        }\n+        CalleeData::Fn(f) => {\n+            llargs.extend_from_slice(args);\n+            f\n+        }\n+        _ => bug!(\"Expected virtual or fn pointer callee, found {:?}\", callee)\n+    };\n+\n+    let _icx = push_ctxt(\"invoke_\");\n+    let (llret, bcx) = if cleanup_scope.is_some() && !bcx.sess().no_landing_pads() {\n+        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        let landing_pad = bcx.fcx().get_landing_pad(cleanup_scope);\n+\n+        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n+        (llresult, normal_bcx)\n+    } else {\n+        let llresult = bcx.call(llfn, &llargs[..], None);\n+        (llresult, bcx)\n+    };\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n+\n     bcx\n }\n "}]}