{"sha": "3232fd5179f2e36dee69955ba8aae0463b142e67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMzJmZDUxNzlmMmUzNmRlZTY5OTU1YmE4YWFlMDQ2M2IxNDJlNjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-01T20:16:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-01T20:16:25Z"}, "message": "Merge #4220 #4240\n\n4220: Introduce LowerCtx r=matklad a=edwin0cheng\n\nThis PR introduces `LowerCtx` for path lowering. \r\n\r\nAfter this PR, there are only 2 places remains for using deprecated `Path::from_ast`, which is related to `AstTransform` I am not familiar. I would like to change these in another PR by others ;)\r\n\r\nrelated disscusiion:  https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Path.3A.3Afrom_src\r\n\r\nAnd also fixed part of https://github.com/rust-analyzer/rust-analyzer/issues/4176#issuecomment-620672930\n\n4240: Bump deps r=matklad a=lnicola\n\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "5267198bbe280983f82e0cd892562df0fc297dc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5267198bbe280983f82e0cd892562df0fc297dc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3232fd5179f2e36dee69955ba8aae0463b142e67", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJerIOZCRBK7hj4Ov3rIwAAdHIIADWOQlivpVJq9mWyn/EwwTbX\n8qisyvvqU58AJxrR7IVpcoOJSImqTxwN3pTvjpkhgH4amYdWAdiKEMrivzKGir+l\n3jXshFVQShT5vieoooXA805oNEsb3k2M50TGK+YGbB1B+zQDolVE9whn6BBd8Ar4\n60lDEmtGNGXU7+HP+NH1DWHiTEaB+IEluJXDCVwoMMeRTXzgDUrtn1XRDwVt/hHX\nEb37cmuDuIa/vWBZxVRzRXncftiBE1eCwTxAM6HLJ+hPCuZt7Xxvy+1sLNoX2Eq+\no94OGD57ifsAybazfRQfAZtXhNg6g47P7OMuM7BtVGL4k1KU/1JjvnhBpJoZIn0=\n=p0qX\n-----END PGP SIGNATURE-----\n", "payload": "tree 5267198bbe280983f82e0cd892562df0fc297dc7\nparent d79a699f8e88379bd9c608cccea8afebc6c0d07b\nparent 44f5e2048ce00b0b417be95c16bae9a9ced1a5e8\nparent 1e20467c3a62f0b8a65605938a2ddb7babcfd8bb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588364185 +0000\ncommitter GitHub <noreply@github.com> 1588364185 +0000\n\nMerge #4220 #4240\n\n4220: Introduce LowerCtx r=matklad a=edwin0cheng\n\nThis PR introduces `LowerCtx` for path lowering. \r\n\r\nAfter this PR, there are only 2 places remains for using deprecated `Path::from_ast`, which is related to `AstTransform` I am not familiar. I would like to change these in another PR by others ;)\r\n\r\nrelated disscusiion:  https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Path.3A.3Afrom_src\r\n\r\nAnd also fixed part of https://github.com/rust-analyzer/rust-analyzer/issues/4176#issuecomment-620672930\n\n4240: Bump deps r=matklad a=lnicola\n\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3232fd5179f2e36dee69955ba8aae0463b142e67", "html_url": "https://github.com/rust-lang/rust/commit/3232fd5179f2e36dee69955ba8aae0463b142e67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3232fd5179f2e36dee69955ba8aae0463b142e67/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d79a699f8e88379bd9c608cccea8afebc6c0d07b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d79a699f8e88379bd9c608cccea8afebc6c0d07b", "html_url": "https://github.com/rust-lang/rust/commit/d79a699f8e88379bd9c608cccea8afebc6c0d07b"}, {"sha": "44f5e2048ce00b0b417be95c16bae9a9ced1a5e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f5e2048ce00b0b417be95c16bae9a9ced1a5e8", "html_url": "https://github.com/rust-lang/rust/commit/44f5e2048ce00b0b417be95c16bae9a9ced1a5e8"}, {"sha": "1e20467c3a62f0b8a65605938a2ddb7babcfd8bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e20467c3a62f0b8a65605938a2ddb7babcfd8bb", "html_url": "https://github.com/rust-lang/rust/commit/1e20467c3a62f0b8a65605938a2ddb7babcfd8bb"}], "stats": {"total": 420, "additions": 293, "deletions": 127}, "files": [{"sha": "85ea4f178f58901201451963d665050ca008a7b2", "filename": "Cargo.lock", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -58,9 +58,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace-sys\"\n-version = \"0.1.36\"\n+version = \"0.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78848718ee1255a2485d1309ad9cdecfc2e7d0362dd11c6829364c6b35ae1bc7\"\n+checksum = \"18fbebbe1c9d1f383a9cc7e8ccdb471b91c8d024ee9c2ca5b5346121fe8b4399\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -170,7 +170,7 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-macros\",\n  \"chalk-rust-ir\",\n- \"ena\",\n+ \"ena 0.13.1\",\n  \"itertools\",\n  \"petgraph\",\n  \"rustc-hash\",\n@@ -199,14 +199,15 @@ dependencies = [\n \n [[package]]\n name = \"console\"\n-version = \"0.10.0\"\n+version = \"0.10.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6728a28023f207181b193262711102bfbaf47cc9d13bc71d0736607ef8efe88c\"\n+checksum = \"2586208b33573b7f76ccfbe5adb076394c88deaf81b84d7213969805b0a952a7\"\n dependencies = [\n  \"clicolors-control\",\n  \"encode_unicode\",\n  \"lazy_static\",\n  \"libc\",\n+ \"terminal_size\",\n  \"termios\",\n  \"winapi 0.3.8\",\n ]\n@@ -315,6 +316,15 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"ena\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+dependencies = [\n+ \"log\",\n+]\n+\n [[package]]\n name = \"encode_unicode\"\n version = \"0.3.6\"\n@@ -381,9 +391,9 @@ dependencies = [\n \n [[package]]\n name = \"fst\"\n-version = \"0.4.1\"\n+version = \"0.4.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4eaf9ea41cc964d742f7fc7861db75d2d6e83a3ce0d897d5c6f8b621f015ddc8\"\n+checksum = \"81f9cac32c1741cdf6b66be7dcf0d9c7f25ccf12f8aa84c16cfa31f9f14513b3\"\n \n [[package]]\n name = \"fuchsia-zircon\"\n@@ -447,9 +457,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.11\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a0d737e0f947a1864e93d33fdef4af8445a00d1ed8dc0c8ddb73139ea6abf15\"\n+checksum = \"61565ff7aaace3525556587bd2dc31d4a07071957be715e63ce7b1eccf51a8f4\"\n dependencies = [\n  \"libc\",\n ]\n@@ -814,19 +824,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab4fb1930692d1b6a9cfabdde3d06ea0a7d186518e2f4d67660d8970e2fa647a\"\n+checksum = \"a3c897744f63f34f7ae3a024d9162bb5001f4ad661dd24bea0dc9f075d2de1c6\"\n dependencies = [\n  \"paste-impl\",\n  \"proc-macro-hack\",\n ]\n \n [[package]]\n name = \"paste-impl\"\n-version = \"0.1.10\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a62486e111e571b1e93b710b61e8f493c0013be39629b714cb166bdb06aa5a8a\"\n+checksum = \"66fd6f92e3594f2dd7b3fc23e42d82e292f7bcda6d8e5dcd167072327234ab89\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"proc-macro2\",\n@@ -885,9 +895,9 @@ dependencies = [\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.3\"\n+version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2bdc6c187c65bca4260c9011c9e3132efe4909da44726bad24cf7572ae338d7f\"\n+checksum = \"4c1f4b0efa5fc5e8ceb705136bfee52cfdb6a4e3509f770b478cd6ed434232a7\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -1023,7 +1033,7 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-rust-ir\",\n  \"chalk-solve\",\n- \"ena\",\n+ \"ena 0.14.0\",\n  \"insta\",\n  \"itertools\",\n  \"log\",\n@@ -1374,9 +1384,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"652.0.0\"\n+version = \"656.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a6a43c4d0889218c5e2ae68ffea239f303fc05ab1078c73f74e63feb87f7889\"\n+checksum = \"9cbba98ec46e96a4663197dfa8c0378752de2006e314e5400c0ca74929d6692f\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1486,18 +1496,18 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.104\"\n+version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"414115f25f818d7dfccec8ee535d76949ae78584fc4f79a6f45a904bf8ab4449\"\n+checksum = \"36df6ac6412072f67cf767ebbde4133a5b2e88e76dc6187fa7104cd16f783399\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.104\"\n+version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"128f9e303a5a29922045a830221b8f78ec74a5f544944f3d5984f8ec3895ef64\"\n+checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1506,9 +1516,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.51\"\n+version = \"1.0.52\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"da07b57ee2623368351e9a0488bb0b261322a15a6e0ae53e243cbdc0f4208da9\"\n+checksum = \"a7894c8ed05b7a3a279aeb79025fdec1d3158080b75b98a08faf2806bb799edd\"\n dependencies = [\n  \"itoa\",\n  \"ryu\",\n@@ -1606,6 +1616,16 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"terminal_size\"\n+version = \"0.1.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8038f95fc7a6f351163f4b964af631bd26c9e828f7db085f2a84aca56f70d13b\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"termios\"\n version = \"0.3.2\""}, {"sha": "9ac65ab397fa0eb005bcdb855228d081e0c060d1", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -85,6 +85,7 @@ impl<'a> SubstituteTypeParams<'a> {\n             ast::TypeRef::PathType(path_type) => path_type.path()?,\n             _ => return None,\n         };\n+        // FIXME: use `hir::Path::from_src` instead.\n         let path = hir::Path::from_ast(path)?;\n         let resolution = self.source_scope.resolve_hir_path(&path)?;\n         match resolution {\n@@ -128,6 +129,7 @@ impl<'a> QualifyPaths<'a> {\n             // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n             return None;\n         }\n+        // FIXME: use `hir::Path::from_src` instead.\n         let hir_path = hir::Path::from_ast(p.clone());\n         let resolution = self.source_scope.resolve_hir_path(&hir_path?)?;\n         match resolution {"}, {"sha": "918e8dd8dae5ce36abc80e41979c66101561af3b", "filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn replace_qualified_name_with_use(ctx: AssistCtx) -> Option<Assist>\n         return None;\n     }\n \n-    let hir_path = hir::Path::from_ast(path.clone())?;\n+    let hir_path = ctx.sema.lower_path(&path)?;\n     let segments = collect_hir_path_segments(&hir_path)?;\n     if segments.len() < 2 {\n         return None;"}, {"sha": "c5df4ac24da474e969eac53c332326164a49b214", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -70,6 +70,7 @@ pub use hir_def::{\n     type_ref::Mutability,\n };\n pub use hir_expand::{\n-    name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, Origin,\n+    hygiene::Hygiene, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId,\n+    MacroFile, Origin,\n };\n pub use hir_ty::{display::HirDisplay, CallableDef};"}, {"sha": "515e5eb1713beff9ca63217f5407f8b04d565481", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -8,7 +8,7 @@ use hir_def::{\n     resolver::{self, HasResolver, Resolver},\n     AsMacroCall, TraitId,\n };\n-use hir_expand::ExpansionInfo;\n+use hir_expand::{hygiene::Hygiene, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n use ra_db::{FileId, FileRange};\n@@ -246,6 +246,11 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.analyze(path.syntax()).resolve_path(self.db, path)\n     }\n \n+    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n+        let src = self.find_file(path.syntax().clone());\n+        Path::from_src(path.clone(), &Hygiene::new(self.db.upcast(), src.file_id.into()))\n+    }\n+\n     pub fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }"}, {"sha": "c63d1b8473ef7dd931c05eafdb82f0f812446284", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -224,7 +224,8 @@ impl SourceAnalyzer {\n             }\n         }\n         // This must be a normal source file rather than macro file.\n-        let hir_path = crate::Path::from_ast(path.clone())?;\n+        let hir_path =\n+            crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n "}, {"sha": "8eef518283536b4a65d21bf1b78dfa7677bf57ad", "filename": "crates/ra_hir_def/src/adt.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fadt.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -12,9 +12,15 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, VisibilityOwner};\n \n use crate::{\n-    body::CfgExpander, db::DefDatabase, src::HasChildSource, src::HasSource, trace::Trace,\n-    type_ref::TypeRef, visibility::RawVisibility, EnumId, HasModule, LocalEnumVariantId,\n-    LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+    body::{CfgExpander, LowerCtx},\n+    db::DefDatabase,\n+    src::HasChildSource,\n+    src::HasSource,\n+    trace::Trace,\n+    type_ref::TypeRef,\n+    visibility::RawVisibility,\n+    EnumId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId,\n+    VariantId,\n };\n \n /// Note that we use `StructData` for unions as well!\n@@ -198,6 +204,8 @@ fn lower_struct(\n     trace: &mut Trace<FieldData, Either<ast::TupleFieldDef, ast::RecordFieldDef>>,\n     ast: &InFile<ast::StructKind>,\n ) -> StructKind {\n+    let ctx = LowerCtx::new(db, ast.file_id);\n+\n     match &ast.value {\n         ast::StructKind::Tuple(fl) => {\n             for (i, fd) in fl.fields().enumerate() {\n@@ -210,7 +218,7 @@ fn lower_struct(\n                     || Either::Left(fd.clone()),\n                     || FieldData {\n                         name: Name::new_tuple_field(i),\n-                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.type_ref()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );\n@@ -228,7 +236,7 @@ fn lower_struct(\n                     || Either::Right(fd.clone()),\n                     || FieldData {\n                         name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n-                        type_ref: TypeRef::from_ast_opt(fd.ascribed_type()),\n+                        type_ref: TypeRef::from_ast_opt(&ctx, fd.ascribed_type()),\n                         visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n                     },\n                 );"}, {"sha": "4edaad9600afce6223a2f6b2eb42a227325d5d94", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -15,6 +15,8 @@ use ra_prof::profile;\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n+pub(crate) use lower::LowerCtx;\n+\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,"}, {"sha": "e9dd65b0a436894f5b74b16c794ed102b32abafc", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -3,8 +3,9 @@\n \n use either::Either;\n use hir_expand::{\n+    hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    MacroDefId, MacroDefKind,\n+    HirFileId, MacroDefId, MacroDefKind,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -26,7 +27,7 @@ use crate::{\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n-    path::GenericArgs,\n+    path::{GenericArgs, Path},\n     type_ref::{Mutability, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n     StaticLoc, StructLoc, TraitLoc, TypeAliasLoc, UnionLoc,\n@@ -35,17 +36,37 @@ use crate::{\n use super::{ExprSource, PatSource};\n use ast::AstChildren;\n \n+pub(crate) struct LowerCtx {\n+    hygiene: Hygiene,\n+}\n+\n+impl LowerCtx {\n+    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n+    }\n+    pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n+        LowerCtx { hygiene: hygiene.clone() }\n+    }\n+\n+    pub fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, &self.hygiene)\n+    }\n+}\n+\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n+    let ctx = LowerCtx::new(db, expander.current_file_id.clone());\n+\n     ExprCollector {\n         db,\n         def,\n         expander,\n+        ctx,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -62,7 +83,7 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     def: DefWithBodyId,\n     expander: Expander,\n-\n+    ctx: LowerCtx,\n     body: Body,\n     source_map: BodySourceMap,\n }\n@@ -237,7 +258,8 @@ impl ExprCollector<'_> {\n                     Vec::new()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n-                let generic_args = e.type_arg_list().and_then(GenericArgs::from_ast);\n+                let generic_args =\n+                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx, it));\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -343,7 +365,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let type_ref = TypeRef::from_ast_opt(e.type_ref());\n+                let type_ref = TypeRef::from_ast_opt(&self.ctx, e.type_ref());\n                 self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n             }\n             ast::Expr::RefExpr(e) => {\n@@ -365,12 +387,16 @@ impl ExprCollector<'_> {\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n                         let pat = self.collect_pat_opt(param.pat());\n-                        let type_ref = param.ascribed_type().map(TypeRef::from_ast);\n+                        let type_ref =\n+                            param.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n-                let ret_type = e.ret_type().and_then(|r| r.type_ref()).map(TypeRef::from_ast);\n+                let ret_type = e\n+                    .ret_type()\n+                    .and_then(|r| r.type_ref())\n+                    .map(|it| TypeRef::from_ast(&self.ctx, it));\n                 let body = self.collect_expr_opt(e.body());\n                 self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr)\n             }\n@@ -476,7 +502,7 @@ impl ExprCollector<'_> {\n             .map(|s| match s {\n                 ast::Stmt::LetStmt(stmt) => {\n                     let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ascribed_type().map(TypeRef::from_ast);\n+                    let type_ref = stmt.ascribed_type().map(|it| TypeRef::from_ast(&self.ctx, it));\n                     let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n                     Statement::Let { pat, type_ref, initializer }\n                 }"}, {"sha": "7a2067e49cb7fef0f783d6e3c1ce4c6245c27722", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -15,6 +15,7 @@ use ra_syntax::ast::{\n \n use crate::{\n     attr::Attrs,\n+    body::LowerCtx,\n     db::DefDatabase,\n     path::{path, AssociatedTypeBinding, GenericArgs, Path},\n     src::HasSource,\n@@ -40,13 +41,14 @@ impl FunctionData {\n     pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n         let src = loc.source(db);\n+        let ctx = LowerCtx::new(db, src.file_id);\n         let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n         let mut params = Vec::new();\n         let mut has_self_param = false;\n         if let Some(param_list) = src.value.param_list() {\n             if let Some(self_param) = param_list.self_param() {\n                 let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(type_ref)\n+                    TypeRef::from_ast(&ctx, type_ref)\n                 } else {\n                     let self_type = TypeRef::Path(name![Self].into());\n                     match self_param.kind() {\n@@ -63,14 +65,14 @@ impl FunctionData {\n                 has_self_param = true;\n             }\n             for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+                let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n                 params.push(type_ref);\n             }\n         }\n         let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n \n         let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(type_ref)\n+            TypeRef::from_ast(&ctx, type_ref)\n         } else {\n             TypeRef::unit()\n         };\n@@ -122,15 +124,16 @@ impl TypeAliasData {\n         let loc = typ.lookup(db);\n         let node = loc.source(db);\n         let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let type_ref = node.value.type_ref().map(TypeRef::from_ast);\n+        let lower_ctx = LowerCtx::new(db, node.file_id);\n+        let type_ref = node.value.type_ref().map(|it| TypeRef::from_ast(&lower_ctx, it));\n         let vis_default = RawVisibility::default_for_container(loc.container);\n         let visibility = RawVisibility::from_ast_with_default(\n             db,\n             vis_default,\n             node.as_ref().map(|n| n.visibility()),\n         );\n         let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n-            bound_list.bounds().map(TypeBound::from_ast).collect()\n+            bound_list.bounds().map(|it| TypeBound::from_ast(&lower_ctx, it)).collect()\n         } else {\n             Vec::new()\n         };\n@@ -223,9 +226,10 @@ impl ImplData {\n         let _p = profile(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n         let src = impl_loc.source(db);\n+        let lower_ctx = LowerCtx::new(db, src.file_id);\n \n-        let target_trait = src.value.target_trait().map(TypeRef::from_ast);\n-        let target_type = TypeRef::from_ast_opt(src.value.target_type());\n+        let target_trait = src.value.target_trait().map(|it| TypeRef::from_ast(&lower_ctx, it));\n+        let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n         let is_negative = src.value.excl_token().is_some();\n         let module_id = impl_loc.container.module(db);\n \n@@ -279,8 +283,9 @@ impl ConstData {\n         vis_default: RawVisibility,\n         node: InFile<N>,\n     ) -> ConstData {\n+        let ctx = LowerCtx::new(db, node.file_id);\n         let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(node.value.ascribed_type());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n         let visibility =\n             RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n         ConstData { name, type_ref, visibility }"}, {"sha": "09a5241f7812b533f0e63c9509f2747a3eddd8c6", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 47, "deletions": 21, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -15,6 +15,7 @@ use ra_prof::profile;\n use ra_syntax::ast::{self, NameOwner, TypeBoundsOwner, TypeParamsOwner};\n \n use crate::{\n+    body::LowerCtx,\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n     dyn_map::DynMap,\n@@ -80,11 +81,13 @@ impl GenericParams {\n     fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n         let mut generics = GenericParams { types: Arena::default(), where_predicates: Vec::new() };\n         let mut sm = ArenaMap::default();\n+\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         let file_id = match def {\n             GenericDefId::FunctionId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 // lower `impl Trait` in arguments\n                 let data = db.function_data(it);\n                 for param in &data.params {\n@@ -94,21 +97,25 @@ impl GenericParams {\n             }\n             GenericDefId::AdtId(AdtId::StructId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::UnionId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::AdtId(AdtId::EnumId(it)) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::TraitId(it) => {\n                 let src = it.lookup(db).source(db);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n \n                 // traits get the Self type as an implicit first type parameter\n                 let self_param_id = generics.types.alloc(TypeParamData {\n@@ -120,22 +127,26 @@ impl GenericParams {\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&src.value, self_param);\n+                generics.fill_bounds(&lower_ctx, &src.value, self_param);\n \n-                generics.fill(&mut sm, &src.value);\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             GenericDefId::TypeAliasId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n             GenericDefId::ImplId(it) => {\n                 let src = it.lookup(db).source(db);\n-                generics.fill(&mut sm, &src.value);\n+                let lower_ctx = LowerCtx::new(db, src.file_id);\n+\n+                generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n             }\n             // We won't be using this ID anyway\n@@ -145,28 +156,38 @@ impl GenericParams {\n         (generics, InFile::new(file_id, sm))\n     }\n \n-    fn fill(&mut self, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n+    fn fill(&mut self, lower_ctx: &LowerCtx, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(sm, params)\n+            self.fill_params(lower_ctx, sm, params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n-            self.fill_where_predicates(where_clause);\n+            self.fill_where_predicates(lower_ctx, where_clause);\n         }\n     }\n \n-    fn fill_bounds(&mut self, node: &dyn ast::TypeBoundsOwner, type_ref: TypeRef) {\n+    fn fill_bounds(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        node: &dyn ast::TypeBoundsOwner,\n+        type_ref: TypeRef,\n+    ) {\n         for bound in\n             node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n         {\n-            self.add_where_predicate_from_bound(bound, type_ref.clone());\n+            self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n         }\n     }\n \n-    fn fill_params(&mut self, sm: &mut SourceMap, params: ast::TypeParamList) {\n+    fn fill_params(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        sm: &mut SourceMap,\n+        params: ast::TypeParamList,\n+    ) {\n         for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n-            let default = type_param.default_type().map(TypeRef::from_ast);\n+            let default = type_param.default_type().map(|it| TypeRef::from_ast(lower_ctx, it));\n             let param = TypeParamData {\n                 name: Some(name.clone()),\n                 default,\n@@ -176,29 +197,34 @@ impl GenericParams {\n             sm.insert(param_id, Either::Right(type_param.clone()));\n \n             let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(&type_param, type_ref);\n+            self.fill_bounds(&lower_ctx, &type_param, type_ref);\n         }\n     }\n \n-    fn fill_where_predicates(&mut self, where_clause: ast::WhereClause) {\n+    fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n             let type_ref = match pred.type_ref() {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };\n-            let type_ref = TypeRef::from_ast(type_ref);\n+            let type_ref = TypeRef::from_ast(lower_ctx, type_ref);\n             for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                self.add_where_predicate_from_bound(bound, type_ref.clone());\n+                self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n             }\n         }\n     }\n \n-    fn add_where_predicate_from_bound(&mut self, bound: ast::TypeBound, type_ref: TypeRef) {\n+    fn add_where_predicate_from_bound(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        bound: ast::TypeBound,\n+        type_ref: TypeRef,\n+    ) {\n         if bound.question_token().is_some() {\n             // FIXME: remove this bound\n             return;\n         }\n-        let bound = TypeBound::from_ast(bound);\n+        let bound = TypeBound::from_ast(lower_ctx, bound);\n         self.where_predicates\n             .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n     }"}, {"sha": "e84efe2abd04e6edbfbd7f9f264a0b9c4611d945", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -7,6 +7,7 @@ use std::{\n     sync::Arc,\n };\n \n+use crate::body::LowerCtx;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{AsName, Name},\n@@ -244,8 +245,8 @@ impl<'a> PathSegments<'a> {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(node: ast::TypeArgList) -> Option<GenericArgs> {\n-        lower::lower_generic_args(node)\n+    pub(crate) fn from_ast(lower_ctx: &LowerCtx, node: ast::TypeArgList) -> Option<GenericArgs> {\n+        lower::lower_generic_args(lower_ctx, node)\n     }\n \n     pub(crate) fn empty() -> GenericArgs {"}, {"sha": "e3d237a0acb967b2ca06377b94a688e84863780b", "filename": "crates/ra_hir_def/src/path/lower.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath%2Flower.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -13,6 +13,7 @@ use ra_syntax::ast::{self, AstNode, TypeAscriptionOwner, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n use crate::{\n+    body::LowerCtx,\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n     type_ref::{TypeBound, TypeRef},\n };\n@@ -26,6 +27,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     let mut type_anchor = None;\n     let mut segments = Vec::new();\n     let mut generic_args = Vec::new();\n+    let ctx = LowerCtx::with_hygiene(hygiene);\n     loop {\n         let segment = path.segment()?;\n \n@@ -40,9 +42,10 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                     Either::Left(name) => {\n                         let args = segment\n                             .type_arg_list()\n-                            .and_then(lower_generic_args)\n+                            .and_then(|it| lower_generic_args(&ctx, it))\n                             .or_else(|| {\n                                 lower_generic_args_from_fn_path(\n+                                    &ctx,\n                                     segment.param_list(),\n                                     segment.ret_type(),\n                                 )\n@@ -60,7 +63,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n \n-                let self_type = TypeRef::from_ast(type_ref?);\n+                let self_type = TypeRef::from_ast(&ctx, type_ref?);\n \n                 match trait_ref {\n                     // <T>::foo\n@@ -128,10 +131,13 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     }\n }\n \n-pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs> {\n+pub(super) fn lower_generic_args(\n+    lower_ctx: &LowerCtx,\n+    node: ast::TypeArgList,\n+) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n     for type_arg in node.type_args() {\n-        let type_ref = TypeRef::from_ast_opt(type_arg.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.type_ref());\n         args.push(GenericArg::Type(type_ref));\n     }\n     // lifetimes ignored for now\n@@ -140,9 +146,9 @@ pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs>\n         let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n         if let Some(name_ref) = assoc_type_arg.name_ref() {\n             let name = name_ref.as_name();\n-            let type_ref = assoc_type_arg.type_ref().map(TypeRef::from_ast);\n+            let type_ref = assoc_type_arg.type_ref().map(|it| TypeRef::from_ast(lower_ctx, it));\n             let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n-                l.bounds().map(TypeBound::from_ast).collect()\n+                l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n             } else {\n                 Vec::new()\n             };\n@@ -159,6 +165,7 @@ pub(super) fn lower_generic_args(node: ast::TypeArgList) -> Option<GenericArgs>\n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n /// -> Z` (which desugars to `Fn<(X, Y), Output=Z>`).\n fn lower_generic_args_from_fn_path(\n+    ctx: &LowerCtx,\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {\n@@ -167,14 +174,14 @@ fn lower_generic_args_from_fn_path(\n     if let Some(params) = params {\n         let mut param_types = Vec::new();\n         for param in params.params() {\n-            let type_ref = TypeRef::from_ast_opt(param.ascribed_type());\n+            let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n             param_types.push(type_ref);\n         }\n         let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n         args.push(arg);\n     }\n     if let Some(ret_type) = ret_type {\n-        let type_ref = TypeRef::from_ast_opt(ret_type.type_ref());\n+        let type_ref = TypeRef::from_ast_opt(&ctx, ret_type.type_ref());\n         bindings.push(AssociatedTypeBinding {\n             name: name![Output],\n             type_ref: Some(type_ref),"}, {"sha": "5bdad9efdef3276a61202853552bdac2b9907909", "filename": "crates/ra_hir_def/src/type_ref.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ftype_ref.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -3,7 +3,7 @@\n \n use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n \n-use crate::path::Path;\n+use crate::{body::LowerCtx, path::Path};\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Mutability {\n@@ -64,30 +64,34 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeRef) -> Self {\n         match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n             ast::TypeRef::TupleType(inner) => {\n-                TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect())\n+                TypeRef::Tuple(inner.fields().map(|it| TypeRef::from_ast(ctx, it)).collect())\n             }\n             ast::TypeRef::NeverType(..) => TypeRef::Never,\n             ast::TypeRef::PathType(inner) => {\n                 // FIXME: Use `Path::from_src`\n-                inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n+                inner\n+                    .path()\n+                    .and_then(|it| ctx.lower_path(it))\n+                    .map(TypeRef::Path)\n+                    .unwrap_or(TypeRef::Error)\n             }\n             ast::TypeRef::PointerType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n             ast::TypeRef::ArrayType(inner) => {\n-                TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+                TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n             }\n             ast::TypeRef::SliceType(inner) => {\n-                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref())))\n+                TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.type_ref())))\n             }\n             ast::TypeRef::ReferenceType(inner) => {\n-                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let inner_ty = TypeRef::from_ast_opt(&ctx, inner.type_ref());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n@@ -96,30 +100,33 @@ impl TypeRef {\n                 let ret_ty = inner\n                     .ret_type()\n                     .and_then(|rt| rt.type_ref())\n-                    .map(TypeRef::from_ast)\n+                    .map(|it| TypeRef::from_ast(ctx, it))\n                     .unwrap_or_else(|| TypeRef::Tuple(Vec::new()));\n                 let mut params = if let Some(pl) = inner.param_list() {\n-                    pl.params().map(|p| p.ascribed_type()).map(TypeRef::from_ast_opt).collect()\n+                    pl.params()\n+                        .map(|p| p.ascribed_type())\n+                        .map(|it| TypeRef::from_ast_opt(&ctx, it))\n+                        .collect()\n                 } else {\n                     Vec::new()\n                 };\n                 params.push(ret_ty);\n                 TypeRef::Fn(params)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.type_ref()),\n             ast::TypeRef::ImplTraitType(inner) => {\n-                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n+                TypeRef::ImplTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n             ast::TypeRef::DynTraitType(inner) => {\n-                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n+                TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::TypeRef>) -> Self {\n         if let Some(node) = node {\n-            TypeRef::from_ast(node)\n+            TypeRef::from_ast(ctx, node)\n         } else {\n             TypeRef::Error\n         }\n@@ -180,24 +187,27 @@ impl TypeRef {\n     }\n }\n \n-pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n+pub(crate) fn type_bounds_from_ast(\n+    lower_ctx: &LowerCtx,\n+    type_bounds_opt: Option<ast::TypeBoundList>,\n+) -> Vec<TypeBound> {\n     if let Some(type_bounds) = type_bounds_opt {\n-        type_bounds.bounds().map(TypeBound::from_ast).collect()\n+        type_bounds.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n     } else {\n         vec![]\n     }\n }\n \n impl TypeBound {\n-    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeBound) -> Self {\n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n                 let path = match path_type.path() {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };\n-                // FIXME: Use `Path::from_src`\n-                let path = match Path::from_ast(path) {\n+\n+                let path = match ctx.lower_path(path) {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };"}, {"sha": "53866bbcb7c1f287e4457d6253bd53d09c608a15", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -12,7 +12,7 @@ use crate::{\n     HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct Hygiene {\n     // This is what `$crate` expands to\n     def_crate: Option<CrateId>,"}, {"sha": "65db6d1b088892bf122a6ea63bb526e10d3a9876", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -11,7 +11,7 @@ doctest = false\n itertools = \"0.9.0\"\n arrayvec = \"0.5.1\"\n smallvec = \"1.2.0\"\n-ena = \"0.13.1\"\n+ena = \"0.14.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n "}, {"sha": "1f796876da2cc8a01e936b7ae2acc9d387078e20", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -338,6 +338,46 @@ pub fn baz() -> usize { 31usize }\n     assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_macro_with_dollar_crate_is_correct_in_trait_associate_type() {\n+    let (db, pos) = TestDB::with_position(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::Trait;\n+\n+fn test() {\n+    let msg = foo::Message(foo::MessageRef);\n+    let r = msg.deref();\n+    r<|>;\n+}\n+\n+//- /lib.rs crate:foo\n+pub struct MessageRef;\n+pub struct Message(MessageRef);\n+\n+pub trait Trait {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+#[macro_export]\n+macro_rules! expand {\n+    () => {\n+        impl Trait for Message {\n+            type Target = $crate::MessageRef;\n+            fn deref(&self) ->  &Self::Target {\n+                &self.0\n+            }\n+        }\n+    }\n+}\n+\n+expand!();\n+\"#,\n+    );\n+    assert_eq!(\"&MessageRef\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_type_value_non_legacy_macro_use_as() {\n     assert_snapshot!("}, {"sha": "886e148703d7ab36c30da75d7cc38b965412f461", "filename": "crates/ra_proc_macro_srv/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2FCargo.toml?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -21,4 +21,4 @@ test_utils = { path = \"../test_utils\" }\n cargo_metadata = \"0.9.1\"\n difference = \"2.0.0\"\n # used as proc macro test target\n-serde_derive = \"=1.0.104\"\n+serde_derive = \"=1.0.106\""}, {"sha": "6776f5231743381d2e8ef89698ce77a899ae552f", "filename": "crates/ra_proc_macro_srv/src/tests/fixtures/test_serialize_proc_macro.txt", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Ffixtures%2Ftest_serialize_proc_macro.txt?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -1,5 +1,10 @@\n SUBTREE $\n   PUNCH   # [alone] 4294967295\n+  SUBTREE [] 4294967295\n+    IDENT   doc 4294967295\n+    SUBTREE () 4294967295\n+      IDENT   hidden 4294967295\n+  PUNCH   # [alone] 4294967295\n   SUBTREE [] 4294967295\n     IDENT   allow 4294967295\n     SUBTREE () 4294967295\n@@ -184,4 +189,4 @@ SUBTREE $\n         IDENT   end 4294967295\n         SUBTREE () 4294967295\n           IDENT   __serde_state 4294967295\n-  PUNCH   ; [alone] 4294967295\n\\ No newline at end of file\n+  PUNCH   ; [alone] 4294967295"}, {"sha": "9cf58511ce7fe6a6e26b339b1cde38f55433c0b3", "filename": "crates/ra_proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -10,7 +10,7 @@ fn test_derive_serialize_proc_macro() {\n     assert_expand(\n         \"serde_derive\",\n         \"Serialize\",\n-        \"1.0.104\",\n+        \"1.0.106\",\n         r##\"struct Foo {}\"##,\n         include_str!(\"fixtures/test_serialize_proc_macro.txt\"),\n     );\n@@ -21,7 +21,7 @@ fn test_derive_serialize_proc_macro_failed() {\n     assert_expand(\n         \"serde_derive\",\n         \"Serialize\",\n-        \"1.0.104\",\n+        \"1.0.106\",\n         r##\"\n     struct {}\n \"##,\n@@ -37,7 +37,7 @@ SUBTREE $\n \n #[test]\n fn test_derive_proc_macro_list() {\n-    let res = list(\"serde_derive\", \"1.0.104\").join(\"\\n\");\n+    let res = list(\"serde_derive\", \"1.0.106\").join(\"\\n\");\n \n     assert_eq_text!(\n         &res,"}, {"sha": "5e651fe70d9e2a35c03275d3e2848cfc272a9752", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -18,7 +18,7 @@ ra_db = { path = \"../ra_db\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n \n-serde = { version = \"1.0.104\", features = [\"derive\"] }\n+serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\"\n \n anyhow = \"1.0.26\""}, {"sha": "c07ff488e4f0e0147dbedc762cc3a7372f8d2095", "filename": "crates/ra_syntax/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_syntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_syntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2FCargo.toml?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -13,7 +13,7 @@ doctest = false\n [dependencies]\n itertools = \"0.9.0\"\n rowan = \"0.10.0\"\n-rustc_lexer = { version = \"652.0.0\", package = \"rustc-ap-rustc_lexer\" }\n+rustc_lexer = { version = \"656.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\"\n once_cell = \"1.3.1\"\n@@ -27,7 +27,7 @@ ra_parser = { path = \"../ra_parser\" }\n # ideally, `serde` should be enabled by `rust-analyzer`, but we enable it here\n # to reduce number of compilations\n smol_str = { version = \"0.1.15\", features = [\"serde\"] }\n-serde = { version = \"1.0.104\", features = [\"derive\"] }\n+serde = { version = \"1.0.106\", features = [\"derive\"] }\n \n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }"}, {"sha": "1a5a6dc065eb2458caab58028a4484a08eee8245", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -180,7 +180,7 @@ fn rustc_token_kind_to_syntax_kind(\n     return (syntax_kind, None);\n \n     fn match_literal_kind(kind: &rustc_lexer::LiteralKind) -> (SyntaxKind, Option<&'static str>) {\n-        use rustc_lexer::LiteralKind as LK;\n+        use rustc_lexer::{LexRawStrError, LiteralKind as LK};\n \n         #[rustfmt::skip]\n         let syntax_kind = match *kind {\n@@ -215,21 +215,28 @@ fn rustc_token_kind_to_syntax_kind(\n                 return (BYTE_STRING, Some(\"Missing trailing `\\\"` symbol to terminate the byte string literal\"))\n             }\n \n-            LK::RawStr { started: true, terminated: true, .. } => RAW_STRING,\n-            LK::RawStr { started: true, terminated: false, .. } => {\n-                return (RAW_STRING, Some(\"Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"))\n-            }\n-            LK::RawStr { started: false, .. } => {\n-                return (RAW_STRING, Some(\"Missing `\\\"` symbol after `#` symbols to begin the raw string literal\"))\n-            }\n+            LK::RawStr(str) => match str.validate() {\n+                Ok(_) => RAW_STRING,\n+                Err(LexRawStrError::InvalidStarter) => return (RAW_STRING, Some(\"Missing `\\\"` symbol after `#` symbols to begin the raw string literal\")),\n+                Err(LexRawStrError::NoTerminator { expected, found, .. }) => if expected == found {\n+                    return (RAW_STRING, Some(\"Missing trailing `\\\"` to terminate the raw string literal\"))\n+                } else {\n+                    return (RAW_STRING, Some(\"Missing trailing `\\\"` with `#` symbols to terminate the raw string literal\"))\n+\n+                },\n+                Err(LexRawStrError::TooManyDelimiters { .. }) => return (RAW_STRING, Some(\"Too many `#` symbols: raw strings may be delimited by up to 65535 `#` symbols\")),\n+            },\n+            LK::RawByteStr(str) => match str.validate() {\n+                Ok(_) => RAW_BYTE_STRING,\n+                Err(LexRawStrError::InvalidStarter) => return (RAW_BYTE_STRING, Some(\"Missing `\\\"` symbol after `#` symbols to begin the raw byte string literal\")),\n+                Err(LexRawStrError::NoTerminator { expected, found, .. }) => if expected == found {\n+                    return (RAW_BYTE_STRING, Some(\"Missing trailing `\\\"` to terminate the raw byte string literal\"))\n+                } else {\n+                    return (RAW_BYTE_STRING, Some(\"Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"))\n \n-            LK::RawByteStr { started: true, terminated: true, .. } => RAW_BYTE_STRING,\n-            LK::RawByteStr { started: true, terminated: false, .. } => {\n-                return (RAW_BYTE_STRING, Some(\"Missing trailing `\\\"` with `#` symbols to terminate the raw byte string literal\"))\n-            }\n-            LK::RawByteStr { started: false, .. } => {\n-                return (RAW_BYTE_STRING, Some(\"Missing `\\\"` symbol after `#` symbols to begin the raw byte string literal\"))\n-            }\n+                },\n+                Err(LexRawStrError::TooManyDelimiters { .. }) => return (RAW_BYTE_STRING, Some(\"Too many `#` symbols: raw byte strings may be delimited by up to 65535 `#` symbols\")),\n+            },\n         };\n \n         (syntax_kind, None)"}, {"sha": "8c94f430a29dec80de359187ba16ab4985a07485", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3232fd5179f2e36dee69955ba8aae0463b142e67/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=3232fd5179f2e36dee69955ba8aae0463b142e67", "patch": "@@ -26,7 +26,7 @@ pico-args = \"0.3.1\"\n rand = { version = \"0.7.3\", features = [\"small_rng\"] }\n relative-path = \"1.0.0\"\n rustc-hash = \"1.1.0\"\n-serde = { version = \"1.0.104\", features = [\"derive\"] }\n+serde = { version = \"1.0.106\", features = [\"derive\"] }\n serde_json = \"1.0.48\"\n threadpool = \"1.7.1\"\n "}]}