{"sha": "cc408fb5be059bd73a9b1d40b75a040d606f5843", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNDA4ZmI1YmUwNTliZDczYTliMWQ0MGI3NWEwNDBkNjA2ZjU4NDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-31T01:25:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-31T01:25:49Z"}, "message": "Auto merge of #52731 - nikomatsakis:issue-52057-inference-variable, r=pnkfelix\n\nIssue 52057 \u2014 inference variable\n\nBreak out the computation of universal region relations and do it during the typeck, where we can handle the resulting constraints that arise.\n\nr? @pnkfelix", "tree": {"sha": "cf033e7d81821349c2da2b2a91e703c9d112a4a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf033e7d81821349c2da2b2a91e703c9d112a4a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc408fb5be059bd73a9b1d40b75a040d606f5843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc408fb5be059bd73a9b1d40b75a040d606f5843", "html_url": "https://github.com/rust-lang/rust/commit/cc408fb5be059bd73a9b1d40b75a040d606f5843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc408fb5be059bd73a9b1d40b75a040d606f5843/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54628c8ea844956f3f4f416b82067c634eb09f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/54628c8ea844956f3f4f416b82067c634eb09f7b", "html_url": "https://github.com/rust-lang/rust/commit/54628c8ea844956f3f4f416b82067c634eb09f7b"}, {"sha": "b9652aee6533378bc3116969f04551058d3667e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9652aee6533378bc3116969f04551058d3667e9", "html_url": "https://github.com/rust-lang/rust/commit/b9652aee6533378bc3116969f04551058d3667e9"}], "stats": {"total": 896, "additions": 565, "deletions": 331}, "files": [{"sha": "cc752d21ab2b8ade98969e8abe70f03128c1772e", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -75,6 +75,19 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n ) -> Fallible<(R, Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>)> {\n     let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n     let dummy_body_id = ObligationCause::dummy().body_id;\n+\n+    // During NLL, we expect that nobody will register region\n+    // obligations **except** as part of a custom type op (and, at the\n+    // end of each custom type op, we scrape out the region\n+    // obligations that resulted). So this vector should be empty on\n+    // entry.\n+    let pre_obligations = infcx.take_registered_region_obligations();\n+    assert!(\n+        pre_obligations.is_empty(),\n+        \"scrape_region_constraints: incoming region obligations = {:#?}\",\n+        pre_obligations,\n+    );\n+\n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n     debug_assert!(obligations.iter().all(|o| o.cause.body_id == dummy_body_id));\n     fulfill_cx.register_predicate_obligations(infcx, obligations);"}, {"sha": "973568a67f030e8fdf04c89d45a8e59cfc5376c2", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -104,12 +104,14 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         None\n     };\n \n+    let universal_regions = Rc::new(universal_regions);\n+\n     let elements = &Rc::new(RegionValueElements::new(mir));\n \n     // Run the MIR type-checker.\n     let liveness_map = NllLivenessMap::compute(&mir);\n     let liveness = LivenessResults::compute(mir, &liveness_map);\n-    let constraint_sets = type_check::type_check(\n+    let (constraint_sets, universal_region_relations) = type_check::type_check(\n         infcx,\n         param_env,\n         mir,\n@@ -153,6 +155,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let mut regioncx = RegionInferenceContext::new(\n         var_origins,\n         universal_regions,\n+        universal_region_relations,\n         mir,\n         outlives_constraints,\n         type_tests,"}, {"sha": "d3b4f0a0447a1e952c7266fa4bb483c99dcde02c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     .universal_regions\n                     .region_classification(region)\n                     .unwrap();\n-                let outlived_by = self.universal_regions.regions_outlived_by(region);\n+                let outlived_by = self.universal_region_relations.regions_outlived_by(region);\n                 writeln!(\n                     out,\n                     \"| {r:rw$} | {c:cw$} | {ob}\","}, {"sha": "afd4e2859aced768268d115e4c867da0bd4d5e53", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -14,6 +14,7 @@ use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n+use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n@@ -80,8 +81,12 @@ pub struct RegionInferenceContext<'tcx> {\n     type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n-    /// on this function and their (known) relations to one another.\n+    /// on this function.\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n+\n+    /// Information about how the universally quantified regions in\n+    /// scope on this function relate to one another.\n+    universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -206,15 +211,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// of constraints produced by the MIR type check.\n     pub(crate) fn new(\n         var_infos: VarInfos,\n-        universal_regions: UniversalRegions<'tcx>,\n+        universal_regions: Rc<UniversalRegions<'tcx>>,\n+        universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n-        let universal_regions = Rc::new(universal_regions);\n-\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .into_iter()\n@@ -251,6 +255,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             scc_values,\n             type_tests,\n             universal_regions,\n+            universal_region_relations,\n         };\n \n         result.init_free_and_bound_regions();\n@@ -308,8 +313,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n                 \"init_universal_regions: region {:?} has external name {:?}\",\n-                variable,\n-                external_name\n+                variable, external_name\n             );\n             self.definitions[variable].external_name = Some(external_name);\n         }\n@@ -419,10 +423,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         self.check_type_tests(\n-            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n+            infcx,\n+            mir,\n+            mir_def_id,\n+            outlives_requirements.as_mut(),\n+            errors_buffer,\n+        );\n \n         self.check_universal_regions(\n-            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n+            infcx,\n+            mir,\n+            mir_def_id,\n+            outlives_requirements.as_mut(),\n+            errors_buffer,\n+        );\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -581,13 +595,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n                 let type_test_span = type_test.locations.span(mir);\n-                infcx.construct_generic_bound_failure(\n-                    region_scope_tree,\n-                    type_test_span,\n-                    None,\n-                    type_test.generic_kind,\n-                    lower_bound_region,\n-                ).buffer(errors_buffer);\n+                infcx\n+                    .construct_generic_bound_failure(\n+                        region_scope_tree,\n+                        type_test_span,\n+                        None,\n+                        type_test.generic_kind,\n+                        lower_bound_region,\n+                    )\n+                    .buffer(errors_buffer);\n             } else {\n                 // FIXME. We should handle this case better. It\n                 // indicates that we have e.g. some region variable\n@@ -599,10 +615,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n                 let type_test_span = type_test.locations.span(mir);\n-                tcx.sess.struct_span_err(\n-                    type_test_span,\n-                    &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n-                ).buffer(errors_buffer);\n+                tcx.sess\n+                    .struct_span_err(\n+                        type_test_span,\n+                        &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n+                    )\n+                    .buffer(errors_buffer);\n             }\n         }\n     }\n@@ -654,8 +672,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(!self.universal_regions\n-            .is_local_free_region(lower_bound_plus));\n+        assert!(\n+            !self\n+                .universal_regions\n+                .is_local_free_region(lower_bound_plus)\n+        );\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -768,7 +789,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Grow further to get smallest universal region known to\n         // creator.\n-        let non_local_lub = self.universal_regions.non_local_upper_bound(lub);\n+        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n \n         debug!(\n             \"non_local_universal_upper_bound: non_local_lub={:?}\",\n@@ -804,7 +825,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut lub = self.universal_regions.fr_fn_body;\n         let r_scc = self.constraint_sccs.scc(r);\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n-            lub = self.universal_regions.postdom_upper_bound(lub, ur);\n+            lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n         }\n \n         debug!(\"universal_upper_bound: r={:?} lub={:?}\", r, lub);\n@@ -872,7 +893,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .all(|r1| {\n                 self.scc_values\n                     .universal_regions_outlived_by(sup_region_scc)\n-                    .any(|r2| self.universal_regions.outlives(r2, r1))\n+                    .any(|r2| self.universal_region_relations.outlives(r2, r1))\n             });\n \n         if !universal_outlives {\n@@ -887,7 +908,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values\n+            .contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -977,7 +999,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n             // If it is known that `fr: o`, carry on.\n-            if self.universal_regions.outlives(longer_fr, shorter_fr) {\n+            if self\n+                .universal_region_relations\n+                .outlives(longer_fr, shorter_fr)\n+            {\n                 continue;\n             }\n \n@@ -991,14 +1016,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n                 // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                if let Some(fr_minus) = self\n+                    .universal_region_relations\n+                    .non_local_lower_bound(longer_fr)\n+                {\n                     debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                     // Grow `shorter_fr` until we find a non-local\n                     // region. (We always will.)  We'll call that\n                     // `shorter_fr+` -- it's ever so slightly larger than\n                     // `fr`.\n-                    let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                    let shorter_fr_plus = self\n+                        .universal_region_relations\n+                        .non_local_upper_bound(shorter_fr);\n                     debug!(\n                         \"check_universal_region: shorter_fr_plus={:?}\",\n                         shorter_fr_plus\n@@ -1021,8 +1051,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(\n-                mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         }\n     }\n "}, {"sha": "e4b1aacd34f71fad8306bf6e1efa98696d147a66", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -0,0 +1,361 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::type_check::constraint_conversion;\n+use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n+use rustc::traits::query::type_op::{self, TypeOp};\n+use rustc::ty::{self, RegionVid, Ty};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use std::rc::Rc;\n+use syntax::ast;\n+\n+#[derive(Debug)]\n+crate struct UniversalRegionRelations<'tcx> {\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n+\n+    /// Stores the outlives relations that are known to hold from the\n+    /// implied bounds, in-scope where clauses, and that sort of\n+    /// thing.\n+    outlives: TransitiveRelation<RegionVid>,\n+\n+    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n+    /// and we store that here. This is useful when figuring out how\n+    /// to express some local region in terms of external regions our\n+    /// caller will understand.\n+    inverse_outlives: TransitiveRelation<RegionVid>,\n+}\n+\n+/// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n+/// be true. These encode relationships like `T: 'a` that are\n+/// added via implicit bounds.\n+///\n+/// Each region here is guaranteed to be a key in the `indices`\n+/// map.  We use the \"original\" regions (i.e., the keys from the\n+/// map, and not the values) because the code in\n+/// `process_registered_region_obligations` has some special-cased\n+/// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+/// our special inference variable there, we would mess that up.\n+type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n+\n+/// As part of computing the free region relations, we also have to\n+/// normalize the input-output types, which we then need later. So we\n+/// return those.  This vector consists of first the input types and\n+/// then the output type as the last element.\n+type NormalizedInputsAndOutput<'tcx> = Vec<Ty<'tcx>>;\n+\n+crate struct CreateResult<'tcx> {\n+    crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    crate region_bound_pairs: RegionBoundPairs<'tcx>,\n+    crate normalized_inputs_and_output: NormalizedInputsAndOutput<'tcx>,\n+}\n+\n+crate fn create(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    mir_def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    location_table: &LocationTable,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    universal_regions: &Rc<UniversalRegions<'tcx>>,\n+    constraints: &mut MirTypeckRegionConstraints<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+) -> CreateResult<'tcx> {\n+    let mir_node_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+    UniversalRegionRelationsBuilder {\n+        infcx,\n+        mir_def_id,\n+        mir_node_id,\n+        param_env,\n+        implicit_region_bound,\n+        constraints,\n+        location_table,\n+        all_facts,\n+        universal_regions: universal_regions.clone(),\n+        region_bound_pairs: Vec::new(),\n+        relations: UniversalRegionRelations {\n+            universal_regions: universal_regions.clone(),\n+            outlives: TransitiveRelation::new(),\n+            inverse_outlives: TransitiveRelation::new(),\n+        },\n+    }.create()\n+}\n+\n+impl UniversalRegionRelations<'tcx> {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`. Invoked by the\n+    /// builder below.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\n+            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n+            fr_a, fr_b\n+        );\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+\n+    /// Given two universal regions, returns the postdominating\n+    /// upper-bound (effectively the least upper bound).\n+    ///\n+    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n+    /// the postdominating upper bound in general.)\n+    crate fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+        assert!(self.universal_regions.is_universal_region(fr1));\n+        assert!(self.universal_regions.is_universal_region(fr2));\n+        *self\n+            .inverse_outlives\n+            .postdom_upper_bound(&fr1, &fr2)\n+            .unwrap_or(&self.universal_regions.fr_static)\n+    }\n+\n+    /// Finds an \"upper bound\" for `fr` that is not local. In other\n+    /// words, returns the smallest (*) known region `fr1` that (a)\n+    /// outlives `fr` and (b) is not local. This cannot fail, because\n+    /// we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.inverse_outlives, fr)\n+            .unwrap_or(self.universal_regions.fr_static)\n+    }\n+\n+    /// Finds a \"lower bound\" for `fr` that is not local. In other\n+    /// words, returns the largest (*) known region `fr1` that (a) is\n+    /// outlived by `fr` and (b) is not local. This cannot fail,\n+    /// because we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.outlives, fr)\n+    }\n+\n+    /// Helper for `non_local_upper_bound` and\n+    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns None if we\n+    /// never do so.\n+    fn non_local_bound(\n+        &self,\n+        relation: &TransitiveRelation<RegionVid>,\n+        fr0: RegionVid,\n+    ) -> Option<RegionVid> {\n+        // This method assumes that `fr0` is one of the universally\n+        // quantified region variables.\n+        assert!(self.universal_regions.is_universal_region(fr0));\n+\n+        let mut external_parents = vec![];\n+        let mut queue = vec![&fr0];\n+\n+        // Keep expanding `fr` into its parents until we reach\n+        // non-local regions.\n+        while let Some(fr) = queue.pop() {\n+            if !self.universal_regions.is_local_free_region(*fr) {\n+                external_parents.push(fr);\n+                continue;\n+            }\n+\n+            queue.extend(relation.parents(fr));\n+        }\n+\n+        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = relation\n+            .mutual_immediate_postdominator(external_parents)\n+            .cloned();\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom.and_then(|post_dom| {\n+            // If the mutual immediate postdom is not local, then\n+            // there is no non-local result we can return.\n+            if !self.universal_regions.is_local_free_region(post_dom) {\n+                Some(post_dom)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// True if fr1 is known to outlive fr2.\n+    ///\n+    /// This will only ever be true for universally quantified regions.\n+    crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        self.outlives.contains(&fr1, &fr2)\n+    }\n+\n+    /// Returns a vector of free regions `x` such that `fr1: x` is\n+    /// known to hold.\n+    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n+        self.outlives.reachable_from(&fr1)\n+    }\n+}\n+\n+struct UniversalRegionRelationsBuilder<'this, 'gcx: 'tcx, 'tcx: 'this> {\n+    infcx: &'this InferCtxt<'this, 'gcx, 'tcx>,\n+    mir_def_id: DefId,\n+    mir_node_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    location_table: &'this LocationTable,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    constraints: &'this mut MirTypeckRegionConstraints<'tcx>,\n+    all_facts: &'this mut Option<AllFacts>,\n+\n+    // outputs:\n+    relations: UniversalRegionRelations<'tcx>,\n+    region_bound_pairs: RegionBoundPairs<'tcx>,\n+}\n+\n+impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n+    crate fn create(mut self) -> CreateResult<'tcx> {\n+        let unnormalized_input_output_tys = self\n+            .universal_regions\n+            .unnormalized_input_tys\n+            .iter()\n+            .cloned()\n+            .chain(Some(self.universal_regions.unnormalized_output_ty));\n+\n+        // For each of the input/output types:\n+        // - Normalize the type. This will create some region\n+        //   constraints, which we buffer up because we are\n+        //   not ready to process them yet.\n+        // - Then compute the implied bounds. This will adjust\n+        //   the `region_bound_pairs` and so forth.\n+        // - After this is done, we'll process the constraints, once\n+        //   the `relations` is built.\n+        let mut normalized_inputs_and_output =\n+            Vec::with_capacity(self.universal_regions.unnormalized_input_tys.len() + 1);\n+        let constraint_sets: Vec<_> = unnormalized_input_output_tys\n+            .flat_map(|ty| {\n+                debug!(\"build: input_or_output={:?}\", ty);\n+                let (ty, constraints) = self\n+                    .param_env\n+                    .and(type_op::normalize::Normalize::new(ty))\n+                    .fully_perform(self.infcx)\n+                    .unwrap_or_else(|_| bug!(\"failed to normalize {:?}\", ty));\n+                self.add_implied_bounds(ty);\n+                normalized_inputs_and_output.push(ty);\n+                constraints\n+            })\n+            .collect();\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        let param_env = self.param_env;\n+        self.add_outlives_bounds(outlives_bounds::explicit_outlives_bounds(param_env));\n+\n+        // Finally:\n+        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n+        // - `'static: 'r` for every region `'r`\n+        // - `'r: 'fn_body` for every (other) universally quantified\n+        //   region `'r`, all of which are provided by our caller\n+        let fr_static = self.universal_regions.fr_static;\n+        let fr_fn_body = self.universal_regions.fr_fn_body;\n+        for fr in self.universal_regions.universal_regions() {\n+            debug!(\n+                \"build: relating free region {:?} to itself and to 'static\",\n+                fr\n+            );\n+            self.relations.relate_universal_regions(fr, fr);\n+            self.relations.relate_universal_regions(fr_static, fr);\n+            self.relations.relate_universal_regions(fr, fr_fn_body);\n+        }\n+\n+        for data in constraint_sets {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx.tcx,\n+                &self.universal_regions,\n+                &self.location_table,\n+                &self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n+                Locations::All,\n+                &mut self.constraints.outlives_constraints,\n+                &mut self.constraints.type_tests,\n+                &mut self.all_facts,\n+            ).convert_all(&data);\n+        }\n+\n+        CreateResult {\n+            universal_region_relations: Rc::new(self.relations),\n+            region_bound_pairs: self.region_bound_pairs,\n+            normalized_inputs_and_output,\n+        }\n+    }\n+\n+    /// Update the type of a single local, which should represent\n+    /// either the return type of the MIR or one of its arguments. At\n+    /// the same time, compute and add any implied bounds that come\n+    /// from this local.\n+    fn add_implied_bounds(&mut self, ty: Ty<'tcx>) {\n+        debug!(\"add_implied_bounds(ty={:?})\", ty);\n+        let span = self.infcx.tcx.def_span(self.mir_def_id);\n+        let bounds = self\n+            .infcx\n+            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        self.add_outlives_bounds(bounds);\n+    }\n+\n+    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n+    /// the outlives relation as well as the region-bound pairs\n+    /// listing.\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n+    where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n+\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n+                    let r1 = self.universal_regions.to_region_vid(r1);\n+                    let r2 = self.universal_regions.to_region_vid(r2);\n+                    self.relations.relate_universal_regions(r2, r1);\n+                }\n+\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// This trait is used by the `impl-trait` constraint code to abstract\n+/// over the `FreeRegionMap` from lexical regions and\n+/// `UniversalRegions` (from NLL)`.\n+impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+        let shorter = shorter.to_region_vid();\n+        assert!(self.universal_regions.is_universal_region(shorter));\n+        let longer = longer.to_region_vid();\n+        assert!(self.universal_regions.is_universal_region(longer));\n+        self.outlives(longer, shorter)\n+    }\n+}"}, {"sha": "af42667016780618e7d0854706ba51f9ea09546e", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -18,6 +18,7 @@\n //! contain revealed `impl Trait` values).\n \n use borrow_check::nll::renumber;\n+use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n@@ -37,22 +38,25 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         universal_regions: &UniversalRegions<'tcx>,\n+        universal_region_relations: &UniversalRegionRelations<'tcx>,\n+        normalized_inputs_and_output: &[Ty<'tcx>],\n     ) {\n         let tcx = self.infcx.tcx;\n \n-        let &UniversalRegions {\n-            unnormalized_output_ty,\n-            unnormalized_input_tys,\n-            ..\n-        } = universal_regions;\n+        let (&normalized_output_ty, normalized_input_tys) =\n+            normalized_inputs_and_output.split_last().unwrap();\n         let infcx = self.infcx;\n \n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n-        for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n-            let input_ty = self.normalize(unnormalized_input_ty, Locations::All);\n+        for (&normalized_input_ty, local) in normalized_input_tys.iter().zip(argument_locals) {\n+            debug!(\n+                \"equate_inputs_and_outputs: normalized_input_ty = {:?}\",\n+                normalized_input_ty\n+            );\n+\n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(input_ty, mir_input_ty);\n+            self.equate_normalized_input_or_output(normalized_input_ty, mir_input_ty);\n         }\n \n         assert!(\n@@ -66,15 +70,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n-        debug!(\n-            \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n-            unnormalized_output_ty\n-        );\n-        let output_ty = self.normalize(unnormalized_output_ty, Locations::All);\n-        debug!(\n-            \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n-            output_ty\n-        );\n         let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n         let anon_type_map =\n@@ -90,7 +85,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                 mir_def_id,\n                                 dummy_body_id,\n                                 param_env,\n-                                &output_ty,\n+                                &normalized_output_ty,\n                             ));\n                         debug!(\n                             \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n@@ -144,7 +139,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self,\n                     Location::START,\n                     \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    output_ty,\n+                    normalized_output_ty,\n                     mir_output_ty,\n                     terr\n                 );\n@@ -160,7 +155,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 Locations::All,\n                 CustomTypeOp::new(\n                     |_cx| {\n-                        infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                        infcx.constrain_anon_types(&anon_type_map, universal_region_relations);\n                         Ok(InferOk {\n                             value: (),\n                             obligations: vec![],"}, {"sha": "a18e2368bf724d55b81f5f5afba76711e8d149d3", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -17,9 +17,10 @@ use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n+use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::LocalWithRegion;\n+use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n@@ -36,12 +37,12 @@ use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n+use rustc_errors::Diagnostic;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n-use rustc_errors::Diagnostic;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -71,6 +72,7 @@ macro_rules! span_mirbug_and_err {\n }\n \n mod constraint_conversion;\n+pub mod free_region_relations;\n mod input_output;\n mod liveness;\n mod relate_tys;\n@@ -110,7 +112,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n     mir_def_id: DefId,\n-    universal_regions: &UniversalRegions<'tcx>,\n+    universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n     liveness: &LivenessResults<LocalWithRegion>,\n@@ -119,14 +121,32 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     errors_buffer: &mut Vec<Diagnostic>,\n-) -> MirTypeckRegionConstraints<'tcx> {\n+) -> (\n+    MirTypeckRegionConstraints<'tcx>,\n+    Rc<UniversalRegionRelations<'tcx>>,\n+) {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n         liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         type_tests: Vec::default(),\n     };\n \n+    let CreateResult {\n+        universal_region_relations,\n+        region_bound_pairs,\n+        normalized_inputs_and_output,\n+    } = free_region_relations::create(\n+        infcx,\n+        mir_def_id,\n+        param_env,\n+        location_table,\n+        Some(implicit_region_bound),\n+        universal_regions,\n+        &mut constraints,\n+        all_facts,\n+    );\n+\n     {\n         let mut borrowck_context = BorrowCheckContext {\n             universal_regions,\n@@ -141,17 +161,24 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             mir_def_id,\n             param_env,\n             mir,\n-            &universal_regions.region_bound_pairs,\n+            &region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n             Some(errors_buffer),\n             |cx| {\n                 liveness::generate(cx, mir, liveness, flow_inits, move_data);\n-                cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n+                cx.equate_inputs_and_outputs(\n+                    mir,\n+                    mir_def_id,\n+                    universal_regions,\n+                    &universal_region_relations,\n+                    &normalized_inputs_and_output,\n+                );\n             },\n         );\n     }\n-    constraints\n+\n+    (constraints, universal_region_relations)\n }\n \n fn type_check_internal<'a, 'gcx, 'tcx, F>(\n@@ -164,8 +191,8 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     errors_buffer: Option<&mut Vec<Diagnostic>>,\n     mut extra: F,\n-)\n-    where F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>)\n+) where\n+    F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>),\n {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -307,8 +334,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // don't have a handy function for that, so for\n             // now we just ignore `value.val` regions.\n \n-            let instantiated_predicates =\n-                tcx.predicates_of(def_id).instantiate(tcx, substs);\n+            let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n             type_checker.normalize_and_prove_instantiated_predicates(\n                 instantiated_predicates,\n                 location.boring(),\n@@ -1023,9 +1049,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n                     if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                        let region_vid = borrowck_context.universal_regions.to_region_vid(\n-                            late_bound_region);\n-                        borrowck_context.constraints\n+                        let region_vid = borrowck_context\n+                            .universal_regions\n+                            .to_region_vid(late_bound_region);\n+                        borrowck_context\n+                            .constraints\n                             .liveness_constraints\n                             .add_element(region_vid, term_location);\n                     }\n@@ -1241,12 +1269,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self,\n-                   mir: &Mir<'tcx>,\n-                   local: Local,\n-                   local_decl: &LocalDecl<'tcx>,\n-                   errors_buffer: &mut Option<&mut Vec<Diagnostic>>)\n-    {\n+    fn check_local(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        local: Local,\n+        local_decl: &LocalDecl<'tcx>,\n+        errors_buffer: &mut Option<&mut Vec<Diagnostic>>,\n+    ) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1274,12 +1303,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                let mut diag = struct_span_err!(self.tcx().sess,\n-                                                span,\n-                                                E0161,\n-                                                \"cannot move a value of type {0}: the size of {0} \\\n-                                                 cannot be statically determined\",\n-                                                ty);\n+                let mut diag = struct_span_err!(\n+                    self.tcx().sess,\n+                    span,\n+                    E0161,\n+                    \"cannot move a value of type {0}: the size of {0} \\\n+                     cannot be statically determined\",\n+                    ty\n+                );\n                 if let Some(ref mut errors_buffer) = *errors_buffer {\n                     diag.buffer(errors_buffer);\n                 } else {\n@@ -1577,13 +1608,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n                         ty::TyRef(ref_region, _, mutbl) => {\n-                            constraints\n-                                .outlives_constraints\n-                                .push(OutlivesConstraint {\n-                                    sup: ref_region.to_region_vid(),\n-                                    sub: borrow_region.to_region_vid(),\n-                                    locations: location.boring(),\n-                                });\n+                            constraints.outlives_constraints.push(OutlivesConstraint {\n+                                sup: ref_region.to_region_vid(),\n+                                sub: borrow_region.to_region_vid(),\n+                                locations: location.boring(),\n+                            });\n \n                             if let Some(all_facts) = all_facts {\n                                 all_facts.outlives.push((\n@@ -1768,10 +1797,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self,\n-                  mir: &Mir<'tcx>,\n-                  mut errors_buffer: Option<&mut Vec<Diagnostic>>)\n-    {\n+    fn typeck_mir(&mut self, mir: &Mir<'tcx>, mut errors_buffer: Option<&mut Vec<Diagnostic>>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n@@ -1841,7 +1867,17 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, None, |_| ());\n+            type_check_internal(\n+                &infcx,\n+                def_id,\n+                param_env,\n+                mir,\n+                &[],\n+                None,\n+                None,\n+                None,\n+                |_| (),\n+            );\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "765c4cf906e68a4c4a89ba524e52317df654d88d", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 241, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -25,16 +25,12 @@\n use either::Either;\n use rustc::hir::def_id::DefId;\n use rustc::hir::{self, BodyOwnerKind, HirId};\n-use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n use std::iter;\n use syntax::ast;\n \n@@ -85,21 +81,7 @@ pub struct UniversalRegions<'tcx> {\n     /// as the name suggests. =)\n     pub unnormalized_input_tys: &'tcx [Ty<'tcx>],\n \n-    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n-    /// be true. These encode relationships like `T: 'a` that are\n-    /// added via implicit bounds.\n-    ///\n-    /// Each region here is guaranteed to be a key in the `indices`\n-    /// map.  We use the \"original\" regions (i.e., the keys from the\n-    /// map, and not the values) because the code in\n-    /// `process_registered_region_obligations` has some special-cased\n-    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n-    /// our special inference variable there, we would mess that up.\n-    pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-\n     pub yield_ty: Option<Ty<'tcx>>,\n-\n-    relations: UniversalRegionRelations,\n }\n \n /// The \"defining type\" for this MIR. The key feature of the \"defining\n@@ -171,20 +153,6 @@ struct UniversalRegionIndices<'tcx> {\n     indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n }\n \n-#[derive(Debug)]\n-struct UniversalRegionRelations {\n-    /// Stores the outlives relations that are known to hold from the\n-    /// implied bounds, in-scope where clauses, and that sort of\n-    /// thing.\n-    outlives: TransitiveRelation<RegionVid>,\n-\n-    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n-    /// and we store that here. This is useful when figuring out how\n-    /// to express some local region in terms of external regions our\n-    /// caller will understand.\n-    inverse_outlives: TransitiveRelation<RegionVid>,\n-}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum RegionClassification {\n     /// A **global** region is one that can be named from\n@@ -249,11 +217,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n             mir_node_id,\n             mir_hir_id,\n             param_env,\n-            region_bound_pairs: vec![],\n-            relations: UniversalRegionRelations {\n-                outlives: TransitiveRelation::new(),\n-                inverse_outlives: TransitiveRelation::new(),\n-            },\n         }.build()\n     }\n \n@@ -326,45 +289,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.num_universals\n     }\n \n-    /// Given two universal regions, returns the postdominating\n-    /// upper-bound (effectively the least upper bound).\n-    ///\n-    /// (See `TransitiveRelation::postdom_upper_bound` for details on\n-    /// the postdominating upper bound in general.)\n-    pub fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n-        assert!(self.is_universal_region(fr1));\n-        assert!(self.is_universal_region(fr2));\n-        *self.relations\n-            .inverse_outlives\n-            .postdom_upper_bound(&fr1, &fr2)\n-            .unwrap_or(&self.fr_static)\n-    }\n-\n-    /// Finds an \"upper bound\" for `fr` that is not local. In other\n-    /// words, returns the smallest (*) known region `fr1` that (a)\n-    /// outlives `fr` and (b) is not local. This cannot fail, because\n-    /// we will always find `'static` at worst.\n-    ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    pub fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.relations.inverse_outlives, fr)\n-            .unwrap_or(self.fr_static)\n-    }\n-\n-    /// Finds a \"lower bound\" for `fr` that is not local. In other\n-    /// words, returns the largest (*) known region `fr1` that (a) is\n-    /// outlived by `fr` and (b) is not local. This cannot fail,\n-    /// because we will always find `'static` at worst.\n-    ///\n-    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n-    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    pub fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n-        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        self.non_local_bound(&self.relations.outlives, fr)\n-    }\n-\n     /// Returns the number of global plus external universal regions.\n     /// For closures, these are the regions that appear free in the\n     /// closure type (versus those bound in the closure\n@@ -374,68 +298,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n         self.first_local_index\n     }\n \n-    /// Helper for `non_local_upper_bound` and\n-    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n-    /// until we find something that is not local. Returns None if we\n-    /// never do so.\n-    fn non_local_bound(\n-        &self,\n-        relation: &TransitiveRelation<RegionVid>,\n-        fr0: RegionVid,\n-    ) -> Option<RegionVid> {\n-        // This method assumes that `fr0` is one of the universally\n-        // quantified region variables.\n-        assert!(self.is_universal_region(fr0));\n-\n-        let mut external_parents = vec![];\n-        let mut queue = vec![&fr0];\n-\n-        // Keep expanding `fr` into its parents until we reach\n-        // non-local regions.\n-        while let Some(fr) = queue.pop() {\n-            if !self.is_local_free_region(*fr) {\n-                external_parents.push(fr);\n-                continue;\n-            }\n-\n-            queue.extend(relation.parents(fr));\n-        }\n-\n-        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = relation\n-            .mutual_immediate_postdominator(external_parents)\n-            .cloned();\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom.and_then(|post_dom| {\n-            // If the mutual immediate postdom is not local, then\n-            // there is no non-local result we can return.\n-            if !self.is_local_free_region(post_dom) {\n-                Some(post_dom)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    /// True if fr1 is known to outlive fr2.\n-    ///\n-    /// This will only ever be true for universally quantified regions.\n-    pub fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        self.relations.outlives.contains(&fr1, &fr2)\n-    }\n-\n-    /// Returns a vector of free regions `x` such that `fr1: x` is\n-    /// known to hold.\n-    pub fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n-        self.relations.outlives.reachable_from(&fr1)\n-    }\n-\n     /// Get an iterator over all the early-bound regions that have names.\n     pub fn named_universal_regions<'s>(\n         &'s self,\n@@ -455,14 +317,12 @@ struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     mir_hir_id: HirId,\n     mir_node_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-    relations: UniversalRegionRelations,\n }\n \n const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n \n impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n-    fn build(mut self) -> UniversalRegions<'tcx> {\n+    fn build(self) -> UniversalRegions<'tcx> {\n         debug!(\"build(mir_def_id={:?})\", self.mir_def_id);\n \n         let param_env = self.param_env;\n@@ -519,33 +379,6 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n         let num_universals = self.infcx.num_region_vars();\n \n-        // Insert the facts we know from the predicates. Why? Why not.\n-        self.add_outlives_bounds(\n-            &indices,\n-            outlives_bounds::explicit_outlives_bounds(param_env),\n-        );\n-\n-        // Add the implied bounds from inputs and outputs.\n-        for ty in inputs_and_output {\n-            debug!(\"build: input_or_output={:?}\", ty);\n-            self.add_implied_bounds(&indices, ty);\n-        }\n-\n-        // Finally:\n-        // - outlives is reflexive, so `'r: 'r` for every region `'r`\n-        // - `'static: 'r` for every region `'r`\n-        // - `'r: 'fn_body` for every (other) universally quantified\n-        //   region `'r`, all of which are provided by our caller\n-        for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n-            debug!(\n-                \"build: relating free region {:?} to itself and to 'static\",\n-                fr\n-            );\n-            self.relations.relate_universal_regions(fr, fr);\n-            self.relations.relate_universal_regions(fr_static, fr);\n-            self.relations.relate_universal_regions(fr, fr_fn_body);\n-        }\n-\n         let (unnormalized_output_ty, unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n \n@@ -579,9 +412,7 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             defining_ty,\n             unnormalized_output_ty,\n             unnormalized_input_tys,\n-            region_bound_pairs: self.region_bound_pairs,\n             yield_ty: yield_ty,\n-            relations: self.relations,\n         }\n     }\n \n@@ -730,64 +561,6 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Update the type of a single local, which should represent\n-    /// either the return type of the MIR or one of its arguments. At\n-    /// the same time, compute and add any implied bounds that come\n-    /// from this local.\n-    ///\n-    /// Assumes that `universal_regions` indices map is fully constructed.\n-    fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n-        debug!(\"add_implied_bounds(ty={:?})\", ty);\n-        let span = self.infcx.tcx.def_span(self.mir_def_id);\n-        let bounds = self.infcx\n-            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n-        self.add_outlives_bounds(indices, bounds);\n-    }\n-\n-    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n-    /// the outlives relation as well as the region-bound pairs\n-    /// listing.\n-    fn add_outlives_bounds<I>(&mut self, indices: &UniversalRegionIndices<'tcx>, outlives_bounds: I)\n-    where\n-        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n-    {\n-        for outlives_bound in outlives_bounds {\n-            debug!(\"add_outlives_bounds(bound={:?})\", outlives_bound);\n-\n-            match outlives_bound {\n-                OutlivesBound::RegionSubRegion(r1, r2) => {\n-                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n-                    let r1 = indices.to_region_vid(r1);\n-                    let r2 = indices.to_region_vid(r2);\n-                    self.relations.relate_universal_regions(r2, r1);\n-                }\n-\n-                OutlivesBound::RegionSubParam(r_a, param_b) => {\n-                    self.region_bound_pairs\n-                        .push((r_a, GenericKind::Param(param_b)));\n-                }\n-\n-                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n-                    self.region_bound_pairs\n-                        .push((r_a, GenericKind::Projection(projection_b)));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl UniversalRegionRelations {\n-    /// Records in the `outlives_relation` (and\n-    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n-    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n-        debug!(\n-            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n-            fr_a, fr_b\n-        );\n-        self.outlives.add(fr_a, fr_b);\n-        self.inverse_outlives.add(fr_b, fr_a);\n-    }\n }\n \n trait InferCtxtExt<'tcx> {\n@@ -925,19 +698,6 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n     }\n }\n \n-/// This trait is used by the `impl-trait` constraint code to abstract\n-/// over the `FreeRegionMap` from lexical regions and\n-/// `UniversalRegions` (from NLL)`.\n-impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegions<'tcx> {\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n-        let shorter = shorter.to_region_vid();\n-        assert!(self.is_universal_region(shorter));\n-        let longer = longer.to_region_vid();\n-        assert!(self.is_universal_region(longer));\n-        self.outlives(longer, shorter)\n-    }\n-}\n-\n /// Iterates over the late-bound regions defined on fn_def_id and\n /// invokes `f` with the liberated form of each one.\n fn for_each_late_bound_region_defined_on<'tcx>("}, {"sha": "3f32d307409edb35c8ce34f672c80ea4700e26f1", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -14,6 +14,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n */\n \n+#![feature(infer_outlives_requirements)]\n+#![feature(in_band_lifetimes)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(from_ref)]"}, {"sha": "533623fd389004a65d44169a8d29a6e018c7d8a0", "filename": "src/test/ui/issue-52057.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Ftest%2Fui%2Fissue-52057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc408fb5be059bd73a9b1d40b75a040d606f5843/src%2Ftest%2Fui%2Fissue-52057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-52057.rs?ref=cc408fb5be059bd73a9b1d40b75a040d606f5843", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #52057. There is an implied bound\n+// that `I: 'a` where `'a` is the lifetime of `self` in `parse_first`;\n+// but to observe that, one must normalize first.\n+//\n+// run-pass\n+\n+#![feature(nll)]\n+\n+pub trait Parser {\n+    type Input;\n+\n+    #[inline(always)]\n+    fn parse_first(input: &mut Self::Input);\n+}\n+\n+impl<'a, I, P: ?Sized> Parser for &'a mut P\n+where\n+    P: Parser<Input = I>,\n+{\n+    type Input = I;\n+\n+    fn parse_first(_: &mut Self::Input) {}\n+}\n+\n+fn main() {}"}]}