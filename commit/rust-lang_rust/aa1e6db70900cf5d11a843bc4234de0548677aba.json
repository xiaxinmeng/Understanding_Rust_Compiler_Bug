{"sha": "aa1e6db70900cf5d11a843bc4234de0548677aba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMWU2ZGI3MDkwMGNmNWQxMWE4NDNiYzQyMzRkZTA1NDg2NzdhYmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-06T01:53:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-06T01:53:58Z"}, "message": "Auto merge of #53002 - QuietMisdreavus:brother-may-i-have-some-loops, r=pnkfelix\n\nmake `everybody_loops` preserve item declarations\n\nFirst half of https://github.com/rust-lang/rust/issues/52545.\n\n`everybody_loops` is used by rustdoc to ensure we don't contain erroneous references to platform APIs if one of its uses is pulled in by `#[doc(cfg)]`. However, you can also implement traits for public types inside of functions. This is used by Diesel (probably others, but they were the example that was reported) to get around a recent macro hygiene fix, which has caused their crate to fail to document. While this won't make the traits show up in documentation (that step comes later), it will at least allow files to be generated.", "tree": {"sha": "84330e513f53e39adc19ecae49a64c843a658a44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84330e513f53e39adc19ecae49a64c843a658a44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa1e6db70900cf5d11a843bc4234de0548677aba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa1e6db70900cf5d11a843bc4234de0548677aba", "html_url": "https://github.com/rust-lang/rust/commit/aa1e6db70900cf5d11a843bc4234de0548677aba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa1e6db70900cf5d11a843bc4234de0548677aba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9fa9f5a6a7dede07b71987b893065f290b7acf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9fa9f5a6a7dede07b71987b893065f290b7acf7", "html_url": "https://github.com/rust-lang/rust/commit/e9fa9f5a6a7dede07b71987b893065f290b7acf7"}, {"sha": "7e77d19905ebfcc76c19301587baf2c53acf2fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e77d19905ebfcc76c19301587baf2c53acf2fd9", "html_url": "https://github.com/rust-lang/rust/commit/7e77d19905ebfcc76c19301587baf2c53acf2fd9"}], "stats": {"total": 132, "additions": 108, "deletions": 24}, "files": [{"sha": "556ee9f5716ea32c9849b8f33af0af4e39573edc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=aa1e6db70900cf5d11a843bc4234de0548677aba", "patch": "@@ -20,6 +20,7 @@\n \n #![feature(box_syntax)]\n #![cfg_attr(unix, feature(libc))]\n+#![feature(option_replace)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}, {"sha": "3e74aef9e7345791beaab0480a387e509843d3f2", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=aa1e6db70900cf5d11a843bc4234de0548677aba", "patch": "@@ -33,6 +33,7 @@ use syntax::fold::{self, Folder};\n use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n+use syntax::util::ThinVec;\n use syntax::util::small_vector::SmallVector;\n use syntax_pos::{self, FileName};\n \n@@ -650,18 +651,25 @@ impl UserIdentifiedItem {\n // [#34511]: https://github.com/rust-lang/rust/issues/34511#issuecomment-322340401\n pub struct ReplaceBodyWithLoop<'a> {\n     within_static_or_const: bool,\n+    nested_blocks: Option<Vec<ast::Block>>,\n     sess: &'a Session,\n }\n \n impl<'a> ReplaceBodyWithLoop<'a> {\n     pub fn new(sess: &'a Session) -> ReplaceBodyWithLoop<'a> {\n-        ReplaceBodyWithLoop { within_static_or_const: false, sess }\n+        ReplaceBodyWithLoop {\n+            within_static_or_const: false,\n+            nested_blocks: None,\n+            sess\n+        }\n     }\n \n     fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n         let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n+        let old_blocks = self.nested_blocks.take();\n         let ret = action(self);\n         self.within_static_or_const = old_const;\n+        self.nested_blocks = old_blocks;\n         ret\n     }\n \n@@ -739,42 +747,88 @@ impl<'a> fold::Folder for ReplaceBodyWithLoop<'a> {\n         self.run(is_const, |s| fold::noop_fold_impl_item(i, s))\n     }\n \n+    fn fold_anon_const(&mut self, c: ast::AnonConst) -> ast::AnonConst {\n+        self.run(true, |s| fold::noop_fold_anon_const(c, s))\n+    }\n+\n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {\n-        fn expr_to_block(rules: ast::BlockCheckMode,\n+        fn stmt_to_block(rules: ast::BlockCheckMode,\n                          recovered: bool,\n-                         e: Option<P<ast::Expr>>,\n-                         sess: &Session) -> P<ast::Block> {\n-            P(ast::Block {\n-                stmts: e.map(|e| {\n-                        ast::Stmt {\n-                            id: sess.next_node_id(),\n-                            span: e.span,\n-                            node: ast::StmtKind::Expr(e),\n-                        }\n-                    })\n-                    .into_iter()\n-                    .collect(),\n+                         s: Option<ast::Stmt>,\n+                         sess: &Session) -> ast::Block {\n+            ast::Block {\n+                stmts: s.into_iter().collect(),\n                 rules,\n                 id: sess.next_node_id(),\n                 span: syntax_pos::DUMMY_SP,\n                 recovered,\n-            })\n+            }\n         }\n \n-        if !self.within_static_or_const {\n-\n-            let empty_block = expr_to_block(BlockCheckMode::Default, false, None, self.sess);\n-            let loop_expr = P(ast::Expr {\n-                node: ast::ExprKind::Loop(empty_block, None),\n-                id: self.sess.next_node_id(),\n+        fn block_to_stmt(b: ast::Block, sess: &Session) -> ast::Stmt {\n+            let expr = P(ast::Expr {\n+                id: sess.next_node_id(),\n+                node: ast::ExprKind::Block(P(b), None),\n                 span: syntax_pos::DUMMY_SP,\n-                attrs: ast::ThinVec::new(),\n+                attrs: ThinVec::new(),\n             });\n \n-            expr_to_block(b.rules, b.recovered, Some(loop_expr), self.sess)\n+            ast::Stmt {\n+                id: sess.next_node_id(),\n+                node: ast::StmtKind::Expr(expr),\n+                span: syntax_pos::DUMMY_SP,\n+            }\n+        }\n \n-        } else {\n+        let empty_block = stmt_to_block(BlockCheckMode::Default, false, None, self.sess);\n+        let loop_expr = P(ast::Expr {\n+            node: ast::ExprKind::Loop(P(empty_block), None),\n+            id: self.sess.next_node_id(),\n+            span: syntax_pos::DUMMY_SP,\n+            attrs: ast::ThinVec::new(),\n+        });\n+\n+        let loop_stmt = ast::Stmt {\n+            id: self.sess.next_node_id(),\n+            span: syntax_pos::DUMMY_SP,\n+            node: ast::StmtKind::Expr(loop_expr),\n+        };\n+\n+        if self.within_static_or_const {\n             fold::noop_fold_block(b, self)\n+        } else {\n+            b.map(|b| {\n+                let mut stmts = vec![];\n+                for s in b.stmts {\n+                    let old_blocks = self.nested_blocks.replace(vec![]);\n+\n+                    stmts.extend(self.fold_stmt(s).into_iter().filter(|s| s.is_item()));\n+\n+                    // we put a Some in there earlier with that replace(), so this is valid\n+                    let new_blocks = self.nested_blocks.take().unwrap();\n+                    self.nested_blocks = old_blocks;\n+                    stmts.extend(new_blocks.into_iter().map(|b| block_to_stmt(b, &self.sess)));\n+                }\n+\n+                let mut new_block = ast::Block {\n+                    stmts,\n+                    ..b\n+                };\n+\n+                if let Some(old_blocks) = self.nested_blocks.as_mut() {\n+                    //push our fresh block onto the cache and yield an empty block with `loop {}`\n+                    if !new_block.stmts.is_empty() {\n+                        old_blocks.push(new_block);\n+                    }\n+\n+                    stmt_to_block(b.rules, b.recovered, Some(loop_stmt), self.sess)\n+                } else {\n+                    //push `loop {}` onto the end of our fresh block and yield that\n+                    new_block.stmts.push(loop_stmt);\n+\n+                    new_block\n+                }\n+            })\n         }\n     }\n "}, {"sha": "3acf4af5fd247fd7495338f5f809faba2da4aaa3", "filename": "src/test/rustdoc/traits-in-bodies.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa1e6db70900cf5d11a843bc4234de0548677aba/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftraits-in-bodies.rs?ref=aa1e6db70900cf5d11a843bc4234de0548677aba", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//prior to fixing `everybody_loops` to preserve items, rustdoc would crash on this file, as it\n+//didn't see that `SomeStruct` implemented `Clone`\n+\n+//FIXME(misdreavus): whenever rustdoc shows traits impl'd inside bodies, make sure this test\n+//reflects that\n+\n+pub struct Bounded<T: Clone>(T);\n+\n+pub struct SomeStruct;\n+\n+fn asdf() -> Bounded<SomeStruct> {\n+    impl Clone for SomeStruct {\n+        fn clone(&self) -> SomeStruct {\n+            SomeStruct\n+        }\n+    }\n+\n+    Bounded(SomeStruct)\n+}"}]}