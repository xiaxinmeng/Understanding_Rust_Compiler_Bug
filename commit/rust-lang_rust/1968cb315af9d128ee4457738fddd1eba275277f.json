{"sha": "1968cb315af9d128ee4457738fddd1eba275277f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NjhjYjMxNWFmOWQxMjhlZTQ0NTc3MzhmZGRkMWViYTI3NTI3N2Y=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakubw@jakubw.net", "date": "2012-12-08T20:22:43Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-12-18T00:50:40Z"}, "message": "Add support for destructuring vectors in match expressions", "tree": {"sha": "99dc401a2713e3502c9b53333b74767adad53e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99dc401a2713e3502c9b53333b74767adad53e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1968cb315af9d128ee4457738fddd1eba275277f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1968cb315af9d128ee4457738fddd1eba275277f", "html_url": "https://github.com/rust-lang/rust/commit/1968cb315af9d128ee4457738fddd1eba275277f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1968cb315af9d128ee4457738fddd1eba275277f/comments", "author": null, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bf7ba077330c4cdb75802a4ca2497af24d21c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bf7ba077330c4cdb75802a4ca2497af24d21c4e", "html_url": "https://github.com/rust-lang/rust/commit/5bf7ba077330c4cdb75802a4ca2497af24d21c4e"}], "stats": {"total": 531, "additions": 521, "deletions": 10}, "files": [{"sha": "fe33f8d6e572c417bac889a2c14ba80c79606c86", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -22,6 +22,7 @@ use syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat, walk_pat};\n use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n+use std::sort;\n \n struct AltCheckCtxt {\n     tcx: ty::ctxt,\n@@ -146,6 +147,12 @@ fn check_exhaustive(cx: @AltCheckCtxt, sp: span, pats: ~[@pat]) {\n               None => fail ~\"check_exhaustive: bad variant in ctor\"\n             }\n           }\n+          ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+            match (*ctor) {\n+              vec(n) => Some(fmt!(\"vectors of length %u\", n)),\n+              _ => None\n+            }\n+          }\n           _ => None\n         }\n       }\n@@ -166,6 +173,8 @@ enum ctor {\n     variant(def_id),\n     val(const_val),\n     range(const_val, const_val),\n+    vec(uint),\n+    vec_with_tail(uint)\n }\n \n impl ctor : cmp::Eq {\n@@ -179,7 +188,12 @@ impl ctor : cmp::Eq {\n              range(ref cv0_other, ref cv1_other)) => {\n                 (*cv0_self) == (*cv0_other) && (*cv1_self) == (*cv1_other)\n             }\n-            (single, _) | (variant(_), _) | (val(_), _) | (range(*), _) => {\n+            (vec(n_self), vec(n_other)) => n_self == n_other,\n+            (vec_with_tail(n_self), vec_with_tail(n_other)) => {\n+                n_self == n_other\n+            }\n+            (single, _) | (variant(_), _) | (val(_), _) |\n+            (range(*), _) | (vec(*), _) | (vec_with_tail(*), _) => {\n                 false\n             }\n         }\n@@ -236,6 +250,21 @@ fn is_useful(cx: @AltCheckCtxt, m: matrix, v: ~[@pat]) -> useful {\n                 }\n                 not_useful\n               }\n+              ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+                let max_len = do m.foldr(0) |r, max_len| {\n+                  match r[0].node {\n+                    pat_vec(elems, _) => uint::max(elems.len(), max_len),\n+                    _ => max_len\n+                  }\n+                };\n+                for uint::range(0, max_len + 1) |n| {\n+                  match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n+                    not_useful => (),\n+                    ref u => return (*u)\n+                  }\n+                }\n+                not_useful\n+              }\n               _ => {\n                 let arity = ctor_arity(cx, single, left_ty);\n                 is_useful_specialized(cx, m, v, single, arity, left_ty)\n@@ -297,6 +326,12 @@ fn pat_ctor_id(cx: @AltCheckCtxt, p: @pat) -> Option<ctor> {\n       pat_region(*) => {\n         Some(single)\n       }\n+      pat_vec(elems, tail) => {\n+        match tail {\n+          Some(_) => Some(vec_with_tail(elems.len())),\n+          None => Some(vec(elems.len()))\n+        }\n+      }\n     }\n }\n \n@@ -360,6 +395,56 @@ fn missing_ctor(cx: @AltCheckCtxt,\n         else if true_found { Some(val(const_bool(false))) }\n         else { Some(val(const_bool(true))) }\n       }\n+      ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+        let max_len = do m.foldr(0) |r, max_len| {\n+          match r[0].node {\n+            pat_vec(elems, _) => uint::max(elems.len(), max_len),\n+            _ => max_len\n+          }\n+        };\n+        let min_len_with_tail = do m.foldr(max_len + 1) |r, min_len| {\n+          match r[0].node {\n+            pat_vec(elems, tail) => {\n+              if tail.is_some() && elems.len() < min_len {\n+                elems.len()\n+              } else {\n+                min_len\n+              }\n+            }\n+            _ => min_len\n+          }\n+        };\n+        let vec_lens = do m.filter_map |r| {\n+          match r[0].node {\n+            pat_vec(elems, tail) => {\n+              match tail {\n+                None if elems.len() < min_len_with_tail => Some(elems.len()),\n+                _ => None\n+              }\n+            }\n+            _ => None\n+          }\n+        };\n+        let mut sorted_vec_lens = do sort::merge_sort(vec_lens) |a, b| {\n+          a < b\n+        };\n+        vec::dedup(&mut sorted_vec_lens);\n+\n+        let mut missing = None;\n+        for uint::range(0, min_len_with_tail) |i| {\n+          if i >= sorted_vec_lens.len() || i != sorted_vec_lens[i] {\n+            missing = Some(i);\n+            break;\n+          }\n+        };\n+        if missing.is_none() && min_len_with_tail > max_len {\n+          missing = Some(min_len_with_tail);\n+        }\n+        match missing {\n+          Some(k) => Some(vec(k)),\n+          None => None\n+        }\n+      }\n       _ => Some(single)\n     }\n }\n@@ -378,6 +463,12 @@ fn ctor_arity(cx: @AltCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n+      ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+        match ctor {\n+          vec(n) | vec_with_tail(n) => n,\n+          _ => 0u\n+        }\n+      }\n       _ => 0u\n     }\n }\n@@ -521,6 +612,32 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n                     compare_const_vals(c_hi, v_hi) <= 0;\n         if match_ { Some(vec::tail(r)) } else { None }\n       }\n+      pat_vec(elems, tail) => {\n+        match ctor_id {\n+          vec_with_tail(_) => {\n+            if elems.len() >= arity {\n+              Some(vec::append(elems.slice(0, arity), vec::tail(r)))\n+            } else {\n+              None\n+            }\n+          }\n+          vec(_) => {\n+            if elems.len() < arity && tail.is_some() {\n+              Some(vec::append(\n+                vec::append(elems, vec::from_elem(\n+                    arity - elems.len(), wild())\n+                ),\n+                vec::tail(r)\n+              ))\n+            } else if elems.len() == arity {\n+              Some(vec::append(elems, vec::tail(r)))\n+            } else {\n+              None\n+            }\n+          }\n+          _ => None\n+        }\n+      }\n     }\n }\n \n@@ -593,6 +710,7 @@ fn is_refutable(cx: @AltCheckCtxt, pat: &pat) -> bool {\n         args.any(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n+      pat_vec(*) => { true }\n     }\n }\n "}, {"sha": "8962a1494e50d70c03190b2b6884c5d0b84a39c0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -978,7 +978,9 @@ impl &mem_categorization_ctxt {\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n-          ast::pat_lit(_) | ast::pat_range(_, _) => { /*always ok*/ }\n+          ast::pat_vec(*) | ast::pat_lit(_) | ast::pat_range(_, _) => {\n+              /*always ok*/\n+          }\n         }\n     }\n "}, {"sha": "922dc2363a05397ce6feba0f5dc976f0c7d8a372", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 143, "deletions": 6, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -179,7 +179,9 @@ enum Lit {\n enum Opt {\n     lit(Lit),\n     var(/* disr val */int, /* variant dids */{enm: def_id, var: def_id}),\n-    range(@ast::expr, @ast::expr)\n+    range(@ast::expr, @ast::expr),\n+    vec_len_eq(uint),\n+    vec_len_ge(uint)\n }\n \n fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n@@ -223,12 +225,15 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n         const_eval::compare_lit_exprs(tcx, a2, b2) == 0\n       }\n       (var(a, _), var(b, _)) => a == b,\n+      (vec_len_eq(a), vec_len_eq(b)) => a == b,\n+      (vec_len_ge(a), vec_len_ge(b)) => a == b,\n       _ => false\n     }\n }\n \n enum opt_result {\n     single_result(Result),\n+    lower_bound(Result),\n     range_result(Result, Result),\n }\n fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n@@ -256,6 +261,12 @@ fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n             return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n                                 rslt(bcx, consts::const_expr(ccx, l2)));\n         }\n+        vec_len_eq(n) => {\n+            return single_result(rslt(bcx, C_int(ccx, n as int)));\n+        }\n+        vec_len_ge(n) => {\n+            return lower_bound(rslt(bcx, C_int(ccx, n as int)));\n+        }\n     }\n }\n \n@@ -545,6 +556,24 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     None\n                 }\n             }\n+            ast::pat_vec(elems, tail) => {\n+                match tail {\n+                    Some(_) => {\n+                        if opt_eq(tcx, &vec_len_ge(elems.len()), opt) {\n+                            Some(vec::append_one(elems, tail.get()))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    None => {\n+                        if opt_eq(tcx, &vec_len_eq(elems.len()), opt) {\n+                            Some(copy elems)\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                }\n+            }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n                 Some(vec::from_elem(variant_size, dummy))\n@@ -755,6 +784,13 @@ fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_range(l1, l2) => {\n                 add_to_set(ccx.tcx, &found, range(l1, l2));\n             }\n+            ast::pat_vec(elems, tail) => {\n+                let opt = match tail {\n+                    None => vec_len_eq(elems.len()),\n+                    Some(_) => vec_len_ge(elems.len())\n+                };\n+                add_to_set(ccx.tcx, &found, opt);\n+            }\n             _ => {}\n         }\n     }\n@@ -790,6 +826,41 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n     return {vals: args, bcx: bcx};\n }\n \n+fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n+                     elem_count: uint, tail: bool, val: ValueRef)\n+    -> {vals: ~[ValueRef], bcx: block}\n+{\n+    let _icx = bcx.insn_ctxt(\"alt::extract_vec_elems\");\n+    let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n+    let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n+    let (base, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n+\n+    let mut elems = do vec::from_fn(elem_count) |i| {\n+        GEPi(bcx, base, ~[i])\n+    };\n+    if tail {\n+        let tail_offset = Mul(bcx, vt.llunit_size,\n+            C_int(bcx.ccx(), elem_count as int)\n+        );\n+        let tail_begin = tvec::pointer_add(bcx, base, tail_offset);\n+        let tail_len = Sub(bcx, len, tail_offset);\n+        let tail_ty = ty::mk_evec(bcx.tcx(),\n+            {ty: vt.unit_ty, mutbl: ast::m_imm},\n+            ty::vstore_slice(ty::re_static)\n+        );\n+        let scratch = scratch_datum(bcx, tail_ty, false);\n+        Store(bcx, tail_begin,\n+            GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n+        );\n+        Store(bcx, tail_len,\n+            GEPi(bcx, scratch.val, [0u, abi::slice_elt_len])\n+        );\n+        elems.push(scratch.val);\n+        scratch.add_clean(bcx);\n+    }\n+    return {vals: elems, bcx: bcx};\n+}\n+\n // NB: This function does not collect fields from struct-like enum variants.\n fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n                                    ~[ast::ident] {\n@@ -918,7 +989,7 @@ fn pick_col(m: &[@Match]) -> uint {\n     return best_col;\n }\n \n-enum branch_kind { no_branch, single, switch, compare, }\n+enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n impl branch_kind : cmp::Eq {\n     pure fn eq(&self, other: &branch_kind) -> bool {\n@@ -1268,6 +1339,15 @@ fn compile_submatch(bcx: block,\n             range(_, _) => {\n                 test_val = Load(bcx, val);\n                 kind = compare;\n+            },\n+            vec_len_eq(_) | vec_len_ge(_) => {\n+                let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n+                let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n+                let (_, len) = tvec::get_base_and_len(\n+                    bcx, unboxed, vt.vec_ty\n+                );\n+                test_val = SDiv(bcx, len, vt.llunit_size);\n+                kind = compare_vec_len;\n             }\n         }\n     }\n@@ -1323,6 +1403,12 @@ fn compile_submatch(bcx: block,\n                                   Result {bcx, val}) => {\n                                   compare_values(bcx, test_val, val, t)\n                               }\n+                              lower_bound(\n+                                  Result {bcx, val}) => {\n+                                  compare_scalar_types(\n+                                          bcx, test_val, val,\n+                                          t, ast::ge)\n+                              }\n                               range_result(\n                                   Result {val: vbegin, _},\n                                   Result {bcx, val: vend}) => {\n@@ -1342,9 +1428,47 @@ fn compile_submatch(bcx: block,\n                   bcx = sub_block(after_cx, ~\"compare_next\");\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n-                _ => ()\n+              compare_vec_len => {\n+                  let Result {bcx: after_cx, val: matches} = {\n+                      do with_scope_result(bcx, None,\n+                                           ~\"compare_vec_len_scope\") |bcx| {\n+                          match trans_opt(bcx, opt) {\n+                              single_result(\n+                                  Result {bcx, val}) => {\n+                                  let value = compare_scalar_values(\n+                                      bcx, test_val, val,\n+                                      signed_int, ast::eq);\n+                                  rslt(bcx, value)\n+                              }\n+                              lower_bound(\n+                                  Result {bcx, val: val}) => {\n+                                  let value = compare_scalar_values(\n+                                      bcx, test_val, val,\n+                                      signed_int, ast::ge);\n+                                  rslt(bcx, value)\n+                              }\n+                              range_result(\n+                                  Result {val: vbegin, _},\n+                                  Result {bcx, val: vend}) => {\n+                                  let llge =\n+                                      compare_scalar_values(\n+                                          bcx, test_val,\n+                                          vbegin, signed_int, ast::ge);\n+                                  let llle =\n+                                      compare_scalar_values(\n+                                          bcx, test_val, vend,\n+                                          signed_int, ast::le);\n+                                  rslt(bcx, And(bcx, llge, llle))\n+                              }\n+                          }\n+                      }\n+                  };\n+                  bcx = sub_block(after_cx, ~\"compare_vec_len_next\");\n+                  CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+              }\n+              _ => ()\n             }\n-        } else if kind == compare {\n+        } else if kind == compare || kind == compare_vec_len {\n             Br(bcx, else_cx.llbb);\n         }\n \n@@ -1357,6 +1481,16 @@ fn compile_submatch(bcx: block,\n                 unpacked = args.vals;\n                 opt_cx = args.bcx;\n             }\n+            vec_len_eq(n) | vec_len_ge(n) => {\n+                let tail = match *opt {\n+                    vec_len_ge(_) => true,\n+                    _ => false\n+                };\n+                let args = extract_vec_elems(opt_cx, pat_id, n, tail, val);\n+                size = args.vals.len();\n+                unpacked = args.vals;\n+                opt_cx = args.bcx;\n+            }\n             lit(_) | range(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n@@ -1366,7 +1500,9 @@ fn compile_submatch(bcx: block,\n \n     // Compile the fall-through case, if any\n     if !exhaustive {\n-        if kind == compare { Br(bcx, else_cx.llbb); }\n+        if kind == compare || kind == compare_vec_len {\n+            Br(bcx, else_cx.llbb);\n+        }\n         if kind != single {\n             compile_submatch(else_cx, defaults, vals_left, chk);\n         }\n@@ -1640,7 +1776,8 @@ fn bind_irrefutable_pat(bcx: block,\n                                        true,\n                                        binding_mode);\n         }\n-        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) => ()\n+        ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) |\n+        ast::pat_vec(*) => ()\n     }\n     return bcx;\n }"}, {"sha": "68e4c1a4b92cdea58fa1513bb8229fc4a0940e18", "filename": "src/librustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -525,7 +525,36 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n       }\n+      ast::pat_vec(elts, tail) => {\n+        let elt_type = match structure_of(fcx, pat.span, expected) {\n+          ty::ty_evec(mt, _) | ty::ty_unboxed_vec(mt) => mt,\n+          _ => {\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                fmt!(\"mismatched type: expected `%s` but found vector\",\n+                     fcx.infcx().ty_to_str(expected))\n+            );\n+          }\n+        };\n+        for elts.each |elt| {\n+            check_pat(pcx, *elt, elt_type.ty);\n+        }\n+        fcx.write_ty(pat.id, expected);\n \n+        match tail {\n+            Some(tail_pat) => {\n+                let region_var = fcx.infcx().next_region_var_with_lb(\n+                    pat.span, pcx.block_region\n+                );\n+                let slice_ty = ty::mk_evec(tcx,\n+                    {ty: elt_type.ty, mutbl: elt_type.mutbl},\n+                    ty::vstore_slice(region_var)\n+                );\n+                check_pat(pcx, tail_pat, slice_ty);\n+            }\n+            None => ()\n+        }\n+      }\n     }\n }\n "}, {"sha": "351b2995471963efce63d42c0079417849f7ce87", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -389,6 +389,7 @@ enum pat_ {\n     pat_region(@pat), // borrowed pointer pattern\n     pat_lit(@expr),\n     pat_range(@expr, @expr),\n+    pat_vec(~[@pat], Option<@pat>)\n }\n \n #[auto_serialize]"}, {"sha": "294a66166fae8a0088a12b4f68f8de7badb5fc7c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -593,6 +593,14 @@ fn walk_pat(pat: @pat, it: fn(@pat)) {\n         pat_box(s) | pat_uniq(s) | pat_region(s) => {\n             walk_pat(s, it)\n         }\n+        pat_vec(elts, tail) => {\n+            for elts.each |p| {\n+                walk_pat(*p, it)\n+            }\n+            do option::iter(&tail) |tail| {\n+                walk_pat(*tail, it)\n+            }\n+        }\n         pat_wild | pat_lit(_) | pat_range(_, _) | pat_ident(_, _, _) |\n         pat_enum(_, _) => {\n         }"}, {"sha": "0b1ff4f56eced3b12853e91681443ed53113c5c3", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -356,7 +356,11 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_region(inner) => pat_region(fld.fold_pat(inner)),\n           pat_range(e1, e2) => {\n             pat_range(fld.fold_expr(e1), fld.fold_expr(e2))\n-          }\n+          },\n+          pat_vec(elts, tail) => pat_vec(\n+            vec::map(elts, |x| fld.fold_pat(*x)),\n+            option::map(&tail, |tail| fld.fold_pat(*tail))\n+          )\n         };\n }\n "}, {"sha": "50ed0df28a054b5ea69d4435ab9a3098723565b4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -1794,6 +1794,39 @@ impl Parser {\n         };\n     }\n \n+    fn parse_pat_vec_elements(refutable: bool) -> (~[@pat], Option<@pat>) {\n+        let mut elements = ~[];\n+        let mut tail = None;\n+        let mut first = true;\n+\n+        while self.token != token::RBRACKET {\n+            if first { first = false; }\n+            else { self.expect(token::COMMA); }\n+\n+            let mut is_tail = false;\n+            if self.token == token::DOTDOT {\n+                self.bump();\n+                is_tail = true;\n+            }\n+\n+            let subpat = self.parse_pat(refutable);\n+            if is_tail {\n+                match subpat {\n+                    @{ node: pat_wild, _ } => (),\n+                    @{ node: pat_ident(_, _, _), _ } => (),\n+                    @{ span, _ } => self.span_fatal(\n+                        span, ~\"expected an identifier or `_`\"\n+                    )\n+                }\n+                tail = Some(subpat);\n+                break;\n+            }\n+\n+            elements.push(subpat);\n+        }\n+        return (elements, tail);\n+    }\n+\n     fn parse_pat_fields(refutable: bool) -> (~[ast::field_pat], bool) {\n         let mut fields = ~[];\n         let mut etc = false;\n@@ -1929,6 +1962,13 @@ impl Parser {\n                 pat = pat_tup(fields);\n             }\n           }\n+          token::LBRACKET => {\n+            self.bump();\n+            let (elements, tail) = self.parse_pat_vec_elements(refutable);\n+            hi = self.span.hi;\n+            self.expect(token::RBRACKET);\n+            pat = ast::pat_vec(elements, tail);\n+          }\n           copy tok => {\n             if !is_ident_or_path(tok)\n                 || self.is_keyword(~\"true\")"}, {"sha": "3b995addd62b3451a1d89b09d750a71bf40ac09f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -1641,6 +1641,16 @@ fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n         word(s.s, ~\"..\");\n         print_expr(s, end);\n       }\n+      ast::pat_vec(elts, tail) => {\n+        word(s.s, ~\"[\");\n+        commasep(s, inconsistent, elts, |s, p| print_pat(s, p, refutable));\n+        do option::iter(&tail) |tail| {\n+            if vec::len(elts) != 0u { word_space(s, ~\",\"); }\n+            word(s.s, ~\"..\");\n+            print_pat(s, *tail, refutable);\n+        }\n+        word(s.s, ~\"]\");\n+      }\n     }\n     (s.ann.post)(ann_node);\n }"}, {"sha": "9a47edfeb05a6707bb8fa4138c88dc1d67231ac2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -251,7 +251,15 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n         (v.visit_expr)(e1, e, v);\n         (v.visit_expr)(e2, e, v);\n       }\n-      pat_wild => ()\n+      pat_wild => (),\n+      pat_vec(elts, tail) => {\n+        for elts.each |elt| {\n+          (v.visit_pat)(*elt, e, v);\n+        }\n+        do option::iter(&tail) |tail| {\n+          (v.visit_pat)(*tail, e, v);\n+        }\n+      }\n     }\n }\n "}, {"sha": "69bc910669de9fef871e840a576792af66ef322d", "filename": "src/test/compile-fail/alt-vec-illegal-tail-loan.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,15 @@\n+fn a() -> &[int] {\n+    let vec = [1, 2, 3, 4];\n+    let tail = match vec {\n+        [a, ..tail] => tail, //~ ERROR illegal borrow\n+        _ => fail ~\"foo\"\n+    };\n+    move tail\n+}\n+\n+fn main() {\n+    let tail = a();\n+    for tail.each |n| {\n+        io::println(fmt!(\"%d\", *n));\n+    }\n+}"}, {"sha": "4174120b291c615aee1e5a4e53e0e968917b80ba", "filename": "src/test/compile-fail/alt-vec-invalid-2.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid-2.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    match ~[] {\n+        [_, ..tail, _] => {}, //~ ERROR: expected `]` but found `,`\n+        _ => ()\n+    }\n+}"}, {"sha": "b35731c2e4acd211408dfd80930fddc14d9f0f5b", "filename": "src/test/compile-fail/alt-vec-invalid.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-invalid.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let a = ~[];\n+    match a {\n+        [1, ..tail, ..tail] => {}, //~ ERROR: expected `]` but found `,`\n+        _ => ()\n+    }\n+}"}, {"sha": "9e8fb84951d30d485228d1f7477a0ffb90aac7f8", "filename": "src/test/compile-fail/alt-vec-mismatch-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch-2.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    match () {\n+        [()] => { } //~ ERROR mismatched type: expected `()` but found vector\n+    }\n+}"}, {"sha": "ef4d92ea4913bed886ddcd73ff578173775f0246", "filename": "src/test/compile-fail/alt-vec-mismatch.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-mismatch.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    match ~\"foo\" {\n+        ['f', 'o', .._] => { } //~ ERROR mismatched type: expected `~str` but found vector\n+        _ => { }\n+    }\n+}"}, {"sha": "2719d84b2dd2595e76154c585ec48b0f66d14379", "filename": "src/test/compile-fail/alt-vec-unreachable.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Falt-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-unreachable.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,20 @@\n+fn main() {\n+    let x: ~[(int, int)] = ~[];\n+    match x {\n+        [a, (2, 3), _] => (),\n+        [(1, 2), (2, 3), b] => (), //~ ERROR unreachable pattern\n+        _ => ()\n+    }\n+\n+    match [~\"foo\", ~\"bar\", ~\"baz\"] {\n+        [a, _, _, .._] => { io::println(a); }\n+        [~\"foo\", ~\"bar\", ~\"baz\", ~\"foo\", ~\"bar\"] => { } //~ ERROR unreachable pattern\n+        _ => { }\n+    }\n+\n+    match ['a', 'b', 'c'] {\n+        ['a', 'b', 'c', .._tail] => {}\n+        ['a', 'b', 'c'] => {} //~ ERROR unreachable pattern\n+        _ => {}\n+    }\n+}"}, {"sha": "9bd9db207799317462030f083e7daacebf159a48", "filename": "src/test/compile-fail/let-destruct-refutable.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flet-destruct-refutable.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern:refutable pattern\n // error-pattern:refutable pattern\n \n enum xx { xx(int), yy, }\n \n fn main() {\n     let @{x: xx(x), y: y} = @{x: xx(10), y: 20};\n     assert (x + y == 30);\n+\n+    let [a, b] = ~[1, 2];\n }"}, {"sha": "9719dd744b7139d91e13861ab8f7b43d269555aa", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -35,4 +35,28 @@ fn main() {\n       (_, a) => {}\n       (b, b) => {}\n     }\n+    match ~[Some(42), None, Some(21)] { //~ ERROR non-exhaustive patterns: vectors of length 0 not covered\n+        [Some(*), None, ..tail] => {}\n+        [Some(*), Some(*), ..tail] => {}\n+        [None] => {}\n+    }\n+    match ~[1] {\n+        [_, ..tail] => (),\n+        [] => ()\n+    }\n+    match ~[0.5] { //~ ERROR non-exhaustive patterns: vectors of length 4 not covered\n+        [0.1, 0.2, 0.3] => (),\n+        [0.1, 0.2] => (),\n+        [0.1] => (),\n+        [] => ()\n+    }\n+    match ~[Some(42), None, Some(21)] {\n+        [Some(*), None, ..tail] => {}\n+        [Some(*), Some(*), ..tail] => {}\n+        [None, None, ..tail] => {}\n+        [None, Some(*), ..tail] => {}\n+        [Some(_)] => {}\n+        [None] => {}\n+        [] => {}\n+    }\n }"}, {"sha": "a3840c9f561f82aab77648a81b68a1777390f74d", "filename": "src/test/run-pass/vec-matching.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,33 @@\n+fn foldl<T, U: Copy>(\n+    values: &[T],\n+    initial: U,\n+    function: &fn(partial: U, element: &T) -> U\n+) -> U {\n+    match values {\n+        [head, ..tail] =>\n+            foldl(tail, function(initial, &head), function),\n+        _ => copy initial\n+    }\n+}\n+\n+fn main() {\n+    let x = [1, 2, 3, 4, 5];\n+    match x {\n+        [a, b, c, d, e, f] => {\n+            core::util::unreachable();\n+        }\n+        [a, b, c, d, e] => {\n+            assert a == 1;\n+            assert b == 2;\n+            assert c == 3;\n+            assert d == 4;\n+            assert e == 5;\n+        }\n+        _ => {\n+            core::util::unreachable();\n+        }\n+    }\n+\n+    let product = foldl(x, 1, |a, b| a * *b);\n+    assert product == 120;\n+}"}, {"sha": "e2b68a11776e1044cfcc929dfa2f39b308c12193", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1968cb315af9d128ee4457738fddd1eba275277f/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=1968cb315af9d128ee4457738fddd1eba275277f", "patch": "@@ -0,0 +1,35 @@\n+struct Foo {\n+    string: ~str\n+}\n+\n+fn main() {\n+    let x = [\n+        Foo { string: ~\"foo\" },\n+        Foo { string: ~\"bar\" },\n+        Foo { string: ~\"baz\" }\n+    ];\n+    match x {\n+        [first, ..tail] => {\n+            assert first.string == ~\"foo\";\n+            assert tail.len() == 2;\n+            assert tail[0].string == ~\"bar\";\n+            assert tail[1].string == ~\"baz\";\n+\n+            match tail {\n+                [Foo { _ }, _, Foo { _ }, ..tail] => {\n+                    core::util::unreachable();\n+                }\n+                [Foo { string: a }, Foo { string: b }] => {\n+                    assert a == ~\"bar\";\n+                    assert b == ~\"baz\";\n+                }\n+                _ => {\n+                    core::util::unreachable();\n+                }\n+            }\n+        }\n+        _ => {\n+            core::util::unreachable();\n+        }\n+    }\n+}"}]}