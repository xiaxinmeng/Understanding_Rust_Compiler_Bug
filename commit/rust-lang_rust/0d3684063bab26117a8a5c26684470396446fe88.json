{"sha": "0d3684063bab26117a8a5c26684470396446fe88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMzY4NDA2M2JhYjI2MTE3YThhNWMyNjY4NDQ3MDM5NjQ0NmZlODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-10T23:18:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-10T23:18:07Z"}, "message": "Auto merge of #30148 - steveklabnik:doc_string, r=alexcrichton\n\nPart of #29376", "tree": {"sha": "11b6de7754008773db0f9b0c0f1201a574debb5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11b6de7754008773db0f9b0c0f1201a574debb5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d3684063bab26117a8a5c26684470396446fe88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3684063bab26117a8a5c26684470396446fe88", "html_url": "https://github.com/rust-lang/rust/commit/0d3684063bab26117a8a5c26684470396446fe88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d3684063bab26117a8a5c26684470396446fe88/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "611e8b447c5b733057d1ded727f9a6acc8057d17", "url": "https://api.github.com/repos/rust-lang/rust/commits/611e8b447c5b733057d1ded727f9a6acc8057d17", "html_url": "https://github.com/rust-lang/rust/commit/611e8b447c5b733057d1ded727f9a6acc8057d17"}, {"sha": "072dd6fabdacdbcd672c367af8ea3e721ea15d10", "url": "https://api.github.com/repos/rust-lang/rust/commits/072dd6fabdacdbcd672c367af8ea3e721ea15d10", "html_url": "https://github.com/rust-lang/rust/commit/072dd6fabdacdbcd672c367af8ea3e721ea15d10"}], "stats": {"total": 388, "additions": 294, "deletions": 94}, "files": [{"sha": "8c0b52f71f820b5716cac8d6aa30c2a6a9b405d2", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 294, "deletions": 94, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/0d3684063bab26117a8a5c26684470396446fe88/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d3684063bab26117a8a5c26684470396446fe88/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0d3684063bab26117a8a5c26684470396446fe88", "patch": "@@ -291,26 +291,50 @@ pub struct FromUtf8Error {\n pub struct FromUtf16Error(());\n \n impl String {\n-    /// Creates a new string buffer initialized with the empty string.\n+    /// Creates a new empty `String`.\n+    ///\n+    /// Given that the `String` is empty, this will not allocate any initial\n+    /// buffer. While that means that this initial operation is very\n+    /// inexpensive, but may cause excessive allocation later, when you add\n+    /// data. If you have an idea of how much data the `String` will hold,\n+    /// consider the [`with_capacity()`] method to prevent excessive\n+    /// re-allocation.\n+    ///\n+    /// [`with_capacity()`]: #method.with_capacity\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// # #![allow(unused_mut)]\n-    /// let mut s = String::new();\n+    /// let s = String::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> String {\n         String { vec: Vec::new() }\n     }\n \n-    /// Creates a new string buffer with the given capacity.\n-    /// The string will be able to hold exactly `capacity` bytes without\n-    /// reallocating. If `capacity` is 0, the string will not allocate.\n+    /// Creates a new empty `String` with a particular capacity.\n+    ///\n+    /// `String`s have an internal buffer to hold their data. The capacity is\n+    /// the length of that buffer, and can be queried with the [`capacity()`]\n+    /// method. This method creates an empty `String`, but one with an initial\n+    /// buffer that can hold `capacity` bytes. This is useful when you may be\n+    /// appending a bunch of data to the `String`, reducing the number of\n+    /// reallocations it needs to do.\n+    ///\n+    /// [`capacity()`]: #method.capacity\n+    ///\n+    /// If the given capacity is `0`, no allocation will occur, and this method\n+    /// is identical to the [`new()`] method.\n+    ///\n+    /// [`new()`]: #method.new\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::with_capacity(10);\n     ///\n@@ -346,26 +370,30 @@ impl String {\n \n     /// Converts a vector of bytes to a `String`.\n     ///\n-    /// A string slice (`&str`) is made of bytes (`u8`), and a vector of bytes\n-    /// (`Vec<u8>`) is made of bytes, so this function converts between the\n+    /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a vector of bytes\n+    /// ([`Vec<u8>`]) is made of bytes, so this function converts between the\n     /// two. Not all byte slices are valid `String`s, however: `String`\n     /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n     /// the bytes are valid UTF-8, and then does the conversion.\n     ///\n+    /// [`&str`]: ../primitive.str.html\n+    /// [`u8`]: ../primitive.u8.html\n+    /// [`Vec<u8>`]: ../vec/struct.Vec.html\n+    ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the validity check, there is an unsafe version\n-    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n-    /// same behavior but skips the check.\n+    /// of this function, [`from_utf8_unchecked()`], which has the same behavior\n+    /// but skips the check.\n     ///\n-    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    /// [`from_utf8_unchecked()`]: struct.String.html#method.from_utf8_unchecked\n     ///\n     /// This method will take care to not copy the vector, for efficiency's\n     /// sake.\n     ///\n     /// If you need a `&str` instead of a `String`, consider\n-    /// [`str::from_utf8()`][str].\n+    /// [`str::from_utf8()`].\n     ///\n-    /// [str]: ../str/fn.from_utf8.html\n+    /// [`str::from_utf8()`]: ../str/fn.from_utf8.html\n     ///\n     /// # Failure\n     ///\n@@ -395,10 +423,10 @@ impl String {\n     /// assert!(String::from_utf8(sparkle_heart).is_err());\n     /// ```\n     ///\n-    /// See the docs for [`FromUtf8Error`][error] for more details on what you\n-    /// can do with this error.\n+    /// See the docs for [`FromUtf8Error`] for more details on what you can do\n+    /// with this error.\n     ///\n-    /// [error]: struct.FromUtf8Error.html\n+    /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -415,24 +443,28 @@ impl String {\n \n     /// Converts a slice of bytes to a `String`, including invalid characters.\n     ///\n-    /// A string slice (`&str`) is made of bytes (`u8`), and a slice of bytes\n-    /// (`&[u8]`) is made of bytes, so this function converts between the two.\n-    /// Not all byte slices are valid string slices, however: `&str` requires\n-    /// that it is valid UTF-8. During this conversion, `from_utf8_lossy()`\n-    /// will replace any invalid UTF-8 sequences with\n+    /// A string slice ([`&str`]) is made of bytes ([`u8`]), and a slice of\n+    /// bytes ([`&[u8]`]) is made of bytes, so this function converts between\n+    /// the two. Not all byte slices are valid string slices, however: [`&str`]\n+    /// requires that it is valid UTF-8. During this conversion,\n+    /// `from_utf8_lossy()` will replace any invalid UTF-8 sequences with\n     /// `U+FFFD REPLACEMENT CHARACTER`, which looks like this: \ufffd\n     ///\n+    /// [`&str`]: ../primitive.str.html\n+    /// [`u8`]: ../primitive.u8.html\n+    /// [`&[u8]`]: ../primitive.slice.html\n+    ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the conversion, there is an unsafe version\n-    /// of this function, [`from_utf8_unchecked()`][fromutf8], which has the\n-    /// same behavior but skips the checks.\n+    /// of this function, [`from_utf8_unchecked()`], which has the same behavior\n+    /// but skips the checks.\n     ///\n-    /// [fromutf8]: struct.String.html#method.from_utf8_unchecked\n+    /// [`from_utf8_unchecked()`]: struct.String.html#method.from_utf8_unchecked\n     ///\n-    /// If you need a `&str` instead of a `String`, consider\n-    /// [`str::from_utf8()`][str].\n+    /// If you need a [`&str`] instead of a `String`, consider\n+    /// [`str::from_utf8()`].\n     ///\n-    /// [str]: ../str/fn.from_utf8.html\n+    /// [`str::from_utf8()`]: ../str/fn.from_utf8.html\n     ///\n     /// # Examples\n     ///\n@@ -576,12 +608,14 @@ impl String {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// // \ud834\udd1emusic\n     /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///           0x0073, 0x0069, 0x0063];\n-    /// assert_eq!(String::from_utf16(v).unwrap(),\n-    ///            \"\ud834\udd1emusic\".to_string());\n+    /// assert_eq!(String::from(\"\ud834\udd1emusic\"),\n+    ///            String::from_utf16(v).unwrap());\n     ///\n     /// // \ud834\udd1emu<invalid>ic\n     /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n@@ -598,14 +632,16 @@ impl String {\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// // \ud834\udd1emus<invalid>ic<invalid>\n     /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n     ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n     ///           0xD834];\n     ///\n-    /// assert_eq!(String::from_utf16_lossy(v),\n-    ///            \"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\".to_string());\n+    /// assert_eq!(String::from(\"\ud834\udd1emus\\u{FFFD}ic\\u{FFFD}\"),\n+    ///            String::from_utf16_lossy(v));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -617,13 +653,37 @@ impl String {\n     ///\n     /// # Safety\n     ///\n-    /// This is _very_ unsafe because:\n+    /// This is highly unsafe, due to the number of invariants that aren't\n+    /// checked:\n     ///\n-    /// * We call `Vec::from_raw_parts` to get a `Vec<u8>`. Therefore, this\n-    ///   function inherits all of its unsafety, see [its\n-    ///   documentation](../vec/struct.Vec.html#method.from_raw_parts)\n-    ///   for the invariants it expects, they also apply to this function.\n-    /// * We assume that the `Vec` contains valid UTF-8.\n+    /// * The memory at `ptr` needs to have been previously allocated by the\n+    ///   same allocator the standard library uses.\n+    /// * `length` needs to be less than or equal to `capacity`.\n+    /// * `capacity` needs to be the correct value.\n+    ///\n+    /// Violating these may cause problems like corrupting the allocator's\n+    /// internal datastructures.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    ///\n+    /// unsafe {\n+    ///     let s = String::from(\"hello\");\n+    ///     let ptr = s.as_ptr();\n+    ///     let len = s.len();\n+    ///     let capacity = s.capacity();\n+    ///\n+    ///     mem::forget(s);\n+    ///\n+    ///     let s = String::from_raw_parts(ptr as *mut _, len, capacity);\n+    ///\n+    ///     assert_eq!(String::from(\"hello\"), s);\n+    /// }\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_raw_parts(buf: *mut u8, length: usize, capacity: usize) -> String {\n@@ -633,15 +693,16 @@ impl String {\n     /// Converts a vector of bytes to a `String` without checking that the\n     /// string contains valid UTF-8.\n     ///\n-    /// See the safe version, [`from_utf8()`][fromutf8], for more.\n+    /// See the safe version, [`from_utf8()`], for more details.\n     ///\n-    /// [fromutf8]: struct.String.html#method.from_utf8\n+    /// [`from_utf8()`]: struct.String.html#method.from_utf8\n     ///\n     /// # Safety\n     ///\n-    /// This function is unsafe because it does not check that the bytes passed to\n-    /// it are valid UTF-8. If this constraint is violated, undefined behavior\n-    /// results, as the rest of Rust assumes that `String`s are valid UTF-8.\n+    /// This function is unsafe because it does not check that the bytes passed\n+    /// to it are valid UTF-8. If this constraint is violated, it may cause\n+    /// memory unsafety issues with future users of the `String`, as the rest of\n+    /// the standard library assumes that `String`s are valid UTF-8.\n     ///\n     /// # Examples\n     ///\n@@ -663,14 +724,19 @@ impl String {\n         String { vec: bytes }\n     }\n \n-    /// Returns the underlying byte buffer, encoded as UTF-8.\n+    /// Converts a `String` into a byte vector.\n+    ///\n+    /// This consumes the `String`, so we do not need to copy its contents.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = String::from(\"hello\");\n     /// let bytes = s.into_bytes();\n-    /// assert_eq!(bytes, [104, 101, 108, 108, 111]);\n+    ///\n+    /// assert_eq!(&[104, 101, 108, 108, 111][..], &bytes[..]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -687,28 +753,34 @@ impl String {\n         self\n     }\n \n-    /// Pushes the given string onto this string buffer.\n+    /// Appends a given string slice onto the end of this `String`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"foo\");\n+    ///\n     /// s.push_str(\"bar\");\n-    /// assert_eq!(s, \"foobar\");\n+    ///\n+    /// assert_eq!(\"foobar\", s);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_str(&mut self, string: &str) {\n         self.vec.extend_from_slice(string.as_bytes())\n     }\n \n-    /// Returns the number of bytes that this string buffer can hold without\n-    /// reallocating.\n+    /// Returns this `String`'s capacity, in bytes.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = String::with_capacity(10);\n+    ///\n     /// assert!(s.capacity() >= 10);\n     /// ```\n     #[inline]\n@@ -717,79 +789,138 @@ impl String {\n         self.vec.capacity()\n     }\n \n-    /// Reserves capacity for at least `additional` more bytes to be inserted\n-    /// in the given `String`. The collection may reserve more space to avoid\n-    /// frequent reallocations.\n+    /// Ensures that this `String`'s capacity is at least `additional` bytes\n+    /// larger than its length.\n+    ///\n+    /// The capacity may be increased by more than `additional` bytes if it\n+    /// chooses, to prevent frequent reallocations.\n+    ///\n+    /// If you do not want this \"at least\" behavior, see the [`reserve_exact()`]\n+    /// method.\n+    ///\n+    /// [`reserve_exact()`]: #method.reserve_exact\n     ///\n     /// # Panics\n     ///\n     /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::new();\n+    ///\n     /// s.reserve(10);\n+    ///\n     /// assert!(s.capacity() >= 10);\n     /// ```\n+    ///\n+    /// This may not actually increase the capacity:\n+    ///\n+    /// ```\n+    /// let mut s = String::with_capacity(10);\n+    /// s.push('a');\n+    /// s.push('b');\n+    ///\n+    /// // s now has a length of 2 and a capacity of 10\n+    /// assert_eq!(2, s.len());\n+    /// assert_eq!(10, s.capacity());\n+    ///\n+    /// // Since we already have an extra 8 capacity, calling this...\n+    /// s.reserve(8);\n+    ///\n+    /// // ... doesn't actually increase.\n+    /// assert_eq!(10, s.capacity());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         self.vec.reserve(additional)\n     }\n \n-    /// Reserves the minimum capacity for exactly `additional` more bytes to be\n-    /// inserted in the given `String`. Does nothing if the capacity is already\n-    /// sufficient.\n+    /// Ensures that this `String`'s capacity is `additional` bytes\n+    /// larger than its length.\n     ///\n-    /// Note that the allocator may give the collection more space than it\n-    /// requests. Therefore capacity can not be relied upon to be precisely\n-    /// minimal. Prefer `reserve` if future insertions are expected.\n+    /// Consider using the [`reserve()`] method unless you absolutely know\n+    /// better than the allocator.\n+    ///\n+    /// [`reserve()`]: #method.reserve\n     ///\n     /// # Panics\n     ///\n     /// Panics if the new capacity overflows `usize`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::new();\n+    ///\n     /// s.reserve_exact(10);\n+    ///\n     /// assert!(s.capacity() >= 10);\n     /// ```\n+    ///\n+    /// This may not actually increase the capacity:\n+    ///\n+    /// ```\n+    /// let mut s = String::with_capacity(10);\n+    /// s.push('a');\n+    /// s.push('b');\n+    ///\n+    /// // s now has a length of 2 and a capacity of 10\n+    /// assert_eq!(2, s.len());\n+    /// assert_eq!(10, s.capacity());\n+    ///\n+    /// // Since we already have an extra 8 capacity, calling this...\n+    /// s.reserve_exact(8);\n+    ///\n+    /// // ... doesn't actually increase.\n+    /// assert_eq!(10, s.capacity());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.vec.reserve_exact(additional)\n     }\n \n-    /// Shrinks the capacity of this string buffer to match its length.\n+    /// Shrinks the capacity of this `String` to match its length.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"foo\");\n+    ///\n     /// s.reserve(100);\n     /// assert!(s.capacity() >= 100);\n+    ///\n     /// s.shrink_to_fit();\n-    /// assert_eq!(s.capacity(), 3);\n+    /// assert_eq!(3, s.capacity());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.vec.shrink_to_fit()\n     }\n \n-    /// Adds the given character to the end of the string.\n+    /// Appends the given `char` to the end of this `String`.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"abc\");\n+    ///\n     /// s.push('1');\n     /// s.push('2');\n     /// s.push('3');\n-    /// assert_eq!(s, \"abc123\");\n+    ///\n+    /// assert_eq!(\"abc123\", s);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -815,33 +946,42 @@ impl String {\n         }\n     }\n \n-    /// Works with the underlying buffer as a byte slice.\n+    /// Returns a byte slice of this `String`'s contents.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let s = String::from(\"hello\");\n-    /// assert_eq!(s.as_bytes(), [104, 101, 108, 108, 111]);\n+    ///\n+    /// assert_eq!(&[104, 101, 108, 108, 111], s.as_bytes());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.vec\n     }\n \n-    /// Shortens a string to the specified length.\n+    /// Shortens this `String` to the specified length.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `new_len` > current length,\n-    /// or if `new_len` is not a character boundary.\n+    /// Panics if `new_len` > current length, or if `new_len` does not lie on a\n+    /// [`char`] boundary.\n+    ///\n+    /// [`char`]: ../primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"hello\");\n+    ///\n     /// s.truncate(2);\n-    /// assert_eq!(s, \"he\");\n+    ///\n+    /// assert_eq!(\"he\", s);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -851,15 +991,20 @@ impl String {\n     }\n \n     /// Removes the last character from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n+    ///\n+    /// Returns `None` if this `String` is empty.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"foo\");\n+    ///\n     /// assert_eq!(s.pop(), Some('o'));\n     /// assert_eq!(s.pop(), Some('o'));\n     /// assert_eq!(s.pop(), Some('f'));\n+    ///\n     /// assert_eq!(s.pop(), None);\n     /// ```\n     #[inline]\n@@ -877,23 +1022,25 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes the character from the string buffer at byte position `idx` and\n-    /// returns it.\n+    /// Removes a `char` from this `String` at a byte position and returns it.\n     ///\n-    /// # Warning\n-    ///\n-    /// This is an O(n) operation as it requires copying every element in the\n+    /// This is an `O(n)` operation, as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n     ///\n-    /// If `idx` does not lie on a character boundary, or if it is out of\n-    /// bounds, then this function will panic.\n+    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n+    /// lie on a [`char`] boundary.\n+    ///\n+    /// [`char`]: ../primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"foo\");\n+    ///\n     /// assert_eq!(s.remove(0), 'f');\n     /// assert_eq!(s.remove(1), 'o');\n     /// assert_eq!(s.remove(0), 'o');\n@@ -915,17 +1062,31 @@ impl String {\n         ch\n     }\n \n-    /// Inserts a character into the string buffer at byte position `idx`.\n-    ///\n-    /// # Warning\n+    /// Inserts a character into this `String` at a byte position.\n     ///\n-    /// This is an O(n) operation as it requires copying every element in the\n+    /// This is an `O(n)` operation as it requires copying every element in the\n     /// buffer.\n     ///\n     /// # Panics\n     ///\n-    /// If `idx` does not lie on a character boundary or is out of bounds, then\n-    /// this function will panic.\n+    /// Panics if `idx` is larger than the `String`'s length, or if it does not\n+    /// lie on a [`char`] boundary.\n+    ///\n+    /// [`char`]: ../primitive.char.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let mut s = String::with_capacity(3);\n+    ///\n+    /// s.insert(0, 'f');\n+    /// s.insert(1, 'o');\n+    /// s.insert(2, 'o');\n+    ///\n+    /// assert_eq!(\"foo\", s);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: usize, ch: char) {\n@@ -947,18 +1108,26 @@ impl String {\n         }\n     }\n \n-    /// Views the string buffer as a mutable sequence of bytes.\n+    /// Returns a mutable reference to the contents of this `String`.\n     ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n+    /// # Safety\n+    ///\n+    /// This function is unsafe because it does not check that the bytes passed\n+    /// to it are valid UTF-8. If this constraint is violated, it may cause\n+    /// memory unsafety issues with future users of the `String`, as the rest of\n+    /// the standard library assumes that `String`s are valid UTF-8.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"hello\");\n+    ///\n     /// unsafe {\n     ///     let vec = s.as_mut_vec();\n-    ///     assert!(vec == &[104, 101, 108, 108, 111]);\n+    ///     assert_eq!(&[104, 101, 108, 108, 111][..], &vec[..]);\n+    ///\n     ///     vec.reverse();\n     /// }\n     /// assert_eq!(s, \"olleh\");\n@@ -969,12 +1138,15 @@ impl String {\n         &mut self.vec\n     }\n \n-    /// Returns the number of bytes in this string.\n+    /// Returns the length of this `String`, in bytes.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let a = \"foo\".to_string();\n+    /// let a = String::from(\"foo\");\n+    ///\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n@@ -983,13 +1155,18 @@ impl String {\n         self.vec.len()\n     }\n \n-    /// Returns true if the string contains no bytes\n+    /// Returns `true` if this `String` has a length of zero.\n+    ///\n+    /// Returns `false` otherwise.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut v = String::new();\n     /// assert!(v.is_empty());\n+    ///\n     /// v.push('a');\n     /// assert!(!v.is_empty());\n     /// ```\n@@ -999,14 +1176,23 @@ impl String {\n         self.len() == 0\n     }\n \n-    /// Truncates the string, returning it to 0 length.\n+    /// Truncates this `String`, removing all contents.\n+    ///\n+    /// While this means the `String` will have a length of zero, it does not\n+    /// touch its capacity.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let mut s = \"foo\".to_string();\n+    /// let mut s = String::from(\"foo\");\n+    ///\n     /// s.clear();\n+    ///\n     /// assert!(s.is_empty());\n+    /// assert_eq!(0, s.len());\n+    /// assert_eq!(3, s.capacity());\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1020,11 +1206,15 @@ impl String {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the starting point or end point are not on character boundaries,\n-    /// or if they are out of bounds.\n+    /// Panics if the starting point or end point do not lie on a [`char`]\n+    /// boundary, or if they're out of bounds.\n+    ///\n+    /// [`char`]: ../primitive.char.html\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n     /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n@@ -1066,9 +1256,19 @@ impl String {\n         }\n     }\n \n-    /// Converts the string into `Box<str>`.\n+    /// Converts this `String` into a `Box<str>`.\n+    ///\n+    /// This will drop any excess capacity.\n     ///\n-    /// Note that this will drop any excess capacity.\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = String::from(\"hello\");\n+    ///\n+    /// let b = s.into_boxed_str();\n+    /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n     pub fn into_boxed_str(self) -> Box<str> {\n         let slice = self.vec.into_boxed_slice();"}]}