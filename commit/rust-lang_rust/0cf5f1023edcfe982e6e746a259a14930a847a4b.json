{"sha": "0cf5f1023edcfe982e6e746a259a14930a847a4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZjVmMTAyM2VkY2ZlOTgyZTZlNzQ2YTI1OWExNDkzMGE4NDdhNGI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T14:16:42Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T14:16:42Z"}, "message": "Replaced use of `interpret` method in `mir::dataflow::graphviz` with a client-provided closure.", "tree": {"sha": "e0a4b808de19ea4cc3c5e5ad38b6a79abecd29dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a4b808de19ea4cc3c5e5ad38b6a79abecd29dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cf5f1023edcfe982e6e746a259a14930a847a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf5f1023edcfe982e6e746a259a14930a847a4b", "html_url": "https://github.com/rust-lang/rust/commit/0cf5f1023edcfe982e6e746a259a14930a847a4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cf5f1023edcfe982e6e746a259a14930a847a4b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "221cce915a4dfae69ca42536215a5b0c0538047e", "url": "https://api.github.com/repos/rust-lang/rust/commits/221cce915a4dfae69ca42536215a5b0c0538047e", "html_url": "https://github.com/rust-lang/rust/commit/221cce915a4dfae69ca42536215a5b0c0538047e"}], "stats": {"total": 170, "additions": 94, "deletions": 76}, "files": [{"sha": "8b7f04287bc2c7581cf1e51e8af5b97e98c6fd69", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=0cf5f1023edcfe982e6e746a259a14930a847a4b", "patch": "@@ -21,23 +21,73 @@ use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::marker::PhantomData;\n+use std::mem;\n use std::path::Path;\n \n+use super::super::gather_moves::{MoveData};\n use super::super::MirBorrowckCtxtPreDataflow;\n use bitslice::bits_to_string;\n+use indexed_set::{Idx, IdxSet};\n use super::{BitDenotation, DataflowState};\n-use super::{HasMoveData};\n+\n+impl<O: BitDenotation> DataflowState<O> {\n+    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &IdxSet<O::Idx>, mut f: F)\n+        where F: FnMut(O::Idx) {\n+        //! Helper for iterating over the bits in a bitvector.\n+\n+        let bits_per_block = self.operator.bits_per_block(ctxt);\n+        let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+        for (word_index, &word) in words.words().iter().enumerate() {\n+            if word != 0 {\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of usize::BITS. This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value; that's why we first check\n+                        // that we are in range of bits_per_block.\n+                        let bit_index = base_index + offset as usize;\n+                        if bit_index >= bits_per_block {\n+                            return;\n+                        } else {\n+                            f(O::Idx::new(bit_index));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn interpret_set<'c, P>(&self,\n+                                ctxt: &'c O::Ctxt,\n+                                words: &IdxSet<O::Idx>,\n+                                render_idx: &P)\n+                                -> Vec<&'c Debug>\n+        where P: for <'b> Fn(&'b O::Ctxt, O::Idx) -> &'b Debug\n+    {\n+        let mut v = Vec::new();\n+        self.each_bit(ctxt, words, |i| {\n+            v.push(render_idx(ctxt, i));\n+        });\n+        v\n+    }\n+}\n \n pub trait MirWithFlowState<'tcx> {\n-    type BD: BitDenotation;\n+    type BD: BitDenotation<Ctxt=MoveData<'tcx>>;\n     fn node_id(&self) -> NodeId;\n     fn mir(&self) -> &Mir<'tcx>;\n     fn analysis_ctxt(&self) -> &<Self::BD as BitDenotation>::Ctxt;\n     fn flow_state(&self) -> &DataflowState<Self::BD>;\n }\n \n impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where 'a, 'tcx: 'a, BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+    where 'a, 'tcx: 'a, BD: BitDenotation<Ctxt=MoveData<'tcx>>\n {\n     type BD = BD;\n     fn node_id(&self) -> NodeId { self.node_id }\n@@ -46,19 +96,23 @@ impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a,\n     fn flow_state(&self) -> &DataflowState<Self::BD> { &self.flow_state.flow_state }\n }\n \n-struct Graph<'a, 'tcx, MWF:'a> where MWF: MirWithFlowState<'tcx>,\n+struct Graph<'a, 'tcx, MWF:'a, P> where\n+    MWF: MirWithFlowState<'tcx>\n {\n     mbcx: &'a MWF,\n-    phantom: PhantomData<&'tcx ()>\n+    phantom: PhantomData<&'tcx ()>,\n+    render_idx: P,\n }\n \n-pub fn print_borrowck_graph_to<'a, 'tcx, BD>(\n+pub fn print_borrowck_graph_to<'a, 'tcx, BD, P>(\n     mbcx: &MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>,\n-    path: &Path)\n+    path: &Path,\n+    render_idx: P)\n     -> io::Result<()>\n-    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>,\n+    where BD: BitDenotation<Ctxt=MoveData<'tcx>>, BD::Bit: Debug,\n+          P: for <'b> Fn(&'b BD::Ctxt, BD::Idx) -> &'b Debug\n {\n-    let g = Graph { mbcx: mbcx, phantom: PhantomData };\n+    let g = Graph { mbcx: mbcx, phantom: PhantomData, render_idx: render_idx };\n     let mut v = Vec::new();\n     dot::render(&g, &mut v)?;\n     debug!(\"print_borrowck_graph_to path: {} node_id: {}\",\n@@ -76,8 +130,9 @@ fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n     (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n }\n \n-impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n-    where MWF: MirWithFlowState<'tcx>, <MWF::BD as BitDenotation>::Bit: Debug\n+impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n+    where MWF: MirWithFlowState<'tcx>, <MWF::BD as BitDenotation>::Bit: Debug,\n+          P: for <'b> Fn(&'b <MWF::BD as BitDenotation>::Ctxt, <MWF::BD as BitDenotation>::Idx) -> &'b Debug,\n {\n     type Node = Node;\n     type Edge = Edge;\n@@ -136,10 +191,10 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n         const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n         const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n         const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n-        fn chunked_present_left<D: Debug, W:io::Write>(w: &mut W,\n-                                                       interpreted: &[&D],\n-                                                       chunk_size: usize)\n-                                                       -> io::Result<()>\n+        fn chunked_present_left<W:io::Write>(w: &mut W,\n+                                             interpreted: &[&Debug],\n+                                             chunk_size: usize)\n+                                             -> io::Result<()>\n         {\n             // This function may emit a sequence of <tr>'s, but it\n             // always finishes with an (unfinished)\n@@ -171,7 +226,9 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n             |w| {\n                 let ctxt = self.mbcx.analysis_ctxt();\n                 let flow = self.mbcx.flow_state();\n-                let entry_interp = flow.interpret_set(ctxt, flow.sets.on_entry_set_for(i));\n+                let entry_interp = flow.interpret_set(ctxt,\n+                                                      flow.sets.on_entry_set_for(i),\n+                                                      &self.render_idx);\n                 chunked_present_left(w, &entry_interp[..], chunk_size)?;\n                 let bits_per_block = flow.sets.bits_per_block();\n                 let entry = flow.sets.on_entry_set_for(i);\n@@ -186,8 +243,8 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n             |w| {\n                 let ctxt = self.mbcx.analysis_ctxt();\n                 let flow = self.mbcx.flow_state();\n-                let gen_interp = flow.interpret_set(ctxt, flow.sets.gen_set_for(i));\n-                let kill_interp = flow.interpret_set(ctxt, flow.sets.kill_set_for(i));\n+                let gen_interp = flow.interpret_set(ctxt, flow.sets.gen_set_for(i), &self.render_idx);\n+                let kill_interp = flow.interpret_set(ctxt, flow.sets.kill_set_for(i), &self.render_idx);\n                 chunked_present_left(w, &gen_interp[..], chunk_size)?;\n                 let bits_per_block = flow.sets.bits_per_block();\n                 {\n@@ -245,7 +302,7 @@ impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n     }\n }\n \n-impl<'a, 'tcx, MWF> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF>\n+impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n     where MWF: MirWithFlowState<'tcx>\n {\n     type Node = Node;"}, {"sha": "fb8d2ec3922431a7340b6715933f94caca9a60f9", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 16, "deletions": 55, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=0cf5f1023edcfe982e6e746a259a14930a847a4b", "patch": "@@ -31,20 +31,19 @@ mod graphviz;\n mod sanity_check;\n mod impls;\n \n-pub trait Dataflow {\n-    fn dataflow(&mut self);\n+pub trait Dataflow<BD: BitDenotation> {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug;\n }\n \n-impl<'a, 'tcx: 'a, BD> Dataflow for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where BD: BitDenotation + DataflowOperator,\n+impl<'a, 'tcx: 'a, BD> Dataflow<BD> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where BD: BitDenotation<Ctxt=MoveData<'tcx>> + DataflowOperator,\n           BD::Bit: Debug,\n-          BD::Ctxt: HasMoveData<'tcx>\n {\n-    fn dataflow(&mut self) {\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug {\n         self.flow_state.build_sets();\n-        self.pre_dataflow_instrumentation().unwrap();\n+        self.pre_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n         self.flow_state.propagate();\n-        self.post_dataflow_instrumentation().unwrap();\n+        self.post_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n     }\n }\n \n@@ -142,21 +141,25 @@ fn dataflow_path(context: &str, prepost: &str, path: &str) -> PathBuf {\n }\n \n impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n-    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+    where BD: BitDenotation<Ctxt=MoveData<'tcx>>, BD::Bit: Debug\n {\n-    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n+    fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n+        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+    {\n         if let Some(ref path_str) = self.print_preflow_to {\n             let path = dataflow_path(BD::name(), \"preflow\", path_str);\n-            graphviz::print_borrowck_graph_to(self, &path)\n+            graphviz::print_borrowck_graph_to(self, &path, p)\n         } else {\n             Ok(())\n         }\n     }\n \n-    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n+    fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n+        where P: Fn(&BD::Ctxt, BD::Idx) -> &Debug\n+    {\n         if let Some(ref path_str) = self.print_postflow_to {\n             let path = dataflow_path(BD::name(), \"postflow\", path_str);\n-            graphviz::print_borrowck_graph_to(self, &path)\n+            graphviz::print_borrowck_graph_to(self, &path, p)\n         } else{\n             Ok(())\n         }\n@@ -291,48 +294,6 @@ impl<E:Idx> AllSets<E> {\n     }\n }\n \n-impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &IdxSet<O::Idx>, mut f: F)\n-        where F: FnMut(usize) {\n-        //! Helper for iterating over the bits in a bitvector.\n-\n-        let bits_per_block = self.operator.bits_per_block(ctxt);\n-        let usize_bits: usize = mem::size_of::<usize>() * 8;\n-\n-        for (word_index, &word) in words.words().iter().enumerate() {\n-            if word != 0 {\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS. This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value; that's why we first check\n-                        // that we are in range of bits_per_block.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= bits_per_block {\n-                            return;\n-                        } else {\n-                            f(bit_index);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn interpret_set<'c>(&self, ctxt: &'c O::Ctxt, words: &IdxSet<O::Idx>) -> Vec<&'c O::Bit> {\n-        let mut v = Vec::new();\n-        self.each_bit(ctxt, words, |i| {\n-            v.push(self.operator.interpret(ctxt, i));\n-        });\n-        v\n-    }\n-}\n-\n /// Parameterization for the precise form of data flow that is used.\n pub trait DataflowOperator: BitwiseOperator {\n     /// Specifies the initial value for each bit in the `on_entry` set"}, {"sha": "92f8f91b9308128249b588b359cef14613d916f7", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cf5f1023edcfe982e6e746a259a14930a847a4b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=0cf5f1023edcfe982e6e746a259a14930a847a4b", "patch": "@@ -118,7 +118,7 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              attributes: &[ast::Attribute],\n                              ctxt: &BD::Ctxt,\n                              bd: BD) -> DataflowResults<BD>\n-    where BD: BitDenotation + DataflowOperator, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+    where BD: BitDenotation<Idx=MovePathIndex, Ctxt=MoveData<'tcx>> + DataflowOperator, BD::Bit: Debug\n {\n     use syntax::attr::AttrMetaMethods;\n \n@@ -148,7 +148,7 @@ fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         flow_state: DataflowAnalysis::new(tcx, mir, ctxt, bd),\n     };\n \n-    mbcx.dataflow();\n+    mbcx.dataflow(|move_data, i| &move_data.move_paths[i]);\n     mbcx.flow_state.results()\n }\n "}]}