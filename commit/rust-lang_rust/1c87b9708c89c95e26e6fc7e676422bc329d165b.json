{"sha": "1c87b9708c89c95e26e6fc7e676422bc329d165b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjODdiOTcwOGM4OWM5NWUyNmU2ZmM3ZTY3NjQyMmJjMzI5ZDE2NWI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-11-08T05:31:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-09T03:01:47Z"}, "message": "Removing the baked in libuv.", "tree": {"sha": "88d88abf2fb99c70826e2143e63d6372aa775172", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88d88abf2fb99c70826e2143e63d6372aa775172"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c87b9708c89c95e26e6fc7e676422bc329d165b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c87b9708c89c95e26e6fc7e676422bc329d165b", "html_url": "https://github.com/rust-lang/rust/commit/1c87b9708c89c95e26e6fc7e676422bc329d165b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c87b9708c89c95e26e6fc7e676422bc329d165b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "html_url": "https://github.com/rust-lang/rust/commit/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}], "stats": {"total": 142036, "additions": 0, "deletions": 142036}, "files": [{"sha": "09164c65eb0799d6ef1d7faa20ed305da5711127", "filename": "src/rt/libuv/.gitignore", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.gitignore?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,29 +0,0 @@\n-*.swp\n-*.o\n-*.lo\n-*.la\n-*.a\n-*.opensdf\n-*.orig\n-*.sdf\n-*.suo\n-/out/\n-/build/gyp\n-\n-/test/run-tests\n-/test/run-tests.exe\n-/test/run-tests.dSYM\n-/test/run-benchmarks\n-/test/run-benchmarks.exe\n-/test/run-benchmarks.dSYM\n-\n-*.sln\n-*.vcproj\n-*.vcxproj\n-*.vcxproj.filters\n-*.vcxproj.user\n-_UpgradeReport_Files/\n-UpgradeLog*.XML\n-Debug\n-Release\n-ipch"}, {"sha": "2d608f95f4f16995b328057644254b4d0b21801b", "filename": "src/rt/libuv/.mailmap", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2F.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2F.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2F.mailmap?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,10 +0,0 @@\n-# update AUTHORS with:\n-#   git log --all --reverse --format='%aN <%aE>' | perl -ne 'BEGIN{print \"# Authors ordered by first contribution.\\n\"} print unless $h{$_}; $h{$_} = 1' > AUTHORS\n-<rm@joyent.com> <rm@fingolfin.org>\n-<ryan@joyent.com> <ry@tinyclouds.org>\n-<bertbelder@gmail.com> <info@2bs.nl>\n-<alan@prettyrobots.com> <alan@blogometer.com>\n-San-Tai Hsu <vanilla@fatpipi.com>\n-Isaac Z. Schlueter <i@izs.me>\n-Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>\n-Yuki OKUMURA <mjt@cltn.org>"}, {"sha": "2d43c3661416c2c422fe927b4700d493844af73a", "filename": "src/rt/libuv/AUTHORS", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FAUTHORS?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,33 +0,0 @@\n-# Authors ordered by first contribution.\n-Ryan Dahl <ryan@joyent.com>\n-Bert Belder <bertbelder@gmail.com>\n-Josh Roesslein <jroesslein@gmail.com>\n-Alan Gutierrez <alan@prettyrobots.com>\n-Joshua Peek <josh@joshpeek.com>\n-Igor Zinkovsky <igorzi@microsoft.com>\n-San-Tai Hsu <vanilla@fatpipi.com>\n-Ben Noordhuis <info@bnoordhuis.nl>\n-Henry Rawas <henryr@schakra.com>\n-Robert Mustacchi <rm@joyent.com>\n-Matt Stevens <matt@alloysoft.com>\n-Paul Querna <pquerna@apache.org>\n-Shigeki Ohtsu <ohtsu@iij.ad.jp>\n-Tom Hughes <tom.hughes@palm.com>\n-Peter Bright <drpizza@quiscalusmexicanus.org>\n-Jeroen Janssen <jeroen.janssen@gmail.com>\n-Andrea Lattuada <ndr.lattuada@gmail.com>\n-Augusto Henrique Hentz <ahhentz@gmail.com>\n-Clifford Heath <clifford.heath@gmail.com>\n-Jorge Chamorro Bieling <jorge@jorgechamorro.com>\n-Luis Lavena <luislavena@gmail.com>\n-Matthew Sporleder <msporleder@gmail.com>\n-Erick Tryzelaar <erick.tryzelaar@gmail.com>\n-Isaac Z. Schlueter <i@izs.me>\n-Pieter Noordhuis <pcnoordhuis@gmail.com>\n-Marek Jelen <marek@jelen.biz>\n-Fedor Indutny <fedor.indutny@gmail.com>\n-Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>\n-Felix Geisendo\u0308rfer <felix@debuggable.com>\n-Yuki OKUMURA <mjt@cltn.org>\n-Roman Shtylman <shtylman@gmail.com>\n-Frank DENIS <github@pureftpd.org>"}, {"sha": "f7df47f71c9c57f9600cf1ac8aeb6e059d303949", "filename": "src/rt/libuv/LICENSE", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FLICENSE?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,40 +0,0 @@\n-libuv is part of the Node project: http://nodejs.org/\n-libuv may be distributed alone under Node's license:\n-\n-====\n-\n-Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to\n-deal in the Software without restriction, including without limitation the\n-rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n-sell copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included in\n-all copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n-FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n-IN THE SOFTWARE.\n-\n-====\n-\n-This license applies to all parts of libuv that are not externally\n-maintained libraries.\n-\n-The externally maintained libraries used by libuv are:\n-\n-  - tree.h (from FreeBSD), copyright Niels Provos. Two clause BSD license.\n-\n-  - ngx_queue.h (from Nginx), copyright Igor Sysoev. Two clause BSD license.\n-\n-  - libev, located at ev/ is copyright Marc Alexander Lehmann, and\n-    dual-licensed under the MIT license and GPL2.\n-\n-  - libeio, located at eio/ is copyright Marc Alexander Lehmann, and\n-    dual-licensed under the MIT license and GPL2."}, {"sha": "cf1e7880bfac42b525dfe3cb126c2b823b23453b", "filename": "src/rt/libuv/Makefile", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FMakefile?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,119 +0,0 @@\n-# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n-#\n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to\n-# deal in the Software without restriction, including without limitation the\n-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n-# sell copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-#\n-# The above copyright notice and this permission notice shall be included in\n-# all copies or substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n-# IN THE SOFTWARE.\n-\n-uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')\n-\n-ifdef MSVC\n-uname_S := MINGW\n-endif\n-\n-CPPFLAGS += -Iinclude -Iinclude/uv-private\n-\n-CARES_OBJS =\n-CARES_OBJS += src/ares/ares__close_sockets.o\n-CARES_OBJS += src/ares/ares__get_hostent.o\n-CARES_OBJS += src/ares/ares__read_line.o\n-CARES_OBJS += src/ares/ares__timeval.o\n-CARES_OBJS += src/ares/ares_cancel.o\n-CARES_OBJS += src/ares/ares_data.o\n-CARES_OBJS += src/ares/ares_destroy.o\n-CARES_OBJS += src/ares/ares_expand_name.o\n-CARES_OBJS += src/ares/ares_expand_string.o\n-CARES_OBJS += src/ares/ares_fds.o\n-CARES_OBJS += src/ares/ares_free_hostent.o\n-CARES_OBJS += src/ares/ares_free_string.o\n-CARES_OBJS += src/ares/ares_gethostbyaddr.o\n-CARES_OBJS += src/ares/ares_gethostbyname.o\n-CARES_OBJS += src/ares/ares_getnameinfo.o\n-CARES_OBJS += src/ares/ares_getopt.o\n-CARES_OBJS += src/ares/ares_getsock.o\n-CARES_OBJS += src/ares/ares_init.o\n-CARES_OBJS += src/ares/ares_library_init.o\n-CARES_OBJS += src/ares/ares_llist.o\n-CARES_OBJS += src/ares/ares_mkquery.o\n-CARES_OBJS += src/ares/ares_nowarn.o\n-CARES_OBJS += src/ares/ares_options.o\n-CARES_OBJS += src/ares/ares_parse_a_reply.o\n-CARES_OBJS += src/ares/ares_parse_aaaa_reply.o\n-CARES_OBJS += src/ares/ares_parse_mx_reply.o\n-CARES_OBJS += src/ares/ares_parse_ns_reply.o\n-CARES_OBJS += src/ares/ares_parse_ptr_reply.o\n-CARES_OBJS += src/ares/ares_parse_srv_reply.o\n-CARES_OBJS += src/ares/ares_parse_txt_reply.o\n-CARES_OBJS += src/ares/ares_process.o\n-CARES_OBJS += src/ares/ares_query.o\n-CARES_OBJS += src/ares/ares_search.o\n-CARES_OBJS += src/ares/ares_send.o\n-CARES_OBJS += src/ares/ares_strcasecmp.o\n-CARES_OBJS += src/ares/ares_strdup.o\n-CARES_OBJS += src/ares/ares_strerror.o\n-CARES_OBJS += src/ares/ares_timeout.o\n-CARES_OBJS += src/ares/ares_version.o\n-CARES_OBJS += src/ares/ares_writev.o\n-CARES_OBJS += src/ares/bitncmp.o\n-CARES_OBJS += src/ares/inet_net_pton.o\n-CARES_OBJS += src/ares/inet_ntop.o\n-\n-ifneq (,$(findstring MINGW,$(uname_S)))\n-include config-mingw.mk\n-else\n-include config-unix.mk\n-endif\n-\n-TESTS=test/blackhole-server.c test/echo-server.c test/test-*.c\n-BENCHMARKS=test/blackhole-server.c test/echo-server.c test/dns-server.c test/benchmark-*.c\n-\n-all: uv.a\n-\n-$(CARES_OBJS): %.o: %.c\n-\t$(CC) -o $*.o -c $(CFLAGS) $(CPPFLAGS) $< -DHAVE_CONFIG_H\n-\n-test/run-tests$(E): test/*.h test/run-tests.c $(RUNNER_SRC) test/runner-unix.c $(TESTS) uv.a\n-\t$(CC) $(CPPFLAGS) $(RUNNER_CFLAGS) -o test/run-tests test/run-tests.c \\\n-\t\ttest/runner.c $(RUNNER_SRC) $(TESTS) uv.a $(RUNNER_LIBS) $(RUNNER_LINKFLAGS)\n-\n-test/run-benchmarks$(E): test/*.h test/run-benchmarks.c test/runner.c $(RUNNER_SRC) $(BENCHMARKS) uv.a\n-\t$(CC) $(CPPFLAGS) $(RUNNER_CFLAGS) -o test/run-benchmarks test/run-benchmarks.c \\\n-\t\t test/runner.c $(RUNNER_SRC) $(BENCHMARKS) uv.a $(RUNNER_LIBS) $(RUNNER_LINKFLAGS)\n-\n-test/echo.o: test/echo.c test/echo.h\n-\t$(CC) $(CPPFLAGS) $(CFLAGS) -c test/echo.c -o test/echo.o\n-\n-\n-.PHONY: clean clean-platform distclean distclean-platform test bench\n-\n-\n-test: test/run-tests$(E)\n-\ttest/run-tests\n-\n-#test-%:\ttest/run-tests$(E)\n-#\ttest/run-tests $(@:test-%=%)\n-\n-bench: test/run-benchmarks$(E)\n-\ttest/run-benchmarks\n-\n-#bench-%:\ttest/run-benchmarks$(E)\n-#\ttest/run-benchmarks $(@:bench-%=%)\n-\n-clean: clean-platform\n-\t$(RM) -f src/*.o *.a test/run-tests$(E) test/run-benchmarks$(E)\n-\n-distclean: distclean-platform\n-\t$(RM) -f src/*.o *.a test/run-tests$(E) test/run-benchmarks$(E)"}, {"sha": "8e569bbfb6128dd0f5f844b94b4cb864457f9711", "filename": "src/rt/libuv/README.md", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2FREADME.md?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,88 +0,0 @@\n-# libuv\n-\n-libuv is a new platform layer for Node. Its purpose is to abstract IOCP on\n-windows and libev on Unix systems. We intend to eventually contain all\n-platform differences in this library.\n-\n-http://nodejs.org/\n-\n-## Features\n-\n- * Non-blocking TCP sockets\n-\n- * Non-blocking named pipes\n-\n- * UDP\n-\n- * Timers\n-\n- * Child process spawning\n-\n- * Asynchronous DNS via c-ares or `uv_getaddrinfo`.\n-\n- * Asynchronous file system APIs `uv_fs_*`\n-\n- * High resolution time `uv_hrtime`\n-\n- * Current executable path look up `uv_exepath`\n-\n- * Thread pool scheduling `uv_queue_work`\n-\n- * ANSI escape code controlled TTY `uv_tty_t`\n-\n- * File system events Currently supports inotify, `ReadDirectoryChangesW`\n-   and kqueue. Event ports in the near future.\n-   `uv_fs_event_t`\n-\n- * IPC and socket sharing between processes `uv_write2`\n-\n-\n-## Documentation\n-\n-See `include/uv.h`.\n-\n-\n-## Build Instructions\n-\n-For GCC (including MinGW) there are two methods building: via normal\n-makefiles or via GYP. GYP is a meta-build system which can generate MSVS,\n-Makefile, and XCode backends. It is best used for integration into other\n-projects.  The old (more stable) system is using Makefiles.\n-\n-To build via Makefile simply execute:\n-\n-    make\n-\n-To build with Visual Studio run the vcbuilds.bat file which will\n-checkout the GYP code into build/gyp and generate the uv.sln and\n-related files.\n-\n-Windows users can also build from cmd-line using msbuild.  This is\n-done by running vcbuild.bat from Visual Studio command prompt.\n-\n-To have GYP generate build script for another system you will need to\n-checkout GYP into the project tree manually:\n-\n-    svn co http://gyp.googlecode.com/svn/trunk build/gyp\n-\n-Unix users run\n-\n-    ./gyp_uv -f make\n-    make\n-\n-Macintosh users run\n-\n-    ./gyp_uv -f xcode\n-    xcodebuild -project uv.xcodeproj -configuration Release -target All\n-\n-\n-## Supported Platforms\n-\n-Microsoft Windows operating systems since Windows XP SP2. It can be built\n-with either Visual Studio or MinGW.\n-\n-Linux 2.6 using the GCC toolchain.\n-\n-MacOS using the GCC or XCode toolchain.\n-\n-Solaris 121 and later using GCC toolchain."}, {"sha": "da019e866114b0a3df4d35796ab318e02db81a7d", "filename": "src/rt/libuv/build/gcc_version.py", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fbuild%2Fgcc_version.py?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,20 +0,0 @@\n-#!/usr/bin/env python\n-\n-import os\n-import re\n-import subprocess\n-import sys\n-\n-\n-def DoMain(*args):\n-  cc = os.environ.get('CC', 'gcc')\n-  stdin, stderr = os.pipe()\n-  subprocess.call([cc, '-v'], stderr=stderr)\n-  output = os.read(stdin, 4096)\n-  match = re.search(\"\\ngcc version (\\d+\\.\\d+\\.\\d+)\", output)\n-  if match:\n-    print(match.group(1))\n-\n-\n-if __name__ == '__main__':\n-  DoMain(*sys.argv)"}, {"sha": "e0eb76d267bd475d0f8d1fb98fe250e2f0f24c59", "filename": "src/rt/libuv/common.gypi", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fcommon.gypi", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fcommon.gypi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fcommon.gypi?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,177 +0,0 @@\n-{\n-  'variables': {\n-    'visibility%': 'hidden',         # V8's visibility setting\n-    'target_arch%': 'ia32',          # set v8's target architecture\n-    'host_arch%': 'ia32',            # set v8's host architecture\n-    'library%': 'static_library',    # allow override to 'shared_library' for DLL/.so builds\n-    'component%': 'static_library',  # NB. these names match with what V8 expects\n-    'msvs_multi_core_compile': '0',  # we do enable multicore compiles, but not using the V8 way\n-  },\n-\n-  'target_defaults': {\n-    'default_configuration': 'Debug',\n-    'configurations': {\n-      'Debug': {\n-        'defines': [ 'DEBUG', '_DEBUG' ],\n-        'cflags': [ '-g', '-O0' ],\n-        'msvs_settings': {\n-          'VCCLCompilerTool': {\n-            'target_conditions': [\n-              ['library==\"static_library\"', {\n-                'RuntimeLibrary': 1, # static debug\n-              }, {\n-                'RuntimeLibrary': 3, # DLL debug\n-              }],\n-            ],\n-            'Optimization': 0, # /Od, no optimization\n-            'MinimalRebuild': 'true',\n-            'OmitFramePointers': 'false',\n-            'BasicRuntimeChecks': 3, # /RTC1\n-          },\n-          'VCLinkerTool': {\n-            'LinkIncremental': 2, # enable incremental linking\n-          },\n-        },\n-        'conditions': [\n-          ['OS != \"win\"', {\n-            'defines': [ 'EV_VERIFY=2' ],\n-          }],\n-        ]\n-      },\n-      'Release': {\n-        'defines': [ 'NDEBUG' ],\n-        'cflags': [ '-O3', '-fomit-frame-pointer', '-fdata-sections', '-ffunction-sections' ],\n-        'msvs_settings': {\n-          'VCCLCompilerTool': {\n-            'target_conditions': [\n-              ['library==\"static_library\"', {\n-                'RuntimeLibrary': 0, # static release\n-              }, {\n-                'RuntimeLibrary': 2, # debug release\n-              }],\n-            ],\n-            'Optimization': 3, # /Ox, full optimization\n-            'FavorSizeOrSpeed': 1, # /Ot, favour speed over size\n-            'InlineFunctionExpansion': 2, # /Ob2, inline anything eligible\n-            'WholeProgramOptimization': 'true', # /GL, whole program optimization, needed for LTCG\n-            'OmitFramePointers': 'true',\n-            'EnableFunctionLevelLinking': 'true',\n-            'EnableIntrinsicFunctions': 'true',\n-            'AdditionalOptions': [\n-              '/MP', # compile across multiple CPUs\n-            ],\n-          },\n-          'VCLibrarianTool': {\n-            'AdditionalOptions': [\n-              '/LTCG', # link time code generation\n-            ],\n-          },\n-          'VCLinkerTool': {\n-            'LinkTimeCodeGeneration': 1, # link-time code generation\n-            'OptimizeReferences': 2, # /OPT:REF\n-            'EnableCOMDATFolding': 2, # /OPT:ICF\n-            'LinkIncremental': 1, # disable incremental linking\n-          },\n-        },\n-      }\n-    },\n-    'msvs_settings': {\n-      'VCCLCompilerTool': {\n-        'StringPooling': 'true', # pool string literals\n-        'DebugInformationFormat': 3, # Generate a PDB\n-        'WarningLevel': 3,\n-        'BufferSecurityCheck': 'true',\n-        'ExceptionHandling': 1, # /EHsc\n-        'SuppressStartupBanner': 'true',\n-        'WarnAsError': 'false',\n-      },\n-      'VCLibrarianTool': {\n-      },\n-      'VCLinkerTool': {\n-        'GenerateDebugInformation': 'true',\n-        'RandomizedBaseAddress': 2, # enable ASLR\n-        'DataExecutionPrevention': 2, # enable DEP\n-        'AllowIsolation': 'true',\n-        'SuppressStartupBanner': 'true',\n-        'target_conditions': [\n-          ['_type==\"executable\"', {\n-            'SubSystem': 1, # console executable\n-          }],\n-        ],\n-      },\n-    },\n-    'conditions': [\n-      ['OS == \"win\"', {\n-        'msvs_cygwin_shell': 0, # prevent actions from trying to use cygwin\n-        'defines': [\n-          'WIN32',\n-          # we don't really want VC++ warning us about\n-          # how dangerous C functions are...\n-          '_CRT_SECURE_NO_DEPRECATE',\n-          # ... or that C implementations shouldn't use\n-          # POSIX names\n-          '_CRT_NONSTDC_NO_DEPRECATE',\n-        ],\n-      }],\n-      [ 'OS==\"linux\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"solaris\"', {\n-        'variables': {\n-          'gcc_version%': '<!(python build/gcc_version.py)>)',\n-        },\n-        'cflags': [ '-Wall' ],\n-        'cflags_cc': [ '-fno-rtti', '-fno-exceptions' ],\n-        'conditions': [\n-          [ 'host_arch != target_arch and target_arch==\"ia32\"', {\n-            'cflags': [ '-m32' ],\n-            'ldflags': [ '-m32' ],\n-          }],\n-          [ 'OS==\"linux\"', {\n-            'cflags': [ '-ansi' ],\n-          }],\n-          [ 'OS==\"solaris\"', {\n-            'cflags': [ '-pthreads' ],\n-            'ldflags': [ '-pthreads' ],\n-          }, {\n-            'cflags': [ '-pthread' ],\n-            'ldflags': [ '-pthread' ],\n-          }],\n-          [ 'visibility==\"hidden\" and gcc_version >= \"4.0.0\"', {\n-            'cflags': [ '-fvisibility=hidden' ],\n-          }],\n-        ],\n-      }],\n-      ['OS==\"mac\"', {\n-        'xcode_settings': {\n-          'ALWAYS_SEARCH_USER_PATHS': 'NO',\n-          'GCC_CW_ASM_SYNTAX': 'NO',                # No -fasm-blocks\n-          'GCC_DYNAMIC_NO_PIC': 'NO',               # No -mdynamic-no-pic\n-                                                    # (Equivalent to -fPIC)\n-          'GCC_ENABLE_CPP_EXCEPTIONS': 'NO',        # -fno-exceptions\n-          'GCC_ENABLE_CPP_RTTI': 'NO',              # -fno-rtti\n-          'GCC_ENABLE_PASCAL_STRINGS': 'NO',        # No -mpascal-strings\n-          # GCC_INLINES_ARE_PRIVATE_EXTERN maps to -fvisibility-inlines-hidden\n-          'GCC_INLINES_ARE_PRIVATE_EXTERN': 'YES',\n-          'GCC_SYMBOLS_PRIVATE_EXTERN': 'YES',      # -fvisibility=hidden\n-          'GCC_THREADSAFE_STATICS': 'NO',           # -fno-threadsafe-statics\n-          'GCC_WARN_ABOUT_MISSING_NEWLINE': 'YES',  # -Wnewline-eof\n-          'MACOSX_DEPLOYMENT_TARGET': '10.4',       # -mmacosx-version-min=10.4\n-          'PREBINDING': 'NO',                       # No -Wl,-prebind\n-          'USE_HEADERMAP': 'NO',\n-          'OTHER_CFLAGS': [\n-            '-fno-strict-aliasing',\n-          ],\n-          'WARNING_CFLAGS': [\n-            '-Wall',\n-            '-Wendif-labels',\n-            '-W',\n-            '-Wno-unused-parameter',\n-          ],\n-        },\n-        'target_conditions': [\n-          ['_type!=\"static_library\"', {\n-            'xcode_settings': {'OTHER_LDFLAGS': ['-Wl,-search_paths_first']},\n-          }],\n-        ],\n-      }],\n-    ],\n-  },\n-}"}, {"sha": "5ef189bd738673ec7a7977f25c3f68a00a18fa3c", "filename": "src/rt/libuv/config-mingw.mk", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fconfig-mingw.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-mingw.mk?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,61 +0,0 @@\n-# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n-#\n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to\n-# deal in the Software without restriction, including without limitation the\n-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n-# sell copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-#\n-# The above copyright notice and this permission notice shall be included in\n-# all copies or substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n-# IN THE SOFTWARE.\n-\n-# Use make -f Makefile.gcc PREFIX=i686-w64-mingw32-\n-# for cross compilation\n-CC = $(PREFIX)gcc\n-AR = $(PREFIX)ar\n-E=.exe\n-\n-CFLAGS=$(CPPFLAGS) -g --std=gnu89 -D_WIN32_WINNT=0x0501 -Isrc/ares/config_win32\n-LINKFLAGS=-lm\n-\n-CARES_OBJS += src/ares/windows_port.o\n-CARES_OBJS += src/ares/ares_platform.o\n-WIN_SRCS=$(wildcard src/win/*.c)\n-WIN_OBJS=$(WIN_SRCS:.c=.o)\n-\n-RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE # Need _GNU_SOURCE for strdup?\n-RUNNER_LINKFLAGS=$(LINKFLAGS)\n-RUNNER_LIBS=-lws2_32\n-RUNNER_SRC=test/runner-win.c\n-\n-uv.a: $(WIN_OBJS) src/uv-common.o $(CARES_OBJS)\n-\t$(AR) rcs uv.a src/win/*.o src/uv-common.o $(CARES_OBJS)\n-\n-src/win/%.o: src/win/%.c src/win/internal.h\n-\t$(CC) $(CFLAGS) -o $@ -c $<\n-\n-src/uv-common.o: src/uv-common.c include/uv.h include/uv-private/uv-win.h\n-\t$(CC) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n-\n-EIO_CPPFLAGS += $(CPPFLAGS)\n-EIO_CPPFLAGS += -DEIO_STACKSIZE=65536\n-EIO_CPPFLAGS += -D_GNU_SOURCE\n-\n-clean-platform:\n-\t-rm -f src/ares/*.o\n-\t-rm -f src/eio/*.o\n-\t-rm -f src/win/*.o\n-\n-distclean-platform:\n-\t-rm -f src/ares/*.o\n-\t-rm -f src/eio/*.o\n-\t-rm -f src/win/*.o"}, {"sha": "9524061b1c509aebefdd827c798639e140f44b19", "filename": "src/rt/libuv/config-unix.mk", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fconfig-unix.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fconfig-unix.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fconfig-unix.mk?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,155 +0,0 @@\n-# Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n-#\n-# Permission is hereby granted, free of charge, to any person obtaining a copy\n-# of this software and associated documentation files (the \"Software\"), to\n-# deal in the Software without restriction, including without limitation the\n-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n-# sell copies of the Software, and to permit persons to whom the Software is\n-# furnished to do so, subject to the following conditions:\n-#\n-# The above copyright notice and this permission notice shall be included in\n-# all copies or substantial portions of the Software.\n-#\n-# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n-# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n-# IN THE SOFTWARE.\n-\n-E=\n-CSTDFLAG=--std=c89 -pedantic -Wall -Wextra -Wno-unused-parameter\n-CFLAGS += -g\n-CPPFLAGS += -Isrc/unix/ev\n-LINKFLAGS=-lm\n-\n-CPPFLAGS += -D_LARGEFILE_SOURCE\n-CPPFLAGS += -D_FILE_OFFSET_BITS=64\n-\n-OBJS += src/unix/core.o\n-OBJS += src/unix/dl.o\n-OBJS += src/unix/fs.o\n-OBJS += src/unix/cares.o\n-OBJS += src/unix/udp.o\n-OBJS += src/unix/error.o\n-OBJS += src/unix/process.o\n-OBJS += src/unix/tcp.o\n-OBJS += src/unix/pipe.o\n-OBJS += src/unix/tty.o\n-OBJS += src/unix/stream.o\n-\n-ifeq (SunOS,$(uname_S))\n-EV_CONFIG=config_sunos.h\n-EIO_CONFIG=config_sunos.h\n-CPPFLAGS += -Isrc/ares/config_sunos -D__EXTENSIONS__ -D_XOPEN_SOURCE=500\n-LINKFLAGS+=-lsocket -lnsl -lkstat\n-OBJS += src/unix/sunos.o\n-endif\n-\n-ifeq (Darwin,$(uname_S))\n-EV_CONFIG=config_darwin.h\n-EIO_CONFIG=config_darwin.h\n-CPPFLAGS += -Isrc/ares/config_darwin\n-LINKFLAGS+=-framework CoreServices\n-OBJS += src/unix/darwin.o\n-OBJS += src/unix/kqueue.o\n-endif\n-\n-ifeq (Linux,$(uname_S))\n-EV_CONFIG=config_linux.h\n-EIO_CONFIG=config_linux.h\n-CSTDFLAG += -D_GNU_SOURCE\n-CPPFLAGS += -Isrc/ares/config_linux\n-LINKFLAGS+=-lrt\n-OBJS += src/unix/linux.o\n-endif\n-\n-ifeq (FreeBSD,$(uname_S))\n-EV_CONFIG=config_freebsd.h\n-EIO_CONFIG=config_freebsd.h\n-CPPFLAGS += -Isrc/ares/config_freebsd\n-LINKFLAGS+=\n-OBJS += src/unix/freebsd.o\n-OBJS += src/unix/kqueue.o\n-endif\n-\n-ifeq (NetBSD,$(uname_S))\n-EV_CONFIG=config_netbsd.h\n-EIO_CONFIG=config_netbsd.h\n-CPPFLAGS += -Isrc/ares/config_netbsd\n-LINKFLAGS+=\n-OBJS += src/unix/netbsd.o\n-OBJS += src/unix/kqueue.o\n-endif\n-\n-ifeq (OpenBSD,$(uname_S))\n-EV_CONFIG=config_openbsd.h\n-EIO_CONFIG=config_openbsd.h\n-CPPFLAGS += -Isrc/ares/config_openbsd\n-LINKFLAGS+=\n-OBJS += src/unix/openbsd.o\n-OBJS += src/unix/kqueue.o\n-endif\n-\n-ifneq (,$(findstring CYGWIN,$(uname_S)))\n-EV_CONFIG=config_cygwin.h\n-EIO_CONFIG=config_cygwin.h\n-# We drop the --std=c89, it hides CLOCK_MONOTONIC on cygwin\n-CSTDFLAG = -D_GNU_SOURCE\n-CPPFLAGS += -Isrc/ares/config_cygwin\n-LINKFLAGS+=\n-OBJS += src/unix/cygwin.o\n-endif\n-\n-# Need _GNU_SOURCE for strdup?\n-RUNNER_CFLAGS=$(CFLAGS) -D_GNU_SOURCE\n-RUNNER_LINKFLAGS=$(LINKFLAGS)\n-\n-ifeq (SunOS,$(uname_S))\n-RUNNER_LINKFLAGS += -pthreads\n-else\n-RUNNER_LINKFLAGS += -pthread\n-endif\n-\n-RUNNER_LIBS=\n-RUNNER_SRC=test/runner-unix.c\n-\n-uv.a: $(OBJS) src/uv-common.o src/unix/ev/ev.o src/unix/uv-eio.o src/unix/eio/eio.o $(CARES_OBJS)\n-\t$(AR) rcs uv.a $(OBJS) src/uv-common.o src/unix/uv-eio.o src/unix/ev/ev.o src/unix/eio/eio.o $(CARES_OBJS)\n-\n-src/unix/%.o: src/unix/%.c include/uv.h include/uv-private/uv-unix.h src/unix/internal.h\n-\t$(CC) $(CSTDFLAG) $(CPPFLAGS) -Isrc  $(CFLAGS) -c $< -o $@\n-\n-src/uv-common.o: src/uv-common.c include/uv.h include/uv-private/uv-unix.h\n-\t$(CC) $(CSTDFLAG) $(CPPFLAGS) $(CFLAGS) -c src/uv-common.c -o src/uv-common.o\n-\n-src/unix/ev/ev.o: src/unix/ev/ev.c\n-\t$(CC) $(CPPFLAGS) $(CFLAGS) -c src/unix/ev/ev.c -o src/unix/ev/ev.o -DEV_CONFIG_H=\\\"$(EV_CONFIG)\\\"\n-\n-\n-EIO_CPPFLAGS += $(CPPFLAGS)\n-EIO_CPPFLAGS += -DEIO_CONFIG_H=\\\"$(EIO_CONFIG)\\\"\n-EIO_CPPFLAGS += -DEIO_STACKSIZE=262144\n-EIO_CPPFLAGS += -D_GNU_SOURCE\n-\n-src/unix/eio/eio.o: src/unix/eio/eio.c\n-\t$(CC) $(EIO_CPPFLAGS) $(CFLAGS) -c src/unix/eio/eio.c -o src/unix/eio/eio.o\n-\n-src/unix/uv-eio.o: src/unix/uv-eio.c\n-\t$(CC) $(CPPFLAGS) -Isrc/unix/eio/ $(CSTDFLAG) $(CFLAGS) -c src/unix/uv-eio.c -o src/unix/uv-eio.o\n-\n-\n-clean-platform:\n-\t-rm -f src/ares/*.o\n-\t-rm -f src/unix/ev/*.o\n-\t-rm -f src/unix/eio/*.o\n-\t-rm -f src/unix/*.o\n-\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM\n-\n-distclean-platform:\n-\t-rm -f src/ares/*.o\n-\t-rm -f src/unix/ev/*.o\n-\t-rm -f src/unix/*.o\n-\t-rm -f src/unix/eio/*.o\n-\t-rm -rf test/run-tests.dSYM run-benchmarks.dSYM"}, {"sha": "a7a9689c265b29c87c1932bd7ce616afd32ee546", "filename": "src/rt/libuv/gyp_uv", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fgyp_uv", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fgyp_uv", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fgyp_uv?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,60 +0,0 @@\n-#!/usr/bin/env python\n-import glob\n-import os\n-import shlex\n-import sys\n-\n-script_dir = os.path.dirname(__file__)\n-uv_root = os.path.normpath(script_dir)\n-\n-sys.path.insert(0, os.path.join(uv_root, 'build', 'gyp', 'pylib'))\n-import gyp\n-\n-# Directory within which we want all generated files (including Makefiles)\n-# to be written.\n-output_dir = os.path.join(os.path.abspath(uv_root), 'out')\n-\n-def run_gyp(args):\n-  rc = gyp.main(args)\n-  if rc != 0:\n-    print 'Error running GYP'\n-    sys.exit(rc)\n-\n-if __name__ == '__main__':\n-  args = sys.argv[1:]\n-\n-  # GYP bug.\n-  # On msvs it will crash if it gets an absolute path.\n-  # On Mac/make it will crash if it doesn't get an absolute path.\n-  if sys.platform == 'win32':\n-    args.append(os.path.join(uv_root, 'uv.gyp'))\n-    common_fn  = os.path.join(uv_root, 'common.gypi')\n-    options_fn = os.path.join(uv_root, 'options.gypi')\n-  else:\n-    args.append(os.path.join(os.path.abspath(uv_root), 'uv.gyp'))\n-    common_fn  = os.path.join(os.path.abspath(uv_root), 'common.gypi')\n-    options_fn = os.path.join(os.path.abspath(uv_root), 'options.gypi')\n-\n-  if os.path.exists(common_fn):\n-    args.extend(['-I', common_fn])\n-\n-  if os.path.exists(options_fn):\n-    args.extend(['-I', options_fn])\n-\n-  args.append('--depth=' + uv_root)\n-\n-  # There's a bug with windows which doesn't allow this feature.\n-  if sys.platform != 'win32':\n-\n-    # Tell gyp to write the Makefiles into output_dir\n-    args.extend(['--generator-output', output_dir])\n-\n-    # Tell make to write its output into the same dir\n-    args.extend(['-Goutput_dir=' + output_dir])\n-\n-  args.append('-Dtarget_arch=ia32')\n-  args.append('-Dcomponent=static_library')\n-  args.append('-Dlibrary=static_library')\n-  gyp_args = list(args)\n-  print gyp_args\n-  run_gyp(gyp_args)"}, {"sha": "53ac861b2cec69c5c5dc21bc70c6e99d638f7bf2", "filename": "src/rt/libuv/include/ares.h", "status": "removed", "additions": 0, "deletions": 591, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fares.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fares.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,591 +0,0 @@\n-\n-/* Copyright 1998, 2009 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2007-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#ifndef ARES__H\n-#define ARES__H\n-\n-#include \"ares_version.h\"  /* c-ares version defines   */\n-\n-/*\n- * Define WIN32 when build target is Win32 API\n- */\n-\n-#if (defined(_WIN32) || defined(__WIN32__)) && \\\n-   !defined(WIN32) && !defined(__SYMBIAN32__)\n-#  define WIN32\n-#endif\n-\n-/*************************** libuv patch ***************/\n-\n-/*\n- * We want to avoid autoconf altogether since there are a finite number of\n- * operating systems and simply build c-ares. Therefore we do not want the\n- * configurations provided by ares_build.h since we are always statically\n- * linking c-ares into libuv. Having a system dependent ares_build.h forces\n- * all users of ares.h to include the correct ares_build.h.  We do not care\n- * about the linking checks provided by ares_rules.h. This would complicate\n- * the libuv build process.\n- */\n-\n-\n-#if defined(WIN32)\n-/* Configure process defines this to 1 when it finds out that system  */\n-/* header file ws2tcpip.h must be included by the external interface. */\n-/* #undef CARES_PULL_WS2TCPIP_H */\n-# include <winsock2.h>\n-# include <ws2tcpip.h>\n-# include <windows.h>\n-\n-#else /* Not Windows */\n-\n-# include <sys/time.h>\n-# include <sys/types.h>\n-# include <sys/socket.h>\n-#endif\n-\n-#if 0\n-/* The size of `long', as computed by sizeof. */\n-#define CARES_SIZEOF_LONG 4\n-#endif\n-\n-/* Integral data type used for ares_socklen_t. */\n-#define CARES_TYPEOF_ARES_SOCKLEN_T socklen_t\n-\n-#if 0\n-/* The size of `ares_socklen_t', as computed by sizeof. */\n-#define CARES_SIZEOF_ARES_SOCKLEN_T 4\n-#endif\n-\n-/* Data type definition of ares_socklen_t. */\n-typedef int ares_socklen_t;\n-\n-#if 0 /* libuv disabled */\n-#include \"ares_rules.h\"    /* c-ares rules enforcement */\n-#endif\n-\n-/*********************** end libuv patch ***************/\n-\n-#include <sys/types.h>\n-\n-/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish\n-   libc5-based Linux systems. Only include it on system that are known to\n-   require it! */\n-#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || \\\n-    defined(__minix) || defined(__SYMBIAN32__) || defined(__INTEGRITY)\n-#include <sys/select.h>\n-#endif\n-#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n-#include <sys/bsdskt.h>\n-#endif\n-\n-#if defined(WATT32)\n-#  include <netinet/in.h>\n-#  include <sys/socket.h>\n-#  include <tcp.h>\n-#elif defined(_WIN32_WCE)\n-#  ifndef WIN32_LEAN_AND_MEAN\n-#    define WIN32_LEAN_AND_MEAN\n-#  endif\n-#  include <windows.h>\n-#  include <winsock.h>\n-#elif defined(WIN32)\n-#  ifndef WIN32_LEAN_AND_MEAN\n-#    define WIN32_LEAN_AND_MEAN\n-#  endif\n-#  include <windows.h>\n-#  include <winsock2.h>\n-#  include <ws2tcpip.h>\n-#else\n-#  include <sys/socket.h>\n-#  include <netinet/in.h>\n-#endif\n-\n-#ifdef  __cplusplus\n-extern \"C\" {\n-#endif\n-\n-/*\n-** c-ares external API function linkage decorations.\n-*/\n-\n-#if !defined(CARES_STATICLIB) && \\\n-   (defined(WIN32) || defined(_WIN32) || defined(__SYMBIAN32__))\n-   /* __declspec function decoration for Win32 and Symbian DLL's */\n-#  if defined(CARES_BUILDING_LIBRARY)\n-#    define CARES_EXTERN  __declspec(dllexport)\n-#  else\n-#    define CARES_EXTERN  __declspec(dllimport)\n-#  endif\n-#else\n-   /* visibility function decoration for other cases */\n-#  if !defined(CARES_SYMBOL_HIDING) || \\\n-     defined(WIN32) || defined(_WIN32) || defined(__SYMBIAN32__)\n-#    define CARES_EXTERN\n-#  else\n-#    define CARES_EXTERN CARES_SYMBOL_SCOPE_EXTERN\n-#  endif\n-#endif\n-\n-\n-#define ARES_SUCCESS            0\n-\n-/* Server error codes (ARES_ENODATA indicates no relevant answer) */\n-#define ARES_ENODATA            1\n-#define ARES_EFORMERR           2\n-#define ARES_ESERVFAIL          3\n-#define ARES_ENOTFOUND          4\n-#define ARES_ENOTIMP            5\n-#define ARES_EREFUSED           6\n-\n-/* Locally generated error codes */\n-#define ARES_EBADQUERY          7\n-#define ARES_EBADNAME           8\n-#define ARES_EBADFAMILY         9\n-#define ARES_EBADRESP           10\n-#define ARES_ECONNREFUSED       11\n-#define ARES_ETIMEOUT           12\n-#define ARES_EOF                13\n-#define ARES_EFILE              14\n-#define ARES_ENOMEM             15\n-#define ARES_EDESTRUCTION       16\n-#define ARES_EBADSTR            17\n-\n-/* ares_getnameinfo error codes */\n-#define ARES_EBADFLAGS          18\n-\n-/* ares_getaddrinfo error codes */\n-#define ARES_ENONAME            19\n-#define ARES_EBADHINTS          20\n-\n-/* Uninitialized library error code */\n-#define ARES_ENOTINITIALIZED    21          /* introduced in 1.7.0 */\n-\n-/* ares_library_init error codes */\n-#define ARES_ELOADIPHLPAPI           22     /* introduced in 1.7.0 */\n-#define ARES_EADDRGETNETWORKPARAMS   23     /* introduced in 1.7.0 */\n-\n-/* More error codes */\n-#define ARES_ECANCELLED         24          /* introduced in 1.7.0 */\n-\n-/* Flag values */\n-#define ARES_FLAG_USEVC         (1 << 0)\n-#define ARES_FLAG_PRIMARY       (1 << 1)\n-#define ARES_FLAG_IGNTC         (1 << 2)\n-#define ARES_FLAG_NORECURSE     (1 << 3)\n-#define ARES_FLAG_STAYOPEN      (1 << 4)\n-#define ARES_FLAG_NOSEARCH      (1 << 5)\n-#define ARES_FLAG_NOALIASES     (1 << 6)\n-#define ARES_FLAG_NOCHECKRESP   (1 << 7)\n-\n-/* Option mask values */\n-#define ARES_OPT_FLAGS          (1 << 0)\n-#define ARES_OPT_TIMEOUT        (1 << 1)\n-#define ARES_OPT_TRIES          (1 << 2)\n-#define ARES_OPT_NDOTS          (1 << 3)\n-#define ARES_OPT_UDP_PORT       (1 << 4)\n-#define ARES_OPT_TCP_PORT       (1 << 5)\n-#define ARES_OPT_SERVERS        (1 << 6)\n-#define ARES_OPT_DOMAINS        (1 << 7)\n-#define ARES_OPT_LOOKUPS        (1 << 8)\n-#define ARES_OPT_SOCK_STATE_CB  (1 << 9)\n-#define ARES_OPT_SORTLIST       (1 << 10)\n-#define ARES_OPT_SOCK_SNDBUF    (1 << 11)\n-#define ARES_OPT_SOCK_RCVBUF    (1 << 12)\n-#define ARES_OPT_TIMEOUTMS      (1 << 13)\n-#define ARES_OPT_ROTATE         (1 << 14)\n-\n-/* Nameinfo flag values */\n-#define ARES_NI_NOFQDN                  (1 << 0)\n-#define ARES_NI_NUMERICHOST             (1 << 1)\n-#define ARES_NI_NAMEREQD                (1 << 2)\n-#define ARES_NI_NUMERICSERV             (1 << 3)\n-#define ARES_NI_DGRAM                   (1 << 4)\n-#define ARES_NI_TCP                     0\n-#define ARES_NI_UDP                     ARES_NI_DGRAM\n-#define ARES_NI_SCTP                    (1 << 5)\n-#define ARES_NI_DCCP                    (1 << 6)\n-#define ARES_NI_NUMERICSCOPE            (1 << 7)\n-#define ARES_NI_LOOKUPHOST              (1 << 8)\n-#define ARES_NI_LOOKUPSERVICE           (1 << 9)\n-/* Reserved for future use */\n-#define ARES_NI_IDN                     (1 << 10)\n-#define ARES_NI_IDN_ALLOW_UNASSIGNED    (1 << 11)\n-#define ARES_NI_IDN_USE_STD3_ASCII_RULES (1 << 12)\n-\n-/* Addrinfo flag values */\n-#define ARES_AI_CANONNAME               (1 << 0)\n-#define ARES_AI_NUMERICHOST             (1 << 1)\n-#define ARES_AI_PASSIVE                 (1 << 2)\n-#define ARES_AI_NUMERICSERV             (1 << 3)\n-#define ARES_AI_V4MAPPED                (1 << 4)\n-#define ARES_AI_ALL                     (1 << 5)\n-#define ARES_AI_ADDRCONFIG              (1 << 6)\n-/* Reserved for future use */\n-#define ARES_AI_IDN                     (1 << 10)\n-#define ARES_AI_IDN_ALLOW_UNASSIGNED    (1 << 11)\n-#define ARES_AI_IDN_USE_STD3_ASCII_RULES (1 << 12)\n-#define ARES_AI_CANONIDN                (1 << 13)\n-\n-#define ARES_AI_MASK (ARES_AI_CANONNAME|ARES_AI_NUMERICHOST|ARES_AI_PASSIVE| \\\n-                      ARES_AI_NUMERICSERV|ARES_AI_V4MAPPED|ARES_AI_ALL| \\\n-                      ARES_AI_ADDRCONFIG)\n-#define ARES_GETSOCK_MAXNUM 16 /* ares_getsock() can return info about this\n-                                  many sockets */\n-#define ARES_GETSOCK_READABLE(bits,num) (bits & (1<< (num)))\n-#define ARES_GETSOCK_WRITABLE(bits,num) (bits & (1 << ((num) + \\\n-                                         ARES_GETSOCK_MAXNUM)))\n-\n-/* c-ares library initialization flag values */\n-#define ARES_LIB_INIT_NONE   (0)\n-#define ARES_LIB_INIT_WIN32  (1 << 0)\n-#define ARES_LIB_INIT_ALL    (ARES_LIB_INIT_WIN32)\n-\n-\n-/*\n- * Typedef our socket type\n- */\n-\n-#ifndef ares_socket_typedef\n-#ifdef WIN32\n-typedef SOCKET ares_socket_t;\n-#define ARES_SOCKET_BAD INVALID_SOCKET\n-#else\n-typedef int ares_socket_t;\n-#define ARES_SOCKET_BAD -1\n-#endif\n-#define ares_socket_typedef\n-#endif /* ares_socket_typedef */\n-\n-typedef void (*ares_sock_state_cb)(void *data,\n-                                   ares_socket_t socket_fd,\n-                                   int readable,\n-                                   int writable);\n-\n-struct apattern;\n-\n-/* NOTE about the ares_options struct to users and developers.\n-\n-   This struct will remain looking like this. It will not be extended nor\n-   shrunk in future releases, but all new options will be set by ares_set_*()\n-   options instead of with the ares_init_options() function.\n-\n-   Eventually (in a galaxy far far away), all options will be settable by\n-   ares_set_*() options and the ares_init_options() function will become\n-   deprecated.\n-\n-   When new options are added to c-ares, they are not added to this\n-   struct. And they are not \"saved\" with the ares_save_options() function but\n-   instead we encourage the use of the ares_dup() function. Needless to say,\n-   if you add config options to c-ares you need to make sure ares_dup()\n-   duplicates this new option.\n-\n- */\n-struct ares_options {\n-  int flags;\n-  int timeout; /* in seconds or milliseconds, depending on options */\n-  int tries;\n-  int ndots;\n-  unsigned short udp_port;\n-  unsigned short tcp_port;\n-  int socket_send_buffer_size;\n-  int socket_receive_buffer_size;\n-  struct in_addr *servers;\n-  int nservers;\n-  char **domains;\n-  int ndomains;\n-  char *lookups;\n-  ares_sock_state_cb sock_state_cb;\n-  void *sock_state_cb_data;\n-  struct apattern *sortlist;\n-  int nsort;\n-};\n-\n-struct hostent;\n-struct timeval;\n-struct sockaddr;\n-struct ares_channeldata;\n-\n-typedef struct ares_channeldata *ares_channel;\n-\n-typedef void (*ares_callback)(void *arg,\n-                              int status,\n-                              int timeouts,\n-                              unsigned char *abuf,\n-                              int alen);\n-\n-typedef void (*ares_host_callback)(void *arg,\n-                                   int status,\n-                                   int timeouts,\n-                                   struct hostent *hostent);\n-\n-typedef void (*ares_nameinfo_callback)(void *arg,\n-                                       int status,\n-                                       int timeouts,\n-                                       char *node,\n-                                       char *service);\n-\n-typedef int  (*ares_sock_create_callback)(ares_socket_t socket_fd,\n-                                          int type,\n-                                          void *data);\n-\n-CARES_EXTERN int ares_library_init(int flags);\n-\n-CARES_EXTERN void ares_library_cleanup(void);\n-\n-CARES_EXTERN const char *ares_version(int *version);\n-\n-CARES_EXTERN int ares_init(ares_channel *channelptr);\n-\n-CARES_EXTERN int ares_init_options(ares_channel *channelptr,\n-                                   struct ares_options *options,\n-                                   int optmask);\n-\n-CARES_EXTERN int ares_save_options(ares_channel channel,\n-                                   struct ares_options *options,\n-                                   int *optmask);\n-\n-CARES_EXTERN void ares_destroy_options(struct ares_options *options);\n-\n-CARES_EXTERN int ares_dup(ares_channel *dest,\n-                          ares_channel src);\n-\n-CARES_EXTERN void ares_destroy(ares_channel channel);\n-\n-CARES_EXTERN void ares_cancel(ares_channel channel);\n-\n-/* These next 3 configure local binding for the out-going socket\n- * connection.  Use these to specify source IP and/or network device\n- * on multi-homed systems.\n- */\n-CARES_EXTERN void ares_set_local_ip4(ares_channel channel, unsigned int local_ip);\n-\n-/* local_ip6 should be 16 bytes in length */\n-CARES_EXTERN void ares_set_local_ip6(ares_channel channel,\n-                                     const unsigned char* local_ip6);\n-\n-/* local_dev_name should be null terminated. */\n-CARES_EXTERN void ares_set_local_dev(ares_channel channel,\n-                                     const char* local_dev_name);\n-\n-CARES_EXTERN void ares_set_socket_callback(ares_channel channel,\n-                                           ares_sock_create_callback callback,\n-                                           void *user_data);\n-\n-CARES_EXTERN void ares_send(ares_channel channel,\n-                            const unsigned char *qbuf,\n-                            int qlen,\n-                            ares_callback callback,\n-                            void *arg);\n-\n-CARES_EXTERN void ares_query(ares_channel channel,\n-                             const char *name,\n-                             int dnsclass,\n-                             int type,\n-                             ares_callback callback,\n-                             void *arg);\n-\n-CARES_EXTERN void ares_search(ares_channel channel,\n-                              const char *name,\n-                              int dnsclass,\n-                              int type,\n-                              ares_callback callback,\n-                              void *arg);\n-\n-CARES_EXTERN void ares_gethostbyname(ares_channel channel,\n-                                     const char *name,\n-                                     int family,\n-                                     ares_host_callback callback,\n-                                     void *arg);\n-\n-CARES_EXTERN int ares_gethostbyname_file(ares_channel channel,\n-                                         const char *name,\n-                                         int family,\n-                                         struct hostent **host);\n-\n-CARES_EXTERN void ares_gethostbyaddr(ares_channel channel,\n-                                     const void *addr,\n-                                     int addrlen,\n-                                     int family,\n-                                     ares_host_callback callback,\n-                                     void *arg);\n-\n-CARES_EXTERN void ares_getnameinfo(ares_channel channel,\n-                                   const struct sockaddr *sa,\n-                                   ares_socklen_t salen,\n-                                   int flags,\n-                                   ares_nameinfo_callback callback,\n-                                   void *arg);\n-\n-CARES_EXTERN int ares_fds(ares_channel channel,\n-                          fd_set *read_fds,\n-                          fd_set *write_fds);\n-\n-CARES_EXTERN int ares_getsock(ares_channel channel,\n-                              ares_socket_t *socks,\n-                              int numsocks);\n-\n-CARES_EXTERN struct timeval *ares_timeout(ares_channel channel,\n-                                          struct timeval *maxtv,\n-                                          struct timeval *tv);\n-\n-CARES_EXTERN void ares_process(ares_channel channel,\n-                               fd_set *read_fds,\n-                               fd_set *write_fds);\n-\n-CARES_EXTERN void ares_process_fd(ares_channel channel,\n-                                  ares_socket_t read_fd,\n-                                  ares_socket_t write_fd);\n-\n-CARES_EXTERN int ares_mkquery(const char *name,\n-                              int dnsclass,\n-                              int type,\n-                              unsigned short id,\n-                              int rd,\n-                              unsigned char **buf,\n-                              int *buflen);\n-\n-CARES_EXTERN int ares_expand_name(const unsigned char *encoded,\n-                                  const unsigned char *abuf,\n-                                  int alen,\n-                                  char **s,\n-                                  long *enclen);\n-\n-CARES_EXTERN int ares_expand_string(const unsigned char *encoded,\n-                                    const unsigned char *abuf,\n-                                    int alen,\n-                                    unsigned char **s,\n-                                    long *enclen);\n-\n-/*\n- * NOTE: before c-ares 1.7.0 we would most often use the system in6_addr\n- * struct below when ares itself was built, but many apps would use this\n- * private version since the header checked a HAVE_* define for it. Starting\n- * with 1.7.0 we always declare and use our own to stop relying on the\n- * system's one.\n- */\n-struct ares_in6_addr {\n-  union {\n-    unsigned char _S6_u8[16];\n-  } _S6_un;\n-};\n-\n-struct ares_addrttl {\n-  struct in_addr ipaddr;\n-  int            ttl;\n-};\n-\n-struct ares_addr6ttl {\n-  struct ares_in6_addr ip6addr;\n-  int             ttl;\n-};\n-\n-struct ares_srv_reply {\n-  struct ares_srv_reply  *next;\n-  char                   *host;\n-  unsigned short          priority;\n-  unsigned short          weight;\n-  unsigned short          port;\n-};\n-\n-struct ares_mx_reply {\n-  struct ares_mx_reply   *next;\n-  char                   *host;\n-  unsigned short          priority;\n-};\n-\n-struct ares_txt_reply {\n-  struct ares_txt_reply  *next;\n-  unsigned char          *txt;\n-  size_t                  length;  /* length excludes null termination */\n-};\n-\n-/*\n-** Parse the buffer, starting at *abuf and of length alen bytes, previously\n-** obtained from an ares_search call.  Put the results in *host, if nonnull.\n-** Also, if addrttls is nonnull, put up to *naddrttls IPv4 addresses along with\n-** their TTLs in that array, and set *naddrttls to the number of addresses\n-** so written.\n-*/\n-\n-CARES_EXTERN int ares_parse_a_reply(const unsigned char *abuf,\n-                                    int alen,\n-                                    struct hostent **host,\n-                                    struct ares_addrttl *addrttls,\n-                                    int *naddrttls);\n-\n-CARES_EXTERN int ares_parse_aaaa_reply(const unsigned char *abuf,\n-                                       int alen,\n-                                       struct hostent **host,\n-                                       struct ares_addr6ttl *addrttls,\n-                                       int *naddrttls);\n-\n-CARES_EXTERN int ares_parse_ptr_reply(const unsigned char *abuf,\n-                                      int alen,\n-                                      const void *addr,\n-                                      int addrlen,\n-                                      int family,\n-                                      struct hostent **host);\n-\n-CARES_EXTERN int ares_parse_ns_reply(const unsigned char *abuf,\n-                                     int alen,\n-                                     struct hostent **host);\n-\n-CARES_EXTERN int ares_parse_srv_reply(const unsigned char* abuf,\n-                                      int alen,\n-                                      struct ares_srv_reply** srv_out);\n-\n-CARES_EXTERN int ares_parse_mx_reply(const unsigned char* abuf,\n-                                      int alen,\n-                                      struct ares_mx_reply** mx_out);\n-\n-CARES_EXTERN int ares_parse_txt_reply(const unsigned char* abuf,\n-                                      int alen,\n-                                      struct ares_txt_reply** txt_out);\n-\n-CARES_EXTERN void ares_free_string(void *str);\n-\n-CARES_EXTERN void ares_free_hostent(struct hostent *host);\n-\n-CARES_EXTERN void ares_free_data(void *dataptr);\n-\n-CARES_EXTERN const char *ares_strerror(int code);\n-\n-/* TODO:  Hold port here as well. */\n-struct ares_addr_node {\n-  struct ares_addr_node *next;\n-  int family;\n-  union {\n-    struct in_addr       addr4;\n-    struct ares_in6_addr addr6;\n-  } addr;\n-};\n-\n-CARES_EXTERN int ares_set_servers(ares_channel channel,\n-                                  struct ares_addr_node *servers);\n-\n-/* Incomming string format: host[:port][,host[:port]]... */\n-CARES_EXTERN int ares_set_servers_csv(ares_channel channel,\n-                                      const char* servers);\n-\n-CARES_EXTERN int ares_get_servers(ares_channel channel,\n-                                  struct ares_addr_node **servers);\n-\n-#ifdef  __cplusplus\n-}\n-#endif\n-\n-#endif /* ARES__H */"}, {"sha": "efd0156dd10f3790b2ce5f0628336a347a8cf019", "filename": "src/rt/libuv/include/ares_version.h", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fares_version.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fares_version.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,24 +0,0 @@\n-\n-#ifndef ARES__VERSION_H\n-#define ARES__VERSION_H\n-\n-/* This is the global package copyright */\n-#define ARES_COPYRIGHT \"2004 - 2010 Daniel Stenberg, <daniel@haxx.se>.\"\n-\n-#define ARES_VERSION_MAJOR 1\n-#define ARES_VERSION_MINOR 7\n-#define ARES_VERSION_PATCH 5\n-#define ARES_VERSION ((ARES_VERSION_MAJOR<<16)|\\\n-                       (ARES_VERSION_MINOR<<8)|\\\n-                       (ARES_VERSION_PATCH))\n-#define ARES_VERSION_STR \"1.7.5-DEV\"\n-\n-#if (ARES_VERSION >= 0x010700)\n-#  define CARES_HAVE_ARES_LIBRARY_INIT 1\n-#  define CARES_HAVE_ARES_LIBRARY_CLEANUP 1\n-#else\n-#  undef CARES_HAVE_ARES_LIBRARY_INIT\n-#  undef CARES_HAVE_ARES_LIBRARY_CLEANUP\n-#endif\n-\n-#endif"}, {"sha": "450df6ba299789e4f7b2984b1503d1b28744a81f", "filename": "src/rt/libuv/include/uv-private/eio.h", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Feio.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,376 +0,0 @@\n-/*\n- * libeio API header\n- *\n- * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libeio@schmorp.de>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without modifica-\n- * tion, are permitted provided that the following conditions are met:\n- * \n- *   1.  Redistributions of source code must retain the above copyright notice,\n- *       this list of conditions and the following disclaimer.\n- * \n- *   2.  Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- * \n- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n- * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n- * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n- * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n- * OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- * Alternatively, the contents of this file may be used under the terms of\n- * the GNU General Public License (\"GPL\") version 2 or any later version,\n- * in which case the provisions of the GPL are applicable instead of\n- * the above. If you wish to allow the use of your version of this file\n- * only under the terms of the GPL and not to allow others to use your\n- * version of this file under the BSD license, indicate your decision\n- * by deleting the provisions above and replace them with the notice\n- * and other provisions required by the GPL. If you do not delete the\n- * provisions above, a recipient may use your version of this file under\n- * either the BSD or the GPL.\n- */\n-\n-#ifndef EIO_H_\n-#define EIO_H_\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#include <stddef.h>\n-#include <signal.h>\n-#include <sys/types.h>\n-\n-typedef struct eio_req    eio_req;\n-typedef struct eio_dirent eio_dirent;\n-\n-typedef int (*eio_cb)(eio_req *req);\n-\n-#ifndef EIO_REQ_MEMBERS\n-# define EIO_REQ_MEMBERS\n-#endif\n-\n-#ifndef EIO_STRUCT_STAT\n-# ifdef _WIN32\n-#  define EIO_STRUCT_STAT struct _stati64\n-#  define EIO_STRUCT_STATI64\n-# else\n-#  define EIO_STRUCT_STAT struct stat\n-# endif\n-#endif\n-\n-#ifdef _WIN32\n-  typedef int      eio_uid_t;\n-  typedef int      eio_gid_t;\n-  typedef int      eio_mode_t;\n-  #ifdef __MINGW32__ /* no intptr_t */\n-    typedef ssize_t  eio_ssize_t;\n-  #else\n-    typedef intptr_t eio_ssize_t; /* or SSIZE_T */\n-  #endif\n-  #if __GNUC__\n-    typedef long long eio_ino_t;\n-  #else\n-    typedef __int64   eio_ino_t; /* unsigned not supported by msvc */\n-  #endif\n-#else\n-  typedef uid_t    eio_uid_t;\n-  typedef gid_t    eio_gid_t;\n-  typedef ssize_t  eio_ssize_t;\n-  typedef ino_t    eio_ino_t;\n-  typedef mode_t   eio_mode_t;\n-#endif\n-\n-#ifndef EIO_STRUCT_STATVFS\n-# define EIO_STRUCT_STATVFS struct statvfs\n-#endif\n-\n-/* for readdir */\n-\n-/* eio_readdir flags */\n-enum\n-{\n-  EIO_READDIR_DENTS         = 0x01, /* ptr2 contains eio_dirents, not just the (unsorted) names */\n-  EIO_READDIR_DIRS_FIRST    = 0x02, /* dirents gets sorted into a good stat() ing order to find directories first */\n-  EIO_READDIR_STAT_ORDER    = 0x04, /* dirents gets sorted into a good stat() ing order to quickly stat all files */\n-  EIO_READDIR_FOUND_UNKNOWN = 0x80, /* set by eio_readdir when *_ARRAY was set and any TYPE=UNKNOWN's were found */\n-\n-  EIO_READDIR_CUSTOM1       = 0x100, /* for use by apps */\n-  EIO_READDIR_CUSTOM2       = 0x200  /* for use by apps */\n-};\n-\n-/* using \"typical\" values in the hope that the compiler will do something sensible */\n-enum eio_dtype\n-{\n-  EIO_DT_UNKNOWN =  0,\n-  EIO_DT_FIFO    =  1,\n-  EIO_DT_CHR     =  2,\n-  EIO_DT_MPC     =  3, /* multiplexed char device (v7+coherent) */\n-  EIO_DT_DIR     =  4,\n-  EIO_DT_NAM     =  5, /* xenix special named file */\n-  EIO_DT_BLK     =  6,\n-  EIO_DT_MPB     =  7, /* multiplexed block device (v7+coherent) */\n-  EIO_DT_REG     =  8,\n-  EIO_DT_NWK     =  9, /* HP-UX network special */\n-  EIO_DT_CMP     =  9, /* VxFS compressed */\n-  EIO_DT_LNK     = 10,\n-  /*  DT_SHAD    = 11,*/\n-  EIO_DT_SOCK    = 12,\n-  EIO_DT_DOOR    = 13, /* solaris door */\n-  EIO_DT_WHT     = 14,\n-  EIO_DT_MAX     = 15  /* highest DT_VALUE ever, hopefully */\n-};\n-\n-struct eio_dirent\n-{\n-  int nameofs; /* offset of null-terminated name string in (char *)req->ptr2 */\n-  unsigned short namelen; /* size of filename without trailing 0 */\n-  unsigned char type; /* one of EIO_DT_* */\n-  signed char score; /* internal use */\n-  eio_ino_t inode; /* the inode number, if available, otherwise unspecified */\n-};\n-\n-/* eio_msync flags */\n-enum\n-{\n-  EIO_MS_ASYNC      = 1,\n-  EIO_MS_INVALIDATE = 2,\n-  EIO_MS_SYNC       = 4\n-};\n-\n-/* eio_mtouch flags */\n-enum\n-{\n-  EIO_MT_MODIFY     = 1\n-};\n-\n-/* eio_sync_file_range flags */\n-enum\n-{\n-  EIO_SYNC_FILE_RANGE_WAIT_BEFORE = 1,\n-  EIO_SYNC_FILE_RANGE_WRITE       = 2,\n-  EIO_SYNC_FILE_RANGE_WAIT_AFTER  = 4\n-};\n-\n-/* eio_fallocate flags */\n-enum\n-{\n-  EIO_FALLOC_FL_KEEP_SIZE = 1 /* MUST match the value in linux/falloc.h */\n-};\n-\n-/* timestamps and differences - feel free to use double in your code directly */\n-typedef double eio_tstamp;\n-\n-/* the eio request structure */\n-enum\n-{\n-  EIO_CUSTOM,\n-  EIO_OPEN, EIO_CLOSE, EIO_DUP2,\n-  EIO_READ, EIO_WRITE,\n-  EIO_READAHEAD, EIO_SENDFILE,\n-  EIO_STAT, EIO_LSTAT, EIO_FSTAT,\n-  EIO_STATVFS, EIO_FSTATVFS,\n-  EIO_TRUNCATE, EIO_FTRUNCATE,\n-  EIO_UTIME, EIO_FUTIME,\n-  EIO_CHMOD, EIO_FCHMOD,\n-  EIO_CHOWN, EIO_FCHOWN,\n-  EIO_SYNC, EIO_FSYNC, EIO_FDATASYNC, EIO_SYNCFS,\n-  EIO_MSYNC, EIO_MTOUCH, EIO_SYNC_FILE_RANGE, EIO_FALLOCATE,\n-  EIO_MLOCK, EIO_MLOCKALL,\n-  EIO_UNLINK, EIO_RMDIR, EIO_MKDIR, EIO_RENAME,\n-  EIO_MKNOD, EIO_READDIR,\n-  EIO_LINK, EIO_SYMLINK, EIO_READLINK, EIO_REALPATH,\n-  EIO_GROUP, EIO_NOP,\n-  EIO_BUSY\n-};\n-\n-/* mlockall constants */\n-enum\n-{\n-  EIO_MCL_CURRENT = 1,\n-  EIO_MCL_FUTURE  = 2\n-};\n-\n-/* request priorities */\n-\n-enum {\n-  EIO_PRI_MIN     = -4,\n-  EIO_PRI_MAX     =  4,\n-  EIO_PRI_DEFAULT =  0\n-};\n-\n-/* eio request structure */\n-/* this structure is mostly read-only */\n-/* when initialising it, all members must be zero-initialised */\n-struct eio_req\n-{\n-  eio_req volatile *next; /* private ETP */\n-\n-  eio_ssize_t result;  /* result of syscall, e.g. result = read (... */\n-  off_t offs;      /* read, write, truncate, readahead, sync_file_range, fallocate: file offset, mknod: dev_t */\n-  size_t size;     /* read, write, readahead, sendfile, msync, mlock, sync_file_range, fallocate: length */\n-  void *ptr1;      /* all applicable requests: pathname, old name; readdir: optional eio_dirents */\n-  void *ptr2;      /* all applicable requests: new name or memory buffer; readdir: name strings */\n-  eio_tstamp nv1;  /* utime, futime: atime; busy: sleep time */\n-  eio_tstamp nv2;  /* utime, futime: mtime */\n-\n-  int type;        /* EIO_xxx constant ETP */\n-  int int1;        /* all applicable requests: file descriptor; sendfile: output fd; open, msync, mlockall, readdir: flags */\n-  long int2;       /* chown, fchown: uid; sendfile: input fd; open, chmod, mkdir, mknod: file mode, sync_file_range, fallocate: flags */\n-  long int3;       /* chown, fchown: gid */\n-  int errorno;     /* errno value on syscall return */\n-\n-#if __i386 || __amd64\n-  unsigned char cancelled;\n-#else\n-  sig_atomic_t cancelled;\n-#endif\n-\n-  unsigned char flags; /* private */\n-  signed char pri;     /* the priority */\n-\n-  void *data;\n-  eio_cb finish;\n-  void (*destroy)(eio_req *req); /* called when request no longer needed */\n-  void (*feed)(eio_req *req);    /* only used for group requests */\n-\n-  EIO_REQ_MEMBERS\n-\n-  eio_req *grp, *grp_prev, *grp_next, *grp_first; /* private */\n-};\n-\n-/* _private_ request flags */\n-enum {\n-  EIO_FLAG_PTR1_FREE = 0x01, /* need to free(ptr1) */\n-  EIO_FLAG_PTR2_FREE = 0x02, /* need to free(ptr2) */\n-  EIO_FLAG_GROUPADD  = 0x04  /* some request was added to the group */\n-};\n-\n-/* undocumented/unsupported/private helper */\n-/*void eio_page_align (void **addr, size_t *length);*/\n-\n-/* returns < 0 on error, errno set\n- * need_poll, if non-zero, will be called when results are available\n- * and eio_poll_cb needs to be invoked (it MUST NOT call eio_poll_cb itself).\n- * done_poll is called when the need to poll is gone.\n- */\n-int eio_init (void (*want_poll)(void), void (*done_poll)(void));\n-\n-/* must be called regularly to handle pending requests */\n-/* returns 0 if all requests were handled, -1 if not, or the value of EIO_FINISH if != 0 */\n-int eio_poll (void);\n-\n-/* stop polling if poll took longer than duration seconds */\n-void eio_set_max_poll_time (eio_tstamp nseconds);\n-/* do not handle more then count requests in one call to eio_poll_cb */\n-void eio_set_max_poll_reqs (unsigned int nreqs);\n-\n-/* set minimum required number\n- * maximum wanted number\n- * or maximum idle number of threads */\n-void eio_set_min_parallel (unsigned int nthreads);\n-void eio_set_max_parallel (unsigned int nthreads);\n-void eio_set_max_idle     (unsigned int nthreads);\n-void eio_set_idle_timeout (unsigned int seconds);\n-\n-unsigned int eio_nreqs    (void); /* number of requests in-flight */\n-unsigned int eio_nready   (void); /* number of not-yet handled requests */\n-unsigned int eio_npending (void); /* number of finished but unhandled requests */\n-unsigned int eio_nthreads (void); /* number of worker threads in use currently */\n-\n-/*****************************************************************************/\n-/* convenience wrappers */\n-\n-#ifndef EIO_NO_WRAPPERS\n-eio_req *eio_nop       (int pri, eio_cb cb, void *data); /* does nothing except go through the whole process */\n-eio_req *eio_busy      (eio_tstamp delay, int pri, eio_cb cb, void *data); /* ties a thread for this long, simulating busyness */\n-eio_req *eio_sync      (int pri, eio_cb cb, void *data);\n-eio_req *eio_fsync     (int fd, int pri, eio_cb cb, void *data);\n-eio_req *eio_fdatasync (int fd, int pri, eio_cb cb, void *data);\n-eio_req *eio_syncfs    (int fd, int pri, eio_cb cb, void *data);\n-eio_req *eio_msync     (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n-eio_req *eio_mtouch    (void *addr, size_t length, int flags, int pri, eio_cb cb, void *data);\n-eio_req *eio_mlock     (void *addr, size_t length, int pri, eio_cb cb, void *data);\n-eio_req *eio_mlockall  (int flags, int pri, eio_cb cb, void *data);\n-eio_req *eio_sync_file_range (int fd, off_t offset, size_t nbytes, unsigned int flags, int pri, eio_cb cb, void *data);\n-eio_req *eio_fallocate (int fd, int mode, off_t offset, size_t len, int pri, eio_cb cb, void *data);\n-eio_req *eio_close     (int fd, int pri, eio_cb cb, void *data);\n-eio_req *eio_readahead (int fd, off_t offset, size_t length, int pri, eio_cb cb, void *data);\n-eio_req *eio_read      (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_write     (int fd, void *buf, size_t length, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_fstat     (int fd, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_fstatvfs  (int fd, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_futime    (int fd, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n-eio_req *eio_ftruncate (int fd, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_fchmod    (int fd, eio_mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_fchown    (int fd, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data);\n-eio_req *eio_dup2      (int fd, int fd2, int pri, eio_cb cb, void *data);\n-eio_req *eio_sendfile  (int out_fd, int in_fd, off_t in_offset, size_t length, int pri, eio_cb cb, void *data);\n-eio_req *eio_open      (const char *path, int flags, eio_mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_utime     (const char *path, eio_tstamp atime, eio_tstamp mtime, int pri, eio_cb cb, void *data);\n-eio_req *eio_truncate  (const char *path, off_t offset, int pri, eio_cb cb, void *data);\n-eio_req *eio_chown     (const char *path, eio_uid_t uid, eio_gid_t gid, int pri, eio_cb cb, void *data);\n-eio_req *eio_chmod     (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_mkdir     (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data);\n-eio_req *eio_readdir   (const char *path, int flags, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n-eio_req *eio_rmdir     (const char *path, int pri, eio_cb cb, void *data);\n-eio_req *eio_unlink    (const char *path, int pri, eio_cb cb, void *data);\n-eio_req *eio_readlink  (const char *path, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n-eio_req *eio_realpath  (const char *path, int pri, eio_cb cb, void *data); /* result=ptr2 allocated dynamically */\n-eio_req *eio_stat      (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_lstat     (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_statvfs   (const char *path, int pri, eio_cb cb, void *data); /* stat buffer=ptr2 allocated dynamically */\n-eio_req *eio_mknod     (const char *path, eio_mode_t mode, dev_t dev, int pri, eio_cb cb, void *data);\n-eio_req *eio_link      (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n-eio_req *eio_symlink   (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n-eio_req *eio_rename    (const char *path, const char *new_path, int pri, eio_cb cb, void *data);\n-eio_req *eio_custom    (void (*execute)(eio_req *), int pri, eio_cb cb, void *data);\n-#endif\n-\n-/*****************************************************************************/\n-/* groups */\n-\n-eio_req *eio_grp       (eio_cb cb, void *data);\n-void eio_grp_feed      (eio_req *grp, void (*feed)(eio_req *req), int limit);\n-void eio_grp_limit     (eio_req *grp, int limit);\n-void eio_grp_add       (eio_req *grp, eio_req *req);\n-void eio_grp_cancel    (eio_req *grp); /* cancels all sub requests but not the group */\n-\n-/*****************************************************************************/\n-/* request api */\n-\n-/* true if the request was cancelled, useful in the invoke callback */\n-#define EIO_CANCELLED(req)   ((req)->cancelled)\n-\n-#define EIO_RESULT(req)      ((req)->result)\n-/* returns a pointer to the result buffer allocated by eio */\n-#define EIO_BUF(req)         ((req)->ptr2)\n-#define EIO_STAT_BUF(req)    ((EIO_STRUCT_STAT    *)EIO_BUF(req))\n-#define EIO_STATVFS_BUF(req) ((EIO_STRUCT_STATVFS *)EIO_BUF(req))\n-#define EIO_PATH(req)        ((char *)(req)->ptr1)\n-\n-/* submit a request for execution */\n-void eio_submit (eio_req *req);\n-/* cancel a request as soon fast as possible, if possible */\n-void eio_cancel (eio_req *req);\n-\n-/*****************************************************************************/\n-/* convenience functions */\n-\n-eio_ssize_t eio_sendfile_sync (int ofd, int ifd, off_t offset, size_t count);\n-eio_ssize_t eio__pread        (int fd, void *buf, size_t count, off_t offset);\n-eio_ssize_t eio__pwrite       (int fd, void *buf, size_t count, off_t offset);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif\n-"}, {"sha": "5d2d7a1e37edf50b9686e7ddbe0c5c7709c5d9c9", "filename": "src/rt/libuv/include/uv-private/ev.h", "status": "removed", "additions": 0, "deletions": 836, "changes": 836, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fev.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,836 +0,0 @@\n-/*\n- * libev native API header\n- *\n- * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without modifica-\n- * tion, are permitted provided that the following conditions are met:\n- *\n- *   1.  Redistributions of source code must retain the above copyright notice,\n- *       this list of conditions and the following disclaimer.\n- *\n- *   2.  Redistributions in binary form must reproduce the above copyright\n- *       notice, this list of conditions and the following disclaimer in the\n- *       documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-\n- * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n- * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-\n- * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n- * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-\n- * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n- * OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- * Alternatively, the contents of this file may be used under the terms of\n- * the GNU General Public License (\"GPL\") version 2 or any later version,\n- * in which case the provisions of the GPL are applicable instead of\n- * the above. If you wish to allow the use of your version of this file\n- * only under the terms of the GPL and not to allow others to use your\n- * version of this file under the BSD license, indicate your decision\n- * by deleting the provisions above and replace them with the notice\n- * and other provisions required by the GPL. If you do not delete the\n- * provisions above, a recipient may use your version of this file under\n- * either the BSD or the GPL.\n- */\n-\n-#ifndef EV_H_\n-#define EV_H_\n-\n-#ifdef __cplusplus\n-# define EV_CPP(x) x\n-#else\n-# define EV_CPP(x)\n-#endif\n-\n-EV_CPP(extern \"C\" {)\n-\n-#ifdef __GNUC__\n-# define EV_MAYBE_UNUSED __attribute__ ((unused))\n-#else\n-# define EV_MAYBE_UNUSED\n-#endif\n-\n-/*****************************************************************************/\n-\n-/* pre-4.0 compatibility */\n-#ifndef EV_COMPAT3\n-# define EV_COMPAT3 1\n-#endif\n-\n-#ifndef EV_FEATURES\n-# define EV_FEATURES 0x7f\n-#endif\n-\n-#define EV_FEATURE_CODE     ((EV_FEATURES) &  1)\n-#define EV_FEATURE_DATA     ((EV_FEATURES) &  2)\n-#define EV_FEATURE_CONFIG   ((EV_FEATURES) &  4)\n-#define EV_FEATURE_API      ((EV_FEATURES) &  8)\n-#define EV_FEATURE_WATCHERS ((EV_FEATURES) & 16)\n-#define EV_FEATURE_BACKENDS ((EV_FEATURES) & 32)\n-#define EV_FEATURE_OS       ((EV_FEATURES) & 64)\n-\n-/* these priorities are inclusive, higher priorities will be invoked earlier */\n-#ifndef EV_MINPRI\n-# define EV_MINPRI (EV_FEATURE_CONFIG ? -2 : 0)\n-#endif\n-#ifndef EV_MAXPRI\n-# define EV_MAXPRI (EV_FEATURE_CONFIG ? +2 : 0)\n-#endif\n-\n-#ifndef EV_MULTIPLICITY\n-# define EV_MULTIPLICITY EV_FEATURE_CONFIG\n-#endif\n-\n-#ifndef EV_PERIODIC_ENABLE\n-# define EV_PERIODIC_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_STAT_ENABLE\n-# define EV_STAT_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_PREPARE_ENABLE\n-# define EV_PREPARE_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_CHECK_ENABLE\n-# define EV_CHECK_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_IDLE_ENABLE\n-# define EV_IDLE_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_FORK_ENABLE\n-# define EV_FORK_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_CLEANUP_ENABLE\n-# define EV_CLEANUP_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_SIGNAL_ENABLE\n-# define EV_SIGNAL_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_CHILD_ENABLE\n-# ifdef _WIN32\n-#  define EV_CHILD_ENABLE 0\n-# else\n-#  define EV_CHILD_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-#endif\n-\n-#ifndef EV_ASYNC_ENABLE\n-# define EV_ASYNC_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_EMBED_ENABLE\n-# define EV_EMBED_ENABLE EV_FEATURE_WATCHERS\n-#endif\n-\n-#ifndef EV_WALK_ENABLE\n-# define EV_WALK_ENABLE 0 /* not yet */\n-#endif\n-\n-/*****************************************************************************/\n-\n-#if EV_CHILD_ENABLE && !EV_SIGNAL_ENABLE\n-# undef EV_SIGNAL_ENABLE\n-# define EV_SIGNAL_ENABLE 1\n-#endif\n-\n-/*****************************************************************************/\n-\n-typedef double ev_tstamp;\n-\n-#ifndef EV_ATOMIC_T\n-# include <signal.h>\n-# define EV_ATOMIC_T sig_atomic_t volatile\n-#endif\n-\n-#if EV_STAT_ENABLE\n-# ifdef _WIN32\n-#  include <time.h>\n-#  include <sys/types.h>\n-# endif\n-# include <sys/stat.h>\n-#endif\n-\n-/* support multiple event loops? */\n-#if EV_MULTIPLICITY\n-struct ev_loop;\n-# define EV_P  struct ev_loop *loop               /* a loop as sole parameter in a declaration */\n-# define EV_P_ EV_P,                              /* a loop as first of multiple parameters */\n-# define EV_A  loop                               /* a loop as sole argument to a function call */\n-# define EV_A_ EV_A,                              /* a loop as first of multiple arguments */\n-# define EV_DEFAULT_UC  ev_default_loop_uc_ ()    /* the default loop, if initialised, as sole arg */\n-# define EV_DEFAULT_UC_ EV_DEFAULT_UC,            /* the default loop as first of multiple arguments */\n-# define EV_DEFAULT  ev_default_loop (0)          /* the default loop as sole arg */\n-# define EV_DEFAULT_ EV_DEFAULT,                  /* the default loop as first of multiple arguments */\n-#else\n-# define EV_P void\n-# define EV_P_\n-# define EV_A\n-# define EV_A_\n-# define EV_DEFAULT\n-# define EV_DEFAULT_\n-# define EV_DEFAULT_UC\n-# define EV_DEFAULT_UC_\n-# undef EV_EMBED_ENABLE\n-#endif\n-\n-/* EV_INLINE is used for functions in header files */\n-#if __STDC_VERSION__ >= 199901L && __GNUC__ >= 3\n-# define EV_INLINE static inline\n-#else\n-# define EV_INLINE static\n-#endif\n-\n-/* EV_PROTOTYPES can be used to switch of prototype declarations */\n-#ifndef EV_PROTOTYPES\n-# define EV_PROTOTYPES 1\n-#endif\n-\n-/*****************************************************************************/\n-\n-#define EV_VERSION_MAJOR 4\n-#define EV_VERSION_MINOR 4\n-\n-/* eventmask, revents, events... */\n-enum {\n-  EV_UNDEF    =         -1, /* guaranteed to be invalid */\n-  EV_NONE     =       0x00, /* no events */\n-  EV_READ     =       0x01, /* ev_io detected read will not block */\n-  EV_WRITE    =       0x02, /* ev_io detected write will not block */\n-  EV_LIBUV_KQUEUE_HACK = 0x40,\n-  EV__IOFDSET =       0x80, /* internal use only */\n-  EV_IO       =    EV_READ, /* alias for type-detection */\n-  EV_TIMER    = 0x00000100, /* timer timed out */\n-#if EV_COMPAT3\n-  EV_TIMEOUT  =   EV_TIMER, /* pre 4.0 API compatibility */\n-#endif\n-  EV_PERIODIC = 0x00000200, /* periodic timer timed out */\n-  EV_SIGNAL   = 0x00000400, /* signal was received */\n-  EV_CHILD    = 0x00000800, /* child/pid had status change */\n-  EV_STAT     = 0x00001000, /* stat data changed */\n-  EV_IDLE     = 0x00002000, /* event loop is idling */\n-  EV_PREPARE  = 0x00004000, /* event loop about to poll */\n-  EV_CHECK    = 0x00008000, /* event loop finished poll */\n-  EV_EMBED    = 0x00010000, /* embedded event loop needs sweep */\n-  EV_FORK     = 0x00020000, /* event loop resumed in child */\n-  EV_CLEANUP  = 0x00040000, /* event loop resumed in child */\n-  EV_ASYNC    = 0x00080000, /* async intra-loop signal */\n-  EV_CUSTOM   = 0x01000000, /* for use by user code */\n-  EV_ERROR    = (-2147483647 - 1) /* sent when an error occurs */\n-};\n-\n-/* can be used to add custom fields to all watchers, while losing binary compatibility */\n-#ifndef EV_COMMON\n-# define EV_COMMON void *data;\n-#endif\n-\n-#ifndef EV_CB_DECLARE\n-# define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents);\n-#endif\n-#ifndef EV_CB_INVOKE\n-# define EV_CB_INVOKE(watcher,revents) (watcher)->cb (EV_A_ (watcher), (revents))\n-#endif\n-\n-/* not official, do not use */\n-#define EV_CB(type,name) void name (EV_P_ struct ev_ ## type *w, int revents)\n-\n-/*\n- * struct member types:\n- * private: you may look at them, but not change them,\n- *          and they might not mean anything to you.\n- * ro: can be read anytime, but only changed when the watcher isn't active.\n- * rw: can be read and modified anytime, even when the watcher is active.\n- *\n- * some internal details that might be helpful for debugging:\n- *\n- * active is either 0, which means the watcher is not active,\n- *           or the array index of the watcher (periodics, timers)\n- *           or the array index + 1 (most other watchers)\n- *           or simply 1 for watchers that aren't in some array.\n- * pending is either 0, in which case the watcher isn't,\n- *           or the array index + 1 in the pendings array.\n- */\n-\n-#if EV_MINPRI == EV_MAXPRI\n-# define EV_DECL_PRIORITY\n-#elif !defined (EV_DECL_PRIORITY)\n-# define EV_DECL_PRIORITY int priority;\n-#endif\n-\n-/* shared by all watchers */\n-#define EV_WATCHER(type)\t\t\t\\\n-  int active; /* private */\t\t\t\\\n-  int pending; /* private */\t\t\t\\\n-  EV_DECL_PRIORITY /* private */\t\t\\\n-  EV_COMMON /* rw */\t\t\t\t\\\n-  EV_CB_DECLARE (type) /* private */\n-\n-#define EV_WATCHER_LIST(type)\t\t\t\\\n-  EV_WATCHER (type)\t\t\t\t\\\n-  struct ev_watcher_list *next; /* private */\n-\n-#define EV_WATCHER_TIME(type)\t\t\t\\\n-  EV_WATCHER (type)\t\t\t\t\\\n-  ev_tstamp at;     /* private */\n-\n-/* base class, nothing to see here unless you subclass */\n-typedef struct ev_watcher\n-{\n-  EV_WATCHER (ev_watcher)\n-} ev_watcher;\n-\n-/* base class, nothing to see here unless you subclass */\n-typedef struct ev_watcher_list\n-{\n-  EV_WATCHER_LIST (ev_watcher_list)\n-} ev_watcher_list;\n-\n-/* base class, nothing to see here unless you subclass */\n-typedef struct ev_watcher_time\n-{\n-  EV_WATCHER_TIME (ev_watcher_time)\n-} ev_watcher_time;\n-\n-/* invoked when fd is either EV_READable or EV_WRITEable */\n-/* revent EV_READ, EV_WRITE */\n-typedef struct ev_io\n-{\n-  EV_WATCHER_LIST (ev_io)\n-\n-  int fd;     /* ro */\n-  int events; /* ro */\n-} ev_io;\n-\n-/* invoked after a specific time, repeatable (based on monotonic clock) */\n-/* revent EV_TIMEOUT */\n-typedef struct ev_timer\n-{\n-  EV_WATCHER_TIME (ev_timer)\n-\n-  ev_tstamp repeat; /* rw */\n-} ev_timer;\n-\n-/* invoked at some specific time, possibly repeating at regular intervals (based on UTC) */\n-/* revent EV_PERIODIC */\n-typedef struct ev_periodic\n-{\n-  EV_WATCHER_TIME (ev_periodic)\n-\n-  ev_tstamp offset; /* rw */\n-  ev_tstamp interval; /* rw */\n-  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now); /* rw */\n-} ev_periodic;\n-\n-/* invoked when the given signal has been received */\n-/* revent EV_SIGNAL */\n-typedef struct ev_signal\n-{\n-  EV_WATCHER_LIST (ev_signal)\n-\n-  int signum; /* ro */\n-} ev_signal;\n-\n-/* invoked when sigchld is received and waitpid indicates the given pid */\n-/* revent EV_CHILD */\n-/* does not support priorities */\n-typedef struct ev_child\n-{\n-  EV_WATCHER_LIST (ev_child)\n-\n-  int flags;   /* private */\n-  int pid;     /* ro */\n-  int rpid;    /* rw, holds the received pid */\n-  int rstatus; /* rw, holds the exit status, use the macros from sys/wait.h */\n-} ev_child;\n-\n-#if EV_STAT_ENABLE\n-/* st_nlink = 0 means missing file or other error */\n-# ifdef _WIN32\n-typedef struct _stati64 ev_statdata;\n-# else\n-typedef struct stat ev_statdata;\n-# endif\n-\n-/* invoked each time the stat data changes for a given path */\n-/* revent EV_STAT */\n-typedef struct ev_stat\n-{\n-  EV_WATCHER_LIST (ev_stat)\n-\n-  ev_timer timer;     /* private */\n-  ev_tstamp interval; /* ro */\n-  const char *path;   /* ro */\n-  ev_statdata prev;   /* ro */\n-  ev_statdata attr;   /* ro */\n-\n-  int wd; /* wd for inotify, fd for kqueue */\n-} ev_stat;\n-#endif\n-\n-#if EV_IDLE_ENABLE\n-/* invoked when the nothing else needs to be done, keeps the process from blocking */\n-/* revent EV_IDLE */\n-typedef struct ev_idle\n-{\n-  EV_WATCHER (ev_idle)\n-} ev_idle;\n-#endif\n-\n-/* invoked for each run of the mainloop, just before the blocking call */\n-/* you can still change events in any way you like */\n-/* revent EV_PREPARE */\n-typedef struct ev_prepare\n-{\n-  EV_WATCHER (ev_prepare)\n-} ev_prepare;\n-\n-/* invoked for each run of the mainloop, just after the blocking call */\n-/* revent EV_CHECK */\n-typedef struct ev_check\n-{\n-  EV_WATCHER (ev_check)\n-} ev_check;\n-\n-#if EV_FORK_ENABLE\n-/* the callback gets invoked before check in the child process when a fork was detected */\n-/* revent EV_FORK */\n-typedef struct ev_fork\n-{\n-  EV_WATCHER (ev_fork)\n-} ev_fork;\n-#endif\n-\n-#if EV_CLEANUP_ENABLE\n-/* is invoked just before the loop gets destroyed */\n-/* revent EV_CLEANUP */\n-typedef struct ev_cleanup\n-{\n-  EV_WATCHER (ev_cleanup)\n-} ev_cleanup;\n-#endif\n-\n-#if EV_EMBED_ENABLE\n-/* used to embed an event loop inside another */\n-/* the callback gets invoked when the event loop has handled events, and can be 0 */\n-typedef struct ev_embed\n-{\n-  EV_WATCHER (ev_embed)\n-\n-  struct ev_loop *other; /* ro */\n-  ev_io io;              /* private */\n-  ev_prepare prepare;    /* private */\n-  ev_check check;        /* unused */\n-  ev_timer timer;        /* unused */\n-  ev_periodic periodic;  /* unused */\n-  ev_idle idle;          /* unused */\n-  ev_fork fork;          /* private */\n-#if EV_CLEANUP_ENABLE\n-  ev_cleanup cleanup;    /* unused */\n-#endif\n-} ev_embed;\n-#endif\n-\n-#if EV_ASYNC_ENABLE\n-/* invoked when somebody calls ev_async_send on the watcher */\n-/* revent EV_ASYNC */\n-typedef struct ev_async\n-{\n-  EV_WATCHER (ev_async)\n-\n-  EV_ATOMIC_T sent; /* private */\n-} ev_async;\n-\n-# define ev_async_pending(w) (+(w)->sent)\n-#endif\n-\n-/* the presence of this union forces similar struct layout */\n-union ev_any_watcher\n-{\n-  struct ev_watcher w;\n-  struct ev_watcher_list wl;\n-\n-  struct ev_io io;\n-  struct ev_timer timer;\n-  struct ev_periodic periodic;\n-  struct ev_signal signal;\n-  struct ev_child child;\n-#if EV_STAT_ENABLE\n-  struct ev_stat stat;\n-#endif\n-#if EV_IDLE_ENABLE\n-  struct ev_idle idle;\n-#endif\n-  struct ev_prepare prepare;\n-  struct ev_check check;\n-#if EV_FORK_ENABLE\n-  struct ev_fork fork;\n-#endif\n-#if EV_CLEANUP_ENABLE\n-  struct ev_cleanup cleanup;\n-#endif\n-#if EV_EMBED_ENABLE\n-  struct ev_embed embed;\n-#endif\n-#if EV_ASYNC_ENABLE\n-  struct ev_async async;\n-#endif\n-};\n-\n-/* flag bits for ev_default_loop and ev_loop_new */\n-enum {\n-  /* the default */\n-  EVFLAG_AUTO      = 0x00000000U, /* not quite a mask */\n-  /* flag bits */\n-  EVFLAG_NOENV     = 0x01000000U, /* do NOT consult environment */\n-  EVFLAG_FORKCHECK = 0x02000000U, /* check for a fork in each iteration */\n-  /* debugging/feature disable */\n-  EVFLAG_NOINOTIFY = 0x00100000U, /* do not attempt to use inotify */\n-#if EV_COMPAT3\n-  EVFLAG_NOSIGFD   = 0, /* compatibility to pre-3.9 */\n-#endif\n-  EVFLAG_SIGNALFD  = 0x00200000U, /* attempt to use signalfd */\n-  EVFLAG_NOSIGMASK = 0x00400000U  /* avoid modifying the signal mask */\n-};\n-\n-/* method bits to be ored together */\n-enum {\n-  EVBACKEND_SELECT  = 0x00000001U, /* about anywhere */\n-  EVBACKEND_POLL    = 0x00000002U, /* !win */\n-  EVBACKEND_EPOLL   = 0x00000004U, /* linux */\n-  EVBACKEND_KQUEUE  = 0x00000008U, /* bsd */\n-  EVBACKEND_DEVPOLL = 0x00000010U, /* solaris 8 */ /* NYI */\n-  EVBACKEND_PORT    = 0x00000020U, /* solaris 10 */\n-  EVBACKEND_ALL     = 0x0000003FU, /* all known backends */\n-  EVBACKEND_MASK    = 0x0000FFFFU  /* all future backends */\n-};\n-\n-#if EV_PROTOTYPES\n-int ev_version_major (void);\n-int ev_version_minor (void);\n-\n-unsigned int ev_supported_backends (void);\n-unsigned int ev_recommended_backends (void);\n-unsigned int ev_embeddable_backends (void);\n-\n-ev_tstamp ev_time (void);\n-void ev_sleep (ev_tstamp delay); /* sleep for a while */\n-\n-/* Sets the allocation function to use, works like realloc.\n- * It is used to allocate and free memory.\n- * If it returns zero when memory needs to be allocated, the library might abort\n- * or take some potentially destructive action.\n- * The default is your system realloc function.\n- */\n-void ev_set_allocator (void *(*cb)(void *ptr, long size));\n-\n-/* set the callback function to call on a\n- * retryable syscall error\n- * (such as failed select, poll, epoll_wait)\n- */\n-void ev_set_syserr_cb (void (*cb)(const char *msg));\n-\n-#if EV_MULTIPLICITY\n-\n-/* the default loop is the only one that handles signals and child watchers */\n-/* you can call this as often as you like */\n-struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0));\n-\n-EV_INLINE struct ev_loop *\n-EV_MAYBE_UNUSED ev_default_loop_uc_ (void)\n-{\n-  extern struct ev_loop *ev_default_loop_ptr;\n-\n-  return ev_default_loop_ptr;\n-}\n-\n-EV_INLINE int\n-EV_MAYBE_UNUSED ev_is_default_loop (EV_P)\n-{\n-  return EV_A == EV_DEFAULT_UC;\n-}\n-\n-/* create and destroy alternative loops that don't handle signals */\n-struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0));\n-\n-ev_tstamp ev_now (EV_P); /* time w.r.t. timers and the eventloop, updated after each poll */\n-\n-#else\n-\n-int ev_default_loop (unsigned int flags EV_CPP (= 0)); /* returns true when successful */\n-\n-EV_INLINE ev_tstamp\n-ev_now (void)\n-{\n-  extern ev_tstamp ev_rt_now;\n-\n-  return ev_rt_now;\n-}\n-\n-/* looks weird, but ev_is_default_loop (EV_A) still works if this exists */\n-EV_INLINE int\n-ev_is_default_loop (void)\n-{\n-  return 1;\n-}\n-\n-#endif /* multiplicity */\n-\n-/* destroy event loops, also works for the default loop */\n-void ev_loop_destroy (EV_P);\n-\n-/* this needs to be called after fork, to duplicate the loop */\n-/* when you want to re-use it in the child */\n-/* you can call it in either the parent or the child */\n-/* you can actually call it at any time, anywhere :) */\n-void ev_loop_fork (EV_P);\n-\n-unsigned int ev_backend (EV_P); /* backend in use by loop */\n-\n-void ev_now_update (EV_P); /* update event loop time */\n-\n-#if EV_WALK_ENABLE\n-/* walk (almost) all watchers in the loop of a given type, invoking the */\n-/* callback on every such watcher. The callback might stop the watcher, */\n-/* but do nothing else with the loop */\n-void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w));\n-#endif\n-\n-#endif /* prototypes */\n-\n-/* ev_run flags values */\n-enum {\n-  EVRUN_NOWAIT = 1, /* do not block/wait */\n-  EVRUN_ONCE   = 2  /* block *once* only */\n-};\n-\n-/* ev_break how values */\n-enum {\n-  EVBREAK_CANCEL = 0, /* undo unloop */\n-  EVBREAK_ONE    = 1, /* unloop once */\n-  EVBREAK_ALL    = 2  /* unloop all loops */\n-};\n-\n-#if EV_PROTOTYPES\n-void ev_run (EV_P_ int flags EV_CPP (= 0));\n-void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)); /* break out of the loop */\n-\n-/*\n- * ref/unref can be used to add or remove a refcount on the mainloop. every watcher\n- * keeps one reference. if you have a long-running watcher you never unregister that\n- * should not keep ev_loop from running, unref() after starting, and ref() before stopping.\n- */\n-void ev_ref   (EV_P);\n-void ev_unref (EV_P);\n-\n-/*\n- * convenience function, wait for a single event, without registering an event watcher\n- * if timeout is < 0, do wait indefinitely\n- */\n-void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg);\n-\n-# if EV_FEATURE_API\n-unsigned int ev_iteration (EV_P); /* number of loop iterations */\n-unsigned int ev_depth     (EV_P); /* #ev_loop enters - #ev_loop leaves */\n-void         ev_verify    (EV_P); /* abort if loop data corrupted */\n-\n-void ev_set_io_collect_interval (EV_P_ ev_tstamp interval); /* sleep at least this time, default 0 */\n-void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval); /* sleep at least this time, default 0 */\n-\n-/* advanced stuff for threading etc. support, see docs */\n-void ev_set_userdata (EV_P_ void *data);\n-void *ev_userdata (EV_P);\n-void ev_set_invoke_pending_cb (EV_P_ void (*invoke_pending_cb)(EV_P));\n-void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P), void (*acquire)(EV_P));\n-\n-unsigned int ev_pending_count (EV_P); /* number of pending events, if any */\n-void ev_invoke_pending (EV_P); /* invoke all pending watchers */\n-\n-/*\n- * stop/start the timer handling.\n- */\n-void ev_suspend (EV_P);\n-void ev_resume  (EV_P);\n-#endif\n-\n-#endif\n-\n-/* these may evaluate ev multiple times, and the other arguments at most once */\n-/* either use ev_init + ev_TYPE_set, or the ev_TYPE_init macro, below, to first initialise a watcher */\n-#define ev_init(ev,cb_) do {\t\t\t\\\n-  ((ev_watcher *)(void *)(ev))->active  =\t\\\n-  ((ev_watcher *)(void *)(ev))->pending = 0;\t\\\n-  ev_set_priority ((ev), 0);\t\t\t\\\n-  ev_set_cb ((ev), cb_);\t\t\t\\\n-} while (0)\n-\n-#define ev_io_set(ev,fd_,events_)            do { (ev)->fd = (fd_); (ev)->events = (events_) | EV__IOFDSET; } while (0)\n-#define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))->at = (after_); (ev)->repeat = (repeat_); } while (0)\n-#define ev_periodic_set(ev,ofs_,ival_,rcb_)  do { (ev)->offset = (ofs_); (ev)->interval = (ival_); (ev)->reschedule_cb = (rcb_); } while (0)\n-#define ev_signal_set(ev,signum_)            do { (ev)->signum = (signum_); } while (0)\n-#define ev_child_set(ev,pid_,trace_)         do { (ev)->pid = (pid_); (ev)->flags = !!(trace_); } while (0)\n-#define ev_stat_set(ev,path_,interval_)      do { (ev)->path = (path_); (ev)->interval = (interval_); (ev)->wd = -2; } while (0)\n-#define ev_idle_set(ev)                      /* nop, yes, this is a serious in-joke */\n-#define ev_prepare_set(ev)                   /* nop, yes, this is a serious in-joke */\n-#define ev_check_set(ev)                     /* nop, yes, this is a serious in-joke */\n-#define ev_embed_set(ev,other_)              do { (ev)->other = (other_); } while (0)\n-#define ev_fork_set(ev)                      /* nop, yes, this is a serious in-joke */\n-#define ev_cleanup_set(ev)                   /* nop, yes, this is a serious in-joke */\n-#define ev_async_set(ev)                     /* nop, yes, this is a serious in-joke */\n-\n-#define ev_io_init(ev,cb,fd,events)          do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)\n-#define ev_timer_init(ev,cb,after,repeat)    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)\n-#define ev_periodic_init(ev,cb,ofs,ival,rcb) do { ev_init ((ev), (cb)); ev_periodic_set ((ev),(ofs),(ival),(rcb)); } while (0)\n-#define ev_signal_init(ev,cb,signum)         do { ev_init ((ev), (cb)); ev_signal_set ((ev), (signum)); } while (0)\n-#define ev_child_init(ev,cb,pid,trace)       do { ev_init ((ev), (cb)); ev_child_set ((ev),(pid),(trace)); } while (0)\n-#define ev_stat_init(ev,cb,path,interval)    do { ev_init ((ev), (cb)); ev_stat_set ((ev),(path),(interval)); } while (0)\n-#define ev_idle_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_idle_set ((ev)); } while (0)\n-#define ev_prepare_init(ev,cb)               do { ev_init ((ev), (cb)); ev_prepare_set ((ev)); } while (0)\n-#define ev_check_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_check_set ((ev)); } while (0)\n-#define ev_embed_init(ev,cb,other)           do { ev_init ((ev), (cb)); ev_embed_set ((ev),(other)); } while (0)\n-#define ev_fork_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_fork_set ((ev)); } while (0)\n-#define ev_cleanup_init(ev,cb)               do { ev_init ((ev), (cb)); ev_cleanup_set ((ev)); } while (0)\n-#define ev_async_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_async_set ((ev)); } while (0)\n-\n-#define ev_is_pending(ev)                    (0 + ((ev_watcher *)(void *)(ev))->pending) /* ro, true when watcher is waiting for callback invocation */\n-#define ev_is_active(ev)                     (0 + ((ev_watcher *)(void *)(ev))->active) /* ro, true when the watcher has been started */\n-\n-#define ev_cb(ev)                            (ev)->cb /* rw */\n-\n-#if EV_MINPRI == EV_MAXPRI\n-# define ev_priority(ev)                     ((ev), EV_MINPRI)\n-# define ev_set_priority(ev,pri)             ((ev), (pri))\n-#else\n-# define ev_priority(ev)                     (+(((ev_watcher *)(void *)(ev))->priority))\n-# define ev_set_priority(ev,pri)             (   (ev_watcher *)(void *)(ev))->priority = (pri)\n-#endif\n-\n-#define ev_periodic_at(ev)                   (+((ev_watcher_time *)(ev))->at)\n-\n-#ifndef ev_set_cb\n-# define ev_set_cb(ev,cb_)                   ev_cb (ev) = (cb_)\n-#endif\n-\n-/* stopping (enabling, adding) a watcher does nothing if it is already running */\n-/* stopping (disabling, deleting) a watcher does nothing unless its already running */\n-#if EV_PROTOTYPES\n-\n-/* feeds an event into a watcher as if the event actually occured */\n-/* accepts any ev_watcher type */\n-void ev_feed_event     (EV_P_ void *w, int revents);\n-void ev_feed_fd_event  (EV_P_ int fd, int revents);\n-#if EV_SIGNAL_ENABLE\n-void ev_feed_signal    (int signum);\n-void ev_feed_signal_event (EV_P_ int signum);\n-#endif\n-void ev_invoke         (EV_P_ void *w, int revents);\n-int  ev_clear_pending  (EV_P_ void *w);\n-\n-void ev_io_start       (EV_P_ ev_io *w);\n-void ev_io_stop        (EV_P_ ev_io *w);\n-\n-void ev_timer_start    (EV_P_ ev_timer *w);\n-void ev_timer_stop     (EV_P_ ev_timer *w);\n-/* stops if active and no repeat, restarts if active and repeating, starts if inactive and repeating */\n-void ev_timer_again    (EV_P_ ev_timer *w);\n-/* return remaining time */\n-ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w);\n-\n-#if EV_PERIODIC_ENABLE\n-void ev_periodic_start (EV_P_ ev_periodic *w);\n-void ev_periodic_stop  (EV_P_ ev_periodic *w);\n-void ev_periodic_again (EV_P_ ev_periodic *w);\n-#endif\n-\n-/* only supported in the default loop */\n-#if EV_SIGNAL_ENABLE\n-void ev_signal_start   (EV_P_ ev_signal *w);\n-void ev_signal_stop    (EV_P_ ev_signal *w);\n-#endif\n-\n-/* only supported in the default loop */\n-# if EV_CHILD_ENABLE\n-void ev_child_start    (EV_P_ ev_child *w);\n-void ev_child_stop     (EV_P_ ev_child *w);\n-# endif\n-\n-# if EV_STAT_ENABLE\n-void ev_stat_start     (EV_P_ ev_stat *w);\n-void ev_stat_stop      (EV_P_ ev_stat *w);\n-void ev_stat_stat      (EV_P_ ev_stat *w);\n-# endif\n-\n-# if EV_IDLE_ENABLE\n-void ev_idle_start     (EV_P_ ev_idle *w);\n-void ev_idle_stop      (EV_P_ ev_idle *w);\n-# endif\n-\n-#if EV_PREPARE_ENABLE\n-void ev_prepare_start  (EV_P_ ev_prepare *w);\n-void ev_prepare_stop   (EV_P_ ev_prepare *w);\n-#endif\n-\n-#if EV_CHECK_ENABLE\n-void ev_check_start    (EV_P_ ev_check *w);\n-void ev_check_stop     (EV_P_ ev_check *w);\n-#endif\n-\n-# if EV_FORK_ENABLE\n-void ev_fork_start     (EV_P_ ev_fork *w);\n-void ev_fork_stop      (EV_P_ ev_fork *w);\n-# endif\n-\n-# if EV_CLEANUP_ENABLE\n-void ev_cleanup_start  (EV_P_ ev_cleanup *w);\n-void ev_cleanup_stop   (EV_P_ ev_cleanup *w);\n-# endif\n-\n-# if EV_EMBED_ENABLE\n-/* only supported when loop to be embedded is in fact embeddable */\n-void ev_embed_start    (EV_P_ ev_embed *w);\n-void ev_embed_stop     (EV_P_ ev_embed *w);\n-void ev_embed_sweep    (EV_P_ ev_embed *w);\n-# endif\n-\n-# if EV_ASYNC_ENABLE\n-void ev_async_start    (EV_P_ ev_async *w);\n-void ev_async_stop     (EV_P_ ev_async *w);\n-void ev_async_send     (EV_P_ ev_async *w);\n-# endif\n-\n-#if EV_COMPAT3\n-  #define EVLOOP_NONBLOCK EVRUN_NOWAIT\n-  #define EVLOOP_ONESHOT  EVRUN_ONCE\n-  #define EVUNLOOP_CANCEL EVBREAK_CANCEL\n-  #define EVUNLOOP_ONE    EVBREAK_ONE\n-  #define EVUNLOOP_ALL    EVBREAK_ALL\n-  #if EV_PROTOTYPES\n-    EV_INLINE void EV_MAYBE_UNUSED ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }\n-    EV_INLINE void EV_MAYBE_UNUSED ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }\n-    EV_INLINE void EV_MAYBE_UNUSED ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }\n-    EV_INLINE void EV_MAYBE_UNUSED ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }\n-    #if EV_FEATURE_API\n-      EV_INLINE unsigned int EV_MAYBE_UNUSED ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }\n-      EV_INLINE unsigned int EV_MAYBE_UNUSED ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }\n-      EV_INLINE void         EV_MAYBE_UNUSED ev_loop_verify (EV_P) {        ev_verify     (EV_A); }\n-    #endif\n-  #endif\n-#else\n-  typedef struct ev_loop ev_loop;\n-#endif\n-\n-#endif\n-\n-EV_CPP(})\n-\n-#endif\n-"}, {"sha": "f8576d67dc24f44fa6d1cf5c112ad15160457d7e", "filename": "src/rt/libuv/include/uv-private/ngx-queue.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fngx-queue.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,102 +0,0 @@\n-\n-/*\n- * Copyright (C) Igor Sysoev\n- */\n-\n-\n-#ifndef _NGX_QUEUE_H_INCLUDED_\n-#define _NGX_QUEUE_H_INCLUDED_\n-\n-\n-typedef struct ngx_queue_s  ngx_queue_t;\n-\n-struct ngx_queue_s {\n-    ngx_queue_t  *prev;\n-    ngx_queue_t  *next;\n-};\n-\n-\n-#define ngx_queue_init(q)                                                     \\\n-    (q)->prev = q;                                                            \\\n-    (q)->next = q\n-\n-\n-#define ngx_queue_empty(h)                                                    \\\n-    (h == (h)->prev)\n-\n-\n-#define ngx_queue_insert_head(h, x)                                           \\\n-    (x)->next = (h)->next;                                                    \\\n-    (x)->next->prev = x;                                                      \\\n-    (x)->prev = h;                                                            \\\n-    (h)->next = x\n-\n-\n-#define ngx_queue_insert_after   ngx_queue_insert_head\n-\n-\n-#define ngx_queue_insert_tail(h, x)                                           \\\n-    (x)->prev = (h)->prev;                                                    \\\n-    (x)->prev->next = x;                                                      \\\n-    (x)->next = h;                                                            \\\n-    (h)->prev = x\n-\n-\n-#define ngx_queue_head(h)                                                     \\\n-    (h)->next\n-\n-\n-#define ngx_queue_last(h)                                                     \\\n-    (h)->prev\n-\n-\n-#define ngx_queue_sentinel(h)                                                 \\\n-    (h)\n-\n-\n-#define ngx_queue_next(q)                                                     \\\n-    (q)->next\n-\n-\n-#define ngx_queue_prev(q)                                                     \\\n-    (q)->prev\n-\n-\n-#if (NGX_DEBUG)\n-\n-#define ngx_queue_remove(x)                                                   \\\n-    (x)->next->prev = (x)->prev;                                              \\\n-    (x)->prev->next = (x)->next;                                              \\\n-    (x)->prev = NULL;                                                         \\\n-    (x)->next = NULL\n-\n-#else\n-\n-#define ngx_queue_remove(x)                                                   \\\n-    (x)->next->prev = (x)->prev;                                              \\\n-    (x)->prev->next = (x)->next\n-\n-#endif\n-\n-\n-#define ngx_queue_split(h, q, n)                                              \\\n-    (n)->prev = (h)->prev;                                                    \\\n-    (n)->prev->next = n;                                                      \\\n-    (n)->next = q;                                                            \\\n-    (h)->prev = (q)->prev;                                                    \\\n-    (h)->prev->next = h;                                                      \\\n-    (q)->prev = n;\n-\n-\n-#define ngx_queue_add(h, n)                                                   \\\n-    (h)->prev->next = (n)->next;                                              \\\n-    (n)->next->prev = (h)->prev;                                              \\\n-    (h)->prev = (n)->prev;                                                    \\\n-    (h)->prev->next = h;\n-\n-\n-#define ngx_queue_data(q, type, link)                                         \\\n-    (type *) ((unsigned char *) q - offsetof(type, link))\n-\n-\n-#endif /* _NGX_QUEUE_H_INCLUDED_ */"}, {"sha": "37966d353c3de68aefa5dba3e773dc8513d0c9d7", "filename": "src/rt/libuv/include/uv-private/tree.h", "status": "removed", "additions": 0, "deletions": 762, "changes": 762, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Ftree.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,762 +0,0 @@\n-/*-\n- * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-#ifndef  _UV_TREE_H_\n-#define  _UV_TREE_H_\n-\n-#define __unused\n-\n-/*\n- * This file defines data structures for different types of trees:\n- * splay trees and red-black trees.\n- *\n- * A splay tree is a self-organizing data structure.  Every operation\n- * on the tree causes a splay to happen.  The splay moves the requested\n- * node to the root of the tree and partly rebalances it.\n- *\n- * This has the benefit that request locality causes faster lookups as\n- * the requested nodes move to the top of the tree.  On the other hand,\n- * every lookup causes memory writes.\n- *\n- * The Balance Theorem bounds the total access time for m operations\n- * and n inserts on an initially empty tree as O((m + n)lg n).  The\n- * amortized cost for a sequence of m accesses to a splay tree is O(lg n);\n- *\n- * A red-black tree is a binary search tree with the node color as an\n- * extra attribute.  It fulfills a set of conditions:\n- *  - every search path from the root to a leaf consists of the\n- *    same number of black nodes,\n- *  - each red node (except for the root) has a black parent,\n- *  - each leaf node is black.\n- *\n- * Every operation on a red-black tree is bounded as O(lg n).\n- * The maximum height of a red-black tree is 2lg (n+1).\n- */\n-\n-#define SPLAY_HEAD(name, type)                                                \\\n-struct name {                                                                 \\\n-  struct type *sph_root; /* root of the tree */                               \\\n-}\n-\n-#define SPLAY_INITIALIZER(root)                                               \\\n-  { NULL }\n-\n-#define SPLAY_INIT(root) do {                                                 \\\n-  (root)->sph_root = NULL;                                                    \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define SPLAY_ENTRY(type)                                                     \\\n-struct {                                                                      \\\n-  struct type *spe_left;          /* left element */                          \\\n-  struct type *spe_right;         /* right element */                         \\\n-}\n-\n-#define SPLAY_LEFT(elm, field)    (elm)->field.spe_left\n-#define SPLAY_RIGHT(elm, field)   (elm)->field.spe_right\n-#define SPLAY_ROOT(head)          (head)->sph_root\n-#define SPLAY_EMPTY(head)         (SPLAY_ROOT(head) == NULL)\n-\n-/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */\n-#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {                             \\\n-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);              \\\n-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \\\n-  (head)->sph_root = tmp;                                                     \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define SPLAY_ROTATE_LEFT(head, tmp, field) do {                              \\\n-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);              \\\n-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \\\n-  (head)->sph_root = tmp;                                                     \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define SPLAY_LINKLEFT(head, tmp, field) do {                                 \\\n-  SPLAY_LEFT(tmp, field) = (head)->sph_root;                                  \\\n-  tmp = (head)->sph_root;                                                     \\\n-  (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                     \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define SPLAY_LINKRIGHT(head, tmp, field) do {                                \\\n-  SPLAY_RIGHT(tmp, field) = (head)->sph_root;                                 \\\n-  tmp = (head)->sph_root;                                                     \\\n-  (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                    \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define SPLAY_ASSEMBLE(head, node, left, right, field) do {                   \\\n-  SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);             \\\n-  SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);            \\\n-  SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);             \\\n-  SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);             \\\n-} while (/*CONSTCOND*/ 0)\n-\n-/* Generates prototypes and inline functions */\n-\n-#define SPLAY_PROTOTYPE(name, type, field, cmp)                               \\\n-void name##_SPLAY(struct name *, struct type *);                              \\\n-void name##_SPLAY_MINMAX(struct name *, int);                                 \\\n-struct type *name##_SPLAY_INSERT(struct name *, struct type *);               \\\n-struct type *name##_SPLAY_REMOVE(struct name *, struct type *);               \\\n-                                                                              \\\n-/* Finds the node with the same key as elm */                                 \\\n-static __inline struct type *                                                 \\\n-name##_SPLAY_FIND(struct name *head, struct type *elm)                        \\\n-{                                                                             \\\n-  if (SPLAY_EMPTY(head))                                                      \\\n-    return(NULL);                                                             \\\n-  name##_SPLAY(head, elm);                                                    \\\n-  if ((cmp)(elm, (head)->sph_root) == 0)                                      \\\n-    return (head->sph_root);                                                  \\\n-  return (NULL);                                                              \\\n-}                                                                             \\\n-                                                                              \\\n-static __inline struct type *                                                 \\\n-name##_SPLAY_NEXT(struct name *head, struct type *elm)                        \\\n-{                                                                             \\\n-  name##_SPLAY(head, elm);                                                    \\\n-  if (SPLAY_RIGHT(elm, field) != NULL) {                                      \\\n-    elm = SPLAY_RIGHT(elm, field);                                            \\\n-    while (SPLAY_LEFT(elm, field) != NULL) {                                  \\\n-      elm = SPLAY_LEFT(elm, field);                                           \\\n-    }                                                                         \\\n-  } else                                                                      \\\n-    elm = NULL;                                                               \\\n-  return (elm);                                                               \\\n-}                                                                             \\\n-                                                                              \\\n-static __inline struct type *                                                 \\\n-name##_SPLAY_MIN_MAX(struct name *head, int val)                              \\\n-{                                                                             \\\n-  name##_SPLAY_MINMAX(head, val);                                             \\\n-  return (SPLAY_ROOT(head));                                                  \\\n-}\n-\n-/* Main splay operation.\n- * Moves node close to the key of elm to top\n- */\n-#define SPLAY_GENERATE(name, type, field, cmp)                                \\\n-struct type *                                                                 \\\n-name##_SPLAY_INSERT(struct name *head, struct type *elm)                      \\\n-{                                                                             \\\n-    if (SPLAY_EMPTY(head)) {                                                  \\\n-      SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;                \\\n-    } else {                                                                  \\\n-      int __comp;                                                             \\\n-      name##_SPLAY(head, elm);                                                \\\n-      __comp = (cmp)(elm, (head)->sph_root);                                  \\\n-      if(__comp < 0) {                                                        \\\n-        SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);         \\\n-        SPLAY_RIGHT(elm, field) = (head)->sph_root;                           \\\n-        SPLAY_LEFT((head)->sph_root, field) = NULL;                           \\\n-      } else if (__comp > 0) {                                                \\\n-        SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);       \\\n-        SPLAY_LEFT(elm, field) = (head)->sph_root;                            \\\n-        SPLAY_RIGHT((head)->sph_root, field) = NULL;                          \\\n-      } else                                                                  \\\n-        return ((head)->sph_root);                                            \\\n-    }                                                                         \\\n-    (head)->sph_root = (elm);                                                 \\\n-    return (NULL);                                                            \\\n-}                                                                             \\\n-                                                                              \\\n-struct type *                                                                 \\\n-name##_SPLAY_REMOVE(struct name *head, struct type *elm)                      \\\n-{                                                                             \\\n-  struct type *__tmp;                                                         \\\n-  if (SPLAY_EMPTY(head))                                                      \\\n-    return (NULL);                                                            \\\n-  name##_SPLAY(head, elm);                                                    \\\n-  if ((cmp)(elm, (head)->sph_root) == 0) {                                    \\\n-    if (SPLAY_LEFT((head)->sph_root, field) == NULL) {                        \\\n-      (head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);                \\\n-    } else {                                                                  \\\n-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n-      (head)->sph_root = SPLAY_LEFT((head)->sph_root, field);                 \\\n-      name##_SPLAY(head, elm);                                                \\\n-      SPLAY_RIGHT((head)->sph_root, field) = __tmp;                           \\\n-    }                                                                         \\\n-    return (elm);                                                             \\\n-  }                                                                           \\\n-  return (NULL);                                                              \\\n-}                                                                             \\\n-                                                                              \\\n-void                                                                          \\\n-name##_SPLAY(struct name *head, struct type *elm)                             \\\n-{                                                                             \\\n-  struct type __node, *__left, *__right, *__tmp;                              \\\n-  int __comp;                                                                 \\\n-                                                                              \\\n-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \\\n-  __left = __right = &__node;                                                 \\\n-                                                                              \\\n-  while ((__comp = (cmp)(elm, (head)->sph_root)) != 0) {                      \\\n-    if (__comp < 0) {                                                         \\\n-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \\\n-      if (__tmp == NULL)                                                      \\\n-        break;                                                                \\\n-      if ((cmp)(elm, __tmp) < 0){                                             \\\n-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \\\n-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \\\n-          break;                                                              \\\n-      }                                                                       \\\n-      SPLAY_LINKLEFT(head, __right, field);                                   \\\n-    } else if (__comp > 0) {                                                  \\\n-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n-      if (__tmp == NULL)                                                      \\\n-        break;                                                                \\\n-      if ((cmp)(elm, __tmp) > 0){                                             \\\n-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \\\n-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \\\n-          break;                                                              \\\n-      }                                                                       \\\n-      SPLAY_LINKRIGHT(head, __left, field);                                   \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \\\n-}                                                                             \\\n-                                                                              \\\n-/* Splay with either the minimum or the maximum element                       \\\n- * Used to find minimum or maximum element in tree.                           \\\n- */                                                                           \\\n-void name##_SPLAY_MINMAX(struct name *head, int __comp)                       \\\n-{                                                                             \\\n-  struct type __node, *__left, *__right, *__tmp;                              \\\n-                                                                              \\\n-  SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;            \\\n-  __left = __right = &__node;                                                 \\\n-                                                                              \\\n-  while (1) {                                                                 \\\n-    if (__comp < 0) {                                                         \\\n-      __tmp = SPLAY_LEFT((head)->sph_root, field);                            \\\n-      if (__tmp == NULL)                                                      \\\n-        break;                                                                \\\n-      if (__comp < 0){                                                        \\\n-        SPLAY_ROTATE_RIGHT(head, __tmp, field);                               \\\n-        if (SPLAY_LEFT((head)->sph_root, field) == NULL)                      \\\n-          break;                                                              \\\n-      }                                                                       \\\n-      SPLAY_LINKLEFT(head, __right, field);                                   \\\n-    } else if (__comp > 0) {                                                  \\\n-      __tmp = SPLAY_RIGHT((head)->sph_root, field);                           \\\n-      if (__tmp == NULL)                                                      \\\n-        break;                                                                \\\n-      if (__comp > 0) {                                                       \\\n-        SPLAY_ROTATE_LEFT(head, __tmp, field);                                \\\n-        if (SPLAY_RIGHT((head)->sph_root, field) == NULL)                     \\\n-          break;                                                              \\\n-      }                                                                       \\\n-      SPLAY_LINKRIGHT(head, __left, field);                                   \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  SPLAY_ASSEMBLE(head, &__node, __left, __right, field);                      \\\n-}\n-\n-#define SPLAY_NEGINF  -1\n-#define SPLAY_INF     1\n-\n-#define SPLAY_INSERT(name, x, y)  name##_SPLAY_INSERT(x, y)\n-#define SPLAY_REMOVE(name, x, y)  name##_SPLAY_REMOVE(x, y)\n-#define SPLAY_FIND(name, x, y)    name##_SPLAY_FIND(x, y)\n-#define SPLAY_NEXT(name, x, y)    name##_SPLAY_NEXT(x, y)\n-#define SPLAY_MIN(name, x)        (SPLAY_EMPTY(x) ? NULL                      \\\n-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))\n-#define SPLAY_MAX(name, x)        (SPLAY_EMPTY(x) ? NULL                      \\\n-                                  : name##_SPLAY_MIN_MAX(x, SPLAY_INF))\n-\n-#define SPLAY_FOREACH(x, name, head)                                          \\\n-  for ((x) = SPLAY_MIN(name, head);                                           \\\n-       (x) != NULL;                                                           \\\n-       (x) = SPLAY_NEXT(name, head, x))\n-\n-/* Macros that define a red-black tree */\n-#define RB_HEAD(name, type)                                                   \\\n-struct name {                                                                 \\\n-  struct type *rbh_root; /* root of the tree */                               \\\n-}\n-\n-#define RB_INITIALIZER(root)                                                  \\\n-  { NULL }\n-\n-#define RB_INIT(root) do {                                                    \\\n-  (root)->rbh_root = NULL;                                                    \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define RB_BLACK  0\n-#define RB_RED    1\n-#define RB_ENTRY(type)                                                        \\\n-struct {                                                                      \\\n-  struct type *rbe_left;        /* left element */                            \\\n-  struct type *rbe_right;       /* right element */                           \\\n-  struct type *rbe_parent;      /* parent element */                          \\\n-  int rbe_color;                /* node color */                              \\\n-}\n-\n-#define RB_LEFT(elm, field)     (elm)->field.rbe_left\n-#define RB_RIGHT(elm, field)    (elm)->field.rbe_right\n-#define RB_PARENT(elm, field)   (elm)->field.rbe_parent\n-#define RB_COLOR(elm, field)    (elm)->field.rbe_color\n-#define RB_ROOT(head)           (head)->rbh_root\n-#define RB_EMPTY(head)          (RB_ROOT(head) == NULL)\n-\n-#define RB_SET(elm, parent, field) do {                                       \\\n-  RB_PARENT(elm, field) = parent;                                             \\\n-  RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;                          \\\n-  RB_COLOR(elm, field) = RB_RED;                                              \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define RB_SET_BLACKRED(black, red, field) do {                               \\\n-  RB_COLOR(black, field) = RB_BLACK;                                          \\\n-  RB_COLOR(red, field) = RB_RED;                                              \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#ifndef RB_AUGMENT\n-#define RB_AUGMENT(x)  do {} while (0)\n-#endif\n-\n-#define RB_ROTATE_LEFT(head, elm, tmp, field) do {                            \\\n-  (tmp) = RB_RIGHT(elm, field);                                               \\\n-  if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field)) != NULL) {                 \\\n-    RB_PARENT(RB_LEFT(tmp, field), field) = (elm);                            \\\n-  }                                                                           \\\n-  RB_AUGMENT(elm);                                                            \\\n-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \\\n-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \\\n-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \\\n-    else                                                                      \\\n-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \\\n-  } else                                                                      \\\n-    (head)->rbh_root = (tmp);                                                 \\\n-  RB_LEFT(tmp, field) = (elm);                                                \\\n-  RB_PARENT(elm, field) = (tmp);                                              \\\n-  RB_AUGMENT(tmp);                                                            \\\n-  if ((RB_PARENT(tmp, field)))                                                \\\n-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \\\n-} while (/*CONSTCOND*/ 0)\n-\n-#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {                           \\\n-  (tmp) = RB_LEFT(elm, field);                                                \\\n-  if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field)) != NULL) {                 \\\n-    RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);                           \\\n-  }                                                                           \\\n-  RB_AUGMENT(elm);                                                            \\\n-  if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field)) != NULL) {              \\\n-    if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))                       \\\n-      RB_LEFT(RB_PARENT(elm, field), field) = (tmp);                          \\\n-    else                                                                      \\\n-      RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);                         \\\n-  } else                                                                      \\\n-    (head)->rbh_root = (tmp);                                                 \\\n-  RB_RIGHT(tmp, field) = (elm);                                               \\\n-  RB_PARENT(elm, field) = (tmp);                                              \\\n-  RB_AUGMENT(tmp);                                                            \\\n-  if ((RB_PARENT(tmp, field)))                                                \\\n-    RB_AUGMENT(RB_PARENT(tmp, field));                                        \\\n-} while (/*CONSTCOND*/ 0)\n-\n-/* Generates prototypes and inline functions */\n-#define  RB_PROTOTYPE(name, type, field, cmp)                                 \\\n-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)\n-#define  RB_PROTOTYPE_STATIC(name, type, field, cmp)                          \\\n-  RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __unused static)\n-#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)                   \\\n-attr void name##_RB_INSERT_COLOR(struct name *, struct type *);               \\\n-attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\\\n-attr struct type *name##_RB_REMOVE(struct name *, struct type *);             \\\n-attr struct type *name##_RB_INSERT(struct name *, struct type *);             \\\n-attr struct type *name##_RB_FIND(struct name *, struct type *);               \\\n-attr struct type *name##_RB_NFIND(struct name *, struct type *);              \\\n-attr struct type *name##_RB_NEXT(struct type *);                              \\\n-attr struct type *name##_RB_PREV(struct type *);                              \\\n-attr struct type *name##_RB_MINMAX(struct name *, int);                       \\\n-                                                                              \\\n-\n-/* Main rb operation.\n- * Moves node close to the key of elm to top\n- */\n-#define  RB_GENERATE(name, type, field, cmp)                                  \\\n-  RB_GENERATE_INTERNAL(name, type, field, cmp,)\n-#define  RB_GENERATE_STATIC(name, type, field, cmp)                           \\\n-  RB_GENERATE_INTERNAL(name, type, field, cmp, __unused static)\n-#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)                    \\\n-attr void                                                                     \\\n-name##_RB_INSERT_COLOR(struct name *head, struct type *elm)                   \\\n-{                                                                             \\\n-  struct type *parent, *gparent, *tmp;                                        \\\n-  while ((parent = RB_PARENT(elm, field)) != NULL &&                          \\\n-      RB_COLOR(parent, field) == RB_RED) {                                    \\\n-    gparent = RB_PARENT(parent, field);                                       \\\n-    if (parent == RB_LEFT(gparent, field)) {                                  \\\n-      tmp = RB_RIGHT(gparent, field);                                         \\\n-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \\\n-        RB_COLOR(tmp, field) = RB_BLACK;                                      \\\n-        RB_SET_BLACKRED(parent, gparent, field);                              \\\n-        elm = gparent;                                                        \\\n-        continue;                                                             \\\n-      }                                                                       \\\n-      if (RB_RIGHT(parent, field) == elm) {                                   \\\n-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n-        tmp = parent;                                                         \\\n-        parent = elm;                                                         \\\n-        elm = tmp;                                                            \\\n-      }                                                                       \\\n-      RB_SET_BLACKRED(parent, gparent, field);                                \\\n-      RB_ROTATE_RIGHT(head, gparent, tmp, field);                             \\\n-    } else {                                                                  \\\n-      tmp = RB_LEFT(gparent, field);                                          \\\n-      if (tmp && RB_COLOR(tmp, field) == RB_RED) {                            \\\n-        RB_COLOR(tmp, field) = RB_BLACK;                                      \\\n-        RB_SET_BLACKRED(parent, gparent, field);                              \\\n-        elm = gparent;                                                        \\\n-        continue;                                                             \\\n-      }                                                                       \\\n-      if (RB_LEFT(parent, field) == elm) {                                    \\\n-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n-        tmp = parent;                                                         \\\n-        parent = elm;                                                         \\\n-        elm = tmp;                                                            \\\n-      }                                                                       \\\n-      RB_SET_BLACKRED(parent, gparent, field);                                \\\n-      RB_ROTATE_LEFT(head, gparent, tmp, field);                              \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  RB_COLOR(head->rbh_root, field) = RB_BLACK;                                 \\\n-}                                                                             \\\n-                                                                              \\\n-attr void                                                                     \\\n-name##_RB_REMOVE_COLOR(struct name *head, struct type *parent,                \\\n-    struct type *elm)                                                         \\\n-{                                                                             \\\n-  struct type *tmp;                                                           \\\n-  while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&                 \\\n-      elm != RB_ROOT(head)) {                                                 \\\n-    if (RB_LEFT(parent, field) == elm) {                                      \\\n-      tmp = RB_RIGHT(parent, field);                                          \\\n-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \\\n-        RB_SET_BLACKRED(tmp, parent, field);                                  \\\n-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n-        tmp = RB_RIGHT(parent, field);                                        \\\n-      }                                                                       \\\n-      if ((RB_LEFT(tmp, field) == NULL ||                                     \\\n-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \\\n-          (RB_RIGHT(tmp, field) == NULL ||                                    \\\n-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \\\n-        RB_COLOR(tmp, field) = RB_RED;                                        \\\n-        elm = parent;                                                         \\\n-        parent = RB_PARENT(elm, field);                                       \\\n-      } else {                                                                \\\n-        if (RB_RIGHT(tmp, field) == NULL ||                                   \\\n-            RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {              \\\n-          struct type *oleft;                                                 \\\n-          if ((oleft = RB_LEFT(tmp, field))                                   \\\n-              != NULL)                                                        \\\n-            RB_COLOR(oleft, field) = RB_BLACK;                                \\\n-          RB_COLOR(tmp, field) = RB_RED;                                      \\\n-          RB_ROTATE_RIGHT(head, tmp, oleft, field);                           \\\n-          tmp = RB_RIGHT(parent, field);                                      \\\n-        }                                                                     \\\n-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \\\n-        RB_COLOR(parent, field) = RB_BLACK;                                   \\\n-        if (RB_RIGHT(tmp, field))                                             \\\n-          RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;                   \\\n-        RB_ROTATE_LEFT(head, parent, tmp, field);                             \\\n-        elm = RB_ROOT(head);                                                  \\\n-        break;                                                                \\\n-      }                                                                       \\\n-    } else {                                                                  \\\n-      tmp = RB_LEFT(parent, field);                                           \\\n-      if (RB_COLOR(tmp, field) == RB_RED) {                                   \\\n-        RB_SET_BLACKRED(tmp, parent, field);                                  \\\n-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n-        tmp = RB_LEFT(parent, field);                                         \\\n-      }                                                                       \\\n-      if ((RB_LEFT(tmp, field) == NULL ||                                     \\\n-          RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&                \\\n-          (RB_RIGHT(tmp, field) == NULL ||                                    \\\n-          RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {               \\\n-        RB_COLOR(tmp, field) = RB_RED;                                        \\\n-        elm = parent;                                                         \\\n-        parent = RB_PARENT(elm, field);                                       \\\n-      } else {                                                                \\\n-        if (RB_LEFT(tmp, field) == NULL ||                                    \\\n-            RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {               \\\n-          struct type *oright;                                                \\\n-          if ((oright = RB_RIGHT(tmp, field))                                 \\\n-              != NULL)                                                        \\\n-            RB_COLOR(oright, field) = RB_BLACK;                               \\\n-          RB_COLOR(tmp, field) = RB_RED;                                      \\\n-          RB_ROTATE_LEFT(head, tmp, oright, field);                           \\\n-          tmp = RB_LEFT(parent, field);                                       \\\n-        }                                                                     \\\n-        RB_COLOR(tmp, field) = RB_COLOR(parent, field);                       \\\n-        RB_COLOR(parent, field) = RB_BLACK;                                   \\\n-        if (RB_LEFT(tmp, field))                                              \\\n-          RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;                    \\\n-        RB_ROTATE_RIGHT(head, parent, tmp, field);                            \\\n-        elm = RB_ROOT(head);                                                  \\\n-        break;                                                                \\\n-      }                                                                       \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  if (elm)                                                                    \\\n-    RB_COLOR(elm, field) = RB_BLACK;                                          \\\n-}                                                                             \\\n-                                                                              \\\n-attr struct type *                                                            \\\n-name##_RB_REMOVE(struct name *head, struct type *elm)                         \\\n-{                                                                             \\\n-  struct type *child, *parent, *old = elm;                                    \\\n-  int color;                                                                  \\\n-  if (RB_LEFT(elm, field) == NULL)                                            \\\n-    child = RB_RIGHT(elm, field);                                             \\\n-  else if (RB_RIGHT(elm, field) == NULL)                                      \\\n-    child = RB_LEFT(elm, field);                                              \\\n-  else {                                                                      \\\n-    struct type *left;                                                        \\\n-    elm = RB_RIGHT(elm, field);                                               \\\n-    while ((left = RB_LEFT(elm, field)) != NULL)                              \\\n-      elm = left;                                                             \\\n-    child = RB_RIGHT(elm, field);                                             \\\n-    parent = RB_PARENT(elm, field);                                           \\\n-    color = RB_COLOR(elm, field);                                             \\\n-    if (child)                                                                \\\n-      RB_PARENT(child, field) = parent;                                       \\\n-    if (parent) {                                                             \\\n-      if (RB_LEFT(parent, field) == elm)                                      \\\n-        RB_LEFT(parent, field) = child;                                       \\\n-      else                                                                    \\\n-        RB_RIGHT(parent, field) = child;                                      \\\n-      RB_AUGMENT(parent);                                                     \\\n-    } else                                                                    \\\n-      RB_ROOT(head) = child;                                                  \\\n-    if (RB_PARENT(elm, field) == old)                                         \\\n-      parent = elm;                                                           \\\n-    (elm)->field = (old)->field;                                              \\\n-    if (RB_PARENT(old, field)) {                                              \\\n-      if (RB_LEFT(RB_PARENT(old, field), field) == old)                       \\\n-        RB_LEFT(RB_PARENT(old, field), field) = elm;                          \\\n-      else                                                                    \\\n-        RB_RIGHT(RB_PARENT(old, field), field) = elm;                         \\\n-      RB_AUGMENT(RB_PARENT(old, field));                                      \\\n-    } else                                                                    \\\n-      RB_ROOT(head) = elm;                                                    \\\n-    RB_PARENT(RB_LEFT(old, field), field) = elm;                              \\\n-    if (RB_RIGHT(old, field))                                                 \\\n-      RB_PARENT(RB_RIGHT(old, field), field) = elm;                           \\\n-    if (parent) {                                                             \\\n-      left = parent;                                                          \\\n-      do {                                                                    \\\n-        RB_AUGMENT(left);                                                     \\\n-      } while ((left = RB_PARENT(left, field)) != NULL);                      \\\n-    }                                                                         \\\n-    goto color;                                                               \\\n-  }                                                                           \\\n-  parent = RB_PARENT(elm, field);                                             \\\n-  color = RB_COLOR(elm, field);                                               \\\n-  if (child)                                                                  \\\n-    RB_PARENT(child, field) = parent;                                         \\\n-  if (parent) {                                                               \\\n-    if (RB_LEFT(parent, field) == elm)                                        \\\n-      RB_LEFT(parent, field) = child;                                         \\\n-    else                                                                      \\\n-      RB_RIGHT(parent, field) = child;                                        \\\n-    RB_AUGMENT(parent);                                                       \\\n-  } else                                                                      \\\n-    RB_ROOT(head) = child;                                                    \\\n-color:                                                                        \\\n-  if (color == RB_BLACK)                                                      \\\n-    name##_RB_REMOVE_COLOR(head, parent, child);                              \\\n-  return (old);                                                               \\\n-}                                                                             \\\n-                                                                              \\\n-/* Inserts a node into the RB tree */                                         \\\n-attr struct type *                                                            \\\n-name##_RB_INSERT(struct name *head, struct type *elm)                         \\\n-{                                                                             \\\n-  struct type *tmp;                                                           \\\n-  struct type *parent = NULL;                                                 \\\n-  int comp = 0;                                                               \\\n-  tmp = RB_ROOT(head);                                                        \\\n-  while (tmp) {                                                               \\\n-    parent = tmp;                                                             \\\n-    comp = (cmp)(elm, parent);                                                \\\n-    if (comp < 0)                                                             \\\n-      tmp = RB_LEFT(tmp, field);                                              \\\n-    else if (comp > 0)                                                        \\\n-      tmp = RB_RIGHT(tmp, field);                                             \\\n-    else                                                                      \\\n-      return (tmp);                                                           \\\n-  }                                                                           \\\n-  RB_SET(elm, parent, field);                                                 \\\n-  if (parent != NULL) {                                                       \\\n-    if (comp < 0)                                                             \\\n-      RB_LEFT(parent, field) = elm;                                           \\\n-    else                                                                      \\\n-      RB_RIGHT(parent, field) = elm;                                          \\\n-    RB_AUGMENT(parent);                                                       \\\n-  } else                                                                      \\\n-    RB_ROOT(head) = elm;                                                      \\\n-  name##_RB_INSERT_COLOR(head, elm);                                          \\\n-  return (NULL);                                                              \\\n-}                                                                             \\\n-                                                                              \\\n-/* Finds the node with the same key as elm */                                 \\\n-attr struct type *                                                            \\\n-name##_RB_FIND(struct name *head, struct type *elm)                           \\\n-{                                                                             \\\n-  struct type *tmp = RB_ROOT(head);                                           \\\n-  int comp;                                                                   \\\n-  while (tmp) {                                                               \\\n-    comp = cmp(elm, tmp);                                                     \\\n-    if (comp < 0)                                                             \\\n-      tmp = RB_LEFT(tmp, field);                                              \\\n-    else if (comp > 0)                                                        \\\n-      tmp = RB_RIGHT(tmp, field);                                             \\\n-    else                                                                      \\\n-      return (tmp);                                                           \\\n-  }                                                                           \\\n-  return (NULL);                                                              \\\n-}                                                                             \\\n-                                                                              \\\n-/* Finds the first node greater than or equal to the search key */            \\\n-attr struct type *                                                            \\\n-name##_RB_NFIND(struct name *head, struct type *elm)                          \\\n-{                                                                             \\\n-  struct type *tmp = RB_ROOT(head);                                           \\\n-  struct type *res = NULL;                                                    \\\n-  int comp;                                                                   \\\n-  while (tmp) {                                                               \\\n-    comp = cmp(elm, tmp);                                                     \\\n-    if (comp < 0) {                                                           \\\n-      res = tmp;                                                              \\\n-      tmp = RB_LEFT(tmp, field);                                              \\\n-    }                                                                         \\\n-    else if (comp > 0)                                                        \\\n-      tmp = RB_RIGHT(tmp, field);                                             \\\n-    else                                                                      \\\n-      return (tmp);                                                           \\\n-  }                                                                           \\\n-  return (res);                                                               \\\n-}                                                                             \\\n-                                                                              \\\n-/* ARGSUSED */                                                                \\\n-attr struct type *                                                            \\\n-name##_RB_NEXT(struct type *elm)                                              \\\n-{                                                                             \\\n-  if (RB_RIGHT(elm, field)) {                                                 \\\n-    elm = RB_RIGHT(elm, field);                                               \\\n-    while (RB_LEFT(elm, field))                                               \\\n-      elm = RB_LEFT(elm, field);                                              \\\n-  } else {                                                                    \\\n-    if (RB_PARENT(elm, field) &&                                              \\\n-        (elm == RB_LEFT(RB_PARENT(elm, field), field)))                       \\\n-      elm = RB_PARENT(elm, field);                                            \\\n-    else {                                                                    \\\n-      while (RB_PARENT(elm, field) &&                                         \\\n-          (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                    \\\n-        elm = RB_PARENT(elm, field);                                          \\\n-      elm = RB_PARENT(elm, field);                                            \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  return (elm);                                                               \\\n-}                                                                             \\\n-                                                                              \\\n-/* ARGSUSED */                                                                \\\n-attr struct type *                                                            \\\n-name##_RB_PREV(struct type *elm)                                              \\\n-{                                                                             \\\n-  if (RB_LEFT(elm, field)) {                                                  \\\n-    elm = RB_LEFT(elm, field);                                                \\\n-    while (RB_RIGHT(elm, field))                                              \\\n-      elm = RB_RIGHT(elm, field);                                             \\\n-  } else {                                                                    \\\n-    if (RB_PARENT(elm, field) &&                                              \\\n-        (elm == RB_RIGHT(RB_PARENT(elm, field), field)))                      \\\n-      elm = RB_PARENT(elm, field);                                            \\\n-    else {                                                                    \\\n-      while (RB_PARENT(elm, field) &&                                         \\\n-          (elm == RB_LEFT(RB_PARENT(elm, field), field)))                     \\\n-        elm = RB_PARENT(elm, field);                                          \\\n-      elm = RB_PARENT(elm, field);                                            \\\n-    }                                                                         \\\n-  }                                                                           \\\n-  return (elm);                                                               \\\n-}                                                                             \\\n-                                                                              \\\n-attr struct type *                                                            \\\n-name##_RB_MINMAX(struct name *head, int val)                                  \\\n-{                                                                             \\\n-  struct type *tmp = RB_ROOT(head);                                           \\\n-  struct type *parent = NULL;                                                 \\\n-  while (tmp) {                                                               \\\n-    parent = tmp;                                                             \\\n-    if (val < 0)                                                              \\\n-      tmp = RB_LEFT(tmp, field);                                              \\\n-    else                                                                      \\\n-      tmp = RB_RIGHT(tmp, field);                                             \\\n-  }                                                                           \\\n-  return (parent);                                                            \\\n-}\n-\n-#define RB_NEGINF   -1\n-#define RB_INF      1\n-\n-#define RB_INSERT(name, x, y)   name##_RB_INSERT(x, y)\n-#define RB_REMOVE(name, x, y)   name##_RB_REMOVE(x, y)\n-#define RB_FIND(name, x, y)     name##_RB_FIND(x, y)\n-#define RB_NFIND(name, x, y)    name##_RB_NFIND(x, y)\n-#define RB_NEXT(name, x, y)     name##_RB_NEXT(y)\n-#define RB_PREV(name, x, y)     name##_RB_PREV(y)\n-#define RB_MIN(name, x)         name##_RB_MINMAX(x, RB_NEGINF)\n-#define RB_MAX(name, x)         name##_RB_MINMAX(x, RB_INF)\n-\n-#define RB_FOREACH(x, name, head)                                             \\\n-  for ((x) = RB_MIN(name, head);                                              \\\n-       (x) != NULL;                                                           \\\n-       (x) = name##_RB_NEXT(x))\n-\n-#define RB_FOREACH_FROM(x, name, y)                                           \\\n-  for ((x) = (y);                                                             \\\n-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \\\n-       (x) = (y))\n-\n-#define RB_FOREACH_SAFE(x, name, head, y)                                     \\\n-  for ((x) = RB_MIN(name, head);                                              \\\n-      ((x) != NULL) && ((y) = name##_RB_NEXT(x), (x) != NULL);                \\\n-       (x) = (y))\n-\n-#define RB_FOREACH_REVERSE(x, name, head)                                     \\\n-  for ((x) = RB_MAX(name, head);                                              \\\n-       (x) != NULL;                                                           \\\n-       (x) = name##_RB_PREV(x))\n-\n-#define RB_FOREACH_REVERSE_FROM(x, name, y)                                   \\\n-  for ((x) = (y);                                                             \\\n-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \\\n-       (x) = (y))\n-\n-#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)                             \\\n-  for ((x) = RB_MAX(name, head);                                              \\\n-      ((x) != NULL) && ((y) = name##_RB_PREV(x), (x) != NULL);                \\\n-       (x) = (y))\n-\n-#endif  /* _UV_TREE_H_ */"}, {"sha": "b07781f4068b123e19dbade66098882409a5dd15", "filename": "src/rt/libuv/include/uv-private/uv-unix.h", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-unix.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,219 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#ifndef UV_UNIX_H\n-#define UV_UNIX_H\n-\n-#include \"ngx-queue.h\"\n-\n-#include \"ev.h\"\n-#include \"eio.h\"\n-\n-#include <sys/types.h>\n-#include <sys/socket.h>\n-#include <netinet/in.h>\n-#include <netinet/tcp.h>\n-#include <arpa/inet.h>\n-#include <netdb.h>\n-#include <termios.h>\n-\n-/* Note: May be cast to struct iovec. See writev(2). */\n-typedef struct {\n-  char* base;\n-  size_t len;\n-} uv_buf_t;\n-\n-typedef int uv_file;\n-\n-/* Platform-specific definitions for uv_dlopen support. */\n-typedef void* uv_lib_t;\n-#define UV_DYNAMIC /* empty */\n-\n-#define UV_LOOP_PRIVATE_FIELDS \\\n-  ares_channel channel; \\\n-  /* \\\n-   * While the channel is active this timer is called once per second to be \\\n-   * sure that we're always calling ares_process. See the warning above the \\\n-   * definition of ares_timeout(). \\\n-   */ \\\n-  ev_timer timer; \\\n-  struct ev_loop* ev;\n-\n-#define UV_REQ_BUFSML_SIZE (4)\n-\n-#define UV_REQ_PRIVATE_FIELDS  /* empty */\n-\n-#define UV_WRITE_PRIVATE_FIELDS \\\n-  ngx_queue_t queue; \\\n-  int write_index; \\\n-  uv_buf_t* bufs; \\\n-  int bufcnt; \\\n-  int error; \\\n-  uv_buf_t bufsml[UV_REQ_BUFSML_SIZE];\n-\n-#define UV_SHUTDOWN_PRIVATE_FIELDS /* empty */\n-\n-#define UV_CONNECT_PRIVATE_FIELDS \\\n-  ngx_queue_t queue;\n-\n-#define UV_UDP_SEND_PRIVATE_FIELDS  \\\n-  ngx_queue_t queue;                \\\n-  struct sockaddr_storage addr;     \\\n-  socklen_t addrlen;                \\\n-  uv_buf_t* bufs;                   \\\n-  int bufcnt;                       \\\n-  ssize_t status;                   \\\n-  uv_udp_send_cb send_cb;           \\\n-  uv_buf_t bufsml[UV_REQ_BUFSML_SIZE];  \\\n-\n-#define UV_PRIVATE_REQ_TYPES /* empty */\n-\n-\n-/* TODO: union or classes please! */\n-#define UV_HANDLE_PRIVATE_FIELDS \\\n-  int fd; \\\n-  int flags; \\\n-  ev_idle next_watcher;\n-\n-\n-#define UV_STREAM_PRIVATE_FIELDS \\\n-  uv_connect_t *connect_req; \\\n-  uv_shutdown_t *shutdown_req; \\\n-  ev_io read_watcher; \\\n-  ev_io write_watcher; \\\n-  ngx_queue_t write_queue; \\\n-  ngx_queue_t write_completed_queue; \\\n-  int delayed_error; \\\n-  uv_connection_cb connection_cb; \\\n-  int accepted_fd; \\\n-  int blocking;\n-\n-\n-/* UV_TCP */\n-#define UV_TCP_PRIVATE_FIELDS\n-\n-\n-/* UV_UDP */\n-#define UV_UDP_PRIVATE_FIELDS         \\\n-  uv_alloc_cb alloc_cb;               \\\n-  uv_udp_recv_cb recv_cb;             \\\n-  ev_io read_watcher;                 \\\n-  ev_io write_watcher;                \\\n-  ngx_queue_t write_queue;            \\\n-  ngx_queue_t write_completed_queue;  \\\n-\n-\n-/* UV_NAMED_PIPE */\n-#define UV_PIPE_PRIVATE_FIELDS \\\n-  const char* pipe_fname; /* strdup'ed */\n-\n-\n-/* UV_PREPARE */ \\\n-#define UV_PREPARE_PRIVATE_FIELDS \\\n-  ev_prepare prepare_watcher; \\\n-  uv_prepare_cb prepare_cb;\n-\n-\n-/* UV_CHECK */\n-#define UV_CHECK_PRIVATE_FIELDS \\\n-  ev_check check_watcher; \\\n-  uv_check_cb check_cb;\n-\n-\n-/* UV_IDLE */\n-#define UV_IDLE_PRIVATE_FIELDS \\\n-  ev_idle idle_watcher; \\\n-  uv_idle_cb idle_cb;\n-\n-\n-/* UV_ASYNC */\n-#define UV_ASYNC_PRIVATE_FIELDS \\\n-  ev_async async_watcher; \\\n-  uv_async_cb async_cb;\n-\n-\n-/* UV_TIMER */\n-#define UV_TIMER_PRIVATE_FIELDS \\\n-  ev_timer timer_watcher; \\\n-  uv_timer_cb timer_cb;\n-\n-#define UV_ARES_TASK_PRIVATE_FIELDS \\\n-  int sock; \\\n-  ev_io read_watcher; \\\n-  ev_io write_watcher;\n-\n-#define UV_GETADDRINFO_PRIVATE_FIELDS \\\n-  uv_getaddrinfo_cb cb; \\\n-  struct addrinfo* hints; \\\n-  char* hostname; \\\n-  char* service; \\\n-  struct addrinfo* res; \\\n-  int retcode;\n-\n-#define UV_PROCESS_PRIVATE_FIELDS \\\n-  ev_child child_watcher;\n-\n-#define UV_FS_PRIVATE_FIELDS \\\n-  struct stat statbuf; \\\n-  eio_req* eio;\n-\n-#define UV_WORK_PRIVATE_FIELDS \\\n-  eio_req* eio;\n-\n-#define UV_TTY_PRIVATE_FIELDS \\\n-  struct termios orig_termios; \\\n-  int mode;\n-\n-/* UV_FS_EVENT_PRIVATE_FIELDS */\n-#if defined(__linux__)\n-\n-#define UV_FS_EVENT_PRIVATE_FIELDS \\\n-  ev_io read_watcher; \\\n-  uv_fs_event_cb cb; \\\n-\n-#elif (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED >= 1060) \\\n-  || defined(__FreeBSD__) \\\n-  || defined(__OpenBSD__) \\\n-  || defined(__NetBSD__)\n-\n-#define UV_FS_EVENT_PRIVATE_FIELDS \\\n-  ev_io event_watcher; \\\n-  uv_fs_event_cb cb; \\\n-  int fflags; \\\n-\n-#elif defined(__sun)\n-\n-#include <sys/port.h>\n-#include <port.h>\n-\n-#define UV_FS_EVENT_PRIVATE_FIELDS \\\n-  ev_io event_watcher; \\\n-  uv_fs_event_cb cb; \\\n-  file_obj_t fo; \\\n-\n-#else\n-\n-/* Stub for platforms where the file watcher isn't implemented yet. */\n-#define UV_FS_EVENT_PRIVATE_FIELDS\n-\n-#endif\n-\n-#endif /* UV_UNIX_H */"}, {"sha": "5d461090f159dc6ffdb85a7401c74b98de3f14b7", "filename": "src/rt/libuv/include/uv-private/uv-win.h", "status": "removed", "additions": 0, "deletions": 422, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv-private%2Fuv-win.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,422 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-#ifndef _WIN32_WINNT\n-# define _WIN32_WINNT   0x0502\n-#endif\n-\n-#include <stdint.h>\n-#include <winsock2.h>\n-#include <mswsock.h>\n-#include <ws2tcpip.h>\n-#include <windows.h>\n-#include <sys/stat.h>\n-\n-#include \"tree.h\"\n-\n-#define MAX_PIPENAME_LEN 256\n-\n-/*\n- * Guids and typedefs for winsock extension functions\n- * Mingw32 doesn't have these :-(\n- */\n-#ifndef WSAID_ACCEPTEX\n-# define WSAID_ACCEPTEX                                        \\\n-         {0xb5367df1, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-# define WSAID_CONNECTEX                                       \\\n-         {0x25a207b9, 0xddf3, 0x4660,                          \\\n-         {0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e}}\n-\n-# define WSAID_GETACCEPTEXSOCKADDRS                            \\\n-         {0xb5367df2, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-# define WSAID_DISCONNECTEX                                    \\\n-         {0x7fda2e11, 0x8630, 0x436f,                          \\\n-         {0xa0, 0x31, 0xf5, 0x36, 0xa6, 0xee, 0xc1, 0x57}}\n-\n-# define WSAID_TRANSMITFILE                                    \\\n-         {0xb5367df0, 0xcbac, 0x11cf,                          \\\n-         {0x95, 0xca, 0x00, 0x80, 0x5f, 0x48, 0xa1, 0x92}}\n-\n-  typedef BOOL PASCAL (*LPFN_ACCEPTEX)\n-                      (SOCKET sListenSocket,\n-                       SOCKET sAcceptSocket,\n-                       PVOID lpOutputBuffer,\n-                       DWORD dwReceiveDataLength,\n-                       DWORD dwLocalAddressLength,\n-                       DWORD dwRemoteAddressLength,\n-                       LPDWORD lpdwBytesReceived,\n-                       LPOVERLAPPED lpOverlapped);\n-\n-  typedef BOOL PASCAL (*LPFN_CONNECTEX)\n-                      (SOCKET s,\n-                       const struct sockaddr* name,\n-                       int namelen,\n-                       PVOID lpSendBuffer,\n-                       DWORD dwSendDataLength,\n-                       LPDWORD lpdwBytesSent,\n-                       LPOVERLAPPED lpOverlapped);\n-\n-  typedef void PASCAL (*LPFN_GETACCEPTEXSOCKADDRS)\n-                      (PVOID lpOutputBuffer,\n-                       DWORD dwReceiveDataLength,\n-                       DWORD dwLocalAddressLength,\n-                       DWORD dwRemoteAddressLength,\n-                       LPSOCKADDR* LocalSockaddr,\n-                       LPINT LocalSockaddrLength,\n-                       LPSOCKADDR* RemoteSockaddr,\n-                       LPINT RemoteSockaddrLength);\n-\n-  typedef BOOL PASCAL (*LPFN_DISCONNECTEX)\n-                      (SOCKET hSocket,\n-                       LPOVERLAPPED lpOverlapped,\n-                       DWORD dwFlags,\n-                       DWORD reserved);\n-\n-  typedef BOOL PASCAL (*LPFN_TRANSMITFILE)\n-                      (SOCKET hSocket,\n-                       HANDLE hFile,\n-                       DWORD nNumberOfBytesToWrite,\n-                       DWORD nNumberOfBytesPerSend,\n-                       LPOVERLAPPED lpOverlapped,\n-                       LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,\n-                       DWORD dwFlags);\n-#endif\n-\n-typedef int (WSAAPI* LPFN_WSARECV)\n-            (SOCKET socket,\n-             LPWSABUF buffers,\n-             DWORD buffer_count,\n-             LPDWORD bytes,\n-             LPDWORD flags,\n-             LPWSAOVERLAPPED overlapped,\n-             LPWSAOVERLAPPED_COMPLETION_ROUTINE\n-             completion_routine);\n-\n-typedef int (WSAAPI* LPFN_WSARECVFROM)\n-            (SOCKET socket,\n-             LPWSABUF buffers,\n-             DWORD buffer_count,\n-             LPDWORD bytes,\n-             LPDWORD flags,\n-             struct sockaddr* addr,\n-             LPINT addr_len,\n-             LPWSAOVERLAPPED overlapped,\n-             LPWSAOVERLAPPED_COMPLETION_ROUTINE completion_routine);\n-\n-\n-/**\n- * It should be possible to cast uv_buf_t[] to WSABUF[]\n- * see http://msdn.microsoft.com/en-us/library/ms741542(v=vs.85).aspx\n- */\n-typedef struct uv_buf_t {\n-  ULONG len;\n-  char* base;\n-} uv_buf_t;\n-\n-typedef int uv_file;\n-\n-/* Platform-specific definitions for uv_dlopen support. */\n-typedef HMODULE uv_lib_t;\n-#define UV_DYNAMIC FAR WINAPI\n-\n-RB_HEAD(uv_timer_tree_s, uv_timer_s);\n-\n-#define UV_LOOP_PRIVATE_FIELDS                                                \\\n-    /* The loop's I/O completion port */                                      \\\n-  HANDLE iocp;                                                                \\\n-  /* Reference count that keeps the event loop alive */                       \\\n-  int refs;                                                                   \\\n-  /* The current time according to the event loop. in msecs. */               \\\n-  int64_t time;                                                               \\\n-  /* Tail of a single-linked circular queue of pending reqs. If the queue */  \\\n-  /* is empty, tail_ is NULL. If there is only one item, */                   \\\n-  /* tail_->next_req == tail_ */                                              \\\n-  uv_req_t* pending_reqs_tail;                                                \\\n-  /* Head of a single-linked list of closed handles */                        \\\n-  uv_handle_t* endgame_handles;                                               \\\n-  /* The head of the timers tree */                                           \\\n-  struct uv_timer_tree_s timers;                                              \\\n-    /* Lists of active loop (prepare / check / idle) watchers */              \\\n-  uv_prepare_t* prepare_handles;                                              \\\n-  uv_check_t* check_handles;                                                  \\\n-  uv_idle_t* idle_handles;                                                    \\\n-  /* This pointer will refer to the prepare/check/idle handle whose */        \\\n-  /* callback is scheduled to be called next. This is needed to allow */      \\\n-  /* safe removal from one of the lists above while that list being */        \\\n-  /* iterated over. */                                                        \\\n-  uv_prepare_t* next_prepare_handle;                                          \\\n-  uv_check_t* next_check_handle;                                              \\\n-  uv_idle_t* next_idle_handle;                                                \\\n-  ares_channel ares_chan;                                                     \\\n-  int ares_active_sockets;                                                    \\\n-  uv_timer_t ares_polling_timer;\n-\n-#define UV_REQ_TYPE_PRIVATE               \\\n-  /* TODO: remove the req suffix */       \\\n-  UV_ARES_EVENT_REQ,                      \\\n-  UV_ARES_CLEANUP_REQ,                    \\\n-  UV_GETADDRINFO_REQ,                     \\\n-  UV_PROCESS_EXIT,                        \\\n-  UV_PROCESS_CLOSE,                       \\\n-  UV_UDP_RECV,                            \\\n-  UV_FS_EVENT_REQ\n-\n-#define UV_REQ_PRIVATE_FIELDS             \\\n-  union {                                 \\\n-    /* Used by I/O operations */          \\\n-    struct {                              \\\n-      OVERLAPPED overlapped;              \\\n-      size_t queued_bytes;                \\\n-    };                                    \\\n-  };                                      \\\n-  struct uv_req_s* next_req;\n-\n-#define UV_WRITE_PRIVATE_FIELDS           \\\n-  int ipc_header;                         \\\n-  uv_buf_t write_buffer;                  \\\n-  HANDLE event_handle;                    \\\n-  HANDLE wait_handle;\n-\n-#define UV_CONNECT_PRIVATE_FIELDS         \\\n-  /* empty */\n-\n-#define UV_SHUTDOWN_PRIVATE_FIELDS        \\\n-  /* empty */\n-\n-#define UV_UDP_SEND_PRIVATE_FIELDS        \\\n-  /* empty */\n-\n-#define UV_PRIVATE_REQ_TYPES              \\\n-  typedef struct uv_pipe_accept_s {       \\\n-    UV_REQ_FIELDS                         \\\n-    HANDLE pipeHandle;                    \\\n-    struct uv_pipe_accept_s* next_pending; \\\n-  } uv_pipe_accept_t;                     \\\n-                                          \\\n-  typedef struct uv_tcp_accept_s {        \\\n-    UV_REQ_FIELDS                         \\\n-    SOCKET accept_socket;                 \\\n-    char accept_buffer[sizeof(struct sockaddr_storage) * 2 + 32]; \\\n-    HANDLE event_handle;                  \\\n-    HANDLE wait_handle;                   \\\n-    struct uv_tcp_accept_s* next_pending; \\\n-  } uv_tcp_accept_t;                      \\\n-                                          \\\n-  typedef struct uv_read_s {              \\\n-    UV_REQ_FIELDS                         \\\n-    HANDLE event_handle;                  \\\n-    HANDLE wait_handle;                   \\\n-  } uv_read_t;\n-\n-#define uv_stream_connection_fields       \\\n-  unsigned int write_reqs_pending;        \\\n-  uv_shutdown_t* shutdown_req;\n-\n-#define uv_stream_server_fields           \\\n-  uv_connection_cb connection_cb;\n-\n-#define UV_STREAM_PRIVATE_FIELDS          \\\n-  unsigned int reqs_pending;              \\\n-  uv_read_t read_req;                     \\\n-  union {                                 \\\n-    struct { uv_stream_connection_fields };  \\\n-    struct { uv_stream_server_fields     };  \\\n-  };\n-\n-#define uv_tcp_server_fields              \\\n-  uv_tcp_accept_t* accept_reqs;           \\\n-  unsigned int processed_accepts;         \\\n-  uv_tcp_accept_t* pending_accepts;       \\\n-  LPFN_ACCEPTEX func_acceptex;\n-\n-#define uv_tcp_connection_fields          \\\n-  uv_buf_t read_buffer;                   \\\n-  LPFN_CONNECTEX func_connectex;\n-\n-#define UV_TCP_PRIVATE_FIELDS             \\\n-  SOCKET socket;                          \\\n-  int bind_error;                         \\\n-  union {                                 \\\n-    struct { uv_tcp_server_fields };      \\\n-    struct { uv_tcp_connection_fields };  \\\n-  };\n-\n-#define UV_UDP_PRIVATE_FIELDS             \\\n-  SOCKET socket;                          \\\n-  unsigned int reqs_pending;              \\\n-  uv_req_t recv_req;                      \\\n-  uv_buf_t recv_buffer;                   \\\n-  struct sockaddr_storage recv_from;      \\\n-  int recv_from_len;                      \\\n-  uv_udp_recv_cb recv_cb;                 \\\n-  uv_alloc_cb alloc_cb;                   \\\n-  LPFN_WSARECV func_wsarecv;              \\\n-  LPFN_WSARECVFROM func_wsarecvfrom;\n-\n-#define uv_pipe_server_fields             \\\n-  uv_pipe_accept_t accept_reqs[4];        \\\n-  uv_pipe_accept_t* pending_accepts;\n-\n-#define uv_pipe_connection_fields         \\\n-  uv_timer_t* eof_timer;                  \\\n-  uv_write_t ipc_header_write_req;        \\\n-  int ipc_pid;                            \\\n-  uint64_t remaining_ipc_rawdata_bytes;   \\\n-  WSAPROTOCOL_INFOW* pending_socket_info; \\\n-  uv_write_t* non_overlapped_writes_tail;\n-\n-#define UV_PIPE_PRIVATE_FIELDS            \\\n-  HANDLE handle;                          \\\n-  wchar_t* name;                          \\\n-  union {                                 \\\n-    struct { uv_pipe_server_fields };     \\\n-    struct { uv_pipe_connection_fields }; \\\n-  };\n-\n-/* TODO: put the parser states in an union - TTY handles are always */\n-/* half-duplex so read-state can safely overlap write-state. */\n-#define UV_TTY_PRIVATE_FIELDS             \\\n-  HANDLE handle;                          \\\n-  HANDLE read_line_handle;                \\\n-  uv_buf_t read_line_buffer;              \\\n-  HANDLE read_raw_wait;                   \\\n-  DWORD original_console_mode;            \\\n-  /* Fields used for translating win */   \\\n-  /* keystrokes into vt100 characters */  \\\n-  char last_key[8];                       \\\n-  unsigned char last_key_offset;          \\\n-  unsigned char last_key_len;             \\\n-  INPUT_RECORD last_input_record;         \\\n-  WCHAR last_utf16_high_surrogate;        \\\n-  /* utf8-to-utf16 conversion state */    \\\n-  unsigned char utf8_bytes_left;          \\\n-  unsigned int utf8_codepoint;            \\\n-  /* eol conversion state */              \\\n-  unsigned char previous_eol;             \\\n-  /* ansi parser state */                 \\\n-  unsigned char ansi_parser_state;        \\\n-  unsigned char ansi_csi_argc;            \\\n-  unsigned short ansi_csi_argv[4];        \\\n-  COORD saved_position;                   \\\n-  WORD saved_attributes;\n-\n-#define UV_TIMER_PRIVATE_FIELDS           \\\n-  RB_ENTRY(uv_timer_s) tree_entry;        \\\n-  int64_t due;                            \\\n-  int64_t repeat;                         \\\n-  uv_timer_cb timer_cb;\n-\n-#define UV_ASYNC_PRIVATE_FIELDS           \\\n-  struct uv_req_s async_req;              \\\n-  uv_async_cb async_cb;                   \\\n-  /* char to avoid alignment issues */    \\\n-  char volatile async_sent;\n-\n-#define UV_PREPARE_PRIVATE_FIELDS         \\\n-  uv_prepare_t* prepare_prev;             \\\n-  uv_prepare_t* prepare_next;             \\\n-  uv_prepare_cb prepare_cb;\n-\n-#define UV_CHECK_PRIVATE_FIELDS           \\\n-  uv_check_t* check_prev;                 \\\n-  uv_check_t* check_next;                 \\\n-  uv_check_cb check_cb;\n-\n-#define UV_IDLE_PRIVATE_FIELDS            \\\n-  uv_idle_t* idle_prev;                   \\\n-  uv_idle_t* idle_next;                   \\\n-  uv_idle_cb idle_cb;\n-\n-#define UV_HANDLE_PRIVATE_FIELDS          \\\n-  uv_handle_t* endgame_next;              \\\n-  unsigned int flags;\n-\n-#define UV_ARES_TASK_PRIVATE_FIELDS       \\\n-  struct uv_req_s ares_req;               \\\n-  SOCKET sock;                            \\\n-  HANDLE h_wait;                          \\\n-  WSAEVENT h_event;                       \\\n-  HANDLE h_close_event;\n-\n-#define UV_GETADDRINFO_PRIVATE_FIELDS     \\\n-  struct uv_req_s getadddrinfo_req;       \\\n-  uv_getaddrinfo_cb getaddrinfo_cb;       \\\n-  void* alloc;                            \\\n-  wchar_t* node;                          \\\n-  wchar_t* service;                       \\\n-  struct addrinfoW* hints;                \\\n-  struct addrinfoW* res;                  \\\n-  int retcode;\n-\n-#define UV_PROCESS_PRIVATE_FIELDS         \\\n-  struct uv_process_exit_s {              \\\n-    UV_REQ_FIELDS                         \\\n-  } exit_req;                             \\\n-  struct uv_process_close_s {             \\\n-    UV_REQ_FIELDS                         \\\n-  } close_req;                            \\\n-  HANDLE child_stdio[3];                  \\\n-  int exit_signal;                        \\\n-  DWORD spawn_errno;                      \\\n-  HANDLE wait_handle;                     \\\n-  HANDLE process_handle;                  \\\n-  HANDLE close_handle;\n-\n-#define UV_FS_PRIVATE_FIELDS              \\\n-  wchar_t* pathw;                         \\\n-  int flags;                              \\\n-  int last_error;                         \\\n-  struct _stati64 stat;                   \\\n-  void* arg0;                             \\\n-  union {                                 \\\n-    struct {                              \\\n-      void* arg1;                         \\\n-      void* arg2;                         \\\n-      void* arg3;                         \\\n-    };                                    \\\n-    struct {                              \\\n-      ssize_t arg4;                       \\\n-      ssize_t arg5;                       \\\n-    };                                    \\\n-  };\n-\n-#define UV_WORK_PRIVATE_FIELDS            \\\n-\n-#define UV_FS_EVENT_PRIVATE_FIELDS        \\\n-  struct uv_fs_event_req_s {              \\\n-    UV_REQ_FIELDS                         \\\n-  } req;                                  \\\n-  HANDLE dir_handle;                      \\\n-  int req_pending;                        \\\n-  uv_fs_event_cb cb;                      \\\n-  wchar_t* filew;                         \\\n-  wchar_t* short_filew;                   \\\n-  int is_path_dir;                        \\\n-  char* buffer;\n-\n-int uv_utf16_to_utf8(const wchar_t* utf16Buffer, size_t utf16Size,\n-    char* utf8Buffer, size_t utf8Size);\n-int uv_utf8_to_utf16(const char* utf8Buffer, wchar_t* utf16Buffer,\n-    size_t utf16Size);"}, {"sha": "88afed448d9a4ab41e7c147ce3a6e174e451396c", "filename": "src/rt/libuv/include/uv.h", "status": "removed", "additions": 0, "deletions": 1317, "changes": 1317, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Finclude%2Fuv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Finclude%2Fuv.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,1317 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-\n-/* See uv_loop_new for an introduction. */\n-\n-#ifndef UV_H\n-#define UV_H\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#ifdef _WIN32\n-  /* Windows - set up dll import/export decorators. */\n-# if defined(BUILDING_UV_SHARED)\n-    /* Building shared library. Export everything from c-ares as well. */\n-#   define UV_EXTERN __declspec(dllexport)\n-#   define CARES_BUILDING_LIBRARY 1\n-# elif defined(USING_UV_SHARED)\n-    /* Using shared library. Use shared c-ares as well. */\n-#   define UV_EXTERN __declspec(dllimport)\n-# else\n-    /* Building static library. Build c-ares statically as well. */\n-#   define UV_EXTERN /* nothing */\n-#   define CARES_STATICLIB 1\n-# endif\n-#else\n-  /* Unix. TODO: symbol hiding */\n-# define UV_EXTERN /* nothing */\n-#endif\n-\n-\n-#define UV_VERSION_MAJOR 0\n-#define UV_VERSION_MINOR 1\n-\n-\n-#include <stdint.h> /* int64_t */\n-#include <sys/types.h> /* size_t */\n-\n-#include \"ares.h\"\n-\n-#ifndef _SSIZE_T_\n-typedef intptr_t ssize_t;\n-#endif\n-\n-#if defined(__unix__) || defined(__POSIX__) || defined(__APPLE__)\n-# include \"uv-private/uv-unix.h\"\n-#else\n-# include \"uv-private/uv-win.h\"\n-#endif\n-\n-/* Expand this list if necessary. */\n-typedef enum {\n-  UV_UNKNOWN = -1,\n-  UV_OK = 0,\n-  UV_EOF,\n-  UV_EADDRINFO,\n-  UV_EACCES,\n-  UV_EAGAIN,\n-  UV_EADDRINUSE,\n-  UV_EADDRNOTAVAIL,\n-  UV_EAFNOSUPPORT,\n-  UV_EALREADY,\n-  UV_EBADF,\n-  UV_EBUSY,\n-  UV_ECONNABORTED,\n-  UV_ECONNREFUSED,\n-  UV_ECONNRESET,\n-  UV_EDESTADDRREQ,\n-  UV_EFAULT,\n-  UV_EHOSTUNREACH,\n-  UV_EINTR,\n-  UV_EINVAL,\n-  UV_EISCONN,\n-  UV_EMFILE,\n-  UV_EMSGSIZE,\n-  UV_ENETDOWN,\n-  UV_ENETUNREACH,\n-  UV_ENFILE,\n-  UV_ENOBUFS,\n-  UV_ENOMEM,\n-  UV_ENOTDIR,\n-  UV_EISDIR,\n-  UV_ENONET,\n-  UV_ENOPROTOOPT,\n-  UV_ENOTCONN,\n-  UV_ENOTSOCK,\n-  UV_ENOTSUP,\n-  UV_ENOENT,\n-  UV_ENOSYS,\n-  UV_EPIPE,\n-  UV_EPROTO,\n-  UV_EPROTONOSUPPORT,\n-  UV_EPROTOTYPE,\n-  UV_ETIMEDOUT,\n-  UV_ECHARSET,\n-  UV_EAIFAMNOSUPPORT,\n-  UV_EAINONAME,\n-  UV_EAISERVICE,\n-  UV_EAISOCKTYPE,\n-  UV_ESHUTDOWN,\n-  UV_EEXIST\n-} uv_err_code;\n-\n-typedef enum {\n-  UV_UNKNOWN_HANDLE = 0,\n-  UV_TCP,\n-  UV_UDP,\n-  UV_NAMED_PIPE,\n-  UV_TTY,\n-  UV_FILE,\n-  UV_TIMER,\n-  UV_PREPARE,\n-  UV_CHECK,\n-  UV_IDLE,\n-  UV_ASYNC,\n-  UV_ARES_TASK,\n-  UV_ARES_EVENT,\n-  UV_PROCESS,\n-  UV_FS_EVENT\n-} uv_handle_type;\n-\n-typedef enum {\n-  UV_UNKNOWN_REQ = 0,\n-  UV_CONNECT,\n-  UV_ACCEPT,\n-  UV_READ,\n-  UV_WRITE,\n-  UV_SHUTDOWN,\n-  UV_WAKEUP,\n-  UV_UDP_SEND,\n-  UV_FS,\n-  UV_WORK,\n-  UV_GETADDRINFO,\n-  UV_REQ_TYPE_PRIVATE\n-} uv_req_type;\n-\n-\n-\n-typedef struct uv_loop_s uv_loop_t;\n-typedef struct uv_ares_task_s uv_ares_task_t;\n-typedef struct uv_err_s uv_err_t;\n-typedef struct uv_handle_s uv_handle_t;\n-typedef struct uv_stream_s uv_stream_t;\n-typedef struct uv_tcp_s uv_tcp_t;\n-typedef struct uv_udp_s uv_udp_t;\n-typedef struct uv_pipe_s uv_pipe_t;\n-typedef struct uv_tty_s uv_tty_t;\n-typedef struct uv_timer_s uv_timer_t;\n-typedef struct uv_prepare_s uv_prepare_t;\n-typedef struct uv_check_s uv_check_t;\n-typedef struct uv_idle_s uv_idle_t;\n-typedef struct uv_async_s uv_async_t;\n-typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\n-typedef struct uv_process_s uv_process_t;\n-typedef struct uv_counters_s uv_counters_t;\n-/* Request types */\n-typedef struct uv_req_s uv_req_t;\n-typedef struct uv_shutdown_s uv_shutdown_t;\n-typedef struct uv_write_s uv_write_t;\n-typedef struct uv_connect_s uv_connect_t;\n-typedef struct uv_udp_send_s uv_udp_send_t;\n-typedef struct uv_fs_s uv_fs_t;\n-/* uv_fs_event_t is a subclass of uv_handle_t. */\n-typedef struct uv_fs_event_s uv_fs_event_t;\n-typedef struct uv_work_s uv_work_t;\n-\n-\n-/*\n- * This function must be called before any other functions in libuv.\n- *\n- * All functions besides uv_run() are non-blocking.\n- *\n- * All callbacks in libuv are made asynchronously. That is they are never\n- * made by the function that takes them as a parameter.\n- */\n-UV_EXTERN uv_loop_t* uv_loop_new(void);\n-UV_EXTERN void uv_loop_delete(uv_loop_t*);\n-\n-\n-/*\n- * Returns the default loop.\n- */\n-UV_EXTERN uv_loop_t* uv_default_loop(void);\n-\n-/*\n- * This function starts the event loop. It blocks until the reference count\n- * of the loop drops to zero.\n- */\n-UV_EXTERN int uv_run (uv_loop_t*);\n-\n-/*\n- * Manually modify the event loop's reference count. Useful if the user wants\n- * to have a handle or timeout that doesn't keep the loop alive.\n- */\n-UV_EXTERN void uv_ref(uv_loop_t*);\n-UV_EXTERN void uv_unref(uv_loop_t*);\n-\n-UV_EXTERN void uv_update_time(uv_loop_t*);\n-UV_EXTERN int64_t uv_now(uv_loop_t*);\n-\n-\n-/*\n- * The status parameter is 0 if the request completed successfully,\n- * and should be -1 if the request was cancelled or failed.\n- * For uv_close_cb, -1 means that the handle was closed due to an error.\n- * Error details can be obtained by calling uv_last_error().\n- *\n- * In the case of uv_read_cb the uv_buf_t returned should be freed by the\n- * user.\n- */\n-typedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);\n-typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n-/*\n- * Just like the uv_read_cb except that if the pending parameter is true\n- * then you can use uv_accept() to pull the new handle into the process.\n- * If no handle is pending then pending will be UV_UNKNOWN_HANDLE.\n- */\n-typedef void (*uv_read2_cb)(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,\n-    uv_handle_type pending);\n-typedef void (*uv_write_cb)(uv_write_t* req, int status);\n-typedef void (*uv_connect_cb)(uv_connect_t* req, int status);\n-typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\n-typedef void (*uv_connection_cb)(uv_stream_t* server, int status);\n-typedef void (*uv_close_cb)(uv_handle_t* handle);\n-typedef void (*uv_timer_cb)(uv_timer_t* handle, int status);\n-/* TODO: do these really need a status argument? */\n-typedef void (*uv_async_cb)(uv_async_t* handle, int status);\n-typedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);\n-typedef void (*uv_check_cb)(uv_check_t* handle, int status);\n-typedef void (*uv_idle_cb)(uv_idle_t* handle, int status);\n-typedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* handle, int status,\n-    struct addrinfo* res);\n-typedef void (*uv_exit_cb)(uv_process_t*, int exit_status, int term_signal);\n-typedef void (*uv_fs_cb)(uv_fs_t* req);\n-typedef void (*uv_work_cb)(uv_work_t* req);\n-typedef void (*uv_after_work_cb)(uv_work_t* req);\n-\n-/*\n-* This will be called repeatedly after the uv_fs_event_t is initialized.\n-* If uv_fs_event_t was initialized with a directory the filename parameter\n-* will be a relative path to a file contained in the directory.\n-* The events paramenter is an ORed mask of enum uv_fs_event elements.\n-*/\n-typedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,\n-    int events, int status);\n-\n-typedef enum {\n-  UV_LEAVE_GROUP = 0,\n-  UV_JOIN_GROUP\n-} uv_membership;\n-\n-\n-struct uv_err_s {\n-  /* read-only */\n-  uv_err_code code;\n-  /* private */\n-  int sys_errno_;\n-};\n-\n-\n-/*\n- * Most functions return boolean: 0 for success and -1 for failure.\n- * On error the user should then call uv_last_error() to determine\n- * the error code.\n- */\n-UV_EXTERN uv_err_t uv_last_error(uv_loop_t*);\n-UV_EXTERN const char* uv_strerror(uv_err_t err);\n-UV_EXTERN const char* uv_err_name(uv_err_t err);\n-\n-\n-#define UV_REQ_FIELDS \\\n-  /* read-only */ \\\n-  uv_req_type type; \\\n-  /* public */ \\\n-  void* data; \\\n-  /* private */ \\\n-  UV_REQ_PRIVATE_FIELDS\n-\n-/* Abstract base class of all requests. */\n-struct uv_req_s {\n-  UV_REQ_FIELDS\n-};\n-\n-\n-/* Platform-specific request types */\n-UV_PRIVATE_REQ_TYPES\n-\n-\n-/*\n- * uv_shutdown_t is a subclass of uv_req_t\n- *\n- * Shutdown the outgoing (write) side of a duplex stream. It waits for\n- * pending write requests to complete. The handle should refer to a\n- * initialized stream. req should be an uninitalized shutdown request\n- * struct. The cb is a called after shutdown is complete.\n- */\n-UV_EXTERN int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle,\n-    uv_shutdown_cb cb);\n-\n-struct uv_shutdown_s {\n-  UV_REQ_FIELDS\n-  uv_stream_t* handle;\n-  uv_shutdown_cb cb;\n-  UV_SHUTDOWN_PRIVATE_FIELDS\n-};\n-\n-\n-#define UV_HANDLE_FIELDS \\\n-  /* read-only */ \\\n-  uv_loop_t* loop; \\\n-  uv_handle_type type; \\\n-  /* public */ \\\n-  uv_close_cb close_cb; \\\n-  void* data; \\\n-  /* private */ \\\n-  UV_HANDLE_PRIVATE_FIELDS\n-\n-/* The abstract base class of all handles.  */\n-struct uv_handle_s {\n-  UV_HANDLE_FIELDS\n-};\n-\n-/*\n- * Returns 1 if the prepare/check/idle handle has been started, 0 otherwise.\n- * For other handle types this always returns 1.\n- */\n-UV_EXTERN int uv_is_active(uv_handle_t* handle);\n-\n-/*\n- * Request handle to be closed. close_cb will be called asynchronously after\n- * this call. This MUST be called on each handle before memory is released.\n- *\n- * Note that handles that wrap file descriptors are closed immediately but\n- * close_cb will still be deferred to the next iteration of the event loop.\n- * It gives you a chance to free up any resources associated with the handle.\n- */\n-UV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n-\n-\n-/*\n- * Constructor for uv_buf_t.\n- * Due to platform differences the user cannot rely on the ordering of the\n- * base and len members of the uv_buf_t struct. The user is responsible for\n- * freeing base after the uv_buf_t is done. Return struct passed by value.\n- */\n-UV_EXTERN uv_buf_t uv_buf_init(char* base, size_t len);\n-\n-\n-#define UV_STREAM_FIELDS \\\n-  /* number of bytes queued for writing */ \\\n-  size_t write_queue_size; \\\n-  uv_alloc_cb alloc_cb; \\\n-  uv_read_cb read_cb; \\\n-  uv_read2_cb read2_cb; \\\n-  /* private */ \\\n-  UV_STREAM_PRIVATE_FIELDS\n-\n-/*\n- * uv_stream_t is a subclass of uv_handle_t\n- *\n- * uv_stream is an abstract class.\n- *\n- * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t, and\n- * soon uv_file_t.\n- */\n-struct uv_stream_s {\n-  UV_HANDLE_FIELDS\n-  UV_STREAM_FIELDS\n-};\n-\n-UV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n-\n-/*\n- * This call is used in conjunction with uv_listen() to accept incoming\n- * connections. Call uv_accept after receiving a uv_connection_cb to accept\n- * the connection. Before calling uv_accept use uv_*_init() must be\n- * called on the client. Non-zero return value indicates an error.\n- *\n- * When the uv_connection_cb is called it is guaranteed that uv_accept will\n- * complete successfully the first time. If you attempt to use it more than\n- * once, it may fail. It is suggested to only call uv_accept once per\n- * uv_connection_cb call.\n- */\n-UV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n-\n-/*\n- * Read data from an incoming stream. The callback will be made several\n- * several times until there is no more data to read or uv_read_stop is\n- * called. When we've reached EOF nread will be set to -1 and the error is\n- * set to UV_EOF. When nread == -1 the buf parameter might not point to a\n- * valid buffer; in that case buf.len and buf.base are both set to 0.\n- * Note that nread might also be 0, which does *not* indicate an error or\n- * eof; it happens when libuv requested a buffer through the alloc callback\n- * but then decided that it didn't need that buffer.\n- */\n-UV_EXTERN int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n-    uv_read_cb read_cb);\n-\n-UV_EXTERN int uv_read_stop(uv_stream_t*);\n-\n-/*\n- * Extended read methods for receiving handles over a pipe. The pipe must be\n- * initialized with ipc == 1.\n- */\n-UV_EXTERN int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n-    uv_read2_cb read_cb);\n-\n-\n-/*\n- * Write data to stream. Buffers are written in order. Example:\n- *\n- *   uv_buf_t a[] = {\n- *     { .base = \"1\", .len = 1 },\n- *     { .base = \"2\", .len = 1 }\n- *   };\n- *\n- *   uv_buf_t b[] = {\n- *     { .base = \"3\", .len = 1 },\n- *     { .base = \"4\", .len = 1 }\n- *   };\n- *\n- *   // writes \"1234\"\n- *   uv_write(req, stream, a, 2);\n- *   uv_write(req, stream, b, 2);\n- *\n- */\n-UV_EXTERN int uv_write(uv_write_t* req, uv_stream_t* handle,\n-    uv_buf_t bufs[], int bufcnt, uv_write_cb cb);\n-\n-UV_EXTERN int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[],\n-    int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);\n-\n-/* uv_write_t is a subclass of uv_req_t */\n-struct uv_write_s {\n-  UV_REQ_FIELDS\n-  uv_write_cb cb;\n-  uv_stream_t* send_handle;\n-  uv_stream_t* handle;\n-  UV_WRITE_PRIVATE_FIELDS\n-};\n-\n-\n-\n-/*\n- * uv_tcp_t is a subclass of uv_stream_t\n- *\n- * Represents a TCP stream or TCP server.\n- */\n-struct uv_tcp_s {\n-  UV_HANDLE_FIELDS\n-  UV_STREAM_FIELDS\n-  UV_TCP_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n-\n-/* Enable/disable Nagle's algorithm. */\n-UV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\n-\n-/* Enable/disable TCP keep-alive.\n- *\n- * `ms` is the initial delay in seconds, ignored when `enable` is zero.\n- */\n-UV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle, int enable,\n-    unsigned int delay);\n-\n-/*\n- * This setting applies to Windows only.\n- * Enable/disable simultaneous asynchronous accept requests that are\n- * queued by the operating system when listening for new tcp connections.\n- * This setting is used to tune a tcp server for the desired performance.\n- * Having simultaneous accepts can significantly improve the rate of\n- * accepting connections (which is why it is enabled by default).\n- */\n-UV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n-\n-UV_EXTERN int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\n-UV_EXTERN int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\n-UV_EXTERN int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n-    int* namelen);\n-UV_EXTERN int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n-    int* namelen);\n-\n-/*\n- * uv_tcp_connect, uv_tcp_connect6\n- * These functions establish IPv4 and IPv6 TCP connections. Provide an\n- * initialized TCP handle and an uninitialized uv_connect_t*. The callback\n- * will be made when the connection is estabished.\n- */\n-UV_EXTERN int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n-    struct sockaddr_in address, uv_connect_cb cb);\n-UV_EXTERN int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n-    struct sockaddr_in6 address, uv_connect_cb cb);\n-\n-/* uv_connect_t is a subclass of uv_req_t */\n-struct uv_connect_s {\n-  UV_REQ_FIELDS\n-  uv_connect_cb cb;\n-  uv_stream_t* handle;\n-  UV_CONNECT_PRIVATE_FIELDS\n-};\n-\n-\n-/*\n- * UDP support.\n- */\n-\n-enum uv_udp_flags {\n-  /* Disables dual stack mode. Used with uv_udp_bind6(). */\n-  UV_UDP_IPV6ONLY = 1,\n-  /*\n-   * Indicates message was truncated because read buffer was too small. The\n-   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n-   */\n-  UV_UDP_PARTIAL = 2\n-};\n-\n-/*\n- * Called after a uv_udp_send() or uv_udp_send6(). status 0 indicates\n- * success otherwise error.\n- */\n-typedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\n-\n-/*\n- * Callback that is invoked when a new UDP datagram is received.\n- *\n- *  handle  UDP handle.\n- *  nread   Number of bytes that have been received.\n- *          0 if there is no more data to read. You may\n- *          discard or repurpose the read buffer.\n- *          -1 if a transmission error was detected.\n- *  buf     uv_buf_t with the received data.\n- *  addr    struct sockaddr_in or struct sockaddr_in6.\n- *          Valid for the duration of the callback only.\n- *  flags   One or more OR'ed UV_UDP_* constants.\n- *          Right now only UV_UDP_PARTIAL is used.\n- */\n-typedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,\n-    struct sockaddr* addr, unsigned flags);\n-\n-/* uv_udp_t is a subclass of uv_handle_t */\n-struct uv_udp_s {\n-  UV_HANDLE_FIELDS\n-  UV_UDP_PRIVATE_FIELDS\n-};\n-\n-/* uv_udp_send_t is a subclass of uv_req_t */\n-struct uv_udp_send_s {\n-  UV_REQ_FIELDS\n-  uv_udp_t* handle;\n-  uv_udp_send_cb cb;\n-  UV_UDP_SEND_PRIVATE_FIELDS\n-};\n-\n-/*\n- * Initialize a new UDP handle. The actual socket is created lazily.\n- * Returns 0 on success.\n- */\n-UV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n-\n-/*\n- * Bind to a IPv4 address and port.\n- *\n- * Arguments:\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *  addr      struct sockaddr_in with the address and port to bind to.\n- *  flags     Unused.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n-    unsigned flags);\n-\n-/*\n- * Bind to a IPv6 address and port.\n- *\n- * Arguments:\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *  addr      struct sockaddr_in with the address and port to bind to.\n- *  flags     Should be 0 or UV_UDP_IPV6ONLY.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n-    unsigned flags);\n-UV_EXTERN int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n-    int* namelen);\n-\n-/*\n- * Set membership for a multicast address\n- *\n- * Arguments:\n- *  handle              UDP handle. Should have been initialized with\n- *                      `uv_udp_init`.\n- *  multicast_addr      multicast address to set membership for\n- *  interface_addr      interface address\n- *  membership          Should be UV_JOIN_GROUP or UV_LEAVE_GROUP\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n-    const char* multicast_addr, const char* interface_addr,\n-    uv_membership membership);\n-\n-/*\n- * Send data. If the socket has not previously been bound with `uv_udp_bind`\n- * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n- * and a random port number.\n- *\n- * Arguments:\n- *  req       UDP request handle. Need not be initialized.\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *  bufs      List of buffers to send.\n- *  bufcnt    Number of buffers in `bufs`.\n- *  addr      Address of the remote peer. See `uv_ip4_addr`.\n- *  send_cb   Callback to invoke when the data has been sent out.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle,\n-    uv_buf_t bufs[], int bufcnt, struct sockaddr_in addr,\n-    uv_udp_send_cb send_cb);\n-\n-/*\n- * Send data. If the socket has not previously been bound with `uv_udp_bind6`,\n- * it is bound to ::0 (the \"all interfaces\" address) and a random port number.\n- *\n- * Arguments:\n- *  req       UDP request handle. Need not be initialized.\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *  bufs      List of buffers to send.\n- *  bufcnt    Number of buffers in `bufs`.\n- *  addr      Address of the remote peer. See `uv_ip6_addr`.\n- *  send_cb   Callback to invoke when the data has been sent out.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle,\n-    uv_buf_t bufs[], int bufcnt, struct sockaddr_in6 addr,\n-    uv_udp_send_cb send_cb);\n-\n-/*\n- * Receive data. If the socket has not previously been bound with `uv_udp_bind`\n- * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n- * and a random port number.\n- *\n- * Arguments:\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *  alloc_cb  Callback to invoke when temporary storage is needed.\n- *  recv_cb   Callback to invoke with received data.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n-    uv_udp_recv_cb recv_cb);\n-\n-/*\n- * Stop listening for incoming datagrams.\n- *\n- * Arguments:\n- *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n- *\n- * Returns:\n- *  0 on success, -1 on error.\n- */\n-UV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\n-\n-\n-/*\n- * uv_tty_t is a subclass of uv_stream_t\n- *\n- * Representing a stream for the console.\n- */\n-struct uv_tty_s {\n-  UV_HANDLE_FIELDS\n-  UV_STREAM_FIELDS\n-  UV_TTY_PRIVATE_FIELDS\n-};\n-\n-/*\n- * Initialize a new TTY stream with the given file descriptor. Usually the\n- * file descriptor will be\n- *   0 = stdin\n- *   1 = stdout\n- *   2 = stderr\n- * The last argument, readable, specifies if you plan on calling\n- * uv_read_start with this stream. stdin is readable, stdout is not.\n- *\n- * TTY streams which are not readable have blocking writes.\n- */\n-UV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\n-\n-/*\n- * Set mode. 0 for normal, 1 for raw.\n- */\n-UV_EXTERN int uv_tty_set_mode(uv_tty_t*, int mode);\n-\n-/*\n- * To be called when the program exits. Resets TTY settings to default\n- * values for the next process to take over.\n- */\n-UV_EXTERN void uv_tty_reset_mode();\n-\n-/*\n- * Gets the current Window size. On success zero is returned.\n- */\n-UV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n-\n-/*\n- * Used to detect what type of stream should be used with a given file\n- * descriptor. Usually this will be used during initialization to guess the\n- * type of the stdio streams.\n- * For isatty() functionality use this function and test for UV_TTY.\n- */\n-UV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n-\n-/*\n- * uv_pipe_t is a subclass of uv_stream_t\n- *\n- * Representing a pipe stream or pipe server. On Windows this is a Named\n- * Pipe. On Unix this is a UNIX domain socket.\n- */\n-struct uv_pipe_s {\n-  UV_HANDLE_FIELDS\n-  UV_STREAM_FIELDS\n-  UV_PIPE_PRIVATE_FIELDS\n-  int ipc; /* non-zero if this pipe is used for passing handles */\n-};\n-\n-/*\n- * Initialize a pipe. The last argument is a boolean to indicate if\n- * this pipe will be used for handle passing between processes.\n- */\n-UV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\n-\n-/*\n- * Opens an existing file descriptor or HANDLE as a pipe.\n- */\n-UV_EXTERN void uv_pipe_open(uv_pipe_t*, uv_file file);\n-\n-UV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\n-\n-UV_EXTERN void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n-    const char* name, uv_connect_cb cb);\n-\n-\n-/*\n- * uv_prepare_t is a subclass of uv_handle_t.\n- *\n- * libev wrapper. Every active prepare handle gets its callback called\n- * exactly once per loop iteration, just before the system blocks to wait\n- * for completed i/o.\n- */\n-struct uv_prepare_s {\n-  UV_HANDLE_FIELDS\n-  UV_PREPARE_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\n-\n-UV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n-\n-UV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n-\n-\n-/*\n- * uv_check_t is a subclass of uv_handle_t.\n- *\n- * libev wrapper. Every active check handle gets its callback called exactly\n- * once per loop iteration, just after the system returns from blocking.\n- */\n-struct uv_check_s {\n-  UV_HANDLE_FIELDS\n-  UV_CHECK_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\n-\n-UV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\n-\n-UV_EXTERN int uv_check_stop(uv_check_t* check);\n-\n-\n-/*\n- * uv_idle_t is a subclass of uv_handle_t.\n- *\n- * libev wrapper. Every active idle handle gets its callback called\n- * repeatedly until it is stopped. This happens after all other types of\n- * callbacks are processed.  When there are multiple \"idle\" handles active,\n- * their callbacks are called in turn.\n- */\n-struct uv_idle_s {\n-  UV_HANDLE_FIELDS\n-  UV_IDLE_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\n-\n-UV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n-\n-UV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n-\n-\n-/*\n- * uv_async_t is a subclass of uv_handle_t.\n- *\n- * libev wrapper. uv_async_send wakes up the event\n- * loop and calls the async handle's callback There is no guarantee that\n- * every uv_async_send call leads to exactly one invocation of the callback;\n- * The only guarantee is that the callback function is  called at least once\n- * after the call to async_send. Unlike all other libuv functions,\n- * uv_async_send can be called from another thread.\n- */\n-struct uv_async_s {\n-  UV_HANDLE_FIELDS\n-  UV_ASYNC_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_async_init(uv_loop_t*, uv_async_t* async,\n-    uv_async_cb async_cb);\n-\n-/*\n- * This can be called from other threads to wake up a libuv thread.\n- *\n- * libuv is single threaded at the moment.\n- */\n-UV_EXTERN int uv_async_send(uv_async_t* async);\n-\n-\n-/*\n- * uv_timer_t is a subclass of uv_handle_t.\n- *\n- * Wraps libev's ev_timer watcher. Used to get woken up at a specified time\n- * in the future.\n- */\n-struct uv_timer_s {\n-  UV_HANDLE_FIELDS\n-  UV_TIMER_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* timer);\n-\n-UV_EXTERN int uv_timer_start(uv_timer_t* timer, uv_timer_cb cb,\n-    int64_t timeout, int64_t repeat);\n-\n-UV_EXTERN int uv_timer_stop(uv_timer_t* timer);\n-\n-/*\n- * Stop the timer, and if it is repeating restart it using the repeat value\n- * as the timeout. If the timer has never been started before it returns -1 and\n- * sets the error to UV_EINVAL.\n- */\n-UV_EXTERN int uv_timer_again(uv_timer_t* timer);\n-\n-/*\n- * Set the repeat value. Note that if the repeat value is set from a timer\n- * callback it does not immediately take effect. If the timer was nonrepeating\n- * before, it will have been stopped. If it was repeating, then the old repeat\n- * value will have been used to schedule the next timeout.\n- */\n-UV_EXTERN void uv_timer_set_repeat(uv_timer_t* timer, int64_t repeat);\n-\n-UV_EXTERN int64_t uv_timer_get_repeat(uv_timer_t* timer);\n-\n-\n-/* c-ares integration initialize and terminate */\n-UV_EXTERN  int uv_ares_init_options(uv_loop_t*,\n-    ares_channel *channelptr, struct ares_options *options, int optmask);\n-\n-/* TODO remove the loop argument from this function? */\n-UV_EXTERN void uv_ares_destroy(uv_loop_t*, ares_channel channel);\n-\n-\n-/*\n- * uv_getaddrinfo_t is a subclass of uv_req_t\n- *\n- * Request object for uv_getaddrinfo.\n- */\n-struct uv_getaddrinfo_s {\n-  UV_REQ_FIELDS\n-  /* read-only */\n-  uv_loop_t* loop; \\\n-  UV_GETADDRINFO_PRIVATE_FIELDS\n-};\n-\n-\n-/*\n- * Asynchronous getaddrinfo(3).\n- *\n- * Return code 0 means that request is accepted and callback will be called\n- * with result. Other return codes mean that there will not be a callback.\n- * Input arguments may be released after return from this call.\n- *\n- * uv_freeaddrinfo() must be called after completion to free the addrinfo\n- * structure.\n- *\n- * On error NXDOMAIN the status code will be non-zero and UV_ENOENT returned.\n- */\n-UV_EXTERN int uv_getaddrinfo(uv_loop_t*, uv_getaddrinfo_t* handle,\n-    uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service,\n-    const struct addrinfo* hints);\n-\n-UV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n-\n-/* uv_spawn() options */\n-typedef struct uv_process_options_s {\n-  uv_exit_cb exit_cb; /* Called after the process exits. */\n-  const char* file; /* Path to program to execute. */\n-  /*\n-   * Command line arguments. args[0] should be the path to the program. On\n-   * Windows this uses CreateProcess which concatinates the arguments into a\n-   * string this can cause some strange errors. See the note at\n-   * windows_verbatim_arguments.\n-   */\n-  char** args;\n-  /*\n-   * This will be set as the environ variable in the subprocess. If this is\n-   * NULL then the parents environ will be used.\n-   */\n-  char** env;\n-  /*\n-   * If non-null this represents a directory the subprocess should execute\n-   * in. Stands for current working directory.\n-   */\n-  char* cwd;\n-\n-  /*\n-   * TODO describe how this works.\n-   */\n-  int windows_verbatim_arguments;\n-\n-  /*\n-   * The user should supply pointers to initialized uv_pipe_t structs for\n-   * stdio. This is used to to send or receive input from the subprocess.\n-   * The user is reponsible for calling uv_close on them.\n-   */\n-  uv_pipe_t* stdin_stream;\n-  uv_pipe_t* stdout_stream;\n-  uv_pipe_t* stderr_stream;\n-} uv_process_options_t;\n-\n-/*\n- * uv_process_t is a subclass of uv_handle_t\n- */\n-struct uv_process_s {\n-  UV_HANDLE_FIELDS\n-  uv_exit_cb exit_cb;\n-  int pid;\n-  UV_PROCESS_PRIVATE_FIELDS\n-};\n-\n-/* Initializes uv_process_t and starts the process. */\n-UV_EXTERN int uv_spawn(uv_loop_t*, uv_process_t*,\n-    uv_process_options_t options);\n-\n-/*\n- * Kills the process with the specified signal. The user must still\n- * call uv_close on the process.\n- */\n-UV_EXTERN int uv_process_kill(uv_process_t*, int signum);\n-\n-\n-/* Kills the process with the specified signal. */\n-UV_EXTERN uv_err_t uv_kill(int pid, int signum);\n-\n-\n-/*\n- * uv_work_t is a subclass of uv_req_t\n- */\n-struct uv_work_s {\n-  UV_REQ_FIELDS\n-  uv_loop_t* loop;\n-  uv_work_cb work_cb;\n-  uv_after_work_cb after_work_cb;\n-  UV_WORK_PRIVATE_FIELDS\n-};\n-\n-/* Queues a work request to execute asynchronously on the thread pool. */\n-UV_EXTERN int uv_queue_work(uv_loop_t* loop, uv_work_t* req,\n-    uv_work_cb work_cb, uv_after_work_cb after_work_cb);\n-\n-\n-\n-\n-/*\n- * File System Methods.\n- *\n- * The uv_fs_* functions execute a blocking system call asynchronously (in a\n- * thread pool) and call the specified callback in the specified loop after\n- * completion. If the user gives NULL as the callback the blocking system\n- * call will be called synchronously. req should be a pointer to an\n- * uninitialized uv_fs_t object.\n- *\n- * uv_fs_req_cleanup() must be called after completion of the uv_fs_\n- * function to free any internal memory allocations associted with the\n- * request.\n- */\n-\n-typedef enum {\n-  UV_FS_UNKNOWN = -1,\n-  UV_FS_CUSTOM,\n-  UV_FS_OPEN,\n-  UV_FS_CLOSE,\n-  UV_FS_READ,\n-  UV_FS_WRITE,\n-  UV_FS_SENDFILE,\n-  UV_FS_STAT,\n-  UV_FS_LSTAT,\n-  UV_FS_FSTAT,\n-  UV_FS_FTRUNCATE,\n-  UV_FS_UTIME,\n-  UV_FS_FUTIME,\n-  UV_FS_CHMOD,\n-  UV_FS_FCHMOD,\n-  UV_FS_FSYNC,\n-  UV_FS_FDATASYNC,\n-  UV_FS_UNLINK,\n-  UV_FS_RMDIR,\n-  UV_FS_MKDIR,\n-  UV_FS_RENAME,\n-  UV_FS_READDIR,\n-  UV_FS_LINK,\n-  UV_FS_SYMLINK,\n-  UV_FS_READLINK,\n-  UV_FS_CHOWN,\n-  UV_FS_FCHOWN\n-} uv_fs_type;\n-\n-/* uv_fs_t is a subclass of uv_req_t */\n-struct uv_fs_s {\n-  UV_REQ_FIELDS\n-  uv_loop_t* loop;\n-  uv_fs_type fs_type;\n-  uv_fs_cb cb;\n-  ssize_t result;\n-  void* ptr;\n-  char* path;\n-  int errorno;\n-  UV_FS_PRIVATE_FIELDS\n-};\n-\n-UV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\n-\n-UV_EXTERN int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    int flags, int mode, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    void* buf, size_t length, off_t offset, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    void* buf, size_t length, off_t offset, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    int mode, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req,\n-    const char* path, int flags, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    const char* new_path, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    off_t offset, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n-    uv_file in_fd, off_t in_offset, size_t length, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    int mode, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    double atime, double mtime, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    double atime, double mtime, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    const char* new_path, uv_fs_cb cb);\n-\n-/*\n- * This flag can be used with uv_fs_symlink on Windows\n- * to specify whether path argument points to a directory.\n- */\n-#define UV_FS_SYMLINK_DIR          0x0001\n-\n-UV_EXTERN int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    const char* new_path, int flags, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    int mode, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path,\n-    int uid, int gid, uv_fs_cb cb);\n-\n-UV_EXTERN int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n-    int uid, int gid, uv_fs_cb cb);\n-\n-\n-enum uv_fs_event {\n-  UV_RENAME = 1,\n-  UV_CHANGE = 2\n-};\n-\n-\n-struct uv_fs_event_s {\n-  UV_HANDLE_FIELDS\n-  char* filename;\n-  UV_FS_EVENT_PRIVATE_FIELDS\n-};\n-\n-\n-/*\n- * Gets load avg\n- * See: http://en.wikipedia.org/wiki/Load_(computing)\n- * (Returns [0,0,0] for windows and cygwin)\n- */\n-UV_EXTERN void uv_loadavg(double avg[3]);\n-\n-\n-/*\n- * Flags to be passed to uv_fs_event_init.\n- */\n-enum uv_fs_event_flags {\n-  /*\n-   * By default, if the fs event watcher is given a directory name, we will\n-   * watch for all events in that directory. This flags overrides this behavior\n-   * and makes fs_event report only changes to the directory entry itself. This\n-   * flag does not affect individual files watched.\n-   * This flag is currently not implemented yet on any backend.\n-   */\n- UV_FS_EVENT_WATCH_ENTRY = 1,\n-\n-  /*\n-   * By default uv_fs_event will try to use a kernel interface such as inotify\n-   * or kqueue to detect events. This may not work on remote filesystems such\n-   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n-   * regular interval.\n-   * This flag is currently not implemented yet on any backend.\n-   */\n-  UV_FS_EVENT_STAT = 2\n-};\n-\n-\n-UV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n-    const char* filename, uv_fs_event_cb cb, int flags);\n-\n-/* Utility */\n-\n-/* Convert string ip addresses to binary structures */\n-UV_EXTERN struct sockaddr_in uv_ip4_addr(const char* ip, int port);\n-UV_EXTERN struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n-\n-/* Convert binary addresses to strings */\n-UV_EXTERN int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);\n-UV_EXTERN int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n-\n-/* Gets the executable path */\n-UV_EXTERN int uv_exepath(char* buffer, size_t* size);\n-\n-/* Gets memory info in bytes */\n-UV_EXTERN uint64_t uv_get_free_memory(void);\n-UV_EXTERN uint64_t uv_get_total_memory(void);\n-\n-/*\n- * Returns the current high-resolution real time. This is expressed in\n- * nanoseconds. It is relative to an arbitrary time in the past. It is not\n- * related to the time of day and therefore not subject to clock drift. The\n- * primary use is for measuring performance between intervals.\n- *\n- * Note not every platform can support nanosecond resolution; however, this\n- * value will always be in nanoseconds.\n- */\n-UV_EXTERN extern uint64_t uv_hrtime(void);\n-\n-\n-/*\n- * Opens a shared library. The filename is in utf-8. On success, -1 is\n- * and the variable pointed by library receives a handle to the library.\n- */\n-UV_EXTERN uv_err_t uv_dlopen(const char* filename, uv_lib_t* library);\n-UV_EXTERN uv_err_t uv_dlclose(uv_lib_t library);\n-\n-/*\n- * Retrieves a data pointer from a dynamic library.\n- */\n-UV_EXTERN uv_err_t uv_dlsym(uv_lib_t library, const char* name, void** ptr);\n-\n-\n-/* the presence of these unions force similar struct layout */\n-union uv_any_handle {\n-  uv_tcp_t tcp;\n-  uv_pipe_t pipe;\n-  uv_prepare_t prepare;\n-  uv_check_t check;\n-  uv_idle_t idle;\n-  uv_async_t async;\n-  uv_timer_t timer;\n-  uv_getaddrinfo_t getaddrinfo;\n-  uv_fs_event_t fs_event;\n-};\n-\n-union uv_any_req {\n-  uv_req_t req;\n-  uv_write_t write;\n-  uv_connect_t connect;\n-  uv_shutdown_t shutdown;\n-  uv_fs_t fs_req;\n-  uv_work_t work_req;\n-};\n-\n-\n-struct uv_counters_s {\n-  uint64_t eio_init;\n-  uint64_t req_init;\n-  uint64_t handle_init;\n-  uint64_t stream_init;\n-  uint64_t tcp_init;\n-  uint64_t udp_init;\n-  uint64_t pipe_init;\n-  uint64_t tty_init;\n-  uint64_t prepare_init;\n-  uint64_t check_init;\n-  uint64_t idle_init;\n-  uint64_t async_init;\n-  uint64_t timer_init;\n-  uint64_t process_init;\n-  uint64_t fs_event_init;\n-};\n-\n-\n-struct uv_loop_s {\n-  UV_LOOP_PRIVATE_FIELDS\n-  /* list used for ares task handles */\n-  uv_ares_task_t* uv_ares_handles_;\n-  /* Various thing for libeio. */\n-  uv_async_t uv_eio_want_poll_notifier;\n-  uv_async_t uv_eio_done_poll_notifier;\n-  uv_idle_t uv_eio_poller;\n-  /* Diagnostic counters */\n-  uv_counters_t counters;\n-  /* The last error */\n-  uv_err_t last_err;\n-  /* User data - use this for whatever. */\n-  void* data;\n-};\n-\n-\n-/* Don't export the private CPP symbols. */\n-#undef UV_REQ_TYPE_PRIVATE\n-#undef UV_REQ_PRIVATE_FIELDS\n-#undef UV_STREAM_PRIVATE_FIELDS\n-#undef UV_TCP_PRIVATE_FIELDS\n-#undef UV_PREPARE_PRIVATE_FIELDS\n-#undef UV_CHECK_PRIVATE_FIELDS\n-#undef UV_IDLE_PRIVATE_FIELDS\n-#undef UV_ASYNC_PRIVATE_FIELDS\n-#undef UV_TIMER_PRIVATE_FIELDS\n-#undef UV_GETADDRINFO_PRIVATE_FIELDS\n-#undef UV_FS_REQ_PRIVATE_FIELDS\n-#undef UV_WORK_PRIVATE_FIELDS\n-#undef UV_FS_EVENT_PRIVATE_FIELDS\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif /* UV_H */"}, {"sha": "e197a7419d0065f0865f7bf6aeb1c775396522f6", "filename": "src/rt/libuv/src/ares/AUTHORS", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FAUTHORS?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,37 +0,0 @@\n-c-ares is based on ares, and these are the people that have worked on it since\n-the fork was made:\n-\n-Alexander Lazic\n-Alexey Simak\n-Andreas Rieke\n-Ashish Sharma\n-Brad House\n-Brad Spencer\n-Bram Matthys\n-Dan Fandrich\n-Daniel Stenberg\n-Dirk Manske\n-Dominick Meglio\n-Doug Goldstein\n-Duncan Wilcox\n-Eino Tuominen\n-Erik Kline\n-George Neill\n-Gisle Vanem\n-Guilherme Balena Versiani\n-Gunter Knauf\n-Henrik Stoerner\n-James Bursa\n-Michael Wallner\n-Nick Mathewson\n-Phil Blundell\n-Ravi Pratap\n-Robin Cornelius\n-Sebastian at basti79.de\n-Shmulik Regev\n-Steinar H. Gunderson\n-Tofu Linden\n-Vlad Dinulescu\n-William Ahern\n-Yang Tse\n-liren at vivisimo.com"}, {"sha": "73fe8c77104058d792346a2654080ee45406d2ab", "filename": "src/rt/libuv/src/ares/CHANGES", "status": "removed", "additions": 0, "deletions": 1218, "changes": 1218, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCHANGES?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,1218 +0,0 @@\n-  Changelog for the c-ares project\n-\n-Version 1.7.5 (August 16, 2011)\n-\n-Fixed:\n-\n- o detection of semicolon comments in resolv.conf\n- o avoid using system's inet_net_pton affected by the WLB-2008080064 advisory\n- o replacement ares_inet_net_pton affected by the WLB-2008080064 advisory\n- o replacement ares_inet_ntop affected by potential out of bounds write\n- o added install target to Makefile.msvc\n- o only fall back to AF_INET searches when looking for AF_UNSPEC addresses\n- o fixed ares_parse_*_reply memory leaks\n- o Use correct sizeof in ares_getnameinfo()\n- o IPv6-on-windows: find DNS servers correctly\n- o man pages: docs for the c-ares utility programs\n- o getservbyport replacement for Win CE\n- o config_sortlist: (win32) missing else\n- o advance_tcp_send_queue: avoid NULL ptr dereference\n- o configure: fix a bashism\n- o ares_expand_name: Fix encoded length for indirect root\n-\n-Version 1.7.4 (December 9, 2010)\n-\n-Changed:\n-\n- o local-bind: Support binding to local interface/IPs, see\n-   ares_set_local_ip4, ares_set_local_ip6, ares_set_local_dev\n-\n-Fixed:\n-\n- o memory leak in ares_getnameinfo\n- o add missing break that caused get_ares_servers to fail\n- o ares_parse_a_reply: fix CNAME response parsing\n- o init_by_options: don't copy an empty sortlist\n- o Replaced uint32_t with unsigned int to fix broken builds\n-   on a couple of platforms\n- o Fix lookup with HOSTALIASES set\n- o adig: fix NAPTR parsing\n- o compiler warning cleanups\n-\n-Version 1.7.3 (June 11, 2010)\n-\n-Fixed:\n-\n- o builds on Android\n- o now includes all files necessary to build it (1.7.2 lacked a file)\n-\n-Version 1.7.2 (June 10, 2010)\n-\n-Changed:\n-\n- o Added ares_parse_mx_reply()\n-\n-Fixed:\n-\n- o ares_init: Last, not first instance of domain or search should win\n- o improve alternative definition of bool\n- o fix VS2010 compiler warnings\n-\n-\n-Version 1.7.1 (Mar 23, 2010)\n-\n-* May 31, 2010 (Jakub Hrozek)\n-- Use the last instance of domain/search, not the first one\n-\n-* March 23, 2010 (Daniel Stenberg)\n-- We switched from CVS to git. See http://github.com/bagder/c-ares\n-\n-* March 5, 2010 (Daniel Stenberg)\n-- Daniel Johnson provided fixes for building with the clang compiler.\n-\n-* March 5, 2010 (Yang Tse)\n-- Added IPv6 name servers support. Implementation has been based on code,\n-  comments and feedback provided November and December of 2008 by Daniel\n-  Stenberg, Gregor Jasny, Phil Blundell and myself, December 2009 by Cedric\n-  Bail, and February 2010 by Jakub Hrozek on the c-ares mailing list. On\n-  March I reviewed all that, selected the best of each, and adjusted or\n-  extended parts of it to make the best fit.\n-\n-  The external and visible result of all this is that two new functions are\n-  added to the external API, ares_get_servers() and ares_set_servers(), which\n-  becomes now the preferred way of getting and setting name servers for any\n-  ares channel as these support both IPv4 and IPv6 name servers.\n-\n-  In order to not break ABI compatibility, ares_init_options() with option\n-  mask ARES_OPT_SERVERS and ares_save_options() may still be used in code\n-  which is intended to run on IPv4-only stacks. But remember that these\n-  functions do not support IPv6 name servers. This implies that if the user\n-  is capable of defining or providing an IPv6 name server, and the app is\n-  using ares_init_options() or ares_save_options() at some point to handle\n-  the name servers, the app will likely lose IPv6 name servers.\n-\n-* January 28, 2010 (Daniel Stenberg)\n-- Tommie Gannert pointed out a silly bug in ares_process_fd() since it didn't\n-  check for broken connections like ares_process() did. Based on that, I\n-  merged the two functions into a single generic one with two front-ends.\n-\n-* December 29, 2009 (Yang Tse)\n-- Laszlo Tamas Szabo adjusted Makefile.msvc compiler options so that where\n-  run-time error checks enabling compiler option /GZ was used it is replaced\n-  with equivalent /RTCsu for Visual Studio 2003 and newer versions. Option\n-  /GX is replaced with equivalent /EHsc for all versions. Also fixed socket\n-  data type for internal configure_socket function.\n-\n-* December 21, 2009 (Yang Tse)\n-- Ingmar Runge noticed that Windows config-win32.h configuration file\n-  did not include a definition for HAVE_CLOSESOCKET which resulted in\n-  function close() being inappropriately used to close sockets.\n-\n-Version 1.7.0 (Nov 30, 2009)\n-\n-* November 26, 2009 (Yang Tse)\n-- Larry Lansing fixed ares_parse_srv_reply to properly parse replies\n-  which might contain non-SRV answers, skipping over potential non-SRV\n-  ones such as CNAMEs.\n-\n-* November 23, 2009 (Yang Tse)\n-- Changed naming convention for c-ares libraries built with MSVC, details\n-  and build instructions provided in README.msvc file.\n-\n-* November 22, 2009 (Yang Tse)\n-- Jakub Hrozek fixed more function prototypes in man pages to sync them\n-  with the ones declared in ares.h\n-\n-- Jakub Hrozek renamed addrttl and addr6ttl structs to ares_addrttl and\n-  ares_addr6ttl in order to prevent name space pollution, along with\n-  necessary changes to code base and man pages.This change does not break\n-  ABI, there is no need to recompile existing applications. But existing\n-  applications using these structs with the old name will need source code\n-  adjustments when recompiled using c-ares 1.7.0.\n-\n-* November 21, 2009 (Yang Tse)\n-- Added manifest stuff to Makefile.msvc.\n-\n-* November 20, 2009 (Yang Tse)\n-- Fixed several function prototypes in man pages that were out of sync\n-  with the ones declared in ares.h.  Added ares_free_data() along with\n-  man page.  Updated ares_parse_srv_reply() and ares_parse_txt_reply()\n-  with changes from Jakub Hrozek making these now return linked lists\n-  instead of arrays, and merging the ares_free_data() adjustments.\n-\n-* November 10, 2009 (Yang Tse)\n-- Updated MSVC 6.0 project files to match settings from Makefile.msvc.\n-\n-* November 9, 2009 (Yang Tse)\n-- Makefile.msvc is now the reference method to build c-ares and sample\n-  programs with any MSVC compiler or MS Visual Studio version.  If no\n-  option or target are specified it builds dynamic and static c-ares\n-  libraries in debug and release flavours and also builds all sample\n-  programs using each of the different c-ares libraries.\n-\n-* November 2, 2009 (Yang Tse)\n-- Renamed c-ares setup.h to ares_setup.h\n-\n-* October 31, 2009 (Yang Tse)\n-- Symbol hiding configure options are named now --enable-symbol-hiding\n-  and --disable-symbol-hiding in an attempt to make them less ambiguous.\n-\n-* October 30, 2009 (Yang Tse)\n-- Many fixes for ares_parse_txt_reply()\n-\n-* October 29, 2009 (Daniel Stenberg)\n-- Jakub Hrozek added ares_parse_txt_reply() for TXT parsing\n-\n-* October 29, 2009 (Yang Tse)\n-- Updated MSVC 6.0 workspace and project files that allows building\n-  dynamic and static c-ares libraries in debug and release flavours.\n-  Additionally each of the three sample programs is built against\n-  each of the four possible c-ares libraries, generating all this\n-  a total number of 12 executables and 4 libraries.\n-\n-* October 28, 2009 (Yang Tse)\n-- Initial step towards the ability to reduce c-ares exported symbols\n-  when built as a shared library based on the 'visibility' attribute\n-  for GNUC and Intel compilers and based on __global for Sun compilers,\n-  taking also in account __declspec function decoration for Win32 and\n-  Symbian DLL's.\n-\n-* October 27, 2009 (Yang Tse)\n-- Fixed Pelles C Win32 target compilation issues.\n-\n-* October 23, 2009 (Yang Tse)\n-- John Engelhart noticed an unreleased problem relative to a duplicate\n-  ARES_ECANCELLED error code value and missing error code description.\n-\n-* October 7, 2009 (Yang Tse)\n-- Overhauled ares__get_hostent() Fixing out of bounds memory overwrite\n-  triggered with malformed /etc/hosts file. Improving parsing of /etc/hosts\n-  file. Validating requested address family. Ensuring that failures always\n-  return a NULL pointer. Adjusting header inclusions.\n-\n-* October 6, 2009 (Yang Tse)\n-- Fix ssize_t redefinition errors on WIN64 reported by Alexey Simak.\n-\n-* September 29, 2009 (Yang Tse)\n-- Make configure script also check if _REENTRANT definition is required to\n-  make errno available as a preprocessor macro.\n-\n-* September 7, 2009 (Yang Tse)\n-- Add T_SRV portability check to ares_parse_srv_reply.c\n-\n-* 4 Sep 2009 (Daniel Stenberg)\n-- Jakub Hrozek added ares_parse_srv_reply() for SRV parsing\n-\n-* 3 Aug 2009 (Daniel Stenberg)\n-- Joshua Kwan fixed the init routine to fill in the defaults for stuff that\n-  fails to get inited by other means. This fixes a case of when the c-ares\n-  init fails when internet access is fone.\n-\n-- Timo Teras changed the reason code used in the resolve callback done when\n-  ares_cancel() is used, to be ARES_ECANCELLED instead of ARES_ETIMEOUT to\n-  better allow the callback to know what's happening.\n-\n-* 14 Jul 2009 (Guenter Knauf)\n-- renamed generated config.h to ares_config.h to avoid any future clashes\n-  with config.h from other projects.\n-\n-* June 20 2009 (Yang Tse)\n-- Refactor how libraries are checked for connect() function in configure\n-  script and check for connect() as it is done for other functions.\n-\n-* June 19 2009 (Yang Tse)\n-- Make sclose() function-like macro definition used to close a socket,\n-  now solely based on HAVE_CLOSESOCKET and HAVE_CLOSESOCKET_CAMEL\n-  config file preprocessor definitions\n-\n-* June 18 2009 (Yang Tse)\n-- Add CloseSocket camel case function check for configure script.\n-\n-* June 17 2009 (Yang Tse)\n-- Check for socket() and closesocket() as it is done for other functions\n-  in configure script.\n-\n-* June 11 2009 (Yang Tse)\n-- Modified buildconf so that when automake runs it copies missing files\n-  instead of symlinking them.\n-\n-* June 8 2009 (Yang Tse)\n-- Removed buildconf.bat from release and daily snapshot archives. This\n-  file is only for CVS tree checkout builds.\n-\n-* May 26 2009 (Yang Tse)\n-- Added --enable-curldebug configure option to enable and disable building\n-  with the low-level curl debug memory tracking 'feature' to allow decoupled\n-  setting from --enable-debug, allowing again to build c-ares independently\n-  out of the CVS tree.\n-\n-  For the c-ares library option --enable-debug enables debug build features\n-  which are _not_ related with memory tracking. For the c-ares library when\n-  --enable-debug is given it does not enable the memory tracking feature. If\n-  you wish to enable the curl debug memory tracking you must use configure\n-  option --enable-curldebug explicitily to do so.\n-\n-  Internally, definition of preprocessor symbol DEBUGBUILD restricts code\n-  which is only compiled for debug enabled builds. And symbol CURLDEBUG is\n-  used to differentiate code which is _only_ used for memory tracking.\n-\n-  Make ares_init(), ares_dup() and ares_init_options() fail returning\n-  ARES_ENOTINITIALIZED if library initialization has not been performed\n-  calling ares_library_init().\n-\n-* May 20 2009 (Yang Tse)\n-- Added ares_library_init() and ares_library_cleanup() man pages.\n-\n-* May 19 2009 (Yang Tse)\n-- Introduced ares_library_init() and ares_library_cleanup() functions.\n-\n-  This is an API and ABI break for Win32/64 systems. Non-Win32/64 build targets\n-  using c-ares 1.7.0 can still survive without calling these functions. Read all\n-  the details on ares_library_init(3) and ares_library_cleanup(3) man pages that\n-  are included.\n-\n-  curl/libcurl 7.19.5 is fully compatible with c-ares 1.7.0 on all systems.\n-\n-  In order to use c-ares 1.7.0 with curl/libcurl on Win32/64 systems it is\n-  required that curl/libcurl is 7.19.5 or newer. In other words, it is not\n-  possible on Win32/64 to use c-ares 1.7.0 with a curl/libcurl version less\n-  than 7.19.5\n-\n-* May 11 2009 (Daniel Stenberg)\n-- Gregor Jasny made c-ares link with libtool 's -export-symbols-regex option to\n-  only expose functions starting with ares_.\n-\n-* May 7 2009 (Yang Tse)\n-- Fix an m4 overquoting triggering a spurious 'AS_TR_CPP' symbol definition\n-  attempt in generated config.h\n-\n-* May 2 2009 (Yang Tse)\n-- Use a build-time configured ares_socklen_t data type instead of socklen_t.\n-\n-* April 21 2009 (Yang Tse)\n-- Moved potential inclusion of system's malloc.h and memory.h header files to\n-  setup_once.h.  Inclusion of each header file is based on the definition of\n-  NEED_MALLOC_H and NEED_MEMORY_H respectively.\n-\n-* March 11 2009 (Yang Tse)\n-- Japheth Cleaver fixed acountry.c replacing u_long with unsigned long.\n-\n-* February 20 2009 (Yang Tse)\n-- Do not halt compilation when using VS2008 to build a Windows 2000 target.\n-\n-* February 3 2009 (Phil Blundell)\n-- If the server returns garbage or nothing at all in response to an AAAA query,\n-  go on and ask for A records anyway.\n-\n-* January 31 2009 (Daniel Stenberg)\n-- ares_gethostbyname() now accepts 'AF_UNSPEC' as a family for resolving\n-  either AF_INET6 or AF_INET. It works by accepting any of the looksups in the\n-  hosts file, and it resolves the AAAA field with a fallback to A.\n-\n-* January 14 2009 (Daniel Stenberg)\n-- ares.h no longer uses the HAVE_STRUCT_IN6_ADDR define check, but instead it\n-  now declares the private struct ares_in6_addr for all systems instead of\n-  relying on one possibly not present in the system.\n-\n-* January 13 2009 (Phil Blundell)\n-- ares__send_query() now varies the retry timeout pseudo-randomly to avoid\n-  packet storms when several queries were started at the same time.\n-\n-* January 11 2009 (Daniel Stenberg)\n-- Phil Blundell added the internal function ares__expand_name_for_response()\n-  that is now used by the ares_parse_*_reply() functions instead of the\n-  ares_expand_name() simply to easier return ARES_EBADRESP for the cases where\n-  the name expansion fails as in responses that really isn't expected.\n-\n-Version 1.6.0 (Dec 9, 2008)\n-\n-* December 9 2008 (Gisle Vanem)\n-\n-  Fixes for Win32 targets using the Watt-32 tcp/ip stack.\n-\n-* Dec 4 2008 (Daniel Stenberg)\n-\n-  Gregor Jasny provided the patch that introduces ares_set_socket_callback(),\n-  and I edited it to also get duped by ares_dup().\n-\n-* Dec 3 2008 (Daniel Stenberg)\n-\n-  API changes:\n-\n-  I made sure the public ares_config struct looks like before and yet it\n-  supports the ROTATE option thanks to c-ares now storing the \"optmask\"\n-  internally. Thus we should be ABI compatible with the past release(s)\n-  now. My efforts mentioned below should not break backwards ABI compliance.\n-\n-  Here's how I suggest we proceed with the API:\n-\n-  ares_init() will be primary \"channel creator\" function.\n-\n-  ares_init_options() will continue to work exactly like now and before. For\n-  starters, it will be the (only) way to set the existing options.\n-\n-  ares_save_options() will continue to work like today, but will ONLY save\n-  options that you can set today (including ARES_OPT_ROTATE actually) but new\n-  options that we add may not be saved with this.\n-\n-  Instead we introduce:\n-\n-  ares_dup() that instead can make a new channel and clone the config used\n-  from an existing channel. It will then clone all config options, including\n-  future new things we add.\n-\n-  ares_set_*() style functions that set (new) config options. As a start we\n-  simply add these for new functionality, but over time we can also introduce\n-  them for existing \"struct ares_options\" so that we can eventually deprecate\n-  the two ares_*_options() functions.\n-\n-  ares_get_*() style functions for extracting info from a channel handle that\n-  should be used instead of ares_save_options().\n-\n-* Nov 26 2008 (Yang Tse)\n-- Brad Spencer provided changes to allow buildconf to work on OS X.\n-\n-- Gerald Combs fixed a bug in ares_parse_ptr_reply() which would cause a\n-  buffer to shrink instead of expand if a reply contained 8 or more records.\n-\n-* Nov 25 2008 (Yang Tse)\n-- In preparation for the upcomming IPv6 nameservers patch, the internal\n-  ares_addr union is now changed into an internal struct which also holds\n-  the address family.\n-\n-* Nov 19 2008 (Daniel Stenberg)\n-- Brad Spencer brought the new function ares_gethostbyname_file() which simply\n-  resolves a host name from the given file, using the regular hosts syntax.\n-\n-* Nov 1 2008 (Daniel Stenberg)\n-- Carlo Contavalli added support for the glibc \"rotate\" option, as documented\n-  in man resolv.conf:\n-\n-  causes round robin selection of nameservers from among those listed.  This\n-  has the effect of spreading the query load among all listed servers, rather\n-  than having all clients try the first listed server first every time.\n-\n-  You can enable it with ARES_OPT_ROTATE\n-\n-* Oct 21 2008 (Yang Tse)\n-  Charles Hardin added handling of EINPROGRESS for UDP connects.\n-\n-* Oct 18 2008 (Daniel Stenberg)\n-  Charles Hardin made adig support a regular numerical dotted IP address for the\n-  -s option as well.\n-\n-* Oct 7 2008 (Yang Tse)\n-- Added --enable-optimize configure option to enable and disable compiler\n-  optimizations to allow decoupled setting from --enable-debug.\n-\n-* Oct 2 2008 (Yang Tse)\n-- Added --enable-warnings configure option to enable and disable strict\n-  compiler warnings to allow decoupled setting from --enable-debug.\n-\n-* Sep 17 2008 (Yang Tse)\n-- Code reorganization to allow internal/private use of \"nameser.h\" to any\n-  system that lacks arpa/nameser.h or arpa/nameser_compat.h header files.\n-\n-* Sep 16 2008 (Yang Tse)\n-- Code reorganization to allow internal/private use of ares_writev to any\n-  system that lacks the writev function.\n-\n-* Sep 15 2008 (Yang Tse)\n-- Code reorganization to allow internal/private use of ares_strcasecmp to any\n-  system that lacks the strcasecmp function.\n-\n-- Improve configure detection of some string functions.\n-\n-* Sep 11 2008 (Yang Tse)\n-- Code reorganization to allow internal/private use of ares_strdup to any\n-  system that lacks the strdup function.\n-\n-Version 1.5.3 (Aug 29, 2008)\n-\n-* Aug 25 2008 (Yang Tse)\n-- Improvement by Brad House:\n-\n-  This patch addresses an issue in which a response could be sent back to the\n-  source port of a client from a different address than the request was made to.\n-  This is one form of a DNS cache poisoning attack.\n-\n-  The patch simply uses recvfrom() rather than recv() and validates that the\n-  address returned from recvfrom() matches the address of the server we have\n-  connected to. Only necessary on UDP sockets as they are connection-less, TCP\n-  is unaffected.\n-\n-- Fix by George Neill:\n-  Fixed compilation of acountry sample application failure on some systems.\n-\n-* Aug 4 2008 (Daniel Stenberg)\n-- Fix by Tofu Linden:\n-\n-  The symptom:\n-  * Users (usually, but not always) on 2-Wire routers and the Comcast service\n-  and a wired connection to their router would find that the second and\n-  subsequent DNS lookups from fresh processes using c-ares to resolve the same\n-  address would cause the process to never see a reply (it keeps polling for\n-  around 1m15s before giving up).\n-\n-  The repro:\n-  * On such a machine (and yeah, it took us a lot of QA to find the systems\n-  that reproduce such a specific problem!), do 'ahost www.secondlife.com',\n-  then do it again.  The first process's lookup will work, subsequent lookups\n-  will time-out and fail.\n-\n-  The cause:\n-  * init_id_key() was calling randomize_key() *before* it initialized\n-  key->state, meaning that the randomness generated by randomize_key() is\n-  immediately overwritten with deterministic values. (/dev/urandom was also\n-  being read incorrectly in the c-ares version we were using, but this was\n-  fixed in a later version.)\n-  * This makes the stream of generated query-IDs from any new c-ares process\n-  be an identical and predictable sequence of IDs.\n-  * This makes the 2-Wire's default built-in DNS server detect these queries\n-  as probable-duplicates and (erroneously) not respond at all.\n-\n-\n-* Aug 4 2008 (Yang Tse)\n-- Autoconf 2.62 has changed the behaviour of the AC_AIX macro which we use.\n-  Prior versions of autoconf defined _ALL_SOURCE if _AIX was defined. 2.62\n-  version of AC_AIX defines _ALL_SOURCE and other four preprocessor symbols\n-  no matter if the system is AIX or not. To keep the traditional behaviour,\n-  and an uniform one across autoconf versions AC_AIX is replaced with our\n-  own internal macro CARES_CHECK_AIX_ALL_SOURCE.\n-\n-* Aug 1 2008 (Yang Tse)\n-- Configure process now checks if the preprocessor _REENTRANT symbol is already\n-  defined. If it isn't currently defined a set of checks are performed to test\n-  if its definition is required to make visible to the compiler a set of *_r\n-  functions. Finally, if _REENTRANT is already defined or needed it takes care\n-  of making adjustments necessary to ensure that it is defined equally for the\n-  configure process tests and generated config file.\n-\n-* Jul 20 2008 (Yang Tse)\n-- When recvfrom prototype uses a void pointer for arguments 2, 5 or 6 this will\n-  now cause the definition, as appropriate, of RECVFROM_TYPE_ARG2_IS_VOID,\n-  RECVFROM_TYPE_ARG5_IS_VOID or RECVFROM_TYPE_ARG6_IS_VOID.\n-\n-* Jul 17 2008 (Yang Tse)\n-- RECVFROM_TYPE_ARG2, RECVFROM_TYPE_ARG5 and RECVFROM_TYPE_ARG6 are now defined\n-  to the data type pointed by its respective argument and not the pointer type.\n-\n-* Jul 16 2008 (Yang Tse)\n-- Improved configure detection of number of arguments for getservbyport_r.\n-  Detection is now based on compilation checks instead of linker ones.\n-\n-- Configure process now checks availability of recvfrom() socket function and\n-  finds out its return type and the types of its arguments. Added definitions\n-  for non-configure systems config files, and introduced macro sreadfrom which\n-  will be used on udp sockets as a recvfrom() wrapper in the future.\n-\n-* Jul 15 2008 (Yang Tse)\n-- Introduce definition of _REENTRANT symbol in setup.h to improve library\n-  usability.  Previously the configure process only used the AC_SYS_LARGEFILE\n-  macro for debug builds, now it is also used for non-debug ones enabling the\n-  use of configure options --enable-largefile and --disable-largefile which\n-  might be needed for library compatibility.  Remove checking the size of\n-  curl_off_t, it is no longer needed.\n-\n-* Jul 3 2008 (Daniel Stenberg)\n-- Phil Blundell: If you ask ares_gethostbyname() to do an AF_INET6 lookup and\n-  the target host has only A records, it automatically falls back to an\n-  AF_INET lookup and gives you the A results.  However, if the target host has\n-  a CNAME record, this behaviour is defeated since the original query does\n-  return some data even though ares_parse_aaa_reply() doesn't consider it\n-  relevant. Here's a small patch to make it behave the same with and without\n-  the CNAME.\n-\n-* Jul 2 2008 (Yang Tse)\n-- Fallback to gettimeofday when monotonic clock is unavailable at run-time.\n-\n-* Jun 30 2008 (Daniel Stenberg)\n-\n-- As was pointed out to me by Andreas Schuldei, the MAXHOSTNAMELEN define is\n-  not posix or anything and thus c-ares failed to build on hurd (and possibly\n-  elsewhere). The define was also somewhat artificially used in the windows\n-  port. Now, I instead rewrote the use of gethostbyname to enlarge the host\n-  name buffer in case of need and totally avoid the use of the MAXHOSTNAMELEN\n-  define. I thus also removed the defien from the namser.h file where it was\n-  once added for the windows build.\n-\n-  I also fixed init_by_defaults() function to not leak memory in case if\n-  error.\n-\n-* Jun 9 2008 (Yang Tse)\n-\n-- Make libcares.pc generated file for pkg-config include information relative\n-  to the libraries needed for the static linking of c-ares.\n-\n-* May 30 2008 (Yang Tse)\n-\n-- Brad House fixed a missing header file inclusion in adig sample program.\n-\n-Version 1.5.2 (May 29, 2008)\n-\n-* May 13 2008 (Daniel Stenberg)\n-\n-- Introducing millisecond resolution support for the timeout option. See\n-  ares_init_options()'s ARES_OPT_TIMEOUTMS.\n-\n-* May 9 2008 (Yang Tse)\n-\n-- Use monotonic time source if available, for private function ares__tvnow()\n-\n-* May 7 2008 (Daniel Stenberg)\n-\n-- Sebastian made c-ares able to return all PTR-records when doing reverse\n-  lookups. It is not common practice to have multiple PTR-Records for a single\n-  IP, but its perfectly legal and some sites have those.\n-\n-- Doug Goldstein provided a configure patch: updates autoconf 2.13 usage to\n-  autoconf 2.57 usage (which is the version you have specified as the minimum\n-  version). It's a minor change but it does clean up some warnings with newer\n-  autoconf (specifically 2.62).\n-\n-* May 5 2008 (Yang Tse)\n-\n-- Improved parsing of resolver configuration files.\n-\n-* April 4 2008 (Daniel Stenberg)\n-\n-- Eino Tuominen improved the code when a file is used to seed the randomizer.\n-\n-- Alexey Simak made adig support NAPTR records\n-\n-- Alexey Simak fixed the VC dsp file by adding the missing source file\n-  ares_expand_string.c\n-\n-* December 11 2007 (Gisle Vanem)\n-\n-- Added another sample application; acountry.c which converts an\n-  IPv4-address(es) and/or host-name(s) to country-name and country-code.\n-  This uses the service of the DNSBL at countries.nerd.dk.\n-\n-* December 3 2007 (Daniel Stenberg)\n-\n-- Brad Spencer fixed the configure script to assume that there's no\n-  /dev/urandom when built cross-compiled as then the script cannot check for\n-  it.\n-\n-- Erik Kline cleaned up ares_gethostbyaddr.c:next_lookup() somewhat\n-\n-Version 1.5.1 (Nov 21, 2007)\n-\n-* November 21 2007 (Daniel Stenberg)\n-\n-- Robin Cornelius pointed out that ares_llist.h was missing in the release\n-  archive for 1.5.0\n-\n-Version 1.5.0 (Nov 21, 2007)\n-\n-* October 2 2007 (Daniel Stenberg)\n-\n-- ares_strerror() segfaulted if the input error number was out of the currently\n-  supported range.\n-\n-- Yang Tse: Avoid a segfault when generating a DNS \"Transaction ID\" in\n-  internal function init_id_key() under low memory conditions.\n-\n-* September 28 2007 (Daniel Stenberg)\n-\n-- Bumped version to 1.5.0 for next release and soname bumped to 2 due to ABI\n-  and API changes in the progress callback (and possibly more coming up from\n-  Steinar)\n-\n-* September 28 2007 (Steinar H. Gunderson)\n-\n-- Don't skip a server if it's the only one. (Bugfix from the Google tree.)\n-\n-- Made the query callbacks receive the number of timeouts that happened during\n-  the execution of a query, and updated documentation accordingly. (Patch from\n-  the Google tree.)\n-\n-- Support a few more socket options: ARES_OPT_SOCK_SNDBUF and\n-  ARES_OPT_SOCK_RCVBUF\n-\n-- Always register for TCP events even if there are no outstanding queries, as\n-  the other side could always close the connection, which is a valid event\n-  which should be responded to.\n-\n-* September 22 2007 (Daniel Stenberg)\n-\n-- Steinar H. Gunderson fixed: Correctly clear sockets from the fd_set on in\n-  several functions (write_tcp_data, read_tcp_data, read_udp_packets) so that\n-  if it fails and the socket is closed the following code doesn't try to use\n-  the file descriptor.\n-\n-- Steinar H. Gunderson modified c-ares to now also do to DNS retries even when\n-  TCP is used since there are several edge cases where it still makes sense.\n-\n-- Brad House provided a fix for ares_save_options():\n-\n-  Apparently I overlooked something with the ares_save_options() where it\n-  would try to do a malloc(0) when no options of that type needed to be saved.\n-  On most platforms, this was fine because malloc(0) doesn't actually return\n-  NULL, but on AIX it does, so ares_save_options would return ARES_ENOMEM.\n-\n-* July 14 2007 (Daniel Stenberg)\n-\n-- Vlad Dinulescu fixed two outstanding valgrind reports:\n-\n-  1. In ares_query.c , in find_query_by_id we compare q->qid (which is a short\n-  int variable) with qid, which is declared as an int variable.  Moreover,\n-  DNS_HEADER_SET_QID is used to set the value of qid, but DNS_HEADER_SET_QID\n-  sets only the first two bytes of qid. I think that qid should be declared as\n-  \"unsigned short\" in this function.\n-\n-  2. The same problem occurs in ares_process.c, process_answer() .  query->qid\n-  (an unsigned short integer variable) is compared with id, which is an\n-  integer variable. Moreover, id is initialized from DNS_HEADER_QID which sets\n-  only the first two bytes of id. I think that the id variable should be\n-  declared as \"unsigned short\" in this function.\n-\n-  Even after declaring these variables as \"unsigned short\", the valgrind\n-  errors are still there. Which brings us to the third problem.\n-\n-  3. The third problem is that Valgrind assumes that query->qid is not\n-  initialised correctly. And it does that because query->qid is set from\n-  DNS_HEADER_QID(qbuf); Valgrind says that qbuf has unitialised bytes. And\n-  qbuf has uninitialised bytes because of channel->next_id . And next_id is\n-  set by ares_init.c:ares__generate_new_id() . I found that putting short r=0\n-  in this function (instead of short r) makes all Valgrind warnings go away.\n-  I have studied ares__rc4() too, and this is the offending line:\n-\n-        buffer_ptr[counter] ^= state[xorIndex];   (ares_query.c:62)\n-\n-  This is what triggers Valgrind.. buffer_ptr is unitialised in this function,\n-  and by applying ^= on it, it remains unitialised.\n-\n-Version 1.4.0 (June 8, 2007)\n-\n-* June 4 2007 (Daniel Stenberg)\n-\n-- James Bursa reported a major memory problem when resolving multi-IP names\n-  and I found and fixed the problem. It was added by Ashish Sharma's patch\n-  two days ago.\n-\n-  When I then tried to verify multiple entries in /etc/hosts after my fix, I\n-  got another segfault and decided this code was not ripe for inclusion and I\n-  reverted the patch.\n-\n-* June 2 2007\n-\n-- Brad Spencer found and fixed three flaws in the code, found with the new\n-  gcc 4.2.0 warning: -Waddress\n-\n-- Brad House fixed VS2005 compiler warnings due to time_t being 64bit.\n-  He also made recent Microsoft compilers use _strdup() instead of strdup().\n-\n-- Brad House's man pages for ares_save_options() and ares_destroy_options()\n-  were added.\n-\n-- Ashish Sharma provided a patch for supporting multiple entries in the\n-  /etc/hosts file. Patch edited for coding style and functionality by me\n-  (Daniel).\n-\n-* May 30 2007\n-\n-- Shmulik Regev brought cryptographically secure transaction IDs:\n-\n-  The c-ares library implementation uses a DNS \"Transaction ID\" field that is\n-  seeded with a pseudo random number (based on gettimeofday) which is\n-  incremented (++) between consecutive calls and is therefore rather\n-  predictable. In general, predictability of DNS Transaction ID is a well\n-  known security problem (e.g.\n-  http://bak.spc.org/dms/archive/dns_id_attack.txt) and makes a c-ares based\n-  implementation vulnerable to DNS poisoning. Credit goes to Amit Klein\n-  (Trusteer) for identifying this problem.\n-\n-  The patch I wrote changes the implementation to use a more secure way of\n-  generating unique IDs. It starts by obtaining a key with reasonable entropy\n-  which is used with an RC4 stream to generate the cryptographically secure\n-  transaction IDs.\n-\n-  Note that the key generation code (in ares_init:randomize_key) has two\n-  versions, the Windows specific one uses a cryptographically safe function\n-  provided (but undocumented :) by the operating system (described at\n-  http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx).  The\n-  default implementation is a bit naive and uses the standard 'rand'\n-  function. Surely a better way to generate random keys exists for other\n-  platforms.\n-\n-  The patch can be tested by using the adig utility and using the '-s' option.\n-\n-- Brad House added ares_save_options() and ares_destroy_options() that can be\n-  used to keep options for later re-usal when ares_init_options() is used.\n-\n-  Problem: Calling ares_init() for each lookup can be unnecessarily resource\n-         intensive.  On windows, it must LoadLibrary() or search the registry\n-         on each call to ares_init().  On unix, it must read and parse\n-         multiple files to obtain the necessary configuration information.  In\n-         a single-threaded environment, it would make sense to only\n-         ares_init() once, but in a heavily multi-threaded environment, it is\n-         undesirable to ares_init() and ares_destroy() for each thread created\n-         and track that.\n-\n-  Solution: Create ares_save_options() and ares_destroy_options() functions to\n-         retrieve and free options obtained from an initialized channel.  The\n-         options populated can be used to pass back into ares_init_options(),\n-         it should populate all needed fields and not retrieve any information\n-         from the system.  Probably wise to destroy the cache every minute or\n-         so to prevent the data from becoming stale.\n-\n-- Daniel S added ares_process_fd() to allow applications to ask for processing\n-  on specific sockets and thus avoiding select() and associated\n-  functions/macros.  This function will be used by upcoming libcurl releases\n-  for this very reason. It also made me export the ares_socket_t type in the\n-  public ares.h header file, since ares_process_fd() uses that type for two of\n-  the arguments.\n-\n-* May 25 2007\n-\n-- Ravi Pratap fixed a flaw in the init_by_resolv_conf() function for windows\n-  that could cause it to return a bad return code.\n-\n-* April 16 2007\n-\n-- Yang Tse: Provide ares_getopt() command-line parser function as a source\n-  code helper function, not belonging to the actual c-ares library.\n-\n-* February 19 2007\n-\n-- Vlad Dinulescu added ares_parse_ns_reply().\n-\n-* February 13 2007\n-\n-- Yang Tse: Fix failure to get the search sequence of /etc/hosts and\n-  DNS from /etc/nsswitch.conf, /etc/host.conf or /etc/svc.conf when\n-  /etc/resolv.conf did not exist or was unable to read it.\n-\n-* November 22 2006\n-\n-- Install ares_dns.h too\n-\n-- Michael Wallner fixed this problem: When I set domains in the options\n-  struct, and there are domain/search entries in /etc/resolv.conf, the domains\n-  of the options struct will be overridden.\n-\n-* November 6 2006\n-\n-- Yang Tse removed a couple of potential zero size memory allocations.\n-\n-- Andreas Rieke fixed the line endings in the areslib.dsp file that I (Daniel)\n-  broke in the 1.3.2 release. We should switch to a system where that file is\n-  auto-generated. We could rip some code for that from curl...\n-\n-Version 1.3.2 (November 3, 2006)\n-\n-* October 12 2006\n-\n-- Prevent ares_getsock() to overflow if more than 16 sockets are used.\n-\n-* September 11 2006\n-\n-- Guilherme Balena Versiani: I noted a strange BUG in Win32 port\n-  (ares_init.c/get_iphlpapi_dns_info() function): when I disable the network\n-  by hand or disconnect the network cable in Windows 2000 or Windows XP, my\n-  application gets 127.0.0.1 as the only name server. The problem comes from\n-  'GetNetworkParams' function, that returns the empty string \"\" as the only\n-  name server in that case. Moreover, the Windows implementation of\n-  inet_addr() returns INADDR_LOOPBACK instead of INADDR_NONE.\n-\n-* August 29 2006\n-\n-- Brad Spencer did\n-\n-  o made ares_version.h use extern \"C\" for c++ compilers\n-  o fixed compiler warnings in ares_getnameinfo.c\n-  o fixed a buffer position init for TCP reads\n-\n-* August 3 2006\n-\n-- Ravi Pratap fixed ares_getsock() to actually return the proper bitmap and\n-  not always zero!\n-\n-Version 1.3.1 (June 24, 2006)\n-\n-* July 23, 2006\n-\n-- Gisle Vanem added getopt() to the ahost program. Currently accepts\n-  only [-t {a|aaaa}] to specify address family in ares_gethostbyname().\n-\n-* June 19, 2006\n-\n-- (wahern) Removed \"big endian\" DNS section and RR data integer parser\n-  macros from ares_dns.h, which break c-ares on my Sparc64. Bit-wise\n-  operations in C operate on logical values. And in any event the octets are\n-  already in big-endian (aka network) byte order so they're being reversed\n-  (thus the source of the breakage).\n-\n-* June 18, 2006\n-\n-- William Ahern handles EAGAIN/EWOULDBLOCK errors in most of the I/O calls\n-  from area_process.c.\n-\n-  TODO: Handle one last EAGAIN for a UDP socket send(2) in\n-  ares__send_query().\n-\n-* May 10, 2006\n-\n-- Bram Matthys brought my attention to a libtool peculiarity where detecting\n-  things such as C++ compiler actually is a bad thing and since we don't need\n-  that detection I added a work-around, much inspired by a previous patch by\n-  Paolo Bonzini. This also shortens the configure script quite a lot.\n-\n-* May 3, 2006\n-\n-- Nick Mathewson added the ARES_OPT_SOCK_STATE_CB option that when set makes\n-  c-ares call a callback on socket state changes. A better way than the\n-  ares_getsock() to get full control over the socket state.\n-\n-* January 9, 2006\n-\n-- Alexander Lazic improved the getservbyport_r() configure check.\n-\n-* January 6, 2006\n-\n-- Alexander Lazic pointed out that the buildconf should use the ACLOCAL_FLAGS\n-  variable for easier controlling what it does and how it runs.\n-\n-* January 5, 2006\n-\n-- James Bursa fixed c-ares to find the hosts file on RISC OS, and made it\n-  build with newer gcc versions that no longer defines \"riscos\".\n-\n-* December 22\n-\n-- Daniel Stenberg added ares_getsock() that extracts the set of sockets to\n-  wait for action on. Similar to ares_fds() but not restricted to using\n-  select() for the waiting.\n-\n-* November 25\n-\n-- Yang Tse fixed some send() / recv() compiler warnings\n-\n-* September 18\n-\n-- Added constants that will be used by ares_getaddrinfo\n-\n-- Made ares_getnameinfo use the reentrant getservbyport (getservbyport_r) if it\n-  is available to ensure it works properly in a threaded environment.\n-\n-* September 10\n-\n-- configure fix for detecting a member in the sockaddr_in6 struct which failed\n-  on ipv6-enabled HP-UX 11.00\n-\n-Version 1.3.0 (August 29, 2005)\n-\n-* August 21\n-\n-- Alfredo Tupone provided a fix for the Windows code in get_iphlpapi_dns_info()\n-  when getting the DNS server etc.\n-\n-* June 19\n-\n-- Added some checks for the addrinfo structure.\n-\n-* June 2\n-\n-- William Ahern:\n-\n-  Make UDP sockets non-blocking. I've confirmed that at least on Linux 2.4 a\n-  read event can come back from poll() on a valid SOCK_DGRAM socket but\n-  recv(2) will still block. This patch doesn't ignore EAGAIN in\n-  read_udp_packets(), though maybe it should. (This patch was edited by Daniel\n-  Stenberg and a new configure test was added (imported from curl's configure)\n-  to properly detect what non-blocking socket approach to use.)\n-\n-  I'm not quite sure how this was happening, but I've been seeing PTR queries\n-  which seem to return empty responses. At least, they were empty when calling\n-  ares_expand_name() on the record. Here's a patch which guarantees to\n-  NUL-terminate the expanded name. The old behavior failed to NUL-terminate if\n-  len was 0, and this was causing strlen() to run past the end of the buffer\n-  after calling ares_expand_name() and getting ARES_SUCCESS as the return\n-  value. If q is not greater than *s then it's equal and *s is always\n-  allocated with at least one byte.\n-\n-* May 16\n-\n-- Added ares_getnameinfo which mimics the getnameinfo API (another feature\n-  that could use testing).\n-\n-* May 14\n-\n-- Added an inet_ntop function from BIND for systems that do not have it.\n-\n-* April 9\n-\n-- Made sortlist support IPv6 (this can probably use some testing).\n-\n-- Made sortlist support CIDR matching for IPv4.\n-\n-* April 8\n-\n-- Added preliminary IPv6 support to ares_gethostbyname. Currently, sortlist\n-  does not work with IPv6. Also provided an implementation of bitncmp from\n-  BIND for systems that do not supply this function. This will be used to add\n-  IPv6 support to sortlist.\n-\n-- Made ares_gethostbyaddr support IPv6 by specifying AF_INET6 as the family.\n-  The function can lookup IPv6 addresses both from files (/etc/hosts) and\n-  DNS lookups.\n-\n-* April 7\n-\n-- Tupone Alfredo fixed includes of arpa/nameser_compat.h to build fine on Mac\n-  OS X.\n-\n-* April 5\n-\n-- Dominick Meglio: Provided implementations of inet_net_pton and inet_pton\n-  from BIND for systems that do not include these functions.\n-\n-* March 11, 2005\n-\n-- Dominick Meglio added ares_parse_aaaa_reply.c and did various\n-  adjustments. The first little steps towards IPv6 support!\n-\n-* November 7\n-\n-- Fixed the VC project and makefile to use ares_cancel and ares_version\n-\n-* October 24\n-\n-- The released ares_version.h from 1.2.1 says 1.2.0 due to a maketgz flaw.\n-  This is now fixed.\n-\n-Version 1.2.1 (October 20, 2004)\n-\n-* September 29\n-\n-- Henrik Stoerner fix: got a report that Tru64 Unix (the unix from Digital\n-  when they made Alpha's) uses /etc/svc.conf for the purpose fixed below for\n-  other OSes. He made c-ares check for and understand it if present.\n-\n-- Now c-ares will use local host name lookup _before_ DNS resolving by default\n-  if nothing else is told.\n-\n-* September 26\n-\n-- Henrik Stoerner: found out that c-ares does not look at the /etc/host.conf\n-  file to determine the sequence in which to search /etc/hosts and DNS.  So on\n-  systems where this order is defined by /etc/host.conf instead of a \"lookup\"\n-  entry in /etc/resolv.conf, c-ares will always default to looking in DNS\n-  first, and /etc/hosts second.\n-\n-  c-ares now looks at\n-\n-  1) resolv.conf (for the \"lookup\" line);\n-  2) nsswitch.fon (for the \"hosts:\" line);\n-  3) host.conf (for the \"order\" line).\n-\n-  First match wins.\n-\n-- Dominick Meglio patched: C-ares on Windows assumed that the HOSTS file is\n-  located in a static location. It assumed\n-  C:\\Windows\\System32\\Drivers\\Etc. This is a poor assumption to make. In fact,\n-  the location of the HOSTS file can be changed via a registry setting.\n-\n-  There is a key called DatabasePath which specifies the path to the HOSTS\n-  file:\n-  http://www.microsoft.com/technet/itsolutions/network/deploy/depovg/tcpip2k.mspx\n-\n-  The patch will make c-ares correctly consult the registry for the location\n-  of this file.\n-\n-* August 29\n-\n-- Gisle Vanem fixed the MSVC build files.\n-\n-* August 20\n-\n-- Gisle Vanem made c-ares build and work with his Watt-32 TCP/IP stack.\n-\n-* August 13\n-\n-- Harshal Pradhan made a minor syntax change in ares_init.c to make it build\n-  fine with MSVC 7.1\n-\n-* July 24\n-\n-- Made the lib get built static only if --enable-debug is used.\n-\n-- Gisle Vanem fixed:\n-\n-  Basically in loops like handle_errors(), 'query->next' was assigned a local\n-  variable and then query was referenced after the memory was freed by\n-  next_server(). I've changed that so next_server() and end_query() returns\n-  the next query. So callers should use this ret-value.\n-\n-  The next problem was that 'server->tcp_buffer_pos' had a random value at\n-  entry to 1st recv() (luckily causing Winsock to return ENOBUFS).\n-\n-  I've also added a ares_writev() for Windows to streamline the code a bit\n-  more.\n-\n-* July 20\n-- Fixed a few variable return types for some system calls. Made configure\n-  check for ssize_t to make it possible to use that when receiving the send()\n-  error code. This is necessary to prevent compiler warnings on some systems.\n-\n-- Made configure create config.h, and all source files now include setup.h that\n-  might include the proper config.h (or a handicrafted alternative).\n-\n-- Switched to 'ares_socket_t' type for sockets in ares, since Windows don't\n-  use 'int' for that.\n-\n-- automake-ified and libool-ified c-ares. Now it builds libcares as a shared\n-  lib on most platforms if wanted. (This bloated the size of the release\n-  archive with another 200K!)\n-\n-- Makefile.am now uses Makefile.inc for the c sources, h headers and man\n-  pages, to make it easier for other makefiles to use the exact same set of\n-  files.\n-\n-- Adjusted 'maketgz' to use the new automake magic when building distribution\n-  archives.\n-\n-- Anyone desires HTML and/or PDF versions of the man pages in the release\n-  archives?\n-\n-* July 3\n-- G\ufffdnter Knauf made c-ares build and run on Novell Netware.\n-\n-* July 1\n-- Gisle Vanem provided Makefile.dj to build with djgpp, added a few more djgpp\n-  fixes and made ares not use 'errno' to provide further info on Windows.\n-\n-* June 30\n-- Gisle Vanem made it build with djgpp and run fine with the Watt-32 stack.\n-\n-* June 10\n-- Gisle Vanem's init patch for Windows:\n-\n-  The init_by_resolv_conf() function fetches the DNS-server(s)\n-  from a series of registry branches.\n-\n-  This can be wrong in the case where DHCP has assigned nameservers, but the\n-  user has overridden these servers with other prefered settings. Then it's\n-  wrong to use the DHCPNAMESERVER setting in registry.\n-\n-  In the case of no global DHCP-assigned or fixed servers, but DNS server(s)\n-  per adapter, one has to query the adapter branches.  But how can c-ares know\n-  which adapter is valid for use? AFAICS it can't. There could be one adapter\n-  that is down (e.g. a VPN adapter).\n-\n-  So it's better to leave this to the IP Helper API (iphlapi) available in\n-  Win-98/2000 and later. My patch falls-back to the old way if not available.\n-\n-* June 8\n-- James Bursa fixed an init issue for RISC OS.\n-\n-* May 11\n-- Nico Stappenbelt reported that when processing domain and search lines in\n-  the resolv.conf file, the first entry encountered is processed and used as\n-  the search list. According to the manual pages for both Linux, Solaris and\n-  Tru64, the last entry of either a domain or a search field is used.\n-\n-  This is now adjusted in the code\n-\n-Version 1.2.0 (April 13, 2004)\n-\n-* April 2, 2004\n-- Updated various man pages to look nicer when converted to HTML on the web\n-  site.\n-\n-* April 1, 2004\n-- Dirk Manske provided a new function that is now named ares_cancel(). It is\n-  used to cancel/cleanup a resolve/request made using ares functions on the\n-  given ares channel. It does not destroy/kill the ares channel itself.\n-\n-- Dominick Meglio cleaned up the formatting in several man pages.\n-\n-* March 30, 2004\n-- Dominick Meglio's new ares_expand_string. A helper function when decoding\n-  incoming DNS packages.\n-\n-- Daniel Stenberg modified the Makefile.in to use a for loop for the man page\n-  installation to improve overview and make it easier to add man pages.\n-\n-Version 1.1.0 (March 11, 2004)\n-\n-* March 9, 2004\n-- Gisle Vanem improved build on Windows.\n-\n-* February 25, 2004\n-- Dan Fandrich found a flaw in the Feb 22 fix.\n-\n-- Added better configure --enable-debug logic (taken from the curl configure\n-  script). Added acinclude.m4 to the tarball.\n-\n-* February 23, 2004\n-- Removed ares_free_errmem(), the function, the file and the man page. It was\n-  not used and it did nothing.\n-\n-- Fixed a lot of code that wasn't \"64bit clean\" and thus caused a lot of\n-  compiler warnings on picky compilers.\n-\n-* February 22, 2004\n-- Dominick Meglio made ares init support multiple name servers in the\n-  NameServer key on Windows.\n-\n-* February 16, 2004\n-- Modified ares_private.h to include libcurl's memory debug header if\n-  CURLDEBUG is set. This makes all the ares-functions supervised properly by\n-  the curl test suite. This also forced me to add inclusion of the\n-  ares_private.h header in a few more files that are using some kind of\n-  memory-related resources.\n-\n-- Made the makefile only build ahost and adig if 'make demos' is used.\n-\n-* February 10, 2004\n-- Dirk Manske made ares_version.h installed with 'make install'\n-\n-* February 4, 2004\n-- ares_free_errmem() is subject for removal, it is simply present for future\n-  purposes, and since we removed the extra parameter in strerror() it won't\n-  be used by c-ares!\n-- configure --enable-debug now enables picky compiler options if gcc is used\n-- fixed several compiler warnings --enable-debug showed and Joerg Mueller-Tolk\n-  reported\n-\n-Version 1.0.0 (February 3, 2004)\n-\n-* February 3, 2004\n-- now we produce the libcares.a library instead of the previous libares.a\n-  since we are no longer compatible\n-\n-* February 2, 2004\n-\n-- ares_strerror() has one argument less. This is the first official\n-  modification of the existing provided ares API.\n-\n-* January 29, 2004\n-\n-- Dirk Manske fixed how the socket is set non-blocking.\n-\n-* January 4, 2004\n-\n-- Dominick Meglio made the private gettimeofday() become ares_gettimeofday()\n-  instead in order to not pollute the name space and risk colliding with\n-  other libraries' versions of this function.\n-\n-* October 24, 2003. Daniel Stenberg\n-\n-  Added ares_version().\n-\n-Version 1.0-pre1 (8 October 2003)\n-\n-- James Bursa made it run on RISC OS\n-\n-- Dominick Meglio made it run fine on NT4\n-\n-- Duncan Wilcox made it work fine on Mac OS X\n-\n-- Daniel Stenberg adjusted the windows port\n-\n-- liren at vivisimo.com made the initial windows port\n-\n-* Imported the sources from ares 1.1.1"}, {"sha": "7bbb95b879cea72095854c0bd50291587a3e121c", "filename": "src/rt/libuv/src/ares/CMakeLists.txt", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FCMakeLists.txt?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,22 +0,0 @@\n-include_directories(${CMAKE_CURRENT_SOURCE_DIR})\n-include_directories(${node_platform}-${cares_arch})\n-add_definitions(-DHAVE_CONFIG_H=1)\n-\n-include(CheckLibraryExists)\n-check_library_exists(socket socket \"\" HAVE_SOCKET_LIB)\n-check_library_exists(nsl gethostbyname \"\" HAVE_NSL_LIB)\n-\n-file(GLOB lib_sources *.c)\n-add_library(cares ${lib_sources})\n-\n-if(${HAVE_SOCKET_LIB})\n-  set(cares_libs ${cares_libs} socket)\n-endif()\n-\n-if(${HAVE_NSL_LIB})\n-  set(cares_libs ${cares_libs} nsl)\n-endif()\n-\n-if(cares_libs)\n-  target_link_libraries(cares ${cares_libs})\n-endif()"}, {"sha": "95a2eeea2742b06a2e8645634509c27326b4ee07", "filename": "src/rt/libuv/src/ares/NEWS", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FNEWS?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,21 +0,0 @@\n-Major changes since:\n-* see the CHANGES file\n-\n-Major changes in release 1.1.1:\n-* ares should now compile as C++ code (no longer uses reserved word\n-  \"class\").\n-* Added SRV support to adig test program.\n-* Fixed a few error handling bugs in query processing.\n-\n-Major changes in release 1.1.0:\n-* Added ares_free_string() function so that memory can be freed in the\n-  same layer as it is allocated, a desirable feature in some\n-  environments.\n-* A few of the ares_dns.h macros are fixed to use the proper bitwise\n-  operator.\n-* Fixed a couple of fenceposts fixed in ares_expand_name()'s\n-  bounds-checking.\n-* In process_timeouts(), extract query->next before calling\n-  next_server() and possibly freeing the query structure.\n-* Casted arguments to ctype macros casted to unsigned char, since not\n-  all char values are valid inputs to those macros according to ANSI."}, {"sha": "56a43c53a74b4b826ef807634ddaa3e21eee3bb6", "filename": "src/rt/libuv/src/ares/README", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,60 +0,0 @@\n-c-ares\n-======\n-\n-This is c-ares, an asynchronous resolver library.  It is intended for\n-applications which need to perform DNS queries without blocking, or need to\n-perform multiple DNS queries in parallel.  The primary examples of such\n-applications are servers which communicate with multiple clients and programs\n-with graphical user interfaces.\n-\n-The full source code is available in the 'c-ares' release archives, and in a\n-git repository: http://github.com/bagder/c-ares\n-\n-If you find bugs, correct flaws, have questions or have comments in general in\n-regard to c-ares (or by all means the original ares too), get in touch with us\n-on the c-ares mailing list: http://cool.haxx.se/mailman/listinfo/c-ares\n-\n-c-ares is of course distributed under the same MIT-style license as the\n-original ares.\n-\n-You'll find all c-ares details and news here:\n-\n-        http://c-ares.haxx.se/\n-\n-\n-NOTES FOR C-ARES HACKERS\n-\n-The following notes apply to c-ares version 1.7.0 and later.\n-\n-* The distributed ares_build.h file is only intended to be used on systems\n-  which can not run the also distributed configure script.\n-\n-* The distributed ares_build.h file is generated as a copy of ares_build.h.dist\n-  when the c-ares source code distribution archive file is originally created.\n-\n-* If you check out from git on a non-configure platform, you must run the\n-  appropriate buildconf* script to set up ares_build.h and other local files\n-  before being able of compiling the library.\n-\n-* On systems capable of running the configure script, the configure process\n-  will overwrite the distributed ares_build.h file with one that is suitable\n-  and specific to the library being configured and built, this new file is\n-  generated from the ares_build.h.in template file.\n-\n-* If you intend to distribute an already compiled c-ares library you _MUST_\n-  also distribute along with it the generated ares_build.h which has been\n-  used to compile it. Otherwise the library will be of no use for the users of\n-  the library that you have built. It is _your_ responsibility to provide this\n-  file. No one at the c-ares project can know how you have built the library.\n-\n-* File ares_build.h includes platform and configuration dependent info,\n-  and must not be modified by anyone. Configure script generates it for you.\n-\n-* We cannot assume anything else but very basic compiler features being\n-  present. While c-ares requires an ANSI C compiler to build, some of the\n-  earlier ANSI compilers clearly can't deal with some preprocessor operators.\n-\n-* Newlines must remain unix-style for older compilers' sake.\n-\n-* Comments must be written in the old-style /* unnested C-fashion */\n-"}, {"sha": "aca54c8cd1fc77e7259609bb0a2c75ed8414c75b", "filename": "src/rt/libuv/src/ares/README.cares", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.cares?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,13 +0,0 @@\n-c-ares\n-======\n-\n-This package is based on ares 1.1.1 (written by Greg Hudson). I decided to\n-fork and release a separate project since the ares author didn't want the\n-improvements that were vital for our use of it.\n-\n-This package is dubbed 'c-ares' since I (Daniel Stenberg) wanted this for use\n-within the curl project (hence the letter C) and it makes a nice pun. Also,\n-c-ares is not API compatible with ares: a new name makes that more obvious to\n-the public.\n-\n-The original libares was distributed at athena-dist.mit.edu:pub/ATHENA/ares."}, {"sha": "4ff8700cb89a107dd6ce65fbac5777c424cb1070", "filename": "src/rt/libuv/src/ares/README.msvc", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.msvc?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,142 +0,0 @@\n-\n-\n-                          ___       __ _ _ __ ___  ___ \n-                         / __| ___ / _` | '__/ _ \\/ __|\n-                        | (_  |___| (_| | | |  __/\\__ \\\n-                         \\___|     \\__,_|_|  \\___||___/\n-\n-\n-                How to build c-ares using MSVC or Visual Studio\n-               =================================================\n-\n-\n-\n-  How to build using MSVC from the command line\n-  ---------------------------------------------\n-\n-  Open a command prompt window and ensure that the environment is properly\n-  set up in order to use MSVC or Visual Studio compiler tools.\n-\n-  Change to c-ares source folder where Makefile.msvc file is located and run:\n-\n-  > nmake -f Makefile.msvc\n-\n-  This will build all c-ares libraries as well as three sample programs.\n-\n-  Once the above command has finished a new folder named MSVCXX will exist\n-  below the folder where makefile.msvc is found. The name of the folder\n-  depends on the MSVC compiler version being used to build c-ares.\n-\n-  Below the MSVCXX folder there will exist four folders named 'cares',\n-  'ahost', 'acountry', and 'adig'. The 'cares' folder is the one that\n-  holds the c-ares libraries you have just generated, the other three\n-  hold sample programs that use the libraries.\n-\n-  The above command builds four versions of the c-ares library, dynamic\n-  and static versions and each one in release and debug flavours. Each\n-  of these is found in folders named dll-release, dll-debug, lib-release,\n-  and lib-debug, which hang from the 'cares' folder mentioned above. Each\n-  sample program also has folders with the same names to reflect which\n-  library version it is using.\n-\n-\n-  How to install using MSVC from the command line\n-  -----------------------------------------------\n-\n-  In order to allow easy usage of c-ares libraries it may be convenient to\n-  install c-ares libraries and header files to a common subdirectory tree.\n-\n-  Once that c-ares libraries have been built using procedure described above,\n-  use same command prompt window to define environment variable INSTALL_DIR\n-  to designate the top subdirectory where installation of c-ares libraries and\n-  header files will be done.\n-\n-  > set INSTALL_DIR=c:\\c-ares\n-\n-  Afterwards, run following command to actually perform the installation:\n-\n-  > nmake -f Makefile.msvc install\n-\n-  Installation procedure will copy c-ares libraries to subdirectory 'lib' and\n-  c-ares header files to subdirectory 'include' below the INSTALL_DIR subdir.\n-\n-  When environment variable INSTALL_DIR is not defined, installation is done\n-  to c-ares source folder where Makefile.msvc file is located.\n-\n-\n-  How to build using Visual Studio 6 IDE\n-  --------------------------------------\n-\n-  A VC++ 6.0 reference workspace (vc6aws.dsw) is available within the 'vc'\n-  folder to allow proper building of the library and sample programs.\n-\n-  1) Open the vc6aws.dsw workspace with MSVC6's IDE.\n-  2) Select 'Build' from top menu.\n-  3) Select 'Batch Build' from dropdown menu.\n-  4) Make sure that the sixteen project configurations are 'checked'.\n-  5) Click on the 'Build' button.\n-  6) Once the sixteen project configurations are built you are done.\n-\n-  Dynamic and static c-ares libraries are built in debug and release flavours,\n-  and can be located each one in its own subdirectory, dll-debug, dll-release,\n-  lib-debug and lib-release, all of them below the 'vc\\cares' subdirectory.\n-\n-  In the same way four executable versions of each sample program are built,\n-  each using its respective library. The resulting sample executables are\n-  located in its own subdirectory, dll-debug, dll-release, lib-debug and\n-  lib-release, below the 'vc\\acountry', 'vc\\adig' and 'vc\\ahost'folders.\n-\n-  These reference VC++ 6.0 configurations are generated using the dynamic CRT.\n-\n-\n-  How to build using Visual Studio 2003 or newer IDE\n-  --------------------------------------------------\n-\n-  First you have to convert the VC++ 6.0 reference workspace and project files\n-  to the Visual Studio IDE version you are using, following next steps:\n-\n-  1) Open vc\\vc6aws.dsw with VS20XX.\n-  2) Allow VS20XX to update all projects and workspaces.\n-  3) Save ALL and close VS20XX.\n-  4) Open vc\\vc6aws.sln with VS20XX.\n-  5) Select batch build, check 'all' projects and click 'build' button.\n-\n-  Same comments relative to generated files and folders as done above for\n-  Visual Studio 6 IDE apply here.\n-\n-\n-  Relationship between c-ares library file names and versions\n-  -----------------------------------------------------------\n-\n-  c-ares static release library version files:\n-\n-      libcares.lib -> static release library\n-\n-  c-ares static debug library version files:\n-\n-      libcaresd.lib -> static debug library\n-\n-  c-ares dynamic release library version files:\n-\n-      cares.dll -> dynamic release library\n-      cares.lib -> import library for the dynamic release library\n-      cares.exp -> export file for the dynamic release library\n-\n-  c-ares dynamic debug library version files:\n-\n-      caresd.dll -> dynamic debug library\n-      caresd.lib -> import library for the dynamic debug library\n-      caresd.exp -> export file for the dynamic debug library\n-      caresd.pdb -> debug symbol file for the dynamic debug library\n-\n-\n-  How to use c-ares static libraries\n-  ----------------------------------\n-\n-  When using the c-ares static library in your program, you will have to\n-  define preprocessor symbol CARES_STATICLIB while building your program,\n-  otherwise you will get errors at linkage stage.\n-\n-\n-Have Fun!\n- "}, {"sha": "17503096fdd636b6c01b9a8d364812bf0c697bff", "filename": "src/rt/libuv/src/ares/README.node", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FREADME.node?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,21 +0,0 @@\n-Library: c-ares, DNS resolver\n-\n-Version: 1.7.3 (11 June, 2010)\n-\n-Authors: Greg Hudson, Daniel Stenberg\n-\n-License: MIT\n-\n-Notes:\n-\n-Just use waf instead of the autoconf based configure script. Delete most of\n-the documentation and other files distributed with it. To upgrade, run\n-./configure on linux, macintosh, solaris (and other supported platforms) and\n-copy\n-- ares_config.h\n-- ares_setup.h\n-- ares_build.h\n-into the appropriate directory.\n-\n-\n-"}, {"sha": "06d7856bc74d15d73c1a7bd779ec9eaeaff4fbcd", "filename": "src/rt/libuv/src/ares/RELEASE-NOTES", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FRELEASE-NOTES?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,26 +0,0 @@\n-c-ares version 1.7.5\n-\n-Fixed:\n-\n- o detection of semicolon comments in resolv.conf\n- o avoid using system's inet_net_pton affected by the WLB-2008080064 advisory\n- o replacement ares_inet_net_pton affected by the WLB-2008080064 advisory\n- o replacement ares_inet_ntop affected by potential out of bounds write\n- o added install target to Makefile.msvc\n- o only fall back to AF_INET searches when looking for AF_UNSPEC addresses\n- o fixed ares_parse_*_reply memory leaks\n- o Use correct sizeof in ares_getnameinfo()\n- o IPv6-on-windows: find DNS servers correctly\n- o man pages: docs for the c-ares utility programs\n- o getservbyport replacement for Win CE\n- o config_sortlist: (win32) missing else\n- o advance_tcp_send_queue: avoid NULL ptr dereference\n- o configure: fix a bashism\n- o ares_expand_name: Fix encoded length for indirect root\n-\n-Thanks go to these friendly people for their efforts and contributions:\n-\n- Yang Tse, Jakub Hrozek, Gisle Vanem, Tom Hughes, David Stuart, Dima Tisnek,\n- Peter Pentchev, Stefan Buhler\n-\n-Have fun!"}, {"sha": "fa31cea6fb79b42edda1a4dd4ab9745fb783c237", "filename": "src/rt/libuv/src/ares/TODO", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2FTODO?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,23 +0,0 @@\n-TODO\n-====\n-\n-ares_reinit()\n-\n-- To allow an app to force a re-read of /etc/resolv.conf etc, pretty much\n-  like the res_init() resolver function offers\n-\n-ares_gethostbyname\n-\n-- When built to support IPv6, it needs to also support PF_UNSPEC or similar,\n-  so that an application can ask for any protocol and then c-ares would return\n-  all known resolves and not just explicitly IPv4 _or_ IPv6 resolves.\n-\n-ares_process\n-\n-- Upon next ABI breakage ares_process() should be changed to return 'int'\n-  and return ARES_ENOTINITIALIZED if ares_library_init() has not been called.\n-\n-ares_process_fd\n-\n-- Upon next ABI breakage ares_process_fd() should be changed to return\n-  'int' and return ARES_ENOTINITIALIZED if library has not been initialized."}, {"sha": "5d391a9ef2ec7fb4c6eb6ec11aa459d56393eebb", "filename": "src/rt/libuv/src/ares/ares__close_sockets.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__close_sockets.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,66 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#include <stdlib.h>\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-void ares__close_sockets(ares_channel channel, struct server_state *server)\n-{\n-  struct send_request *sendreq;\n-\n-  /* Free all pending output buffers. */\n-  while (server->qhead)\n-    {\n-      /* Advance server->qhead; pull out query as we go. */\n-      sendreq = server->qhead;\n-      server->qhead = sendreq->next;\n-      if (sendreq->data_storage != NULL)\n-        free(sendreq->data_storage);\n-      free(sendreq);\n-    }\n-  server->qtail = NULL;\n-\n-  /* Reset any existing input buffer. */\n-  if (server->tcp_buffer)\n-    free(server->tcp_buffer);\n-  server->tcp_buffer = NULL;\n-  server->tcp_lenbuf_pos = 0;\n-\n-  /* Reset brokenness */\n-  server->is_broken = 0;\n-\n-  /* Close the TCP and UDP sockets. */\n-  if (server->tcp_socket != ARES_SOCKET_BAD)\n-    {\n-      SOCK_STATE_CALLBACK(channel, server->tcp_socket, 0, 0);\n-      sclose(server->tcp_socket);\n-      server->tcp_socket = ARES_SOCKET_BAD;\n-      server->tcp_connection_generation = ++channel->tcp_connection_generation;\n-    }\n-  if (server->udp_socket != ARES_SOCKET_BAD)\n-    {\n-      SOCK_STATE_CALLBACK(channel, server->udp_socket, 0, 0);\n-      sclose(server->udp_socket);\n-      server->udp_socket = ARES_SOCKET_BAD;\n-    }\n-}"}, {"sha": "298df09182a63c7b4ae9ed5fc78e5cebf6cb996f", "filename": "src/rt/libuv/src/ares/ares__get_hostent.c", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__get_hostent.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,263 +0,0 @@\n-\n-/* Copyright 1998, 2010 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"inet_net_pton.h\"\n-#include \"ares_private.h\"\n-\n-int ares__get_hostent(FILE *fp, int family, struct hostent **host)\n-{\n-  char *line = NULL, *p, *q, **alias;\n-  char *txtaddr, *txthost, *txtalias;\n-  int status;\n-  size_t addrlen, linesize, naliases;\n-  struct ares_addr addr;\n-  struct hostent *hostent = NULL;\n-\n-  *host = NULL; /* Assume failure */\n-\n-  /* Validate family */\n-  switch (family) {\n-    case AF_INET:\n-    case AF_INET6:\n-    case AF_UNSPEC:\n-      break;\n-    default:\n-      return ARES_EBADFAMILY;\n-  }\n-\n-  while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n-    {\n-\n-      /* Trim line comment. */\n-      p = line;\n-      while (*p && (*p != '#'))\n-        p++;\n-      *p = '\\0';\n-\n-      /* Trim trailing whitespace. */\n-      q = p - 1;\n-      while ((q >= line) && ISSPACE(*q))\n-        q--;\n-      *++q = '\\0';\n-\n-      /* Skip leading whitespace. */\n-      p = line;\n-      while (*p && ISSPACE(*p))\n-        p++;\n-      if (!*p)\n-        /* Ignore line if empty. */\n-        continue;\n-\n-      /* Pointer to start of IPv4 or IPv6 address part. */\n-      txtaddr = p;\n-\n-      /* Advance past address part. */\n-      while (*p && !ISSPACE(*p))\n-        p++;\n-      if (!*p)\n-        /* Ignore line if reached end of line. */\n-        continue;\n-\n-      /* Null terminate address part. */\n-      *p = '\\0';\n-\n-      /* Advance to host name */\n-      p++;\n-      while (*p && ISSPACE(*p))\n-        p++;\n-      if (!*p)\n-        /* Ignore line if reached end of line. */\n-        continue;\n-\n-      /* Pointer to start of host name. */\n-      txthost = p;\n-\n-      /* Advance past host name. */\n-      while (*p && !ISSPACE(*p))\n-        p++;\n-\n-      /* Pointer to start of first alias. */\n-      txtalias = NULL;\n-      if (*p)\n-        {\n-          q = p + 1;\n-          while (*q && ISSPACE(*q))\n-            q++;\n-          if (*q)\n-            txtalias = q;\n-        }\n-\n-      /* Null terminate host name. */\n-      *p = '\\0';\n-\n-      /* find out number of aliases. */\n-      naliases = 0;\n-      if (txtalias)\n-        {\n-          p = txtalias;\n-          while (*p)\n-            {\n-              while (*p && !ISSPACE(*p))\n-                p++;\n-              while (*p && ISSPACE(*p))\n-                p++;\n-              naliases++;\n-            }\n-        }\n-\n-      /* Convert address string to network address for the requested family. */\n-      addrlen = 0;\n-      addr.family = AF_UNSPEC;\n-      addr.addrV4.s_addr = INADDR_NONE;\n-      if ((family == AF_INET) || (family == AF_UNSPEC))\n-        {\n-          addr.addrV4.s_addr = inet_addr(txtaddr);\n-          if (addr.addrV4.s_addr != INADDR_NONE)\n-            {\n-              /* Actual network address family and length. */\n-              addr.family = AF_INET;\n-              addrlen = sizeof(addr.addrV4);\n-            }\n-        }\n-      if ((family == AF_INET6) || ((family == AF_UNSPEC) && (!addrlen)))\n-        {\n-          if (ares_inet_pton(AF_INET6, txtaddr, &addr.addrV6) > 0)\n-            {\n-              /* Actual network address family and length. */\n-              addr.family = AF_INET6;\n-              addrlen = sizeof(addr.addrV6);\n-            }\n-        }\n-      if (!addrlen)\n-        /* Ignore line if invalid address string for the requested family. */\n-        continue;\n-\n-      /*\n-      ** Actual address family possible values are AF_INET and AF_INET6 only.\n-      */\n-\n-      /* Allocate memory for the hostent structure. */\n-      hostent = malloc(sizeof(struct hostent));\n-      if (!hostent)\n-        break;\n-\n-      /* Initialize fields for out of memory condition. */\n-      hostent->h_aliases = NULL;\n-      hostent->h_addr_list = NULL;\n-\n-      /* Copy official host name. */\n-      hostent->h_name = strdup(txthost);\n-      if (!hostent->h_name)\n-        break;\n-\n-      /* Copy network address. */\n-      hostent->h_addr_list = malloc(2 * sizeof(char *));\n-      if (!hostent->h_addr_list)\n-        break;\n-      hostent->h_addr_list[1] = NULL;\n-      hostent->h_addr_list[0] = malloc(addrlen);\n-      if (!hostent->h_addr_list[0])\n-        break;\n-      if (addr.family == AF_INET)\n-        memcpy(hostent->h_addr_list[0], &addr.addrV4, sizeof(addr.addrV4));\n-      else\n-        memcpy(hostent->h_addr_list[0], &addr.addrV6, sizeof(addr.addrV6));\n-\n-      /* Copy aliases. */\n-      hostent->h_aliases = malloc((naliases + 1) * sizeof(char *));\n-      if (!hostent->h_aliases)\n-        break;\n-      alias = hostent->h_aliases;\n-      while (naliases)\n-        *(alias + naliases--) = NULL;\n-      *alias = NULL;\n-      while (txtalias)\n-        {\n-          p = txtalias;\n-          while (*p && !ISSPACE(*p))\n-            p++;\n-          q = p;\n-          while (*q && ISSPACE(*q))\n-            q++;\n-          *p = '\\0';\n-          if ((*alias = strdup(txtalias)) == NULL)\n-            break;\n-          alias++;\n-          txtalias = *q ? q : NULL;\n-        }\n-      if (txtalias)\n-        /* Alias memory allocation failure. */\n-        break;\n-\n-      /* Copy actual network address family and length. */\n-      hostent->h_addrtype = addr.family;\n-      hostent->h_length = (int)addrlen;\n-\n-      /* Free line buffer. */\n-      free(line);\n-\n-      /* Return hostent successfully */\n-      *host = hostent;\n-      return ARES_SUCCESS;\n-\n-    }\n-\n-  /* If allocated, free line buffer. */\n-  if (line)\n-    free(line);\n-\n-  if (status == ARES_SUCCESS)\n-    {\n-      /* Memory allocation failure; clean up. */\n-      if (hostent)\n-        {\n-          if (hostent->h_name)\n-            free((char *) hostent->h_name);\n-          if (hostent->h_aliases)\n-            {\n-              for (alias = hostent->h_aliases; *alias; alias++)\n-                free(*alias);\n-              free(hostent->h_aliases);\n-            }\n-          if (hostent->h_addr_list)\n-            {\n-              if (hostent->h_addr_list[0])\n-                free(hostent->h_addr_list[0]);\n-              free(hostent->h_addr_list);\n-            }\n-          free(hostent);\n-        }\n-      return ARES_ENOMEM;\n-    }\n-\n-  return status;\n-}"}, {"sha": "ca018035ec369820362929584143fb0713ed9673", "filename": "src/rt/libuv/src/ares/ares__read_line.c", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__read_line.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,71 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_nowarn.h\"\n-#include \"ares_private.h\"\n-\n-/* This is an internal function.  Its contract is to read a line from\n- * a file into a dynamically allocated buffer, zeroing the trailing\n- * newline if there is one.  The calling routine may call\n- * ares__read_line multiple times with the same buf and bufsize\n- * pointers; *buf will be reallocated and *bufsize adjusted as\n- * appropriate.  The initial value of *buf should be NULL.  After the\n- * calling routine is done reading lines, it should free *buf.\n- */\n-int ares__read_line(FILE *fp, char **buf, size_t *bufsize)\n-{\n-  char *newbuf;\n-  size_t offset = 0;\n-  size_t len;\n-\n-  if (*buf == NULL)\n-    {\n-      *buf = malloc(128);\n-      if (!*buf)\n-        return ARES_ENOMEM;\n-      *bufsize = 128;\n-    }\n-\n-  for (;;)\n-    {\n-      int bytestoread = aresx_uztosi(*bufsize - offset);\n-\n-      if (!fgets(*buf + offset, bytestoread, fp))\n-        return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;\n-      len = offset + strlen(*buf + offset);\n-      if ((*buf)[len - 1] == '\\n')\n-        {\n-          (*buf)[len - 1] = 0;\n-          break;\n-        }\n-      offset = len;\n-      if(len < *bufsize - 1)\n-        continue;\n-\n-      /* Allocate more space. */\n-      newbuf = realloc(*buf, *bufsize * 2);\n-      if (!newbuf)\n-        return ARES_ENOMEM;\n-      *buf = newbuf;\n-      *bufsize *= 2;\n-    }\n-  return ARES_SUCCESS;\n-}"}, {"sha": "f7aa7883f93572e8e23945305c59a8a1877135b2", "filename": "src/rt/libuv/src/ares/ares__timeval.c", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares__timeval.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,111 +0,0 @@\n-\n-/* Copyright (C) 2008 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this software and its\n- * documentation for any purpose and without fee is hereby granted, provided\n- * that the above copyright notice appear in all copies and that both that\n- * copyright notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in advertising or\n- * publicity pertaining to distribution of the software without specific,\n- * written prior permission.  M.I.T. makes no representations about the\n- * suitability of this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-#if defined(WIN32) && !defined(MSDOS)\n-\n-struct timeval ares__tvnow(void)\n-{\n-  /*\n-  ** GetTickCount() is available on _all_ Windows versions from W95 up\n-  ** to nowadays. Returns milliseconds elapsed since last system boot,\n-  ** increases monotonically and wraps once 49.7 days have elapsed.\n-  */\n-  struct timeval now;\n-  DWORD milliseconds = GetTickCount();\n-  now.tv_sec = milliseconds / 1000;\n-  now.tv_usec = (milliseconds % 1000) * 1000;\n-  return now;\n-}\n-\n-#elif defined(HAVE_CLOCK_GETTIME_MONOTONIC)\n-\n-struct timeval ares__tvnow(void)\n-{\n-  /*\n-  ** clock_gettime() is granted to be increased monotonically when the\n-  ** monotonic clock is queried. Time starting point is unspecified, it\n-  ** could be the system start-up time, the Epoch, or something else,\n-  ** in any case the time starting point does not change once that the\n-  ** system has started up.\n-  */\n-  struct timeval now;\n-  struct timespec tsnow;\n-  if(0 == clock_gettime(CLOCK_MONOTONIC, &tsnow)) {\n-    now.tv_sec = tsnow.tv_sec;\n-    now.tv_usec = tsnow.tv_nsec / 1000;\n-  }\n-  /*\n-  ** Even when the configure process has truly detected monotonic clock\n-  ** availability, it might happen that it is not actually available at\n-  ** run-time. When this occurs simply fallback to other time source.\n-  */\n-#ifdef HAVE_GETTIMEOFDAY\n-  else\n-    (void)gettimeofday(&now, NULL);\n-#else\n-  else {\n-    now.tv_sec = (long)time(NULL);\n-    now.tv_usec = 0;\n-  }\n-#endif\n-  return now;\n-}\n-\n-#elif defined(HAVE_GETTIMEOFDAY)\n-\n-struct timeval ares__tvnow(void)\n-{\n-  /*\n-  ** gettimeofday() is not granted to be increased monotonically, due to\n-  ** clock drifting and external source time synchronization it can jump\n-  ** forward or backward in time.\n-  */\n-  struct timeval now;\n-  (void)gettimeofday(&now, NULL);\n-  return now;\n-}\n-\n-#else\n-\n-struct timeval ares__tvnow(void)\n-{\n-  /*\n-  ** time() returns the value of time in seconds since the Epoch.\n-  */\n-  struct timeval now;\n-  now.tv_sec = (long)time(NULL);\n-  now.tv_usec = 0;\n-  return now;\n-}\n-\n-#endif\n-\n-#if 0 /* Not used */\n-/*\n- * Make sure that the first argument is the more recent time, as otherwise\n- * we'll get a weird negative time-diff back...\n- *\n- * Returns: the time difference in number of milliseconds.\n- */\n-long ares__tvdiff(struct timeval newer, struct timeval older)\n-{\n-  return (newer.tv_sec-older.tv_sec)*1000+\n-    (newer.tv_usec-older.tv_usec)/1000;\n-}\n-#endif\n-"}, {"sha": "eb790ae00d06f82f0d9d350ccd54d75a364dfae0", "filename": "src/rt/libuv/src/ares/ares_cancel.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_cancel.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,63 +0,0 @@\n-\n-/* Copyright (C) 2004 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this software and its\n- * documentation for any purpose and without fee is hereby granted, provided\n- * that the above copyright notice appear in all copies and that both that\n- * copyright notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in advertising or\n- * publicity pertaining to distribution of the software without specific,\n- * written prior permission.  M.I.T. makes no representations about the\n- * suitability of this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <assert.h>\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-/*\n- * ares_cancel() cancels all ongoing requests/resolves that might be going on\n- * on the given channel. It does NOT kill the channel, use ares_destroy() for\n- * that.\n- */\n-void ares_cancel(ares_channel channel)\n-{\n-  struct query *query;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-  int i;\n-\n-  list_head = &(channel->all_queries);\n-  for (list_node = list_head->next; list_node != list_head; )\n-  {\n-    query = list_node->data;\n-    list_node = list_node->next;  /* since we're deleting the query */\n-    query->callback(query->arg, ARES_ECANCELLED, 0, NULL, 0);\n-    ares__free_query(query);\n-  }\n-#ifndef NDEBUG\n-  /* Freeing the query should remove it from all the lists in which it sits,\n-   * so all query lists should be empty now.\n-   */\n-  assert(ares__is_list_empty(&(channel->all_queries)));\n-  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n-    {\n-      assert(ares__is_list_empty(&(channel->queries_by_qid[i])));\n-    }\n-  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n-    {\n-      assert(ares__is_list_empty(&(channel->queries_by_timeout[i])));\n-    }\n-#endif\n-  if (!(channel->flags & ARES_FLAG_STAYOPEN))\n-  {\n-    if (channel->servers)\n-    {\n-      for (i = 0; i < channel->nservers; i++)\n-        ares__close_sockets(channel, &channel->servers[i]);\n-    }\n-  }\n-}"}, {"sha": "a2477be192c562389cb7d23b5dbec58e08db40f9", "filename": "src/rt/libuv/src/ares/ares_data.c", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,190 +0,0 @@\n-\n-/* Copyright (C) 2009-2010 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-\n-#include \"ares_setup.h\"\n-\n-#include <stddef.h>\n-\n-#include \"ares.h\"\n-#include \"ares_data.h\"\n-#include \"ares_private.h\"\n-\n-\n-/*\n-** ares_free_data() - c-ares external API function.\n-**\n-** This function must be used by the application to free data memory that\n-** has been internally allocated by some c-ares function and for which a\n-** pointer has already been returned to the calling application. The list\n-** of c-ares functions returning pointers that must be free'ed using this\n-** function is:\n-**\n-**   ares_get_servers()\n-**   ares_parse_srv_reply()\n-**   ares_parse_txt_reply()\n-*/\n-\n-void ares_free_data(void *dataptr)\n-{\n-  struct ares_data *ptr;\n-\n-  if (!dataptr)\n-    return;\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:1684)\n-   /* 1684: conversion from pointer to same-sized integral type */\n-#endif\n-\n-  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-\n-  if (ptr->mark != ARES_DATATYPE_MARK)\n-    return;\n-\n-  switch (ptr->type)\n-    {\n-      case ARES_DATATYPE_MX_REPLY:\n-\n-        if (ptr->data.mx_reply.next)\n-          ares_free_data(ptr->data.mx_reply.next);\n-        if (ptr->data.mx_reply.host)\n-          free(ptr->data.mx_reply.host);\n-        break;\n-\n-      case ARES_DATATYPE_SRV_REPLY:\n-\n-        if (ptr->data.srv_reply.next)\n-          ares_free_data(ptr->data.srv_reply.next);\n-        if (ptr->data.srv_reply.host)\n-          free(ptr->data.srv_reply.host);\n-        break;\n-\n-      case ARES_DATATYPE_TXT_REPLY:\n-\n-        if (ptr->data.txt_reply.next)\n-          ares_free_data(ptr->data.txt_reply.next);\n-        if (ptr->data.txt_reply.txt)\n-          free(ptr->data.txt_reply.txt);\n-        break;\n-\n-      case ARES_DATATYPE_ADDR_NODE:\n-\n-        if (ptr->data.addr_node.next)\n-          ares_free_data(ptr->data.addr_node.next);\n-        break;\n-\n-      default:\n-        return;\n-    }\n-\n-  free(ptr);\n-}\n-\n-\n-/*\n-** ares_malloc_data() - c-ares internal helper function.\n-**\n-** This function allocates memory for a c-ares private ares_data struct\n-** for the specified ares_datatype, initializes c-ares private fields\n-** and zero initializes those which later might be used from the public\n-** API. It returns an interior pointer which can be passed by c-ares\n-** functions to the calling application, and that must be free'ed using\n-** c-ares external API function ares_free_data().\n-*/\n-\n-void *ares_malloc_data(ares_datatype type)\n-{\n-  struct ares_data *ptr;\n-\n-  ptr = malloc(sizeof(struct ares_data));\n-  if (!ptr)\n-    return NULL;\n-\n-  switch (type)\n-    {\n-      case ARES_DATATYPE_MX_REPLY:\n-        ptr->data.mx_reply.next = NULL;\n-        ptr->data.mx_reply.host = NULL;\n-        ptr->data.mx_reply.priority = 0;\n-        break;\n-\n-      case ARES_DATATYPE_SRV_REPLY:\n-        ptr->data.srv_reply.next = NULL;\n-        ptr->data.srv_reply.host = NULL;\n-        ptr->data.srv_reply.priority = 0;\n-        ptr->data.srv_reply.weight = 0;\n-        ptr->data.srv_reply.port = 0;\n-        break;\n-\n-      case ARES_DATATYPE_TXT_REPLY:\n-        ptr->data.txt_reply.next = NULL;\n-        ptr->data.txt_reply.txt = NULL;\n-        ptr->data.txt_reply.length  = 0;\n-        break;\n-\n-      case ARES_DATATYPE_ADDR_NODE:\n-        ptr->data.addr_node.next = NULL;\n-        ptr->data.addr_node.family = 0;\n-        memset(&ptr->data.addr_node.addrV6, 0,\n-               sizeof(ptr->data.addr_node.addrV6));\n-        break;\n-\n-      default:\n-        free(ptr);\n-        return NULL;\n-    }\n-\n-  ptr->mark = ARES_DATATYPE_MARK;\n-  ptr->type = type;\n-\n-  return &ptr->data;\n-}\n-\n-\n-/*\n-** ares_get_datatype() - c-ares internal helper function.\n-**\n-** This function returns the ares_datatype of the data stored in a\n-** private ares_data struct when given the public API pointer.\n-*/\n-\n-ares_datatype ares_get_datatype(void * dataptr)\n-{\n-  struct ares_data *ptr;\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:1684)\n-   /* 1684: conversion from pointer to same-sized integral type */\n-#endif\n-\n-  ptr = (void *)((char *)dataptr - offsetof(struct ares_data, data));\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-\n-  if (ptr->mark == ARES_DATATYPE_MARK)\n-    return ptr->type;\n-\n-  return ARES_DATATYPE_UNKNOWN;\n-}"}, {"sha": "de1608be5b85519b9e64ab8232f4984646ed10f4", "filename": "src/rt/libuv/src/ares/ares_data.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_data.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,65 +0,0 @@\n-\n-/* Copyright (C) 2009-2010 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-typedef enum {\n-  ARES_DATATYPE_UNKNOWN = 1,  /* unknown data type     - introduced in 1.7.0 */\n-  ARES_DATATYPE_SRV_REPLY,    /* struct ares_srv_reply - introduced in 1.7.0 */\n-  ARES_DATATYPE_TXT_REPLY,    /* struct ares_txt_reply - introduced in 1.7.0 */\n-  ARES_DATATYPE_ADDR_NODE,    /* struct ares_addr_node - introduced in 1.7.1 */\n-  ARES_DATATYPE_MX_REPLY,    /* struct ares_mx_reply   - introduced in 1.7.2 */\n-#if 0\n-  ARES_DATATYPE_ADDR6TTL,     /* struct ares_addrttl   */\n-  ARES_DATATYPE_ADDRTTL,      /* struct ares_addr6ttl  */\n-  ARES_DATATYPE_HOSTENT,      /* struct hostent        */\n-  ARES_DATATYPE_OPTIONS,      /* struct ares_options   */\n-#endif\n-  ARES_DATATYPE_LAST          /* not used              - introduced in 1.7.0 */\n-} ares_datatype;\n-\n-#define ARES_DATATYPE_MARK 0xbead\n-\n-/*\n- * ares_data struct definition is internal to c-ares and shall not\n- * be exposed by the public API in order to allow future changes\n- * and extensions to it without breaking ABI.  This will be used\n- * internally by c-ares as the container of multiple types of data\n- * dynamically allocated for which a reference will be returned\n- * to the calling application.\n- *\n- * c-ares API functions returning a pointer to c-ares internally\n- * allocated data will actually be returning an interior pointer\n- * into this ares_data struct.\n- *\n- * All this is 'invisible' to the calling application, the only\n- * requirement is that this kind of data must be free'ed by the\n- * calling application using ares_free_data() with the pointer\n- * it has received from a previous c-ares function call.\n- */\n-\n-struct ares_data {\n-  ares_datatype type;  /* Actual data type identifier. */\n-  unsigned int  mark;  /* Private ares_data signature. */\n-  union {\n-    struct ares_txt_reply txt_reply;\n-    struct ares_srv_reply srv_reply;\n-    struct ares_addr_node addr_node;\n-    struct ares_mx_reply mx_reply;\n-  } data;\n-};\n-\n-void *ares_malloc_data(ares_datatype type);\n-\n-ares_datatype ares_get_datatype(void * dataptr);"}, {"sha": "5e274daeef5d67526856f6282ab505e59901cf2d", "filename": "src/rt/libuv/src/ares/ares_destroy.c", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_destroy.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,105 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2010 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <assert.h>\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-void ares_destroy_options(struct ares_options *options)\n-{\n-  int i;\n-\n-  if(options->servers)\n-    free(options->servers);\n-  for (i = 0; i < options->ndomains; i++)\n-    free(options->domains[i]);\n-  free(options->domains);\n-  if(options->sortlist)\n-    free(options->sortlist);\n-  free(options->lookups);\n-}\n-\n-void ares_destroy(ares_channel channel)\n-{\n-  int i;\n-  struct query *query;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-  \n-  if (!channel)\n-    return;\n-\n-  list_head = &(channel->all_queries);\n-  for (list_node = list_head->next; list_node != list_head; )\n-    {\n-      query = list_node->data;\n-      list_node = list_node->next;  /* since we're deleting the query */\n-      query->callback(query->arg, ARES_EDESTRUCTION, 0, NULL, 0);\n-      ares__free_query(query);\n-    }\n-#ifndef NDEBUG\n-  /* Freeing the query should remove it from all the lists in which it sits,\n-   * so all query lists should be empty now.\n-   */\n-  assert(ares__is_list_empty(&(channel->all_queries)));\n-  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n-    {\n-      assert(ares__is_list_empty(&(channel->queries_by_qid[i])));\n-    }\n-  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n-    {\n-      assert(ares__is_list_empty(&(channel->queries_by_timeout[i])));\n-    }\n-#endif\n-\n-  ares__destroy_servers_state(channel);\n-\n-  if (channel->domains) {\n-    for (i = 0; i < channel->ndomains; i++)\n-      free(channel->domains[i]);\n-    free(channel->domains);\n-  }\n-\n-  if(channel->sortlist)\n-    free(channel->sortlist);\n-\n-  if (channel->lookups)\n-    free(channel->lookups);\n-\n-  free(channel);\n-}\n-\n-void ares__destroy_servers_state(ares_channel channel)\n-{\n-  struct server_state *server;\n-  int i;\n-\n-  if (channel->servers)\n-    {\n-      for (i = 0; i < channel->nservers; i++)\n-        {\n-          server = &channel->servers[i];\n-          ares__close_sockets(channel, server);\n-          assert(ares__is_list_empty(&server->queries_to_server));\n-        }\n-      free(channel->servers);\n-      channel->servers = NULL;\n-    }\n-  channel->nservers = -1;\n-}"}, {"sha": "6893c024c89f5e1b3ead0526cb82ce16ad9d7091", "filename": "src/rt/libuv/src/ares/ares_dns.h", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_dns.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,90 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#ifndef ARES__DNS_H\n-#define ARES__DNS_H\n-\n-#define DNS__16BIT(p)                   (((p)[0] << 8) | (p)[1])\n-#define DNS__32BIT(p)                   (((p)[0] << 24) | ((p)[1] << 16) | \\\n-                                         ((p)[2] << 8) | (p)[3])\n-\n-#define DNS__SET16BIT(p, v)  (((p)[0] = (unsigned char)(((v) >> 8) & 0xff)), \\\n-                              ((p)[1] = (unsigned char)((v) & 0xff)))\n-#define DNS__SET32BIT(p, v)  (((p)[0] = (unsigned char)(((v) >> 24) & 0xff)), \\\n-                              ((p)[1] = (unsigned char)(((v) >> 16) & 0xff)), \\\n-                              ((p)[2] = (unsigned char)(((v) >> 8) & 0xff)), \\\n-                              ((p)[3] = (unsigned char)((v) & 0xff)))\n-\n-#if 0\n-/* we cannot use this approach on systems where we can't access 16/32 bit\n-   data on un-aligned addresses */\n-#define DNS__16BIT(p)                   ntohs(*(unsigned short*)(p))\n-#define DNS__32BIT(p)                   ntohl(*(unsigned long*)(p))\n-#define DNS__SET16BIT(p, v)             *(unsigned short*)(p) = htons(v)\n-#define DNS__SET32BIT(p, v)             *(unsigned long*)(p) = htonl(v)\n-#endif\n-\n-/* Macros for parsing a DNS header */\n-#define DNS_HEADER_QID(h)               DNS__16BIT(h)\n-#define DNS_HEADER_QR(h)                (((h)[2] >> 7) & 0x1)\n-#define DNS_HEADER_OPCODE(h)            (((h)[2] >> 3) & 0xf)\n-#define DNS_HEADER_AA(h)                (((h)[2] >> 2) & 0x1)\n-#define DNS_HEADER_TC(h)                (((h)[2] >> 1) & 0x1)\n-#define DNS_HEADER_RD(h)                ((h)[2] & 0x1)\n-#define DNS_HEADER_RA(h)                (((h)[3] >> 7) & 0x1)\n-#define DNS_HEADER_Z(h)                 (((h)[3] >> 4) & 0x7)\n-#define DNS_HEADER_RCODE(h)             ((h)[3] & 0xf)\n-#define DNS_HEADER_QDCOUNT(h)           DNS__16BIT((h) + 4)\n-#define DNS_HEADER_ANCOUNT(h)           DNS__16BIT((h) + 6)\n-#define DNS_HEADER_NSCOUNT(h)           DNS__16BIT((h) + 8)\n-#define DNS_HEADER_ARCOUNT(h)           DNS__16BIT((h) + 10)\n-\n-/* Macros for constructing a DNS header */\n-#define DNS_HEADER_SET_QID(h, v)      DNS__SET16BIT(h, v)\n-#define DNS_HEADER_SET_QR(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 7))\n-#define DNS_HEADER_SET_OPCODE(h, v)   ((h)[2] |= (unsigned char)(((v) & 0xf) << 3))\n-#define DNS_HEADER_SET_AA(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 2))\n-#define DNS_HEADER_SET_TC(h, v)       ((h)[2] |= (unsigned char)(((v) & 0x1) << 1))\n-#define DNS_HEADER_SET_RD(h, v)       ((h)[2] |= (unsigned char)((v) & 0x1))\n-#define DNS_HEADER_SET_RA(h, v)       ((h)[3] |= (unsigned char)(((v) & 0x1) << 7))\n-#define DNS_HEADER_SET_Z(h, v)        ((h)[3] |= (unsigned char)(((v) & 0x7) << 4))\n-#define DNS_HEADER_SET_RCODE(h, v)    ((h)[3] |= (unsigned char)((v) & 0xf))\n-#define DNS_HEADER_SET_QDCOUNT(h, v)  DNS__SET16BIT((h) + 4, v)\n-#define DNS_HEADER_SET_ANCOUNT(h, v)  DNS__SET16BIT((h) + 6, v)\n-#define DNS_HEADER_SET_NSCOUNT(h, v)  DNS__SET16BIT((h) + 8, v)\n-#define DNS_HEADER_SET_ARCOUNT(h, v)  DNS__SET16BIT((h) + 10, v)\n-\n-/* Macros for parsing the fixed part of a DNS question */\n-#define DNS_QUESTION_TYPE(q)            DNS__16BIT(q)\n-#define DNS_QUESTION_CLASS(q)           DNS__16BIT((q) + 2)\n-\n-/* Macros for constructing the fixed part of a DNS question */\n-#define DNS_QUESTION_SET_TYPE(q, v)     DNS__SET16BIT(q, v)\n-#define DNS_QUESTION_SET_CLASS(q, v)    DNS__SET16BIT((q) + 2, v)\n-\n-/* Macros for parsing the fixed part of a DNS resource record */\n-#define DNS_RR_TYPE(r)                  DNS__16BIT(r)\n-#define DNS_RR_CLASS(r)                 DNS__16BIT((r) + 2)\n-#define DNS_RR_TTL(r)                   DNS__32BIT((r) + 4)\n-#define DNS_RR_LEN(r)                   DNS__16BIT((r) + 8)\n-\n-/* Macros for constructing the fixed part of a DNS resource record */\n-#define DNS_RR_SET_TYPE(r)              DNS__SET16BIT(r, v)\n-#define DNS_RR_SET_CLASS(r)             DNS__SET16BIT((r) + 2, v)\n-#define DNS_RR_SET_TTL(r)               DNS__SET32BIT((r) + 4, v)\n-#define DNS_RR_SET_LEN(r)               DNS__SET16BIT((r) + 8, v)\n-\n-#endif /* ARES__DNS_H */"}, {"sha": "e3eccd2f74d2e3591133985b81f02c4c7199df1d", "filename": "src/rt/libuv/src/ares/ares_expand_name.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_name.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,200 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_private.h\" /* for the memdebug */\n-\n-static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n-                       int alen);\n-\n-/* Expand an RFC1035-encoded domain name given by encoded.  The\n- * containing message is given by abuf and alen.  The result given by\n- * *s, which is set to a NUL-terminated allocated buffer.  *enclen is\n- * set to the length of the encoded name (not the length of the\n- * expanded name; the goal is to tell the caller how many bytes to\n- * move forward to get past the encoded name).\n- *\n- * In the simple case, an encoded name is a series of labels, each\n- * composed of a one-byte length (limited to values between 0 and 63\n- * inclusive) followed by the label contents.  The name is terminated\n- * by a zero-length label.\n- *\n- * In the more complicated case, a label may be terminated by an\n- * indirection pointer, specified by two bytes with the high bits of\n- * the first byte (corresponding to INDIR_MASK) set to 11.  With the\n- * two high bits of the first byte stripped off, the indirection\n- * pointer gives an offset from the beginning of the containing\n- * message with more labels to decode.  Indirection can happen an\n- * arbitrary number of times, so we have to detect loops.\n- *\n- * Since the expanded name uses '.' as a label separator, we use\n- * backslashes to escape periods or backslashes in the expanded name.\n- */\n-\n-int ares_expand_name(const unsigned char *encoded, const unsigned char *abuf,\n-                     int alen, char **s, long *enclen)\n-{\n-  int len, indir = 0;\n-  char *q;\n-  const unsigned char *p;\n-  union {\n-    ssize_t sig;\n-     size_t uns;\n-  } nlen;\n-\n-  nlen.sig = name_length(encoded, abuf, alen);\n-  if (nlen.sig < 0)\n-    return ARES_EBADNAME;\n-\n-  *s = malloc(nlen.uns + 1);\n-  if (!*s)\n-    return ARES_ENOMEM;\n-  q = *s;\n-\n-  if (nlen.uns == 0) {\n-    /* RFC2181 says this should be \".\": the root of the DNS tree.\n-     * Since this function strips trailing dots though, it becomes \"\"\n-     */\n-    q[0] = '\\0';\n-\n-    /* indirect root label (like 0xc0 0x0c) is 2 bytes long (stupid, but\n-       valid) */\n-    if ((*encoded & INDIR_MASK) == INDIR_MASK)\n-      *enclen = 2;\n-    else\n-      *enclen = 1;  /* the caller should move one byte to get past this */\n-\n-    return ARES_SUCCESS;\n-  }\n-\n-  /* No error-checking necessary; it was all done by name_length(). */\n-  p = encoded;\n-  while (*p)\n-    {\n-      if ((*p & INDIR_MASK) == INDIR_MASK)\n-        {\n-          if (!indir)\n-            {\n-              *enclen = p + 2 - encoded;\n-              indir = 1;\n-            }\n-          p = abuf + ((*p & ~INDIR_MASK) << 8 | *(p + 1));\n-        }\n-      else\n-        {\n-          len = *p;\n-          p++;\n-          while (len--)\n-            {\n-              if (*p == '.' || *p == '\\\\')\n-                *q++ = '\\\\';\n-              *q++ = *p;\n-              p++;\n-            }\n-          *q++ = '.';\n-        }\n-    }\n-  if (!indir)\n-    *enclen = p + 1 - encoded;\n-\n-  /* Nuke the trailing period if we wrote one. */\n-  if (q > *s)\n-    *(q - 1) = 0;\n-  else\n-    *q = 0; /* zero terminate */\n-\n-  return ARES_SUCCESS;\n-}\n-\n-/* Return the length of the expansion of an encoded domain name, or\n- * -1 if the encoding is invalid.\n- */\n-static int name_length(const unsigned char *encoded, const unsigned char *abuf,\n-                       int alen)\n-{\n-  int n = 0, offset, indir = 0;\n-\n-  /* Allow the caller to pass us abuf + alen and have us check for it. */\n-  if (encoded == abuf + alen)\n-    return -1;\n-\n-  while (*encoded)\n-    {\n-      if ((*encoded & INDIR_MASK) == INDIR_MASK)\n-        {\n-          /* Check the offset and go there. */\n-          if (encoded + 1 >= abuf + alen)\n-            return -1;\n-          offset = (*encoded & ~INDIR_MASK) << 8 | *(encoded + 1);\n-          if (offset >= alen)\n-            return -1;\n-          encoded = abuf + offset;\n-\n-          /* If we've seen more indirects than the message length,\n-           * then there's a loop.\n-           */\n-          if (++indir > alen)\n-            return -1;\n-        }\n-      else\n-        {\n-          offset = *encoded;\n-          if (encoded + offset + 1 >= abuf + alen)\n-            return -1;\n-          encoded++;\n-          while (offset--)\n-            {\n-              n += (*encoded == '.' || *encoded == '\\\\') ? 2 : 1;\n-              encoded++;\n-            }\n-          n++;\n-        }\n-    }\n-\n-  /* If there were any labels at all, then the number of dots is one\n-   * less than the number of labels, so subtract one.\n-   */\n-  return (n) ? n - 1 : n;\n-}\n-\n-/* Like ares_expand_name but returns EBADRESP in case of invalid input. */\n-int ares__expand_name_for_response(const unsigned char *encoded,\n-                                   const unsigned char *abuf, int alen,\n-                                   char **s, long *enclen)\n-{\n-  int status = ares_expand_name(encoded, abuf, alen, s, enclen);\n-  if (status == ARES_EBADNAME)\n-    status = ARES_EBADRESP;\n-  return status;\n-}"}, {"sha": "f24cccf6470d17391c07e31635dc78588fdee1f7", "filename": "src/rt/libuv/src/ares/ares_expand_string.c", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_expand_string.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,75 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-\n-#include <string.h>\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_private.h\" /* for the memdebug */\n-\n-/* Simply decodes a length-encoded character string. The first byte of the\n- * input is the length of the string to be returned and the bytes thereafter\n- * are the characters of the string. The returned result will be NULL\n- * terminated.\n- */\n-int ares_expand_string(const unsigned char *encoded,\n-                       const unsigned char *abuf,\n-                       int alen,\n-                       unsigned char **s,\n-                       long *enclen)\n-{\n-  unsigned char *q;\n-  union {\n-    ssize_t sig;\n-     size_t uns;\n-  } elen;\n-\n-  if (encoded == abuf+alen)\n-    return ARES_EBADSTR;\n-\n-  elen.uns = *encoded;\n-  if (encoded+elen.sig+1 > abuf+alen)\n-    return ARES_EBADSTR;\n-\n-  encoded++;\n-\n-  *s = malloc(elen.uns+1);\n-  if (*s == NULL)\n-    return ARES_ENOMEM;\n-  q = *s;\n-  strncpy((char *)q, (char *)encoded, elen.uns);\n-  q[elen.uns] = '\\0';\n-\n-  *s = q;\n-\n-  *enclen = (long)(elen.sig+1);\n-\n-  return ARES_SUCCESS;\n-}\n-"}, {"sha": "ac5eedb325390f77bba0a29559a837d8a8c86976", "filename": "src/rt/libuv/src/ares/ares_fds.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_fds.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,63 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys/time.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_nowarn.h\"\n-#include \"ares_private.h\"\n-\n-int ares_fds(ares_channel channel, fd_set *read_fds, fd_set *write_fds)\n-{\n-  struct server_state *server;\n-  ares_socket_t nfds;\n-  int i;\n-\n-  /* Are there any active queries? */\n-  int active_queries = !ares__is_list_empty(&(channel->all_queries));\n-\n-  nfds = 0;\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      server = &channel->servers[i];\n-      /* We only need to register interest in UDP sockets if we have\n-       * outstanding queries.\n-       */\n-      if (active_queries && server->udp_socket != ARES_SOCKET_BAD)\n-        {\n-          FD_SET(server->udp_socket, read_fds);\n-          if (server->udp_socket >= nfds)\n-            nfds = server->udp_socket + 1;\n-        }\n-      /* We always register for TCP events, because we want to know\n-       * when the other side closes the connection, so we don't waste\n-       * time trying to use a broken connection.\n-       */\n-      if (server->tcp_socket != ARES_SOCKET_BAD)\n-       {\n-         FD_SET(server->tcp_socket, read_fds);\n-         if (server->qhead)\n-           FD_SET(server->tcp_socket, write_fds);\n-         if (server->tcp_socket >= nfds)\n-           nfds = server->tcp_socket + 1;\n-\t}\n-    }\n-  return (int)nfds;\n-}"}, {"sha": "349d379af3a0609c259168b1d3cb1b62d8a4c65d", "filename": "src/rt/libuv/src/ares/ares_free_hostent.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_hostent.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,42 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <stdlib.h>\n-\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\" /* for memdebug */\n-\n-void ares_free_hostent(struct hostent *host)\n-{\n-  char **p;\n-\n-  if (!host)\n-    return;\n-\n-  free((char *)(host->h_name));\n-  for (p = host->h_aliases; *p; p++)\n-    free(*p);\n-  free(host->h_aliases);\n-  free(host->h_addr_list[0]); /* no matter if there is one or many entries,\n-                                 there is only one malloc for all of them */\n-  free(host->h_addr_list);\n-  free(host);\n-}"}, {"sha": "e0545c1d1af076b7321f659111d6cbe3dc7355a9", "filename": "src/rt/libuv/src/ares/ares_free_string.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_free_string.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,25 +0,0 @@\n-\n-/* Copyright 2000 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-void ares_free_string(void *str)\n-{\n-  free(str);\n-}"}, {"sha": "1b2e85d2bee9c5ecf027e3b36b106a48ef605741", "filename": "src/rt/libuv/src/ares/ares_getenv.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,30 +0,0 @@\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include \"ares_getenv.h\"\n-\n-#ifndef HAVE_GETENV\n-\n-char *ares_getenv(const char *name)\n-{\n-#ifdef _WIN32_WCE\n-  return NULL;\n-#endif\n-}\n-\n-#endif"}, {"sha": "6da6cc5081a7be03c622ef4532f076fe1cc15443", "filename": "src/rt/libuv/src/ares/ares_getenv.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getenv.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,26 +0,0 @@\n-#ifndef HEADER_CARES_GETENV_H\n-#define HEADER_CARES_GETENV_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifndef HAVE_GETENV\n-extern char *ares_getenv(const char *name);\n-#endif\n-\n-#endif /* HEADER_CARES_GETENV_H */"}, {"sha": "4b4c8a7dbde838040dca6d42f54fc827b33895a0", "filename": "src/rt/libuv/src/ares/ares_gethostbyaddr.c", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyaddr.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,301 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"ares.h\"\n-#include \"inet_net_pton.h\"\n-#include \"ares_platform.h\"\n-#include \"ares_private.h\"\n-\n-#ifdef WATT32\n-#undef WIN32\n-#endif\n-\n-struct addr_query {\n-  /* Arguments passed to ares_gethostbyaddr() */\n-  ares_channel channel;\n-  struct ares_addr addr;\n-  ares_host_callback callback;\n-  void *arg;\n-\n-  const char *remaining_lookups;\n-  int timeouts;\n-};\n-\n-static void next_lookup(struct addr_query *aquery);\n-static void addr_callback(void *arg, int status, int timeouts,\n-                          unsigned char *abuf, int alen);\n-static void end_aquery(struct addr_query *aquery, int status,\n-                       struct hostent *host);\n-static int file_lookup(struct ares_addr *addr, struct hostent **host);\n-static void ptr_rr_name(char *name, const struct ares_addr *addr);\n-\n-void ares_gethostbyaddr(ares_channel channel, const void *addr, int addrlen,\n-                        int family, ares_host_callback callback, void *arg)\n-{\n-  struct addr_query *aquery;\n-\n-  if (family != AF_INET && family != AF_INET6)\n-    {\n-      callback(arg, ARES_ENOTIMP, 0, NULL);\n-      return;\n-    }\n-\n-  if ((family == AF_INET && addrlen != sizeof(aquery->addr.addrV4)) ||\n-      (family == AF_INET6 && addrlen != sizeof(aquery->addr.addrV6)))\n-    {\n-      callback(arg, ARES_ENOTIMP, 0, NULL);\n-      return;\n-    }\n-\n-  aquery = malloc(sizeof(struct addr_query));\n-  if (!aquery)\n-    {\n-      callback(arg, ARES_ENOMEM, 0, NULL);\n-      return;\n-    }\n-  aquery->channel = channel;\n-  if (family == AF_INET)\n-    memcpy(&aquery->addr.addrV4, addr, sizeof(aquery->addr.addrV4));\n-  else\n-    memcpy(&aquery->addr.addrV6, addr, sizeof(aquery->addr.addrV6));\n-  aquery->addr.family = family;\n-  aquery->callback = callback;\n-  aquery->arg = arg;\n-  aquery->remaining_lookups = channel->lookups;\n-  aquery->timeouts = 0;\n-\n-  next_lookup(aquery);\n-}\n-\n-static void next_lookup(struct addr_query *aquery)\n-{\n-  const char *p;\n-  char name[128];\n-  int status;\n-  struct hostent *host;\n-\n-  for (p = aquery->remaining_lookups; *p; p++)\n-    {\n-      switch (*p)\n-        {\n-        case 'b':\n-          ptr_rr_name(name, &aquery->addr);\n-          aquery->remaining_lookups = p + 1;\n-          ares_query(aquery->channel, name, C_IN, T_PTR, addr_callback,\n-                     aquery);\n-          return;\n-        case 'f':\n-          status = file_lookup(&aquery->addr, &host);\n-\n-          /* this status check below previously checked for !ARES_ENOTFOUND,\n-             but we should not assume that this single error code is the one\n-             that can occur, as that is in fact no longer the case */\n-          if (status == ARES_SUCCESS)\n-            {\n-              end_aquery(aquery, status, host);\n-              return;\n-            }\n-          break;\n-        }\n-    }\n-  end_aquery(aquery, ARES_ENOTFOUND, NULL);\n-}\n-\n-static void addr_callback(void *arg, int status, int timeouts,\n-                          unsigned char *abuf, int alen)\n-{\n-  struct addr_query *aquery = (struct addr_query *) arg;\n-  struct hostent *host;\n-  size_t addrlen;\n-\n-  aquery->timeouts += timeouts;\n-  if (status == ARES_SUCCESS)\n-    {\n-      if (aquery->addr.family == AF_INET)\n-        {\n-          addrlen = sizeof(aquery->addr.addrV4);\n-          status = ares_parse_ptr_reply(abuf, alen, &aquery->addr.addrV4,\n-                                        (int)addrlen, AF_INET, &host);\n-        }\n-      else\n-        {\n-          addrlen = sizeof(aquery->addr.addrV6);\n-          status = ares_parse_ptr_reply(abuf, alen, &aquery->addr.addrV6,\n-                                        (int)addrlen, AF_INET6, &host);\n-        }\n-      end_aquery(aquery, status, host);\n-    }\n-  else if (status == ARES_EDESTRUCTION)\n-    end_aquery(aquery, status, NULL);\n-  else\n-    next_lookup(aquery);\n-}\n-\n-static void end_aquery(struct addr_query *aquery, int status,\n-                       struct hostent *host)\n-{\n-  aquery->callback(aquery->arg, status, aquery->timeouts, host);\n-  if (host)\n-    ares_free_hostent(host);\n-  free(aquery);\n-}\n-\n-static int file_lookup(struct ares_addr *addr, struct hostent **host)\n-{\n-  FILE *fp;\n-  int status;\n-  int error;\n-\n-#ifdef WIN32\n-  char PATH_HOSTS[MAX_PATH];\n-  win_platform platform;\n-\n-  PATH_HOSTS[0] = '\\0';\n-\n-  platform = ares__getplatform();\n-\n-  if (platform == WIN_NT) {\n-    char tmp[MAX_PATH];\n-    HKEY hkeyHosts;\n-\n-    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n-                     &hkeyHosts) == ERROR_SUCCESS)\n-    {\n-      DWORD dwLength = MAX_PATH;\n-      RegQueryValueEx(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n-                      &dwLength);\n-      ExpandEnvironmentStrings(tmp, PATH_HOSTS, MAX_PATH);\n-      RegCloseKey(hkeyHosts);\n-    }\n-  }\n-  else if (platform == WIN_9X)\n-    GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n-  else\n-    return ARES_ENOTFOUND;\n-\n-  strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n-\n-#elif defined(WATT32)\n-  extern const char *_w32_GetHostsFile (void);\n-  const char *PATH_HOSTS = _w32_GetHostsFile();\n-\n-  if (!PATH_HOSTS)\n-    return ARES_ENOTFOUND;\n-#endif\n-\n-  fp = fopen(PATH_HOSTS, \"r\");\n-  if (!fp)\n-    {\n-      error = ERRNO;\n-      switch(error)\n-        {\n-        case ENOENT:\n-        case ESRCH:\n-          return ARES_ENOTFOUND;\n-        default:\n-          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                         error, strerror(error)));\n-          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n-                         PATH_HOSTS));\n-          *host = NULL;\n-          return ARES_EFILE;\n-        }\n-    }\n-  while ((status = ares__get_hostent(fp, addr->family, host)) == ARES_SUCCESS)\n-    {\n-      if (addr->family != (*host)->h_addrtype)\n-        {\n-          ares_free_hostent(*host);\n-          continue;\n-        }\n-      if (addr->family == AF_INET)\n-        {\n-          if (memcmp((*host)->h_addr, &addr->addrV4,\n-                     sizeof(addr->addrV4)) == 0)\n-            break;\n-        }\n-      else if (addr->family == AF_INET6)\n-        {\n-          if (memcmp((*host)->h_addr, &addr->addrV6,\n-                     sizeof(addr->addrV6)) == 0)\n-            break;\n-        }\n-      ares_free_hostent(*host);\n-    }\n-  fclose(fp);\n-  if (status == ARES_EOF)\n-    status = ARES_ENOTFOUND;\n-  if (status != ARES_SUCCESS)\n-    *host = NULL;\n-  return status;\n-}\n-\n-static void ptr_rr_name(char *name, const struct ares_addr *addr)\n-{\n-  if (addr->family == AF_INET)\n-    {\n-       unsigned long laddr = ntohl(addr->addrV4.s_addr);\n-       unsigned long a1 = (laddr >> 24UL) & 0xFFUL;\n-       unsigned long a2 = (laddr >> 16UL) & 0xFFUL;\n-       unsigned long a3 = (laddr >>  8UL) & 0xFFUL;\n-       unsigned long a4 = laddr & 0xFFUL;\n-       sprintf(name, \"%lu.%lu.%lu.%lu.in-addr.arpa\", a4, a3, a2, a1);\n-    }\n-  else\n-    {\n-       unsigned char *bytes = (unsigned char *)&addr->addrV6;\n-       /* There are too many arguments to do this in one line using\n-        * minimally C89-compliant compilers */\n-       sprintf(name,\n-                \"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.\",\n-                bytes[15]&0xf, bytes[15] >> 4, bytes[14]&0xf, bytes[14] >> 4,\n-                bytes[13]&0xf, bytes[13] >> 4, bytes[12]&0xf, bytes[12] >> 4,\n-                bytes[11]&0xf, bytes[11] >> 4, bytes[10]&0xf, bytes[10] >> 4,\n-                bytes[9]&0xf, bytes[9] >> 4, bytes[8]&0xf, bytes[8] >> 4);\n-       sprintf(name+strlen(name),\n-                \"%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.ip6.arpa\",\n-                bytes[7]&0xf, bytes[7] >> 4, bytes[6]&0xf, bytes[6] >> 4,\n-                bytes[5]&0xf, bytes[5] >> 4, bytes[4]&0xf, bytes[4] >> 4,\n-                bytes[3]&0xf, bytes[3] >> 4, bytes[2]&0xf, bytes[2] >> 4,\n-                bytes[1]&0xf, bytes[1] >> 4, bytes[0]&0xf, bytes[0] >> 4);\n-    }\n-}"}, {"sha": "ad89dc27bf810c57f0324da46d3da31c2bc04a44", "filename": "src/rt/libuv/src/ares/ares_gethostbyname.c", "status": "removed", "additions": 0, "deletions": 523, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_gethostbyname.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,523 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <ctype.h>\n-#ifdef HAVE_STRINGS_H\n-#include <strings.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"inet_net_pton.h\"\n-#include \"bitncmp.h\"\n-#include \"ares_platform.h\"\n-#include \"ares_private.h\"\n-\n-#ifdef WATT32\n-#undef WIN32\n-#endif\n-\n-struct host_query {\n-  /* Arguments passed to ares_gethostbyname() */\n-  ares_channel channel;\n-  char *name;\n-  ares_host_callback callback;\n-  void *arg;\n-  int sent_family; /* this family is what was is being used */\n-  int want_family; /* this family is what is asked for in the API */\n-  const char *remaining_lookups;\n-  int timeouts;\n-};\n-\n-static void next_lookup(struct host_query *hquery, int status_code);\n-static void host_callback(void *arg, int status, int timeouts,\n-                          unsigned char *abuf, int alen);\n-static void end_hquery(struct host_query *hquery, int status,\n-                       struct hostent *host);\n-static int fake_hostent(const char *name, int family,\n-                        ares_host_callback callback, void *arg);\n-static int file_lookup(const char *name, int family, struct hostent **host);\n-static void sort_addresses(struct hostent *host,\n-                           const struct apattern *sortlist, int nsort);\n-static void sort6_addresses(struct hostent *host,\n-                            const struct apattern *sortlist, int nsort);\n-static int get_address_index(const struct in_addr *addr,\n-                             const struct apattern *sortlist, int nsort);\n-static int get6_address_index(const struct ares_in6_addr *addr,\n-                              const struct apattern *sortlist, int nsort);\n-\n-void ares_gethostbyname(ares_channel channel, const char *name, int family,\n-                        ares_host_callback callback, void *arg)\n-{\n-  struct host_query *hquery;\n-\n-  /* Right now we only know how to look up Internet addresses - and unspec\n-     means try both basically. */\n-  switch (family) {\n-  case AF_INET:\n-  case AF_INET6:\n-  case AF_UNSPEC:\n-    break;\n-  default:\n-    callback(arg, ARES_ENOTIMP, 0, NULL);\n-    return;\n-  }\n-\n-  if (fake_hostent(name, family, callback, arg))\n-    return;\n-\n-  /* Allocate and fill in the host query structure. */\n-  hquery = malloc(sizeof(struct host_query));\n-  if (!hquery)\n-    {\n-      callback(arg, ARES_ENOMEM, 0, NULL);\n-      return;\n-    }\n-  hquery->channel = channel;\n-  hquery->name = strdup(name);\n-  hquery->want_family = family;\n-  hquery->sent_family = -1; /* nothing is sent yet */\n-  if (!hquery->name) {\n-    free(hquery);\n-    callback(arg, ARES_ENOMEM, 0, NULL);\n-    return;\n-  }\n-  hquery->callback = callback;\n-  hquery->arg = arg;\n-  hquery->remaining_lookups = channel->lookups;\n-  hquery->timeouts = 0;\n-\n-  /* Start performing lookups according to channel->lookups. */\n-  next_lookup(hquery, ARES_ECONNREFUSED /* initial error code */);\n-}\n-\n-static void next_lookup(struct host_query *hquery, int status_code)\n-{\n-  const char *p;\n-  struct hostent *host;\n-  int status = status_code;\n-\n-  for (p = hquery->remaining_lookups; *p; p++)\n-    {\n-      switch (*p)\n-        {\n-        case 'b':\n-          /* DNS lookup */\n-          hquery->remaining_lookups = p + 1;\n-          if ((hquery->want_family == AF_INET6) ||\n-              (hquery->want_family == AF_UNSPEC)) {\n-            /* if inet6 or unspec, start out with AAAA */\n-            hquery->sent_family = AF_INET6;\n-            ares_search(hquery->channel, hquery->name, C_IN, T_AAAA,\n-                        host_callback, hquery);\n-          }\n-          else {\n-            hquery->sent_family = AF_INET;\n-            ares_search(hquery->channel, hquery->name, C_IN, T_A,\n-                        host_callback, hquery);\n-          }\n-          return;\n-\n-        case 'f':\n-          /* Host file lookup */\n-          status = file_lookup(hquery->name, hquery->want_family, &host);\n-\n-          /* this status check below previously checked for !ARES_ENOTFOUND,\n-             but we should not assume that this single error code is the one\n-             that can occur, as that is in fact no longer the case */\n-          if (status == ARES_SUCCESS)\n-            {\n-              end_hquery(hquery, status, host);\n-              return;\n-            }\n-          status = status_code;   /* Use original status code */\n-          break;\n-        }\n-    }\n-  end_hquery(hquery, status, NULL);\n-}\n-\n-static void host_callback(void *arg, int status, int timeouts,\n-                          unsigned char *abuf, int alen)\n-{\n-  struct host_query *hquery = (struct host_query *) arg;\n-  ares_channel channel = hquery->channel;\n-  struct hostent *host = NULL;\n-\n-  hquery->timeouts += timeouts;\n-  if (status == ARES_SUCCESS)\n-    {\n-      if (hquery->sent_family == AF_INET)\n-        {\n-          status = ares_parse_a_reply(abuf, alen, &host, NULL, NULL);\n-          if (host && channel->nsort)\n-            sort_addresses(host, channel->sortlist, channel->nsort);\n-        }\n-      else if (hquery->sent_family == AF_INET6)\n-        {\n-          status = ares_parse_aaaa_reply(abuf, alen, &host, NULL, NULL);\n-          if ((status == ARES_ENODATA || status == ARES_EBADRESP) &&\n-               hquery->want_family == AF_UNSPEC) {\n-            /* The query returned something but either there were no AAAA\n-               records (e.g. just CNAME) or the response was malformed.  Try\n-               looking up A instead. */\n-            hquery->sent_family = AF_INET;\n-            ares_search(hquery->channel, hquery->name, C_IN, T_A,\n-                        host_callback, hquery);\n-            return;\n-          }\n-          if (host && channel->nsort)\n-            sort6_addresses(host, channel->sortlist, channel->nsort);\n-        }\n-      end_hquery(hquery, status, host);\n-    }\n-  else if ((status == ARES_ENODATA || status == ARES_EBADRESP ||\n-            status == ARES_ETIMEOUT) && (hquery->sent_family == AF_INET6 &&\n-            hquery->want_family == AF_UNSPEC))\n-    {\n-      /* The AAAA query yielded no useful result.  Now look up an A instead. */\n-      hquery->sent_family = AF_INET;\n-      ares_search(hquery->channel, hquery->name, C_IN, T_A, host_callback,\n-                  hquery);\n-    }\n-  else if (status == ARES_EDESTRUCTION)\n-    end_hquery(hquery, status, NULL);\n-  else\n-    next_lookup(hquery, status);\n-}\n-\n-static void end_hquery(struct host_query *hquery, int status,\n-                       struct hostent *host)\n-{\n-  hquery->callback(hquery->arg, status, hquery->timeouts, host);\n-  if (host)\n-    ares_free_hostent(host);\n-  free(hquery->name);\n-  free(hquery);\n-}\n-\n-/* If the name looks like an IP address, fake up a host entry, end the\n- * query immediately, and return true.  Otherwise return false.\n- */\n-static int fake_hostent(const char *name, int family,\n-                        ares_host_callback callback, void *arg)\n-{\n-  struct hostent hostent;\n-  char *aliases[1] = { NULL };\n-  char *addrs[2];\n-  int result = 0;\n-  struct in_addr in;\n-  struct ares_in6_addr in6;\n-\n-  if (family == AF_INET || family == AF_INET6)\n-    {\n-      /* It only looks like an IP address if it's all numbers and dots. */\n-      int numdots = 0, valid = 1;\n-      const char *p;\n-      for (p = name; *p; p++)\n-        {\n-          if (!ISDIGIT(*p) && *p != '.') {\n-            valid = 0;\n-            break;\n-          } else if (*p == '.') {\n-            numdots++;\n-          }\n-        }\n-\n-      /* if we don't have 3 dots, it is illegal\n-       * (although inet_addr doesn't think so).\n-       */\n-      if (numdots != 3 || !valid)\n-        result = 0;\n-      else\n-        result = ((in.s_addr = inet_addr(name)) == INADDR_NONE ? 0 : 1);\n-\n-      if (result)\n-        family = AF_INET;\n-    }\n-  if (family == AF_INET6)\n-    result = (ares_inet_pton(AF_INET6, name, &in6) < 1 ? 0 : 1);\n-\n-  if (!result)\n-    return 0;\n-\n-  if (family == AF_INET)\n-    {\n-      hostent.h_length = (int)sizeof(struct in_addr);\n-      addrs[0] = (char *)&in;\n-    }\n-  else if (family == AF_INET6)\n-    {\n-      hostent.h_length = (int)sizeof(struct ares_in6_addr);\n-      addrs[0] = (char *)&in6;\n-    }\n-  /* Duplicate the name, to avoid a constness violation. */\n-  hostent.h_name = strdup(name);\n-  if (!hostent.h_name)\n-    {\n-      callback(arg, ARES_ENOMEM, 0, NULL);\n-      return 1;\n-    }\n-\n-  /* Fill in the rest of the host structure and terminate the query. */\n-  addrs[1] = NULL;\n-  hostent.h_aliases = aliases;\n-  hostent.h_addrtype = family;\n-  hostent.h_addr_list = addrs;\n-  callback(arg, ARES_SUCCESS, 0, &hostent);\n-\n-  free((char *)(hostent.h_name));\n-  return 1;\n-}\n-\n-/* This is an API method */\n-int ares_gethostbyname_file(ares_channel channel, const char *name,\n-                            int family, struct hostent **host)\n-{\n-  int result;\n-\n-  /* We only take the channel to ensure that ares_init() been called. */\n-  if(channel == NULL)\n-    {\n-      /* Anything will do, really.  This seems fine, and is consistent with\n-         other error cases. */\n-      *host = NULL;\n-      return ARES_ENOTFOUND;\n-    }\n-\n-  /* Just chain to the internal implementation we use here; it's exactly\n-   * what we want.\n-   */\n-  result = file_lookup(name, family, host);\n-  if(result != ARES_SUCCESS)\n-    {\n-      /* We guarantee a NULL hostent on failure. */\n-      *host = NULL;\n-    }\n-  return result;\n-}\n-\n-static int file_lookup(const char *name, int family, struct hostent **host)\n-{\n-  FILE *fp;\n-  char **alias;\n-  int status;\n-  int error;\n-\n-#ifdef WIN32\n-  char PATH_HOSTS[MAX_PATH];\n-  win_platform platform;\n-\n-  PATH_HOSTS[0] = '\\0';\n-\n-  platform = ares__getplatform();\n-\n-  if (platform == WIN_NT) {\n-    char tmp[MAX_PATH];\n-    HKEY hkeyHosts;\n-\n-    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0, KEY_READ,\n-                     &hkeyHosts) == ERROR_SUCCESS)\n-    {\n-      DWORD dwLength = MAX_PATH;\n-      RegQueryValueEx(hkeyHosts, DATABASEPATH, NULL, NULL, (LPBYTE)tmp,\n-                      &dwLength);\n-      ExpandEnvironmentStrings(tmp, PATH_HOSTS, MAX_PATH);\n-      RegCloseKey(hkeyHosts);\n-    }\n-  }\n-  else if (platform == WIN_9X)\n-    GetWindowsDirectory(PATH_HOSTS, MAX_PATH);\n-  else\n-    return ARES_ENOTFOUND;\n-\n-  strcat(PATH_HOSTS, WIN_PATH_HOSTS);\n-\n-#elif defined(WATT32)\n-  extern const char *_w32_GetHostsFile (void);\n-  const char *PATH_HOSTS = _w32_GetHostsFile();\n-\n-  if (!PATH_HOSTS)\n-    return ARES_ENOTFOUND;\n-#endif\n-\n-  fp = fopen(PATH_HOSTS, \"r\");\n-  if (!fp)\n-    {\n-      error = ERRNO;\n-      switch(error)\n-        {\n-        case ENOENT:\n-        case ESRCH:\n-          return ARES_ENOTFOUND;\n-        default:\n-          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                         error, strerror(error)));\n-          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n-                         PATH_HOSTS));\n-          *host = NULL;\n-          return ARES_EFILE;\n-        }\n-    }\n-  while ((status = ares__get_hostent(fp, family, host)) == ARES_SUCCESS)\n-    {\n-      if (strcasecmp((*host)->h_name, name) == 0)\n-        break;\n-      for (alias = (*host)->h_aliases; *alias; alias++)\n-        {\n-          if (strcasecmp(*alias, name) == 0)\n-            break;\n-        }\n-      if (*alias)\n-        break;\n-      ares_free_hostent(*host);\n-    }\n-  fclose(fp);\n-  if (status == ARES_EOF)\n-    status = ARES_ENOTFOUND;\n-  if (status != ARES_SUCCESS)\n-    *host = NULL;\n-  return status;\n-}\n-\n-static void sort_addresses(struct hostent *host,\n-                           const struct apattern *sortlist, int nsort)\n-{\n-  struct in_addr a1, a2;\n-  int i1, i2, ind1, ind2;\n-\n-  /* This is a simple insertion sort, not optimized at all.  i1 walks\n-   * through the address list, with the loop invariant that everything\n-   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n-   * back through the list (via i2) until it is in sorted order.\n-   */\n-  for (i1 = 0; host->h_addr_list[i1]; i1++)\n-    {\n-      memcpy(&a1, host->h_addr_list[i1], sizeof(struct in_addr));\n-      ind1 = get_address_index(&a1, sortlist, nsort);\n-      for (i2 = i1 - 1; i2 >= 0; i2--)\n-        {\n-          memcpy(&a2, host->h_addr_list[i2], sizeof(struct in_addr));\n-          ind2 = get_address_index(&a2, sortlist, nsort);\n-          if (ind2 <= ind1)\n-            break;\n-          memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct in_addr));\n-        }\n-      memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct in_addr));\n-    }\n-}\n-\n-/* Find the first entry in sortlist which matches addr.  Return nsort\n- * if none of them match.\n- */\n-static int get_address_index(const struct in_addr *addr,\n-                             const struct apattern *sortlist,\n-                             int nsort)\n-{\n-  int i;\n-\n-  for (i = 0; i < nsort; i++)\n-    {\n-      if (sortlist[i].family != AF_INET)\n-        continue;\n-      if (sortlist[i].type == PATTERN_MASK)\n-        {\n-          if ((addr->s_addr & sortlist[i].mask.addr4.s_addr)\n-              == sortlist[i].addrV4.s_addr)\n-            break;\n-        }\n-      else\n-        {\n-          if (!ares_bitncmp(&addr->s_addr, &sortlist[i].addrV4.s_addr,\n-                            sortlist[i].mask.bits))\n-            break;\n-        }\n-    }\n-  return i;\n-}\n-\n-static void sort6_addresses(struct hostent *host,\n-                            const struct apattern *sortlist, int nsort)\n-{\n-  struct ares_in6_addr a1, a2;\n-  int i1, i2, ind1, ind2;\n-\n-  /* This is a simple insertion sort, not optimized at all.  i1 walks\n-   * through the address list, with the loop invariant that everything\n-   * to the left of i1 is sorted.  In the loop body, the value at i1 is moved\n-   * back through the list (via i2) until it is in sorted order.\n-   */\n-  for (i1 = 0; host->h_addr_list[i1]; i1++)\n-    {\n-      memcpy(&a1, host->h_addr_list[i1], sizeof(struct ares_in6_addr));\n-      ind1 = get6_address_index(&a1, sortlist, nsort);\n-      for (i2 = i1 - 1; i2 >= 0; i2--)\n-        {\n-          memcpy(&a2, host->h_addr_list[i2], sizeof(struct ares_in6_addr));\n-          ind2 = get6_address_index(&a2, sortlist, nsort);\n-          if (ind2 <= ind1)\n-            break;\n-          memcpy(host->h_addr_list[i2 + 1], &a2, sizeof(struct ares_in6_addr));\n-        }\n-      memcpy(host->h_addr_list[i2 + 1], &a1, sizeof(struct ares_in6_addr));\n-    }\n-}\n-\n-/* Find the first entry in sortlist which matches addr.  Return nsort\n- * if none of them match.\n- */\n-static int get6_address_index(const struct ares_in6_addr *addr,\n-                              const struct apattern *sortlist,\n-                              int nsort)\n-{\n-  int i;\n-\n-  for (i = 0; i < nsort; i++)\n-    {\n-      if (sortlist[i].family != AF_INET6)\n-        continue;\n-        if (!ares_bitncmp(addr,\n-                          &sortlist[i].addrV6,\n-                          sortlist[i].mask.bits))\n-          break;\n-    }\n-  return i;\n-}"}, {"sha": "82e261dae41a0a3c7fef4cebba65386a3ca2d4a2", "filename": "src/rt/libuv/src/ares/ares_getnameinfo.c", "status": "removed", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getnameinfo.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,427 +0,0 @@\n-\n-/* Copyright 2005 by Dominick Meglio\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_GETSERVBYPORT_R\n-#  if !defined(GETSERVBYPORT_R_ARGS) || \\\n-     (GETSERVBYPORT_R_ARGS < 4) || (GETSERVBYPORT_R_ARGS > 6)\n-#    error \"you MUST specifiy a valid number of arguments for getservbyport_r\"\n-#  endif\n-#endif\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_NET_IF_H\n-#include <net/if.h>\n-#endif\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"ares.h\"\n-#include \"ares_ipv6.h\"\n-#include \"inet_ntop.h\"\n-#include \"ares_nowarn.h\"\n-#include \"ares_private.h\"\n-\n-struct nameinfo_query {\n-  ares_nameinfo_callback callback;\n-  void *arg;\n-  union {\n-    struct sockaddr_in addr4;\n-    struct sockaddr_in6 addr6;\n-  } addr;\n-  int family;\n-  int flags;\n-  int timeouts;\n-};\n-\n-#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n-#define IPBUFSIZ \\\n-        (sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\") + IF_NAMESIZE)\n-#else\n-#define IPBUFSIZ \\\n-        (sizeof(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\"))\n-#endif\n-\n-static void nameinfo_callback(void *arg, int status, int timeouts,\n-                              struct hostent *host);\n-static char *lookup_service(unsigned short port, int flags,\n-                            char *buf, size_t buflen);\n-#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n-static void append_scopeid(struct sockaddr_in6 *addr6, unsigned int scopeid,\n-                           char *buf, size_t buflen);\n-#endif\n-static char *ares_striendstr(const char *s1, const char *s2);\n-\n-void ares_getnameinfo(ares_channel channel, const struct sockaddr *sa,\n-                      ares_socklen_t salen,\n-                      int flags, ares_nameinfo_callback callback, void *arg)\n-{\n-  struct sockaddr_in *addr = NULL;\n-  struct sockaddr_in6 *addr6 = NULL;\n-  struct nameinfo_query *niquery;\n-  unsigned int port = 0;\n-\n-  /* Validate socket address family and length */\n-  if ((sa->sa_family == AF_INET) &&\n-      (salen == sizeof(struct sockaddr_in)))\n-    {\n-      addr = (struct sockaddr_in *)sa;\n-      port = addr->sin_port;\n-    }\n-  else if ((sa->sa_family == AF_INET6) &&\n-           (salen == sizeof(struct sockaddr_in6)))\n-    {\n-      addr6 = (struct sockaddr_in6 *)sa;\n-      port = addr6->sin6_port;\n-    }\n-  else\n-    {\n-      callback(arg, ARES_ENOTIMP, 0, NULL, NULL);\n-      return;\n-    }\n-\n-  /* If neither, assume they want a host */\n-  if (!(flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST))\n-    flags |= ARES_NI_LOOKUPHOST;\n-\n-  /* All they want is a service, no need for DNS */\n-  if ((flags & ARES_NI_LOOKUPSERVICE) && !(flags & ARES_NI_LOOKUPHOST))\n-    {\n-      char buf[33], *service;\n-\n-      service = lookup_service((unsigned short)(port & 0xffff),\n-                               flags, buf, sizeof(buf));\n-      callback(arg, ARES_SUCCESS, 0, NULL, service);\n-      return;\n-    }\n-\n-  /* They want a host lookup */\n-  if ((flags & ARES_NI_LOOKUPHOST))\n-    {\n-     /* A numeric host can be handled without DNS */\n-     if ((flags & ARES_NI_NUMERICHOST))\n-      {\n-        char ipbuf[IPBUFSIZ];\n-        char srvbuf[33];\n-        char *service = NULL;\n-        ipbuf[0] = 0;\n-\n-        /* Specifying not to lookup a host, but then saying a host\n-         * is required has to be illegal.\n-         */\n-        if (flags & ARES_NI_NAMEREQD)\n-          {\n-            callback(arg, ARES_EBADFLAGS, 0, NULL, NULL);\n-            return;\n-          }\n-        if (salen == sizeof(struct sockaddr_in6))\n-          {\n-            ares_inet_ntop(AF_INET6, &addr6->sin6_addr, ipbuf, IPBUFSIZ);\n-            /* If the system supports scope IDs, use it */\n-#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n-            append_scopeid(addr6, flags, ipbuf, sizeof(ipbuf));\n-#endif\n-          }\n-        else\n-          {\n-            ares_inet_ntop(AF_INET, &addr->sin_addr, ipbuf, IPBUFSIZ);\n-          }\n-        /* They also want a service */\n-        if (flags & ARES_NI_LOOKUPSERVICE)\n-          service = lookup_service((unsigned short)(port & 0xffff),\n-                                   flags, srvbuf, sizeof(srvbuf));\n-        callback(arg, ARES_SUCCESS, 0, ipbuf, service);\n-        return;\n-      }\n-    /* This is where a DNS lookup becomes necessary */\n-    else\n-      {\n-        niquery = malloc(sizeof(struct nameinfo_query));\n-        if (!niquery)\n-          {\n-            callback(arg, ARES_ENOMEM, 0, NULL, NULL);\n-            return;\n-          }\n-        niquery->callback = callback;\n-        niquery->arg = arg;\n-        niquery->flags = flags;\n-        niquery->timeouts = 0;\n-        if (sa->sa_family == AF_INET)\n-          {\n-            niquery->family = AF_INET;\n-            memcpy(&niquery->addr.addr4, addr, sizeof(struct in_addr));\n-            ares_gethostbyaddr(channel, &addr->sin_addr,\n-                               sizeof(struct in_addr), AF_INET,\n-                               nameinfo_callback, niquery);\n-          }\n-        else\n-          {\n-            niquery->family = AF_INET6;\n-            memcpy(&niquery->addr.addr6, addr6, sizeof(struct ares_in6_addr));\n-            ares_gethostbyaddr(channel, &addr6->sin6_addr,\n-                               sizeof(struct ares_in6_addr), AF_INET6,\n-                               nameinfo_callback, niquery);\n-          }\n-      }\n-    }\n-}\n-\n-static void nameinfo_callback(void *arg, int status, int timeouts,\n-                              struct hostent *host)\n-{\n-  struct nameinfo_query *niquery = (struct nameinfo_query *) arg;\n-  char srvbuf[33];\n-  char *service = NULL;\n-\n-  niquery->timeouts += timeouts;\n-  if (status == ARES_SUCCESS)\n-    {\n-      /* They want a service too */\n-      if (niquery->flags & ARES_NI_LOOKUPSERVICE)\n-        {\n-          if (niquery->family == AF_INET)\n-            service = lookup_service(niquery->addr.addr4.sin_port,\n-                                     niquery->flags, srvbuf, sizeof(srvbuf));\n-          else\n-            service = lookup_service(niquery->addr.addr6.sin6_port,\n-                                     niquery->flags, srvbuf, sizeof(srvbuf));\n-        }\n-      /* NOFQDN means we have to strip off the domain name portion.  We do\n-         this by determining our own domain name, then searching the string\n-         for this domain name and removing it.\n-       */\n-#ifdef HAVE_GETHOSTNAME\n-      if (niquery->flags & ARES_NI_NOFQDN)\n-        {\n-           char buf[255];\n-           char *domain;\n-           gethostname(buf, 255);\n-           if ((domain = strchr(buf, '.')) != NULL)\n-             {\n-               char *end = ares_striendstr(host->h_name, domain);\n-               if (end)\n-                 *end = 0;\n-             }\n-        }\n-#endif\n-      niquery->callback(niquery->arg, ARES_SUCCESS, niquery->timeouts,\n-                        (char *)(host->h_name),\n-                        service);\n-      free(niquery);\n-      return;\n-    }\n-  /* We couldn't find the host, but it's OK, we can use the IP */\n-  else if (status == ARES_ENOTFOUND && !(niquery->flags & ARES_NI_NAMEREQD))\n-    {\n-      char ipbuf[IPBUFSIZ];\n-      if (niquery->family == AF_INET)\n-        ares_inet_ntop(AF_INET, &niquery->addr.addr4.sin_addr, ipbuf,\n-                       IPBUFSIZ);\n-      else\n-        {\n-          ares_inet_ntop(AF_INET6, &niquery->addr.addr6.sin6_addr, ipbuf,\n-                         IPBUFSIZ);\n-#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n-          append_scopeid(&niquery->addr.addr6, niquery->flags, ipbuf,\n-                         sizeof(ipbuf));\n-#endif\n-        }\n-      /* They want a service too */\n-      if (niquery->flags & ARES_NI_LOOKUPSERVICE)\n-        {\n-          if (niquery->family == AF_INET)\n-            service = lookup_service(niquery->addr.addr4.sin_port,\n-                                     niquery->flags, srvbuf, sizeof(srvbuf));\n-          else\n-            service = lookup_service(niquery->addr.addr6.sin6_port,\n-                                     niquery->flags, srvbuf, sizeof(srvbuf));\n-        }\n-      niquery->callback(niquery->arg, ARES_SUCCESS, niquery->timeouts, ipbuf,\n-                        service);\n-      free(niquery);\n-      return;\n-    }\n-  niquery->callback(niquery->arg, status, niquery->timeouts, NULL, NULL);\n-  free(niquery);\n-}\n-\n-static char *lookup_service(unsigned short port, int flags,\n-                            char *buf, size_t buflen)\n-{\n-  const char *proto;\n-  struct servent *sep;\n-#ifdef HAVE_GETSERVBYPORT_R\n-  struct servent se;\n-#endif\n-  char tmpbuf[4096];\n-\n-  if (port)\n-    {\n-      if (flags & ARES_NI_NUMERICSERV)\n-        sep = NULL;\n-      else\n-        {\n-          if (flags & ARES_NI_UDP)\n-            proto = \"udp\";\n-          else if (flags & ARES_NI_SCTP)\n-            proto = \"sctp\";\n-          else if (flags & ARES_NI_DCCP)\n-            proto = \"dccp\";\n-          else\n-            proto = \"tcp\";\n-#ifdef HAVE_GETSERVBYPORT_R\n-          sep = &se;\n-          memset(tmpbuf, 0, sizeof(tmpbuf));\n-#if GETSERVBYPORT_R_ARGS == 6\n-          if (getservbyport_r(port, proto, &se, (void *)tmpbuf,\n-                              sizeof(tmpbuf), &sep) != 0)\n-            sep = NULL;\n-#elif GETSERVBYPORT_R_ARGS == 5\n-          sep = getservbyport_r(port, proto, &se, (void *)tmpbuf,\n-                                sizeof(tmpbuf));\n-#elif GETSERVBYPORT_R_ARGS == 4\n-          if (getservbyport_r(port, proto, &se, (void *)tmpbuf) != 0)\n-            sep = NULL;\n-#else\n-          /* Lets just hope the OS uses TLS! */\n-          sep = getservbyport(port, proto);\n-#endif\n-#else\n-          /* Lets just hope the OS uses TLS! */\n-#if (defined(NETWARE) && !defined(__NOVELL_LIBC__))\n-          sep = getservbyport(port, (char*)proto);\n-#else\n-          sep = getservbyport(port, proto);\n-#endif\n-#endif\n-        }\n-      if (sep && sep->s_name)\n-        /* get service name */\n-        strcpy(tmpbuf, sep->s_name);\n-      else\n-        /* get port as a string */\n-        sprintf(tmpbuf, \"%u\", (unsigned int)ntohs(port));\n-      if (strlen(tmpbuf) < buflen)\n-        /* return it if buffer big enough */\n-        strcpy(buf, tmpbuf);\n-      else\n-        /* avoid reusing previous one */\n-        buf[0] = '\\0';\n-      return buf;\n-    }\n-  buf[0] = '\\0';\n-  return NULL;\n-}\n-\n-#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID\n-static void append_scopeid(struct sockaddr_in6 *addr6, unsigned int flags,\n-                           char *buf, size_t buflen)\n-{\n-#ifdef HAVE_IF_INDEXTONAME\n-  int is_ll, is_mcll;\n-#endif\n-  static const char fmt_u[] = \"%u\";\n-  static const char fmt_lu[] = \"%lu\";\n-  char tmpbuf[IF_NAMESIZE + 2];\n-  size_t bufl;\n-  const char *fmt = (sizeof(addr6->sin6_scope_id) > sizeof(unsigned int))?\n-    fmt_lu:fmt_u;\n-\n-  tmpbuf[0] = '%';\n-\n-#ifdef HAVE_IF_INDEXTONAME\n-  is_ll = IN6_IS_ADDR_LINKLOCAL(&addr6->sin6_addr);\n-  is_mcll = IN6_IS_ADDR_MC_LINKLOCAL(&addr6->sin6_addr);\n-  if ((flags & ARES_NI_NUMERICSCOPE) ||\n-      (!is_ll && !is_mcll))\n-    {\n-       sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n-    }\n-  else\n-    {\n-      if (if_indextoname(addr6->sin6_scope_id, &tmpbuf[1]) == NULL)\n-        sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n-    }\n-#else\n-  sprintf(&tmpbuf[1], fmt, addr6->sin6_scope_id);\n-  (void) flags;\n-#endif\n-  tmpbuf[IF_NAMESIZE + 1] = '\\0';\n-  bufl = strlen(buf);\n-\n-  if(bufl + strlen(tmpbuf) < buflen)\n-    /* only append the scopeid string if it fits in the target buffer */\n-    strcpy(&buf[bufl], tmpbuf);\n-}\n-#endif\n-\n-/* Determines if s1 ends with the string in s2 (case-insensitive) */\n-static char *ares_striendstr(const char *s1, const char *s2)\n-{\n-  const char *c1, *c2, *c1_begin;\n-  int lo1, lo2;\n-  size_t s1_len = strlen(s1), s2_len = strlen(s2);\n-\n-  /* If the substr is longer than the full str, it can't match */\n-  if (s2_len > s1_len)\n-    return NULL;\n-\n-  /* Jump to the end of s1 minus the length of s2 */\n-  c1_begin = s1+s1_len-s2_len;\n-  c1 = (const char *)c1_begin;\n-  c2 = s2;\n-  while (c2 < s2+s2_len)\n-    {\n-      lo1 = TOLOWER(*c1);\n-      lo2 = TOLOWER(*c2);\n-      if (lo1 != lo2)\n-        return NULL;\n-      else\n-        {\n-          c1++;\n-          c2++;\n-        }\n-    }\n-  if (c2 == c1 && c2 == NULL)\n-    return (char *)c1_begin;\n-  return NULL;\n-}"}, {"sha": "1e02d086866ed8440bc2e6143f1e4e7f8e8f5afc", "filename": "src/rt/libuv/src/ares/ares_getopt.c", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,122 +0,0 @@\n-/*\n- * Original file name getopt.c  Initial import into the c-ares source tree\n- * on 2007-04-11.  Lifted from version 5.2 of the 'Open Mash' project with\n- * the modified BSD license, BSD license without the advertising clause.\n- *\n- */\n-\n-/*\n- * getopt.c --\n- *\n- *      Standard UNIX getopt function.  Code is from BSD.\n- *\n- * Copyright (c) 1987-2001 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- * A. Redistributions of source code must retain the above copyright notice,\n- *    this list of conditions and the following disclaimer.\n- * B. Redistributions in binary form must reproduce the above copyright notice,\n- *    this list of conditions and the following disclaimer in the documentation\n- *    and/or other materials provided with the distribution.\n- * C. Neither the names of the copyright holders nor the names of its\n- *    contributors may be used to endorse or promote products derived from this\n- *    software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS\n- * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-/* #if !defined(lint)\n- * static char sccsid[] = \"@(#)getopt.c 8.2 (Berkeley) 4/2/94\";\n- * #endif\n- */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares_getopt.h\"\n-\n-int   opterr = 1,     /* if error message should be printed */\n-      optind = 1;     /* index into parent argv vector */\n-int   optopt = 0;     /* character checked for validity */\n-static int optreset;  /* reset getopt */\n-char  *optarg;        /* argument associated with option */\n-\n-#define  BADCH   (int)'?'\n-#define  BADARG  (int)':'\n-#define  EMSG    (char *)\"\"\n-\n-/*\n- * ares_getopt --\n- *    Parse argc/argv argument vector.\n- */\n-int\n-ares_getopt(int nargc, char * const nargv[], const char *ostr)\n-{\n-    static char *place = EMSG;                /* option letter processing */\n-    char *oli;                                /* option letter list index */\n-\n-    if (optreset || !*place) {                /* update scanning pointer */\n-        optreset = 0;\n-        if (optind >= nargc || *(place = nargv[optind]) != '-') {\n-            place = EMSG;\n-            return (EOF);\n-        }\n-        if (place[1] && *++place == '-') {    /* found \"--\" */\n-            ++optind;\n-            place = EMSG;\n-            return (EOF);\n-        }\n-    }                                         /* option letter okay? */\n-    if ((optopt = (int)*place++) == (int)':' ||\n-        (oli = strchr(ostr, optopt)) == NULL) {\n-        /*\n-         * if the user didn't specify '-' as an option,\n-         * assume it means EOF.\n-         */\n-        if (optopt == (int)'-')\n-            return (EOF);\n-        if (!*place)\n-            ++optind;\n-        if (opterr && *ostr != ':')\n-            (void)fprintf(stderr,\n-                \"%s: illegal option -- %c\\n\", __FILE__, optopt);\n-        return (BADCH);\n-    }\n-    if (*++oli != ':') {                      /* don't need argument */\n-        optarg = NULL;\n-        if (!*place)\n-            ++optind;\n-    }\n-    else {                                    /* need an argument */\n-        if (*place)                           /* no white space */\n-            optarg = place;\n-        else if (nargc <= ++optind) {         /* no arg */\n-            place = EMSG;\n-            if (*ostr == ':')\n-                return (BADARG);\n-            if (opterr)\n-                (void)fprintf(stderr,\n-                    \"%s: option requires an argument -- %c\\n\",\n-                    __FILE__, optopt);\n-            return (BADCH);\n-        }\n-         else                                 /* white space */\n-            optarg = nargv[optind];\n-        place = EMSG;\n-        ++optind;\n-    }\n-    return (optopt);                          /* dump back option letter */\n-}"}, {"sha": "63acb3b42323d70984caa1dd5762c50d677d5174", "filename": "src/rt/libuv/src/ares/ares_getopt.h", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getopt.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,53 +0,0 @@\n-#ifndef ARES_GETOPT_H\n-#define ARES_GETOPT_H\n-\n-/*\n- * Copyright (c) 1987-2001 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- * A. Redistributions of source code must retain the above copyright notice,\n- *    this list of conditions and the following disclaimer.\n- * B. Redistributions in binary form must reproduce the above copyright notice,\n- *    this list of conditions and the following disclaimer in the documentation\n- *    and/or other materials provided with the distribution.\n- * C. Neither the names of the copyright holders nor the names of its\n- *    contributors may be used to endorse or promote products derived from this\n- *    software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS\n- * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-\n-int ares_getopt(int nargc, char * const nargv[], const char *ostr);\n-\n-#undef optarg\n-#undef optind\n-#undef opterr\n-#undef optopt\n-#undef optreset\n-\n-#define optarg   ares_optarg\n-#define optind   ares_optind\n-#define opterr   ares_opterr\n-#define optopt   ares_optopt\n-#define optreset ares_optreset\n-\n-extern char *optarg;\n-extern int optind;\n-extern int opterr;\n-extern int optopt;\n-\n-#endif /* ARES_GETOPT_H */"}, {"sha": "72e467f2e63758a3bdb4e787c991e03cdf5d714d", "filename": "src/rt/libuv/src/ares/ares_getsock.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_getsock.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,72 +0,0 @@\n-\n-/* Copyright (C) 2005 - 2010, Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this software and its\n- * documentation for any purpose and without fee is hereby granted, provided\n- * that the above copyright notice appear in all copies and that both that\n- * copyright notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in advertising or\n- * publicity pertaining to distribution of the software without specific,\n- * written prior permission.  M.I.T. makes no representations about the\n- * suitability of this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys/time.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-int ares_getsock(ares_channel channel,\n-                 ares_socket_t *socks,\n-                 int numsocks) /* size of the 'socks' array */\n-{\n-  struct server_state *server;\n-  int i;\n-  int sockindex=0;\n-  int bitmap = 0;\n-  unsigned int setbits = 0xffffffff;\n-\n-  /* Are there any active queries? */\n-  int active_queries = !ares__is_list_empty(&(channel->all_queries));\n-\n-  for (i = 0;\n-       (i < channel->nservers) && (sockindex < ARES_GETSOCK_MAXNUM);\n-       i++)\n-    {\n-      server = &channel->servers[i];\n-      /* We only need to register interest in UDP sockets if we have\n-       * outstanding queries.\n-       */\n-      if (active_queries && server->udp_socket != ARES_SOCKET_BAD)\n-        {\n-          if(sockindex >= numsocks)\n-            break;\n-          socks[sockindex] = server->udp_socket;\n-          bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n-          sockindex++;\n-        }\n-      /* We always register for TCP events, because we want to know\n-       * when the other side closes the connection, so we don't waste\n-       * time trying to use a broken connection.\n-       */\n-      if (server->tcp_socket != ARES_SOCKET_BAD)\n-       {\n-         if(sockindex >= numsocks)\n-           break;\n-         socks[sockindex] = server->tcp_socket;\n-         bitmap |= ARES_GETSOCK_READABLE(setbits, sockindex);\n-\n-         if (server->qhead && active_queries)\n-           /* then the tcp socket is also writable! */\n-           bitmap |= ARES_GETSOCK_WRITABLE(setbits, sockindex);\n-\n-         sockindex++;\n-       }\n-    }\n-  return bitmap;\n-}"}, {"sha": "52bb4d6c8941ed163197fbe80c1c699c9ef864dd", "filename": "src/rt/libuv/src/ares/ares_init.c", "status": "removed", "additions": 0, "deletions": 1809, "changes": 1809, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_init.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,1809 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2007-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_PARAM_H\n-#include <sys/param.h>\n-#endif\n-\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys/time.h>\n-#endif\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <ctype.h>\n-#include <time.h>\n-\n-#ifdef ANDROID\n-#include <sys/system_properties.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"inet_net_pton.h\"\n-#include \"ares_library_init.h\"\n-#include \"ares_nowarn.h\"\n-#include \"ares_platform.h\"\n-#include \"inet_ntop.h\"\n-#include \"ares_private.h\"\n-\n-#ifdef WATT32\n-#undef WIN32  /* Redefined in MingW/MSVC headers */\n-#endif\n-\n-static int init_by_options(ares_channel channel, const struct ares_options *options,\n-                           int optmask);\n-static int init_by_environment(ares_channel channel);\n-static int init_by_resolv_conf(ares_channel channel);\n-static int init_by_defaults(ares_channel channel);\n-\n-#ifndef WATT32\n-static int config_nameserver(struct server_state **servers, int *nservers,\n-                             char *str);\n-#endif\n-static int set_search(ares_channel channel, const char *str);\n-static int set_options(ares_channel channel, const char *str);\n-static const char *try_option(const char *p, const char *q, const char *opt);\n-static int init_id_key(rc4_key* key,int key_data_len);\n-\n-#if !defined(WIN32) && !defined(WATT32)\n-static int sortlist_alloc(struct apattern **sortlist, int *nsort, struct apattern *pat);\n-static int ip_addr(const char *s, ssize_t len, struct in_addr *addr);\n-static void natural_mask(struct apattern *pat);\n-static int config_domain(ares_channel channel, char *str);\n-static int config_lookup(ares_channel channel, const char *str,\n-                         const char *bindch, const char *filech);\n-static int config_sortlist(struct apattern **sortlist, int *nsort,\n-                           const char *str);\n-static char *try_config(char *s, const char *opt, char scc);\n-#endif\n-\n-#define ARES_CONFIG_CHECK(x) (x->lookups && x->nsort > -1 && \\\n-                             x->nservers > -1 && \\\n-                             x->ndomains > -1 && \\\n-                             x->ndots > -1 && x->timeout > -1 && \\\n-                             x->tries > -1)\n-\n-int ares_init(ares_channel *channelptr)\n-{\n-  return ares_init_options(channelptr, NULL, 0);\n-}\n-\n-int ares_init_options(ares_channel *channelptr, struct ares_options *options,\n-                      int optmask)\n-{\n-  ares_channel channel;\n-  int i;\n-  int status = ARES_SUCCESS;\n-  struct timeval now;\n-\n-#ifdef CURLDEBUG\n-  const char *env = getenv(\"CARES_MEMDEBUG\");\n-\n-  if (env)\n-    curl_memdebug(env);\n-  env = getenv(\"CARES_MEMLIMIT\");\n-  if (env) {\n-    char *endptr;\n-    long num = strtol(env, &endptr, 10);\n-    if((endptr != env) && (endptr == env + strlen(env)) && (num > 0))\n-      curl_memlimit(num);\n-  }\n-#endif\n-\n-  if (ares_library_initialized() != ARES_SUCCESS)\n-    return ARES_ENOTINITIALIZED;\n-\n-  channel = malloc(sizeof(struct ares_channeldata));\n-  if (!channel) {\n-    *channelptr = NULL;\n-    return ARES_ENOMEM;\n-  }\n-\n-  now = ares__tvnow();\n-\n-  /* Set everything to distinguished values so we know they haven't\n-   * been set yet.\n-   */\n-  channel->flags = -1;\n-  channel->timeout = -1;\n-  channel->tries = -1;\n-  channel->ndots = -1;\n-  channel->rotate = -1;\n-  channel->udp_port = -1;\n-  channel->tcp_port = -1;\n-  channel->socket_send_buffer_size = -1;\n-  channel->socket_receive_buffer_size = -1;\n-  channel->nservers = -1;\n-  channel->ndomains = -1;\n-  channel->nsort = -1;\n-  channel->tcp_connection_generation = 0;\n-  channel->lookups = NULL;\n-  channel->domains = NULL;\n-  channel->sortlist = NULL;\n-  channel->servers = NULL;\n-  channel->sock_state_cb = NULL;\n-  channel->sock_state_cb_data = NULL;\n-  channel->sock_create_cb = NULL;\n-  channel->sock_create_cb_data = NULL;\n-\n-  channel->last_server = 0;\n-  channel->last_timeout_processed = (time_t)now.tv_sec;\n-\n-  memset(&channel->local_dev_name, 0, sizeof(channel->local_dev_name));\n-  channel->local_ip4 = 0;\n-  memset(&channel->local_ip6, 0, sizeof(channel->local_ip6));\n-\n-  /* Initialize our lists of queries */\n-  ares__init_list_head(&(channel->all_queries));\n-  for (i = 0; i < ARES_QID_TABLE_SIZE; i++)\n-    {\n-      ares__init_list_head(&(channel->queries_by_qid[i]));\n-    }\n-  for (i = 0; i < ARES_TIMEOUT_TABLE_SIZE; i++)\n-    {\n-      ares__init_list_head(&(channel->queries_by_timeout[i]));\n-    }\n-\n-  /* Initialize configuration by each of the four sources, from highest\n-   * precedence to lowest.\n-   */\n-\n-  if (status == ARES_SUCCESS) {\n-    status = init_by_options(channel, options, optmask);\n-    if (status != ARES_SUCCESS)\n-      DEBUGF(fprintf(stderr, \"Error: init_by_options failed: %s\\n\",\n-                     ares_strerror(status)));\n-  }\n-  if (status == ARES_SUCCESS) {\n-    status = init_by_environment(channel);\n-    if (status != ARES_SUCCESS)\n-      DEBUGF(fprintf(stderr, \"Error: init_by_environment failed: %s\\n\",\n-                     ares_strerror(status)));\n-  }\n-  if (status == ARES_SUCCESS) {\n-    status = init_by_resolv_conf(channel);\n-    if (status != ARES_SUCCESS)\n-      DEBUGF(fprintf(stderr, \"Error: init_by_resolv_conf failed: %s\\n\",\n-                     ares_strerror(status)));\n-  }\n-\n-  /*\n-   * No matter what failed or succeeded, seed defaults to provide\n-   * useful behavior for things that we missed.\n-   */\n-  status = init_by_defaults(channel);\n-  if (status != ARES_SUCCESS)\n-    DEBUGF(fprintf(stderr, \"Error: init_by_defaults failed: %s\\n\",\n-                   ares_strerror(status)));\n-\n-  /* Generate random key */\n-\n-  if (status == ARES_SUCCESS) {\n-    status = init_id_key(&channel->id_key, ARES_ID_KEY_LEN);\n-    if (status == ARES_SUCCESS)\n-      channel->next_id = ares__generate_new_id(&channel->id_key);\n-    else\n-      DEBUGF(fprintf(stderr, \"Error: init_id_key failed: %s\\n\",\n-                     ares_strerror(status)));\n-  }\n-\n-  if (status != ARES_SUCCESS)\n-    {\n-      /* Something failed; clean up memory we may have allocated. */\n-      if (channel->servers)\n-        free(channel->servers);\n-      if (channel->domains)\n-        {\n-          for (i = 0; i < channel->ndomains; i++)\n-            free(channel->domains[i]);\n-          free(channel->domains);\n-        }\n-      if (channel->sortlist)\n-        free(channel->sortlist);\n-      if(channel->lookups)\n-        free(channel->lookups);\n-      free(channel);\n-      return status;\n-    }\n-\n-  /* Trim to one server if ARES_FLAG_PRIMARY is set. */\n-  if ((channel->flags & ARES_FLAG_PRIMARY) && channel->nservers > 1)\n-    channel->nservers = 1;\n-\n-  ares__init_servers_state(channel);\n-\n-  *channelptr = channel;\n-  return ARES_SUCCESS;\n-}\n-\n-/* ares_dup() duplicates a channel handle with all its options and returns a\n-   new channel handle */\n-int ares_dup(ares_channel *dest, ares_channel src)\n-{\n-  struct ares_options opts;\n-  struct ares_addr_node *servers;\n-  int ipv6_nservers = 0;\n-  int i, rc;\n-  int optmask;\n-\n-  *dest = NULL; /* in case of failure return NULL explicitly */\n-\n-  /* First get the options supported by the old ares_save_options() function,\n-     which is most of them */\n-  rc = ares_save_options(src, &opts, &optmask);\n-  if(rc)\n-    return rc;\n-\n-  /* Then create the new channel with those options */\n-  rc = ares_init_options(dest, &opts, optmask);\n-\n-  /* destroy the options copy to not leak any memory */\n-  ares_destroy_options(&opts);\n-\n-  if(rc)\n-    return rc;\n-\n-  /* Now clone the options that ares_save_options() doesn't support. */\n-  (*dest)->sock_create_cb      = src->sock_create_cb;\n-  (*dest)->sock_create_cb_data = src->sock_create_cb_data;\n-\n-  strncpy((*dest)->local_dev_name, src->local_dev_name, sizeof(src->local_dev_name));\n-  (*dest)->local_ip4 = src->local_ip4;\n-  memcpy((*dest)->local_ip6, src->local_ip6, sizeof(src->local_ip6));\n-\n-  /* Full name server cloning required when not all are IPv4 */\n-  for (i = 0; i < src->nservers; i++)\n-    {\n-      if (src->servers[i].addr.family != AF_INET) {\n-        ipv6_nservers++;\n-        break;\n-      }\n-    }\n-  if (ipv6_nservers) {\n-    rc = ares_get_servers(src, &servers);\n-    if (rc != ARES_SUCCESS)\n-      return rc;\n-    rc = ares_set_servers(*dest, servers);\n-    ares_free_data(servers);\n-    if (rc != ARES_SUCCESS)\n-      return rc;\n-  }\n-\n-  return ARES_SUCCESS; /* everything went fine */\n-}\n-\n-/* Save options from initialized channel */\n-int ares_save_options(ares_channel channel, struct ares_options *options,\n-                      int *optmask)\n-{\n-  int i, j;\n-  int ipv4_nservers = 0;\n-\n-  /* Zero everything out */\n-  memset(options, 0, sizeof(struct ares_options));\n-\n-  if (!ARES_CONFIG_CHECK(channel))\n-    return ARES_ENODATA;\n-\n-  /* Traditionally the optmask wasn't saved in the channel struct so it was\n-     recreated here. ROTATE is the first option that has no struct field of\n-     its own in the public config struct */\n-  (*optmask) = (ARES_OPT_FLAGS|ARES_OPT_TRIES|ARES_OPT_NDOTS|\n-                ARES_OPT_UDP_PORT|ARES_OPT_TCP_PORT|ARES_OPT_SOCK_STATE_CB|\n-                ARES_OPT_SERVERS|ARES_OPT_DOMAINS|ARES_OPT_LOOKUPS|\n-                ARES_OPT_SORTLIST|ARES_OPT_TIMEOUTMS) |\n-    (channel->optmask & ARES_OPT_ROTATE);\n-\n-  /* Copy easy stuff */\n-  options->flags   = channel->flags;\n-\n-  /* We return full millisecond resolution but that's only because we don't\n-     set the ARES_OPT_TIMEOUT anymore, only the new ARES_OPT_TIMEOUTMS */\n-  options->timeout = channel->timeout;\n-  options->tries   = channel->tries;\n-  options->ndots   = channel->ndots;\n-  options->udp_port = (unsigned short)channel->udp_port;\n-  options->tcp_port = (unsigned short)channel->tcp_port;\n-  options->sock_state_cb     = channel->sock_state_cb;\n-  options->sock_state_cb_data = channel->sock_state_cb_data;\n-\n-  /* Copy IPv4 servers */\n-  if (channel->nservers) {\n-    for (i = 0; i < channel->nservers; i++)\n-    {\n-      if (channel->servers[i].addr.family == AF_INET)\n-        ipv4_nservers++;\n-    }\n-    if (ipv4_nservers) {\n-      options->servers = malloc(ipv4_nservers * sizeof(struct in_addr));\n-      if (!options->servers)\n-        return ARES_ENOMEM;\n-      for (i = j = 0; i < channel->nservers; i++)\n-      {\n-        if (channel->servers[i].addr.family == AF_INET)\n-          memcpy(&options->servers[j++],\n-                 &channel->servers[i].addr.addrV4,\n-                 sizeof(channel->servers[i].addr.addrV4));\n-      }\n-    }\n-  }\n-  options->nservers = ipv4_nservers;\n-\n-  /* copy domains */\n-  if (channel->ndomains) {\n-    options->domains = malloc(channel->ndomains * sizeof(char *));\n-    if (!options->domains)\n-      return ARES_ENOMEM;\n-\n-    for (i = 0; i < channel->ndomains; i++)\n-    {\n-      options->ndomains = i;\n-      options->domains[i] = strdup(channel->domains[i]);\n-      if (!options->domains[i])\n-        return ARES_ENOMEM;\n-    }\n-  }\n-  options->ndomains = channel->ndomains;\n-\n-  /* copy lookups */\n-  if (channel->lookups) {\n-    options->lookups = strdup(channel->lookups);\n-    if (!options->lookups && channel->lookups)\n-      return ARES_ENOMEM;\n-  }\n-\n-  /* copy sortlist */\n-  if (channel->nsort) {\n-    options->sortlist = malloc(channel->nsort * sizeof(struct apattern));\n-    if (!options->sortlist)\n-      return ARES_ENOMEM;\n-    for (i = 0; i < channel->nsort; i++)\n-      options->sortlist[i] = channel->sortlist[i];\n-  }\n-  options->nsort = channel->nsort;\n-\n-  return ARES_SUCCESS;\n-}\n-\n-static int init_by_options(ares_channel channel,\n-                           const struct ares_options *options,\n-                           int optmask)\n-{\n-  int i;\n-\n-  /* Easy stuff. */\n-  if ((optmask & ARES_OPT_FLAGS) && channel->flags == -1)\n-    channel->flags = options->flags;\n-  if ((optmask & ARES_OPT_TIMEOUTMS) && channel->timeout == -1)\n-    channel->timeout = options->timeout;\n-  else if ((optmask & ARES_OPT_TIMEOUT) && channel->timeout == -1)\n-    channel->timeout = options->timeout * 1000;\n-  if ((optmask & ARES_OPT_TRIES) && channel->tries == -1)\n-    channel->tries = options->tries;\n-  if ((optmask & ARES_OPT_NDOTS) && channel->ndots == -1)\n-    channel->ndots = options->ndots;\n-  if ((optmask & ARES_OPT_ROTATE) && channel->rotate == -1)\n-    channel->rotate = 1;\n-  if ((optmask & ARES_OPT_UDP_PORT) && channel->udp_port == -1)\n-    channel->udp_port = options->udp_port;\n-  if ((optmask & ARES_OPT_TCP_PORT) && channel->tcp_port == -1)\n-    channel->tcp_port = options->tcp_port;\n-  if ((optmask & ARES_OPT_SOCK_STATE_CB) && channel->sock_state_cb == NULL)\n-    {\n-      channel->sock_state_cb = options->sock_state_cb;\n-      channel->sock_state_cb_data = options->sock_state_cb_data;\n-    }\n-  if ((optmask & ARES_OPT_SOCK_SNDBUF)\n-      && channel->socket_send_buffer_size == -1)\n-    channel->socket_send_buffer_size = options->socket_send_buffer_size;\n-  if ((optmask & ARES_OPT_SOCK_RCVBUF)\n-      && channel->socket_receive_buffer_size == -1)\n-    channel->socket_receive_buffer_size = options->socket_receive_buffer_size;\n-\n-  /* Copy the IPv4 servers, if given. */\n-  if ((optmask & ARES_OPT_SERVERS) && channel->nservers == -1)\n-    {\n-      /* Avoid zero size allocations at any cost */\n-      if (options->nservers > 0)\n-        {\n-          channel->servers =\n-            malloc(options->nservers * sizeof(struct server_state));\n-          if (!channel->servers)\n-            return ARES_ENOMEM;\n-          for (i = 0; i < options->nservers; i++)\n-            {\n-              channel->servers[i].addr.family = AF_INET;\n-              memcpy(&channel->servers[i].addr.addrV4,\n-                     &options->servers[i],\n-                     sizeof(channel->servers[i].addr.addrV4));\n-            }\n-        }\n-      channel->nservers = options->nservers;\n-    }\n-\n-  /* Copy the domains, if given.  Keep channel->ndomains consistent so\n-   * we can clean up in case of error.\n-   */\n-  if ((optmask & ARES_OPT_DOMAINS) && channel->ndomains == -1)\n-    {\n-      /* Avoid zero size allocations at any cost */\n-      if (options->ndomains > 0)\n-      {\n-        channel->domains = malloc(options->ndomains * sizeof(char *));\n-        if (!channel->domains)\n-          return ARES_ENOMEM;\n-        for (i = 0; i < options->ndomains; i++)\n-          {\n-            channel->ndomains = i;\n-            channel->domains[i] = strdup(options->domains[i]);\n-            if (!channel->domains[i])\n-              return ARES_ENOMEM;\n-          }\n-      }\n-      channel->ndomains = options->ndomains;\n-    }\n-\n-  /* Set lookups, if given. */\n-  if ((optmask & ARES_OPT_LOOKUPS) && !channel->lookups)\n-    {\n-      channel->lookups = strdup(options->lookups);\n-      if (!channel->lookups)\n-        return ARES_ENOMEM;\n-    }\n-\n-  /* copy sortlist */\n-  if ((optmask & ARES_OPT_SORTLIST) && (channel->nsort == -1) &&\n-      (options->nsort>0)) {\n-    channel->sortlist = malloc(options->nsort * sizeof(struct apattern));\n-    if (!channel->sortlist)\n-      return ARES_ENOMEM;\n-    for (i = 0; i < options->nsort; i++)\n-      channel->sortlist[i] = options->sortlist[i];\n-    channel->nsort = options->nsort;\n-  }\n-\n-  channel->optmask = optmask;\n-\n-  return ARES_SUCCESS;\n-}\n-\n-static int init_by_environment(ares_channel channel)\n-{\n-  const char *localdomain, *res_options;\n-  int status;\n-\n-  localdomain = getenv(\"LOCALDOMAIN\");\n-  if (localdomain && channel->ndomains == -1)\n-    {\n-      status = set_search(channel, localdomain);\n-      if (status != ARES_SUCCESS)\n-        return status;\n-    }\n-\n-  res_options = getenv(\"RES_OPTIONS\");\n-  if (res_options)\n-    {\n-      status = set_options(channel, res_options);\n-      if (status != ARES_SUCCESS)\n-        return status;\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-\n-#ifdef WIN32\n-/*\n- * Warning: returns a dynamically allocated buffer, the user MUST\n- * use free() if the function returns 1\n- */\n-static int get_res_nt(HKEY hKey, const char *subkey, char **obuf)\n-{\n-  /* Test for the size we need */\n-  DWORD size = 0;\n-  int result;\n-\n-  result = RegQueryValueEx(hKey, subkey, 0, NULL, NULL, &size);\n-  if ((result != ERROR_SUCCESS && result != ERROR_MORE_DATA) || !size)\n-    return 0;\n-  *obuf = malloc(size+1);\n-  if (!*obuf)\n-    return 0;\n-\n-  if (RegQueryValueEx(hKey, subkey, 0, NULL,\n-                      (LPBYTE)*obuf, &size) != ERROR_SUCCESS)\n-  {\n-    free(*obuf);\n-    return 0;\n-  }\n-  if (size == 1)\n-  {\n-    free(*obuf);\n-    return 0;\n-  }\n-  return 1;\n-}\n-\n-static int get_res_interfaces_nt(HKEY hKey, const char *subkey, char **obuf)\n-{\n-  char enumbuf[39]; /* GUIDs are 38 chars + 1 for NULL */\n-  DWORD enum_size = 39;\n-  int idx = 0;\n-  HKEY hVal;\n-\n-  while (RegEnumKeyEx(hKey, idx++, enumbuf, &enum_size, 0,\n-                      NULL, NULL, NULL) != ERROR_NO_MORE_ITEMS)\n-  {\n-    int rc;\n-\n-    enum_size = 39;\n-    if (RegOpenKeyEx(hKey, enumbuf, 0, KEY_QUERY_VALUE, &hVal) !=\n-        ERROR_SUCCESS)\n-      continue;\n-    rc = get_res_nt(hVal, subkey, obuf);\n-      RegCloseKey(hVal);\n-    if (rc)\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/**\n- * The desired output for this method is that we set \"ret_buf\" to\n- * something like:\n- *\n- * 192.168.0.1,dns01.my.domain,fe80::200:f8ff:fe21:67cf\n- *\n- * The only ordering requirement is that primary servers are listed\n- * before secondary. There is no requirement that IPv4 addresses should\n- * necessarily be before IPv6.\n- *\n- * Note that ret_size should ideally be big enough to hold around\n- * 2-3 IPv4 and 2-3 IPv6 addresses.\n- *\n- * Finally, we need to return the total number of DNS servers located.\n- */\n-static int get_iphlpapi_dns_info (char *ret_buf, size_t ret_size)\n-{\n-  const size_t  ipv4_size = INET_ADDRSTRLEN  + 1;  /* +1 for ',' at end */\n-  const size_t  ipv6_size = INET6_ADDRSTRLEN + 12; /* +12 for \"%0123456789,\" at end */\n-  size_t        left = ret_size;\n-  char         *ret  = ret_buf;\n-  int           count = 0;\n-\n-  /* Use the GetAdaptersAddresses method if it's available, otherwise\n-     fall back to GetNetworkParams. */\n-  if (ares_fpGetAdaptersAddresses != ZERO_NULL)\n-  {\n-    const ULONG            working_buf_size = 15000;\n-    IP_ADAPTER_ADDRESSES   *pFirstEntry = NULL;\n-    IP_ADAPTER_ADDRESSES   *pEntry = NULL;\n-    ULONG                  bufSize = 0;\n-    ULONG                  result = 0;\n-\n-    /* According to MSDN, the recommended way to do this is to use a temporary\n-       buffer of 15K, to \"dramatically reduce the chance that the GetAdaptersAddresses\n-       method returns ERROR_BUFFER_OVERFLOW\" */\n-    pFirstEntry  = ( IP_ADAPTER_ADDRESSES * ) malloc( working_buf_size );\n-    bufSize = working_buf_size;\n-    if( !pFirstEntry )\n-      return 0;\n-\n-    /* Call the method one time */\n-    result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n-    if( result == ERROR_BUFFER_OVERFLOW )\n-    {\n-      /* Reallocate, bufSize should now be set to the required size */\n-      pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n-      if( !pFirstEntry )\n-        return 0;\n-\n-      /* Call the method a second time */\n-      result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n-      if( result == ERROR_BUFFER_OVERFLOW )\n-      {\n-        /* Reallocate, bufSize should now be set to the required size */\n-        pFirstEntry = ( IP_ADAPTER_ADDRESSES * ) realloc( pFirstEntry, bufSize );\n-        if( !pFirstEntry )\n-          return 0;\n-\n-        /* Call the method a third time. The maximum number of times we're going to do\n-           this is 3. Three shall be the number thou shalt count, and the number of the\n-           counting shall be three.  Five is right out. */\n-        result = ( *ares_fpGetAdaptersAddresses )( AF_UNSPEC, 0, 0, pFirstEntry, &bufSize );\n-      }\n-    }\n-\n-    /* Check the current result for failure */\n-    if( result != ERROR_SUCCESS )\n-    {\n-      free( pFirstEntry );\n-      return 0;\n-    }\n-\n-    /* process the results */\n-    for( pEntry = pFirstEntry ; pEntry != NULL ; pEntry = pEntry->Next )\n-    {\n-      IP_ADAPTER_DNS_SERVER_ADDRESS* pDNSAddr = pEntry->FirstDnsServerAddress;\n-      for( ; pDNSAddr != NULL ; pDNSAddr = pDNSAddr->Next )\n-      {\n-        struct sockaddr *pGenericAddr = pDNSAddr->Address.lpSockaddr;\n-        size_t stringlen = 0;\n-\n-        if( pGenericAddr->sa_family == AF_INET && left > ipv4_size )\n-        {\n-          /* Handle the v4 case */\n-          struct sockaddr_in *pIPv4Addr = ( struct sockaddr_in * ) pGenericAddr;\n-          ares_inet_ntop( AF_INET, &pIPv4Addr->sin_addr, ret, ipv4_size - 1 ); /* -1 for comma */\n-\n-          /* Append a comma to the end, THEN NULL. Should be OK because we\n-             already tested the size at the top of the if statement. */\n-          stringlen = strlen( ret );\n-          ret[ stringlen ] = ',';\n-          ret[ stringlen + 1 ] = '\\0';\n-          ret += stringlen + 1;\n-          left -= ret - ret_buf;\n-          ++count;\n-        }\n-        else if( pGenericAddr->sa_family == AF_INET6 && left > ipv6_size )\n-        {\n-          /* Handle the v6 case */\n-          struct sockaddr_in6 *pIPv6Addr = ( struct sockaddr_in6 * ) pGenericAddr;\n-          ares_inet_ntop( AF_INET6, &pIPv6Addr->sin6_addr, ret, ipv6_size - 1 ); /* -1 for comma */\n-\n-          stringlen = strlen( ret );\n-\n-          /* Windows apparently always reports some IPv6 DNS servers that\n-             prefixed with fec0:0:0:ffff. These ususally do not point to\n-             working DNS servers, so we ignore them. */\n-          if (strncmp(ret, \"fec0:0:0:ffff:\", 14) != 0) {\n-            /* Append a comma to the end, THEN NULL. Should be OK because we\n-               already tested the size at the top of the if statement. */\n-            ret[ stringlen ] = ',';\n-            ret[ stringlen + 1 ] = '\\0';\n-            ret += stringlen + 1;\n-            left -= ret - ret_buf;\n-            ++count;\n-          }\n-        }\n-      }\n-    }\n-\n-    if( pFirstEntry )\n-      free( pFirstEntry );\n-    if (ret > ret_buf)\n-      ret[-1] = '\\0';\n-    return count;\n-  }\n-  else\n-  {\n-    FIXED_INFO    *fi, *newfi;\n-    DWORD          size = sizeof (*fi);\n-    IP_ADDR_STRING *ipAddr;\n-    int            i;\n-    int            debug  = 0;\n-    HRESULT        res;\n-\n-    fi = malloc(size);\n-    if (!fi)\n-      return 0;\n-\n-    res = (*ares_fpGetNetworkParams) (fi, &size);\n-    if ((res != ERROR_BUFFER_OVERFLOW) && (res != ERROR_SUCCESS))\n-      goto quit;\n-\n-    newfi = realloc(fi, size);\n-    if (!newfi)\n-      goto quit;\n-\n-    fi = newfi;\n-    res = (*ares_fpGetNetworkParams) (fi, &size);\n-    if (res != ERROR_SUCCESS)\n-      goto quit;\n-\n-    if (debug)\n-    {\n-      printf (\"Host Name: %s\\n\", fi->HostName);\n-      printf (\"Domain Name: %s\\n\", fi->DomainName);\n-      printf (\"DNS Servers:\\n\"\n-              \"    %s (primary)\\n\", fi->DnsServerList.IpAddress.String);\n-    }\n-    if (strlen(fi->DnsServerList.IpAddress.String) > 0 &&\n-        inet_addr(fi->DnsServerList.IpAddress.String) != INADDR_NONE &&\n-        left > ipv4_size)\n-    {\n-      ret += sprintf (ret, \"%s,\", fi->DnsServerList.IpAddress.String);\n-      left -= ret - ret_buf;\n-      ++count;\n-    }\n-\n-    for (i = 0, ipAddr = fi->DnsServerList.Next; ipAddr && left > ipv4_size;\n-         ipAddr = ipAddr->Next, i++)\n-    {\n-      if (inet_addr(ipAddr->IpAddress.String) != INADDR_NONE)\n-      {\n-         ret += sprintf (ret, \"%s,\", ipAddr->IpAddress.String);\n-         left -= ret - ret_buf;\n-         ++count;\n-      }\n-      if (debug)\n-         printf (\"    %s (secondary %d)\\n\", ipAddr->IpAddress.String, i+1);\n-    }\n-\n-quit:\n-    if (fi)\n-      free(fi);\n-\n-    if (debug && left <= ipv4_size)\n-      printf (\"Too many nameservers. Truncating to %d addressess\", count);\n-    if (ret > ret_buf)\n-      ret[-1] = '\\0';\n-    return count;\n-  }\n-}\n-#endif\n-\n-static int init_by_resolv_conf(ares_channel channel)\n-{\n-#ifndef WATT32\n-  char *line = NULL;\n-#endif\n-  int status = -1, nservers = 0, nsort = 0;\n-  struct server_state *servers = NULL;\n-  struct apattern *sortlist = NULL;\n-\n-#ifdef WIN32\n-\n-    /*\n-  NameServer info via IPHLPAPI (IP helper API):\n-    GetNetworkParams() should be the trusted source for this.\n-    Available in Win-98/2000 and later. If that fail, fall-back to\n-    registry information.\n-\n-  NameServer Registry:\n-\n-   On Windows 9X, the DNS server can be found in:\n-HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\VxD\\MSTCP\\NameServer\n-\n-        On Windows NT/2000/XP/2003:\n-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\NameServer\n-        or\n-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DhcpNameServer\n-        or\n-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\{AdapterID}\\\n-NameServer\n-        or\n-HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\{AdapterID}\\\n-DhcpNameServer\n-   */\n-\n-  HKEY mykey;\n-  HKEY subkey;\n-  DWORD data_type;\n-  DWORD bytes;\n-  DWORD result;\n-  char  buf[512];\n-  win_platform platform;\n-\n-  if (channel->nservers > -1)  /* don't override ARES_OPT_SERVER */\n-     return ARES_SUCCESS;\n-\n-  if (get_iphlpapi_dns_info(buf,sizeof(buf)) > 0)\n-  {\n-    status = config_nameserver(&servers, &nservers, buf);\n-    if (status == ARES_SUCCESS)\n-      goto okay;\n-  }\n-\n-  platform = ares__getplatform();\n-\n-  if (platform == WIN_NT)\n-  {\n-    if (RegOpenKeyEx(\n-          HKEY_LOCAL_MACHINE, WIN_NS_NT_KEY, 0,\n-          KEY_READ, &mykey\n-          ) == ERROR_SUCCESS)\n-    {\n-      RegOpenKeyEx(mykey, \"Interfaces\", 0,\n-                   KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS, &subkey);\n-      if (get_res_nt(mykey, NAMESERVER, &line))\n-      {\n-        status = config_nameserver(&servers, &nservers, line);\n-        free(line);\n-      }\n-      else if (get_res_nt(mykey, DHCPNAMESERVER, &line))\n-      {\n-        status = config_nameserver(&servers, &nservers, line);\n-        free(line);\n-      }\n-      /* Try the interfaces */\n-      else if (get_res_interfaces_nt(subkey, NAMESERVER, &line))\n-      {\n-        status = config_nameserver(&servers, &nservers, line);\n-        free(line);\n-      }\n-      else if (get_res_interfaces_nt(subkey, DHCPNAMESERVER, &line))\n-      {\n-        status = config_nameserver(&servers, &nservers, line);\n-        free(line);\n-      }\n-      RegCloseKey(subkey);\n-      RegCloseKey(mykey);\n-    }\n-  }\n-  else if (platform == WIN_9X)\n-  {\n-    if (RegOpenKeyEx(\n-          HKEY_LOCAL_MACHINE, WIN_NS_9X, 0,\n-          KEY_READ, &mykey\n-          ) == ERROR_SUCCESS)\n-    {\n-      if ((result = RegQueryValueEx(\n-             mykey, NAMESERVER, NULL, &data_type,\n-             NULL, &bytes\n-             )\n-            ) == ERROR_SUCCESS ||\n-          result == ERROR_MORE_DATA)\n-      {\n-        if (bytes)\n-        {\n-          line = malloc(bytes+1);\n-          if (RegQueryValueEx(mykey, NAMESERVER, NULL, &data_type,\n-                              (unsigned char *)line, &bytes) ==\n-              ERROR_SUCCESS)\n-          {\n-            status = config_nameserver(&servers, &nservers, line);\n-          }\n-          free(line);\n-        }\n-      }\n-    }\n-    RegCloseKey(mykey);\n-  }\n-\n-  if (status == ARES_SUCCESS)\n-    status = ARES_EOF;\n-  else\n-    /* Catch the case when all the above checks fail (which happens when there\n-       is no network card or the cable is unplugged) */\n-    status = ARES_EFILE;\n-\n-#elif defined(__riscos__)\n-\n-  /* Under RISC OS, name servers are listed in the\n-     system variable Inet$Resolvers, space separated. */\n-\n-  line = getenv(\"Inet$Resolvers\");\n-  status = ARES_EOF;\n-  if (line) {\n-    char *resolvers = strdup(line), *pos, *space;\n-\n-    if (!resolvers)\n-      return ARES_ENOMEM;\n-\n-    pos = resolvers;\n-    do {\n-      space = strchr(pos, ' ');\n-      if (space)\n-        *space = '\\0';\n-      status = config_nameserver(&servers, &nservers, pos);\n-      if (status != ARES_SUCCESS)\n-        break;\n-      pos = space + 1;\n-    } while (space);\n-\n-    if (status == ARES_SUCCESS)\n-      status = ARES_EOF;\n-\n-    free(resolvers);\n-  }\n-\n-#elif defined(WATT32)\n-  int i;\n-\n-  sock_init();\n-  for (i = 0; def_nameservers[i]; i++)\n-      ;\n-  if (i == 0)\n-    return ARES_SUCCESS; /* use localhost DNS server */\n-\n-  nservers = i;\n-  servers = calloc(i, sizeof(struct server_state));\n-  if (!servers)\n-     return ARES_ENOMEM;\n-\n-  for (i = 0; def_nameservers[i]; i++)\n-  {\n-    servers[i].addr.addrV4.s_addr = htonl(def_nameservers[i]);\n-    servers[i].addr.family = AF_INET;\n-  }\n-  status = ARES_EOF;\n-\n-#elif defined(ANDROID)\n-  char value[PROP_VALUE_MAX]=\"\";\n-  __system_property_get(\"net.dns1\", value);\n-  status = config_nameserver(&servers, &nservers, value);\n-  if (status == ARES_SUCCESS)\n-    status = ARES_EOF;\n-#else\n-  {\n-    char *p;\n-    FILE *fp;\n-    size_t linesize;\n-    int error;\n-\n-    /* Don't read resolv.conf and friends if we don't have to */\n-    if (ARES_CONFIG_CHECK(channel))\n-        return ARES_SUCCESS;\n-\n-    fp = fopen(PATH_RESOLV_CONF, \"r\");\n-    if (fp) {\n-      while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n-      {\n-        if ((p = try_config(line, \"domain\", ';')))\n-          status = config_domain(channel, p);\n-        else if ((p = try_config(line, \"lookup\", ';')) && !channel->lookups)\n-          status = config_lookup(channel, p, \"bind\", \"file\");\n-        else if ((p = try_config(line, \"search\", ';')))\n-          status = set_search(channel, p);\n-        else if ((p = try_config(line, \"nameserver\", ';')) &&\n-                 channel->nservers == -1)\n-          status = config_nameserver(&servers, &nservers, p);\n-        else if ((p = try_config(line, \"sortlist\", ';')) &&\n-                 channel->nsort == -1)\n-          status = config_sortlist(&sortlist, &nsort, p);\n-        else if ((p = try_config(line, \"options\", ';')))\n-          status = set_options(channel, p);\n-        else\n-          status = ARES_SUCCESS;\n-        if (status != ARES_SUCCESS)\n-          break;\n-      }\n-      fclose(fp);\n-    }\n-    else {\n-      error = ERRNO;\n-      switch(error) {\n-      case ENOENT:\n-      case ESRCH:\n-        status = ARES_EOF;\n-        break;\n-      default:\n-        DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                       error, strerror(error)));\n-        DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", PATH_RESOLV_CONF));\n-        status = ARES_EFILE;\n-      }\n-    }\n-\n-    if ((status == ARES_EOF) && (!channel->lookups)) {\n-      /* Many systems (Solaris, Linux, BSD's) use nsswitch.conf */\n-      fp = fopen(\"/etc/nsswitch.conf\", \"r\");\n-      if (fp) {\n-        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n-        {\n-          if ((p = try_config(line, \"hosts:\", '\\0')) && !channel->lookups)\n-            /* ignore errors */\n-            (void)config_lookup(channel, p, \"dns\", \"files\");\n-        }\n-        fclose(fp);\n-      }\n-      else {\n-        error = ERRNO;\n-        switch(error) {\n-        case ENOENT:\n-        case ESRCH:\n-          status = ARES_EOF;\n-          break;\n-        default:\n-          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                         error, strerror(error)));\n-          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/nsswitch.conf\"));\n-          status = ARES_EFILE;\n-        }\n-      }\n-    }\n-\n-    if ((status == ARES_EOF) && (!channel->lookups)) {\n-      /* Linux / GNU libc 2.x and possibly others have host.conf */\n-      fp = fopen(\"/etc/host.conf\", \"r\");\n-      if (fp) {\n-        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n-        {\n-          if ((p = try_config(line, \"order\", '\\0')) && !channel->lookups)\n-            /* ignore errors */\n-            (void)config_lookup(channel, p, \"bind\", \"hosts\");\n-        }\n-        fclose(fp);\n-      }\n-      else {\n-        error = ERRNO;\n-        switch(error) {\n-        case ENOENT:\n-        case ESRCH:\n-          status = ARES_EOF;\n-          break;\n-        default:\n-          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                         error, strerror(error)));\n-          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/host.conf\"));\n-          status = ARES_EFILE;\n-        }\n-      }\n-    }\n-\n-    if ((status == ARES_EOF) && (!channel->lookups)) {\n-      /* Tru64 uses /etc/svc.conf */\n-      fp = fopen(\"/etc/svc.conf\", \"r\");\n-      if (fp) {\n-        while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)\n-        {\n-          if ((p = try_config(line, \"hosts=\", '\\0')) && !channel->lookups)\n-            /* ignore errors */\n-            (void)config_lookup(channel, p, \"bind\", \"local\");\n-        }\n-        fclose(fp);\n-      }\n-      else {\n-        error = ERRNO;\n-        switch(error) {\n-        case ENOENT:\n-        case ESRCH:\n-          status = ARES_EOF;\n-          break;\n-        default:\n-          DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                         error, strerror(error)));\n-          DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\", \"/etc/svc.conf\"));\n-          status = ARES_EFILE;\n-        }\n-      }\n-    }\n-\n-    if(line)\n-      free(line);\n-  }\n-\n-#endif\n-\n-  /* Handle errors. */\n-  if (status != ARES_EOF)\n-    {\n-      if (servers != NULL)\n-        free(servers);\n-      if (sortlist != NULL)\n-        free(sortlist);\n-      return status;\n-    }\n-\n-  /* If we got any name server entries, fill them in. */\n-#ifdef WIN32\n-okay:\n-#endif\n-  if (servers)\n-    {\n-      channel->servers = servers;\n-      channel->nservers = nservers;\n-    }\n-\n-  /* If we got any sortlist entries, fill them in. */\n-  if (sortlist)\n-    {\n-      channel->sortlist = sortlist;\n-      channel->nsort = nsort;\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-\n-static int init_by_defaults(ares_channel channel)\n-{\n-  char *hostname = NULL;\n-  int rc = ARES_SUCCESS;\n-#ifdef HAVE_GETHOSTNAME\n-  char *dot;\n-#endif\n-\n-  if (channel->flags == -1)\n-    channel->flags = 0;\n-  if (channel->timeout == -1)\n-    channel->timeout = DEFAULT_TIMEOUT;\n-  if (channel->tries == -1)\n-    channel->tries = DEFAULT_TRIES;\n-  if (channel->ndots == -1)\n-    channel->ndots = 1;\n-  if (channel->rotate == -1)\n-    channel->rotate = 0;\n-  if (channel->udp_port == -1)\n-    channel->udp_port = htons(NAMESERVER_PORT);\n-  if (channel->tcp_port == -1)\n-    channel->tcp_port = htons(NAMESERVER_PORT);\n-\n-  if (channel->nservers == -1) {\n-    /* If nobody specified servers, try a local named. */\n-    channel->servers = malloc(sizeof(struct server_state));\n-    if (!channel->servers) {\n-      rc = ARES_ENOMEM;\n-      goto error;\n-    }\n-    channel->servers[0].addr.family = AF_INET;\n-    channel->servers[0].addr.addrV4.s_addr = htonl(INADDR_LOOPBACK);\n-    channel->nservers = 1;\n-  }\n-\n-#if defined(USE_WINSOCK)\n-#define toolong(x) (x == -1) &&  (SOCKERRNO == WSAEFAULT)\n-#elif defined(ENAMETOOLONG)\n-#define toolong(x) (x == -1) && ((SOCKERRNO == ENAMETOOLONG) || \\\n-                                 (SOCKERRNO == EINVAL))\n-#else\n-#define toolong(x) (x == -1) &&  (SOCKERRNO == EINVAL)\n-#endif\n-\n-  if (channel->ndomains == -1) {\n-    /* Derive a default domain search list from the kernel hostname,\n-     * or set it to empty if the hostname isn't helpful.\n-     */\n-    size_t len = 64;\n-    int res;\n-    channel->ndomains = 0; /* default to none */\n-\n-#ifdef HAVE_GETHOSTNAME\n-    hostname = malloc(len);\n-    if(!hostname) {\n-      rc = ARES_ENOMEM;\n-      goto error;\n-    }\n-\n-    do {\n-      res = gethostname(hostname, len);\n-\n-      if(toolong(res)) {\n-        char *p;\n-        len *= 2;\n-        p = realloc(hostname, len);\n-        if(!p) {\n-          rc = ARES_ENOMEM;\n-          goto error;\n-        }\n-        hostname = p;\n-        continue;\n-      }\n-      else if(res) {\n-        rc = ARES_EBADNAME;\n-        goto error;\n-      }\n-\n-    } while(0);\n-\n-    dot = strchr(hostname, '.');\n-    if (dot) {\n-      /* a dot was found */\n-      channel->domains = malloc(sizeof(char *));\n-      if (!channel->domains) {\n-        rc = ARES_ENOMEM;\n-        goto error;\n-      }\n-      channel->domains[0] = strdup(dot + 1);\n-      if (!channel->domains[0]) {\n-        rc = ARES_ENOMEM;\n-        goto error;\n-      }\n-      channel->ndomains = 1;\n-    }\n-#endif\n-  }\n-\n-  if (channel->nsort == -1) {\n-    channel->sortlist = NULL;\n-    channel->nsort = 0;\n-  }\n-\n-  if (!channel->lookups) {\n-    channel->lookups = strdup(\"fb\");\n-    if (!channel->lookups)\n-      rc = ARES_ENOMEM;\n-  }\n-\n-  error:\n-  if(rc) {\n-    if(channel->servers)\n-      free(channel->servers);\n-\n-    if(channel->domains && channel->domains[0])\n-      free(channel->domains[0]);\n-    if(channel->domains)\n-      free(channel->domains);\n-    if(channel->lookups)\n-      free(channel->lookups);\n-  }\n-\n-  if(hostname)\n-    free(hostname);\n-\n-  return rc;\n-}\n-\n-#if !defined(WIN32) && !defined(WATT32)\n-static int config_domain(ares_channel channel, char *str)\n-{\n-  char *q;\n-\n-  /* Set a single search domain. */\n-  q = str;\n-  while (*q && !ISSPACE(*q))\n-    q++;\n-  *q = '\\0';\n-  return set_search(channel, str);\n-}\n-\n-#if defined(__INTEL_COMPILER) && (__INTEL_COMPILER == 910) && \\\n-    defined(__OPTIMIZE__) && defined(__unix__) &&  defined(__i386__)\n-  /* workaround icc 9.1 optimizer issue */\n-# define vqualifier volatile\n-#else\n-# define vqualifier\n-#endif\n-\n-static int config_lookup(ares_channel channel, const char *str,\n-                         const char *bindch, const char *filech)\n-{\n-  char lookups[3], *l;\n-  const char *vqualifier p;\n-\n-  /* Set the lookup order.  Only the first letter of each work\n-   * is relevant, and it has to be \"b\" for DNS or \"f\" for the\n-   * host file.  Ignore everything else.\n-   */\n-  l = lookups;\n-  p = str;\n-  while (*p)\n-    {\n-      if ((*p == *bindch || *p == *filech) && l < lookups + 2) {\n-        if (*p == *bindch) *l++ = 'b';\n-        else *l++ = 'f';\n-      }\n-      while (*p && !ISSPACE(*p) && (*p != ','))\n-        p++;\n-      while (*p && (ISSPACE(*p) || (*p == ',')))\n-        p++;\n-    }\n-  *l = '\\0';\n-  channel->lookups = strdup(lookups);\n-  return (channel->lookups) ? ARES_SUCCESS : ARES_ENOMEM;\n-}\n-#endif  /* !WIN32 & !WATT32 */\n-\n-#ifndef WATT32\n-static int config_nameserver(struct server_state **servers, int *nservers,\n-                             char *str)\n-{\n-  struct ares_addr host;\n-  struct server_state *newserv;\n-  char *p, *txtaddr;\n-  /* On Windows, there may be more than one nameserver specified in the same\n-   * registry key, so we parse input as a space or comma seperated list.\n-   */\n-  for (p = str; p;)\n-    {\n-      /* Skip whitespace and commas. */\n-      while (*p && (ISSPACE(*p) || (*p == ',')))\n-        p++;\n-      if (!*p)\n-        /* No more input, done. */\n-        break;\n-\n-      /* Pointer to start of IPv4 or IPv6 address part. */\n-      txtaddr = p;\n-\n-      /* Advance past this address. */\n-      while (*p && !ISSPACE(*p) && (*p != ','))\n-        p++;\n-      if (*p)\n-        /* Null terminate this address. */\n-        *p++ = '\\0';\n-      else\n-        /* Reached end of input, done when this address is processed. */\n-        p = NULL;\n-\n-      /* Convert textual address to binary format. */\n-      if (ares_inet_pton(AF_INET, txtaddr, &host.addrV4) == 1)\n-        host.family = AF_INET;\n-      else if (ares_inet_pton(AF_INET6, txtaddr, &host.addrV6) == 1)\n-        host.family = AF_INET6;\n-      else\n-        continue;\n-\n-      /* Resize servers state array. */\n-      newserv = realloc(*servers, (*nservers + 1) *\n-                        sizeof(struct server_state));\n-      if (!newserv)\n-        return ARES_ENOMEM;\n-\n-      /* Store address data. */\n-      newserv[*nservers].addr.family = host.family;\n-      if (host.family == AF_INET)\n-        memcpy(&newserv[*nservers].addr.addrV4, &host.addrV4,\n-               sizeof(host.addrV4));\n-      else\n-        memcpy(&newserv[*nservers].addr.addrV6, &host.addrV6,\n-               sizeof(host.addrV6));\n-\n-      /* Update arguments. */\n-      *servers = newserv;\n-      *nservers += 1;\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-\n-#ifndef WIN32\n-static int config_sortlist(struct apattern **sortlist, int *nsort,\n-                           const char *str)\n-{\n-  struct apattern pat;\n-  const char *q;\n-\n-  /* Add sortlist entries. */\n-  while (*str && *str != ';')\n-    {\n-      int bits;\n-      char ipbuf[16], ipbufpfx[32];\n-      /* Find just the IP */\n-      q = str;\n-      while (*q && *q != '/' && *q != ';' && !ISSPACE(*q))\n-        q++;\n-      memcpy(ipbuf, str, q-str);\n-      ipbuf[q-str] = '\\0';\n-      /* Find the prefix */\n-      if (*q == '/')\n-        {\n-          const char *str2 = q+1;\n-          while (*q && *q != ';' && !ISSPACE(*q))\n-            q++;\n-          memcpy(ipbufpfx, str, q-str);\n-          ipbufpfx[q-str] = '\\0';\n-          str = str2;\n-        }\n-      else\n-        ipbufpfx[0] = '\\0';\n-      /* Lets see if it is CIDR */\n-      /* First we'll try IPv6 */\n-      if ((bits = ares_inet_net_pton(AF_INET6, ipbufpfx[0] ? ipbufpfx : ipbuf,\n-                                     &pat.addrV6,\n-                                     sizeof(pat.addrV6))) > 0)\n-        {\n-          pat.type = PATTERN_CIDR;\n-          pat.mask.bits = (unsigned short)bits;\n-          pat.family = AF_INET6;\n-          if (!sortlist_alloc(sortlist, nsort, &pat))\n-            return ARES_ENOMEM;\n-        }\n-      else if (ipbufpfx[0] &&\n-               (bits = ares_inet_net_pton(AF_INET, ipbufpfx, &pat.addrV4,\n-                                          sizeof(pat.addrV4))) > 0)\n-        {\n-          pat.type = PATTERN_CIDR;\n-          pat.mask.bits = (unsigned short)bits;\n-          pat.family = AF_INET;\n-          if (!sortlist_alloc(sortlist, nsort, &pat))\n-            return ARES_ENOMEM;\n-        }\n-      /* See if it is just a regular IP */\n-      else if (ip_addr(ipbuf, q-str, &pat.addrV4) == 0)\n-        {\n-          if (ipbufpfx[0])\n-            {\n-              memcpy(ipbuf, str, q-str);\n-              ipbuf[q-str] = '\\0';\n-              if (ip_addr(ipbuf, q-str, &pat.mask.addr4) != 0)\n-                natural_mask(&pat);\n-            }\n-          else\n-            natural_mask(&pat);\n-          pat.family = AF_INET;\n-          pat.type = PATTERN_MASK;\n-          if (!sortlist_alloc(sortlist, nsort, &pat))\n-            return ARES_ENOMEM;\n-        }\n-      else\n-        {\n-          while (*q && *q != ';' && !ISSPACE(*q))\n-            q++;\n-        }\n-      str = q;\n-      while (ISSPACE(*str))\n-        str++;\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-#endif  /* !WIN32 */\n-#endif  /* !WATT32 */\n-\n-static int set_search(ares_channel channel, const char *str)\n-{\n-  int n;\n-  const char *p, *q;\n-\n-  if(channel->ndomains != -1) {\n-    /* if we already have some domains present, free them first */\n-    for(n=0; n < channel->ndomains; n++)\n-      free(channel->domains[n]);\n-    free(channel->domains);\n-    channel->domains = NULL;\n-    channel->ndomains = -1;\n-  }\n-\n-  /* Count the domains given. */\n-  n = 0;\n-  p = str;\n-  while (*p)\n-    {\n-      while (*p && !ISSPACE(*p))\n-        p++;\n-      while (ISSPACE(*p))\n-        p++;\n-      n++;\n-    }\n-\n-  if (!n)\n-    {\n-      channel->ndomains = 0;\n-      return ARES_SUCCESS;\n-    }\n-\n-  channel->domains = malloc(n * sizeof(char *));\n-  if (!channel->domains)\n-    return ARES_ENOMEM;\n-\n-  /* Now copy the domains. */\n-  n = 0;\n-  p = str;\n-  while (*p)\n-    {\n-      channel->ndomains = n;\n-      q = p;\n-      while (*q && !ISSPACE(*q))\n-        q++;\n-      channel->domains[n] = malloc(q - p + 1);\n-      if (!channel->domains[n])\n-        return ARES_ENOMEM;\n-      memcpy(channel->domains[n], p, q - p);\n-      channel->domains[n][q - p] = 0;\n-      p = q;\n-      while (ISSPACE(*p))\n-        p++;\n-      n++;\n-    }\n-  channel->ndomains = n;\n-\n-  return ARES_SUCCESS;\n-}\n-\n-static int set_options(ares_channel channel, const char *str)\n-{\n-  const char *p, *q, *val;\n-\n-  p = str;\n-  while (*p)\n-    {\n-      q = p;\n-      while (*q && !ISSPACE(*q))\n-        q++;\n-      val = try_option(p, q, \"ndots:\");\n-      if (val && channel->ndots == -1)\n-        channel->ndots = aresx_sltosi(strtol(val, NULL, 10));\n-      val = try_option(p, q, \"retrans:\");\n-      if (val && channel->timeout == -1)\n-        channel->timeout = aresx_sltosi(strtol(val, NULL, 10));\n-      val = try_option(p, q, \"retry:\");\n-      if (val && channel->tries == -1)\n-        channel->tries = aresx_sltosi(strtol(val, NULL, 10));\n-      val = try_option(p, q, \"rotate\");\n-      if (val && channel->rotate == -1)\n-        channel->rotate = 1;\n-      p = q;\n-      while (ISSPACE(*p))\n-        p++;\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-\n-static const char *try_option(const char *p, const char *q, const char *opt)\n-{\n-  size_t len = strlen(opt);\n-  return ((size_t)(q - p) >= len && !strncmp(p, opt, len)) ? &p[len] : NULL;\n-}\n-\n-#if !defined(WIN32) && !defined(WATT32)\n-static char *try_config(char *s, const char *opt, char scc)\n-{\n-  size_t len;\n-  char *p;\n-  char *q;\n-\n-  if (!s || !opt)\n-    /* no line or no option */\n-    return NULL;\n-\n-  /* Hash '#' character is always used as primary comment char, additionally\n-     a not-NUL secondary comment char will be considered when specified. */\n-\n-  /* trim line comment */\n-  p = s;\n-  if(scc)\n-    while (*p && (*p != '#') && (*p != scc))\n-      p++;\n-  else\n-    while (*p && (*p != '#'))\n-      p++;\n-  *p = '\\0';\n-\n-  /* trim trailing whitespace */\n-  q = p - 1;\n-  while ((q >= s) && ISSPACE(*q))\n-    q--;\n-  *++q = '\\0';\n-\n-  /* skip leading whitespace */\n-  p = s;\n-  while (*p && ISSPACE(*p))\n-    p++;\n-\n-  if (!*p)\n-    /* empty line */\n-    return NULL;\n-\n-  if ((len = strlen(opt)) == 0)\n-    /* empty option */\n-    return NULL;\n-\n-  if (strncmp(p, opt, len) != 0)\n-    /* line and option do not match */\n-    return NULL;\n-\n-  /* skip over given option name */\n-  p += len;\n-\n-  if (!*p)\n-    /* no option value */\n-    return NULL;\n-\n-  if ((opt[len-1] != ':') && (opt[len-1] != '=') && !ISSPACE(*p))\n-    /* whitespace between option name and value is mandatory\n-       for given option names which do not end with ':' or '=' */\n-    return NULL;\n-\n-  /* skip over whitespace */\n-  while (*p && ISSPACE(*p))\n-    p++;\n-\n-  if (!*p)\n-    /* no option value */\n-    return NULL;\n-\n-  /* return pointer to option value */\n-  return p;\n-}\n-\n-static int sortlist_alloc(struct apattern **sortlist, int *nsort,\n-                          struct apattern *pat)\n-{\n-  struct apattern *newsort;\n-  newsort = realloc(*sortlist, (*nsort + 1) * sizeof(struct apattern));\n-  if (!newsort)\n-    return 0;\n-  newsort[*nsort] = *pat;\n-  *sortlist = newsort;\n-  (*nsort)++;\n-  return 1;\n-}\n-\n-static int ip_addr(const char *ipbuf, ssize_t len, struct in_addr *addr)\n-{\n-\n-  /* Four octets and three periods yields at most 15 characters. */\n-  if (len > 15)\n-    return -1;\n-\n-  addr->s_addr = inet_addr(ipbuf);\n-  if (addr->s_addr == INADDR_NONE && strcmp(ipbuf, \"255.255.255.255\") != 0)\n-    return -1;\n-  return 0;\n-}\n-\n-static void natural_mask(struct apattern *pat)\n-{\n-  struct in_addr addr;\n-\n-  /* Store a host-byte-order copy of pat in a struct in_addr.  Icky,\n-   * but portable.\n-   */\n-  addr.s_addr = ntohl(pat->addrV4.s_addr);\n-\n-  /* This is out of date in the CIDR world, but some people might\n-   * still rely on it.\n-   */\n-  if (IN_CLASSA(addr.s_addr))\n-    pat->mask.addr4.s_addr = htonl(IN_CLASSA_NET);\n-  else if (IN_CLASSB(addr.s_addr))\n-    pat->mask.addr4.s_addr = htonl(IN_CLASSB_NET);\n-  else\n-    pat->mask.addr4.s_addr = htonl(IN_CLASSC_NET);\n-}\n-#endif /* !WIN32 && !WATT32 */\n-\n-/* initialize an rc4 key. If possible a cryptographically secure random key\n-   is generated using a suitable function (for example win32's RtlGenRandom as\n-   described in\n-   http://blogs.msdn.com/michael_howard/archive/2005/01/14/353379.aspx\n-   otherwise the code defaults to cross-platform albeit less secure mechanism\n-   using rand\n-*/\n-static void randomize_key(unsigned char* key,int key_data_len)\n-{\n-  int randomized = 0;\n-  int counter=0;\n-#ifdef WIN32\n-  BOOLEAN res;\n-  if (ares_fpSystemFunction036)\n-    {\n-      res = (*ares_fpSystemFunction036) (key, key_data_len);\n-      if (res)\n-        randomized = 1;\n-    }\n-#else /* !WIN32 */\n-#ifdef RANDOM_FILE\n-  FILE *f = fopen(RANDOM_FILE, \"rb\");\n-  if(f) {\n-    counter = aresx_uztosi(fread(key, 1, key_data_len, f));\n-    fclose(f);\n-  }\n-#endif\n-#endif /* WIN32 */\n-\n-  if ( !randomized ) {\n-    for (;counter<key_data_len;counter++)\n-      key[counter]=(unsigned char)(rand() % 256);\n-  }\n-}\n-\n-static int init_id_key(rc4_key* key,int key_data_len)\n-{\n-  unsigned char index1;\n-  unsigned char index2;\n-  unsigned char* state;\n-  short counter;\n-  unsigned char *key_data_ptr = 0;\n-\n-  key_data_ptr = calloc(1,key_data_len);\n-  if (!key_data_ptr)\n-    return ARES_ENOMEM;\n-\n-  state = &key->state[0];\n-  for(counter = 0; counter < 256; counter++)\n-    /* unnecessary AND but it keeps some compilers happier */\n-    state[counter] = (unsigned char)(counter & 0xff);\n-  randomize_key(key->state,key_data_len);\n-  key->x = 0;\n-  key->y = 0;\n-  index1 = 0;\n-  index2 = 0;\n-  for(counter = 0; counter < 256; counter++)\n-  {\n-    index2 = (unsigned char)((key_data_ptr[index1] + state[counter] +\n-                              index2) % 256);\n-    ARES_SWAP_BYTE(&state[counter], &state[index2]);\n-\n-    index1 = (unsigned char)((index1 + 1) % key_data_len);\n-  }\n-  free(key_data_ptr);\n-  return ARES_SUCCESS;\n-}\n-\n-unsigned short ares__generate_new_id(rc4_key* key)\n-{\n-  unsigned short r=0;\n-  ares__rc4(key, (unsigned char *)&r, sizeof(r));\n-  return r;\n-}\n-\n-void ares_set_local_ip4(ares_channel channel, unsigned int local_ip)\n-{\n-  channel->local_ip4 = local_ip;\n-}\n-\n-/* local_ip6 should be 16 bytes in length */\n-void ares_set_local_ip6(ares_channel channel,\n-                        const unsigned char* local_ip6)\n-{\n-  memcpy(&channel->local_ip6, local_ip6, sizeof(channel->local_ip6));\n-}\n-\n-/* local_dev_name should be null terminated. */\n-void ares_set_local_dev(ares_channel channel,\n-                        const char* local_dev_name)\n-{\n-  strncpy(channel->local_dev_name, local_dev_name,\n-          sizeof(channel->local_dev_name));\n-  channel->local_dev_name[sizeof(channel->local_dev_name) - 1] = 0;\n-}\n-\n-\n-void ares_set_socket_callback(ares_channel channel,\n-                              ares_sock_create_callback cb,\n-                              void *data)\n-{\n-  channel->sock_create_cb = cb;\n-  channel->sock_create_cb_data = data;\n-}\n-\n-void ares__init_servers_state(ares_channel channel)\n-{\n-  struct server_state *server;\n-  int i;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      server = &channel->servers[i];\n-      server->udp_socket = ARES_SOCKET_BAD;\n-      server->tcp_socket = ARES_SOCKET_BAD;\n-      server->tcp_connection_generation = ++channel->tcp_connection_generation;\n-      server->tcp_lenbuf_pos = 0;\n-      server->tcp_buffer_pos = 0;\n-      server->tcp_buffer = NULL;\n-      server->tcp_length = 0;\n-      server->qhead = NULL;\n-      server->qtail = NULL;\n-      ares__init_list_head(&server->queries_to_server);\n-      server->channel = channel;\n-      server->is_broken = 0;\n-    }\n-}"}, {"sha": "343aee3ffbdc9bd799a7781f383cc6e698f268a1", "filename": "src/rt/libuv/src/ares/ares_iphlpapi.h", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_iphlpapi.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,221 +0,0 @@\n-#ifndef HEADER_CARES_IPHLPAPI_H\n-#define HEADER_CARES_IPHLPAPI_H\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004 - 2011 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#if defined(USE_WINSOCK)\n-\n-#ifndef INET_ADDRSTRLEN\n-#define INET_ADDRSTRLEN  22\n-#endif\n-\n-#ifndef INET6_ADDRSTRLEN\n-#define INET6_ADDRSTRLEN 65\n-#endif\n-\n-/* ---------------------------------- */\n-#if !defined(_WS2DEF_)           && \\\n-    !defined(__CSADDR_DEFINED__) && \\\n-    !defined(__CSADDR_T_DEFINED)\n-/* ---------------------------------- */\n-\n-typedef struct _SOCKET_ADDRESS {\n-  LPSOCKADDR lpSockaddr;\n-  INT iSockaddrLength;\n-} SOCKET_ADDRESS, *PSOCKET_ADDRESS;\n-\n-typedef struct _CSADDR_INFO {\n-  SOCKET_ADDRESS LocalAddr;\n-  SOCKET_ADDRESS RemoteAddr;\n-  INT iSocketType;\n-  INT iProtocol;\n-} CSADDR_INFO, *PCSADDR_INFO;\n-\n-/* --------------------------------- */\n-#endif /* ! _WS2DEF_           && \\  */\n-/*        ! __CSADDR_DEFINED__ && \\  */\n-/*        ! __CSADDR_T_DEFINED       */\n-/* --------------------------------- */\n-\n-/* ------------------------------- */\n-#if !defined(IP_ADAPTER_DDNS_ENABLED)\n-/* ------------------------------- */\n-\n-#define IP_ADAPTER_ADDRESS_DNS_ELIGIBLE  0x0001\n-#define IP_ADAPTER_ADDRESS_TRANSIENT     0x0002\n-\n-#define IP_ADAPTER_DDNS_ENABLED                0x0001\n-#define IP_ADAPTER_REGISTER_ADAPTER_SUFFIX     0x0002\n-#define IP_ADAPTER_DHCP_ENABLED                0x0004\n-#define IP_ADAPTER_RECEIVE_ONLY                0x0008\n-#define IP_ADAPTER_NO_MULTICAST                0x0010\n-#define IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG  0x0020\n-\n-#define GAA_FLAG_SKIP_UNICAST        0x0001\n-#define GAA_FLAG_SKIP_ANYCAST        0x0002\n-#define GAA_FLAG_SKIP_MULTICAST      0x0004\n-#define GAA_FLAG_SKIP_DNS_SERVER     0x0008\n-#define GAA_FLAG_INCLUDE_PREFIX      0x0010\n-#define GAA_FLAG_SKIP_FRIENDLY_NAME  0x0020\n-\n-typedef enum {\n-  IpPrefixOriginOther = 0,\n-  IpPrefixOriginManual,\n-  IpPrefixOriginWellKnown,\n-  IpPrefixOriginDhcp,\n-  IpPrefixOriginRouterAdvertisement\n-} IP_PREFIX_ORIGIN;\n-\n-typedef enum {\n-  IpSuffixOriginOther = 0,\n-  IpSuffixOriginManual,\n-  IpSuffixOriginWellKnown,\n-  IpSuffixOriginDhcp,\n-  IpSuffixOriginLinkLayerAddress,\n-  IpSuffixOriginRandom\n-} IP_SUFFIX_ORIGIN;\n-\n-typedef enum {\n-  IpDadStateInvalid = 0,\n-  IpDadStateTentative,\n-  IpDadStateDuplicate,\n-  IpDadStateDeprecated,\n-  IpDadStatePreferred\n-} IP_DAD_STATE;\n-\n-typedef enum {\n-  IfOperStatusUp = 1,\n-  IfOperStatusDown,\n-  IfOperStatusTesting,\n-  IfOperStatusUnknown,\n-  IfOperStatusDormant,\n-  IfOperStatusNotPresent,\n-  IfOperStatusLowerLayerDown\n-} IF_OPER_STATUS;\n-\n-typedef enum {\n-  ScopeLevelInterface    = 0x0001,\n-  ScopeLevelLink         = 0x0002,\n-  ScopeLevelSubnet       = 0x0003,\n-  ScopeLevelAdmin        = 0x0004,\n-  ScopeLevelSite         = 0x0005,\n-  ScopeLevelOrganization = 0x0008,\n-  ScopeLevelGlobal       = 0x000E\n-} SCOPE_LEVEL;\n-\n-typedef struct _IP_ADAPTER_UNICAST_ADDRESS {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD Flags;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_UNICAST_ADDRESS *Next;\n-  SOCKET_ADDRESS Address;\n-  IP_PREFIX_ORIGIN PrefixOrigin;\n-  IP_SUFFIX_ORIGIN SuffixOrigin;\n-  IP_DAD_STATE DadState;\n-  ULONG ValidLifetime;\n-  ULONG PreferredLifetime;\n-  ULONG LeaseLifetime;\n-} IP_ADAPTER_UNICAST_ADDRESS, *PIP_ADAPTER_UNICAST_ADDRESS;\n-\n-typedef struct _IP_ADAPTER_ANYCAST_ADDRESS {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD Flags;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_ANYCAST_ADDRESS *Next;\n-  SOCKET_ADDRESS Address;\n-} IP_ADAPTER_ANYCAST_ADDRESS, *PIP_ADAPTER_ANYCAST_ADDRESS;\n-\n-typedef struct _IP_ADAPTER_MULTICAST_ADDRESS {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD Flags;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_MULTICAST_ADDRESS *Next;\n-  SOCKET_ADDRESS Address;\n-} IP_ADAPTER_MULTICAST_ADDRESS, *PIP_ADAPTER_MULTICAST_ADDRESS;\n-\n-typedef struct _IP_ADAPTER_DNS_SERVER_ADDRESS {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD Reserved;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_DNS_SERVER_ADDRESS *Next;\n-  SOCKET_ADDRESS Address;\n-} IP_ADAPTER_DNS_SERVER_ADDRESS, *PIP_ADAPTER_DNS_SERVER_ADDRESS;\n-\n-typedef struct _IP_ADAPTER_PREFIX {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD Flags;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_PREFIX *Next;\n-  SOCKET_ADDRESS Address;\n-  ULONG PrefixLength;\n-} IP_ADAPTER_PREFIX, *PIP_ADAPTER_PREFIX;\n-\n-typedef struct _IP_ADAPTER_ADDRESSES {\n-  union {\n-    ULONGLONG Alignment;\n-    struct {\n-      ULONG Length;\n-      DWORD IfIndex;\n-    } s;\n-  } u;\n-  struct _IP_ADAPTER_ADDRESSES *Next;\n-  PCHAR AdapterName;\n-  PIP_ADAPTER_UNICAST_ADDRESS FirstUnicastAddress;\n-  PIP_ADAPTER_ANYCAST_ADDRESS FirstAnycastAddress;\n-  PIP_ADAPTER_MULTICAST_ADDRESS FirstMulticastAddress;\n-  PIP_ADAPTER_DNS_SERVER_ADDRESS FirstDnsServerAddress;\n-  PWCHAR DnsSuffix;\n-  PWCHAR Description;\n-  PWCHAR FriendlyName;\n-  BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];\n-  DWORD PhysicalAddressLength;\n-  DWORD Flags;\n-  DWORD Mtu;\n-  DWORD IfType;\n-  IF_OPER_STATUS OperStatus;\n-  DWORD Ipv6IfIndex;\n-  DWORD ZoneIndices[16];\n-  PIP_ADAPTER_PREFIX FirstPrefix;\n-} IP_ADAPTER_ADDRESSES, *PIP_ADAPTER_ADDRESSES;\n-\n-/* -------------------------------- */\n-#endif /* ! IP_ADAPTER_DDNS_ENABLED */\n-/* -------------------------------- */\n-\n-#endif /* USE_WINSOCK */\n-\n-#endif /* HEADER_CARES_IPHLPAPI_H */"}, {"sha": "6f1022a76f533847fac76852af1b350185c2da96", "filename": "src/rt/libuv/src/ares/ares_ipv6.h", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_ipv6.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,78 +0,0 @@\n-\n-/* Copyright (C) 2005 by Dominick Meglio\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#ifndef ARES_IPV6_H\n-#define ARES_IPV6_H\n-\n-#ifndef HAVE_PF_INET6\n-#define PF_INET6 AF_INET6\n-#endif\n-\n-#ifndef HAVE_STRUCT_SOCKADDR_IN6\n-struct sockaddr_in6\n-{\n-  unsigned short       sin6_family;\n-  unsigned short       sin6_port;\n-  unsigned long        sin6_flowinfo;\n-  struct ares_in6_addr sin6_addr;\n-  unsigned int         sin6_scope_id;\n-};\n-#endif\n-\n-#ifndef HAVE_STRUCT_ADDRINFO\n-struct addrinfo\n-{\n-  int              ai_flags;\n-  int              ai_family;\n-  int              ai_socktype;\n-  int              ai_protocol;\n-  ares_socklen_t   ai_addrlen;   /* Follow rfc3493 struct addrinfo */\n-  char            *ai_canonname;\n-  struct sockaddr *ai_addr;\n-  struct addrinfo *ai_next;\n-};\n-#endif\n-\n-#ifndef NS_IN6ADDRSZ\n-#if SIZEOF_STRUCT_IN6_ADDR == 0\n-/* We cannot have it set to zero, so we pick a fixed value here */\n-#define NS_IN6ADDRSZ 16\n-#else\n-#define NS_IN6ADDRSZ SIZEOF_STRUCT_IN6_ADDR\n-#endif\n-#endif\n-\n-#ifndef NS_INADDRSZ\n-#define NS_INADDRSZ SIZEOF_STRUCT_IN_ADDR\n-#endif\n-\n-#ifndef NS_INT16SZ\n-#define NS_INT16SZ 2\n-#endif\n-\n-#ifndef IF_NAMESIZE\n-#ifdef IFNAMSIZ\n-#define IF_NAMESIZE IFNAMSIZ\n-#else\n-#define IF_NAMESIZE 256\n-#endif\n-#endif\n-\n-/* Defined in ares_net_pton.c for no particular reason. */\n-extern const struct ares_in6_addr ares_in6addr_any; /* :: */\n-\n-\n-#endif /* ARES_IPV6_H */"}, {"sha": "f0137a1828e0f226879b87f612a9994f0ca1ef63", "filename": "src/rt/libuv/src/ares/ares_library_init.c", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,142 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2009 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#include \"ares.h\"\n-#include \"ares_library_init.h\"\n-#include \"ares_private.h\"\n-\n-/* library-private global and unique instance vars */\n-\n-#ifdef USE_WINSOCK\n-fpGetNetworkParams_t ares_fpGetNetworkParams = ZERO_NULL;\n-fpSystemFunction036_t ares_fpSystemFunction036 = ZERO_NULL;\n-fpGetAdaptersAddresses_t ares_fpGetAdaptersAddresses = ZERO_NULL;\n-#endif\n-\n-/* library-private global vars with source visibility restricted to this file */\n-\n-static unsigned int ares_initialized;\n-static int          ares_init_flags;\n-\n-#ifdef USE_WINSOCK\n-static HMODULE hnd_iphlpapi;\n-static HMODULE hnd_advapi32;\n-#endif\n-\n-\n-static int ares_win32_init(void)\n-{\n-#ifdef USE_WINSOCK\n-\n-  hnd_iphlpapi = 0;\n-  hnd_iphlpapi = LoadLibrary(\"iphlpapi.dll\");\n-  if (!hnd_iphlpapi)\n-    return ARES_ELOADIPHLPAPI;\n-\n-  ares_fpGetNetworkParams = (fpGetNetworkParams_t)\n-    GetProcAddress(hnd_iphlpapi, \"GetNetworkParams\");\n-  if (!ares_fpGetNetworkParams)\n-    {\n-      FreeLibrary(hnd_iphlpapi);\n-      return ARES_EADDRGETNETWORKPARAMS;\n-    }\n-\n-  ares_fpGetAdaptersAddresses = (fpGetAdaptersAddresses_t)\n-    GetProcAddress(hnd_iphlpapi, \"GetAdaptersAddresses\");\n-  if (!ares_fpGetAdaptersAddresses)\n-    {\n-      /* This can happen on clients before WinXP, I don't\n-         think it should be an error, unless we don't want to\n-         support Windows 2000 anymore */\n-    }\n-\n-  /*\n-   * When advapi32.dll is unavailable or advapi32.dll has no SystemFunction036,\n-   * also known as RtlGenRandom, which is the case for Windows versions prior\n-   * to WinXP then c-ares uses portable rand() function. Then don't error here.\n-   */\n-\n-  hnd_advapi32 = 0;\n-  hnd_advapi32 = LoadLibrary(\"advapi32.dll\");\n-  if (hnd_advapi32)\n-    {\n-      ares_fpSystemFunction036 = (fpSystemFunction036_t)\n-        GetProcAddress(hnd_advapi32, \"SystemFunction036\");\n-    }\n-\n-#endif\n-  return ARES_SUCCESS;\n-}\n-\n-\n-static void ares_win32_cleanup(void)\n-{\n-#ifdef USE_WINSOCK\n-  if (hnd_advapi32)\n-    FreeLibrary(hnd_advapi32);\n-  if (hnd_iphlpapi)\n-    FreeLibrary(hnd_iphlpapi);\n-#endif\n-}\n-\n-\n-int ares_library_init(int flags)\n-{\n-  int res;\n-\n-  if (ares_initialized)\n-    return ARES_SUCCESS;\n-  ares_initialized++;\n-\n-  if (flags & ARES_LIB_INIT_WIN32)\n-    {\n-      res = ares_win32_init();\n-      if (res != ARES_SUCCESS)\n-        return res;\n-    }\n-\n-  ares_init_flags = flags;\n-\n-  return ARES_SUCCESS;\n-}\n-\n-\n-void ares_library_cleanup(void)\n-{\n-  if (!ares_initialized)\n-    return;\n-  ares_initialized--;\n-\n-  if (ares_init_flags & ARES_LIB_INIT_WIN32)\n-    ares_win32_cleanup();\n-\n-  ares_init_flags = ARES_LIB_INIT_NONE;\n-}\n-\n-\n-int ares_library_initialized(void)\n-{\n-#ifdef USE_WINSOCK\n-  if (!ares_initialized)\n-    return ARES_ENOTINITIALIZED;\n-#endif\n-  return ARES_SUCCESS;\n-}\n-\n-"}, {"sha": "cbbfc6afbad6d4e2621eaf27fa87e93799526530", "filename": "src/rt/libuv/src/ares/ares_library_init.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_library_init.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,42 +0,0 @@\n-#ifndef HEADER_CARES_LIBRARY_INIT_H\n-#define HEADER_CARES_LIBRARY_INIT_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef USE_WINSOCK\n-\n-#include <iphlpapi.h>\n-#include \"ares_iphlpapi.h\"\n-\n-typedef DWORD (WINAPI *fpGetNetworkParams_t) (FIXED_INFO*, DWORD*);\n-typedef BOOLEAN (APIENTRY *fpSystemFunction036_t) (void*, ULONG);\n-typedef ULONG (WINAPI *fpGetAdaptersAddresses_t) ( ULONG, ULONG, void*, IP_ADAPTER_ADDRESSES*, ULONG* );\n-\n-/* Forward-declaration of variables defined in ares_library_init.c */\n-/* that are global and unique instances for whole c-ares library.  */\n-\n-extern fpGetNetworkParams_t ares_fpGetNetworkParams;\n-extern fpSystemFunction036_t ares_fpSystemFunction036;\n-extern fpGetAdaptersAddresses_t ares_fpGetAdaptersAddresses;\n-\n-#endif /* USE_WINSOCK */\n-\n-#endif /* HEADER_CARES_LIBRARY_INIT_H */\n-"}, {"sha": "c0acd90a8e8af9fc4b27f95f33d06414fef4103f", "filename": "src/rt/libuv/src/ares/ares_llist.c", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,86 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-/* Routines for managing doubly-linked circular linked lists with a\n- * dummy head.\n- */\n-\n-/* Initialize a new head node */\n-void ares__init_list_head(struct list_node* head) {\n-  head->prev = head;\n-  head->next = head;\n-  head->data = NULL;\n-}\n-\n-/* Initialize a list node */\n-void ares__init_list_node(struct list_node* node, void* d) {\n-  node->prev = NULL;\n-  node->next = NULL;\n-  node->data = d;\n-}\n-\n-/* Returns true iff the given list is empty */\n-int ares__is_list_empty(struct list_node* head) {\n-  return ((head->next == head) && (head->prev == head));\n-}\n-\n-/* Inserts new_node before old_node */\n-void ares__insert_in_list(struct list_node* new_node,\n-                          struct list_node* old_node) {\n-  new_node->next = old_node;\n-  new_node->prev = old_node->prev;\n-  old_node->prev->next = new_node;\n-  old_node->prev = new_node;\n-}\n-\n-/* Removes the node from the list it's in, if any */\n-void ares__remove_from_list(struct list_node* node) {\n-  if (node->next != NULL) {\n-    node->prev->next = node->next;\n-    node->next->prev = node->prev;\n-    node->prev = NULL;\n-    node->next = NULL;\n-  }\n-}\n-\n-/* Swap the contents of two lists */\n-void ares__swap_lists(struct list_node* head_a,\n-                      struct list_node* head_b) {\n-  int is_a_empty = ares__is_list_empty(head_a);\n-  int is_b_empty = ares__is_list_empty(head_b);\n-  struct list_node old_a = *head_a;\n-  struct list_node old_b = *head_b;\n-\n-  if (is_a_empty) {\n-    ares__init_list_head(head_b);\n-  } else {\n-    *head_b = old_a;\n-    old_a.next->prev = head_b;\n-    old_a.prev->next = head_b;\n-  }\n-  if (is_b_empty) {\n-    ares__init_list_head(head_a);\n-  } else {\n-    *head_a = old_b;\n-    old_b.next->prev = head_a;\n-    old_b.prev->next = head_a;\n-  }\n-}"}, {"sha": "b09f0de6d71b48bc69ca48639883cd8e8c0d3b65", "filename": "src/rt/libuv/src/ares/ares_llist.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_llist.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,42 +0,0 @@\n-#ifndef __ARES_LLIST_H\n-#define __ARES_LLIST_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-\n-/* Node definition for circular, doubly-linked list */\n-struct list_node {\n-  struct list_node *prev;\n-  struct list_node *next;\n-  void* data;\n-};\n-\n-void ares__init_list_head(struct list_node* head);\n-\n-void ares__init_list_node(struct list_node* node, void* d);\n-\n-int ares__is_list_empty(struct list_node* head);\n-\n-void ares__insert_in_list(struct list_node* new_node,\n-                          struct list_node* old_node);\n-\n-void ares__remove_from_list(struct list_node* node);\n-\n-void ares__swap_lists(struct list_node* head_a,\n-                      struct list_node* head_b);\n-\n-#endif /* __ARES_LLIST_H */"}, {"sha": "e33f13ff223216f263dd8e84434e629862d685bc", "filename": "src/rt/libuv/src/ares/ares_mkquery.c", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_mkquery.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,195 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-/* Header format, from RFC 1035:\n- *                                  1  1  1  1  1  1\n- *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                      ID                       |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                    QDCOUNT                    |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                    ANCOUNT                    |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                    NSCOUNT                    |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                    ARCOUNT                    |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *\n- * AA, TC, RA, and RCODE are only set in responses.  Brief description\n- * of the remaining fields:\n- *      ID      Identifier to match responses with queries\n- *      QR      Query (0) or response (1)\n- *      Opcode  For our purposes, always QUERY\n- *      RD      Recursion desired\n- *      Z       Reserved (zero)\n- *      QDCOUNT Number of queries\n- *      ANCOUNT Number of answers\n- *      NSCOUNT Number of name server records\n- *      ARCOUNT Number of additional records\n- *\n- * Question format, from RFC 1035:\n- *                                  1  1  1  1  1  1\n- *    0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                                               |\n- *  /                     QNAME                     /\n- *  /                                               /\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                     QTYPE                     |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *  |                     QCLASS                    |\n- *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n- *\n- * The query name is encoded as a series of labels, each represented\n- * as a one-byte length (maximum 63) followed by the text of the\n- * label.  The list is terminated by a label of length zero (which can\n- * be thought of as the root domain).\n- */\n-\n-int ares_mkquery(const char *name, int dnsclass, int type, unsigned short id,\n-                 int rd, unsigned char **buf, int *buflen)\n-{\n-  int len;\n-  unsigned char *q;\n-  const char *p;\n-\n-  /* Set our results early, in case we bail out early with an error. */\n-  *buflen = 0;\n-  *buf = NULL;\n-\n-  /* Compute the length of the encoded name so we can check buflen.\n-   * Start counting at 1 for the zero-length label at the end. */\n-  len = 1;\n-  for (p = name; *p; p++)\n-    {\n-      if (*p == '\\\\' && *(p + 1) != 0)\n-        p++;\n-      len++;\n-    }\n-  /* If there are n periods in the name, there are n + 1 labels, and\n-   * thus n + 1 length fields, unless the name is empty or ends with a\n-   * period.  So add 1 unless name is empty or ends with a period.\n-   */\n-  if (*name && *(p - 1) != '.')\n-    len++;\n-\n-  /* Immediately reject names that are longer than the maximum of 255\n-   * bytes that's specified in RFC 1035 (\"To simplify implementations,\n-   * the total length of a domain name (i.e., label octets and label\n-   * length octets) is restricted to 255 octets or less.\"). We aren't\n-   * doing this just to be a stickler about RFCs. For names that are\n-   * too long, 'dnscache' closes its TCP connection to us immediately\n-   * (when using TCP) and ignores the request when using UDP, and\n-   * BIND's named returns ServFail (TCP or UDP). Sending a request\n-   * that we know will cause 'dnscache' to close the TCP connection is\n-   * painful, since that makes any other outstanding requests on that\n-   * connection fail. And sending a UDP request that we know\n-   * 'dnscache' will ignore is bad because resources will be tied up\n-   * until we time-out the request.\n-   */\n-  if (len > MAXCDNAME)\n-    return ARES_EBADNAME;\n-\n-  *buflen = len + HFIXEDSZ + QFIXEDSZ;\n-  *buf = malloc(*buflen);\n-  if (!*buf)\n-      return ARES_ENOMEM;\n-\n-  /* Set up the header. */\n-  q = *buf;\n-  memset(q, 0, HFIXEDSZ);\n-  DNS_HEADER_SET_QID(q, id);\n-  DNS_HEADER_SET_OPCODE(q, QUERY);\n-  if (rd) {\n-    DNS_HEADER_SET_RD(q, 1);\n-  }\n-  else {\n-    DNS_HEADER_SET_RD(q, 0);\n-  }\n-  DNS_HEADER_SET_QDCOUNT(q, 1);\n-\n-  /* A name of \".\" is a screw case for the loop below, so adjust it. */\n-  if (strcmp(name, \".\") == 0)\n-    name++;\n-\n-  /* Start writing out the name after the header. */\n-  q += HFIXEDSZ;\n-  while (*name)\n-    {\n-      if (*name == '.')\n-        return ARES_EBADNAME;\n-\n-      /* Count the number of bytes in this label. */\n-      len = 0;\n-      for (p = name; *p && *p != '.'; p++)\n-        {\n-          if (*p == '\\\\' && *(p + 1) != 0)\n-            p++;\n-          len++;\n-        }\n-      if (len > MAXLABEL)\n-        return ARES_EBADNAME;\n-\n-      /* Encode the length and copy the data. */\n-      *q++ = (unsigned char)len;\n-      for (p = name; *p && *p != '.'; p++)\n-        {\n-          if (*p == '\\\\' && *(p + 1) != 0)\n-            p++;\n-          *q++ = *p;\n-        }\n-\n-      /* Go to the next label and repeat, unless we hit the end. */\n-      if (!*p)\n-        break;\n-      name = p + 1;\n-    }\n-\n-  /* Add the zero-length label at the end. */\n-  *q++ = 0;\n-\n-  /* Finish off the question with the type and class. */\n-  DNS_QUESTION_SET_TYPE(q, type);\n-  DNS_QUESTION_SET_CLASS(q, dnsclass);\n-\n-  return ARES_SUCCESS;\n-}"}, {"sha": "701add58c6077dce547013c7d9a24ff19ba74524", "filename": "src/rt/libuv/src/ares/ares_nowarn.c", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,181 +0,0 @@\n-\n-/* Copyright (C) 2010-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_ASSERT_H\n-#  include <assert.h>\n-#endif\n-\n-#if defined(__INTEL_COMPILER) && defined(__unix__)\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-\n-#endif /* __INTEL_COMPILER && __unix__ */\n-\n-#define BUILDING_ARES_NOWARN_C 1\n-\n-#include \"ares_nowarn.h\"\n-\n-#if (SIZEOF_INT == 2)\n-#  define CARES_MASK_SINT  0x7FFF\n-#  define CARES_MASK_UINT  0xFFFF\n-#elif (SIZEOF_INT == 4)\n-#  define CARES_MASK_SINT  0x7FFFFFFF\n-#  define CARES_MASK_UINT  0xFFFFFFFF\n-#elif (SIZEOF_INT == 8)\n-#  define CARES_MASK_SINT  0x7FFFFFFFFFFFFFFF\n-#  define CARES_MASK_UINT  0xFFFFFFFFFFFFFFFF\n-#elif (SIZEOF_INT == 16)\n-#  define CARES_MASK_SINT  0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n-#  define CARES_MASK_UINT  0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n-#endif\n-\n-/*\n-** unsigned size_t to signed int\n-*/\n-\n-int aresx_uztosi(size_t uznum)\n-{\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:810) /* conversion may lose significant bits */\n-#endif\n-\n-  return (int)(uznum & (size_t) CARES_MASK_SINT);\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-}\n-\n-/*\n-** signed long to signed int\n-*/\n-\n-int aresx_sltosi(long slnum)\n-{\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:810) /* conversion may lose significant bits */\n-#endif\n-\n-  DEBUGASSERT(slnum >= 0);\n-  return (int)(slnum & (long) CARES_MASK_SINT);\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-}\n-\n-/*\n-** signed ssize_t to signed int\n-*/\n-\n-int aresx_sztosi(ssize_t sznum)\n-{\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:810) /* conversion may lose significant bits */\n-#endif\n-\n-  DEBUGASSERT(sznum >= 0);\n-  return (int)(sznum & (ssize_t) CARES_MASK_SINT);\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-}\n-\n-/*\n-** signed ssize_t to unsigned int\n-*/\n-\n-unsigned int aresx_sztoui(ssize_t sznum)\n-{\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(push)\n-#  pragma warning(disable:810) /* conversion may lose significant bits */\n-#endif\n-\n-  DEBUGASSERT(sznum >= 0);\n-  return (unsigned int)(sznum & (ssize_t) CARES_MASK_UINT);\n-\n-#ifdef __INTEL_COMPILER\n-#  pragma warning(pop)\n-#endif\n-}\n-\n-#if defined(__INTEL_COMPILER) && defined(__unix__)\n-\n-int aresx_FD_ISSET(int fd, fd_set *fdset)\n-{\n-  #pragma warning(push)\n-  #pragma warning(disable:1469) /* clobber ignored */\n-  return FD_ISSET(fd, fdset);\n-  #pragma warning(pop)\n-}\n-\n-void aresx_FD_SET(int fd, fd_set *fdset)\n-{\n-  #pragma warning(push)\n-  #pragma warning(disable:1469) /* clobber ignored */\n-  FD_SET(fd, fdset);\n-  #pragma warning(pop)\n-}\n-\n-void aresx_FD_ZERO(fd_set *fdset)\n-{\n-  #pragma warning(push)\n-  #pragma warning(disable:593) /* variable was set but never used */\n-  FD_ZERO(fdset);\n-  #pragma warning(pop)\n-}\n-\n-unsigned short aresx_htons(unsigned short usnum)\n-{\n-#if (__INTEL_COMPILER == 910) && defined(__i386__)\n-  return (unsigned short)(((usnum << 8) & 0xFF00) | ((usnum >> 8) & 0x00FF));\n-#else\n-  #pragma warning(push)\n-  #pragma warning(disable:810) /* conversion may lose significant bits */\n-  return htons(usnum);\n-  #pragma warning(pop)\n-#endif\n-}\n-\n-unsigned short aresx_ntohs(unsigned short usnum)\n-{\n-#if (__INTEL_COMPILER == 910) && defined(__i386__)\n-  return (unsigned short)(((usnum << 8) & 0xFF00) | ((usnum >> 8) & 0x00FF));\n-#else\n-  #pragma warning(push)\n-  #pragma warning(disable:810) /* conversion may lose significant bits */\n-  return ntohs(usnum);\n-  #pragma warning(pop)\n-#endif\n-}\n-\n-#endif /* __INTEL_COMPILER && __unix__ */"}, {"sha": "bcaa22721f17fc8911d4b7ef7d072316c3df77ea", "filename": "src/rt/libuv/src/ares/ares_nowarn.h", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_nowarn.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,55 +0,0 @@\n-#ifndef HEADER_CARES_NOWARN_H\n-#define HEADER_CARES_NOWARN_H\n-\n-\n-/* Copyright (C) 2010-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-int aresx_uztosi(size_t uznum);\n-\n-int aresx_sltosi(long slnum);\n-\n-int aresx_sztosi(ssize_t sznum);\n-\n-unsigned int aresx_sztoui(ssize_t sznum);\n-\n-#if defined(__INTEL_COMPILER) && defined(__unix__)\n-\n-int aresx_FD_ISSET(int fd, fd_set *fdset);\n-\n-void aresx_FD_SET(int fd, fd_set *fdset);\n-\n-void aresx_FD_ZERO(fd_set *fdset);\n-\n-unsigned short aresx_htons(unsigned short usnum);\n-\n-unsigned short aresx_ntohs(unsigned short usnum);\n-\n-#ifndef BUILDING_ARES_NOWARN_C\n-#  undef  FD_ISSET\n-#  define FD_ISSET(a,b) aresx_FD_ISSET((a),(b))\n-#  undef  FD_SET\n-#  define FD_SET(a,b)   aresx_FD_SET((a),(b))\n-#  undef  FD_ZERO\n-#  define FD_ZERO(a)    aresx_FD_ZERO((a))\n-#  undef  htons\n-#  define htons(a)      aresx_htons((a))\n-#  undef  ntohs\n-#  define ntohs(a)      aresx_ntohs((a))\n-#endif\n-\n-#endif /* __INTEL_COMPILER && __unix__ */\n-\n-#endif /* HEADER_CARES_NOWARN_H */"}, {"sha": "5174ef26e4cfe7d18aba07debf9dbfa2c82cd34e", "filename": "src/rt/libuv/src/ares/ares_options.c", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_options.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,248 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2008-2011 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_data.h\"\n-#include \"inet_net_pton.h\"\n-#include \"ares_private.h\"\n-\n-\n-int ares_get_servers(ares_channel channel,\n-                     struct ares_addr_node **servers)\n-{\n-  struct ares_addr_node *srvr_head = NULL;\n-  struct ares_addr_node *srvr_last = NULL;\n-  struct ares_addr_node *srvr_curr;\n-  int status = ARES_SUCCESS;\n-  int i;\n-\n-  if (!channel)\n-    return ARES_ENODATA;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      /* Allocate storage for this server node appending it to the list */\n-      srvr_curr = ares_malloc_data(ARES_DATATYPE_ADDR_NODE);\n-      if (!srvr_curr)\n-        {\n-          status = ARES_ENOMEM;\n-          break;\n-        }\n-      if (srvr_last)\n-        {\n-          srvr_last->next = srvr_curr;\n-        }\n-      else\n-        {\n-          srvr_head = srvr_curr;\n-        }\n-      srvr_last = srvr_curr;\n-\n-      /* Fill this server node data */\n-      srvr_curr->family = channel->servers[i].addr.family;\n-      if (srvr_curr->family == AF_INET)\n-        memcpy(&srvr_curr->addrV4, &channel->servers[i].addr.addrV4,\n-               sizeof(srvr_curr->addrV4));\n-      else\n-        memcpy(&srvr_curr->addrV6, &channel->servers[i].addr.addrV6,\n-               sizeof(srvr_curr->addrV6));\n-    }\n-\n-  if (status != ARES_SUCCESS)\n-    {\n-      if (srvr_head)\n-        {\n-          ares_free_data(srvr_head);\n-          srvr_head = NULL;\n-        }\n-    }\n-\n-  *servers = srvr_head;\n-\n-  return status;\n-}\n-\n-\n-int ares_set_servers(ares_channel channel,\n-                     struct ares_addr_node *servers)\n-{\n-  struct ares_addr_node *srvr;\n-  int num_srvrs = 0;\n-  int i;\n-\n-  if (ares_library_initialized() != ARES_SUCCESS)\n-    return ARES_ENOTINITIALIZED;\n-\n-  if (!channel)\n-    return ARES_ENODATA;\n-\n-  ares__destroy_servers_state(channel);\n-\n-  for (srvr = servers; srvr; srvr = srvr->next)\n-    {\n-      num_srvrs++;\n-    }\n-\n-  if (num_srvrs > 0)\n-    {\n-      /* Allocate storage for servers state */\n-      channel->servers = malloc(num_srvrs * sizeof(struct server_state));\n-      if (!channel->servers)\n-        {\n-          return ARES_ENOMEM;\n-        }\n-      channel->nservers = num_srvrs;\n-      /* Fill servers state address data */\n-      for (i = 0, srvr = servers; srvr; i++, srvr = srvr->next)\n-        {\n-          channel->servers[i].addr.family = srvr->family;\n-          if (srvr->family == AF_INET)\n-            memcpy(&channel->servers[i].addr.addrV4, &srvr->addrV4,\n-                   sizeof(srvr->addrV4));\n-          else\n-            memcpy(&channel->servers[i].addr.addrV6, &srvr->addrV6,\n-                   sizeof(srvr->addrV6));\n-        }\n-      /* Initialize servers state remaining data */\n-      ares__init_servers_state(channel);\n-    }\n-\n-  return ARES_SUCCESS;\n-}\n-\n-/* Incomming string format: host[:port][,host[:port]]... */\n-int ares_set_servers_csv(ares_channel channel,\n-                         const char* _csv)\n-{\n-  size_t i;\n-  char* csv = NULL;\n-  char* ptr;\n-  char* start_host;\n-  int rv = ARES_SUCCESS;\n-  struct ares_addr_node *servers = NULL;\n-  struct ares_addr_node *last = NULL;\n-\n-  if (ares_library_initialized() != ARES_SUCCESS)\n-    return ARES_ENOTINITIALIZED;\n-\n-  if (!channel)\n-    return ARES_ENODATA;\n-\n-  ares__destroy_servers_state(channel);\n-\n-  i = strlen(_csv);\n-  if (i == 0)\n-     return ARES_SUCCESS; /* blank all servers */\n-\n-  csv = malloc(i + 2);\n-  strcpy(csv, _csv);\n-  if (csv[i-1] != ',') { /* make parsing easier by ensuring ending ',' */\n-    csv[i] = ',';\n-    csv[i+1] = 0;\n-  }\n-\n-  start_host = csv;\n-  for (ptr = csv; *ptr; ptr++) {\n-    if (*ptr == ',') {\n-      char* pp = ptr - 1;\n-      struct in_addr in4;\n-      struct ares_in6_addr in6;\n-      struct ares_addr_node *s = NULL;\n-\n-      *ptr = 0; /* null terminate host:port string */\n-      /* Got an entry..see if port was specified. */\n-      while (pp > start_host) {\n-        if (*pp == ':')\n-          break; /* yes */\n-        if (!ISDIGIT(*pp)) {\n-          /* Found end of digits before we found :, so wasn't a port */\n-          pp = ptr;\n-          break;\n-        }\n-        pp--;\n-      }\n-      if ((pp != start_host) && ((pp + 1) < ptr)) {\n-        /* Found it. Parse over the port number */\n-        (void)strtol(pp + 1, NULL, 10);\n-        *pp = 0; /* null terminate host */\n-      }\n-      /* resolve host, try ipv4 first, rslt is in network byte order */\n-      rv = ares_inet_pton(AF_INET, start_host, &in4);\n-      if (!rv) {\n-        /* Ok, try IPv6 then */\n-        rv = ares_inet_pton(AF_INET6, start_host, &in6);\n-        if (!rv) {\n-          rv = ARES_EBADSTR;\n-          goto out;\n-        }\n-        /* was ipv6, add new server */\n-        s = malloc(sizeof(*s));\n-        if (!s) {\n-          rv = ARES_ENOMEM;\n-          goto out;\n-        }\n-        s->family = AF_INET6;\n-        memcpy(&s->addr, &in6, sizeof(struct ares_in6_addr));\n-      }\n-      else {\n-        /* was ipv4, add new server */\n-        s = malloc(sizeof(*s));\n-        if (!s) {\n-          rv = ARES_ENOMEM;\n-          goto out;\n-        }\n-        s->family = AF_INET;\n-        memcpy(&s->addr, &in4, sizeof(struct in_addr));\n-      }\n-      if (s) {\n-        /* TODO:  Add port to ares_addr_node and assign it here. */\n-\n-        s->next = NULL;\n-        if (last) {\n-          last->next = s;\n-        }\n-        else {\n-          servers = s;\n-          last = s;\n-        }\n-      }\n-\n-      /* Set up for next one */\n-      start_host = ptr + 1;\n-    }\n-  }\n-\n-  rv = ares_set_servers(channel, servers);\n-\n-  out:\n-  if (csv)\n-    free(csv);\n-  while (servers) {\n-    struct ares_addr_node *s = servers;\n-    servers = servers->next;\n-    free(s);\n-  }\n-\n-  return rv;\n-}"}, {"sha": "4bd08458836bdc014d0f38570fa17e97b4bb1ef9", "filename": "src/rt/libuv/src/ares/ares_parse_a_reply.c", "status": "removed", "additions": 0, "deletions": 263, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_a_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,263 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#ifdef HAVE_LIMITS_H\n-#  include <limits.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-int ares_parse_a_reply(const unsigned char *abuf, int alen,\n-                       struct hostent **host,\n-                       struct ares_addrttl *addrttls, int *naddrttls)\n-{\n-  unsigned int qdcount, ancount;\n-  int status, i, rr_type, rr_class, rr_len, rr_ttl, naddrs;\n-  int cname_ttl = INT_MAX;  /* the TTL imposed by the CNAME chain */\n-  int naliases;\n-  long len;\n-  const unsigned char *aptr;\n-  char *hostname, *rr_name, *rr_data, **aliases;\n-  struct in_addr *addrs;\n-  struct hostent *hostent;\n-  const int max_addr_ttls = (addrttls && naddrttls) ? *naddrttls : 0;\n-\n-  /* Set *host to NULL for all failure cases. */\n-  if (host)\n-    *host = NULL;\n-  /* Same with *naddrttls. */\n-  if (naddrttls)\n-    *naddrttls = 0;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT(abuf);\n-  ancount = DNS_HEADER_ANCOUNT(abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares__expand_name_for_response(aptr, abuf, alen, &hostname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free(hostname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  if (host)\n-    {\n-      /* Allocate addresses and aliases; ancount gives an upper bound for\n-         both. */\n-      addrs = malloc(ancount * sizeof(struct in_addr));\n-      if (!addrs)\n-        {\n-          free(hostname);\n-          return ARES_ENOMEM;\n-        }\n-      aliases = malloc((ancount + 1) * sizeof(char *));\n-      if (!aliases)\n-        {\n-          free(hostname);\n-          free(addrs);\n-          return ARES_ENOMEM;\n-        }\n-    }\n-  else\n-    {\n-      addrs = NULL;\n-      aliases = NULL;\n-    }\n-\n-  naddrs = 0;\n-  naliases = 0;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for (i = 0; i < (int)ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        break;\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          free(rr_name);\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE(aptr);\n-      rr_class = DNS_RR_CLASS(aptr);\n-      rr_len = DNS_RR_LEN(aptr);\n-      rr_ttl = DNS_RR_TTL(aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      if (rr_class == C_IN && rr_type == T_A\n-          && rr_len == sizeof(struct in_addr)\n-          && strcasecmp(rr_name, hostname) == 0)\n-        {\n-          if (addrs)\n-            {\n-              if (aptr + sizeof(struct in_addr) > abuf + alen)\n-              {\n-                free(rr_name);\n-                status = ARES_EBADRESP;\n-                break;\n-              }\n-              memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr));\n-            }\n-          if (naddrs < max_addr_ttls)\n-            {\n-              struct ares_addrttl * const at = &addrttls[naddrs];\n-              if (aptr + sizeof(struct in_addr) > abuf + alen)\n-              {\n-                free(rr_name);\n-                status = ARES_EBADRESP;\n-                break;\n-              }\n-              memcpy(&at->ipaddr, aptr,  sizeof(struct in_addr));\n-              at->ttl = rr_ttl;\n-            }\n-          naddrs++;\n-          status = ARES_SUCCESS;\n-        }\n-\n-      if (rr_class == C_IN && rr_type == T_CNAME)\n-        {\n-          /* Record the RR name as an alias. */\n-          if (aliases)\n-            aliases[naliases] = rr_name;\n-          else\n-            free(rr_name);\n-          naliases++;\n-\n-          /* Decode the RR data and replace the hostname with it. */\n-          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n-                                                  &len);\n-          if (status != ARES_SUCCESS)\n-            break;\n-          free(hostname);\n-          hostname = rr_data;\n-\n-          /* Take the min of the TTLs we see in the CNAME chain. */\n-          if (cname_ttl > rr_ttl)\n-            cname_ttl = rr_ttl;\n-        }\n-      else\n-        free(rr_name);\n-\n-      aptr += rr_len;\n-      if (aptr > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-    }\n-\n-  if (status == ARES_SUCCESS && naddrs == 0 && naliases == 0)\n-    /* the check for naliases to be zero is to make sure CNAME responses\n-       don't get caught here */\n-    status = ARES_ENODATA;\n-  if (status == ARES_SUCCESS)\n-    {\n-      /* We got our answer. */\n-      if (naddrttls)\n-        {\n-          const int n = naddrs < max_addr_ttls ? naddrs : max_addr_ttls;\n-          for (i = 0; i < n; i++)\n-            {\n-              /* Ensure that each A TTL is no larger than the CNAME TTL. */\n-              if (addrttls[i].ttl > cname_ttl)\n-                addrttls[i].ttl = cname_ttl;\n-            }\n-          *naddrttls = n;\n-        }\n-      if (aliases)\n-        aliases[naliases] = NULL;\n-      if (host)\n-        {\n-          /* Allocate memory to build the host entry. */\n-          hostent = malloc(sizeof(struct hostent));\n-          if (hostent)\n-            {\n-              hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n-              if (hostent->h_addr_list)\n-                {\n-                  /* Fill in the hostent and return successfully. */\n-                  hostent->h_name = hostname;\n-                  hostent->h_aliases = aliases;\n-                  hostent->h_addrtype = AF_INET;\n-                  hostent->h_length = sizeof(struct in_addr);\n-                  for (i = 0; i < naddrs; i++)\n-                    hostent->h_addr_list[i] = (char *) &addrs[i];\n-                  hostent->h_addr_list[naddrs] = NULL;\n-                  if (!naddrs && addrs)\n-                    free(addrs);\n-                  *host = hostent;\n-                  return ARES_SUCCESS;\n-                }\n-              free(hostent);\n-            }\n-          status = ARES_ENOMEM;\n-        }\n-     }\n-  if (aliases)\n-    {\n-      for (i = 0; i < naliases; i++)\n-        free(aliases[i]);\n-      free(aliases);\n-    }\n-  free(addrs);\n-  free(hostname);\n-  return status;\n-}"}, {"sha": "1fbe8389f74fd35f1fbf6a50d914246950bac8c7", "filename": "src/rt/libuv/src/ares/ares_parse_aaaa_reply.c", "status": "removed", "additions": 0, "deletions": 259, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_aaaa_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,259 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright 2005 Dominick Meglio\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#ifdef HAVE_LIMITS_H\n-#  include <limits.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"inet_net_pton.h\"\n-#include \"ares_private.h\"\n-\n-int ares_parse_aaaa_reply(const unsigned char *abuf, int alen,\n-                          struct hostent **host, struct ares_addr6ttl *addrttls,\n-                          int *naddrttls)\n-{\n-  unsigned int qdcount, ancount;\n-  int status, i, rr_type, rr_class, rr_len, rr_ttl, naddrs;\n-  int cname_ttl = INT_MAX;  /* the TTL imposed by the CNAME chain */\n-  int naliases;\n-  long len;\n-  const unsigned char *aptr;\n-  char *hostname, *rr_name, *rr_data, **aliases;\n-  struct ares_in6_addr *addrs;\n-  struct hostent *hostent;\n-  const int max_addr_ttls = (addrttls && naddrttls) ? *naddrttls : 0;\n-\n-  /* Set *host to NULL for all failure cases. */\n-  if (host)\n-    *host = NULL;\n-  /* Same with *naddrttls. */\n-  if (naddrttls)\n-    *naddrttls = 0;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT(abuf);\n-  ancount = DNS_HEADER_ANCOUNT(abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares__expand_name_for_response(aptr, abuf, alen, &hostname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free(hostname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Allocate addresses and aliases; ancount gives an upper bound for both. */\n-  if (host)\n-    {\n-      addrs = malloc(ancount * sizeof(struct ares_in6_addr));\n-      if (!addrs)\n-        {\n-          free(hostname);\n-          return ARES_ENOMEM;\n-        }\n-      aliases = malloc((ancount + 1) * sizeof(char *));\n-      if (!aliases)\n-        {\n-          free(hostname);\n-          free(addrs);\n-          return ARES_ENOMEM;\n-        }\n-    }\n-  else\n-    {\n-      addrs = NULL;\n-      aliases = NULL;\n-    }\n-  naddrs = 0;\n-  naliases = 0;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for (i = 0; i < (int)ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        break;\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          free(rr_name);\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE(aptr);\n-      rr_class = DNS_RR_CLASS(aptr);\n-      rr_len = DNS_RR_LEN(aptr);\n-      rr_ttl = DNS_RR_TTL(aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      if (rr_class == C_IN && rr_type == T_AAAA\n-          && rr_len == sizeof(struct ares_in6_addr)\n-          && strcasecmp(rr_name, hostname) == 0)\n-        {\n-          if (addrs)\n-            {\n-              if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n-              {\n-                free(rr_name);\n-                status = ARES_EBADRESP;\n-                break;\n-              }\n-              memcpy(&addrs[naddrs], aptr, sizeof(struct ares_in6_addr));\n-            }\n-          if (naddrs < max_addr_ttls)\n-            {\n-              struct ares_addr6ttl * const at = &addrttls[naddrs];\n-              if (aptr + sizeof(struct ares_in6_addr) > abuf + alen)\n-              {\n-                free(rr_name);\n-                status = ARES_EBADRESP;\n-                break;\n-              }\n-              memcpy(&at->ip6addr, aptr,  sizeof(struct ares_in6_addr));\n-              at->ttl = rr_ttl;\n-            }\n-          naddrs++;\n-          status = ARES_SUCCESS;\n-        }\n-\n-      if (rr_class == C_IN && rr_type == T_CNAME)\n-        {\n-          /* Record the RR name as an alias. */\n-          if (aliases)\n-            aliases[naliases] = rr_name;\n-          else\n-            free(rr_name);\n-          naliases++;\n-\n-          /* Decode the RR data and replace the hostname with it. */\n-          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n-                                                  &len);\n-          if (status != ARES_SUCCESS)\n-            break;\n-          free(hostname);\n-          hostname = rr_data;\n-\n-          /* Take the min of the TTLs we see in the CNAME chain. */\n-          if (cname_ttl > rr_ttl)\n-            cname_ttl = rr_ttl;\n-        }\n-      else\n-        free(rr_name);\n-\n-      aptr += rr_len;\n-      if (aptr > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-    }\n-\n-  if (status == ARES_SUCCESS && naddrs == 0)\n-    status = ARES_ENODATA;\n-  if (status == ARES_SUCCESS)\n-    {\n-      /* We got our answer. */\n-      if (naddrttls)\n-        {\n-          const int n = naddrs < max_addr_ttls ? naddrs : max_addr_ttls;\n-          for (i = 0; i < n; i++)\n-            {\n-              /* Ensure that each A TTL is no larger than the CNAME TTL. */\n-              if (addrttls[i].ttl > cname_ttl)\n-                addrttls[i].ttl = cname_ttl;\n-            }\n-          *naddrttls = n;\n-        }\n-      if (aliases)\n-        aliases[naliases] = NULL;\n-      if (host)\n-        {\n-          /* Allocate memory to build the host entry. */\n-          hostent = malloc(sizeof(struct hostent));\n-          if (hostent)\n-            {\n-              hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));\n-              if (hostent->h_addr_list)\n-                {\n-                  /* Fill in the hostent and return successfully. */\n-                  hostent->h_name = hostname;\n-                  hostent->h_aliases = aliases;\n-                  hostent->h_addrtype = AF_INET6;\n-                  hostent->h_length = sizeof(struct ares_in6_addr);\n-                  for (i = 0; i < naddrs; i++)\n-                    hostent->h_addr_list[i] = (char *) &addrs[i];\n-                  hostent->h_addr_list[naddrs] = NULL;\n-                  *host = hostent;\n-                  return ARES_SUCCESS;\n-                }\n-              free(hostent);\n-            }\n-          status = ARES_ENOMEM;\n-        }\n-    }\n-  if (aliases)\n-    {\n-      for (i = 0; i < naliases; i++)\n-        free(aliases[i]);\n-      free(aliases);\n-    }\n-  free(addrs);\n-  free(hostname);\n-  return status;\n-}"}, {"sha": "21800546b484ec4bfb1679f00bf314f3feb8811d", "filename": "src/rt/libuv/src/ares/ares_parse_mx_reply.c", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_mx_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,170 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2010 Jeremy Lal <kapouer@melix.org>\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_data.h\"\n-#include \"ares_private.h\"\n-\n-int\n-ares_parse_mx_reply (const unsigned char *abuf, int alen,\n-                     struct ares_mx_reply **mx_out)\n-{\n-  unsigned int qdcount, ancount, i;\n-  const unsigned char *aptr, *vptr;\n-  int status, rr_type, rr_class, rr_len;\n-  long len;\n-  char *hostname = NULL, *rr_name = NULL;\n-  struct ares_mx_reply *mx_head = NULL;\n-  struct ares_mx_reply *mx_last = NULL;\n-  struct ares_mx_reply *mx_curr;\n-\n-  /* Set *mx_out to NULL for all failure cases. */\n-  *mx_out = NULL;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT (abuf);\n-  ancount = DNS_HEADER_ANCOUNT (abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-  if (ancount == 0)\n-    return ARES_ENODATA;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free (hostname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for (i = 0; i < ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        {\n-          break;\n-        }\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE (aptr);\n-      rr_class = DNS_RR_CLASS (aptr);\n-      rr_len = DNS_RR_LEN (aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      /* Check if we are really looking at a MX record */\n-      if (rr_class == C_IN && rr_type == T_MX)\n-        {\n-          /* parse the MX record itself */\n-          if (rr_len < 2)\n-            {\n-              status = ARES_EBADRESP;\n-              break;\n-            }\n-\n-          /* Allocate storage for this MX answer appending it to the list */\n-          mx_curr = ares_malloc_data(ARES_DATATYPE_MX_REPLY);\n-          if (!mx_curr)\n-            {\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-          if (mx_last)\n-            {\n-              mx_last->next = mx_curr;\n-            }\n-          else\n-            {\n-              mx_head = mx_curr;\n-            }\n-          mx_last = mx_curr;\n-\n-          vptr = aptr;\n-          mx_curr->priority = DNS__16BIT(vptr);\n-          vptr += sizeof(unsigned short);\n-\n-          status = ares_expand_name (vptr, abuf, alen, &mx_curr->host, &len);\n-          if (status != ARES_SUCCESS)\n-            break;\n-        }\n-\n-      /* Don't lose memory in the next iteration */\n-      free (rr_name);\n-      rr_name = NULL;\n-\n-      /* Move on to the next record */\n-      aptr += rr_len;\n-    }\n-\n-  if (hostname)\n-    free (hostname);\n-  if (rr_name)\n-    free (rr_name);\n-\n-  /* clean up on error */\n-  if (status != ARES_SUCCESS)\n-    {\n-      if (mx_head)\n-        ares_free_data (mx_head);\n-      return status;\n-    }\n-\n-  /* everything looks fine, return the data */\n-  *mx_out = mx_head;\n-\n-  return ARES_SUCCESS;\n-}"}, {"sha": "5e9af71d1a9676f1d81992151f3eb3abe95ecbb3", "filename": "src/rt/libuv/src/ares/ares_parse_ns_reply.c", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ns_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,182 +0,0 @@\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-/*\n- * ares_parse_ns_reply created by Vlad Dinulescu <vlad.dinulescu@avira.com>\n- *      on behalf of AVIRA Gmbh - http://www.avira.com\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-int ares_parse_ns_reply( const unsigned char* abuf, int alen,\n-                         struct hostent** host )\n-{\n-  unsigned int qdcount, ancount;\n-  int status, i, rr_type, rr_class, rr_len;\n-  int nameservers_num;\n-  long len;\n-  const unsigned char *aptr;\n-  char* hostname, *rr_name, *rr_data, **nameservers;\n-  struct hostent *hostent;\n-\n-  /* Set *host to NULL for all failure cases. */\n-  *host = NULL;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if ( alen < HFIXEDSZ )\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT( abuf );\n-  ancount = DNS_HEADER_ANCOUNT( abuf );\n-  if ( qdcount != 1 )\n-    return ARES_EBADRESP;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares__expand_name_for_response( aptr, abuf, alen, &hostname, &len);\n-  if ( status != ARES_SUCCESS )\n-    return status;\n-  if ( aptr + len + QFIXEDSZ > abuf + alen )\n-  {\n-    free( hostname );\n-    return ARES_EBADRESP;\n-  }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Allocate nameservers array; ancount gives an upper bound */\n-  nameservers = malloc( ( ancount + 1 ) * sizeof( char * ) );\n-  if ( !nameservers )\n-  {\n-    free( hostname );\n-    return ARES_ENOMEM;\n-  }\n-  nameservers_num = 0;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for ( i = 0; i < ( int ) ancount; i++ )\n-  {\n-    /* Decode the RR up to the data field. */\n-    status = ares__expand_name_for_response( aptr, abuf, alen, &rr_name, &len );\n-    if ( status != ARES_SUCCESS )\n-      break;\n-    aptr += len;\n-    if ( aptr + RRFIXEDSZ > abuf + alen )\n-    {\n-      status = ARES_EBADRESP;\n-      free(rr_name);\n-      break;\n-    }\n-    rr_type = DNS_RR_TYPE( aptr );\n-    rr_class = DNS_RR_CLASS( aptr );\n-    rr_len = DNS_RR_LEN( aptr );\n-    aptr += RRFIXEDSZ;\n-\n-    if ( rr_class == C_IN && rr_type == T_NS )\n-    {\n-      /* Decode the RR data and add it to the nameservers list */\n-      status = ares__expand_name_for_response( aptr, abuf, alen, &rr_data,\n-                                               &len);\n-      if ( status != ARES_SUCCESS )\n-      {\n-        free(rr_name);\n-        break;\n-      }\n-\n-      nameservers[nameservers_num] = malloc(strlen(rr_data)+1);\n-\n-      if (nameservers[nameservers_num]==NULL)\n-      {\n-        free(rr_name);\n-        free(rr_data);\n-        status=ARES_ENOMEM;\n-        break;\n-      }\n-      strcpy(nameservers[nameservers_num],rr_data);\n-      free(rr_data);\n-\n-      nameservers_num++;\n-    }\n-\n-    free( rr_name );\n-\n-    aptr += rr_len;\n-    if ( aptr > abuf + alen )\n-    {\n-      status = ARES_EBADRESP;\n-      break;\n-    }\n-  }\n-\n-  if ( status == ARES_SUCCESS && nameservers_num == 0 )\n-  {\n-    status = ARES_ENODATA;\n-  }\n-  if ( status == ARES_SUCCESS )\n-  {\n-    /* We got our answer.  Allocate memory to build the host entry. */\n-    nameservers[nameservers_num] = NULL;\n-    hostent = malloc( sizeof( struct hostent ) );\n-    if ( hostent )\n-    {\n-      hostent->h_addr_list = malloc( 1 * sizeof( char * ) );\n-      if ( hostent->h_addr_list )\n-      {\n-        /* Fill in the hostent and return successfully. */\n-        hostent->h_name = hostname;\n-        hostent->h_aliases = nameservers;\n-        hostent->h_addrtype = AF_INET;\n-        hostent->h_length = sizeof( struct in_addr );\n-        hostent->h_addr_list[0] = NULL;\n-        *host = hostent;\n-        return ARES_SUCCESS;\n-      }\n-      free( hostent );\n-    }\n-    status = ARES_ENOMEM;\n-  }\n-  for ( i = 0; i < nameservers_num; i++ )\n-    free( nameservers[i] );\n-  free( nameservers );\n-  free( hostname );\n-  return status;\n-}"}, {"sha": "3b6dbc32e07338f6516a6d035d40247ef448d623", "filename": "src/rt/libuv/src/ares/ares_parse_ptr_reply.c", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_ptr_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,217 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-int ares_parse_ptr_reply(const unsigned char *abuf, int alen, const void *addr,\n-                         int addrlen, int family, struct hostent **host)\n-{\n-  unsigned int qdcount, ancount;\n-  int status, i, rr_type, rr_class, rr_len;\n-  long len;\n-  const unsigned char *aptr;\n-  char *ptrname, *hostname, *rr_name, *rr_data;\n-  struct hostent *hostent;\n-  int aliascnt = 0;\n-  int alias_alloc = 8;\n-  char ** aliases;\n-\n-  /* Set *host to NULL for all failure cases. */\n-  *host = NULL;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT(abuf);\n-  ancount = DNS_HEADER_ANCOUNT(abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares__expand_name_for_response(aptr, abuf, alen, &ptrname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free(ptrname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  hostname = NULL;\n-  aliases = malloc(alias_alloc * sizeof(char *));\n-  if (!aliases)\n-    {\n-      free(ptrname);\n-      return ARES_ENOMEM;\n-    }\n-  for (i = 0; i < (int)ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares__expand_name_for_response(aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        break;\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          free(rr_name);\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE(aptr);\n-      rr_class = DNS_RR_CLASS(aptr);\n-      rr_len = DNS_RR_LEN(aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      if (rr_class == C_IN && rr_type == T_PTR\n-          && strcasecmp(rr_name, ptrname) == 0)\n-        {\n-          /* Decode the RR data and set hostname to it. */\n-          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n-                                                  &len);\n-          if (status != ARES_SUCCESS)\n-            {\n-              free(rr_name);\n-              break;\n-            }\n-          if (hostname)\n-            free(hostname);\n-          hostname = rr_data;\n-          aliases[aliascnt] = malloc((strlen(rr_data)+1) * sizeof(char));\n-          if (!aliases[aliascnt])\n-            {\n-              free(rr_name);\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-          strncpy(aliases[aliascnt], rr_data, strlen(rr_data)+1);\n-          aliascnt++;\n-          if (aliascnt >= alias_alloc) {\n-            char **ptr;\n-            alias_alloc *= 2;\n-            ptr = realloc(aliases, alias_alloc * sizeof(char *));\n-            if(!ptr) {\n-              free(rr_name);\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-            aliases = ptr;\n-          }\n-        }\n-\n-      if (rr_class == C_IN && rr_type == T_CNAME)\n-        {\n-          /* Decode the RR data and replace ptrname with it. */\n-          status = ares__expand_name_for_response(aptr, abuf, alen, &rr_data,\n-                                                  &len);\n-          if (status != ARES_SUCCESS)\n-            {\n-              free(rr_name);\n-              break;\n-            }\n-          free(ptrname);\n-          ptrname = rr_data;\n-        }\n-\n-      free(rr_name);\n-      aptr += rr_len;\n-      if (aptr > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-    }\n-\n-  if (status == ARES_SUCCESS && !hostname)\n-    status = ARES_ENODATA;\n-  if (status == ARES_SUCCESS)\n-    {\n-      /* We got our answer.  Allocate memory to build the host entry. */\n-      hostent = malloc(sizeof(struct hostent));\n-      if (hostent)\n-        {\n-          hostent->h_addr_list = malloc(2 * sizeof(char *));\n-          if (hostent->h_addr_list)\n-            {\n-              hostent->h_addr_list[0] = malloc(addrlen);\n-              if (hostent->h_addr_list[0])\n-                {\n-                  hostent->h_aliases = malloc((aliascnt+1) * sizeof (char *));\n-                  if (hostent->h_aliases)\n-                    {\n-                      /* Fill in the hostent and return successfully. */\n-                      hostent->h_name = hostname;\n-                      for (i=0 ; i<aliascnt ; i++)\n-                        hostent->h_aliases[i] = aliases[i];\n-                      hostent->h_aliases[aliascnt] = NULL;\n-                      hostent->h_addrtype = family;\n-                      hostent->h_length = addrlen;\n-                      memcpy(hostent->h_addr_list[0], addr, addrlen);\n-                      hostent->h_addr_list[1] = NULL;\n-                      *host = hostent;\n-                      free(aliases);\n-                      free(ptrname);\n-                      return ARES_SUCCESS;\n-                    }\n-                  free(hostent->h_addr_list[0]);\n-                }\n-              free(hostent->h_addr_list);\n-            }\n-          free(hostent);\n-        }\n-      status = ARES_ENOMEM;\n-    }\n-  for (i=0 ; i<aliascnt ; i++)\n-    if (aliases[i]) \n-      free(aliases[i]);\n-  free(aliases);\n-  if (hostname)\n-    free(hostname);\n-  free(ptrname);\n-  return status;\n-}"}, {"sha": "9c7eb6ee3d32df37f840011a34665385b92a875c", "filename": "src/rt/libuv/src/ares/ares_parse_srv_reply.c", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_srv_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,179 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2009 by Jakub Hrozek <jhrozek@redhat.com>\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_data.h\"\n-#include \"ares_private.h\"\n-\n-/* AIX portability check */\n-#ifndef T_SRV\n-#  define T_SRV 33 /* server selection */\n-#endif\n-\n-int\n-ares_parse_srv_reply (const unsigned char *abuf, int alen,\n-                      struct ares_srv_reply **srv_out)\n-{\n-  unsigned int qdcount, ancount, i;\n-  const unsigned char *aptr, *vptr;\n-  int status, rr_type, rr_class, rr_len;\n-  long len;\n-  char *hostname = NULL, *rr_name = NULL;\n-  struct ares_srv_reply *srv_head = NULL;\n-  struct ares_srv_reply *srv_last = NULL;\n-  struct ares_srv_reply *srv_curr;\n-\n-  /* Set *srv_out to NULL for all failure cases. */\n-  *srv_out = NULL;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT (abuf);\n-  ancount = DNS_HEADER_ANCOUNT (abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-  if (ancount == 0)\n-    return ARES_ENODATA;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free (hostname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for (i = 0; i < ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        {\n-          break;\n-        }\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE (aptr);\n-      rr_class = DNS_RR_CLASS (aptr);\n-      rr_len = DNS_RR_LEN (aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      /* Check if we are really looking at a SRV record */\n-      if (rr_class == C_IN && rr_type == T_SRV)\n-        {\n-          /* parse the SRV record itself */\n-          if (rr_len < 6)\n-            {\n-              status = ARES_EBADRESP;\n-              break;\n-            }\n-\n-          /* Allocate storage for this SRV answer appending it to the list */\n-          srv_curr = ares_malloc_data(ARES_DATATYPE_SRV_REPLY);\n-          if (!srv_curr)\n-            {\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-          if (srv_last)\n-            {\n-              srv_last->next = srv_curr;\n-            }\n-          else\n-            {\n-              srv_head = srv_curr;\n-            }\n-          srv_last = srv_curr;\n-\n-          vptr = aptr;\n-          srv_curr->priority = DNS__16BIT(vptr);\n-          vptr += sizeof(unsigned short);\n-          srv_curr->weight = DNS__16BIT(vptr);\n-          vptr += sizeof(unsigned short);\n-          srv_curr->port = DNS__16BIT(vptr);\n-          vptr += sizeof(unsigned short);\n-\n-          status = ares_expand_name (vptr, abuf, alen, &srv_curr->host, &len);\n-          if (status != ARES_SUCCESS)\n-            break;\n-        }\n-\n-      /* Don't lose memory in the next iteration */\n-      free (rr_name);\n-      rr_name = NULL;\n-\n-      /* Move on to the next record */\n-      aptr += rr_len;\n-    }\n-\n-  if (hostname)\n-    free (hostname);\n-  if (rr_name)\n-    free (rr_name);\n-\n-  /* clean up on error */\n-  if (status != ARES_SUCCESS)\n-    {\n-      if (srv_head)\n-        ares_free_data (srv_head);\n-      return status;\n-    }\n-\n-  /* everything looks fine, return the data */\n-  *srv_out = srv_head;\n-\n-  return ARES_SUCCESS;\n-}"}, {"sha": "51653328eb0203b24ee1f1a657191bb68ddb6adf", "filename": "src/rt/libuv/src/ares/ares_parse_txt_reply.c", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_parse_txt_reply.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,201 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2009 by Jakub Hrozek <jhrozek@redhat.com>\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#  include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_data.h\"\n-#include \"ares_private.h\"\n-\n-int\n-ares_parse_txt_reply (const unsigned char *abuf, int alen,\n-                      struct ares_txt_reply **txt_out)\n-{\n-  size_t substr_len, str_len;\n-  unsigned int qdcount, ancount, i;\n-  const unsigned char *aptr;\n-  const unsigned char *strptr;\n-  int status, rr_type, rr_class, rr_len;\n-  long len;\n-  char *hostname = NULL, *rr_name = NULL;\n-  struct ares_txt_reply *txt_head = NULL;\n-  struct ares_txt_reply *txt_last = NULL;\n-  struct ares_txt_reply *txt_curr;\n-\n-  /* Set *txt_out to NULL for all failure cases. */\n-  *txt_out = NULL;\n-\n-  /* Give up if abuf doesn't have room for a header. */\n-  if (alen < HFIXEDSZ)\n-    return ARES_EBADRESP;\n-\n-  /* Fetch the question and answer count from the header. */\n-  qdcount = DNS_HEADER_QDCOUNT (abuf);\n-  ancount = DNS_HEADER_ANCOUNT (abuf);\n-  if (qdcount != 1)\n-    return ARES_EBADRESP;\n-  if (ancount == 0)\n-    return ARES_ENODATA;\n-\n-  /* Expand the name from the question, and skip past the question. */\n-  aptr = abuf + HFIXEDSZ;\n-  status = ares_expand_name (aptr, abuf, alen, &hostname, &len);\n-  if (status != ARES_SUCCESS)\n-    return status;\n-\n-  if (aptr + len + QFIXEDSZ > abuf + alen)\n-    {\n-      free (hostname);\n-      return ARES_EBADRESP;\n-    }\n-  aptr += len + QFIXEDSZ;\n-\n-  /* Examine each answer resource record (RR) in turn. */\n-  for (i = 0; i < ancount; i++)\n-    {\n-      /* Decode the RR up to the data field. */\n-      status = ares_expand_name (aptr, abuf, alen, &rr_name, &len);\n-      if (status != ARES_SUCCESS)\n-        {\n-          break;\n-        }\n-      aptr += len;\n-      if (aptr + RRFIXEDSZ > abuf + alen)\n-        {\n-          status = ARES_EBADRESP;\n-          break;\n-        }\n-      rr_type = DNS_RR_TYPE (aptr);\n-      rr_class = DNS_RR_CLASS (aptr);\n-      rr_len = DNS_RR_LEN (aptr);\n-      aptr += RRFIXEDSZ;\n-\n-      /* Check if we are really looking at a TXT record */\n-      if (rr_class == C_IN && rr_type == T_TXT)\n-        {\n-          /* Allocate storage for this TXT answer appending it to the list */\n-          txt_curr = ares_malloc_data(ARES_DATATYPE_TXT_REPLY);\n-          if (!txt_curr)\n-            {\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-          if (txt_last)\n-            {\n-              txt_last->next = txt_curr;\n-            }\n-          else\n-            {\n-              txt_head = txt_curr;\n-            }\n-          txt_last = txt_curr;\n-\n-          /*\n-           * There may be multiple substrings in a single TXT record. Each\n-           * substring may be up to 255 characters in length, with a\n-           * \"length byte\" indicating the size of the substring payload.\n-           * RDATA contains both the length-bytes and payloads of all\n-           * substrings contained therein.\n-           */\n-\n-          /* Compute total length to allow a single memory allocation */\n-          strptr = aptr;\n-          while (strptr < (aptr + rr_len))\n-            {\n-              substr_len = (unsigned char)*strptr;\n-              txt_curr->length += substr_len;\n-              strptr += substr_len + 1;\n-            }\n-\n-          /* Including null byte */\n-          txt_curr->txt = malloc (txt_curr->length + 1);\n-          if (txt_curr->txt == NULL)\n-            {\n-              status = ARES_ENOMEM;\n-              break;\n-            }\n-\n-          /* Step through the list of substrings, concatenating them */\n-          str_len = 0;\n-          strptr = aptr;\n-          while (strptr < (aptr + rr_len))\n-            {\n-              substr_len = (unsigned char)*strptr;\n-              strptr++;\n-              memcpy ((char *) txt_curr->txt + str_len, strptr, substr_len);\n-              str_len += substr_len;\n-              strptr += substr_len;\n-            }\n-          /* Make sure we NULL-terminate */\n-          *((char *) txt_curr->txt + txt_curr->length) = '\\0';\n-        }\n-\n-      /* Don't lose memory in the next iteration */\n-      free (rr_name);\n-      rr_name = NULL;\n-\n-      /* Move on to the next record */\n-      aptr += rr_len;\n-    }\n-\n-  if (hostname)\n-    free (hostname);\n-  if (rr_name)\n-    free (rr_name);\n-\n-  /* clean up on error */\n-  if (status != ARES_SUCCESS)\n-    {\n-      if (txt_head)\n-        ares_free_data (txt_head);\n-      return status;\n-    }\n-\n-  /* everything looks fine, return the data */\n-  *txt_out = txt_head;\n-\n-  return ARES_SUCCESS;\n-}"}, {"sha": "c20061583f42d61fa905d711e408a8d2dee96792", "filename": "src/rt/libuv/src/ares/ares_platform.c", "status": "removed", "additions": 0, "deletions": 11035, "changes": 11035, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e6885ae546155a8aed2a1e63f0985d5d9d304c66", "filename": "src/rt/libuv/src/ares/ares_platform.h", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_platform.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,43 +0,0 @@\n-#ifndef HEADER_CARES_PLATFORM_H\n-#define HEADER_CARES_PLATFORM_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004 - 2011 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#if defined(WIN32) && !defined(MSDOS)\n-\n-typedef enum {\n-  WIN_UNKNOWN,\n-  WIN_3X,\n-  WIN_9X,\n-  WIN_NT,\n-  WIN_CE\n-} win_platform;\n-\n-win_platform ares__getplatform(void);\n-\n-#endif\n-\n-#if defined(_WIN32_WCE)\n-\n-struct servent *getservbyport(int port, const char *proto);\n-\n-#endif\n-\n-#endif /* HEADER_CARES_PLATFORM_H */"}, {"sha": "ff45ba7e5ac10ee79cae4563ab0d0f66d2dcd8b6", "filename": "src/rt/libuv/src/ares/ares_private.h", "status": "removed", "additions": 0, "deletions": 355, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_private.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,355 +0,0 @@\n-#ifndef __ARES_PRIVATE_H\n-#define __ARES_PRIVATE_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2010 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-/*\n- * Define WIN32 when build target is Win32 API\n- */\n-\n-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n-#define WIN32\n-#endif\n-\n-#include <stdio.h>\n-#include <sys/types.h>\n-\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-\n-#ifdef WATT32\n-#include <tcp.h>\n-#include <sys/ioctl.h>\n-#define writev(s,v,c)     writev_s(s,v,c)\n-#define HAVE_WRITEV 1\n-#endif\n-\n-#ifdef NETWARE\n-#include <time.h>\n-#endif\n-\n-#define DEFAULT_TIMEOUT         5000 /* milliseconds */\n-#define DEFAULT_TRIES           4\n-#ifndef INADDR_NONE\n-#define INADDR_NONE 0xffffffff\n-#endif\n-\n-#if defined(WIN32) && !defined(WATT32)\n-\n-#define WIN_NS_9X      \"System\\\\CurrentControlSet\\\\Services\\\\VxD\\\\MSTCP\"\n-#define WIN_NS_NT_KEY  \"System\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters\"\n-#define NAMESERVER     \"NameServer\"\n-#define DHCPNAMESERVER \"DhcpNameServer\"\n-#define DATABASEPATH   \"DatabasePath\"\n-#define WIN_PATH_HOSTS  \"\\\\hosts\"\n-\n-#elif defined(WATT32)\n-\n-#define PATH_RESOLV_CONF \"/dev/ENV/etc/resolv.conf\"\n-\n-#elif defined(NETWARE)\n-\n-#define PATH_RESOLV_CONF \"sys:/etc/resolv.cfg\"\n-#define PATH_HOSTS              \"sys:/etc/hosts\"\n-\n-#elif defined(__riscos__)\n-\n-#define PATH_HOSTS             \"InetDBase:Hosts\"\n-\n-#else\n-\n-#define PATH_RESOLV_CONF        \"/etc/resolv.conf\"\n-#ifdef ETC_INET\n-#define PATH_HOSTS              \"/etc/inet/hosts\"\n-#else\n-#define PATH_HOSTS              \"/etc/hosts\"\n-#endif\n-\n-#endif\n-\n-#define ARES_ID_KEY_LEN 31\n-\n-#include \"ares_ipv6.h\"\n-#include \"ares_llist.h\"\n-\n-#ifndef HAVE_GETENV\n-#  include \"ares_getenv.h\"\n-#  define getenv(ptr) ares_getenv(ptr)\n-#endif\n-\n-#ifndef HAVE_STRDUP\n-#  include \"ares_strdup.h\"\n-#  define strdup(ptr) ares_strdup(ptr)\n-#endif\n-\n-#ifndef HAVE_STRCASECMP\n-#  include \"ares_strcasecmp.h\"\n-#  define strcasecmp(p1,p2) ares_strcasecmp(p1,p2)\n-#endif\n-\n-#ifndef HAVE_STRNCASECMP\n-#  include \"ares_strcasecmp.h\"\n-#  define strncasecmp(p1,p2,n) ares_strncasecmp(p1,p2,n)\n-#endif\n-\n-#ifndef HAVE_WRITEV\n-#  include \"ares_writev.h\"\n-#  define writev(s,ptr,cnt) ares_writev(s,ptr,cnt)\n-#endif\n-\n-struct ares_addr {\n-  int family;\n-  union {\n-    struct in_addr       addr4;\n-    struct ares_in6_addr addr6;\n-  } addr;\n-};\n-#define addrV4 addr.addr4\n-#define addrV6 addr.addr6\n-\n-struct query;\n-\n-struct send_request {\n-  /* Remaining data to send */\n-  const unsigned char *data;\n-  size_t len;\n-\n-  /* The query for which we're sending this data */\n-  struct query* owner_query;\n-  /* The buffer we're using, if we have our own copy of the packet */\n-  unsigned char *data_storage;\n-\n-  /* Next request in queue */\n-  struct send_request *next;\n-};\n-\n-struct server_state {\n-  struct ares_addr addr;\n-  ares_socket_t udp_socket;\n-  ares_socket_t tcp_socket;\n-\n-  /* Mini-buffer for reading the length word */\n-  unsigned char tcp_lenbuf[2];\n-  int tcp_lenbuf_pos;\n-  int tcp_length;\n-\n-  /* Buffer for reading actual TCP data */\n-  unsigned char *tcp_buffer;\n-  int tcp_buffer_pos;\n-\n-  /* TCP output queue */\n-  struct send_request *qhead;\n-  struct send_request *qtail;\n-\n-  /* Which incarnation of this connection is this? We don't want to\n-   * retransmit requests into the very same socket, but if the server\n-   * closes on us and we re-open the connection, then we do want to\n-   * re-send. */\n-  int tcp_connection_generation;\n-\n-  /* Circular, doubly-linked list of outstanding queries to this server */\n-  struct list_node queries_to_server;\n-\n-  /* Link back to owning channel */\n-  ares_channel channel;\n-\n-  /* Is this server broken? We mark connections as broken when a\n-   * request that is queued for sending times out.\n-   */\n-  int is_broken;\n-};\n-\n-/* State to represent a DNS query */\n-struct query {\n-  /* Query ID from qbuf, for faster lookup, and current timeout */\n-  unsigned short qid;\n-  struct timeval timeout;\n-\n-  /*\n-   * Links for the doubly-linked lists in which we insert a query.\n-   * These circular, doubly-linked lists that are hash-bucketed based\n-   * the attributes we care about, help making most important\n-   * operations O(1).\n-   */\n-  struct list_node queries_by_qid;    /* hopefully in same cache line as qid */\n-  struct list_node queries_by_timeout;\n-  struct list_node queries_to_server;\n-  struct list_node all_queries;\n-\n-  /* Query buf with length at beginning, for TCP transmission */\n-  unsigned char *tcpbuf;\n-  int tcplen;\n-\n-  /* Arguments passed to ares_send() (qbuf points into tcpbuf) */\n-  const unsigned char *qbuf;\n-  int qlen;\n-  ares_callback callback;\n-  void *arg;\n-\n-  /* Query status */\n-  int try_count; /* Number of times we tried this query already. */\n-  int server; /* Server this query has last been sent to. */\n-  struct query_server_info *server_info;   /* per-server state */\n-  int using_tcp;\n-  int error_status;\n-  int timeouts; /* number of timeouts we saw for this request */\n-};\n-\n-/* Per-server state for a query */\n-struct query_server_info {\n-  int skip_server;  /* should we skip server, due to errors, etc? */\n-  int tcp_connection_generation;  /* into which TCP connection did we send? */\n-};\n-\n-/* An IP address pattern; matches an IP address X if X & mask == addr */\n-#define PATTERN_MASK 0x1\n-#define PATTERN_CIDR 0x2\n-\n-struct apattern {\n-  union\n-  {\n-    struct in_addr       addr4;\n-    struct ares_in6_addr addr6;\n-  } addr;\n-  union\n-  {\n-    struct in_addr       addr4;\n-    struct ares_in6_addr addr6;\n-    unsigned short       bits;\n-  } mask;\n-  int family;\n-  unsigned short type;\n-};\n-\n-typedef struct rc4_key\n-{\n-  unsigned char state[256];\n-  unsigned char x;\n-  unsigned char y;\n-} rc4_key;\n-\n-struct ares_channeldata {\n-  /* Configuration data */\n-  int flags;\n-  int timeout; /* in milliseconds */\n-  int tries;\n-  int ndots;\n-  int rotate; /* if true, all servers specified are used */\n-  int udp_port;\n-  int tcp_port;\n-  int socket_send_buffer_size;\n-  int socket_receive_buffer_size;\n-  char **domains;\n-  int ndomains;\n-  struct apattern *sortlist;\n-  int nsort;\n-  char *lookups;\n-\n-  /* For binding to local devices and/or IP addresses.  Leave\n-   * them null/zero for no binding.\n-   */\n-  char local_dev_name[32];\n-  unsigned int local_ip4;\n-  unsigned char local_ip6[16];\n-\n-  int optmask; /* the option bitfield passed in at init time */\n-\n-  /* Server addresses and communications state */\n-  struct server_state *servers;\n-  int nservers;\n-\n-  /* ID to use for next query */\n-  unsigned short next_id;\n-  /* key to use when generating new ids */\n-  rc4_key id_key;\n-\n-  /* Generation number to use for the next TCP socket open/close */\n-  int tcp_connection_generation;\n-\n-  /* The time at which we last called process_timeouts(). Uses integer seconds\n-     just to draw the line somewhere. */\n-  time_t last_timeout_processed;\n-\n-  /* Last server we sent a query to. */\n-  int last_server;\n-\n-  /* Circular, doubly-linked list of queries, bucketed various ways.... */\n-  /* All active queries in a single list: */\n-  struct list_node all_queries;\n-  /* Queries bucketed by qid, for quickly dispatching DNS responses: */\n-#define ARES_QID_TABLE_SIZE 2048\n-  struct list_node queries_by_qid[ARES_QID_TABLE_SIZE];\n-  /* Queries bucketed by timeout, for quickly handling timeouts: */\n-#define ARES_TIMEOUT_TABLE_SIZE 1024\n-  struct list_node queries_by_timeout[ARES_TIMEOUT_TABLE_SIZE];\n-\n-  ares_sock_state_cb sock_state_cb;\n-  void *sock_state_cb_data;\n-\n-  ares_sock_create_callback sock_create_cb;\n-  void *sock_create_cb_data;\n-};\n-\n-/* return true if now is exactly check time or later */\n-int ares__timedout(struct timeval *now,\n-                   struct timeval *check);\n-/* add the specific number of milliseconds to the time in the first argument */\n-int ares__timeadd(struct timeval *now,\n-                  int millisecs);\n-/* return time offset between now and (future) check, in milliseconds */\n-long ares__timeoffset(struct timeval *now,\n-                      struct timeval *check);\n-/* returns ARES_SUCCESS if library has been initialized */\n-int ares_library_initialized(void);\n-void ares__rc4(rc4_key* key,unsigned char *buffer_ptr, int buffer_len);\n-void ares__send_query(ares_channel channel, struct query *query,\n-                      struct timeval *now);\n-void ares__close_sockets(ares_channel channel, struct server_state *server);\n-int ares__get_hostent(FILE *fp, int family, struct hostent **host);\n-int ares__read_line(FILE *fp, char **buf, size_t *bufsize);\n-void ares__free_query(struct query *query);\n-unsigned short ares__generate_new_id(rc4_key* key);\n-struct timeval ares__tvnow(void);\n-int ares__expand_name_for_response(const unsigned char *encoded,\n-                                   const unsigned char *abuf, int alen,\n-                                   char **s, long *enclen);\n-void ares__init_servers_state(ares_channel channel);\n-void ares__destroy_servers_state(ares_channel channel);\n-#if 0 /* Not used */\n-long ares__tvdiff(struct timeval t1, struct timeval t2);\n-#endif\n-\n-#define ARES_SWAP_BYTE(a,b) \\\n-  { unsigned char swapByte = *(a);  *(a) = *(b);  *(b) = swapByte; }\n-\n-#define SOCK_STATE_CALLBACK(c, s, r, w)                                 \\\n-  do {                                                                  \\\n-    if ((c)->sock_state_cb)                                             \\\n-      (c)->sock_state_cb((c)->sock_state_cb_data, (s), (r), (w));       \\\n-  } while (0)\n-\n-#ifdef CURLDEBUG\n-/* This is low-level hard-hacking memory leak tracking and similar. Using the\n-   libcurl lowlevel code from within library is ugly and only works when\n-   c-ares is built and linked with a similarly curldebug-enabled libcurl,\n-   but we do this anyway for convenience. */\n-#include \"../lib/memdebug.h\"\n-#endif\n-\n-#endif /* __ARES_PRIVATE_H */"}, {"sha": "e5efa5fb304b2870f5a161cac285c59222f11380", "filename": "src/rt/libuv/src/ares/ares_process.c", "status": "removed", "additions": 0, "deletions": 1295, "changes": 1295, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_process.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,1295 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- * Copyright (C) 2004-2010 by Daniel Stenberg\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_SYS_UIO_H\n-#  include <sys/uio.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_NETINET_TCP_H\n-#  include <netinet/tcp.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#  include <netdb.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#ifdef HAVE_SYS_TIME_H\n-#  include <sys/time.h>\n-#endif\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-#ifdef HAVE_UNISTD_H\n-#  include <unistd.h>\n-#endif\n-#ifdef HAVE_SYS_IOCTL_H\n-#  include <sys/ioctl.h>\n-#endif\n-#ifdef NETWARE\n-#  include <sys/filio.h>\n-#endif\n-\n-#include <assert.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <fcntl.h>\n-#include <time.h>\n-\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_nowarn.h\"\n-#include \"ares_private.h\"\n-\n-\n-static int try_again(int errnum);\n-static void write_tcp_data(ares_channel channel, fd_set *write_fds,\n-                           ares_socket_t write_fd, struct timeval *now);\n-static void read_tcp_data(ares_channel channel, fd_set *read_fds,\n-                          ares_socket_t read_fd, struct timeval *now);\n-static void read_udp_packets(ares_channel channel, fd_set *read_fds,\n-                             ares_socket_t read_fd, struct timeval *now);\n-static void advance_tcp_send_queue(ares_channel channel, int whichserver,\n-                                   ssize_t num_bytes);\n-static void process_timeouts(ares_channel channel, struct timeval *now);\n-static void process_broken_connections(ares_channel channel,\n-                                       struct timeval *now);\n-static void process_answer(ares_channel channel, unsigned char *abuf,\n-                           int alen, int whichserver, int tcp,\n-                           struct timeval *now);\n-static void handle_error(ares_channel channel, int whichserver,\n-                         struct timeval *now);\n-static void skip_server(ares_channel channel, struct query *query,\n-                        int whichserver);\n-static void next_server(ares_channel channel, struct query *query,\n-                        struct timeval *now);\n-static int open_tcp_socket(ares_channel channel, struct server_state *server);\n-static int open_udp_socket(ares_channel channel, struct server_state *server);\n-static int same_questions(const unsigned char *qbuf, int qlen,\n-                          const unsigned char *abuf, int alen);\n-static int same_address(struct sockaddr *sa, struct ares_addr *aa);\n-static void end_query(ares_channel channel, struct query *query, int status,\n-                      unsigned char *abuf, int alen);\n-\n-/* return true if now is exactly check time or later */\n-int ares__timedout(struct timeval *now,\n-                   struct timeval *check)\n-{\n-  long secs = (now->tv_sec - check->tv_sec);\n-\n-  if(secs > 0)\n-    return 1; /* yes, timed out */\n-  if(secs < 0)\n-    return 0; /* nope, not timed out */\n-\n-  /* if the full seconds were identical, check the sub second parts */\n-  return (now->tv_usec - check->tv_usec >= 0);\n-}\n-\n-/* add the specific number of milliseconds to the time in the first argument */\n-int ares__timeadd(struct timeval *now,\n-                  int millisecs)\n-{\n-  now->tv_sec += millisecs/1000;\n-  now->tv_usec += (millisecs%1000)*1000;\n-\n-  if(now->tv_usec >= 1000000) {\n-    ++(now->tv_sec);\n-    now->tv_usec -= 1000000;\n-  }\n-\n-  return 0;\n-}\n-\n-/* return time offset between now and (future) check, in milliseconds */\n-long ares__timeoffset(struct timeval *now,\n-                      struct timeval *check)\n-{\n-  return (check->tv_sec - now->tv_sec)*1000 +\n-         (check->tv_usec - now->tv_usec)/1000;\n-}\n-\n-\n-/*\n- * generic process function\n- */\n-static void processfds(ares_channel channel,\n-                       fd_set *read_fds, ares_socket_t read_fd,\n-                       fd_set *write_fds, ares_socket_t write_fd)\n-{\n-  struct timeval now = ares__tvnow();\n-\n-  write_tcp_data(channel, write_fds, write_fd, &now);\n-  read_tcp_data(channel, read_fds, read_fd, &now);\n-  read_udp_packets(channel, read_fds, read_fd, &now);\n-  process_timeouts(channel, &now);\n-  process_broken_connections(channel, &now);\n-}\n-\n-/* Something interesting happened on the wire, or there was a timeout.\n- * See what's up and respond accordingly.\n- */\n-void ares_process(ares_channel channel, fd_set *read_fds, fd_set *write_fds)\n-{\n-  processfds(channel, read_fds, ARES_SOCKET_BAD, write_fds, ARES_SOCKET_BAD);\n-}\n-\n-/* Something interesting happened on the wire, or there was a timeout.\n- * See what's up and respond accordingly.\n- */\n-void ares_process_fd(ares_channel channel,\n-                     ares_socket_t read_fd, /* use ARES_SOCKET_BAD or valid\n-                                               file descriptors */\n-                     ares_socket_t write_fd)\n-{\n-  processfds(channel, NULL, read_fd, NULL, write_fd);\n-}\n-\n-\n-/* Return 1 if the specified error number describes a readiness error, or 0\n- * otherwise. This is mostly for HP-UX, which could return EAGAIN or\n- * EWOULDBLOCK. See this man page\n- *\n- * http://devrsrc1.external.hp.com/STKS/cgi-bin/man2html?\n- *     manpage=/usr/share/man/man2.Z/send.2\n- */\n-static int try_again(int errnum)\n-{\n-#if !defined EWOULDBLOCK && !defined EAGAIN\n-#error \"Neither EWOULDBLOCK nor EAGAIN defined\"\n-#endif\n-  switch (errnum)\n-    {\n-#ifdef EWOULDBLOCK\n-    case EWOULDBLOCK:\n-      return 1;\n-#endif\n-#if defined EAGAIN && EAGAIN != EWOULDBLOCK\n-    case EAGAIN:\n-      return 1;\n-#endif\n-    }\n-  return 0;\n-}\n-\n-/* If any TCP sockets select true for writing, write out queued data\n- * we have for them.\n- */\n-static void write_tcp_data(ares_channel channel,\n-                           fd_set *write_fds,\n-                           ares_socket_t write_fd,\n-                           struct timeval *now)\n-{\n-  struct server_state *server;\n-  struct send_request *sendreq;\n-  struct iovec *vec;\n-  int i;\n-  ssize_t scount;\n-  ssize_t wcount;\n-  size_t n;\n-\n-  if(!write_fds && (write_fd == ARES_SOCKET_BAD))\n-    /* no possible action */\n-    return;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      /* Make sure server has data to send and is selected in write_fds or\n-         write_fd. */\n-      server = &channel->servers[i];\n-      if (!server->qhead || server->tcp_socket == ARES_SOCKET_BAD ||\n-          server->is_broken)\n-        continue;\n-\n-      if(write_fds) {\n-        if(!FD_ISSET(server->tcp_socket, write_fds))\n-          continue;\n-      }\n-      else {\n-        if(server->tcp_socket != write_fd)\n-          continue;\n-      }\n-\n-      if(write_fds)\n-        /* If there's an error and we close this socket, then open\n-         * another with the same fd to talk to another server, then we\n-         * don't want to think that it was the new socket that was\n-         * ready. This is not disastrous, but is likely to result in\n-         * extra system calls and confusion. */\n-        FD_CLR(server->tcp_socket, write_fds);\n-\n-      /* Count the number of send queue items. */\n-      n = 0;\n-      for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n-        n++;\n-\n-      /* Allocate iovecs so we can send all our data at once. */\n-      vec = malloc(n * sizeof(struct iovec));\n-      if (vec)\n-        {\n-          /* Fill in the iovecs and send. */\n-          n = 0;\n-          for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n-            {\n-              vec[n].iov_base = (char *) sendreq->data;\n-              vec[n].iov_len = sendreq->len;\n-              n++;\n-            }\n-          wcount = (ssize_t)writev(server->tcp_socket, vec, (int)n);\n-          free(vec);\n-          if (wcount < 0)\n-            {\n-              if (!try_again(SOCKERRNO))\n-                  handle_error(channel, i, now);\n-              continue;\n-            }\n-\n-          /* Advance the send queue by as many bytes as we sent. */\n-          advance_tcp_send_queue(channel, i, wcount);\n-        }\n-      else\n-        {\n-          /* Can't allocate iovecs; just send the first request. */\n-          sendreq = server->qhead;\n-\n-          scount = swrite(server->tcp_socket, sendreq->data, sendreq->len);\n-          if (scount < 0)\n-            {\n-              if (!try_again(SOCKERRNO))\n-                  handle_error(channel, i, now);\n-              continue;\n-            }\n-\n-          /* Advance the send queue by as many bytes as we sent. */\n-          advance_tcp_send_queue(channel, i, scount);\n-        }\n-    }\n-}\n-\n-/* Consume the given number of bytes from the head of the TCP send queue. */\n-static void advance_tcp_send_queue(ares_channel channel, int whichserver,\n-                                   ssize_t num_bytes)\n-{\n-  struct send_request *sendreq;\n-  struct server_state *server = &channel->servers[whichserver];\n-  while (num_bytes > 0) {\n-    sendreq = server->qhead;\n-    if ((size_t)num_bytes >= sendreq->len) {\n-      num_bytes -= sendreq->len;\n-      server->qhead = sendreq->next;\n-      if (sendreq->data_storage)\n-        free(sendreq->data_storage);\n-      free(sendreq);\n-      if (server->qhead == NULL) {\n-        SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 0);\n-        server->qtail = NULL;\n-\n-        /* qhead is NULL so we cannot continue this loop */\n-        break;\n-      }\n-    }\n-    else {\n-      sendreq->data += num_bytes;\n-      sendreq->len -= num_bytes;\n-      num_bytes = 0;\n-    }\n-  }\n-}\n-\n-/* If any TCP socket selects true for reading, read some data,\n- * allocate a buffer if we finish reading the length word, and process\n- * a packet if we finish reading one.\n- */\n-static void read_tcp_data(ares_channel channel, fd_set *read_fds,\n-                          ares_socket_t read_fd, struct timeval *now)\n-{\n-  struct server_state *server;\n-  int i;\n-  ssize_t count;\n-\n-  if(!read_fds && (read_fd == ARES_SOCKET_BAD))\n-    /* no possible action */\n-    return;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      /* Make sure the server has a socket and is selected in read_fds. */\n-      server = &channel->servers[i];\n-      if (server->tcp_socket == ARES_SOCKET_BAD || server->is_broken)\n-        continue;\n-\n-      if(read_fds) {\n-        if(!FD_ISSET(server->tcp_socket, read_fds))\n-          continue;\n-      }\n-      else {\n-        if(server->tcp_socket != read_fd)\n-          continue;\n-      }\n-\n-      if(read_fds)\n-        /* If there's an error and we close this socket, then open\n-         * another with the same fd to talk to another server, then we\n-         * don't want to think that it was the new socket that was\n-         * ready. This is not disastrous, but is likely to result in\n-         * extra system calls and confusion. */\n-        FD_CLR(server->tcp_socket, read_fds);\n-\n-      if (server->tcp_lenbuf_pos != 2)\n-        {\n-          /* We haven't yet read a length word, so read that (or\n-           * what's left to read of it).\n-           */\n-          count = sread(server->tcp_socket,\n-                        server->tcp_lenbuf + server->tcp_lenbuf_pos,\n-                        2 - server->tcp_lenbuf_pos);\n-          if (count <= 0)\n-            {\n-              if (!(count == -1 && try_again(SOCKERRNO)))\n-                  handle_error(channel, i, now);\n-              continue;\n-            }\n-\n-          server->tcp_lenbuf_pos += (int)count;\n-          if (server->tcp_lenbuf_pos == 2)\n-            {\n-              /* We finished reading the length word.  Decode the\n-               * length and allocate a buffer for the data.\n-               */\n-              server->tcp_length = server->tcp_lenbuf[0] << 8\n-                | server->tcp_lenbuf[1];\n-              server->tcp_buffer = malloc(server->tcp_length);\n-              if (!server->tcp_buffer)\n-                handle_error(channel, i, now);\n-              server->tcp_buffer_pos = 0;\n-            }\n-        }\n-      else\n-        {\n-          /* Read data into the allocated buffer. */\n-          count = sread(server->tcp_socket,\n-                        server->tcp_buffer + server->tcp_buffer_pos,\n-                        server->tcp_length - server->tcp_buffer_pos);\n-          if (count <= 0)\n-            {\n-              if (!(count == -1 && try_again(SOCKERRNO)))\n-                  handle_error(channel, i, now);\n-              continue;\n-            }\n-\n-          server->tcp_buffer_pos += (int)count;\n-          if (server->tcp_buffer_pos == server->tcp_length)\n-            {\n-              /* We finished reading this answer; process it and\n-               * prepare to read another length word.\n-               */\n-              process_answer(channel, server->tcp_buffer, server->tcp_length,\n-                             i, 1, now);\n-          if (server->tcp_buffer)\n-                        free(server->tcp_buffer);\n-              server->tcp_buffer = NULL;\n-              server->tcp_lenbuf_pos = 0;\n-              server->tcp_buffer_pos = 0;\n-            }\n-        }\n-    }\n-}\n-\n-/* If any UDP sockets select true for reading, process them. */\n-static void read_udp_packets(ares_channel channel, fd_set *read_fds,\n-                             ares_socket_t read_fd, struct timeval *now)\n-{\n-  struct server_state *server;\n-  int i;\n-  ssize_t count;\n-  unsigned char buf[PACKETSZ + 1];\n-#ifdef HAVE_RECVFROM\n-  ares_socklen_t fromlen;\n-  union {\n-    struct sockaddr     sa;\n-    struct sockaddr_in  sa4;\n-    struct sockaddr_in6 sa6;\n-  } from;\n-#endif\n-\n-  if(!read_fds && (read_fd == ARES_SOCKET_BAD))\n-    /* no possible action */\n-    return;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      /* Make sure the server has a socket and is selected in read_fds. */\n-      server = &channel->servers[i];\n-\n-      if (server->udp_socket == ARES_SOCKET_BAD || server->is_broken)\n-        continue;\n-\n-      if(read_fds) {\n-        if(!FD_ISSET(server->udp_socket, read_fds))\n-          continue;\n-      }\n-      else {\n-        if(server->udp_socket != read_fd)\n-          continue;\n-      }\n-\n-      if(read_fds)\n-        /* If there's an error and we close this socket, then open\n-         * another with the same fd to talk to another server, then we\n-         * don't want to think that it was the new socket that was\n-         * ready. This is not disastrous, but is likely to result in\n-         * extra system calls and confusion. */\n-        FD_CLR(server->udp_socket, read_fds);\n-\n-      /* To reduce event loop overhead, read and process as many\n-       * packets as we can. */\n-      do {\n-#ifdef HAVE_RECVFROM\n-        if (server->addr.family == AF_INET)\n-          fromlen = sizeof(from.sa4);\n-        else\n-          fromlen = sizeof(from.sa6);\n-        count = (ssize_t)recvfrom(server->udp_socket, (void *)buf, sizeof(buf),\n-                                  0, &from.sa, &fromlen);\n-#else\n-        count = sread(server->udp_socket, buf, sizeof(buf));\n-#endif\n-        if (count == -1 && try_again(SOCKERRNO))\n-          continue;\n-        else if (count <= 0)\n-          handle_error(channel, i, now);\n-#ifdef HAVE_RECVFROM\n-        else if (!same_address(&from.sa, &server->addr))\n-          /* The address the response comes from does not match\n-           * the address we sent the request to. Someone may be\n-           * attempting to perform a cache poisoning attack. */\n-          break;\n-#endif\n-        else\n-          process_answer(channel, buf, (int)count, i, 0, now);\n-       } while (count > 0);\n-    }\n-}\n-\n-/* If any queries have timed out, note the timeout and move them on. */\n-static void process_timeouts(ares_channel channel, struct timeval *now)\n-{\n-  time_t t;  /* the time of the timeouts we're processing */\n-  struct query *query;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-\n-  /* Process all the timeouts that have fired since the last time we\n-   * processed timeouts. If things are going well, then we'll have\n-   * hundreds/thousands of queries that fall into future buckets, and\n-   * only a handful of requests that fall into the \"now\" bucket, so\n-   * this should be quite quick.\n-   */\n-  for (t = channel->last_timeout_processed; t <= now->tv_sec; t++)\n-    {\n-      list_head = &(channel->queries_by_timeout[t % ARES_TIMEOUT_TABLE_SIZE]);\n-      for (list_node = list_head->next; list_node != list_head; )\n-        {\n-          query = list_node->data;\n-          list_node = list_node->next;  /* in case the query gets deleted */\n-          if (query->timeout.tv_sec && ares__timedout(now, &query->timeout))\n-            {\n-              query->error_status = ARES_ETIMEOUT;\n-              ++query->timeouts;\n-              next_server(channel, query, now);\n-            }\n-        }\n-     }\n-  channel->last_timeout_processed = now->tv_sec;\n-}\n-\n-/* Handle an answer from a server. */\n-static void process_answer(ares_channel channel, unsigned char *abuf,\n-                           int alen, int whichserver, int tcp,\n-                           struct timeval *now)\n-{\n-  int tc, rcode;\n-  unsigned short id;\n-  struct query *query;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-\n-  /* If there's no room in the answer for a header, we can't do much\n-   * with it. */\n-  if (alen < HFIXEDSZ)\n-    return;\n-\n-  /* Grab the query ID, truncate bit, and response code from the packet. */\n-  id = DNS_HEADER_QID(abuf);\n-  tc = DNS_HEADER_TC(abuf);\n-  rcode = DNS_HEADER_RCODE(abuf);\n-\n-  /* Find the query corresponding to this packet. The queries are\n-   * hashed/bucketed by query id, so this lookup should be quick.\n-   * Note that both the query id and the questions must be the same;\n-   * when the query id wraps around we can have multiple outstanding\n-   * queries with the same query id, so we need to check both the id and\n-   * question.\n-   */\n-  query = NULL;\n-  list_head = &(channel->queries_by_qid[id % ARES_QID_TABLE_SIZE]);\n-  for (list_node = list_head->next; list_node != list_head;\n-       list_node = list_node->next)\n-    {\n-      struct query *q = list_node->data;\n-      if ((q->qid == id) && same_questions(q->qbuf, q->qlen, abuf, alen))\n-        {\n-          query = q;\n-          break;\n-        }\n-    }\n-  if (!query)\n-    return;\n-\n-  /* If we got a truncated UDP packet and are not ignoring truncation,\n-   * don't accept the packet, and switch the query to TCP if we hadn't\n-   * done so already.\n-   */\n-  if ((tc || alen > PACKETSZ) && !tcp && !(channel->flags & ARES_FLAG_IGNTC))\n-    {\n-      if (!query->using_tcp)\n-        {\n-          query->using_tcp = 1;\n-          ares__send_query(channel, query, now);\n-        }\n-      return;\n-    }\n-\n-  /* Limit alen to PACKETSZ if we aren't using TCP (only relevant if we\n-   * are ignoring truncation.\n-   */\n-  if (alen > PACKETSZ && !tcp)\n-    alen = PACKETSZ;\n-\n-  /* If we aren't passing through all error packets, discard packets\n-   * with SERVFAIL, NOTIMP, or REFUSED response codes.\n-   */\n-  if (!(channel->flags & ARES_FLAG_NOCHECKRESP))\n-    {\n-      if (rcode == SERVFAIL || rcode == NOTIMP || rcode == REFUSED)\n-        {\n-          skip_server(channel, query, whichserver);\n-          if (query->server == whichserver)\n-            next_server(channel, query, now);\n-          return;\n-        }\n-    }\n-\n-  end_query(channel, query, ARES_SUCCESS, abuf, alen);\n-}\n-\n-/* Close all the connections that are no longer usable. */\n-static void process_broken_connections(ares_channel channel,\n-                                       struct timeval *now)\n-{\n-  int i;\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      struct server_state *server = &channel->servers[i];\n-      if (server->is_broken)\n-        {\n-          handle_error(channel, i, now);\n-        }\n-    }\n-}\n-\n-static void handle_error(ares_channel channel, int whichserver,\n-                         struct timeval *now)\n-{\n-  struct server_state *server;\n-  struct query *query;\n-  struct list_node list_head;\n-  struct list_node* list_node;\n-\n-  server = &channel->servers[whichserver];\n-\n-  /* Reset communications with this server. */\n-  ares__close_sockets(channel, server);\n-\n-  /* Tell all queries talking to this server to move on and not try\n-   * this server again. We steal the current list of queries that were\n-   * in-flight to this server, since when we call next_server this can\n-   * cause the queries to be re-sent to this server, which will\n-   * re-insert these queries in that same server->queries_to_server\n-   * list.\n-   */\n-  ares__init_list_head(&list_head);\n-  ares__swap_lists(&list_head, &(server->queries_to_server));\n-  for (list_node = list_head.next; list_node != &list_head; )\n-    {\n-      query = list_node->data;\n-      list_node = list_node->next;  /* in case the query gets deleted */\n-      assert(query->server == whichserver);\n-      skip_server(channel, query, whichserver);\n-      next_server(channel, query, now);\n-    }\n-  /* Each query should have removed itself from our temporary list as\n-   * it re-sent itself or finished up...\n-   */\n-  assert(ares__is_list_empty(&list_head));\n-}\n-\n-static void skip_server(ares_channel channel, struct query *query,\n-                        int whichserver) {\n-  /* The given server gave us problems with this query, so if we have\n-   * the luxury of using other servers, then let's skip the\n-   * potentially broken server and just use the others. If we only\n-   * have one server and we need to retry then we should just go ahead\n-   * and re-use that server, since it's our only hope; perhaps we\n-   * just got unlucky, and retrying will work (eg, the server timed\n-   * out our TCP connection just as we were sending another request).\n-   */\n-  if (channel->nservers > 1)\n-    {\n-      query->server_info[whichserver].skip_server = 1;\n-    }\n-}\n-\n-static void next_server(ares_channel channel, struct query *query,\n-                        struct timeval *now)\n-{\n-  /* We need to try each server channel->tries times. We have channel->nservers\n-   * servers to try. In total, we need to do channel->nservers * channel->tries\n-   * attempts. Use query->try to remember how many times we already attempted\n-   * this query. Use modular arithmetic to find the next server to try. */\n-  while (++(query->try_count) < (channel->nservers * channel->tries))\n-    {\n-      struct server_state *server;\n-\n-      /* Move on to the next server. */\n-      query->server = (query->server + 1) % channel->nservers;\n-      server = &channel->servers[query->server];\n-\n-      /* We don't want to use this server if (1) we decided this\n-       * connection is broken, and thus about to be closed, (2)\n-       * we've decided to skip this server because of earlier\n-       * errors we encountered, or (3) we already sent this query\n-       * over this exact connection.\n-       */\n-      if (!server->is_broken &&\n-           !query->server_info[query->server].skip_server &&\n-           !(query->using_tcp &&\n-             (query->server_info[query->server].tcp_connection_generation ==\n-              server->tcp_connection_generation)))\n-        {\n-           ares__send_query(channel, query, now);\n-           return;\n-        }\n-\n-      /* You might think that with TCP we only need one try. However,\n-       * even when using TCP, servers can time-out our connection just\n-       * as we're sending a request, or close our connection because\n-       * they die, or never send us a reply because they get wedged or\n-       * tickle a bug that drops our request.\n-       */\n-    }\n-\n-  /* If we are here, all attempts to perform query failed. */\n-  end_query(channel, query, query->error_status, NULL, 0);\n-}\n-\n-void ares__send_query(ares_channel channel, struct query *query,\n-                      struct timeval *now)\n-{\n-  struct send_request *sendreq;\n-  struct server_state *server;\n-  int timeplus;\n-\n-  server = &channel->servers[query->server];\n-  if (query->using_tcp)\n-    {\n-      /* Make sure the TCP socket for this server is set up and queue\n-       * a send request.\n-       */\n-      if (server->tcp_socket == ARES_SOCKET_BAD)\n-        {\n-          if (open_tcp_socket(channel, server) == -1)\n-            {\n-              skip_server(channel, query, query->server);\n-              next_server(channel, query, now);\n-              return;\n-            }\n-        }\n-      sendreq = calloc(1, sizeof(struct send_request));\n-      if (!sendreq)\n-        {\n-        end_query(channel, query, ARES_ENOMEM, NULL, 0);\n-          return;\n-        }\n-      /* To make the common case fast, we avoid copies by using the\n-       * query's tcpbuf for as long as the query is alive. In the rare\n-       * case where the query ends while it's queued for transmission,\n-       * then we give the sendreq its own copy of the request packet\n-       * and put it in sendreq->data_storage.\n-       */\n-      sendreq->data_storage = NULL;\n-      sendreq->data = query->tcpbuf;\n-      sendreq->len = query->tcplen;\n-      sendreq->owner_query = query;\n-      sendreq->next = NULL;\n-      if (server->qtail)\n-        server->qtail->next = sendreq;\n-      else\n-        {\n-          SOCK_STATE_CALLBACK(channel, server->tcp_socket, 1, 1);\n-          server->qhead = sendreq;\n-        }\n-      server->qtail = sendreq;\n-      query->server_info[query->server].tcp_connection_generation =\n-        server->tcp_connection_generation;\n-    }\n-  else\n-    {\n-      if (server->udp_socket == ARES_SOCKET_BAD)\n-        {\n-          if (open_udp_socket(channel, server) == -1)\n-            {\n-              skip_server(channel, query, query->server);\n-              next_server(channel, query, now);\n-              return;\n-            }\n-        }\n-      if (swrite(server->udp_socket, query->qbuf, query->qlen) == -1)\n-        {\n-          /* FIXME: Handle EAGAIN here since it likely can happen. */\n-          skip_server(channel, query, query->server);\n-          next_server(channel, query, now);\n-          return;\n-        }\n-    }\n-    timeplus = channel->timeout << (query->try_count / channel->nservers);\n-    timeplus = (timeplus * (9 + (rand () & 7))) / 16;\n-    query->timeout = *now;\n-    ares__timeadd(&query->timeout,\n-                  timeplus);\n-    /* Keep track of queries bucketed by timeout, so we can process\n-     * timeout events quickly.\n-     */\n-    ares__remove_from_list(&(query->queries_by_timeout));\n-    ares__insert_in_list(\n-        &(query->queries_by_timeout),\n-        &(channel->queries_by_timeout[query->timeout.tv_sec %\n-                                      ARES_TIMEOUT_TABLE_SIZE]));\n-\n-    /* Keep track of queries bucketed by server, so we can process server\n-     * errors quickly.\n-     */\n-    ares__remove_from_list(&(query->queries_to_server));\n-    ares__insert_in_list(&(query->queries_to_server),\n-                         &(server->queries_to_server));\n-}\n-\n-/*\n- * setsocknonblock sets the given socket to either blocking or non-blocking\n- * mode based on the 'nonblock' boolean argument. This function is highly\n- * portable.\n- */\n-static int setsocknonblock(ares_socket_t sockfd,    /* operate on this */\n-                    int nonblock   /* TRUE or FALSE */)\n-{\n-#if defined(USE_BLOCKING_SOCKETS)\n-\n-  return 0; /* returns success */\n-\n-#elif defined(HAVE_FCNTL_O_NONBLOCK)\n-\n-  /* most recent unix versions */\n-  int flags;\n-  flags = fcntl(sockfd, F_GETFL, 0);\n-  if (FALSE != nonblock)\n-    return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);\n-  else\n-    return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));\n-\n-#elif defined(HAVE_IOCTL_FIONBIO)\n-\n-  /* older unix versions */\n-  int flags;\n-  flags = nonblock;\n-  return ioctl(sockfd, FIONBIO, &flags);\n-\n-#elif defined(HAVE_IOCTLSOCKET_FIONBIO)\n-\n-#ifdef WATT32\n-  char flags;\n-#else\n-  /* Windows */\n-  unsigned long flags;\n-#endif\n-  flags = nonblock;\n-  return ioctlsocket(sockfd, FIONBIO, &flags);\n-\n-#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)\n-\n-  /* Amiga */\n-  return IoctlSocket(sockfd, FIONBIO, (long)nonblock);\n-\n-#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)\n-\n-  /* BeOS */\n-  long b = nonblock ? 1 : 0;\n-  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));\n-\n-#else\n-#  error \"no non-blocking method was found/used/set\"\n-#endif\n-}\n-\n-static int configure_socket(ares_socket_t s, int family, ares_channel channel)\n-{\n-  union {\n-    struct sockaddr     sa;\n-    struct sockaddr_in  sa4;\n-    struct sockaddr_in6 sa6;\n-  } local;\n-\n-  setsocknonblock(s, TRUE);\n-\n-#if defined(FD_CLOEXEC) && !defined(MSDOS)\n-  /* Configure the socket fd as close-on-exec. */\n-  if (fcntl(s, F_SETFD, FD_CLOEXEC) == -1)\n-    return -1;\n-#endif\n-\n-  /* Set the socket's send and receive buffer sizes. */\n-  if ((channel->socket_send_buffer_size > 0) &&\n-      setsockopt(s, SOL_SOCKET, SO_SNDBUF,\n-                 (void *)&channel->socket_send_buffer_size,\n-                 sizeof(channel->socket_send_buffer_size)) == -1)\n-    return -1;\n-\n-  if ((channel->socket_receive_buffer_size > 0) &&\n-      setsockopt(s, SOL_SOCKET, SO_RCVBUF,\n-                 (void *)&channel->socket_receive_buffer_size,\n-                 sizeof(channel->socket_receive_buffer_size)) == -1)\n-    return -1;\n-\n-#ifdef SO_BINDTODEVICE\n-  if (channel->local_dev_name[0]) {\n-    if (setsockopt(s, SOL_SOCKET, SO_BINDTODEVICE,\n-                   channel->local_dev_name, sizeof(channel->local_dev_name))) {\n-      /* Only root can do this, and usually not fatal if it doesn't work, so */\n-      /* just continue on. */\n-    }\n-  }\n-#endif\n-\n-  if (family == AF_INET) {\n-    if (channel->local_ip4) {\n-      memset(&local.sa4, 0, sizeof(local.sa4));\n-      local.sa4.sin_family = AF_INET;\n-      local.sa4.sin_addr.s_addr = htonl(channel->local_ip4);\n-      if (bind(s, &local.sa, sizeof(local.sa4)) < 0)\n-        return -1;\n-    }\n-  }\n-  else if (family == AF_INET6) {\n-    if (memcmp(channel->local_ip6, &ares_in6addr_any, sizeof(channel->local_ip6)) != 0) {\n-      memset(&local.sa6, 0, sizeof(local.sa6));\n-      local.sa6.sin6_family = AF_INET6;\n-      memcpy(&local.sa6.sin6_addr, channel->local_ip6, sizeof(channel->local_ip6));\n-      if (bind(s, &local.sa, sizeof(local.sa6)) < 0)\n-        return -1;\n-    }\n-  }\n-\n-  return 0;\n-}\n-\n-static int open_tcp_socket(ares_channel channel, struct server_state *server)\n-{\n-  ares_socket_t s;\n-  int opt;\n-  ares_socklen_t salen;\n-  union {\n-    struct sockaddr_in  sa4;\n-    struct sockaddr_in6 sa6;\n-  } saddr;\n-  struct sockaddr *sa;\n-\n-  switch (server->addr.family)\n-    {\n-      case AF_INET:\n-        sa = (void *)&saddr.sa4;\n-        salen = sizeof(saddr.sa4);\n-        memset(sa, 0, salen);\n-        saddr.sa4.sin_family = AF_INET;\n-        saddr.sa4.sin_port = (unsigned short)(channel->tcp_port & 0xffff);\n-        memcpy(&saddr.sa4.sin_addr, &server->addr.addrV4,\n-               sizeof(server->addr.addrV4));\n-        break;\n-      case AF_INET6:\n-        sa = (void *)&saddr.sa6;\n-        salen = sizeof(saddr.sa6);\n-        memset(sa, 0, salen);\n-        saddr.sa6.sin6_family = AF_INET6;\n-        saddr.sa6.sin6_port = (unsigned short)(channel->tcp_port & 0xffff);\n-        memcpy(&saddr.sa6.sin6_addr, &server->addr.addrV6,\n-               sizeof(server->addr.addrV6));\n-        break;\n-      default:\n-        return -1;\n-    }\n-\n-  /* Acquire a socket. */\n-  s = socket(server->addr.family, SOCK_STREAM, 0);\n-  if (s == ARES_SOCKET_BAD)\n-    return -1;\n-\n-  /* Configure it. */\n-  if (configure_socket(s, server->addr.family, channel) < 0)\n-    {\n-       sclose(s);\n-       return -1;\n-    }\n-\n-#ifdef TCP_NODELAY\n-  /*\n-   * Disable the Nagle algorithm (only relevant for TCP sockets, and thus not\n-   * in configure_socket). In general, in DNS lookups we're pretty much\n-   * interested in firing off a single request and then waiting for a reply,\n-   * so batching isn't very interesting.\n-   */\n-  opt = 1;\n-  if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY,\n-                 (void *)&opt, sizeof(opt)) == -1)\n-    {\n-       sclose(s);\n-       return -1;\n-    }\n-#endif\n-\n-  /* Connect to the server. */\n-  if (connect(s, sa, salen) == -1)\n-    {\n-      int err = SOCKERRNO;\n-\n-      if (err != EINPROGRESS && err != EWOULDBLOCK)\n-        {\n-          sclose(s);\n-          return -1;\n-        }\n-    }\n-\n-  if (channel->sock_create_cb)\n-    {\n-      int err = channel->sock_create_cb(s, SOCK_STREAM,\n-                                        channel->sock_create_cb_data);\n-      if (err < 0)\n-        {\n-          sclose(s);\n-          return err;\n-        }\n-    }\n-\n-  SOCK_STATE_CALLBACK(channel, s, 1, 0);\n-  server->tcp_buffer_pos = 0;\n-  server->tcp_socket = s;\n-  server->tcp_connection_generation = ++channel->tcp_connection_generation;\n-  return 0;\n-}\n-\n-static int open_udp_socket(ares_channel channel, struct server_state *server)\n-{\n-  ares_socket_t s;\n-  ares_socklen_t salen;\n-  union {\n-    struct sockaddr_in  sa4;\n-    struct sockaddr_in6 sa6;\n-  } saddr;\n-  struct sockaddr *sa;\n-\n-  switch (server->addr.family)\n-    {\n-      case AF_INET:\n-        sa = (void *)&saddr.sa4;\n-        salen = sizeof(saddr.sa4);\n-        memset(sa, 0, salen);\n-        saddr.sa4.sin_family = AF_INET;\n-        saddr.sa4.sin_port = (unsigned short)(channel->udp_port & 0xffff);\n-        memcpy(&saddr.sa4.sin_addr, &server->addr.addrV4,\n-               sizeof(server->addr.addrV4));\n-        break;\n-      case AF_INET6:\n-        sa = (void *)&saddr.sa6;\n-        salen = sizeof(saddr.sa6);\n-        memset(sa, 0, salen);\n-        saddr.sa6.sin6_family = AF_INET6;\n-        saddr.sa6.sin6_port = (unsigned short)(channel->udp_port & 0xffff);\n-        memcpy(&saddr.sa6.sin6_addr, &server->addr.addrV6,\n-               sizeof(server->addr.addrV6));\n-        break;\n-      default:\n-        return -1;\n-    }\n-\n-  /* Acquire a socket. */\n-  s = socket(server->addr.family, SOCK_DGRAM, 0);\n-  if (s == ARES_SOCKET_BAD)\n-    return -1;\n-\n-  /* Set the socket non-blocking. */\n-  if (configure_socket(s, server->addr.family, channel) < 0)\n-    {\n-       sclose(s);\n-       return -1;\n-    }\n-\n-  /* Connect to the server. */\n-  if (connect(s, sa, salen) == -1)\n-    {\n-      int err = SOCKERRNO;\n-\n-      if (err != EINPROGRESS && err != EWOULDBLOCK)\n-        {\n-          sclose(s);\n-          return -1;\n-        }\n-    }\n-\n-  if (channel->sock_create_cb)\n-    {\n-      int err = channel->sock_create_cb(s, SOCK_DGRAM,\n-                                        channel->sock_create_cb_data);\n-      if (err < 0)\n-        {\n-          sclose(s);\n-          return err;\n-        }\n-    }\n-\n-  SOCK_STATE_CALLBACK(channel, s, 1, 0);\n-\n-  server->udp_socket = s;\n-  return 0;\n-}\n-\n-static int same_questions(const unsigned char *qbuf, int qlen,\n-                          const unsigned char *abuf, int alen)\n-{\n-  struct {\n-    const unsigned char *p;\n-    int qdcount;\n-    char *name;\n-    long namelen;\n-    int type;\n-    int dnsclass;\n-  } q, a;\n-  int i, j;\n-\n-  if (qlen < HFIXEDSZ || alen < HFIXEDSZ)\n-    return 0;\n-\n-  /* Extract qdcount from the request and reply buffers and compare them. */\n-  q.qdcount = DNS_HEADER_QDCOUNT(qbuf);\n-  a.qdcount = DNS_HEADER_QDCOUNT(abuf);\n-  if (q.qdcount != a.qdcount)\n-    return 0;\n-\n-  /* For each question in qbuf, find it in abuf. */\n-  q.p = qbuf + HFIXEDSZ;\n-  for (i = 0; i < q.qdcount; i++)\n-    {\n-      /* Decode the question in the query. */\n-      if (ares_expand_name(q.p, qbuf, qlen, &q.name, &q.namelen)\n-          != ARES_SUCCESS)\n-        return 0;\n-      q.p += q.namelen;\n-      if (q.p + QFIXEDSZ > qbuf + qlen)\n-        {\n-          free(q.name);\n-          return 0;\n-        }\n-      q.type = DNS_QUESTION_TYPE(q.p);\n-      q.dnsclass = DNS_QUESTION_CLASS(q.p);\n-      q.p += QFIXEDSZ;\n-\n-      /* Search for this question in the answer. */\n-      a.p = abuf + HFIXEDSZ;\n-      for (j = 0; j < a.qdcount; j++)\n-        {\n-          /* Decode the question in the answer. */\n-          if (ares_expand_name(a.p, abuf, alen, &a.name, &a.namelen)\n-              != ARES_SUCCESS)\n-            {\n-              free(q.name);\n-              return 0;\n-            }\n-          a.p += a.namelen;\n-          if (a.p + QFIXEDSZ > abuf + alen)\n-            {\n-              free(q.name);\n-              free(a.name);\n-              return 0;\n-            }\n-          a.type = DNS_QUESTION_TYPE(a.p);\n-          a.dnsclass = DNS_QUESTION_CLASS(a.p);\n-          a.p += QFIXEDSZ;\n-\n-          /* Compare the decoded questions. */\n-          if (strcasecmp(q.name, a.name) == 0 && q.type == a.type\n-              && q.dnsclass == a.dnsclass)\n-            {\n-              free(a.name);\n-              break;\n-            }\n-          free(a.name);\n-        }\n-\n-      free(q.name);\n-      if (j == a.qdcount)\n-        return 0;\n-    }\n-  return 1;\n-}\n-\n-static int same_address(struct sockaddr *sa, struct ares_addr *aa)\n-{\n-  void *addr1;\n-  void *addr2;\n-\n-  if (sa->sa_family == aa->family)\n-    {\n-      switch (aa->family)\n-        {\n-          case AF_INET:\n-            addr1 = &aa->addrV4;\n-            addr2 = &((struct sockaddr_in *)sa)->sin_addr;\n-            if (memcmp(addr1, addr2, sizeof(aa->addrV4)) == 0)\n-              return 1; /* match */\n-            break;\n-          case AF_INET6:\n-            addr1 = &aa->addrV6;\n-            addr2 = &((struct sockaddr_in6 *)sa)->sin6_addr;\n-            if (memcmp(addr1, addr2, sizeof(aa->addrV6)) == 0)\n-              return 1; /* match */\n-            break;\n-          default:\n-            break;\n-        }\n-    }\n-  return 0; /* different */\n-}\n-\n-static void end_query (ares_channel channel, struct query *query, int status,\n-                       unsigned char *abuf, int alen)\n-{\n-  int i;\n-\n-  /* First we check to see if this query ended while one of our send\n-   * queues still has pointers to it.\n-   */\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      struct server_state *server = &channel->servers[i];\n-      struct send_request *sendreq;\n-      for (sendreq = server->qhead; sendreq; sendreq = sendreq->next)\n-        if (sendreq->owner_query == query)\n-          {\n-            sendreq->owner_query = NULL;\n-            assert(sendreq->data_storage == NULL);\n-            if (status == ARES_SUCCESS)\n-              {\n-                /* We got a reply for this query, but this queued\n-                 * sendreq points into this soon-to-be-gone query's\n-                 * tcpbuf. Probably this means we timed out and queued\n-                 * the query for retransmission, then received a\n-                 * response before actually retransmitting. This is\n-                 * perfectly fine, so we want to keep the connection\n-                 * running smoothly if we can. But in the worst case\n-                 * we may have sent only some prefix of the query,\n-                 * with some suffix of the query left to send. Also,\n-                 * the buffer may be queued on multiple queues. To\n-                 * prevent dangling pointers to the query's tcpbuf and\n-                 * handle these cases, we just give such sendreqs\n-                 * their own copy of the query packet.\n-                 */\n-               sendreq->data_storage = malloc(sendreq->len);\n-               if (sendreq->data_storage != NULL)\n-                 {\n-                   memcpy(sendreq->data_storage, sendreq->data, sendreq->len);\n-                   sendreq->data = sendreq->data_storage;\n-                 }\n-              }\n-            if ((status != ARES_SUCCESS) || (sendreq->data_storage == NULL))\n-              {\n-                /* We encountered an error (probably a timeout,\n-                 * suggesting the DNS server we're talking to is\n-                 * probably unreachable, wedged, or severely\n-                 * overloaded) or we couldn't copy the request, so\n-                 * mark the connection as broken. When we get to\n-                 * process_broken_connections() we'll close the\n-                 * connection and try to re-send requests to another\n-                 * server.\n-                 */\n-               server->is_broken = 1;\n-               /* Just to be paranoid, zero out this sendreq... */\n-               sendreq->data = NULL;\n-               sendreq->len = 0;\n-             }\n-          }\n-    }\n-\n-  /* Invoke the callback */\n-  query->callback(query->arg, status, query->timeouts, abuf, alen);\n-  ares__free_query(query);\n-\n-  /* Simple cleanup policy: if no queries are remaining, close all\n-   * network sockets unless STAYOPEN is set.\n-   */\n-  if (!(channel->flags & ARES_FLAG_STAYOPEN) &&\n-      ares__is_list_empty(&(channel->all_queries)))\n-    {\n-      for (i = 0; i < channel->nservers; i++)\n-        ares__close_sockets(channel, &channel->servers[i]);\n-    }\n-}\n-\n-void ares__free_query(struct query *query)\n-{\n-  /* Remove the query from all the lists in which it is linked */\n-  ares__remove_from_list(&(query->queries_by_qid));\n-  ares__remove_from_list(&(query->queries_by_timeout));\n-  ares__remove_from_list(&(query->queries_to_server));\n-  ares__remove_from_list(&(query->all_queries));\n-  /* Zero out some important stuff, to help catch bugs */\n-  query->callback = NULL;\n-  query->arg = NULL;\n-  /* Deallocate the memory associated with the query */\n-  free(query->tcpbuf);\n-  free(query->server_info);\n-  free(query);\n-}"}, {"sha": "63652e229d274b6eba21ad076399c979318f5ac2", "filename": "src/rt/libuv/src/ares/ares_query.c", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_query.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,183 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-struct qquery {\n-  ares_callback callback;\n-  void *arg;\n-};\n-\n-static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen);\n-\n-void ares__rc4(rc4_key* key, unsigned char *buffer_ptr, int buffer_len)\n-{\n-  unsigned char x;\n-  unsigned char y;\n-  unsigned char* state;\n-  unsigned char xorIndex;\n-  short counter;\n-\n-  x = key->x;\n-  y = key->y;\n-\n-  state = &key->state[0];\n-  for(counter = 0; counter < buffer_len; counter ++)\n-  {\n-    x = (unsigned char)((x + 1) % 256);\n-    y = (unsigned char)((state[x] + y) % 256);\n-    ARES_SWAP_BYTE(&state[x], &state[y]);\n-\n-    xorIndex = (unsigned char)((state[x] + state[y]) % 256);\n-\n-    buffer_ptr[counter] = (unsigned char)(buffer_ptr[counter]^state[xorIndex]);\n-  }\n-  key->x = x;\n-  key->y = y;\n-}\n-\n-static struct query* find_query_by_id(ares_channel channel, unsigned short id)\n-{\n-  unsigned short qid;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-  DNS_HEADER_SET_QID(((unsigned char*)&qid), id);\n-\n-  /* Find the query corresponding to this packet. */\n-  list_head = &(channel->queries_by_qid[qid % ARES_QID_TABLE_SIZE]);\n-  for (list_node = list_head->next; list_node != list_head;\n-       list_node = list_node->next)\n-    {\n-       struct query *q = list_node->data;\n-       if (q->qid == qid)\n-\t  return q;\n-    }\n-  return NULL;\n-}\n-\n-\n-/* a unique query id is generated using an rc4 key. Since the id may already\n-   be used by a running query (as infrequent as it may be), a lookup is\n-   performed per id generation. In practice this search should happen only\n-   once per newly generated id\n-*/\n-static unsigned short generate_unique_id(ares_channel channel)\n-{\n-  unsigned short id;\n-\n-  do {\n-    id = ares__generate_new_id(&channel->id_key);\n-  } while (find_query_by_id(channel, id));\n-\n-  return (unsigned short)id;\n-}\n-\n-void ares_query(ares_channel channel, const char *name, int dnsclass,\n-                int type, ares_callback callback, void *arg)\n-{\n-  struct qquery *qquery;\n-  unsigned char *qbuf;\n-  int qlen, rd, status;\n-\n-  /* Compose the query. */\n-  rd = !(channel->flags & ARES_FLAG_NORECURSE);\n-  status = ares_mkquery(name, dnsclass, type, channel->next_id, rd, &qbuf,\n-                        &qlen);\n-  if (status != ARES_SUCCESS)\n-    {\n-      if (qbuf != NULL) free(qbuf);\n-      callback(arg, status, 0, NULL, 0);\n-      return;\n-    }\n-\n-  channel->next_id = generate_unique_id(channel);\n-\n-  /* Allocate and fill in the query structure. */\n-  qquery = malloc(sizeof(struct qquery));\n-  if (!qquery)\n-    {\n-      ares_free_string(qbuf);\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-  qquery->callback = callback;\n-  qquery->arg = arg;\n-\n-  /* Send it off.  qcallback will be called when we get an answer. */\n-  ares_send(channel, qbuf, qlen, qcallback, qquery);\n-  ares_free_string(qbuf);\n-}\n-\n-static void qcallback(void *arg, int status, int timeouts, unsigned char *abuf, int alen)\n-{\n-  struct qquery *qquery = (struct qquery *) arg;\n-  unsigned int ancount;\n-  int rcode;\n-\n-  if (status != ARES_SUCCESS)\n-    qquery->callback(qquery->arg, status, timeouts, abuf, alen);\n-  else\n-    {\n-      /* Pull the response code and answer count from the packet. */\n-      rcode = DNS_HEADER_RCODE(abuf);\n-      ancount = DNS_HEADER_ANCOUNT(abuf);\n-\n-      /* Convert errors. */\n-      switch (rcode)\n-        {\n-        case NOERROR:\n-          status = (ancount > 0) ? ARES_SUCCESS : ARES_ENODATA;\n-          break;\n-        case FORMERR:\n-          status = ARES_EFORMERR;\n-          break;\n-        case SERVFAIL:\n-          status = ARES_ESERVFAIL;\n-          break;\n-        case NXDOMAIN:\n-          status = ARES_ENOTFOUND;\n-          break;\n-        case NOTIMP:\n-          status = ARES_ENOTIMP;\n-          break;\n-        case REFUSED:\n-          status = ARES_EREFUSED;\n-          break;\n-        }\n-      qquery->callback(qquery->arg, status, timeouts, abuf, alen);\n-    }\n-  free(qquery);\n-}"}, {"sha": "f94c5b59165e7adb20c67a29103b95c5136298b5", "filename": "src/rt/libuv/src/ares/ares_rules.h", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_rules.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,144 +0,0 @@\n-#ifndef __CARES_RULES_H\n-#define __CARES_RULES_H\n-\n-\n-/* Copyright (C) 2009 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this software and its\n- * documentation for any purpose and without fee is hereby granted, provided\n- * that the above copyright notice appear in all copies and that both that\n- * copyright notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in advertising or\n- * publicity pertaining to distribution of the software without specific,\n- * written prior permission.  M.I.T. makes no representations about the\n- * suitability of this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-/* ================================================================ */\n-/*                    COMPILE TIME SANITY CHECKS                    */\n-/* ================================================================ */\n-\n-/*\n- * NOTE 1:\n- * -------\n- *\n- * All checks done in this file are intentionally placed in a public\n- * header file which is pulled by ares.h when an application is\n- * being built using an already built c-ares library. Additionally\n- * this file is also included and used when building the library.\n- *\n- * If compilation fails on this file it is certainly sure that the\n- * problem is elsewhere. It could be a problem in the ares_build.h\n- * header file, or simply that you are using different compilation\n- * settings than those used to build the library.\n- *\n- * Nothing in this file is intended to be modified or adjusted by the\n- * c-ares library user nor by the c-ares library builder.\n- *\n- * Do not deactivate any check, these are done to make sure that the\n- * library is properly built and used.\n- *\n- * You can find further help on the c-ares development mailing list:\n- * http://cool.haxx.se/mailman/listinfo/c-ares/\n- *\n- * NOTE 2\n- * ------\n- *\n- * Some of the following compile time checks are based on the fact\n- * that the dimension of a constant array can not be a negative one.\n- * In this way if the compile time verification fails, the compilation\n- * will fail issuing an error. The error description wording is compiler\n- * dependent but it will be quite similar to one of the following:\n- *\n- *   \"negative subscript or subscript is too large\"\n- *   \"array must have at least one element\"\n- *   \"-1 is an illegal array size\"\n- *   \"size of array is negative\"\n- *\n- * If you are building an application which tries to use an already\n- * built c-ares library and you are getting this kind of errors on\n- * this file, it is a clear indication that there is a mismatch between\n- * how the library was built and how you are trying to use it for your\n- * application. Your already compiled or binary library provider is the\n- * only one who can give you the details you need to properly use it.\n- */\n-\n-/*\n- * Verify that some macros are actually defined.\n- */\n-\n-#ifndef CARES_SIZEOF_LONG\n-#  error \"CARES_SIZEOF_LONG definition is missing!\"\n-   Error Compilation_aborted_CARES_SIZEOF_LONG_is_missing\n-#endif\n-\n-#ifndef CARES_TYPEOF_ARES_SOCKLEN_T\n-#  error \"CARES_TYPEOF_ARES_SOCKLEN_T definition is missing!\"\n-   Error Compilation_aborted_CARES_TYPEOF_ARES_SOCKLEN_T_is_missing\n-#endif\n-\n-#ifndef CARES_SIZEOF_ARES_SOCKLEN_T\n-#  error \"CARES_SIZEOF_ARES_SOCKLEN_T definition is missing!\"\n-   Error Compilation_aborted_CARES_SIZEOF_ARES_SOCKLEN_T_is_missing\n-#endif\n-\n-/*\n- * Macros private to this header file.\n- */\n-\n-#define CareschkszEQ(t, s) sizeof(t) == s ? 1 : -1\n-\n-#define CareschkszGE(t1, t2) sizeof(t1) >= sizeof(t2) ? 1 : -1\n-\n-/*\n- * Verify that the size previously defined and expected for long\n- * is the same as the one reported by sizeof() at compile time.\n- */\n-\n-typedef char\n-  __cares_rule_01__\n-    [CareschkszEQ(long, CARES_SIZEOF_LONG)];\n-\n-/*\n- * Verify that the size previously defined and expected for\n- * ares_socklen_t is actually the the same as the one reported\n- * by sizeof() at compile time.\n- */\n-\n-typedef char\n-  __cares_rule_02__\n-    [CareschkszEQ(ares_socklen_t, CARES_SIZEOF_ARES_SOCKLEN_T)];\n-\n-/*\n- * Verify at compile time that the size of ares_socklen_t as reported\n- * by sizeof() is greater or equal than the one reported for int for\n- * the current compilation.\n- */\n-\n-typedef char\n-  __cares_rule_03__\n-    [CareschkszGE(ares_socklen_t, int)];\n-\n-/* ================================================================ */\n-/*          EXTERNALLY AND INTERNALLY VISIBLE DEFINITIONS           */\n-/* ================================================================ */\n-\n-/*\n- * Get rid of macros private to this header file.\n- */\n-\n-#undef CareschkszEQ\n-#undef CareschkszGE\n-\n-/*\n- * Get rid of macros not intended to exist beyond this point.\n- */\n-\n-#undef CARES_PULL_WS2TCPIP_H\n-#undef CARES_PULL_SYS_TYPES_H\n-#undef CARES_PULL_SYS_SOCKET_H\n-\n-#undef CARES_TYPEOF_ARES_SOCKLEN_T\n-\n-#endif /* __CARES_RULES_H */"}, {"sha": "1877c19f772b8782ee4308872cf9e90c18a9d86a", "filename": "src/rt/libuv/src/ares/ares_search.c", "status": "removed", "additions": 0, "deletions": 321, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_search.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,321 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <ctype.h>\n-\n-#ifdef HAVE_STRINGS_H\n-#  include <strings.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-struct search_query {\n-  /* Arguments passed to ares_search */\n-  ares_channel channel;\n-  char *name;                   /* copied into an allocated buffer */\n-  int dnsclass;\n-  int type;\n-  ares_callback callback;\n-  void *arg;\n-\n-  int status_as_is;             /* error status from trying as-is */\n-  int next_domain;              /* next search domain to try */\n-  int trying_as_is;             /* current query is for name as-is */\n-  int timeouts;                 /* number of timeouts we saw for this request */\n-  int ever_got_nodata;          /* did we ever get ARES_ENODATA along the way? */\n-};\n-\n-static void search_callback(void *arg, int status, int timeouts,\n-                            unsigned char *abuf, int alen);\n-static void end_squery(struct search_query *squery, int status,\n-                       unsigned char *abuf, int alen);\n-static int cat_domain(const char *name, const char *domain, char **s);\n-static int single_domain(ares_channel channel, const char *name, char **s);\n-\n-void ares_search(ares_channel channel, const char *name, int dnsclass,\n-                 int type, ares_callback callback, void *arg)\n-{\n-  struct search_query *squery;\n-  char *s;\n-  const char *p;\n-  int status, ndots;\n-\n-  /* If name only yields one domain to search, then we don't have\n-   * to keep extra state, so just do an ares_query().\n-   */\n-  status = single_domain(channel, name, &s);\n-  if (status != ARES_SUCCESS)\n-    {\n-      callback(arg, status, 0, NULL, 0);\n-      return;\n-    }\n-  if (s)\n-    {\n-      ares_query(channel, s, dnsclass, type, callback, arg);\n-      free(s);\n-      return;\n-    }\n-\n-  /* Allocate a search_query structure to hold the state necessary for\n-   * doing multiple lookups.\n-   */\n-  squery = malloc(sizeof(struct search_query));\n-  if (!squery)\n-    {\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-  squery->channel = channel;\n-  squery->name = strdup(name);\n-  if (!squery->name)\n-    {\n-      free(squery);\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-  squery->dnsclass = dnsclass;\n-  squery->type = type;\n-  squery->status_as_is = -1;\n-  squery->callback = callback;\n-  squery->arg = arg;\n-  squery->timeouts = 0;\n-  squery->ever_got_nodata = 0;\n-\n-  /* Count the number of dots in name. */\n-  ndots = 0;\n-  for (p = name; *p; p++)\n-    {\n-      if (*p == '.')\n-        ndots++;\n-    }\n-\n-  /* If ndots is at least the channel ndots threshold (usually 1),\n-   * then we try the name as-is first.  Otherwise, we try the name\n-   * as-is last.\n-   */\n-  if (ndots >= channel->ndots)\n-    {\n-      /* Try the name as-is first. */\n-      squery->next_domain = 0;\n-      squery->trying_as_is = 1;\n-      ares_query(channel, name, dnsclass, type, search_callback, squery);\n-    }\n-  else\n-    {\n-      /* Try the name as-is last; start with the first search domain. */\n-      squery->next_domain = 1;\n-      squery->trying_as_is = 0;\n-      status = cat_domain(name, channel->domains[0], &s);\n-      if (status == ARES_SUCCESS)\n-        {\n-          ares_query(channel, s, dnsclass, type, search_callback, squery);\n-          free(s);\n-        }\n-      else\n-      {\n-        /* failed, free the malloc()ed memory */\n-        free(squery->name);\n-        free(squery);\n-        callback(arg, status, 0, NULL, 0);\n-      }\n-    }\n-}\n-\n-static void search_callback(void *arg, int status, int timeouts,\n-                            unsigned char *abuf, int alen)\n-{\n-  struct search_query *squery = (struct search_query *) arg;\n-  ares_channel channel = squery->channel;\n-  char *s;\n-\n-  squery->timeouts += timeouts;\n-\n-  /* Stop searching unless we got a non-fatal error. */\n-  if (status != ARES_ENODATA && status != ARES_ESERVFAIL\n-      && status != ARES_ENOTFOUND)\n-    end_squery(squery, status, abuf, alen);\n-  else\n-    {\n-      /* Save the status if we were trying as-is. */\n-      if (squery->trying_as_is)\n-        squery->status_as_is = status;\n-\n-      /*\n-       * If we ever get ARES_ENODATA along the way, record that; if the search\n-       * should run to the very end and we got at least one ARES_ENODATA,\n-       * then callers like ares_gethostbyname() may want to try a T_A search\n-       * even if the last domain we queried for T_AAAA resource records\n-       * returned ARES_ENOTFOUND.\n-       */\n-      if (status == ARES_ENODATA)\n-        squery->ever_got_nodata = 1;\n-\n-      if (squery->next_domain < channel->ndomains)\n-        {\n-          /* Try the next domain. */\n-          status = cat_domain(squery->name,\n-                              channel->domains[squery->next_domain], &s);\n-          if (status != ARES_SUCCESS)\n-            end_squery(squery, status, NULL, 0);\n-          else\n-            {\n-              squery->trying_as_is = 0;\n-              squery->next_domain++;\n-              ares_query(channel, s, squery->dnsclass, squery->type,\n-                         search_callback, squery);\n-              free(s);\n-            }\n-        }\n-      else if (squery->status_as_is == -1)\n-        {\n-          /* Try the name as-is at the end. */\n-          squery->trying_as_is = 1;\n-          ares_query(channel, squery->name, squery->dnsclass, squery->type,\n-                     search_callback, squery);\n-        }\n-      else {\n-        if (squery->status_as_is == ARES_ENOTFOUND && squery->ever_got_nodata) {\n-          end_squery(squery, ARES_ENODATA, NULL, 0);\n-        }\n-        else\n-          end_squery(squery, squery->status_as_is, NULL, 0);\n-      }\n-    }\n-}\n-\n-static void end_squery(struct search_query *squery, int status,\n-                       unsigned char *abuf, int alen)\n-{\n-  squery->callback(squery->arg, status, squery->timeouts, abuf, alen);\n-  free(squery->name);\n-  free(squery);\n-}\n-\n-/* Concatenate two domains. */\n-static int cat_domain(const char *name, const char *domain, char **s)\n-{\n-  size_t nlen = strlen(name);\n-  size_t dlen = strlen(domain);\n-\n-  *s = malloc(nlen + 1 + dlen + 1);\n-  if (!*s)\n-    return ARES_ENOMEM;\n-  memcpy(*s, name, nlen);\n-  (*s)[nlen] = '.';\n-  memcpy(*s + nlen + 1, domain, dlen);\n-  (*s)[nlen + 1 + dlen] = 0;\n-  return ARES_SUCCESS;\n-}\n-\n-/* Determine if this name only yields one query.  If it does, set *s to\n- * the string we should query, in an allocated buffer.  If not, set *s\n- * to NULL.\n- */\n-static int single_domain(ares_channel channel, const char *name, char **s)\n-{\n-  size_t len = strlen(name);\n-  const char *hostaliases;\n-  FILE *fp;\n-  char *line = NULL;\n-  int status;\n-  size_t linesize;\n-  const char *p, *q;\n-  int error;\n-\n-  /* If the name contains a trailing dot, then the single query is the name\n-   * sans the trailing dot.\n-   */\n-  if (name[len - 1] == '.')\n-    {\n-      *s = strdup(name);\n-      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n-    }\n-\n-  if (!(channel->flags & ARES_FLAG_NOALIASES) && !strchr(name, '.'))\n-    {\n-      /* The name might be a host alias. */\n-      hostaliases = getenv(\"HOSTALIASES\");\n-      if (hostaliases)\n-        {\n-          fp = fopen(hostaliases, \"r\");\n-          if (fp)\n-            {\n-              while ((status = ares__read_line(fp, &line, &linesize))\n-                     == ARES_SUCCESS)\n-                {\n-                  if (strncasecmp(line, name, len) != 0 ||\n-                      !ISSPACE(line[len]))\n-                    continue;\n-                  p = line + len;\n-                  while (ISSPACE(*p))\n-                    p++;\n-                  if (*p)\n-                    {\n-                      q = p + 1;\n-                      while (*q && !ISSPACE(*q))\n-                        q++;\n-                      *s = malloc(q - p + 1);\n-                      if (*s)\n-                        {\n-                          memcpy(*s, p, q - p);\n-                          (*s)[q - p] = 0;\n-                        }\n-                      free(line);\n-                      fclose(fp);\n-                      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n-                    }\n-                }\n-              free(line);\n-              fclose(fp);\n-              if (status != ARES_SUCCESS && status != ARES_EOF)\n-                return status;\n-            }\n-          else\n-            {\n-              error = ERRNO;\n-              switch(error)\n-                {\n-                case ENOENT:\n-                case ESRCH:\n-                  break;\n-                default:\n-                  DEBUGF(fprintf(stderr, \"fopen() failed with error: %d %s\\n\",\n-                                 error, strerror(error)));\n-                  DEBUGF(fprintf(stderr, \"Error opening file: %s\\n\",\n-                                 hostaliases));\n-                  *s = NULL;\n-                  return ARES_EFILE;\n-                }\n-            }\n-        }\n-    }\n-\n-  if (channel->flags & ARES_FLAG_NOSEARCH || channel->ndomains == 0)\n-    {\n-      /* No domain search to do; just try the name as-is. */\n-      *s = strdup(name);\n-      return (*s) ? ARES_SUCCESS : ARES_ENOMEM;\n-    }\n-\n-  *s = NULL;\n-  return ARES_SUCCESS;\n-}"}, {"sha": "37b0704579c63219aa15c25f04e30677fb2a77ed", "filename": "src/rt/libuv/src/ares/ares_send.c", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_send.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,134 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-#  include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#  include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_H\n-#  include <arpa/nameser.h>\n-#else\n-#  include \"nameser.h\"\n-#endif\n-#ifdef HAVE_ARPA_NAMESER_COMPAT_H\n-#  include <arpa/nameser_compat.h>\n-#endif\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include <time.h>\n-#include \"ares.h\"\n-#include \"ares_dns.h\"\n-#include \"ares_private.h\"\n-\n-void ares_send(ares_channel channel, const unsigned char *qbuf, int qlen,\n-               ares_callback callback, void *arg)\n-{\n-  struct query *query;\n-  int i;\n-  struct timeval now;\n-\n-  /* Verify that the query is at least long enough to hold the header. */\n-  if (qlen < HFIXEDSZ || qlen >= (1 << 16))\n-    {\n-      callback(arg, ARES_EBADQUERY, 0, NULL, 0);\n-      return;\n-    }\n-\n-  /* Allocate space for query and allocated fields. */\n-  query = malloc(sizeof(struct query));\n-  if (!query)\n-    {\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-  query->tcpbuf = malloc(qlen + 2);\n-  if (!query->tcpbuf)\n-    {\n-      free(query);\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-  query->server_info = malloc(channel->nservers *\n-                              sizeof(query->server_info[0]));\n-  if (!query->server_info)\n-    {\n-      free(query->tcpbuf);\n-      free(query);\n-      callback(arg, ARES_ENOMEM, 0, NULL, 0);\n-      return;\n-    }\n-\n-  /* Compute the query ID.  Start with no timeout. */\n-  query->qid = (unsigned short)DNS_HEADER_QID(qbuf);\n-  query->timeout.tv_sec = 0;\n-  query->timeout.tv_usec = 0;\n-\n-  /* Form the TCP query buffer by prepending qlen (as two\n-   * network-order bytes) to qbuf.\n-   */\n-  query->tcpbuf[0] = (unsigned char)((qlen >> 8) & 0xff);\n-  query->tcpbuf[1] = (unsigned char)(qlen & 0xff);\n-  memcpy(query->tcpbuf + 2, qbuf, qlen);\n-  query->tcplen = qlen + 2;\n-\n-  /* Fill in query arguments. */\n-  query->qbuf = query->tcpbuf + 2;\n-  query->qlen = qlen;\n-  query->callback = callback;\n-  query->arg = arg;\n-\n-  /* Initialize query status. */\n-  query->try_count = 0;\n-\n-  /* Choose the server to send the query to. If rotation is enabled, keep track\n-   * of the next server we want to use. */\n-  query->server = channel->last_server;\n-  if (channel->rotate == 1)\n-    channel->last_server = (channel->last_server + 1) % channel->nservers;\n-\n-  for (i = 0; i < channel->nservers; i++)\n-    {\n-      query->server_info[i].skip_server = 0;\n-      query->server_info[i].tcp_connection_generation = 0;\n-    }\n-  query->using_tcp = (channel->flags & ARES_FLAG_USEVC) || qlen > PACKETSZ;\n-  query->error_status = ARES_ECONNREFUSED;\n-  query->timeouts = 0;\n-\n-  /* Initialize our list nodes. */\n-  ares__init_list_node(&(query->queries_by_qid),     query);\n-  ares__init_list_node(&(query->queries_by_timeout), query);\n-  ares__init_list_node(&(query->queries_to_server),  query);\n-  ares__init_list_node(&(query->all_queries),        query);\n-\n-  /* Chain the query into the list of all queries. */\n-  ares__insert_in_list(&(query->all_queries), &(channel->all_queries));\n-  /* Keep track of queries bucketed by qid, so we can process DNS\n-   * responses quickly.\n-   */\n-  ares__insert_in_list(\n-    &(query->queries_by_qid),\n-    &(channel->queries_by_qid[query->qid % ARES_QID_TABLE_SIZE]));\n-\n-  /* Perform the first query action. */\n-  now = ares__tvnow();\n-  ares__send_query(channel, query, &now);\n-}"}, {"sha": "254cccbb85165667af4f3f584710de19dcb6d153", "filename": "src/rt/libuv/src/ares/ares_setup.h", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_setup.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,199 +0,0 @@\n-#ifndef HEADER_CARES_SETUP_H\n-#define HEADER_CARES_SETUP_H\n-\n-\n-/* Copyright (C) 2004 - 2009 by Daniel Stenberg et al\n- *\n- * Permission to use, copy, modify, and distribute this software and its\n- * documentation for any purpose and without fee is hereby granted, provided\n- * that the above copyright notice appear in all copies and that both that\n- * copyright notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in advertising or\n- * publicity pertaining to distribution of the software without specific,\n- * written prior permission.  M.I.T. makes no representations about the\n- * suitability of this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-/*\n- * Define WIN32 when build target is Win32 API\n- */\n-\n-#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)\n-#define WIN32\n-#endif\n-\n-/*\n- * Include configuration script results or hand-crafted\n- * configuration file for platforms which lack config tool.\n- */\n-\n-#ifdef HAVE_CONFIG_H\n-#include \"ares_config.h\"\n-#else\n-\n-#ifdef WIN32\n-#include \"config-win32.h\"\n-#endif\n-\n-#endif /* HAVE_CONFIG_H */\n-\n-/* ================================================================ */\n-/* Definition of preprocessor macros/symbols which modify compiler  */\n-/* behaviour or generated code characteristics must be done here,   */\n-/* as appropriate, before any system header file is included. It is */\n-/* also possible to have them defined in the config file included   */\n-/* before this point. As a result of all this we frown inclusion of */\n-/* system header files in our config files, avoid this at any cost. */\n-/* ================================================================ */\n-\n-/*\n- * AIX 4.3 and newer needs _THREAD_SAFE defined to build\n- * proper reentrant code. Others may also need it.\n- */\n-\n-#ifdef NEED_THREAD_SAFE\n-#  ifndef _THREAD_SAFE\n-#    define _THREAD_SAFE\n-#  endif\n-#endif\n-\n-/*\n- * Tru64 needs _REENTRANT set for a few function prototypes and\n- * things to appear in the system header files. Unixware needs it\n- * to build proper reentrant code. Others may also need it.\n- */\n-\n-#ifdef NEED_REENTRANT\n-#  ifndef _REENTRANT\n-#    define _REENTRANT\n-#  endif\n-#endif\n-\n-/* ================================================================ */\n-/*  If you need to include a system header file for your platform,  */\n-/*  please, do it beyond the point further indicated in this file.  */\n-/* ================================================================ */\n-\n-#if 0 /* libuv hack */\n-/*\n- * c-ares external interface definitions are also used internally,\n- * and might also include required system header files to define them.\n- */\n-\n-#include <ares_build.h>\n-\n-/*\n- * Compile time sanity checks must also be done when building the library.\n- */\n-\n-#include <ares_rules.h>\n-#endif /* libuv hack */\n-\n-/* ================================================================= */\n-/* No system header file shall be included in this file before this  */\n-/* point. The only allowed ones are those included from ares_build.h */\n-/* ================================================================= */\n-\n-/*\n- * Include header files for windows builds before redefining anything.\n- * Use this preproessor block only to include or exclude windows.h,\n- * winsock2.h, ws2tcpip.h or winsock.h. Any other windows thing belongs\n- * to any other further and independent block.  Under Cygwin things work\n- * just as under linux (e.g. <sys/socket.h>) and the winsock headers should\n- * never be included when __CYGWIN__ is defined.  configure script takes\n- * care of this, not defining HAVE_WINDOWS_H, HAVE_WINSOCK_H, HAVE_WINSOCK2_H,\n- * neither HAVE_WS2TCPIP_H when __CYGWIN__ is defined.\n- */\n-\n-#ifdef HAVE_WINDOWS_H\n-#  ifndef WIN32_LEAN_AND_MEAN\n-#    define WIN32_LEAN_AND_MEAN\n-#  endif\n-#  include <windows.h>\n-#  ifdef HAVE_WINSOCK2_H\n-#    include <winsock2.h>\n-#    ifdef HAVE_WS2TCPIP_H\n-#       include <ws2tcpip.h>\n-#    endif\n-#  else\n-#    ifdef HAVE_WINSOCK_H\n-#      include <winsock.h>\n-#    endif\n-#  endif\n-#endif\n-\n-/*\n- * Define USE_WINSOCK to 2 if we have and use WINSOCK2 API, else\n- * define USE_WINSOCK to 1 if we have and use WINSOCK  API, else\n- * undefine USE_WINSOCK.\n- */\n-\n-#undef USE_WINSOCK\n-\n-#ifdef HAVE_WINSOCK2_H\n-#  define USE_WINSOCK 2\n-#else\n-#  ifdef HAVE_WINSOCK_H\n-#    define USE_WINSOCK 1\n-#  endif\n-#endif\n-\n-/*\n- * Work-arounds for systems without configure support\n- */\n-\n-#ifndef HAVE_CONFIG_H\n-\n-#if !defined(HAVE_SYS_TIME_H) && !defined(_MSC_VER) && !defined(__WATCOMC__)\n-#define HAVE_SYS_TIME_H\n-#endif\n-\n-#if !defined(HAVE_UNISTD_H) && !defined(_MSC_VER)\n-#define HAVE_UNISTD_H 1\n-#endif\n-\n-#if !defined(HAVE_SYS_UIO_H) && !defined(WIN32) && !defined(MSDOS)\n-#define HAVE_SYS_UIO_H\n-#endif\n-\n-#endif /* HAVE_CONFIG_H */\n-\n-#ifdef __POCC__\n-#  include <sys/types.h>\n-#  include <unistd.h>\n-#  define ESRCH 3\n-#endif\n-\n-/*\n- * Recent autoconf versions define these symbols in ares_config.h. We don't\n- * want them (since they collide with the libcurl ones when we build\n- *  --enable-debug) so we undef them again here.\n- */\n-\n-#undef PACKAGE_STRING\n-#undef PACKAGE_TARNAME\n-#undef PACKAGE_VERSION\n-#undef PACKAGE_BUGREPORT\n-#undef PACKAGE_NAME\n-#undef VERSION\n-#undef PACKAGE\n-\n-/* IPv6 compatibility */\n-#if !defined(HAVE_AF_INET6)\n-#if defined(HAVE_PF_INET6)\n-#define AF_INET6 PF_INET6\n-#else\n-#define AF_INET6 AF_MAX+1\n-#endif\n-#endif\n-\n-/*\n- * Include macros and defines that should only be processed once.\n- */\n-\n-#ifndef __SETUP_ONCE_H\n-#include \"setup_once.h\"\n-#endif\n-\n-#endif /* HEADER_CARES_SETUP_H */"}, {"sha": "f9c85e209666c57a3a8b981a0461b65af82a3c37", "filename": "src/rt/libuv/src/ares/ares_strcasecmp.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,66 +0,0 @@\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include \"ares_strcasecmp.h\"\n-\n-#ifndef HAVE_STRCASECMP\n-int ares_strcasecmp(const char *a, const char *b)\n-{\n-#if defined(HAVE_STRCMPI)\n-  return strcmpi(a, b);\n-#elif defined(HAVE_STRICMP)\n-  return stricmp(a, b);\n-#else\n-  size_t i;\n-\n-  for (i = 0; i < (size_t)-1; i++) {\n-    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n-    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n-    if (c1 != c2)\n-      return c1-c2;\n-    if (!c1)\n-      break;\n-  }\n-  return 0;\n-#endif\n-}\n-#endif\n-\n-#ifndef HAVE_STRNCASECMP\n-int ares_strncasecmp(const char *a, const char *b, size_t n)\n-{\n-#if defined(HAVE_STRNCMPI)\n-  return strncmpi(a, b, n);\n-#elif defined(HAVE_STRNICMP)\n-  return strnicmp(a, b, n);\n-#else\n-  size_t i;\n-\n-  for (i = 0; i < n; i++) {\n-    int c1 = ISUPPER(a[i]) ? tolower(a[i]) : a[i];\n-    int c2 = ISUPPER(b[i]) ? tolower(b[i]) : b[i];\n-    if (c1 != c2)\n-      return c1-c2;\n-    if (!c1)\n-      break;\n-  }\n-  return 0;\n-#endif\n-}\n-#endif\n-"}, {"sha": "57d86f963429ce434a166db3144afa069f8043f4", "filename": "src/rt/libuv/src/ares/ares_strcasecmp.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strcasecmp.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,30 +0,0 @@\n-#ifndef HEADER_CARES_STRCASECMP_H\n-#define HEADER_CARES_STRCASECMP_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifndef HAVE_STRCASECMP\n-extern int ares_strcasecmp(const char *a, const char *b);\n-#endif\n-\n-#ifndef HAVE_STRNCASECMP\n-extern int ares_strncasecmp(const char *a, const char *b, size_t n);\n-#endif\n-\n-#endif /* HEADER_CARES_STRCASECMP_H */"}, {"sha": "18043274e9925dceda4679a1404a05313585435f", "filename": "src/rt/libuv/src/ares/ares_strdup.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,42 +0,0 @@\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include \"ares_strdup.h\"\n-\n-#ifndef HAVE_STRDUP\n-char *ares_strdup(const char *s1)\n-{\n-  size_t sz;\n-  char * s2;\n-\n-  if(s1) {\n-    sz = strlen(s1);\n-    if(sz < (size_t)-1) {\n-      sz++;\n-      if(sz < ((size_t)-1) / sizeof(char)) {\n-        s2 = malloc(sz * sizeof(char));\n-        if(s2) {\n-          memcpy(s2, s1, sz * sizeof(char));\n-          return s2;\n-        }\n-      }\n-    }\n-  }\n-  return (char *)NULL;\n-}\n-#endif"}, {"sha": "c413a941c5179561ca8241c17f4e1f67f796a30c", "filename": "src/rt/libuv/src/ares/ares_strdup.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strdup.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,26 +0,0 @@\n-#ifndef HEADER_CARES_STRDUP_H\n-#define HEADER_CARES_STRDUP_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifndef HAVE_STRDUP\n-extern char *ares_strdup(const char *s1);\n-#endif\n-\n-#endif /* HEADER_CARES_STRDUP_H */"}, {"sha": "c3ecbd7b43c0e75b50e245c08e2f51263bb96a6d", "filename": "src/rt/libuv/src/ares/ares_strerror.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_strerror.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,56 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include <assert.h>\n-#include \"ares.h\"\n-\n-const char *ares_strerror(int code)\n-{\n-  /* Return a string literal from a table. */\n-  const char *errtext[] = {\n-    \"Successful completion\",\n-    \"DNS server returned answer with no data\",\n-    \"DNS server claims query was misformatted\",\n-    \"DNS server returned general failure\",\n-    \"Domain name not found\",\n-    \"DNS server does not implement requested operation\",\n-    \"DNS server refused query\",\n-    \"Misformatted DNS query\",\n-    \"Misformatted domain name\",\n-    \"Unsupported address family\",\n-    \"Misformatted DNS reply\",\n-    \"Could not contact DNS servers\",\n-    \"Timeout while contacting DNS servers\",\n-    \"End of file\",\n-    \"Error reading file\",\n-    \"Out of memory\",\n-    \"Channel is being destroyed\",\n-    \"Misformatted string\",\n-    \"Illegal flags specified\",\n-    \"Given hostname is not numeric\",\n-    \"Illegal hints flags specified\",\n-    \"c-ares library initialization not yet performed\",\n-    \"Error loading iphlpapi.dll\",\n-    \"Could not find GetNetworkParams function\",\n-    \"DNS query cancelled\"\n-  };\n-\n-  if(code >= 0 && code < (int)(sizeof(errtext) / sizeof(*errtext)))\n-    return errtext[code];\n-  else\n-    return \"unknown\";\n-}"}, {"sha": "2da4f5f4a18976a8b50af14f311a8f62614a1b7a", "filename": "src/rt/libuv/src/ares/ares_timeout.c", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_timeout.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,80 +0,0 @@\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys/time.h>\n-#endif\n-\n-#include <time.h>\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-/* WARNING: Beware that this is linear in the number of outstanding\n- * requests! You are probably far better off just calling ares_process()\n- * once per second, rather than calling ares_timeout() to figure out\n- * when to next call ares_process().\n- */\n-struct timeval *ares_timeout(ares_channel channel, struct timeval *maxtv,\n-                             struct timeval *tvbuf)\n-{\n-  struct query *query;\n-  struct list_node* list_head;\n-  struct list_node* list_node;\n-  struct timeval now;\n-  struct timeval nextstop;\n-  long offset, min_offset;\n-\n-  /* No queries, no timeout (and no fetch of the current time). */\n-  if (ares__is_list_empty(&(channel->all_queries)))\n-    return maxtv;\n-\n-  /* Find the minimum timeout for the current set of queries. */\n-  now = ares__tvnow();\n-  min_offset = -1;\n-\n-  list_head = &(channel->all_queries);\n-  for (list_node = list_head->next; list_node != list_head;\n-       list_node = list_node->next)\n-    {\n-      query = list_node->data;\n-      if (query->timeout.tv_sec == 0)\n-        continue;\n-      offset = ares__timeoffset(&now, &query->timeout);\n-      if (offset < 0)\n-        offset = 0;\n-      if (min_offset == -1 || offset < min_offset)\n-        min_offset = offset;\n-    }\n-\n-  if(min_offset != -1) {\n-    nextstop.tv_sec = min_offset/1000;\n-    nextstop.tv_usec = (min_offset%1000)*1000;\n-  }\n-\n-  /* If we found a minimum timeout and it's sooner than the one specified in\n-   * maxtv (if any), return it.  Otherwise go with maxtv.\n-   */\n-  if (min_offset != -1 && (!maxtv || ares__timedout(maxtv, &nextstop)))\n-    {\n-      *tvbuf = nextstop;\n-      return tvbuf;\n-    }\n-  else\n-    return maxtv;\n-}"}, {"sha": "4f8c42f2c9a34d5d11562de85b2256638c31cfda", "filename": "src/rt/libuv/src/ares/ares_version.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_version.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,11 +0,0 @@\n-\n-#include \"ares_setup.h\"\n-#include \"ares.h\"\n-\n-const char *ares_version(int *version)\n-{\n-  if(version)\n-    *version = ARES_VERSION;\n-\n-  return ARES_VERSION_STR;\n-}"}, {"sha": "9e8e2d65741e2ee3621096db8b55d55277bf1249", "filename": "src/rt/libuv/src/ares/ares_writev.c", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,79 +0,0 @@\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-\n-#ifdef HAVE_LIMITS_H\n-#  include <limits.h>\n-#endif\n-\n-#include \"ares.h\"\n-#include \"ares_private.h\"\n-\n-#ifndef HAVE_WRITEV\n-ssize_t ares_writev(ares_socket_t s, const struct iovec *iov, int iovcnt)\n-{\n-  char *buffer, *bp;\n-  int i;\n-  size_t bytes = 0;\n-  ssize_t result;\n-\n-  /* Validate iovcnt */\n-  if (iovcnt <= 0)\n-  {\n-    SET_ERRNO(EINVAL);\n-    return (-1);\n-  }\n-\n-  /* Validate and find the sum of the iov_len values in the iov array */\n-  for (i = 0; i < iovcnt; i++)\n-  {\n-    if (iov[i].iov_len > INT_MAX - bytes)\n-    {\n-      SET_ERRNO(EINVAL);\n-      return (-1);\n-    }\n-    bytes += iov[i].iov_len;\n-  }\n-\n-  if (bytes == 0)\n-    return (0);\n-\n-  /* Allocate a temporary buffer to hold the data */\n-  buffer = malloc(bytes);\n-  if (!buffer)\n-  {\n-    SET_ERRNO(ENOMEM);\n-    return (-1);\n-  }\n-\n-  /* Copy the data into buffer */\n-  for (bp = buffer, i = 0; i < iovcnt; ++i)\n-  {\n-    memcpy (bp, iov[i].iov_base, iov[i].iov_len);\n-    bp += iov[i].iov_len;\n-  }\n-\n-  /* Send buffer contents */\n-  result = swrite(s, buffer, bytes);\n-\n-  free(buffer);\n-\n-  return (result);\n-}\n-#endif\n-"}, {"sha": "1a23a0f3d10929de21f6aaf8d8400c4d5e501565", "filename": "src/rt/libuv/src/ares/ares_writev.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fares_writev.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,36 +0,0 @@\n-#ifndef HEADER_CARES_WRITEV_H\n-#define HEADER_CARES_WRITEV_H\n-\n-\n-/* Copyright 1998 by the Massachusetts Institute of Technology.\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#include \"ares_setup.h\"\n-#include \"ares.h\"\n-\n-#ifndef HAVE_WRITEV\n-\n-/* Structure for scatter/gather I/O. */\n-struct iovec\n-{\n-  void *iov_base;  /* Pointer to data. */\n-  size_t iov_len;  /* Length of data.  */\n-};\n-\n-extern ssize_t ares_writev(ares_socket_t s, const struct iovec *iov, int iovcnt);\n-\n-#endif\n-\n-#endif /* HEADER_CARES_WRITEV_H */"}, {"sha": "5c89506b33f904d10f4fba69e882674c27b0d09b", "filename": "src/rt/libuv/src/ares/bitncmp.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,59 +0,0 @@\n-\n-/*\n- * Copyright (c) 2004 by Internet Systems Consortium, Inc. (\"ISC\")\n- * Copyright (c) 1996,1999 by Internet Software Consortium.\n- *\n- * Permission to use, copy, modify, and distribute this software for any\n- * purpose with or without fee is hereby granted, provided that the above\n- * copyright notice and this permission notice appear in all copies.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\" AND ISC DISCLAIMS ALL WARRANTIES\n- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n- * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR\n- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT\n- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n- */\n-\n-#ifndef HAVE_BITNCMP\n-\n-#include \"ares_setup.h\"\n-#include \"bitncmp.h\"\n-\n-/*\n- * int\n- * bitncmp(l, r, n)\n- *\tcompare bit masks l and r, for n bits.\n- * return:\n- *\t-1, 1, or 0 in the libc tradition.\n- * note:\n- *\tnetwork byte order assumed.  this means 192.5.5.240/28 has\n- *\t0x11110000 in its fourth octet.\n- * author:\n- *\tPaul Vixie (ISC), June 1996\n- */\n-int\n-ares_bitncmp(const void *l, const void *r, int n) {\n-\tunsigned int lb, rb;\n-\tint x, b;\n-\n-\tb = n / 8;\n-\tx = memcmp(l, r, b);\n-\tif (x || (n % 8) == 0)\n-\t\treturn (x);\n-\n-\tlb = ((const unsigned char *)l)[b];\n-\trb = ((const unsigned char *)r)[b];\n-\tfor (b = n % 8; b > 0; b--) {\n-\t\tif ((lb & 0x80) != (rb & 0x80)) {\n-\t\t\tif (lb & 0x80)\n-\t\t\t\treturn (1);\n-\t\t\treturn (-1);\n-\t\t}\n-\t\tlb <<= 1;\n-\t\trb <<= 1;\n-\t}\n-\treturn (0);\n-}\n-#endif"}, {"sha": "b0a5c812b428740d43e469356f0980789857ebae", "filename": "src/rt/libuv/src/ares/bitncmp.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fbitncmp.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,26 +0,0 @@\n-#ifndef __ARES_BITNCMP_H\n-#define __ARES_BITNCMP_H\n-\n-\n-/* Copyright (C) 2005 by Dominick Meglio\n- *\n- * Permission to use, copy, modify, and distribute this\n- * software and its documentation for any purpose and without\n- * fee is hereby granted, provided that the above copyright\n- * notice appear in all copies and that both that copyright\n- * notice and this permission notice appear in supporting\n- * documentation, and that the name of M.I.T. not be used in\n- * advertising or publicity pertaining to distribution of the\n- * software without specific, written prior permission.\n- * M.I.T. makes no representations about the suitability of\n- * this software for any purpose.  It is provided \"as is\"\n- * without express or implied warranty.\n- */\n-\n-#ifndef HAVE_BITNCMP\n-int ares_bitncmp(const void *l, const void *r, int n);\n-#else\n-#define ares_bitncmp(x,y,z) bitncmp(x,y,z)\n-#endif\n-\n-#endif /* __ARES_BITNCMP_H */"}, {"sha": "592a245985e02d6d4eda57aced778171e3cd8f50", "filename": "src/rt/libuv/src/ares/config_cygwin/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_cygwin%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,512 +0,0 @@\n-/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n-/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-/* #undef AC_APPLE_UNIVERSAL_BUILD */\n-\n-/* define this if ares is built for a big endian system */\n-/* #undef ARES_BIG_ENDIAN */\n-\n-/* when building as static part of libcurl */\n-/* #undef BUILDING_LIBCURL */\n-\n-/* when building c-ares library */\n-/* #undef CARES_BUILDING_LIBRARY */\n-\n-/* when not building a shared library */\n-/* #undef CARES_STATICLIB */\n-\n-/* Define to 1 to enable hiding of library internal symbols. */\n-#define CARES_SYMBOL_HIDING 1\n-\n-/* Definition to make a library symbol externally visible. */\n-#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n-\n-/* if a /etc/inet dir is being used */\n-/* #undef ETC_INET */\n-\n-/* Define to the type qualifier of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_QUAL_ARG1 const\n-\n-/* Define to the type of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n-\n-/* Define to the type of arg 2 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG2 socklen_t\n-\n-/* Define to the type of args 4 and 6 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG46 int\n-\n-/* Define to the type of arg 7 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG7 int\n-\n-/* Specifies the number of arguments to getservbyport_r */\n-/* #undef GETSERVBYPORT_R_ARGS */\n-\n-/* Specifies the size of the buffer to pass to getservbyport_r */\n-/* #undef GETSERVBYPORT_R_BUFSIZE */\n-\n-/* Define to 1 if you have AF_INET6. */\n-#define HAVE_AF_INET6 1\n-\n-/* Define to 1 if you have the <arpa/inet.h> header file. */\n-#define HAVE_ARPA_INET_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n-#define HAVE_ARPA_NAMESER_COMPAT_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser.h> header file. */\n-#define HAVE_ARPA_NAMESER_H 1\n-\n-/* Define to 1 if you have the <assert.h> header file. */\n-#define HAVE_ASSERT_H 1\n-\n-/* Define to 1 if you have the `bitncmp' function. */\n-/* #undef HAVE_BITNCMP */\n-\n-/* Define to 1 if bool is an available type. */\n-#define HAVE_BOOL_T 1\n-\n-/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n-/* #undef HAVE_CLOCK_GETTIME_MONOTONIC */\n-\n-/* Define to 1 if you have the closesocket function. */\n-/* #undef HAVE_CLOSESOCKET */\n-\n-/* Define to 1 if you have the CloseSocket camel case function. */\n-/* #undef HAVE_CLOSESOCKET_CAMEL */\n-\n-/* Define to 1 if you have the connect function. */\n-#define HAVE_CONNECT 1\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#define HAVE_DLFCN_H 1\n-\n-/* Define to 1 if you have the <errno.h> header file. */\n-#define HAVE_ERRNO_H 1\n-\n-/* Define to 1 if you have the fcntl function. */\n-#define HAVE_FCNTL 1\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#define HAVE_FCNTL_H 1\n-\n-/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n-#define HAVE_FCNTL_O_NONBLOCK 1\n-\n-/* Define to 1 if you have the freeaddrinfo function. */\n-#define HAVE_FREEADDRINFO 1\n-\n-/* Define to 1 if you have a working getaddrinfo function. */\n-#define HAVE_GETADDRINFO 1\n-\n-/* Define to 1 if the getaddrinfo function is threadsafe. */\n-/* #undef HAVE_GETADDRINFO_THREADSAFE */\n-\n-/* Define to 1 if you have the gethostbyaddr function. */\n-#define HAVE_GETHOSTBYADDR 1\n-\n-/* Define to 1 if you have the gethostbyname function. */\n-#define HAVE_GETHOSTBYNAME 1\n-\n-/* Define to 1 if you have the gethostname function. */\n-#define HAVE_GETHOSTNAME 1\n-\n-/* Define to 1 if you have the getnameinfo function. */\n-#define HAVE_GETNAMEINFO 1\n-\n-/* Define to 1 if you have the getservbyport_r function. */\n-/* #undef HAVE_GETSERVBYPORT_R */\n-\n-/* Define to 1 if you have the `gettimeofday' function. */\n-#define HAVE_GETTIMEOFDAY 1\n-\n-/* Define to 1 if you have the `if_indextoname' function. */\n-#define HAVE_IF_INDEXTONAME 1\n-\n-/* Define to 1 if you have the `inet_net_pton' function. */\n-/* #undef HAVE_INET_NET_PTON */\n-\n-/* Define to 1 if inet_net_pton supports IPv6. */\n-/* #undef HAVE_INET_NET_PTON_IPV6 */\n-\n-/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n-#define HAVE_INET_NTOP 1\n-\n-/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n-#define HAVE_INET_PTON 1\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#define HAVE_INTTYPES_H 1\n-\n-/* Define to 1 if you have the ioctl function. */\n-#define HAVE_IOCTL 1\n-\n-/* Define to 1 if you have the ioctlsocket function. */\n-/* #undef HAVE_IOCTLSOCKET */\n-\n-/* Define to 1 if you have the IoctlSocket camel case function. */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL */\n-\n-/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n-   */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n-/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctl FIONBIO function. */\n-#define HAVE_IOCTL_FIONBIO 1\n-\n-/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n-#define HAVE_IOCTL_SIOCGIFADDR 1\n-\n-/* Define to 1 if you have the `resolve' library (-lresolve). */\n-/* #undef HAVE_LIBRESOLVE */\n-\n-/* Define to 1 if you have the <limits.h> header file. */\n-#define HAVE_LIMITS_H 1\n-\n-/* if your compiler supports LL */\n-#define HAVE_LL 1\n-\n-/* Define to 1 if the compiler supports the 'long long' data type. */\n-#define HAVE_LONGLONG 1\n-\n-/* Define to 1 if you have the malloc.h header file. */\n-#define HAVE_MALLOC_H 1\n-\n-/* Define to 1 if you have the memory.h header file. */\n-#define HAVE_MEMORY_H 1\n-\n-/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n-#define HAVE_MSG_NOSIGNAL 1\n-\n-/* Define to 1 if you have the <netdb.h> header file. */\n-#define HAVE_NETDB_H 1\n-\n-/* Define to 1 if you have the <netinet/in.h> header file. */\n-#define HAVE_NETINET_IN_H 1\n-\n-/* Define to 1 if you have the <netinet/tcp.h> header file. */\n-#define HAVE_NETINET_TCP_H 1\n-\n-/* Define to 1 if you have the <net/if.h> header file. */\n-#define HAVE_NET_IF_H 1\n-\n-/* Define to 1 if you have PF_INET6. */\n-#define HAVE_PF_INET6 1\n-\n-/* Define to 1 if you have the recv function. */\n-#define HAVE_RECV 1\n-\n-/* Define to 1 if you have the recvfrom function. */\n-#define HAVE_RECVFROM 1\n-\n-/* Define to 1 if you have the send function. */\n-#define HAVE_SEND 1\n-\n-/* Define to 1 if you have the setsockopt function. */\n-#define HAVE_SETSOCKOPT 1\n-\n-/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n-/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#define HAVE_SIGNAL_H 1\n-\n-/* Define to 1 if sig_atomic_t is an available typedef. */\n-#define HAVE_SIG_ATOMIC_T 1\n-\n-/* Define to 1 if sig_atomic_t is already defined as volatile. */\n-/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n-\n-/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n-#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n-\n-/* Define to 1 if you have the socket function. */\n-#define HAVE_SOCKET 1\n-\n-/* Define to 1 if you have the <socket.h> header file. */\n-/* #undef HAVE_SOCKET_H */\n-\n-/* Define to 1 if you have the <stdbool.h> header file. */\n-#define HAVE_STDBOOL_H 1\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#define HAVE_STDINT_H 1\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#define HAVE_STDLIB_H 1\n-\n-/* Define to 1 if you have the strcasecmp function. */\n-#define HAVE_STRCASECMP 1\n-\n-/* Define to 1 if you have the strcmpi function. */\n-/* #undef HAVE_STRCMPI */\n-\n-/* Define to 1 if you have the strdup function. */\n-#define HAVE_STRDUP 1\n-\n-/* Define to 1 if you have the stricmp function. */\n-/* #undef HAVE_STRICMP */\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#define HAVE_STRINGS_H 1\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#define HAVE_STRING_H 1\n-\n-/* Define to 1 if you have the strncasecmp function. */\n-#define HAVE_STRNCASECMP 1\n-\n-/* Define to 1 if you have the strncmpi function. */\n-/* #undef HAVE_STRNCMPI */\n-\n-/* Define to 1 if you have the strnicmp function. */\n-/* #undef HAVE_STRNICMP */\n-\n-/* Define to 1 if you have the <stropts.h> header file. */\n-/* #undef HAVE_STROPTS_H */\n-\n-/* Define to 1 if you have struct addrinfo. */\n-#define HAVE_STRUCT_ADDRINFO 1\n-\n-/* Define to 1 if you have struct in6_addr. */\n-#define HAVE_STRUCT_IN6_ADDR 1\n-\n-/* Define to 1 if you have struct sockaddr_in6. */\n-#define HAVE_STRUCT_SOCKADDR_IN6 1\n-\n-/* if struct sockaddr_storage is defined */\n-#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n-\n-/* Define to 1 if you have the timeval struct. */\n-#define HAVE_STRUCT_TIMEVAL 1\n-\n-/* Define to 1 if you have the <sys/ioctl.h> header file. */\n-#define HAVE_SYS_IOCTL_H 1\n-\n-/* Define to 1 if you have the <sys/param.h> header file. */\n-#define HAVE_SYS_PARAM_H 1\n-\n-/* Define to 1 if you have the <sys/select.h> header file. */\n-#define HAVE_SYS_SELECT_H 1\n-\n-/* Define to 1 if you have the <sys/socket.h> header file. */\n-#define HAVE_SYS_SOCKET_H 1\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#define HAVE_SYS_STAT_H 1\n-\n-/* Define to 1 if you have the <sys/time.h> header file. */\n-#define HAVE_SYS_TIME_H 1\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#define HAVE_SYS_TYPES_H 1\n-\n-/* Define to 1 if you have the <sys/uio.h> header file. */\n-#define HAVE_SYS_UIO_H 1\n-\n-/* Define to 1 if you have the <time.h> header file. */\n-#define HAVE_TIME_H 1\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#define HAVE_UNISTD_H 1\n-\n-/* Define to 1 if you have the windows.h header file. */\n-/* #undef HAVE_WINDOWS_H */\n-\n-/* Define to 1 if you have the winsock2.h header file. */\n-/* #undef HAVE_WINSOCK2_H */\n-\n-/* Define to 1 if you have the winsock.h header file. */\n-/* #undef HAVE_WINSOCK_H */\n-\n-/* Define to 1 if you have the writev function. */\n-#define HAVE_WRITEV 1\n-\n-/* Define to 1 if you have the ws2tcpip.h header file. */\n-/* #undef HAVE_WS2TCPIP_H */\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#define LT_OBJDIR \".libs/\"\n-\n-/* Define to 1 if you are building a native Windows target. */\n-/* #undef NATIVE_WINDOWS */\n-\n-/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n-/* #undef NEED_MALLOC_H */\n-\n-/* Define to 1 if you need the memory.h header file even with stdlib.h */\n-/* #undef NEED_MEMORY_H */\n-\n-/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n-/* #undef NEED_REENTRANT */\n-\n-/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n-/* #undef NEED_THREAD_SAFE */\n-\n-/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n-/* #undef NO_MINUS_C_MINUS_O */\n-\n-/* cpu-machine-OS */\n-#define OS \"i686-pc-cygwin\"\n-\n-/* Name of package */\n-#define PACKAGE \"c-ares\"\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n-\n-/* Define to the full name of this package. */\n-#define PACKAGE_NAME \"c-ares\"\n-\n-/* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \"c-ares 1.7.1\"\n-\n-/* Define to the one symbol short name of this package. */\n-#define PACKAGE_TARNAME \"c-ares\"\n-\n-/* Define to the home page for this package. */\n-#define PACKAGE_URL \"\"\n-\n-/* Define to the version of this package. */\n-#define PACKAGE_VERSION \"1.7.1\"\n-\n-/* a suitable file/device to read random data from */\n-#define RANDOM_FILE \"/dev/urandom\"\n-\n-/* Define to the type of arg 1 for recvfrom. */\n-#define RECVFROM_TYPE_ARG1 int\n-\n-/* Define to the type pointed by arg 2 for recvfrom. */\n-#define RECVFROM_TYPE_ARG2 void\n-\n-/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n-#define RECVFROM_TYPE_ARG2_IS_VOID 1\n-\n-/* Define to the type of arg 3 for recvfrom. */\n-#define RECVFROM_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recvfrom. */\n-#define RECVFROM_TYPE_ARG4 int\n-\n-/* Define to the type pointed by arg 5 for recvfrom. */\n-#define RECVFROM_TYPE_ARG5 struct sockaddr\n-\n-/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n-\n-/* Define to the type pointed by arg 6 for recvfrom. */\n-#define RECVFROM_TYPE_ARG6 socklen_t\n-\n-/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n-\n-/* Define to the function return type for recvfrom. */\n-#define RECVFROM_TYPE_RETV int\n-\n-/* Define to the type of arg 1 for recv. */\n-#define RECV_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for recv. */\n-#define RECV_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for recv. */\n-#define RECV_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recv. */\n-#define RECV_TYPE_ARG4 int\n-\n-/* Define to the function return type for recv. */\n-#define RECV_TYPE_RETV int\n-\n-/* Define as the return type of signal handlers (`int' or `void'). */\n-#define RETSIGTYPE void\n-\n-/* Define to the type qualifier of arg 2 for send. */\n-#define SEND_QUAL_ARG2 const\n-\n-/* Define to the type of arg 1 for send. */\n-#define SEND_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for send. */\n-#define SEND_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for send. */\n-#define SEND_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for send. */\n-#define SEND_TYPE_ARG4 int\n-\n-/* Define to the function return type for send. */\n-#define SEND_TYPE_RETV int\n-\n-/* The size of `int', as computed by sizeof. */\n-#define SIZEOF_INT 4\n-\n-/* The size of `long', as computed by sizeof. */\n-#define SIZEOF_LONG 4\n-\n-/* The size of `size_t', as computed by sizeof. */\n-#define SIZEOF_SIZE_T 4\n-\n-/* The size of `struct in6_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN6_ADDR 16\n-\n-/* The size of `struct in_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN_ADDR 4\n-\n-/* The size of `time_t', as computed by sizeof. */\n-#define SIZEOF_TIME_T 4\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#define STDC_HEADERS 1\n-\n-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n-#define TIME_WITH_SYS_TIME 1\n-\n-/* Define to disable non-blocking sockets. */\n-/* #undef USE_BLOCKING_SOCKETS */\n-\n-/* Version number of package */\n-#define VERSION \"1.7.1\"\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-/* #  undef WORDS_BIGENDIAN */\n-# endif\n-#endif\n-\n-/* Define to 1 if OS is AIX. */\n-#ifndef _ALL_SOURCE\n-/* #  undef _ALL_SOURCE */\n-#endif\n-\n-/* Number of bits in a file offset, on hosts where this is settable. */\n-/* #undef _FILE_OFFSET_BITS */\n-\n-/* Define for large files, on AIX-style hosts. */\n-/* #undef _LARGE_FILES */\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-/* #undef const */\n-\n-/* Type to use in place of in_addr_t when system does not provide it. */\n-/* #undef in_addr_t */\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-/* #undef size_t */\n-\n-/* the signed version of size_t */\n-/* #undef ssize_t */\n-\n-#define HAVE_GETENV 1"}, {"sha": "920d922c81c15545aa55aa2385ea5ba0c6e76d7b", "filename": "src/rt/libuv/src/ares/config_darwin/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_darwin%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,512 +0,0 @@\n-/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n-/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-/* #undef AC_APPLE_UNIVERSAL_BUILD */\n-\n-/* define this if ares is built for a big endian system */\n-/* #undef ARES_BIG_ENDIAN */\n-\n-/* when building as static part of libcurl */\n-/* #undef BUILDING_LIBCURL */\n-\n-/* when building c-ares library */\n-/* #undef CARES_BUILDING_LIBRARY */\n-\n-/* when not building a shared library */\n-/* #undef CARES_STATICLIB */\n-\n-/* Define to 1 to enable hiding of library internal symbols. */\n-#define CARES_SYMBOL_HIDING 1\n-\n-/* Definition to make a library symbol externally visible. */\n-#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n-\n-/* if a /etc/inet dir is being used */\n-/* #undef ETC_INET */\n-\n-/* Define to the type qualifier of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_QUAL_ARG1 const\n-\n-/* Define to the type of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n-\n-/* Define to the type of arg 2 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG2 socklen_t\n-\n-/* Define to the type of args 4 and 6 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG46 socklen_t\n-\n-/* Define to the type of arg 7 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG7 int\n-\n-/* Specifies the number of arguments to getservbyport_r */\n-/* #undef GETSERVBYPORT_R_ARGS */\n-\n-/* Specifies the size of the buffer to pass to getservbyport_r */\n-/* #undef GETSERVBYPORT_R_BUFSIZE */\n-\n-/* Define to 1 if you have AF_INET6. */\n-#define HAVE_AF_INET6 1\n-\n-/* Define to 1 if you have the <arpa/inet.h> header file. */\n-#define HAVE_ARPA_INET_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n-#define HAVE_ARPA_NAMESER_COMPAT_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser.h> header file. */\n-#define HAVE_ARPA_NAMESER_H 1\n-\n-/* Define to 1 if you have the <assert.h> header file. */\n-#define HAVE_ASSERT_H 1\n-\n-/* Define to 1 if you have the `bitncmp' function. */\n-/* #undef HAVE_BITNCMP */\n-\n-/* Define to 1 if bool is an available type. */\n-#define HAVE_BOOL_T 1\n-\n-/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n-/* #undef HAVE_CLOCK_GETTIME_MONOTONIC */\n-\n-/* Define to 1 if you have the closesocket function. */\n-/* #undef HAVE_CLOSESOCKET */\n-\n-/* Define to 1 if you have the CloseSocket camel case function. */\n-/* #undef HAVE_CLOSESOCKET_CAMEL */\n-\n-/* Define to 1 if you have the connect function. */\n-#define HAVE_CONNECT 1\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#define HAVE_DLFCN_H 1\n-\n-/* Define to 1 if you have the <errno.h> header file. */\n-#define HAVE_ERRNO_H 1\n-\n-/* Define to 1 if you have the fcntl function. */\n-#define HAVE_FCNTL 1\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#define HAVE_FCNTL_H 1\n-\n-/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n-#define HAVE_FCNTL_O_NONBLOCK 1\n-\n-/* Define to 1 if you have the freeaddrinfo function. */\n-#define HAVE_FREEADDRINFO 1\n-\n-/* Define to 1 if you have a working getaddrinfo function. */\n-#define HAVE_GETADDRINFO 1\n-\n-/* Define to 1 if the getaddrinfo function is threadsafe. */\n-#define HAVE_GETADDRINFO_THREADSAFE 1\n-\n-/* Define to 1 if you have the gethostbyaddr function. */\n-#define HAVE_GETHOSTBYADDR 1\n-\n-/* Define to 1 if you have the gethostbyname function. */\n-#define HAVE_GETHOSTBYNAME 1\n-\n-/* Define to 1 if you have the gethostname function. */\n-#define HAVE_GETHOSTNAME 1\n-\n-/* Define to 1 if you have the getnameinfo function. */\n-#define HAVE_GETNAMEINFO 1\n-\n-/* Define to 1 if you have the getservbyport_r function. */\n-/* #undef HAVE_GETSERVBYPORT_R */\n-\n-/* Define to 1 if you have the `gettimeofday' function. */\n-#define HAVE_GETTIMEOFDAY 1\n-\n-/* Define to 1 if you have the `if_indextoname' function. */\n-#define HAVE_IF_INDEXTONAME 1\n-\n-/* Define to 1 if you have the `inet_net_pton' function. */\n-#define HAVE_INET_NET_PTON 1\n-\n-/* Define to 1 if inet_net_pton supports IPv6. */\n-#define HAVE_INET_NET_PTON_IPV6 1\n-\n-/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n-#define HAVE_INET_NTOP 1\n-\n-/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n-#define HAVE_INET_PTON 1\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#define HAVE_INTTYPES_H 1\n-\n-/* Define to 1 if you have the ioctl function. */\n-#define HAVE_IOCTL 1\n-\n-/* Define to 1 if you have the ioctlsocket function. */\n-/* #undef HAVE_IOCTLSOCKET */\n-\n-/* Define to 1 if you have the IoctlSocket camel case function. */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL */\n-\n-/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n-   */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n-/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctl FIONBIO function. */\n-#define HAVE_IOCTL_FIONBIO 1\n-\n-/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n-#define HAVE_IOCTL_SIOCGIFADDR 1\n-\n-/* Define to 1 if you have the `resolve' library (-lresolve). */\n-/* #undef HAVE_LIBRESOLVE */\n-\n-/* Define to 1 if you have the <limits.h> header file. */\n-#define HAVE_LIMITS_H 1\n-\n-/* if your compiler supports LL */\n-#define HAVE_LL 1\n-\n-/* Define to 1 if the compiler supports the 'long long' data type. */\n-#define HAVE_LONGLONG 1\n-\n-/* Define to 1 if you have the malloc.h header file. */\n-/* #undef HAVE_MALLOC_H */\n-\n-/* Define to 1 if you have the memory.h header file. */\n-#define HAVE_MEMORY_H 1\n-\n-/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n-/* #undef HAVE_MSG_NOSIGNAL */\n-\n-/* Define to 1 if you have the <netdb.h> header file. */\n-#define HAVE_NETDB_H 1\n-\n-/* Define to 1 if you have the <netinet/in.h> header file. */\n-#define HAVE_NETINET_IN_H 1\n-\n-/* Define to 1 if you have the <netinet/tcp.h> header file. */\n-#define HAVE_NETINET_TCP_H 1\n-\n-/* Define to 1 if you have the <net/if.h> header file. */\n-#define HAVE_NET_IF_H 1\n-\n-/* Define to 1 if you have PF_INET6. */\n-#define HAVE_PF_INET6 1\n-\n-/* Define to 1 if you have the recv function. */\n-#define HAVE_RECV 1\n-\n-/* Define to 1 if you have the recvfrom function. */\n-#define HAVE_RECVFROM 1\n-\n-/* Define to 1 if you have the send function. */\n-#define HAVE_SEND 1\n-\n-/* Define to 1 if you have the setsockopt function. */\n-#define HAVE_SETSOCKOPT 1\n-\n-/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n-/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#define HAVE_SIGNAL_H 1\n-\n-/* Define to 1 if sig_atomic_t is an available typedef. */\n-#define HAVE_SIG_ATOMIC_T 1\n-\n-/* Define to 1 if sig_atomic_t is already defined as volatile. */\n-/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n-\n-/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n-#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n-\n-/* Define to 1 if you have the socket function. */\n-#define HAVE_SOCKET 1\n-\n-/* Define to 1 if you have the <socket.h> header file. */\n-/* #undef HAVE_SOCKET_H */\n-\n-/* Define to 1 if you have the <stdbool.h> header file. */\n-#define HAVE_STDBOOL_H 1\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#define HAVE_STDINT_H 1\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#define HAVE_STDLIB_H 1\n-\n-/* Define to 1 if you have the strcasecmp function. */\n-#define HAVE_STRCASECMP 1\n-\n-/* Define to 1 if you have the strcmpi function. */\n-/* #undef HAVE_STRCMPI */\n-\n-/* Define to 1 if you have the strdup function. */\n-#define HAVE_STRDUP 1\n-\n-/* Define to 1 if you have the stricmp function. */\n-/* #undef HAVE_STRICMP */\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#define HAVE_STRINGS_H 1\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#define HAVE_STRING_H 1\n-\n-/* Define to 1 if you have the strncasecmp function. */\n-#define HAVE_STRNCASECMP 1\n-\n-/* Define to 1 if you have the strncmpi function. */\n-/* #undef HAVE_STRNCMPI */\n-\n-/* Define to 1 if you have the strnicmp function. */\n-/* #undef HAVE_STRNICMP */\n-\n-/* Define to 1 if you have the <stropts.h> header file. */\n-/* #undef HAVE_STROPTS_H */\n-\n-/* Define to 1 if you have struct addrinfo. */\n-#define HAVE_STRUCT_ADDRINFO 1\n-\n-/* Define to 1 if you have struct in6_addr. */\n-#define HAVE_STRUCT_IN6_ADDR 1\n-\n-/* Define to 1 if you have struct sockaddr_in6. */\n-#define HAVE_STRUCT_SOCKADDR_IN6 1\n-\n-/* if struct sockaddr_storage is defined */\n-#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n-\n-/* Define to 1 if you have the timeval struct. */\n-#define HAVE_STRUCT_TIMEVAL 1\n-\n-/* Define to 1 if you have the <sys/ioctl.h> header file. */\n-#define HAVE_SYS_IOCTL_H 1\n-\n-/* Define to 1 if you have the <sys/param.h> header file. */\n-#define HAVE_SYS_PARAM_H 1\n-\n-/* Define to 1 if you have the <sys/select.h> header file. */\n-#define HAVE_SYS_SELECT_H 1\n-\n-/* Define to 1 if you have the <sys/socket.h> header file. */\n-#define HAVE_SYS_SOCKET_H 1\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#define HAVE_SYS_STAT_H 1\n-\n-/* Define to 1 if you have the <sys/time.h> header file. */\n-#define HAVE_SYS_TIME_H 1\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#define HAVE_SYS_TYPES_H 1\n-\n-/* Define to 1 if you have the <sys/uio.h> header file. */\n-#define HAVE_SYS_UIO_H 1\n-\n-/* Define to 1 if you have the <time.h> header file. */\n-#define HAVE_TIME_H 1\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#define HAVE_UNISTD_H 1\n-\n-/* Define to 1 if you have the windows.h header file. */\n-/* #undef HAVE_WINDOWS_H */\n-\n-/* Define to 1 if you have the winsock2.h header file. */\n-/* #undef HAVE_WINSOCK2_H */\n-\n-/* Define to 1 if you have the winsock.h header file. */\n-/* #undef HAVE_WINSOCK_H */\n-\n-/* Define to 1 if you have the writev function. */\n-#define HAVE_WRITEV 1\n-\n-/* Define to 1 if you have the ws2tcpip.h header file. */\n-/* #undef HAVE_WS2TCPIP_H */\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#define LT_OBJDIR \".libs/\"\n-\n-/* Define to 1 if you are building a native Windows target. */\n-/* #undef NATIVE_WINDOWS */\n-\n-/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n-/* #undef NEED_MALLOC_H */\n-\n-/* Define to 1 if you need the memory.h header file even with stdlib.h */\n-/* #undef NEED_MEMORY_H */\n-\n-/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n-/* #undef NEED_REENTRANT */\n-\n-/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n-/* #undef NEED_THREAD_SAFE */\n-\n-/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n-/* #undef NO_MINUS_C_MINUS_O */\n-\n-/* cpu-machine-OS */\n-#define OS \"i386-apple-darwin9.8.0\"\n-\n-/* Name of package */\n-#define PACKAGE \"c-ares\"\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n-\n-/* Define to the full name of this package. */\n-#define PACKAGE_NAME \"c-ares\"\n-\n-/* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \"c-ares 1.7.1\"\n-\n-/* Define to the one symbol short name of this package. */\n-#define PACKAGE_TARNAME \"c-ares\"\n-\n-/* Define to the home page for this package. */\n-#define PACKAGE_URL \"\"\n-\n-/* Define to the version of this package. */\n-#define PACKAGE_VERSION \"1.7.1\"\n-\n-/* a suitable file/device to read random data from */\n-#define RANDOM_FILE \"/dev/urandom\"\n-\n-/* Define to the type of arg 1 for recvfrom. */\n-#define RECVFROM_TYPE_ARG1 int\n-\n-/* Define to the type pointed by arg 2 for recvfrom. */\n-#define RECVFROM_TYPE_ARG2 void\n-\n-/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n-#define RECVFROM_TYPE_ARG2_IS_VOID 1\n-\n-/* Define to the type of arg 3 for recvfrom. */\n-#define RECVFROM_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recvfrom. */\n-#define RECVFROM_TYPE_ARG4 int\n-\n-/* Define to the type pointed by arg 5 for recvfrom. */\n-#define RECVFROM_TYPE_ARG5 struct sockaddr\n-\n-/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n-\n-/* Define to the type pointed by arg 6 for recvfrom. */\n-#define RECVFROM_TYPE_ARG6 socklen_t\n-\n-/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n-\n-/* Define to the function return type for recvfrom. */\n-#define RECVFROM_TYPE_RETV ssize_t\n-\n-/* Define to the type of arg 1 for recv. */\n-#define RECV_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for recv. */\n-#define RECV_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for recv. */\n-#define RECV_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recv. */\n-#define RECV_TYPE_ARG4 int\n-\n-/* Define to the function return type for recv. */\n-#define RECV_TYPE_RETV ssize_t\n-\n-/* Define as the return type of signal handlers (`int' or `void'). */\n-#define RETSIGTYPE void\n-\n-/* Define to the type qualifier of arg 2 for send. */\n-#define SEND_QUAL_ARG2 const\n-\n-/* Define to the type of arg 1 for send. */\n-#define SEND_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for send. */\n-#define SEND_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for send. */\n-#define SEND_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for send. */\n-#define SEND_TYPE_ARG4 int\n-\n-/* Define to the function return type for send. */\n-#define SEND_TYPE_RETV ssize_t\n-\n-/* The size of `int', as computed by sizeof. */\n-#define SIZEOF_INT 4\n-\n-/* The size of `long', as computed by sizeof. */\n-#define SIZEOF_LONG 4\n-\n-/* The size of `size_t', as computed by sizeof. */\n-#define SIZEOF_SIZE_T 4\n-\n-/* The size of `struct in6_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN6_ADDR 16\n-\n-/* The size of `struct in_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN_ADDR 4\n-\n-/* The size of `time_t', as computed by sizeof. */\n-#define SIZEOF_TIME_T 4\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#define STDC_HEADERS 1\n-\n-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n-#define TIME_WITH_SYS_TIME 1\n-\n-/* Define to disable non-blocking sockets. */\n-/* #undef USE_BLOCKING_SOCKETS */\n-\n-/* Version number of package */\n-#define VERSION \"1.7.1\"\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-/* #  undef WORDS_BIGENDIAN */\n-# endif\n-#endif\n-\n-/* Define to 1 if OS is AIX. */\n-#ifndef _ALL_SOURCE\n-/* #  undef _ALL_SOURCE */\n-#endif\n-\n-/* Number of bits in a file offset, on hosts where this is settable. */\n-/* #undef _FILE_OFFSET_BITS */\n-\n-/* Define for large files, on AIX-style hosts. */\n-/* #undef _LARGE_FILES */\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-/* #undef const */\n-\n-/* Type to use in place of in_addr_t when system does not provide it. */\n-/* #undef in_addr_t */\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-/* #undef size_t */\n-\n-/* the signed version of size_t */\n-/* #undef ssize_t */\n-\n-#define HAVE_GETENV 1"}, {"sha": "2f9b75d02c254fdb43c1ebf77d405734b253b8d8", "filename": "src/rt/libuv/src/ares/config_freebsd/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_freebsd%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,512 +0,0 @@\n-/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n-/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-/* #undef AC_APPLE_UNIVERSAL_BUILD */\n-\n-/* define this if ares is built for a big endian system */\n-/* #undef ARES_BIG_ENDIAN */\n-\n-/* when building as static part of libcurl */\n-/* #undef BUILDING_LIBCURL */\n-\n-/* when building c-ares library */\n-/* #undef CARES_BUILDING_LIBRARY */\n-\n-/* when not building a shared library */\n-/* #undef CARES_STATICLIB */\n-\n-/* Define to 1 to enable hiding of library internal symbols. */\n-#define CARES_SYMBOL_HIDING 1\n-\n-/* Definition to make a library symbol externally visible. */\n-#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n-\n-/* if a /etc/inet dir is being used */\n-/* #undef ETC_INET */\n-\n-/* Define to the type qualifier of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_QUAL_ARG1 const\n-\n-/* Define to the type of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n-\n-/* Define to the type of arg 2 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG2 socklen_t\n-\n-/* Define to the type of args 4 and 6 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG46 size_t\n-\n-/* Define to the type of arg 7 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG7 int\n-\n-/* Specifies the number of arguments to getservbyport_r */\n-#define GETSERVBYPORT_R_ARGS 6\n-\n-/* Specifies the size of the buffer to pass to getservbyport_r */\n-#define GETSERVBYPORT_R_BUFSIZE 4096\n-\n-/* Define to 1 if you have AF_INET6. */\n-#define HAVE_AF_INET6 1\n-\n-/* Define to 1 if you have the <arpa/inet.h> header file. */\n-#define HAVE_ARPA_INET_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n-#define HAVE_ARPA_NAMESER_COMPAT_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser.h> header file. */\n-#define HAVE_ARPA_NAMESER_H 1\n-\n-/* Define to 1 if you have the <assert.h> header file. */\n-#define HAVE_ASSERT_H 1\n-\n-/* Define to 1 if you have the `bitncmp' function. */\n-/* #undef HAVE_BITNCMP */\n-\n-/* Define to 1 if bool is an available type. */\n-#define HAVE_BOOL_T 1\n-\n-/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n-#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n-\n-/* Define to 1 if you have the closesocket function. */\n-/* #undef HAVE_CLOSESOCKET */\n-\n-/* Define to 1 if you have the CloseSocket camel case function. */\n-/* #undef HAVE_CLOSESOCKET_CAMEL */\n-\n-/* Define to 1 if you have the connect function. */\n-#define HAVE_CONNECT 1\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#define HAVE_DLFCN_H 1\n-\n-/* Define to 1 if you have the <errno.h> header file. */\n-#define HAVE_ERRNO_H 1\n-\n-/* Define to 1 if you have the fcntl function. */\n-#define HAVE_FCNTL 1\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#define HAVE_FCNTL_H 1\n-\n-/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n-#define HAVE_FCNTL_O_NONBLOCK 1\n-\n-/* Define to 1 if you have the freeaddrinfo function. */\n-#define HAVE_FREEADDRINFO 1\n-\n-/* Define to 1 if you have a working getaddrinfo function. */\n-#define HAVE_GETADDRINFO 1\n-\n-/* Define to 1 if the getaddrinfo function is threadsafe. */\n-#define HAVE_GETADDRINFO_THREADSAFE 1\n-\n-/* Define to 1 if you have the gethostbyaddr function. */\n-#define HAVE_GETHOSTBYADDR 1\n-\n-/* Define to 1 if you have the gethostbyname function. */\n-#define HAVE_GETHOSTBYNAME 1\n-\n-/* Define to 1 if you have the gethostname function. */\n-#define HAVE_GETHOSTNAME 1\n-\n-/* Define to 1 if you have the getnameinfo function. */\n-#define HAVE_GETNAMEINFO 1\n-\n-/* Define to 1 if you have the getservbyport_r function. */\n-#define HAVE_GETSERVBYPORT_R 1\n-\n-/* Define to 1 if you have the `gettimeofday' function. */\n-#define HAVE_GETTIMEOFDAY 1\n-\n-/* Define to 1 if you have the `if_indextoname' function. */\n-#define HAVE_IF_INDEXTONAME 1\n-\n-/* Define to 1 if you have the `inet_net_pton' function. */\n-#define HAVE_INET_NET_PTON 1\n-\n-/* Define to 1 if inet_net_pton supports IPv6. */\n-/* #undef HAVE_INET_NET_PTON_IPV6 */\n-\n-/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n-#define HAVE_INET_NTOP 1\n-\n-/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n-#define HAVE_INET_PTON 1\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#define HAVE_INTTYPES_H 1\n-\n-/* Define to 1 if you have the ioctl function. */\n-#define HAVE_IOCTL 1\n-\n-/* Define to 1 if you have the ioctlsocket function. */\n-/* #undef HAVE_IOCTLSOCKET */\n-\n-/* Define to 1 if you have the IoctlSocket camel case function. */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL */\n-\n-/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n-   */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n-/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctl FIONBIO function. */\n-#define HAVE_IOCTL_FIONBIO 1\n-\n-/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n-#define HAVE_IOCTL_SIOCGIFADDR 1\n-\n-/* Define to 1 if you have the `resolve' library (-lresolve). */\n-/* #undef HAVE_LIBRESOLVE */\n-\n-/* Define to 1 if you have the <limits.h> header file. */\n-#define HAVE_LIMITS_H 1\n-\n-/* if your compiler supports LL */\n-#define HAVE_LL 1\n-\n-/* Define to 1 if the compiler supports the 'long long' data type. */\n-#define HAVE_LONGLONG 1\n-\n-/* Define to 1 if you have the malloc.h header file. */\n-/* #undef HAVE_MALLOC_H */\n-\n-/* Define to 1 if you have the memory.h header file. */\n-#define HAVE_MEMORY_H 1\n-\n-/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n-#define HAVE_MSG_NOSIGNAL 1\n-\n-/* Define to 1 if you have the <netdb.h> header file. */\n-#define HAVE_NETDB_H 1\n-\n-/* Define to 1 if you have the <netinet/in.h> header file. */\n-#define HAVE_NETINET_IN_H 1\n-\n-/* Define to 1 if you have the <netinet/tcp.h> header file. */\n-#define HAVE_NETINET_TCP_H 1\n-\n-/* Define to 1 if you have the <net/if.h> header file. */\n-#define HAVE_NET_IF_H 1\n-\n-/* Define to 1 if you have PF_INET6. */\n-#define HAVE_PF_INET6 1\n-\n-/* Define to 1 if you have the recv function. */\n-#define HAVE_RECV 1\n-\n-/* Define to 1 if you have the recvfrom function. */\n-#define HAVE_RECVFROM 1\n-\n-/* Define to 1 if you have the send function. */\n-#define HAVE_SEND 1\n-\n-/* Define to 1 if you have the setsockopt function. */\n-#define HAVE_SETSOCKOPT 1\n-\n-/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n-/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#define HAVE_SIGNAL_H 1\n-\n-/* Define to 1 if sig_atomic_t is an available typedef. */\n-#define HAVE_SIG_ATOMIC_T 1\n-\n-/* Define to 1 if sig_atomic_t is already defined as volatile. */\n-/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n-\n-/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n-#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n-\n-/* Define to 1 if you have the socket function. */\n-#define HAVE_SOCKET 1\n-\n-/* Define to 1 if you have the <socket.h> header file. */\n-/* #undef HAVE_SOCKET_H */\n-\n-/* Define to 1 if you have the <stdbool.h> header file. */\n-#define HAVE_STDBOOL_H 1\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#define HAVE_STDINT_H 1\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#define HAVE_STDLIB_H 1\n-\n-/* Define to 1 if you have the strcasecmp function. */\n-#define HAVE_STRCASECMP 1\n-\n-/* Define to 1 if you have the strcmpi function. */\n-/* #undef HAVE_STRCMPI */\n-\n-/* Define to 1 if you have the strdup function. */\n-#define HAVE_STRDUP 1\n-\n-/* Define to 1 if you have the stricmp function. */\n-/* #undef HAVE_STRICMP */\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#define HAVE_STRINGS_H 1\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#define HAVE_STRING_H 1\n-\n-/* Define to 1 if you have the strncasecmp function. */\n-#define HAVE_STRNCASECMP 1\n-\n-/* Define to 1 if you have the strncmpi function. */\n-/* #undef HAVE_STRNCMPI */\n-\n-/* Define to 1 if you have the strnicmp function. */\n-/* #undef HAVE_STRNICMP */\n-\n-/* Define to 1 if you have the <stropts.h> header file. */\n-/* #undef HAVE_STROPTS_H */\n-\n-/* Define to 1 if you have struct addrinfo. */\n-#define HAVE_STRUCT_ADDRINFO 1\n-\n-/* Define to 1 if you have struct in6_addr. */\n-#define HAVE_STRUCT_IN6_ADDR 1\n-\n-/* Define to 1 if you have struct sockaddr_in6. */\n-#define HAVE_STRUCT_SOCKADDR_IN6 1\n-\n-/* if struct sockaddr_storage is defined */\n-#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n-\n-/* Define to 1 if you have the timeval struct. */\n-#define HAVE_STRUCT_TIMEVAL 1\n-\n-/* Define to 1 if you have the <sys/ioctl.h> header file. */\n-#define HAVE_SYS_IOCTL_H 1\n-\n-/* Define to 1 if you have the <sys/param.h> header file. */\n-#define HAVE_SYS_PARAM_H 1\n-\n-/* Define to 1 if you have the <sys/select.h> header file. */\n-#define HAVE_SYS_SELECT_H 1\n-\n-/* Define to 1 if you have the <sys/socket.h> header file. */\n-#define HAVE_SYS_SOCKET_H 1\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#define HAVE_SYS_STAT_H 1\n-\n-/* Define to 1 if you have the <sys/time.h> header file. */\n-#define HAVE_SYS_TIME_H 1\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#define HAVE_SYS_TYPES_H 1\n-\n-/* Define to 1 if you have the <sys/uio.h> header file. */\n-#define HAVE_SYS_UIO_H 1\n-\n-/* Define to 1 if you have the <time.h> header file. */\n-#define HAVE_TIME_H 1\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#define HAVE_UNISTD_H 1\n-\n-/* Define to 1 if you have the windows.h header file. */\n-/* #undef HAVE_WINDOWS_H */\n-\n-/* Define to 1 if you have the winsock2.h header file. */\n-/* #undef HAVE_WINSOCK2_H */\n-\n-/* Define to 1 if you have the winsock.h header file. */\n-/* #undef HAVE_WINSOCK_H */\n-\n-/* Define to 1 if you have the writev function. */\n-#define HAVE_WRITEV 1\n-\n-/* Define to 1 if you have the ws2tcpip.h header file. */\n-/* #undef HAVE_WS2TCPIP_H */\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#define LT_OBJDIR \".libs/\"\n-\n-/* Define to 1 if you are building a native Windows target. */\n-/* #undef NATIVE_WINDOWS */\n-\n-/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n-/* #undef NEED_MALLOC_H */\n-\n-/* Define to 1 if you need the memory.h header file even with stdlib.h */\n-/* #undef NEED_MEMORY_H */\n-\n-/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n-/* #undef NEED_REENTRANT */\n-\n-/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n-/* #undef NEED_THREAD_SAFE */\n-\n-/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n-/* #undef NO_MINUS_C_MINUS_O */\n-\n-/* cpu-machine-OS */\n-#define OS \"i386-portbld-freebsd8.0\"\n-\n-/* Name of package */\n-#define PACKAGE \"c-ares\"\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n-\n-/* Define to the full name of this package. */\n-#define PACKAGE_NAME \"c-ares\"\n-\n-/* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \"c-ares 1.7.1\"\n-\n-/* Define to the one symbol short name of this package. */\n-#define PACKAGE_TARNAME \"c-ares\"\n-\n-/* Define to the home page for this package. */\n-#define PACKAGE_URL \"\"\n-\n-/* Define to the version of this package. */\n-#define PACKAGE_VERSION \"1.7.1\"\n-\n-/* a suitable file/device to read random data from */\n-#define RANDOM_FILE \"/dev/urandom\"\n-\n-/* Define to the type of arg 1 for recvfrom. */\n-#define RECVFROM_TYPE_ARG1 int\n-\n-/* Define to the type pointed by arg 2 for recvfrom. */\n-#define RECVFROM_TYPE_ARG2 void\n-\n-/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n-#define RECVFROM_TYPE_ARG2_IS_VOID 1\n-\n-/* Define to the type of arg 3 for recvfrom. */\n-#define RECVFROM_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recvfrom. */\n-#define RECVFROM_TYPE_ARG4 int\n-\n-/* Define to the type pointed by arg 5 for recvfrom. */\n-#define RECVFROM_TYPE_ARG5 struct sockaddr\n-\n-/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n-\n-/* Define to the type pointed by arg 6 for recvfrom. */\n-#define RECVFROM_TYPE_ARG6 socklen_t\n-\n-/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n-\n-/* Define to the function return type for recvfrom. */\n-#define RECVFROM_TYPE_RETV int\n-\n-/* Define to the type of arg 1 for recv. */\n-#define RECV_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for recv. */\n-#define RECV_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for recv. */\n-#define RECV_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recv. */\n-#define RECV_TYPE_ARG4 int\n-\n-/* Define to the function return type for recv. */\n-#define RECV_TYPE_RETV int\n-\n-/* Define as the return type of signal handlers (`int' or `void'). */\n-#define RETSIGTYPE void\n-\n-/* Define to the type qualifier of arg 2 for send. */\n-#define SEND_QUAL_ARG2 const\n-\n-/* Define to the type of arg 1 for send. */\n-#define SEND_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for send. */\n-#define SEND_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for send. */\n-#define SEND_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for send. */\n-#define SEND_TYPE_ARG4 int\n-\n-/* Define to the function return type for send. */\n-#define SEND_TYPE_RETV int\n-\n-/* The size of `int', as computed by sizeof. */\n-#define SIZEOF_INT 4\n-\n-/* The size of `long', as computed by sizeof. */\n-#define SIZEOF_LONG 4\n-\n-/* The size of `size_t', as computed by sizeof. */\n-#define SIZEOF_SIZE_T 4\n-\n-/* The size of `struct in6_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN6_ADDR 16\n-\n-/* The size of `struct in_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN_ADDR 4\n-\n-/* The size of `time_t', as computed by sizeof. */\n-#define SIZEOF_TIME_T 4\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#define STDC_HEADERS 1\n-\n-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n-#define TIME_WITH_SYS_TIME 1\n-\n-/* Define to disable non-blocking sockets. */\n-/* #undef USE_BLOCKING_SOCKETS */\n-\n-/* Version number of package */\n-#define VERSION \"1.7.1\"\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-/* #  undef WORDS_BIGENDIAN */\n-# endif\n-#endif\n-\n-/* Define to 1 if OS is AIX. */\n-#ifndef _ALL_SOURCE\n-/* #  undef _ALL_SOURCE */\n-#endif\n-\n-/* Number of bits in a file offset, on hosts where this is settable. */\n-/* #undef _FILE_OFFSET_BITS */\n-\n-/* Define for large files, on AIX-style hosts. */\n-/* #undef _LARGE_FILES */\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-/* #undef const */\n-\n-/* Type to use in place of in_addr_t when system does not provide it. */\n-/* #undef in_addr_t */\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-/* #undef size_t */\n-\n-/* the signed version of size_t */\n-/* #undef ssize_t */\n-\n-#define HAVE_GETENV 1"}, {"sha": "8f8e3307434962c4f74238f34fb99176b07ff1fa", "filename": "src/rt/libuv/src/ares/config_linux/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_linux%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c", "patch": "@@ -1,512 +0,0 @@\n-/* ares_config.h.  Generated from ares_config.h.in by configure.  */\n-/* ares_config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define if building universal (internal helper macro) */\n-/* #undef AC_APPLE_UNIVERSAL_BUILD */\n-\n-/* define this if ares is built for a big endian system */\n-/* #undef ARES_BIG_ENDIAN */\n-\n-/* when building as static part of libcurl */\n-/* #undef BUILDING_LIBCURL */\n-\n-/* when building c-ares library */\n-/* #undef CARES_BUILDING_LIBRARY */\n-\n-/* when not building a shared library */\n-/* #undef CARES_STATICLIB */\n-\n-/* Define to 1 to enable hiding of library internal symbols. */\n-#define CARES_SYMBOL_HIDING 1\n-\n-/* Definition to make a library symbol externally visible. */\n-#define CARES_SYMBOL_SCOPE_EXTERN __attribute__ ((visibility (\"default\")))\n-\n-/* if a /etc/inet dir is being used */\n-/* #undef ETC_INET */\n-\n-/* Define to the type qualifier of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_QUAL_ARG1 const\n-\n-/* Define to the type of arg 1 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG1 struct sockaddr *\n-\n-/* Define to the type of arg 2 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG2 socklen_t\n-\n-/* Define to the type of args 4 and 6 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG46 size_t\n-\n-/* Define to the type of arg 7 for getnameinfo. */\n-#define GETNAMEINFO_TYPE_ARG7 unsigned int\n-\n-/* Specifies the number of arguments to getservbyport_r */\n-#define GETSERVBYPORT_R_ARGS 6\n-\n-/* Specifies the size of the buffer to pass to getservbyport_r */\n-#define GETSERVBYPORT_R_BUFSIZE 4096\n-\n-/* Define to 1 if you have AF_INET6. */\n-#define HAVE_AF_INET6 1\n-\n-/* Define to 1 if you have the <arpa/inet.h> header file. */\n-#define HAVE_ARPA_INET_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser_compat.h> header file. */\n-#define HAVE_ARPA_NAMESER_COMPAT_H 1\n-\n-/* Define to 1 if you have the <arpa/nameser.h> header file. */\n-#define HAVE_ARPA_NAMESER_H 1\n-\n-/* Define to 1 if you have the <assert.h> header file. */\n-#define HAVE_ASSERT_H 1\n-\n-/* Define to 1 if you have the `bitncmp' function. */\n-/* #undef HAVE_BITNCMP */\n-\n-/* Define to 1 if bool is an available type. */\n-#define HAVE_BOOL_T 1\n-\n-/* Define to 1 if you have the clock_gettime function and monotonic timer. */\n-#define HAVE_CLOCK_GETTIME_MONOTONIC 1\n-\n-/* Define to 1 if you have the closesocket function. */\n-/* #undef HAVE_CLOSESOCKET */\n-\n-/* Define to 1 if you have the CloseSocket camel case function. */\n-/* #undef HAVE_CLOSESOCKET_CAMEL */\n-\n-/* Define to 1 if you have the connect function. */\n-#define HAVE_CONNECT 1\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#define HAVE_DLFCN_H 1\n-\n-/* Define to 1 if you have the <errno.h> header file. */\n-#define HAVE_ERRNO_H 1\n-\n-/* Define to 1 if you have the fcntl function. */\n-#define HAVE_FCNTL 1\n-\n-/* Define to 1 if you have the <fcntl.h> header file. */\n-#define HAVE_FCNTL_H 1\n-\n-/* Define to 1 if you have a working fcntl O_NONBLOCK function. */\n-#define HAVE_FCNTL_O_NONBLOCK 1\n-\n-/* Define to 1 if you have the freeaddrinfo function. */\n-#define HAVE_FREEADDRINFO 1\n-\n-/* Define to 1 if you have a working getaddrinfo function. */\n-#define HAVE_GETADDRINFO 1\n-\n-/* Define to 1 if the getaddrinfo function is threadsafe. */\n-#define HAVE_GETADDRINFO_THREADSAFE 1\n-\n-/* Define to 1 if you have the gethostbyaddr function. */\n-#define HAVE_GETHOSTBYADDR 1\n-\n-/* Define to 1 if you have the gethostbyname function. */\n-#define HAVE_GETHOSTBYNAME 1\n-\n-/* Define to 1 if you have the gethostname function. */\n-#define HAVE_GETHOSTNAME 1\n-\n-/* Define to 1 if you have the getnameinfo function. */\n-#define HAVE_GETNAMEINFO 1\n-\n-/* Define to 1 if you have the getservbyport_r function. */\n-#define HAVE_GETSERVBYPORT_R 1\n-\n-/* Define to 1 if you have the `gettimeofday' function. */\n-#define HAVE_GETTIMEOFDAY 1\n-\n-/* Define to 1 if you have the `if_indextoname' function. */\n-#define HAVE_IF_INDEXTONAME 1\n-\n-/* Define to 1 if you have the `inet_net_pton' function. */\n-/* #undef HAVE_INET_NET_PTON */\n-\n-/* Define to 1 if inet_net_pton supports IPv6. */\n-/* #undef HAVE_INET_NET_PTON_IPV6 */\n-\n-/* Define to 1 if you have a IPv6 capable working inet_ntop function. */\n-#define HAVE_INET_NTOP 1\n-\n-/* Define to 1 if you have a IPv6 capable working inet_pton function. */\n-#define HAVE_INET_PTON 1\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#define HAVE_INTTYPES_H 1\n-\n-/* Define to 1 if you have the ioctl function. */\n-#define HAVE_IOCTL 1\n-\n-/* Define to 1 if you have the ioctlsocket function. */\n-/* #undef HAVE_IOCTLSOCKET */\n-\n-/* Define to 1 if you have the IoctlSocket camel case function. */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL */\n-\n-/* Define to 1 if you have a working IoctlSocket camel case FIONBIO function.\n-   */\n-/* #undef HAVE_IOCTLSOCKET_CAMEL_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctlsocket FIONBIO function. */\n-/* #undef HAVE_IOCTLSOCKET_FIONBIO */\n-\n-/* Define to 1 if you have a working ioctl FIONBIO function. */\n-#define HAVE_IOCTL_FIONBIO 1\n-\n-/* Define to 1 if you have a working ioctl SIOCGIFADDR function. */\n-#define HAVE_IOCTL_SIOCGIFADDR 1\n-\n-/* Define to 1 if you have the `resolve' library (-lresolve). */\n-/* #undef HAVE_LIBRESOLVE */\n-\n-/* Define to 1 if you have the <limits.h> header file. */\n-#define HAVE_LIMITS_H 1\n-\n-/* if your compiler supports LL */\n-#define HAVE_LL 1\n-\n-/* Define to 1 if the compiler supports the 'long long' data type. */\n-#define HAVE_LONGLONG 1\n-\n-/* Define to 1 if you have the malloc.h header file. */\n-#define HAVE_MALLOC_H 1\n-\n-/* Define to 1 if you have the memory.h header file. */\n-#define HAVE_MEMORY_H 1\n-\n-/* Define to 1 if you have the MSG_NOSIGNAL flag. */\n-#define HAVE_MSG_NOSIGNAL 1\n-\n-/* Define to 1 if you have the <netdb.h> header file. */\n-#define HAVE_NETDB_H 1\n-\n-/* Define to 1 if you have the <netinet/in.h> header file. */\n-#define HAVE_NETINET_IN_H 1\n-\n-/* Define to 1 if you have the <netinet/tcp.h> header file. */\n-#define HAVE_NETINET_TCP_H 1\n-\n-/* Define to 1 if you have the <net/if.h> header file. */\n-#define HAVE_NET_IF_H 1\n-\n-/* Define to 1 if you have PF_INET6. */\n-#define HAVE_PF_INET6 1\n-\n-/* Define to 1 if you have the recv function. */\n-#define HAVE_RECV 1\n-\n-/* Define to 1 if you have the recvfrom function. */\n-#define HAVE_RECVFROM 1\n-\n-/* Define to 1 if you have the send function. */\n-#define HAVE_SEND 1\n-\n-/* Define to 1 if you have the setsockopt function. */\n-#define HAVE_SETSOCKOPT 1\n-\n-/* Define to 1 if you have a working setsockopt SO_NONBLOCK function. */\n-/* #undef HAVE_SETSOCKOPT_SO_NONBLOCK */\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#define HAVE_SIGNAL_H 1\n-\n-/* Define to 1 if sig_atomic_t is an available typedef. */\n-#define HAVE_SIG_ATOMIC_T 1\n-\n-/* Define to 1 if sig_atomic_t is already defined as volatile. */\n-/* #undef HAVE_SIG_ATOMIC_T_VOLATILE */\n-\n-/* Define to 1 if your struct sockaddr_in6 has sin6_scope_id. */\n-#define HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID 1\n-\n-/* Define to 1 if you have the socket function. */\n-#define HAVE_SOCKET 1\n-\n-/* Define to 1 if you have the <socket.h> header file. */\n-/* #undef HAVE_SOCKET_H */\n-\n-/* Define to 1 if you have the <stdbool.h> header file. */\n-#define HAVE_STDBOOL_H 1\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#define HAVE_STDINT_H 1\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#define HAVE_STDLIB_H 1\n-\n-/* Define to 1 if you have the strcasecmp function. */\n-#define HAVE_STRCASECMP 1\n-\n-/* Define to 1 if you have the strcmpi function. */\n-/* #undef HAVE_STRCMPI */\n-\n-/* Define to 1 if you have the strdup function. */\n-#define HAVE_STRDUP 1\n-\n-/* Define to 1 if you have the stricmp function. */\n-/* #undef HAVE_STRICMP */\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#define HAVE_STRINGS_H 1\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#define HAVE_STRING_H 1\n-\n-/* Define to 1 if you have the strncasecmp function. */\n-#define HAVE_STRNCASECMP 1\n-\n-/* Define to 1 if you have the strncmpi function. */\n-/* #undef HAVE_STRNCMPI */\n-\n-/* Define to 1 if you have the strnicmp function. */\n-/* #undef HAVE_STRNICMP */\n-\n-/* Define to 1 if you have the <stropts.h> header file. */\n-#define HAVE_STROPTS_H 1\n-\n-/* Define to 1 if you have struct addrinfo. */\n-#define HAVE_STRUCT_ADDRINFO 1\n-\n-/* Define to 1 if you have struct in6_addr. */\n-#define HAVE_STRUCT_IN6_ADDR 1\n-\n-/* Define to 1 if you have struct sockaddr_in6. */\n-#define HAVE_STRUCT_SOCKADDR_IN6 1\n-\n-/* if struct sockaddr_storage is defined */\n-#define HAVE_STRUCT_SOCKADDR_STORAGE 1\n-\n-/* Define to 1 if you have the timeval struct. */\n-#define HAVE_STRUCT_TIMEVAL 1\n-\n-/* Define to 1 if you have the <sys/ioctl.h> header file. */\n-#define HAVE_SYS_IOCTL_H 1\n-\n-/* Define to 1 if you have the <sys/param.h> header file. */\n-#define HAVE_SYS_PARAM_H 1\n-\n-/* Define to 1 if you have the <sys/select.h> header file. */\n-#define HAVE_SYS_SELECT_H 1\n-\n-/* Define to 1 if you have the <sys/socket.h> header file. */\n-#define HAVE_SYS_SOCKET_H 1\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#define HAVE_SYS_STAT_H 1\n-\n-/* Define to 1 if you have the <sys/time.h> header file. */\n-#define HAVE_SYS_TIME_H 1\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#define HAVE_SYS_TYPES_H 1\n-\n-/* Define to 1 if you have the <sys/uio.h> header file. */\n-#define HAVE_SYS_UIO_H 1\n-\n-/* Define to 1 if you have the <time.h> header file. */\n-#define HAVE_TIME_H 1\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#define HAVE_UNISTD_H 1\n-\n-/* Define to 1 if you have the windows.h header file. */\n-/* #undef HAVE_WINDOWS_H */\n-\n-/* Define to 1 if you have the winsock2.h header file. */\n-/* #undef HAVE_WINSOCK2_H */\n-\n-/* Define to 1 if you have the winsock.h header file. */\n-/* #undef HAVE_WINSOCK_H */\n-\n-/* Define to 1 if you have the writev function. */\n-#define HAVE_WRITEV 1\n-\n-/* Define to 1 if you have the ws2tcpip.h header file. */\n-/* #undef HAVE_WS2TCPIP_H */\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#define LT_OBJDIR \".libs/\"\n-\n-/* Define to 1 if you are building a native Windows target. */\n-/* #undef NATIVE_WINDOWS */\n-\n-/* Define to 1 if you need the malloc.h header file even with stdlib.h */\n-/* #undef NEED_MALLOC_H */\n-\n-/* Define to 1 if you need the memory.h header file even with stdlib.h */\n-/* #undef NEED_MEMORY_H */\n-\n-/* Define to 1 if _REENTRANT preprocessor symbol must be defined. */\n-/* #undef NEED_REENTRANT */\n-\n-/* Define to 1 if _THREAD_SAFE preprocessor symbol must be defined. */\n-/* #undef NEED_THREAD_SAFE */\n-\n-/* Define to 1 if your C compiler doesn't accept -c and -o together. */\n-/* #undef NO_MINUS_C_MINUS_O */\n-\n-/* cpu-machine-OS */\n-#define OS \"i686-pc-linux-gnu\"\n-\n-/* Name of package */\n-#define PACKAGE \"c-ares\"\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#define PACKAGE_BUGREPORT \"c-ares mailing list => http://cool.haxx.se/mailman/listinfo/c-ares\"\n-\n-/* Define to the full name of this package. */\n-#define PACKAGE_NAME \"c-ares\"\n-\n-/* Define to the full name and version of this package. */\n-#define PACKAGE_STRING \"c-ares 1.7.1\"\n-\n-/* Define to the one symbol short name of this package. */\n-#define PACKAGE_TARNAME \"c-ares\"\n-\n-/* Define to the home page for this package. */\n-#define PACKAGE_URL \"\"\n-\n-/* Define to the version of this package. */\n-#define PACKAGE_VERSION \"1.7.1\"\n-\n-/* a suitable file/device to read random data from */\n-#define RANDOM_FILE \"/dev/urandom\"\n-\n-/* Define to the type of arg 1 for recvfrom. */\n-#define RECVFROM_TYPE_ARG1 int\n-\n-/* Define to the type pointed by arg 2 for recvfrom. */\n-#define RECVFROM_TYPE_ARG2 void\n-\n-/* Define to 1 if the type pointed by arg 2 for recvfrom is void. */\n-#define RECVFROM_TYPE_ARG2_IS_VOID 1\n-\n-/* Define to the type of arg 3 for recvfrom. */\n-#define RECVFROM_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recvfrom. */\n-#define RECVFROM_TYPE_ARG4 int\n-\n-/* Define to the type pointed by arg 5 for recvfrom. */\n-#define RECVFROM_TYPE_ARG5 struct sockaddr\n-\n-/* Define to 1 if the type pointed by arg 5 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG5_IS_VOID */\n-\n-/* Define to the type pointed by arg 6 for recvfrom. */\n-#define RECVFROM_TYPE_ARG6 socklen_t\n-\n-/* Define to 1 if the type pointed by arg 6 for recvfrom is void. */\n-/* #undef RECVFROM_TYPE_ARG6_IS_VOID */\n-\n-/* Define to the function return type for recvfrom. */\n-#define RECVFROM_TYPE_RETV int\n-\n-/* Define to the type of arg 1 for recv. */\n-#define RECV_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for recv. */\n-#define RECV_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for recv. */\n-#define RECV_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for recv. */\n-#define RECV_TYPE_ARG4 int\n-\n-/* Define to the function return type for recv. */\n-#define RECV_TYPE_RETV int\n-\n-/* Define as the return type of signal handlers (`int' or `void'). */\n-#define RETSIGTYPE void\n-\n-/* Define to the type qualifier of arg 2 for send. */\n-#define SEND_QUAL_ARG2 const\n-\n-/* Define to the type of arg 1 for send. */\n-#define SEND_TYPE_ARG1 int\n-\n-/* Define to the type of arg 2 for send. */\n-#define SEND_TYPE_ARG2 void *\n-\n-/* Define to the type of arg 3 for send. */\n-#define SEND_TYPE_ARG3 size_t\n-\n-/* Define to the type of arg 4 for send. */\n-#define SEND_TYPE_ARG4 int\n-\n-/* Define to the function return type for send. */\n-#define SEND_TYPE_RETV int\n-\n-/* The size of `int', as computed by sizeof. */\n-#define SIZEOF_INT 4\n-\n-/* The size of `long', as computed by sizeof. */\n-#define SIZEOF_LONG 4\n-\n-/* The size of `size_t', as computed by sizeof. */\n-#define SIZEOF_SIZE_T 4\n-\n-/* The size of `struct in6_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN6_ADDR 16\n-\n-/* The size of `struct in_addr', as computed by sizeof. */\n-#define SIZEOF_STRUCT_IN_ADDR 4\n-\n-/* The size of `time_t', as computed by sizeof. */\n-#define SIZEOF_TIME_T 4\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#define STDC_HEADERS 1\n-\n-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n-#define TIME_WITH_SYS_TIME 1\n-\n-/* Define to disable non-blocking sockets. */\n-/* #undef USE_BLOCKING_SOCKETS */\n-\n-/* Version number of package */\n-#define VERSION \"1.7.1\"\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-/* #  undef WORDS_BIGENDIAN */\n-# endif\n-#endif\n-\n-/* Define to 1 if OS is AIX. */\n-#ifndef _ALL_SOURCE\n-/* #  undef _ALL_SOURCE */\n-#endif\n-\n-/* Number of bits in a file offset, on hosts where this is settable. */\n-#define _FILE_OFFSET_BITS 64\n-\n-/* Define for large files, on AIX-style hosts. */\n-/* #undef _LARGE_FILES */\n-\n-/* Define to empty if `const' does not conform to ANSI C. */\n-/* #undef const */\n-\n-/* Type to use in place of in_addr_t when system does not provide it. */\n-/* #undef in_addr_t */\n-\n-/* Define to `unsigned int' if <sys/types.h> does not define. */\n-/* #undef size_t */\n-\n-/* the signed version of size_t */\n-/* #undef ssize_t */\n-\n-#define HAVE_GETENV 1"}, {"sha": "b5891486553d7bf79c9f6b92179debe5cec8c995", "filename": "src/rt/libuv/src/ares/config_netbsd/ares_config.h", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_netbsd%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "b5891486553d7bf79c9f6b92179debe5cec8c995", "filename": "src/rt/libuv/src/ares/config_openbsd/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_openbsd%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "fb8565e15b61a73c7dbad487106750bed113597c", "filename": "src/rt/libuv/src/ares/config_sunos/ares_config.h", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_sunos%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6ded638093f8f71ad5f262c889fc7b7f2872bd66", "filename": "src/rt/libuv/src/ares/config_win32/ares_config.h", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fconfig_win32%2Fares_config.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a63c729a9dc5c920f129fc61b3f81e30356e6d14", "filename": "src/rt/libuv/src/ares/get_ver.awk", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fget_ver.awk?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "45bb5d48fd1bf5b82088e3e266874fe4b403fe43", "filename": "src/rt/libuv/src/ares/inet_net_pton.c", "status": "removed", "additions": 0, "deletions": 451, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5396a7f2a71001f6e4ca626d7eb9de0057ff4c3a", "filename": "src/rt/libuv/src/ares/inet_net_pton.h", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_net_pton.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "57e1146b76c1df3ec000bc0f7ea51b12b3552e65", "filename": "src/rt/libuv/src/ares/inet_ntop.c", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c583488f75e736f78cca93c8e13539de2a60e4a0", "filename": "src/rt/libuv/src/ares/inet_ntop.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Finet_ntop.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "45f1e3eb80ade024134ab2be854a1bac2a48da06", "filename": "src/rt/libuv/src/ares/nameser.h", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fnameser.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a333f54a7c0798eeb4215c6cc35fce9e99840c0a", "filename": "src/rt/libuv/src/ares/setup_once.h", "status": "removed", "additions": 0, "deletions": 504, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fsetup_once.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "03acd1c1e2b701af6bb0a118f7785a8a39fd7356", "filename": "src/rt/libuv/src/ares/windows_port.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fares%2Fwindows_port.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "85cabac46ea626dabd4a6fa0097c981e0b3db0eb", "filename": "src/rt/libuv/src/unix/cares.c", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcares.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "19d5b91501869c51cc61b287dd43b51b5e138359", "filename": "src/rt/libuv/src/unix/core.c", "status": "removed", "additions": 0, "deletions": 816, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcore.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "024e7d5bf9bcac6a07e2b6c5d98f05881d58d6d7", "filename": "src/rt/libuv/src/unix/cygwin.c", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fcygwin.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "675e0ad488a45bfb579362cfcecd148f9138abbb", "filename": "src/rt/libuv/src/unix/darwin.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdarwin.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6c4ddff89e6aaef0d1b7f0eace3cab3b4eb47f78", "filename": "src/rt/libuv/src/unix/dl.c", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fdl.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9d3e3231c12c0f0d2bbcb4ae3bc93aa47164beba", "filename": "src/rt/libuv/src/unix/eio/Changes", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FChanges?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "1ed1324d304ebd61920cd1f89df05486f3dd49e1", "filename": "src/rt/libuv/src/unix/eio/LICENSE", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FLICENSE?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e9866c0d5e7c33d45c3239a916aaff1df1f80e48", "filename": "src/rt/libuv/src/unix/eio/Makefile.am", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2FMakefile.am?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/unix/eio/aclocal.m4", "status": "removed", "additions": 0, "deletions": 8957, "changes": 8957, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Faclocal.m4?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "8056ee7f9be66c09300ec241e922550f7aab9d34", "filename": "src/rt/libuv/src/unix/eio/autogen.sh", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fautogen.sh?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "73e9dd07d280fe6d849e6e886690354b892d9b5e", "filename": "src/rt/libuv/src/unix/eio/config.h.in", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig.h.in?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f64e7fe441a165f4019ea39277f0c6a818232b70", "filename": "src/rt/libuv/src/unix/eio/config_cygwin.h", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_cygwin.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f406759e09e47afddb1a085dd84831636c5367b4", "filename": "src/rt/libuv/src/unix/eio/config_darwin.h", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_darwin.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "3c93d260f7991925d93cd5f3f88475d8f27b0eec", "filename": "src/rt/libuv/src/unix/eio/config_freebsd.h", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_freebsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "606301faf2ac629fcb6b5ec2a8451913d4f51102", "filename": "src/rt/libuv/src/unix/eio/config_linux.h", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_linux.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "31f18e604656c50da7f64dad88bf944fc8e5db3a", "filename": "src/rt/libuv/src/unix/eio/config_netbsd.h", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_netbsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a73b8a8830739736b32677b10a55b8424fa07802", "filename": "src/rt/libuv/src/unix/eio/config_openbsd.h", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_openbsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "546926fcb50065f7d8b6cd9ec034b782e3105f64", "filename": "src/rt/libuv/src/unix/eio/config_sunos.h", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfig_sunos.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9faffad538b29341e4b7ed294b4bd72d9b5f4ebf", "filename": "src/rt/libuv/src/unix/eio/configure.ac", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fconfigure.ac?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "cbef59557fe0282dabc3df7bb42163f2ea8acac3", "filename": "src/rt/libuv/src/unix/eio/demo.c", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fdemo.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a4aabc109163a51709820509bd42c0c53c55bc8e", "filename": "src/rt/libuv/src/unix/eio/ecb.h", "status": "removed", "additions": 0, "deletions": 370, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fecb.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ec5bde33e1aec5e90582e23519fcc81a75517f8b", "filename": "src/rt/libuv/src/unix/eio/eio.3", "status": "removed", "additions": 0, "deletions": 3428, "changes": 3428, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.3?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2374006110d8d7be4eed7e7a7f02683845df6f28", "filename": "src/rt/libuv/src/unix/eio/eio.c", "status": "removed", "additions": 0, "deletions": 2594, "changes": 2594, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "da5f33c01da39d6d4f9fa543ae9cfd3a10f486cf", "filename": "src/rt/libuv/src/unix/eio/eio.pod", "status": "removed", "additions": 0, "deletions": 969, "changes": 969, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Feio.pod?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "59151f5348a6f181b8330be0083f3ea728db2449", "filename": "src/rt/libuv/src/unix/eio/libeio.m4", "status": "removed", "additions": 0, "deletions": 195, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Flibeio.m4?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "7184c7bb73fb8f0b4c6835abfd26e4d0e59e93c1", "filename": "src/rt/libuv/src/unix/eio/xthread.h", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Feio%2Fxthread.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ac8bdd72cc8c20e7b722c60dca7f477027790aa6", "filename": "src/rt/libuv/src/unix/error.c", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ferror.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "d6fca2f67cde91d0c45c9d2e4fbf450d7fb95c6c", "filename": "src/rt/libuv/src/unix/ev/Changes", "status": "removed", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FChanges?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "7fa0e9f844f0bcc1f34a48c63b2388b02ac5d9e6", "filename": "src/rt/libuv/src/unix/ev/LICENSE", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FLICENSE?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "058c2cb0c1efc542c9539bcde4499524d6eaa102", "filename": "src/rt/libuv/src/unix/ev/Makefile.am", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.am?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9817a7ebd7f4331b09a5fff5dc5b40dd35c1d778", "filename": "src/rt/libuv/src/unix/ev/Makefile.in", "status": "removed", "additions": 0, "deletions": 771, "changes": 771, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FMakefile.in?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ca403c6f470494320d5de96f75f16f99946c68ac", "filename": "src/rt/libuv/src/unix/ev/README", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2FREADME?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "18abb73686c0dfdbc293e38d58bb25852c698ee1", "filename": "src/rt/libuv/src/unix/ev/aclocal.m4", "status": "removed", "additions": 0, "deletions": 8957, "changes": 8957, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Faclocal.m4?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "087d2aa4e963b767adc7a08d828852875e436686", "filename": "src/rt/libuv/src/unix/ev/autogen.sh", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fautogen.sh?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f32079abda668e5fc8f8de6f226e7b26384e8a03", "filename": "src/rt/libuv/src/unix/ev/config.guess", "status": "removed", "additions": 0, "deletions": 1526, "changes": 1526, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.guess?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "75da15cce7e7552e5770d1a1ca44f42762c9587b", "filename": "src/rt/libuv/src/unix/ev/config.h.in", "status": "removed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.h.in?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6759825a5b7fcf64476b4398dc0e30b3090b925c", "filename": "src/rt/libuv/src/unix/ev/config.sub", "status": "removed", "additions": 0, "deletions": 1658, "changes": 1658, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig.sub?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "1f6f6d98c815e28d66bcbb23c8a3188ff7f3a2b3", "filename": "src/rt/libuv/src/unix/ev/config_cygwin.h", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_cygwin.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "03e3b219ec98ecf939dd47d8bdeb990cab564314", "filename": "src/rt/libuv/src/unix/ev/config_darwin.h", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_darwin.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ebebd4156d2e036e1e101e7868b5caac1344f86b", "filename": "src/rt/libuv/src/unix/ev/config_freebsd.h", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_freebsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a13b179f280506224da315742e1d32f8ac421327", "filename": "src/rt/libuv/src/unix/ev/config_linux.h", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_linux.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ebebd4156d2e036e1e101e7868b5caac1344f86b", "filename": "src/rt/libuv/src/unix/ev/config_netbsd.h", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_netbsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "8bc9b89041f5a9c7650ff646695411a08744921b", "filename": "src/rt/libuv/src/unix/ev/config_openbsd.h", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_openbsd.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9f8861d8a369219be47c314e18d738005e2049f4", "filename": "src/rt/libuv/src/unix/ev/config_sunos.h", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfig_sunos.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "98f102f1e42ed1f005a751278302ff5ea66e95d9", "filename": "src/rt/libuv/src/unix/ev/configure", "status": "removed", "additions": 0, "deletions": 13037, "changes": 13037, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "03a784f2eba9bcc262637747cc3984b3d4eb2c8f", "filename": "src/rt/libuv/src/unix/ev/configure.ac", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fconfigure.ac?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "df8eea7e4ce8862105fcd7929b20bdb45488048b", "filename": "src/rt/libuv/src/unix/ev/depcomp", "status": "removed", "additions": 0, "deletions": 630, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fdepcomp?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ce42b5f2de0ef0241d258db609f26eab72f4b2eb", "filename": "src/rt/libuv/src/unix/ev/ev++.h", "status": "removed", "additions": 0, "deletions": 816, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev%2B%2B.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f2a4514582eb89bd724adb6e3dae9e0d49006f44", "filename": "src/rt/libuv/src/unix/ev/ev.3", "status": "removed", "additions": 0, "deletions": 5311, "changes": 5311, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.3?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a3bec43fbec9c815ba17f627a84d586802021516", "filename": "src/rt/libuv/src/unix/ev/ev.c", "status": "removed", "additions": 0, "deletions": 3914, "changes": 3914, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "4bbef1fcf25b3deb62c8a31bb4fddd2b844c598b", "filename": "src/rt/libuv/src/unix/ev/ev.pod", "status": "removed", "additions": 0, "deletions": 5243, "changes": 5243, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev.pod?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e8101e562f1f7e00dbf0b040373ed2d0a942bf4d", "filename": "src/rt/libuv/src/unix/ev/ev_epoll.c", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_epoll.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "212ca29ae643e7843c36d1b643771d29d3791a55", "filename": "src/rt/libuv/src/unix/ev/ev_kqueue.c", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_kqueue.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e53ae0de93c6055e2346e1a5d02afab295ea3e20", "filename": "src/rt/libuv/src/unix/ev/ev_poll.c", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_poll.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0ffebc372672866e3bfde9abe18cbf717b32a24f", "filename": "src/rt/libuv/src/unix/ev/ev_port.c", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_port.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0ea9467e4015a5df7fcf1de9536f8f8d803cdaf6", "filename": "src/rt/libuv/src/unix/ev/ev_select.c", "status": "removed", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_select.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5ee3ed1b2a0eb2368cce927ba8af84bf37d8898f", "filename": "src/rt/libuv/src/unix/ev/ev_vars.h", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_vars.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "338886efe407cfba00e33a1e425cc90d4d760a0c", "filename": "src/rt/libuv/src/unix/ev/ev_win32.c", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_win32.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2c195c5db4b2f8e65de6e55603b9752f3729b24b", "filename": "src/rt/libuv/src/unix/ev/ev_wrap.h", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fev_wrap.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "aaf6d534ca45f8c2c7041e3329bbda88a1d08ad6", "filename": "src/rt/libuv/src/unix/ev/event.c", "status": "removed", "additions": 0, "deletions": 402, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "10ff05a3cb4d64a397bb3aada943f2836858161a", "filename": "src/rt/libuv/src/unix/ev/event.h", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fevent.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6ce63b9f76bc6ab5ff08f967f52f8cf4c53a1353", "filename": "src/rt/libuv/src/unix/ev/install-sh", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Finstall-sh?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e3f4c81b236d53a9f0ea2aa965a4264b2958bfcd", "filename": "src/rt/libuv/src/unix/ev/libev.m4", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Flibev.m4?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "d88da2c264c8c312b286a83ae06d688d5287361a", "filename": "src/rt/libuv/src/unix/ev/ltmain.sh", "status": "removed", "additions": 0, "deletions": 8413, "changes": 8413, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fltmain.sh?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "fc54c64ec969d9c1630335d8a88c5d72d3ca0856", "filename": "src/rt/libuv/src/unix/ev/missing", "status": "removed", "additions": 0, "deletions": 336, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmissing?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "d2d5f21b611235316317197d3a32c2dff5897a6f", "filename": "src/rt/libuv/src/unix/ev/mkinstalldirs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fev%2Fmkinstalldirs?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "cd14d22669fcb69aee1ce4d657a7daa5db350131", "filename": "src/rt/libuv/src/unix/freebsd.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffreebsd.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "57664c83c024aa88898876c2342de8233941e5cf", "filename": "src/rt/libuv/src/unix/fs.c", "status": "removed", "additions": 0, "deletions": 703, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ffs.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0ab8ba9579f1e55c300e0abed4f075bbdbe6cd0e", "filename": "src/rt/libuv/src/unix/internal.h", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Finternal.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "00180cd41d36dd32225e30912fe565360aa7c7ff", "filename": "src/rt/libuv/src/unix/kqueue.c", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fkqueue.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f91839f7f920d205d42d39f26ff3560e240cd970", "filename": "src/rt/libuv/src/unix/linux.c", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Flinux.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "8b91f65c74ac5980bd7e609bc090fb8ff806ca9f", "filename": "src/rt/libuv/src/unix/netbsd.c", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fnetbsd.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "55f8ceb0ded227588a3f17ee74f25f788aafb35d", "filename": "src/rt/libuv/src/unix/openbsd.c", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fopenbsd.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "87959a6e5da957884a3602ecfaf1e688f3c646d6", "filename": "src/rt/libuv/src/unix/pipe.c", "status": "removed", "additions": 0, "deletions": 273, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fpipe.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "555be5a6e56f5b634e4282be730d4adecb58c229", "filename": "src/rt/libuv/src/unix/process.c", "status": "removed", "additions": 0, "deletions": 313, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fprocess.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "3cdeaa8cf7b22f46f9518a6721c9661e68971149", "filename": "src/rt/libuv/src/unix/stream.c", "status": "removed", "additions": 0, "deletions": 961, "changes": 961, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fstream.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f53122079865ea88e760ae69e80649097a026f53", "filename": "src/rt/libuv/src/unix/sunos.c", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fsunos.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ee94ab3ed84e8200209a67430f75e7f404cca8cf", "filename": "src/rt/libuv/src/unix/tcp.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftcp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "de77f5c46abb878f0b6146a4967d9c8fc3b3b9e6", "filename": "src/rt/libuv/src/unix/tty.c", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Ftty.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "15cd609bbecea145c22039bead4b661116a32453", "filename": "src/rt/libuv/src/unix/udp.c", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fudp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "84afe09b74776491305ed98ff531c6c9730c105c", "filename": "src/rt/libuv/src/unix/uv-eio.c", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "711d0cf281c166b157d703fbbcbcd109e0a0b82e", "filename": "src/rt/libuv/src/unix/uv-eio.h", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Funix%2Fuv-eio.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "599d6257890e3644a18c712ffd3368654ce22db3", "filename": "src/rt/libuv/src/uv-common.c", "status": "removed", "additions": 0, "deletions": 291, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "eecb1304386ec7e677a3c742bfe7e0c8a8832d06", "filename": "src/rt/libuv/src/uv-common.h", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fuv-common.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ee5faea272c662efc8adcb21ea515937777f5ef3", "filename": "src/rt/libuv/src/win/async.c", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fasync.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f146c31a56adf6871bb1ff22f64336ba3d98a2d2", "filename": "src/rt/libuv/src/win/cares.c", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcares.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "4914fb4190de1adc19d895d7e452774e2de9178c", "filename": "src/rt/libuv/src/win/core.c", "status": "removed", "additions": 0, "deletions": 236, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fcore.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "37cdc131a1a9269689b981d6a17d305bdaca86d4", "filename": "src/rt/libuv/src/win/dl.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fdl.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "1317ce5b6cc7ca2eefff2efad51869bdccacbf9e", "filename": "src/rt/libuv/src/win/error.c", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ferror.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "b2f6583a408bc1186a0628efcdff6ee354debfd5", "filename": "src/rt/libuv/src/win/fs-event.c", "status": "removed", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs-event.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "09ff145ce27a913c838680a2702f37a4e6aec08c", "filename": "src/rt/libuv/src/win/fs.c", "status": "removed", "additions": 0, "deletions": 1519, "changes": 1519, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ffs.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f0d854216be6f67f025505addf824a22c2bf83f8", "filename": "src/rt/libuv/src/win/getaddrinfo.c", "status": "removed", "additions": 0, "deletions": 368, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fgetaddrinfo.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "b67139cbc6a561a0c2639b635538df036810ed50", "filename": "src/rt/libuv/src/win/handle.c", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fhandle.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "deb8972c5a870ca099b36ab8f5f6e1ed3f0f36df", "filename": "src/rt/libuv/src/win/internal.h", "status": "removed", "additions": 0, "deletions": 364, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Finternal.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c597cd99b12e9c718dcabada78148d09e93fbde3", "filename": "src/rt/libuv/src/win/loop-watcher.c", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Floop-watcher.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "bd187da5f5d9e241ed0f9bef6fa2b3305658d462", "filename": "src/rt/libuv/src/win/pipe.c", "status": "removed", "additions": 0, "deletions": 1564, "changes": 1564, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fpipe.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "fd8018febcb09d03d5734bbe0ce9bb1179fa6099", "filename": "src/rt/libuv/src/win/process.c", "status": "removed", "additions": 0, "deletions": 1133, "changes": 1133, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fprocess.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "dd2b38809e9e20d49ff92b25946850ae8b9c0238", "filename": "src/rt/libuv/src/win/req.c", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Freq.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c2354eecba023f09efb4d75f8f8ac14cf0627384", "filename": "src/rt/libuv/src/win/stream.c", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fstream.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f57c825d15ebb6836fa97e2700124cd2ae5d2c75", "filename": "src/rt/libuv/src/win/tcp.c", "status": "removed", "additions": 0, "deletions": 1144, "changes": 1144, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftcp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "4fb20d34bc46c7150a71466191988e0dd6bd97e5", "filename": "src/rt/libuv/src/win/threadpool.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreadpool.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "1fc6b73f8700dfe16deecfdd7a8c388185054f3c", "filename": "src/rt/libuv/src/win/threads.c", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fthreads.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "58f2eef05f0d7293ccf950e45246fab44c7b5922", "filename": "src/rt/libuv/src/win/timer.c", "status": "removed", "additions": 0, "deletions": 276, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftimer.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a72851276a6184b7af5d741a6b926bd476d19165", "filename": "src/rt/libuv/src/win/tty.c", "status": "removed", "additions": 0, "deletions": 1758, "changes": 1758, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Ftty.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "07082ddb5d421dcb844ae4185cbad066801879fc", "filename": "src/rt/libuv/src/win/udp.c", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fudp.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "3bc3e1dbd43ea3a8909e818ce54085c06ab79eec", "filename": "src/rt/libuv/src/win/util.c", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Futil.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "cc21361bc70cca68f420176011df6f648d3bb17b", "filename": "src/rt/libuv/src/win/winapi.c", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e0038f14aca5172473fe8e5b31a878586785a1eb", "filename": "src/rt/libuv/src/win/winapi.h", "status": "removed", "additions": 0, "deletions": 4366, "changes": 4366, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinapi.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5309f1eedb17a6359b46bef143df5c1af77e77a6", "filename": "src/rt/libuv/src/win/winsock.c", "status": "removed", "additions": 0, "deletions": 425, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "433ce47670127358bbf5fbfe23e364613ebb5925", "filename": "src/rt/libuv/src/win/winsock.h", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fsrc%2Fwin%2Fwinsock.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "bfd081deff54dd7c9c60e9177740a93a49ccff33", "filename": "src/rt/libuv/test/benchmark-ares.c", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ares.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "892c14d1e95815736aae8cb1478ac2f6e123da36", "filename": "src/rt/libuv/test/benchmark-getaddrinfo.c", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-getaddrinfo.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0a72fb9861534a17bee1cded87ecd04fcb44e791", "filename": "src/rt/libuv/test/benchmark-list.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-list.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c36215c1deb802d0bd8636c1a6a1809f37dc741f", "filename": "src/rt/libuv/test/benchmark-ping-pongs.c", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-ping-pongs.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "92a536db77f5b9c10923442006dd54aaec705e85", "filename": "src/rt/libuv/test/benchmark-pound.c", "status": "removed", "additions": 0, "deletions": 322, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pound.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "52f295727c446dc0dbc414d9e273bcc99fd5e22a", "filename": "src/rt/libuv/test/benchmark-pump.c", "status": "removed", "additions": 0, "deletions": 462, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-pump.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "d75cb8e0a409395688372cd7d4b5df4ab97f3c13", "filename": "src/rt/libuv/test/benchmark-sizes.c", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-sizes.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "d34f42b9feb3b01bf5c9693b8599ddfdd166a04a", "filename": "src/rt/libuv/test/benchmark-spawn.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-spawn.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "77bb0191b1e83030747b5bc5dbfbd63f2d832c25", "filename": "src/rt/libuv/test/benchmark-tcp-write-batch.c", "status": "removed", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-tcp-write-batch.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "24a9e1b920dc8824ecc0d517638a92db7e7a4479", "filename": "src/rt/libuv/test/benchmark-udp-packet-storm.c", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fbenchmark-udp-packet-storm.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "85a0efc26bfaba0a52e63ec56de549f558332356", "filename": "src/rt/libuv/test/blackhole-server.c", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fblackhole-server.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "086b52d1a363c1c2c098e04dbf56bf8adb433f1a", "filename": "src/rt/libuv/test/dns-server.c", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fdns-server.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "8b1754410cd160e3e125781bc80f41405c09d97c", "filename": "src/rt/libuv/test/echo-server.c", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Fecho-server.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/rt/libuv/test/fixtures/empty_file", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ffixtures%2Fempty_file?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "af11beb9b4c3ff410b5f2526bfd5743095e16df5", "filename": "src/rt/libuv/test/run-benchmarks.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-benchmarks.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "1d8b0bcf5062ebc7555029bf425529b7c81269bb", "filename": "src/rt/libuv/test/run-tests.c", "status": "removed", "additions": 0, "deletions": 296, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frun-tests.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6033d64294d482721c0e5e345ebe43d5abf3f258", "filename": "src/rt/libuv/test/runner-unix.c", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e21847f92c08658a9ff0fbd5a2b5b53272a33a39", "filename": "src/rt/libuv/test/runner-unix.h", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-unix.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "fc08839ee481e6293019ff4b711f3ce351d5e41c", "filename": "src/rt/libuv/test/runner-win.c", "status": "removed", "additions": 0, "deletions": 343, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-win.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "a2c8b6f3d97d34c491cdcedb64746e37332c995d", "filename": "src/rt/libuv/test/runner-win.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner-win.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "73a3864ee415364c9e60d5ecdb2ba077587e046f", "filename": "src/rt/libuv/test/runner.c", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "3b93ffe991ba8fe22da5287a76c4c8810e030dee", "filename": "src/rt/libuv/test/runner.h", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Frunner.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Frunner.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "e28b393bb727caf6f568b056f30d8e399565e626", "filename": "src/rt/libuv/test/task.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftask.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftask.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "3d8415183d1cd0bb9b3a34114327ae5d6850fff6", "filename": "src/rt/libuv/test/test-async.c", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-async.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "4af636488616def642c4fdf99be5858e2989dfc7", "filename": "src/rt/libuv/test/test-callback-stack.c", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-callback-stack.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2762aa285a9392885c28b724868d2f77b0538916", "filename": "src/rt/libuv/test/test-connection-fail.c", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-connection-fail.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "78531f68067cac74167afd9da5a122c55007f290", "filename": "src/rt/libuv/test/test-delayed-accept.c", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-delayed-accept.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "8d6f2355273baa691eabd728578c26ab79195916", "filename": "src/rt/libuv/test/test-error.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0008459eac715c0456673b77b70ee1ce65e1f2e6", "filename": "src/rt/libuv/test/test-fail-always.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fail-always.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c1f23fe996a959aca8cbd8bad26ea582a518865d", "filename": "src/rt/libuv/test/test-fs-event.c", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs-event.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "28b914a770ba9f4fccbad6c0b8b602c2998eb69f", "filename": "src/rt/libuv/test/test-fs.c", "status": "removed", "additions": 0, "deletions": 1478, "changes": 1478, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-fs.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9dd267691c056bb60a92f5f8200df2ba887e33f4", "filename": "src/rt/libuv/test/test-get-currentexe.c", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-currentexe.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "7465e18b91e9c740834c2a668b4e859d79736fa6", "filename": "src/rt/libuv/test/test-get-loadavg.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-loadavg.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "00281af632445727dd03ddcd18316d5df2c63879", "filename": "src/rt/libuv/test/test-get-memory.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-get-memory.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2a8c94e755283336e1903a5fd07d0ac3f2c0efc0", "filename": "src/rt/libuv/test/test-getaddrinfo.c", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-getaddrinfo.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "583622e72452c1d77a4cfb23cfbbf86ded26a772", "filename": "src/rt/libuv/test/test-gethostbyname.c", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-gethostbyname.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5dac88b73e4896135aea8ea7968f7f38ed34ca2e", "filename": "src/rt/libuv/test/test-getsockname.c", "status": "removed", "additions": 0, "deletions": 342, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-getsockname.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "566e0d2ee020cd290b65e4640f57dbadf9d81606", "filename": "src/rt/libuv/test/test-hrtime.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-hrtime.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "95ef3a94959e9578396df7153c08d1b5d9f7974c", "filename": "src/rt/libuv/test/test-idle.c", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-idle.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0908879510fa6619262225b84896d7f1ab533fec", "filename": "src/rt/libuv/test/test-ipc.c", "status": "removed", "additions": 0, "deletions": 278, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ipc.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9051fdb35ce6cc0b7a2b34437b1bd0ed58a63401", "filename": "src/rt/libuv/test/test-list.h", "status": "removed", "additions": 0, "deletions": 274, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-list.h?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9a76cc53fa6b198d29a0f5eb13c33010cf34f382", "filename": "src/rt/libuv/test/test-loop-handles.c", "status": "removed", "additions": 0, "deletions": 359, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-loop-handles.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0b5c887d69c5c67fb9a9784edc5ef871ed4abe92", "filename": "src/rt/libuv/test/test-multiple-listen.c", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-multiple-listen.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "4fb58ff94be9e039e902d2206d8f589b38f90d16", "filename": "src/rt/libuv/test/test-pass-always.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pass-always.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "b73b4ce4d8ede652edfc430e238bed81983fbbd0", "filename": "src/rt/libuv/test/test-ping-pong.c", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ping-pong.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "b84d20f1eaf4be694bc8bca54b6ed2a27e31ae45", "filename": "src/rt/libuv/test/test-pipe-bind-error.c", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-bind-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2faa446148eff32380a1a1b7819f543a7420edbd", "filename": "src/rt/libuv/test/test-pipe-connect-error.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-pipe-connect-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "0083335fd12c964ab01a6e1209bc7e77662df5eb", "filename": "src/rt/libuv/test/test-ref.c", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-ref.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9d4f2cce74d5aaa41cbcc81a0bbade1c123096d0", "filename": "src/rt/libuv/test/test-shutdown-eof.c", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-shutdown-eof.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "192644bad2618d6b798995dc34c0c396b3e240e3", "filename": "src/rt/libuv/test/test-spawn.c", "status": "removed", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-spawn.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "7c0a692bf9273b754b77101242f711cd75e0c2bc", "filename": "src/rt/libuv/test/test-stdio-over-pipes.c", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-stdio-over-pipes.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9512519ac0cd013d7696583ba37bae4994ca6bb9", "filename": "src/rt/libuv/test/test-tcp-bind-error.c", "status": "removed", "additions": 0, "deletions": 191, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5a8b76363a63ffcbc1d235e3b8099c9fa547caa3", "filename": "src/rt/libuv/test/test-tcp-bind6-error.c", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-bind6-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f5dd0a440582be4888c1f4254018174a6dfe1b34", "filename": "src/rt/libuv/test/test-tcp-close.c", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-close.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5cdacab6321e609856c7df62eeb63f4b49f2281f", "filename": "src/rt/libuv/test/test-tcp-connect-error.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "5c158ff87656983b7b89161087d7811dda36a6ca", "filename": "src/rt/libuv/test/test-tcp-connect6-error.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-connect6-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c441b563f4a44529a3da7c8598c14fa5e518d545", "filename": "src/rt/libuv/test/test-tcp-flags.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-flags.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "c5907676be90199c0b5e9bbd3df8e61e508f71a5", "filename": "src/rt/libuv/test/test-tcp-write-error.c", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-error.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9e7f553ad24ad7316ba37271db834786628ae920", "filename": "src/rt/libuv/test/test-tcp-write-to-half-open-connection.c", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-write-to-half-open-connection.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "f6b1dc6efa1934dfc143ed4200179cf6bbc621cd", "filename": "src/rt/libuv/test/test-tcp-writealot.c", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tcp-writealot.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "92130b506c55516ad8d49b898596b0e366f59186", "filename": "src/rt/libuv/test/test-threadpool.c", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-threadpool.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "9eeee1e34dca36ace803fb8f1a633a5af0681efa", "filename": "src/rt/libuv/test/test-timer-again.c", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer-again.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "87235a51bc744282123a1e0b1c3b2aa746b62379", "filename": "src/rt/libuv/test/test-timer.c", "status": "removed", "additions": 0, "deletions": 172, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-timer.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "60aedf39a940a3568eede455c7299139606a97c6", "filename": "src/rt/libuv/test/test-tty.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-tty.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "2d172c0640ce53a24b5b7486c94ce52cbf7f4ff3", "filename": "src/rt/libuv/test/test-udp-dgram-too-big.c", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-dgram-too-big.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "6ff36b32b017b9f5ffd5c2a7041318046e1e1254", "filename": "src/rt/libuv/test/test-udp-ipv6.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-ipv6.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "159dba0819661fd68cbeb0805912b517cc2adc25", "filename": "src/rt/libuv/test/test-udp-multicast-join.c", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-multicast-join.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "ab47e91c21c30461f650af46e723ba0da79b2dac", "filename": "src/rt/libuv/test/test-udp-send-and-recv.c", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Ftest%2Ftest-udp-send-and-recv.c?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "83129b5c956b21014e1663cafd2764ae6a0368ab", "filename": "src/rt/libuv/uv.gyp", "status": "removed", "additions": 0, "deletions": 397, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fuv.gyp", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fuv.gyp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fuv.gyp?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}, {"sha": "bccefff9dcdec915630c53f0499821a2d673bb0e", "filename": "src/rt/libuv/vcbuild.bat", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fvcbuild.bat", "raw_url": "https://github.com/rust-lang/rust/raw/4f3f04643f2ba6760e66e8efd54be07cb08a6b9c/src%2Frt%2Flibuv%2Fvcbuild.bat", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flibuv%2Fvcbuild.bat?ref=4f3f04643f2ba6760e66e8efd54be07cb08a6b9c"}]}