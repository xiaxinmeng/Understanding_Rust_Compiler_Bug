{"sha": "8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNmM4NzlkMmFmNjgzNGE0ZjdhOGI0MWFkMzM1ZTUyZmU3MTRlNmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T21:50:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-24T21:50:44Z"}, "message": "rollup merge of #23282: nikomatsakis/fn-trait-inheritance\n\nThe primary motivation here is to sidestep #19032 -- for a time, I thought that we should improve coherence or otherwise extend the language, but I now think that any such changes will require more time to bake. In the meantime, inheritance amongst the fn traits is both logically correct *and* a simple solution to that obstacle. This change introduces inheritance and modifies the compiler so that it can properly generate impls for closures and fns.\n\nThings enabled by this PR (but not included in this PR):\n\n1. An impl of `FnMut` for `&mut F` where `F : FnMut` (https://github.com/rust-lang/rust/issues/23015).\n2. A better version of `Thunk` I've been calling `FnBox`.\n\nI did not include either of these in the PR because:\n\n1. Adding the impls in 1 currently induces a coherence conflict with the pattern trait. This is interesting and merits some discussion.\n2. `FnBox` deserves to be a PR of its own.\n\nThe main downside to this design is (a) the need to write impls by hand; (b) the possibility of implementing `FnMut` with different semantics from `Fn`, etc. Point (a) is minor -- in particular, it does not affect normal closure usage -- and could be addressed in the future in many ways (better defaults; convenient macros; specialization; etc). Point (b) is unfortunate but \"just a bug\" from my POV, and certainly not unique to these traits (c.f. Copy/Clone, PartialEq/Eq, etc). (Until we lift the feature-gate on implementing the Fn traits, in any case, there is room to correct both of these if we find a nice way.)\n\nNote that I believe this change is reversible in the future if we decide on another course of action, due to the feature gate on implementing the `Fn` traits, though I do not (currently) think we should reverse it.\n\nFixes #18835.\n\nr? @nrc", "tree": {"sha": "eb514877eac12c4a528ac58fda4a744d33ab2dc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb514877eac12c4a528ac58fda4a744d33ab2dc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "html_url": "https://github.com/rust-lang/rust/commit/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed810385045ab0db90303574ba3ea47dfa2a36d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed810385045ab0db90303574ba3ea47dfa2a36d5", "html_url": "https://github.com/rust-lang/rust/commit/ed810385045ab0db90303574ba3ea47dfa2a36d5"}, {"sha": "9330bae4bde720dbdf8d379bd5529a1bb7a6f1e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9330bae4bde720dbdf8d379bd5529a1bb7a6f1e9", "html_url": "https://github.com/rust-lang/rust/commit/9330bae4bde720dbdf8d379bd5529a1bb7a6f1e9"}], "stats": {"total": 972, "additions": 711, "deletions": 261}, "files": [{"sha": "234cd6e0fd21ec23994810de197661005891dc0a", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -43,15 +43,21 @@ struct Counter<'a, 'b> {\n }\n \n impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n-    type Output = bool;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n         assert_eq!(x, self.expected[*self.i]);\n         *self.i += 1;\n         true\n     }\n }\n \n+impl<'a, 'b, 'c> FnOnce<(&'c i32,)> for Counter<'a, 'b> {\n+    type Output = bool;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (&'c i32,)) -> bool {\n+        self.call_mut(args)\n+    }\n+}\n+\n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n     // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n     F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,"}, {"sha": "fee40115f39525bcca9651cce1cfc47cb3cc3ae6", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -1148,6 +1148,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait Fn<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1156,10 +1157,21 @@ pub trait Fn<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> : FnMut<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait FnMut<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1168,6 +1180,16 @@ pub trait FnMut<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1180,6 +1202,7 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A> FnMut<A> for F\n     where F : Fn<A>\n {\n@@ -1190,6 +1213,7 @@ impl<F: ?Sized, A> FnMut<A> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A> FnOnce<A> for F\n     where F : FnMut<A>\n {"}, {"sha": "7197649a0ea45a334a290b517170d9ff0bd4ce4c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -29,7 +29,7 @@ use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut};\n+use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n@@ -541,6 +541,7 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -550,6 +551,32 @@ impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnMut<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&*self, (ptr,))\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&self, (ptr,))\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n struct CharSplits<'a, P: Pattern<'a>> {\n     /// The slice remaining to be iterated"}, {"sha": "2232bb7bcdbf3698510c56e4f40808c205664dc0", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -789,10 +789,13 @@ fn confirm_callable_candidate<'cx,'tcx>(\n            obligation.repr(tcx),\n            fn_sig.repr(tcx));\n \n+    // the `Output` associated type is declared on `FnOnce`\n+    let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n+\n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n         util::closure_trait_ref_and_return_type(tcx,\n-                                                obligation.predicate.trait_ref.def_id,\n+                                                fn_once_def_id,\n                                                 obligation.predicate.trait_ref.self_ty(),\n                                                 fn_sig,\n                                                 flag);"}, {"sha": "0d6a1f7df5e564cd8d26bf8d7beebec1ba9f4201", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -1069,7 +1069,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                if closure_kind == kind {\n+                if closure_kind.extends(kind) {\n                     candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n                 }\n             }\n@@ -1088,10 +1088,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n-        // We provide a `Fn` impl for fn pointers. There is no need to provide\n-        // the other traits (e.g. `FnMut`) since those are provided by blanket\n-        // impls.\n-        if Some(obligation.predicate.def_id()) != self.tcx().lang_items.fn_trait() {\n+        // We provide impl of all fn traits for fn pointers.\n+        if self.tcx().lang_items.fn_trait_kind(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n "}, {"sha": "5e3f430615ac8c15f4ea843dff6dfb80b00b6441", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -2462,8 +2462,11 @@ pub struct ItemSubsts<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n+    // Warning: Ordering is significant here! The ordering is chosen\n+    // because the trait Fn is a subtrait of FnMut and so in turn, and\n+    // hence we order it so that Fn < FnMut < FnOnce.\n     FnClosureKind,\n     FnMutClosureKind,\n     FnOnceClosureKind,\n@@ -2485,6 +2488,20 @@ impl ClosureKind {\n             Err(err) => cx.sess.fatal(&err[..]),\n         }\n     }\n+\n+    /// True if this a type that impls this closure kind\n+    /// must also implement `other`.\n+    pub fn extends(self, other: ty::ClosureKind) -> bool {\n+        match (self, other) {\n+            (FnClosureKind, FnClosureKind) => true,\n+            (FnClosureKind, FnMutClosureKind) => true,\n+            (FnClosureKind, FnOnceClosureKind) => true,\n+            (FnMutClosureKind, FnMutClosureKind) => true,\n+            (FnMutClosureKind, FnOnceClosureKind) => true,\n+            (FnOnceClosureKind, FnOnceClosureKind) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub trait ClosureTyper<'tcx> {"}, {"sha": "e7911d5cc197006942987d85575ad302488b5037", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -264,24 +264,36 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// but for the bare function type given.\n pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_kind: ty::ClosureKind,\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n {\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n+    // Normalize the type for better caching.\n     let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n-    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n+\n+    // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n+    let is_by_ref = match closure_kind {\n+        ty::FnClosureKind | ty::FnMutClosureKind => true,\n+        ty::FnOnceClosureKind => false,\n+    };\n+    let bare_fn_ty_maybe_ref = if is_by_ref {\n+        ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty)\n+    } else {\n+        bare_fn_ty\n+    };\n+\n+    // Check if we already trans'd this shim.\n+    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n         Some(&llval) => { return llval; }\n         None => { }\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n            bare_fn_ty.repr(tcx));\n \n-    // This is an impl of `Fn` trait, so receiver is `&self`.\n-    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty);\n-\n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n     let (opt_def_id, sig) =\n@@ -306,7 +318,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          unsafety: ast::Unsafety::Normal,\n                                          abi: synabi::RustCall,\n                                          sig: ty::Binder(ty::FnSig {\n-                                             inputs: vec![bare_fn_ty_ref,\n+                                             inputs: vec![bare_fn_ty_maybe_ref,\n                                                           tuple_input_ty],\n                                              output: sig.output,\n                                              variadic: false\n@@ -337,8 +349,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n-    let llfnpointer =\n-        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n+    let llfnpointer = if is_by_ref {\n+        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32))\n+    } else {\n+        get_param(fcx.llfn, fcx.arg_pos(0) as u32)\n+    };\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n@@ -361,7 +376,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n-    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n+    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n     llfn\n }"}, {"sha": "5a48b8e4bce1d37acb4ae77844ff80a2e674c864", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 193, "deletions": 11, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -8,24 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n+use arena::TypedArena;\n+use back::link::{self, mangle_internal_name_by_path_and_seq};\n+use llvm::{ValueRef, get_param};\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n-use trans::cleanup::{CleanupMethods, ScopeId};\n+use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n+use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, rvalue_scratch_datum};\n-use trans::datum::{Rvalue, ByValue};\n-use trans::debuginfo;\n+use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n use middle::ty::{self, ClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n+use util::ppaux::Repr;\n \n+use syntax::abi::RustCall;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -239,11 +242,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(bcx,\n-                                                   &*repr,\n-                                                   dest_addr,\n-                                                   0,\n-                                                   i);\n+        let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -259,3 +258,186 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     Some(bcx)\n }\n+\n+pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                      closure_def_id: ast::DefId,\n+                                      substs: Substs<'tcx>,\n+                                      node: ExprOrMethodCall,\n+                                      param_substs: &'tcx Substs<'tcx>,\n+                                      trait_closure_kind: ty::ClosureKind)\n+                                      -> ValueRef\n+{\n+    // The substitutions should have no type parameters remaining\n+    // after passing through fulfill_obligation\n+    let llfn = callee::trans_fn_ref_with_substs(ccx,\n+                                                closure_def_id,\n+                                                node,\n+                                                param_substs,\n+                                                substs.clone()).val;\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n+    trans_closure_adapter_shim(ccx,\n+                               closure_def_id,\n+                               substs,\n+                               closure_kind,\n+                               trait_closure_kind,\n+                               llfn)\n+}\n+\n+fn trans_closure_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llfn_closure_kind: ty::ClosureKind,\n+    trait_closure_kind: ty::ClosureKind,\n+    llfn: ValueRef)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, \\\n+           llfn={})\",\n+           llfn_closure_kind,\n+           trait_closure_kind,\n+           ccx.tn().val_to_string(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::FnClosureKind, ty::FnClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnMutClosureKind) |\n+        (ty::FnOnceClosureKind, ty::FnOnceClosureKind) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnMutClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnOnceClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnOnceClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n+        }\n+        _ => {\n+            tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                                  llfn_closure_kind,\n+                                  trait_closure_kind));\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n+           closure_def_id.repr(ccx.tcx()),\n+           substs.repr(ccx.tcx()),\n+           ccx.tn().val_to_string(llreffn));\n+\n+    let tcx = ccx.tcx();\n+    let typer = NormalizingClosureTyper::new(tcx);\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let substs = tcx.mk_substs(substs);\n+    let closure_ty = ty::mk_closure(tcx, closure_def_id, substs);\n+    let ref_closure_ty = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                               abi: abi,\n+                                                               sig: sig.clone() });\n+    let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n+           llref_fn_ty.repr(tcx));\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+    let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                                abi: abi,\n+                                                                sig: sig });\n+    let llonce_fn_ty = ty::mk_bare_fn(tcx, None, llonce_bare_fn_ty);\n+\n+    // Create the by-value helper.\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n+    let lloncefn = decl_internal_rust_fn(ccx, llonce_fn_ty, &function_name);\n+\n+    let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      lloncefn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      substs,\n+                      None,\n+                      &block_arena);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    let self_scope_id = CustomScope(self_scope);\n+    let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n+    let llself = get_param(lloncefn, fcx.arg_pos(0) as u32);\n+    let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n+    let env_datum = unpack_datum!(bcx,\n+                                  env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n+                                                                     self_scope_id));\n+\n+    debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n+           bcx.val_to_string(env_datum.val));\n+\n+    // the remaining arguments will be packed up in a tuple.\n+    let input_tys = match sig.inputs[1].sty {\n+        ty::ty_tup(ref tys) => &**tys,\n+        _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n+                                      closure_def_id={}\",\n+                                     closure_def_id.repr(tcx)))\n+    };\n+    let llargs: Vec<_> =\n+        input_tys.iter()\n+                 .enumerate()\n+                 .map(|(i, _)| get_param(lloncefn, fcx.arg_pos(i+1) as u32))\n+                 .collect();\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n+\n+    let callee_data = TraitItem(MethodData { llfn: llreffn,\n+                                             llself: env_datum.val });\n+\n+    bcx = callee::trans_call_inner(bcx,\n+                                   DebugLoc::None,\n+                                   llref_fn_ty,\n+                                   |bcx, _| Callee { bcx: bcx, data: callee_data },\n+                                   ArgVals(&llargs),\n+                                   dest).bcx;\n+\n+    fcx.pop_custom_cleanup_scope(self_scope);\n+\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+\n+    lloncefn\n+}"}, {"sha": "aa038f8ddca3148d51e15f047d2daeab516ab4f4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -17,11 +17,13 @@ use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n+use middle::ty::ClosureTyper;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::*;\n use trans::callee;\n use trans::cleanup;\n+use trans::closure;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n@@ -358,19 +360,21 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                closure_def_id,\n-                                                MethodCallKey(method_call),\n-                                                bcx.fcx.param_substs,\n-                                                substs).val;\n-\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = closure::trans_closure_method(bcx.ccx(),\n+                                                     closure_def_id,\n+                                                     substs,\n+                                                     MethodCallKey(method_call),\n+                                                     bcx.fcx.param_substs,\n+                                                     trait_closure_kind);\n             Callee {\n                 bcx: bcx,\n                 data: Fn(llfn),\n             }\n         }\n         traits::VtableFnPointer(fn_ty) => {\n-            let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n@@ -645,9 +649,6 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let sig =\n-        ty::erase_late_bound_regions(bcx.tcx(), &fty.sig);\n-\n     let dest =\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n@@ -714,17 +715,18 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n             traits::VtableClosure(closure_def_id, substs) => {\n-                let llfn = trans_fn_ref_with_substs(\n-                    ccx,\n-                    closure_def_id,\n-                    ExprId(0),\n-                    param_substs,\n-                    substs).val;\n-\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                let llfn = closure::trans_closure_method(ccx,\n+                                                         closure_def_id,\n+                                                         substs,\n+                                                         ExprId(0),\n+                                                         param_substs,\n+                                                         trait_closure_kind);\n                 vec![llfn].into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n-                vec![trans_fn_pointer_shim(ccx, bare_fn_ty)].into_iter()\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n             }\n             traits::VtableObject(ref data) => {\n                 // this would imply that the Self type being erased is"}, {"sha": "e9de8bd879e202342cbe00df6e0d61ec3adf812c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 133, "deletions": 110, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -55,7 +55,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n@@ -608,24 +608,16 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    let mut projections = Vec::new();\n-\n-    // The trait reference introduces a binding level here, so\n-    // we need to shift the `rscope`. It'd be nice if we could\n-    // do away with this rscope stuff and work this knowledge\n-    // into resolve_lifetimes, as we do with non-omitted\n-    // lifetimes. Oh well, not there yet.\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n-                                          &ast_trait_ref.trait_ref,\n-                                          None, self_ty, Some(&mut projections));\n-\n-    for projection in projections {\n-        poly_projections.push(ty::Binder(projection));\n-    }\n-\n-    ty::Binder(trait_ref)\n+    let trait_ref = &ast_trait_ref.trait_ref;\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap(),\n+                               poly_projections)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n@@ -634,31 +626,27 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_trait_ref<'tcx>(\n+pub fn instantiate_mono_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     trait_ref: &ast::TraitRef,\n-    impl_id: Option<ast::NodeId>,\n-    self_ty: Option<Ty<'tcx>>,\n-    projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    self_ty: Option<Ty<'tcx>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_mono_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap())\n+}\n+\n+fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n-        def::DefTrait(trait_def_id) => {\n-            let trait_ref = ast_path_to_trait_ref(this,\n-                                                  rscope,\n-                                                  path.span,\n-                                                  PathParamMode::Explicit,\n-                                                  trait_def_id,\n-                                                  self_ty,\n-                                                  path.segments.last().unwrap(),\n-                                                  projections);\n-            if let Some(id) = impl_id {\n-                this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n-            }\n-            trait_ref\n-        }\n+        def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path.user_string(this.tcx()));\n@@ -676,35 +664,96 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    // we are introducing a binder here, so shift the\n-    // anonymous regions depth to account for that\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let mut tmp = Vec::new();\n-    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n-                                                     &shifted_rscope,\n-                                                     span,\n-                                                     param_mode,\n-                                                     trait_def_id,\n-                                                     None,\n-                                                     trait_segment,\n-                                                     Some(&mut tmp)));\n-    projections.extend(tmp.into_iter().map(ty::Binder));\n-    trait_ref\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               span,\n+                               param_mode,\n+                               trait_def_id,\n+                               None,\n+                               trait_segment,\n+                               projections)\n }\n \n-fn ast_path_to_trait_ref<'a,'tcx>(\n+fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     trait_segment: &ast::PathSegment,\n-    mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n+    poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n+{\n+    // The trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = &ShiftedRscope::new(rscope);\n+\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        shifted_rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    let poly_trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_def_id, substs)));\n+\n+    {\n+        let converted_bindings =\n+            assoc_bindings\n+            .iter()\n+            .filter_map(|binding| {\n+                // specify type to assert that error was already reported in Err case:\n+                let predicate: Result<_, ErrorReported> =\n+                    ast_type_binding_to_poly_projection_predicate(this,\n+                                                                  poly_trait_ref.clone(),\n+                                                                  self_ty,\n+                                                                  binding);\n+                predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+            });\n+        poly_projections.extend(converted_bindings);\n+    }\n+\n+    poly_trait_ref\n+}\n+\n+fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                       rscope: &RegionScope,\n+                                       span: Span,\n+                                       param_mode: PathParamMode,\n+                                       trait_def_id: ast::DefId,\n+                                       self_ty: Option<Ty<'tcx>>,\n+                                       trait_segment: &ast::PathSegment)\n+                                       -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    prohibit_projections(this.tcx(), &assoc_bindings);\n+    Rc::new(ty::TraitRef::new(trait_def_id, substs))\n+}\n+\n+fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                            rscope: &RegionScope,\n+                                            span: Span,\n+                                            param_mode: PathParamMode,\n+                                            trait_def_id: ast::DefId,\n+                                            self_ty: Option<Ty<'tcx>>,\n+                                            trait_segment: &ast::PathSegment)\n+                                            -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+{\n+    debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n+           trait_segment);\n+\n     let trait_def = match this.get_trait_def(span, trait_def_id) {\n         Ok(trait_def) => trait_def,\n         Err(ErrorReported) => {\n@@ -752,34 +801,16 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                                             self_ty,\n                                             types,\n                                             regions);\n-    let substs = this.tcx().mk_substs(substs);\n \n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n-\n-    match projections {\n-        None => {\n-            prohibit_projections(this.tcx(), &assoc_bindings);\n-        }\n-        Some(ref mut v) => {\n-            for binding in &assoc_bindings {\n-                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n-                                                               self_ty, binding) {\n-                    Ok(pp) => { v.push(pp); }\n-                    Err(ErrorReported) => { }\n-                }\n-            }\n-        }\n-    }\n-\n-    trait_ref\n+    (this.tcx().mk_substs(substs), assoc_bindings)\n }\n \n-fn ast_type_binding_to_projection_predicate<'tcx>(\n+fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     this: &AstConv<'tcx>,\n-    mut trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    mut trait_ref: ty::PolyTraitRef<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n-    -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n+    -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n {\n     let tcx = this.tcx();\n \n@@ -800,14 +831,14 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n     // Simple case: X is defined in the current trait.\n-    if this.trait_defines_associated_type_named(trait_ref.def_id, binding.item_name) {\n-        return Ok(ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref,\n+    if this.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n+        return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n+            projection_ty: ty::ProjectionTy {               //                     |\n+                trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n                 item_name: binding.item_name,\n             },\n             ty: binding.ty,\n-        });\n+        }));\n     }\n \n     // Otherwise, we have to walk through the supertraits to find\n@@ -820,17 +851,17 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n \n     let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n     if self_ty.is_none() { // if converting for an object type\n-        let mut dummy_substs = trait_ref.substs.clone();\n-        assert!(dummy_substs.self_ty().is_none());\n-        dummy_substs.types.push(SelfSpace, dummy_self_ty);\n-        trait_ref = Rc::new(ty::TraitRef::new(trait_ref.def_id,\n-                                              tcx.mk_substs(dummy_substs)));\n+        let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n+        assert!(dummy_substs.self_ty().is_none());                     //                    |\n+        dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n+        trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_ref.def_id(), // <------------+\n+                                                         tcx.mk_substs(dummy_substs))));\n     }\n \n-    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id));\n+    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n \n     let mut candidates: Vec<ty::PolyTraitRef> =\n-        traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n+        traits::supertraits(tcx, trait_ref.clone())\n         .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n         .collect();\n \n@@ -865,21 +896,13 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n         }\n     };\n \n-    if ty::binds_late_bound_regions(tcx, &candidate) {\n-        span_err!(tcx.sess, binding.span, E0219,\n-            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n-                    token::get_name(binding.item_name),\n-                    candidate.user_string(tcx));\n-        return Err(ErrorReported);\n-    }\n-\n-    Ok(ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            trait_ref: candidate.0,\n+    Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n+        projection_ty: ty::ProjectionTy {               //                           |\n+            trait_ref: candidate.skip_binder().clone(), // binder is moved up here --+\n             item_name: binding.item_name,\n         },\n         ty: binding.ty,\n-    })\n+    }))\n }\n \n fn ast_path_to_ty<'tcx>(\n@@ -1134,14 +1157,14 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref = ast_path_to_trait_ref(this,\n-                                          rscope,\n-                                          span,\n-                                          param_mode,\n-                                          trait_def_id,\n-                                          Some(self_ty),\n-                                          trait_segment,\n-                                          None);\n+    let trait_ref =\n+        ast_path_to_mono_trait_ref(this,\n+                                   rscope,\n+                                   span,\n+                                   param_mode,\n+                                   trait_def_id,\n+                                   Some(self_ty),\n+                                   trait_segment);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n "}, {"sha": "d2a06fcf9909138d1a1b354350c9dc1ea903b5ce", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -16,6 +16,7 @@ use astconv;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n+use std::cmp;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n@@ -109,15 +110,11 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n         ty::ty_trait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n-            let expectations =\n-                proj_bounds.iter()\n-                           .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n-                           .next();\n-\n-            match expectations {\n-                Some((sig, kind)) => (Some(sig), Some(kind)),\n-                None => (None, None)\n-            }\n+            let sig = proj_bounds.iter()\n+                                 .filter_map(|pb| deduce_sig_from_projection(fcx, pb))\n+                                 .next();\n+            let kind = fcx.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n+            (sig, kind)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n@@ -136,7 +133,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n     let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n-    let expected_sig_and_kind =\n+    let expected_sig =\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n@@ -150,7 +147,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::Projection(ref proj_predicate) => {\n                     let trait_ref = proj_predicate.to_poly_trait_ref();\n                     self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n-                        .and_then(|_| deduce_expectations_from_projection(fcx, proj_predicate))\n+                        .and_then(|_| deduce_sig_from_projection(fcx, proj_predicate))\n                 }\n                 _ => {\n                     None\n@@ -159,14 +156,10 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         })\n         .next();\n \n-    match expected_sig_and_kind {\n-        Some((sig, kind)) => { return (Some(sig), Some(kind)); }\n-        None => { }\n-    }\n-\n     // Even if we can't infer the full signature, we may be able to\n     // infer the kind. This can occur if there is a trait-reference\n-    // like `F : Fn<A>`.\n+    // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+    // many viable options, so pick the most restrictive.\n     let expected_kind =\n         fulfillment_cx\n         .pending_obligations()\n@@ -183,54 +176,61 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n                 .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n         })\n-        .next();\n+        .fold(None, pick_most_restrictive_closure_kind);\n+\n+    (expected_sig, expected_kind)\n+}\n \n-    (None, expected_kind)\n+fn pick_most_restrictive_closure_kind(best: Option<ty::ClosureKind>,\n+                                      cur: ty::ClosureKind)\n+                                      -> Option<ty::ClosureKind>\n+{\n+    match best {\n+        None => Some(cur),\n+        Some(best) => Some(cmp::min(best, cur))\n+    }\n }\n \n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n /// everything we need to know about a closure.\n-fn deduce_expectations_from_projection<'a,'tcx>(\n+fn deduce_sig_from_projection<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     projection: &ty::PolyProjectionPredicate<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+    -> Option<ty::FnSig<'tcx>>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_expectations_from_projection({})\",\n+    debug!(\"deduce_sig_from_projection({})\",\n            projection.repr(tcx));\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n-    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n-        Some(k) => k,\n-        None => { return None; }\n-    };\n-\n-    debug!(\"found object type {:?}\", kind);\n+    if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+        return None;\n+    }\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n         ty::ty_tup(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"input_tys {}\", input_tys.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr(tcx));\n \n-    return Some((fn_sig, kind));\n+    Some(fn_sig)\n }\n \n fn self_type_matches_expected_vid<'a,'tcx>("}, {"sha": "b95e0ce8cb3c59e512d65101884e5fbd1d9b1697", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -725,7 +725,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             };\n \n             // this closure doesn't implement the right kind of `Fn` trait\n-            if closure_kind != kind {\n+            if !closure_kind.extends(kind) {\n                 continue;\n             }\n "}, {"sha": "5816fe58bc9b1b25948ae56670bb2032fb94470e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -784,14 +784,15 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                    &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref = astconv::instantiate_trait_ref(&ccx.icx(&()),\n-                                                           &ExplicitRscope,\n-                                                           ast_trait_ref,\n-                                                           Some(it.id),\n-                                                           None,\n-                                                           None);\n+            let trait_ref =\n+                astconv::instantiate_mono_trait_ref(&ccx.icx(&()),\n+                                                    &ExplicitRscope,\n+                                                    ast_trait_ref,\n+                                                    None);\n \n             ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n+\n+            tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n@@ -890,13 +891,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n \n-            if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(&ccx.icx(&ty_predicates),\n-                                               &ExplicitRscope,\n-                                               trait_ref,\n-                                               Some(it.id),\n-                                               Some(selfty),\n-                                               None);\n+            if let Some(ref ast_trait_ref) = *opt_trait_ref {\n+                let trait_ref =\n+                    astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                        &ExplicitRscope,\n+                                                        ast_trait_ref,\n+                                                        Some(selfty));\n+\n+                tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n             }\n \n             enforce_impl_ty_params_are_constrained(tcx,"}, {"sha": "93c37524bf565294dd07c4fba3c4ec794c49bd7a", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -18,26 +18,36 @@ struct SFn {\n }\n \n impl Fn<(isize,)> for SFn {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call(&self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnMut<(isize,)> for SFn {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (isize,)) -> isize { self.call(args) }\n+}\n+\n+impl FnOnce<(isize,)> for SFn {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(self, args: (isize,)) -> isize { self.call(args) }\n+}\n+\n struct SFnMut {\n     x: isize,\n     y: isize,\n }\n \n impl FnMut<(isize,)> for SFnMut {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(isize,)> for SFnMut {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, args: (isize,)) -> isize { self.call_mut(args) }\n+}\n+\n struct SFnOnce {\n     x: String,\n }"}, {"sha": "27b4a04054f073f203503b5ef9a01298e864a622", "filename": "src/test/compile-fail/coerce-unsafe-to-closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -10,5 +10,6 @@\n \n fn main() {\n     let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n-    //~^ ERROR: is not implemented for the type\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }"}, {"sha": "d1abed9b2627c0a636bd9f1eb96ceb6ce7c3f008", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     let _x: extern \"C\" fn() = f; // OK\n     is_fn(f);\n     //~^ ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n-    //~| ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n+    //~| ERROR the trait `core::ops::FnOnce<()>` is not implemented for the type `extern \"C\" fn()\n }"}, {"sha": "d86c5d211dc5fa2e339d1fa06582655ee0b44d3f", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -18,28 +18,21 @@\n struct Foo;\n impl Fn<()> for Foo {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n-    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+    extern \"rust-call\" fn call(self, args: ()) -> () {}\n }\n struct Foo1;\n-impl Fn() for Foo1 {\n+impl FnOnce() for Foo1 {\n     //~^ ERROR associated type bindings are not allowed here\n-\n-    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+    extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n }\n struct Bar;\n impl FnMut<()> for Bar {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n }\n struct Baz;\n impl FnOnce<()> for Baz {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n }\n "}, {"sha": "6433255bd4d2fcb7e3dd05894e669f8a38b0b945", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -35,5 +35,5 @@ fn main() {\n \n     needs_fn(1);\n     //~^ ERROR `core::ops::Fn<(isize,)>`\n-    //~| ERROR `core::ops::Fn<(isize,)>`\n+    //~| ERROR `core::ops::FnOnce<(isize,)>`\n }"}, {"sha": "8e1e88a92e452c09d0200806c4bfe2cdc7386394", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -17,9 +17,13 @@ fn apply<T, F>(t: T, f: F) where F: FnOnce(T) {\n }\n \n fn main() {\n-    apply(&3, takes_mut); //~ ERROR (values differ in mutability)\n     apply(&3, takes_imm);\n+    apply(&3, takes_mut);\n+    //~^ ERROR (values differ in mutability)\n+    //~| ERROR (values differ in mutability)\n \n     apply(&mut 3, takes_mut);\n-    apply(&mut 3, takes_imm); //~ ERROR (values differ in mutability)\n+    apply(&mut 3, takes_imm);\n+    //~^ ERROR (values differ in mutability)\n+    //~| ERROR (values differ in mutability)\n }"}, {"sha": "3853434e128ebd0b9465747277150ddf0c9fc41b", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -16,11 +16,10 @@ struct Debuger<T> {\n     x: T\n }\n \n-impl<T: fmt::Debug> ops::Fn<(),> for Debuger<T> {\n+impl<T: fmt::Debug> ops::FnOnce<(),> for Debuger<T> {\n     type Output = ();\n-\n-    fn call(&self, _args: ()) {\n-//~^ ERROR `call` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n+    fn call_once(self, _args: ()) {\n+//~^ ERROR `call_once` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n         println!(\"{:?}\", self.x);\n     }\n }"}, {"sha": "fe427e02451af6a0587f2c7ae49cfc2f98dfa75e", "filename": "src/test/compile-fail/issue-20225.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -13,9 +13,19 @@\n struct Foo;\n \n impl<'a, T> Fn<(&'a T,)> for Foo {\n+  extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n+  //~^ ERROR: has an incompatible type for trait: expected &-ptr\n+}\n+\n+impl<'a, T> FnMut<(&'a T,)> for Foo {\n+  extern \"rust-call\" fn call_mut(&mut self, (_,): (T,)) {}\n+  //~^ ERROR: has an incompatible type for trait: expected &-ptr\n+}\n+\n+impl<'a, T> FnOnce<(&'a T,)> for Foo {\n   type Output = ();\n \n-  extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n+  extern \"rust-call\" fn call_once(self, (_,): (T,)) {}\n   //~^ ERROR: has an incompatible type for trait: expected &-ptr\n }\n "}, {"sha": "77ac97bc8b89951427bf7aaa9d69d0e45675f55a", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -18,13 +18,18 @@ struct S {\n }\n \n impl FnMut<(isize,)> for S {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(isize,)> for S {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, (z,): (isize,)) -> isize {\n+        self.call_mut((z,))\n+    }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 3,"}, {"sha": "ea47d676412098c04e54399afc0a05d7187a7be7", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -18,12 +18,16 @@ struct S {\n }\n \n impl FnMut<isize> for S {\n-    type Output = isize;\n     extern \"rust-call\" fn call_mut(&mut self, z: isize) -> isize {\n         self.x + self.y + z\n     }\n }\n \n+impl FnOnce<isize> for S {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, z: isize) -> isize { self.call_mut(z) }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 1,"}, {"sha": "93498ac7f83514c1768d1babc95dcd640c3435e2", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -19,19 +19,22 @@ use std::ops::{Fn,FnMut,FnOnce};\n struct S;\n \n impl FnMut<(isize,)> for S {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (isize,)) -> isize {\n         x * x\n     }\n }\n \n+impl FnOnce<(isize,)> for S {\n+    type Output = isize;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (isize,)) -> isize { self.call_mut(args) }\n+}\n+\n fn call_it<F:Fn(isize)->isize>(f: &F, x: isize) -> isize {\n     f.call((x,))\n }\n \n fn main() {\n     let x = call_it(&S, 22);\n     //~^ ERROR not implemented\n-    //~| ERROR not implemented\n }"}, {"sha": "2dcd7a97d8977eec83fc37a53c8dd016bc3b31fa", "filename": "src/test/compile-fail/unboxed-closures-recursive-fn-using-fn-mut.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -28,14 +28,19 @@ impl<F,A,R> YCombinator<F,A,R> {\n }\n \n impl<A,R,F : FnMut(&mut FnMut(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n-    type Output = R;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (arg,): (A,)) -> R {\n         (self.func)(self, arg)\n             //~^ ERROR cannot borrow `*self` as mutable more than once at a time\n     }\n }\n \n+impl<A,R,F : FnMut(&mut FnMut(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+    extern \"rust-call\" fn call_once(mut self, args: (A,)) -> R {\n+        self.call_mut(args)\n+    }\n+}\n+\n fn main() {\n     let mut counter = 0;\n     let factorial = |recur: &mut FnMut(u32) -> u32, arg: u32| -> u32 {"}, {"sha": "dc7c70ba649d8b0524766893a060679a1714c511", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -27,11 +27,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "cdcb435b65a6acfcc8cdc3700d420022234385bb", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -27,11 +27,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "150bf36dcc286db2befd582b8dd6fa055495e1b8", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -28,11 +28,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "11219b04f2b97003e55434f34b4f1312af2fe1c2", "filename": "src/test/run-pass/issue-13655.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13655.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -14,14 +14,27 @@ use std::ops::Fn;\n struct Foo<T>(T);\n \n impl<T: Copy> Fn<()> for Foo<T> {\n-    type Output = T;\n     extern \"rust-call\" fn call(&self, _: ()) -> T {\n       match *self {\n         Foo(t) => t\n       }\n     }\n }\n \n+impl<T: Copy> FnMut<()> for Foo<T> {\n+    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> T {\n+        self.call(())\n+    }\n+}\n+\n+impl<T: Copy> FnOnce<()> for Foo<T> {\n+    type Output = T;\n+\n+    extern \"rust-call\" fn call_once(self, _: ()) -> T {\n+        self.call(())\n+    }\n+}\n+\n fn main() {\n   let t: u8 = 1;\n   println!(\"{}\", Foo(t)());"}, {"sha": "ec482a776def32f4e3bf940b0a09272130179b91", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -17,10 +17,18 @@ trait Foo { fn dummy(&self) { }}\n struct Bar;\n \n impl<'a> std::ops::Fn<(&'a (Foo+'a),)> for Bar {\n-    type Output = ();\n     extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n \n+impl<'a> std::ops::FnMut<(&'a (Foo+'a),)> for Bar {\n+    extern \"rust-call\" fn call_mut(&mut self, a: (&'a Foo,)) { self.call(a) }\n+}\n+\n+impl<'a> std::ops::FnOnce<(&'a (Foo+'a),)> for Bar {\n+    type Output = ();\n+    extern \"rust-call\" fn call_once(self, a: (&'a Foo,)) { self.call(a) }\n+}\n+\n struct Baz;\n \n impl Foo for Baz {}"}, {"sha": "5accaf363490fae2b1e45692d78e2e9156ef7941", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -36,9 +36,21 @@ impl Alloy {\n }\n \n impl<'b> Fn<(&'b mut (Response+'b),)> for SendFile {\n+    extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n+}\n+\n+impl<'b> FnMut<(&'b mut (Response+'b),)> for SendFile {\n+    extern \"rust-call\" fn call_mut(&mut self, (_res,): (&'b mut (Response+'b),)) {\n+        self.call((_res,))\n+    }\n+}\n+\n+impl<'b> FnOnce<(&'b mut (Response+'b),)> for SendFile {\n     type Output = ();\n \n-    extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n+    extern \"rust-call\" fn call_once(self, (_res,): (&'b mut (Response+'b),)) {\n+        self.call((_res,))\n+    }\n }\n \n impl<Rq: Request, Rs: Response> Ingot<Rq, Rs> for HelloWorld {"}, {"sha": "99ddaba4e5514513291796aa2d90198757bf776d", "filename": "src/test/run-pass/issue-16739.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -20,20 +20,36 @@\n struct Foo { foo: u32 }\n \n impl FnMut<()> for Foo {\n-    type Output = u32;\n     extern \"rust-call\" fn call_mut(&mut self, _: ()) -> u32 { self.foo }\n }\n \n-impl FnMut<(u32,)> for Foo {\n+impl FnOnce<()> for Foo {\n     type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, _: ()) -> u32 { self.call_mut(()) }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////\n+\n+impl FnMut<(u32,)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (u32,)) -> u32 { self.foo + x }\n }\n \n-impl FnMut<(u32,u32)> for Foo {\n+impl FnOnce<(u32,)> for Foo {\n     type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, args: (u32,)) -> u32 { self.call_mut(args) }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////\n+\n+impl FnMut<(u32,u32)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x, y): (u32, u32)) -> u32 { self.foo + x + y }\n }\n \n+impl FnOnce<(u32,u32)> for Foo {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, args: (u32,u32)) -> u32 { self.call_mut(args) }\n+}\n+\n fn main() {\n     let mut f = box Foo { foo: 42 } as Box<FnMut() -> u32>;\n     assert_eq!(f.call_mut(()), 42);"}, {"sha": "9442b039bc6cbecd1bc3573123e38f156c09d2a0", "filename": "src/test/run-pass/issue-19982.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-19982.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Fissue-19982.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19982.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -16,9 +16,17 @@\n struct Foo;\n \n impl<'a> Fn<(&'a (),)> for Foo {\n+    extern \"rust-call\" fn call(&self, (_,): (&(),)) {}\n+}\n+\n+impl<'a> FnMut<(&'a (),)> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (_,): (&(),)) {}\n+}\n+\n+impl<'a> FnOnce<(&'a (),)> for Foo {\n     type Output = ();\n \n-    extern \"rust-call\" fn call(&self, (_,): (&(),)) {}\n+    extern \"rust-call\" fn call_once(self, (_,): (&(),)) {}\n }\n \n fn main() {}"}, {"sha": "597075c550051bc8664e3b0e63853468757f8932", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -21,13 +21,20 @@ use std::ops::Add;\n struct G<A>(PhantomData<A>);\n \n impl<'a, A: Add<i32, Output=i32>> Fn<(A,)> for G<A> {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> i32 {\n         arg.add(1)\n     }\n }\n \n+impl<'a, A: Add<i32, Output=i32>> FnMut<(A,)> for G<A> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (A,)) -> i32 { self.call(args) }\n+}\n+\n+impl<'a, A: Add<i32, Output=i32>> FnOnce<(A,)> for G<A> {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (A,)) -> i32 { self.call(args) }\n+}\n+\n fn main() {\n     // ICE trigger\n     (G(PhantomData))(1);"}, {"sha": "eeb705a2e3c99b5db12af2de0530c1a98b1c1399", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -20,24 +20,38 @@ struct S1 {\n }\n \n impl FnMut<(i32,)> for S1 {\n-    type Output = i32;\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(i32,)> for S1 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 {\n+        self.call_mut(args)\n+    }\n+}\n+\n struct S2 {\n     x: i32,\n     y: i32,\n }\n \n impl Fn<(i32,)> for S2 {\n-    type Output = i32;\n     extern \"rust-call\" fn call(&self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n+impl FnMut<(i32,)> for S2 {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n+impl FnOnce<(i32,)> for S2 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n struct S3 {\n     x: i32,\n     y: i32,"}, {"sha": "110109018db59d672476ca3f9e9deea720b69b59", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -20,12 +20,16 @@ struct S {\n }\n \n impl FnMut<()> for S {\n-    type Output = i32;\n     extern \"rust-call\" fn call_mut(&mut self, (): ()) -> i32 {\n         self.x * self.y\n     }\n }\n \n+impl FnOnce<()> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(mut self, args: ()) -> i32 { self.call_mut(args) }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 3,"}, {"sha": "9b71abf3653318c21fbc558cdb07822bba9845a5", "filename": "src/test/run-pass/unboxed-closures-fn-as-fnmut-and-fnonce.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -20,12 +20,20 @@ use std::ops::{Fn,FnMut,FnOnce};\n struct S;\n \n impl Fn<(i32,)> for S {\n-    type Output = i32;\n     extern \"rust-call\" fn call(&self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnMut<(i32,)> for S {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n fn call_it<F:Fn(i32)->i32>(f: &F, x: i32) -> i32 {\n     f(x)\n }"}, {"sha": "6261058b86742a2f9d4edc91597ab03ef65e2638", "filename": "src/test/run-pass/unboxed-closures-fnmut-as-fnonce.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -20,13 +20,17 @@ use std::ops::{FnMut,FnOnce};\n struct S;\n \n impl FnMut<(i32,)> for S {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 { self.call_mut(args) }\n+}\n+\n fn call_it_mut<F:FnMut(i32)->i32>(f: &mut F, x: i32) -> i32 {\n     f(x)\n }"}, {"sha": "e02784f917a97e71ca134242bfd9013ac55f188c", "filename": "src/test/run-pass/unboxed-closures-infer-recursive-fn.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -32,13 +32,20 @@ impl<F,A,R> YCombinator<F,A,R> {\n }\n \n impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> Fn<(A,)> for YCombinator<F,A,R> {\n-    type Output = R;\n-\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> R {\n         (self.func)(self, arg)\n     }\n }\n \n+impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (A,)) -> R { self.call(args) }\n+}\n+\n+impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+    extern \"rust-call\" fn call_once(self, args: (A,)) -> R { self.call(args) }\n+}\n+\n fn main() {\n     let factorial = |recur: &Fn(u32) -> u32, arg: u32| -> u32 {\n         if arg == 0 {1} else {arg * recur(arg-1)}"}, {"sha": "38f15d6e4499b30c7f970eb83ebb482bbf025b45", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6c879d2af6834a4f7a8b41ad335e52fe714e6d/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=8f6c879d2af6834a4f7a8b41ad335e52fe714e6d", "patch": "@@ -17,13 +17,17 @@ use std::ops::FnMut;\n struct S;\n \n impl FnMut<(i32,)> for S {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 { self.call_mut(args) }\n+}\n+\n fn call_it<F:FnMut(i32)->i32>(mut f: F, x: i32) -> i32 {\n     f(x) + 3\n }"}]}