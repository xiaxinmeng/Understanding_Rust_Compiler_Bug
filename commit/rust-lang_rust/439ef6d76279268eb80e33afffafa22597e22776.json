{"sha": "439ef6d76279268eb80e33afffafa22597e22776", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzOWVmNmQ3NjI3OTI2OGViODBlMzNhZmZmYWZhMjI1OTdlMjI3NzY=", "commit": {"author": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-07T17:44:32Z"}, "committer": {"name": "Fabian Wolff", "email": "fabi.wolff@arcor.de", "date": "2021-05-07T18:46:49Z"}, "message": "Fix suggestions for missing return type lifetime parameters", "tree": {"sha": "ac074896dd301b7f96ff18ddd281626a55205c64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac074896dd301b7f96ff18ddd281626a55205c64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/439ef6d76279268eb80e33afffafa22597e22776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/439ef6d76279268eb80e33afffafa22597e22776", "html_url": "https://github.com/rust-lang/rust/commit/439ef6d76279268eb80e33afffafa22597e22776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/439ef6d76279268eb80e33afffafa22597e22776/comments", "author": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f83d24aee866a14753a7cedbb4e301dfe5bef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f83d24aee866a14753a7cedbb4e301dfe5bef5", "html_url": "https://github.com/rust-lang/rust/commit/e5f83d24aee866a14753a7cedbb4e301dfe5bef5"}], "stats": {"total": 665, "additions": 514, "deletions": 151}, "files": [{"sha": "405dd2e68c6d061cc4426605679d6e0d0539f683", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -299,6 +299,30 @@ impl Diagnostic {\n         self\n     }\n \n+    /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n+    pub fn multipart_suggestion_with_style(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n+    ) -> &mut Self {\n+        assert!(!suggestion.is_empty());\n+        self.suggestions.push(CodeSuggestion {\n+            substitutions: vec![Substitution {\n+                parts: suggestion\n+                    .into_iter()\n+                    .map(|(span, snippet)| SubstitutionPart { snippet, span })\n+                    .collect(),\n+            }],\n+            msg: msg.to_owned(),\n+            style,\n+            applicability,\n+            tool_metadata: Default::default(),\n+        });\n+        self\n+    }\n+\n     /// Prints out a message with for a multipart suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to"}, {"sha": "ca4873bd51570b561e8fefee5f94b3e3870a39f6", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 205, "deletions": 146, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n@@ -1687,12 +1687,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn report_missing_lifetime_specifiers(\n         &self,\n-        span: Span,\n+        spans: Vec<Span>,\n         count: usize,\n     ) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             self.tcx.sess,\n-            span,\n+            spans,\n             E0106,\n             \"missing lifetime specifier{}\",\n             pluralize!(count)\n@@ -1821,81 +1821,107 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn add_missing_lifetime_specifiers_label(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        count: usize,\n+        spans: Vec<Span>,\n+        counts: Vec<usize>,\n         lifetime_names: &FxHashSet<Symbol>,\n         lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n-        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n-\n-        err.span_label(\n-            span,\n-            &format!(\n-                \"expected {} lifetime parameter{}\",\n-                if count == 1 { \"named\".to_string() } else { count.to_string() },\n-                pluralize!(count)\n-            ),\n-        );\n+        let snippets: Vec<Option<String>> = spans\n+            .iter()\n+            .copied()\n+            .map(|span| self.tcx.sess.source_map().span_to_snippet(span).ok())\n+            .collect();\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n-                                name: &str,\n-                                formatter: &dyn Fn(&str) -> String| {\n-            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n-                self.missing_named_lifetime_spots.iter().rev().next()\n-            {\n-                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n-                // using `'a`, but also introduce the concept of HRLTs by suggesting\n-                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n-                let mut introduce_suggestion = vec![];\n+        for (span, count) in spans.iter().zip(counts.iter()) {\n+            err.span_label(\n+                span.clone(),\n+                format!(\n+                    \"expected {} lifetime parameter{}\",\n+                    if *count == 1 { \"named\".to_string() } else { count.to_string() },\n+                    pluralize!(*count),\n+                ),\n+            );\n+        }\n \n-                let a_to_z_repeat_n = |n| {\n-                    (b'a'..=b'z').map(move |c| {\n-                        let mut s = '\\''.to_string();\n-                        s.extend(std::iter::repeat(char::from(c)).take(n));\n-                        s\n-                    })\n-                };\n+        let suggest_existing =\n+            |err: &mut DiagnosticBuilder<'_>,\n+             name: &str,\n+             formatters: &Vec<Option<Box<dyn Fn(&str) -> String>>>| {\n+                if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                    self.missing_named_lifetime_spots.iter().rev().next()\n+                {\n+                    // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                    // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                    // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                    let mut introduce_suggestion = vec![];\n+\n+                    let a_to_z_repeat_n = |n| {\n+                        (b'a'..=b'z').map(move |c| {\n+                            let mut s = '\\''.to_string();\n+                            s.extend(std::iter::repeat(char::from(c)).take(n));\n+                            s\n+                        })\n+                    };\n \n-                // If all single char lifetime names are present, we wrap around and double the chars.\n-                let lt_name = (1..)\n-                    .flat_map(a_to_z_repeat_n)\n-                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n-                    .unwrap();\n-                let msg = format!(\n-                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                    span_type.descr(),\n-                    lt_name,\n-                );\n-                err.note(\n-                    \"for more information on higher-ranked polymorphism, visit \\\n+                    // If all single char lifetime names are present, we wrap around and double the chars.\n+                    let lt_name = (1..)\n+                        .flat_map(a_to_z_repeat_n)\n+                        .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                        .unwrap();\n+                    let msg = format!(\n+                        \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                        span_type.descr(),\n+                        lt_name,\n+                    );\n+                    err.note(\n+                        \"for more information on higher-ranked polymorphism, visit \\\n                     https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                );\n-                let for_sugg = span_type.suggestion(&lt_name);\n-                for param in params {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n-                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n-                        } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                    );\n+                    let for_sugg = span_type.suggestion(&lt_name);\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                            } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                            }\n                         }\n                     }\n+                    introduce_suggestion.push((*for_span, for_sugg));\n+                    for (span, formatter) in spans.iter().copied().zip(formatters.iter()) {\n+                        if let Some(formatter) = formatter {\n+                            introduce_suggestion.push((span, formatter(&lt_name)));\n+                        }\n+                    }\n+                    err.multipart_suggestion_with_style(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                        SuggestionStyle::ShowAlways,\n+                    );\n                 }\n-                introduce_suggestion.push((*for_span, for_sugg));\n-                introduce_suggestion.push((span, formatter(&lt_name)));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n-            }\n \n-            err.span_suggestion_verbose(\n-                span,\n-                &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                formatter(name),\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-        let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                let mut spans_suggs: Vec<_> = Vec::new();\n+                for (span, fmt) in spans.iter().copied().zip(formatters.iter()) {\n+                    if let Some(formatter) = fmt {\n+                        spans_suggs.push((span, formatter(name)));\n+                    }\n+                }\n+                err.multipart_suggestion_with_style(\n+                    &format!(\n+                        \"consider using the `{}` lifetime\",\n+                        lifetime_names.iter().next().unwrap()\n+                    ),\n+                    spans_suggs,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n+            };\n+        let suggest_new = |err: &mut DiagnosticBuilder<'_>, suggs: &Vec<Option<String>>| {\n             for missing in self.missing_named_lifetime_spots.iter().rev() {\n                 let mut introduce_suggestion = vec![];\n                 let msg;\n@@ -1940,38 +1966,44 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n                     MissingLifetimeSpot::Static => {\n-                        let (span, sugg) = match snippet.as_deref() {\n-                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n-                            Some(\"'_\") => (span, \"'static\".to_owned()),\n-                            Some(snippet) if !snippet.ends_with('>') => {\n-                                if snippet == \"\" {\n-                                    (\n-                                        span,\n-                                        std::iter::repeat(\"'static\")\n-                                            .take(count)\n-                                            .collect::<Vec<_>>()\n-                                            .join(\", \"),\n-                                    )\n-                                } else {\n-                                    (\n-                                        span.shrink_to_hi(),\n-                                        format!(\n-                                            \"<{}>\",\n+                        let mut spans_suggs = Vec::new();\n+                        for ((span, snippet), count) in\n+                            spans.iter().copied().zip(snippets.iter()).zip(counts.iter().copied())\n+                        {\n+                            let (span, sugg) = match snippet.as_deref() {\n+                                Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                                Some(\"'_\") => (span, \"'static\".to_owned()),\n+                                Some(snippet) if !snippet.ends_with('>') => {\n+                                    if snippet == \"\" {\n+                                        (\n+                                            span,\n                                             std::iter::repeat(\"'static\")\n                                                 .take(count)\n                                                 .collect::<Vec<_>>()\n-                                                .join(\", \")\n-                                        ),\n-                                    )\n+                                                .join(\", \"),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            span.shrink_to_hi(),\n+                                            format!(\n+                                                \"<{}>\",\n+                                                std::iter::repeat(\"'static\")\n+                                                    .take(count)\n+                                                    .collect::<Vec<_>>()\n+                                                    .join(\", \")\n+                                            ),\n+                                        )\n+                                    }\n                                 }\n-                            }\n-                            _ => continue,\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n+                                _ => continue,\n+                            };\n+                            spans_suggs.push((span, sugg.to_string()));\n+                        }\n+                        err.multipart_suggestion_with_style(\n                             \"consider using the `'static` lifetime\",\n-                            sugg.to_string(),\n+                            spans_suggs,\n                             Applicability::MaybeIncorrect,\n+                            SuggestionStyle::ShowAlways,\n                         );\n                         continue;\n                     }\n@@ -1986,77 +2018,104 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         }\n                     }\n                 }\n-                introduce_suggestion.push((span, sugg.to_string()));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+                for (span, sugg) in spans.iter().copied().zip(suggs.iter()) {\n+                    if let Some(sugg) = sugg {\n+                        introduce_suggestion.push((span, sugg.to_string()));\n+                    }\n+                }\n+                err.multipart_suggestion_with_style(\n+                    &msg,\n+                    introduce_suggestion,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n                 if should_break {\n                     break;\n                 }\n             }\n         };\n \n         let lifetime_names: Vec<_> = lifetime_names.iter().collect();\n-        match (&lifetime_names[..], snippet.as_deref()) {\n-            ([name], Some(\"&\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n-            }\n-            ([name], Some(\"'_\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n-            }\n-            ([name], Some(\"\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n-            }\n-            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n-                let f = |name: &str| {\n-                    format!(\n-                        \"{}<{}>\",\n-                        snippet,\n-                        std::iter::repeat(name.to_string())\n-                            .take(count)\n-                            .collect::<Vec<_>>()\n-                            .join(\", \")\n-                    )\n-                };\n-                suggest_existing(err, &name.as_str()[..], &f);\n-            }\n-            ([], Some(\"&\")) if count == 1 => {\n-                suggest_new(err, \"&'a \");\n-            }\n-            ([], Some(\"'_\")) if count == 1 => {\n-                suggest_new(err, \"'a\");\n-            }\n-            ([], Some(snippet)) if !snippet.ends_with('>') => {\n-                if snippet == \"\" {\n-                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n-                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n-                    suggest_new(\n-                        err,\n-                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n-                    );\n-                } else {\n-                    suggest_new(\n-                        err,\n-                        &format!(\n-                            \"{}<{}>\",\n-                            snippet,\n-                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n-                        ),\n-                    );\n+        match &lifetime_names[..] {\n+            [name] => {\n+                let mut suggs: Vec<Option<Box<dyn Fn(&str) -> String>>> = Vec::new();\n+                for (snippet, count) in snippets.iter().cloned().zip(counts.iter().copied()) {\n+                    if snippet == Some(\"&\".to_string()) {\n+                        suggs.push(Some(Box::new(|name| format!(\"&{} \", name))));\n+                    } else if snippet == Some(\"'_\".to_string()) {\n+                        suggs.push(Some(Box::new(|n| n.to_string())));\n+                    } else if snippet == Some(\"\".to_string()) {\n+                        suggs.push(Some(Box::new(move |n| format!(\"{}, \", n).repeat(count))));\n+                    } else if let Some(snippet) = snippet {\n+                        if !snippet.ends_with('>') {\n+                            suggs.push(Some(Box::new(move |name| {\n+                                format!(\n+                                    \"{}<{}>\",\n+                                    snippet,\n+                                    std::iter::repeat(name.to_string())\n+                                        .take(count)\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \")\n+                                )\n+                            })));\n+                        } else {\n+                            suggs.push(None);\n+                        }\n+                    } else {\n+                        suggs.push(None);\n+                    }\n+                }\n+                suggest_existing(err, &name.as_str()[..], &suggs);\n+            }\n+            [] => {\n+                let mut suggs: Vec<Option<String>> = Vec::new();\n+                for (snippet, count) in snippets.iter().cloned().zip(counts.iter().copied()) {\n+                    if snippet == Some(\"&\".to_string()) {\n+                        suggs.push(Some(\"&'a \".to_string()));\n+                    } else if snippet == Some(\"'_\".to_string()) {\n+                        suggs.push(Some(\"'a\".to_string()));\n+                    } else if let Some(snippet) = snippet {\n+                        if snippet == \"\" {\n+                            suggs.push(Some(\n+                                std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n+                            ));\n+                        } else {\n+                            suggs.push(Some(format!(\n+                                \"{}<{}>\",\n+                                snippet,\n+                                std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n+                            )));\n+                        }\n+                    } else {\n+                        suggs.push(None);\n+                    }\n                 }\n+                suggest_new(err, &suggs);\n             }\n-            (lts, ..) if lts.len() > 1 => {\n+            lts if lts.len() > 1 => {\n                 err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n-                if Some(\"\") == snippet.as_deref() {\n+\n+                let mut spans_suggs: Vec<_> = Vec::new();\n+                for (span, snippet) in spans.iter().copied().zip(snippets.iter()) {\n+                    if Some(\"\") == snippet.as_deref() {\n+                        spans_suggs.push((span, \"'lifetime, \".to_string()));\n+                    } else if Some(\"&\") == snippet.as_deref() {\n+                        spans_suggs.push((span, \"&'lifetime \".to_string()));\n+                    }\n+                }\n+\n+                if spans_suggs.len() > 0 {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders.\n-                    err.span_suggestion_verbose(\n-                        span,\n+                    err.multipart_suggestion_with_style(\n                         \"consider using one of the available lifetimes here\",\n-                        \"'lifetime, \".repeat(count),\n+                        spans_suggs,\n                         Applicability::HasPlaceholders,\n+                        SuggestionStyle::ShowAlways,\n                     );\n                 }\n             }\n-            _ => {}\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "c81269a46b21af4d3a5ee3e32d811fde16043d5f", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -2956,7 +2956,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             return;\n         }\n \n-        let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n@@ -3035,18 +3034,26 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = self.report_missing_lifetime_specifiers(span, lifetime_refs.len());\n+        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n+        spans.sort();\n+        let mut spans_dedup = spans.clone();\n+        spans_dedup.dedup();\n+        let counts: Vec<_> =\n+            spans_dedup.iter().map(|sp| spans.iter().filter(|nsp| *nsp == sp).count()).collect();\n+\n+        let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n                 lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n+\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n-            span,\n-            lifetime_refs.len(),\n+            spans,\n+            counts,\n             &lifetime_names,\n             lifetime_spans,\n             error.unwrap_or(&[]),"}, {"sha": "aa246aaa3d45efb3006632356d86dca41797ce79", "filename": "src/test/ui/issues/issue-84592.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fissues%2Fissue-84592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fissues%2Fissue-84592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-84592.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -0,0 +1,17 @@\n+/* Checks whether issue #84592 has been resolved. The issue was\n+ * that in this example, there are two expected/missing lifetime\n+ * parameters with *different spans*, leading to incorrect\n+ * suggestions from rustc.\n+ */\n+\n+struct TwoLifetimes<'x, 'y> {\n+    x: &'x (),\n+    y: &'y (),\n+}\n+\n+fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+//~^ ERROR missing lifetime specifiers [E0106]\n+    TwoLifetimes { x: &(), y: &() }\n+}\n+\n+fn main() {}"}, {"sha": "02f9241a6d2dae3fdbb5e13aa35870c777f2702f", "filename": "src/test/ui/issues/issue-84592.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fissues%2Fissue-84592.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fissues%2Fissue-84592.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-84592.stderr?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -0,0 +1,17 @@\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/issue-84592.rs:12:57\n+   |\n+LL | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+   |                            ---     ---                  ^^  ^^ expected named lifetime parameter\n+   |                                                         |\n+   |                                                         expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'a, 'a> {\n+   |                        ^^^^    ^^^^^^     ^^^^^^                  ^^  ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "ca336bbb056d5105847adb9c12be2fc39b0ac935", "filename": "src/test/ui/return-elided-lifetime.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Freturn-elided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Freturn-elided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-elided-lifetime.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -0,0 +1,37 @@\n+/* Checks all four scenarios possible in report_elision_failure() of\n+ * rustc_resolve::late::lifetimes::LifetimeContext related to returning\n+ * borrowed values, in various configurations.\n+ */\n+\n+fn f1() -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f1_() -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+struct S<'a, 'b> { a: &'a i32, b: &'b i32 }\n+fn f3(s: &S) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn main() {}"}, {"sha": "888cd5e58abeca671718a7572b56fe0a53db8f53", "filename": "src/test/ui/return-elided-lifetime.stderr", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Freturn-elided-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Freturn-elided-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn-elided-lifetime.stderr?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -0,0 +1,198 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:6:12\n+   |\n+LL | fn f1() -> &i32 { loop {} }\n+   |            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1() -> &'static i32 { loop {} }\n+   |            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:14\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |              ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&'static i32, &i32) { loop {} }\n+   |              ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:20\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |                    ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&i32, &'static i32) { loop {} }\n+   |                    ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:12:26\n+   |\n+LL | fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+   |                          ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2(a: i32, b: i32) -> &'static i32 { loop {} }\n+   |                          ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:28\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&'static i32, &i32) { loop {} }\n+   |                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:34\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                                  ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &'static i32) { loop {} }\n+   |                                  ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:19:17\n+   |\n+LL | fn f3(s: &S) -> &i32 { loop {} }\n+   |          --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `s`'s 3 lifetimes it is borrowed from\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3<'a>(s: &'a S) -> &'a i32 { loop {} }\n+   |      ^^^^    ^^^^^     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:26\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&'a i32, &i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^      ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:32\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&i32, &'a i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^            ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:25:42\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |                  -------     -------     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:25:7\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |       ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &'lifetime i32 { loop {} }\n+   |                                          ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:44\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&'lifetime i32, &i32) { loop {} }\n+   |                                            ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:50\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &'lifetime i32) { loop {} }\n+   |                                                  ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:31:35\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+   |              -------     ----     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &'a i32 { loop {} }\n+   |                                   ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:37\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&'a i32, &i32) { loop {} }\n+   |                                     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:43\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &'a i32) { loop {} }\n+   |                                           ^^^\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "a7a44b511db8de6b3b12dc917bf902a4f564caa8", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -44,6 +44,10 @@ note: these named lifetimes are available to use\n    |\n LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n    |          ^^              ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &'lifetime X);\n+   |                                        ^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lt-for-hrtb.rs:5:41"}, {"sha": "791489b3960a59a8b2befb9f7c9804a74230fb95", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/439ef6d76279268eb80e33afffafa22597e22776/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=439ef6d76279268eb80e33afffafa22597e22776", "patch": "@@ -8,7 +8,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 1388;\n-const ISSUES_ENTRY_LIMIT: usize = 2551;\n+const ISSUES_ENTRY_LIMIT: usize = 2557;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     let dirs = walkdir::WalkDir::new(&path.join(\"test/ui\"))"}]}