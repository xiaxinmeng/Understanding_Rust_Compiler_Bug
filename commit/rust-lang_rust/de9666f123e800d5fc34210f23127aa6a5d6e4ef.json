{"sha": "de9666f123e800d5fc34210f23127aa6a5d6e4ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlOTY2NmYxMjNlODAwZDVmYzM0MjEwZjIzMTI3YWE2YTVkNmU0ZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-31T13:52:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-31T13:52:00Z"}, "message": "Auto merge of #54806 - parched:park, r=RalfJung\n\nthread::unpark: Avoid notifying with mutex locked.\n\nThis means when the other thread wakes it can continue right away\ninstead of having to wait for the mutex.\n\nAlso add some comments explaining why the mutex needs to be locked in\nthe first place.\n\nThis is a follow up to https://github.com/rust-lang/rust/pull/54174\nI did some tests with relacy [here](https://gist.github.com/parched/b7fb88c97755a81e5cb9f9048a15f7fb) (This PR is InnerV2). If anyone can think of some other test case worth adding let me know.\n\nr? @RalfJung", "tree": {"sha": "e940ed377031f48227e7610a0408d34164883049", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e940ed377031f48227e7610a0408d34164883049"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de9666f123e800d5fc34210f23127aa6a5d6e4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de9666f123e800d5fc34210f23127aa6a5d6e4ef", "html_url": "https://github.com/rust-lang/rust/commit/de9666f123e800d5fc34210f23127aa6a5d6e4ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de9666f123e800d5fc34210f23127aa6a5d6e4ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05812fa8c588473f03e3fa7cf59cd84f4f37c715", "url": "https://api.github.com/repos/rust-lang/rust/commits/05812fa8c588473f03e3fa7cf59cd84f4f37c715", "html_url": "https://github.com/rust-lang/rust/commit/05812fa8c588473f03e3fa7cf59cd84f4f37c715"}, {"sha": "d3e71e4986c3970d2f51b972c1dfdd740f89385a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e71e4986c3970d2f51b972c1dfdd740f89385a", "html_url": "https://github.com/rust-lang/rust/commit/d3e71e4986c3970d2f51b972c1dfdd740f89385a"}], "stats": {"total": 14, "additions": 12, "deletions": 2}, "files": [{"sha": "a57b8dc7237678489baf2476a7350cc6f26e7b09", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de9666f123e800d5fc34210f23127aa6a5d6e4ef/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de9666f123e800d5fc34210f23127aa6a5d6e4ef/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=de9666f123e800d5fc34210f23127aa6a5d6e4ef", "patch": "@@ -1149,8 +1149,18 @@ impl Thread {\n             _ => panic!(\"inconsistent state in unpark\"),\n         }\n \n-        // Coordinate wakeup through the mutex and a condvar notification\n-        let _lock = self.inner.lock.lock().unwrap();\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        drop(self.inner.lock.lock().unwrap());\n         self.inner.cvar.notify_one()\n     }\n "}]}