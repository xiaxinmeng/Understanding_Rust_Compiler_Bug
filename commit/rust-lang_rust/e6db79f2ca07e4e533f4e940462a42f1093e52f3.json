{"sha": "e6db79f2ca07e4e533f4e940462a42f1093e52f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZGI3OWYyY2EwN2U0ZTUzM2Y0ZTk0MDQ2MmE0MmYxMDkzZTUyZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-12T09:42:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-12T09:42:11Z"}, "message": "Auto merge of #50352 - porglezomp:btree-no-empty-alloc, r=Gankro\n\nDon't allocate when creating an empty BTree\n\nFollowing the discussion in #50266, this adds a static instance of `LeafNode` that empty BTrees point to, and then replaces it on `insert`, `append`, and `entry`. This avoids allocating for empty maps.\n\nFixes #50266\n\nr? @Gankro", "tree": {"sha": "785db4f903ca92acdb2e8bc90524fddab40cfebb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/785db4f903ca92acdb2e8bc90524fddab40cfebb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6db79f2ca07e4e533f4e940462a42f1093e52f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6db79f2ca07e4e533f4e940462a42f1093e52f3", "html_url": "https://github.com/rust-lang/rust/commit/e6db79f2ca07e4e533f4e940462a42f1093e52f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6db79f2ca07e4e533f4e940462a42f1093e52f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f98fe714e8e5638fd38cb238c50508c2600002f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f98fe714e8e5638fd38cb238c50508c2600002f", "html_url": "https://github.com/rust-lang/rust/commit/5f98fe714e8e5638fd38cb238c50508c2600002f"}, {"sha": "e83c18f91d373592ecf7a0fbbc24d7597925af13", "url": "https://api.github.com/repos/rust-lang/rust/commits/e83c18f91d373592ecf7a0fbbc24d7597925af13", "html_url": "https://github.com/rust-lang/rust/commit/e83c18f91d373592ecf7a0fbbc24d7597925af13"}], "stats": {"total": 159, "additions": 128, "deletions": 31}, "files": [{"sha": "bb2c68a27ba308f3ba1e825d57bbabd678e20cc4", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e6db79f2ca07e4e533f4e940462a42f1093e52f3/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6db79f2ca07e4e533f4e940462a42f1093e52f3/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=e6db79f2ca07e4e533f4e940462a42f1093e52f3", "patch": "@@ -246,6 +246,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n+        self.ensure_root_is_owned();\n         match search::search_tree::<marker::Mut, K, (), K>(self.root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n@@ -523,7 +524,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         BTreeMap {\n-            root: node::Root::new_leaf(),\n+            root: node::Root::shared_empty_root(),\n             length: 0,\n         }\n     }\n@@ -544,7 +545,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        // FIXME(gereeter) .clear() allocates\n         *self = BTreeMap::new();\n     }\n \n@@ -890,6 +890,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n+        // FIXME(@porglezomp) Avoid allocating if we don't insert\n+        self.ensure_root_is_owned();\n         match search::search_tree(self.root.as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry {\n@@ -910,6 +912,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n+        self.ensure_root_is_owned();\n         let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n@@ -1019,6 +1022,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n+        right.root = node::Root::new_leaf();\n         for _ in 0..(self.root.as_ref().height()) {\n             right.root.push_level();\n         }\n@@ -1153,6 +1157,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n+\n+    /// If the root node is the shared root node, allocate our own node.\n+    fn ensure_root_is_owned(&mut self) {\n+        if self.root.is_shared_root() {\n+            self.root = node::Root::new_leaf();\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1290,6 +1301,10 @@ impl<K, V> Drop for IntoIter<K, V> {\n         self.for_each(drop);\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n+            if leaf_node.is_shared_root() {\n+                return;\n+            }\n+\n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n                 let mut cur_node = first_parent.into_node();\n                 while let Some(parent) = cur_node.deallocate_and_ascend() {"}, {"sha": "431695c32ab68f8f9d35bef16a9442cb6a35d5cb", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 111, "deletions": 29, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e6db79f2ca07e4e533f4e940462a42f1093e52f3/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6db79f2ca07e4e533f4e940462a42f1093e52f3/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=e6db79f2ca07e4e533f4e940462a42f1093e52f3", "patch": "@@ -60,12 +60,12 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// See also rust-lang/rfcs#197, which would make this structure significantly more safe by\n /// avoiding accidentally dropping unused and uninitialized keys and values.\n+///\n+/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n+/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n+/// prevent them from being reordered.\n+#[repr(C)]\n struct LeafNode<K, V> {\n-    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n-    /// array are initialized and valid.\n-    keys: [K; CAPACITY],\n-    vals: [V; CAPACITY],\n-\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -77,10 +77,14 @@ struct LeafNode<K, V> {\n \n     /// The number of keys and values this node stores.\n     ///\n-    /// This is at the end of the node's representation and next to `parent_idx` to encourage\n-    /// the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n-    /// overhead.\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n+\n+    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n+    /// array are initialized and valid.\n+    keys: [K; CAPACITY],\n+    vals: [V; CAPACITY],\n }\n \n impl<K, V> LeafNode<K, V> {\n@@ -97,8 +101,26 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+\n+    fn is_shared_root(&self) -> bool {\n+        self as *const _ == &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V>\n+    }\n }\n \n+// We need to implement Sync here in order to make a static instance.\n+unsafe impl Sync for LeafNode<(), ()> {}\n+\n+// An empty node used as a placeholder for the root node, to avoid allocations.\n+// We use () in order to save space, since no operation on an empty tree will\n+// ever take a pointer past the first key.\n+static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+    parent: ptr::null(),\n+    parent_idx: 0,\n+    len: 0,\n+    keys: [(); CAPACITY],\n+    vals: [(); CAPACITY],\n+};\n+\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -168,6 +190,21 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> { }\n unsafe impl<K: Send, V: Send> Send for Root<K, V> { }\n \n impl<K, V> Root<K, V> {\n+    pub fn is_shared_root(&self) -> bool {\n+        self.as_ref().is_shared_root()\n+    }\n+\n+    pub fn shared_empty_root() -> Self {\n+        Root {\n+            node: unsafe {\n+                BoxedNode::from_ptr(NonNull::new_unchecked(\n+                    &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V> as *mut _\n+                ))\n+            },\n+            height: 0,\n+        }\n+    }\n+\n     pub fn new_leaf() -> Self {\n         Root {\n             node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })),\n@@ -209,6 +246,7 @@ impl<K, V> Root<K, V> {\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n+        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0] = unsafe { BoxedNode::from_ptr(self.node.as_ptr()) };\n \n@@ -353,12 +391,16 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n+    pub fn is_shared_root(&self) -> bool {\n+        self.as_leaf().is_shared_root()\n+    }\n+\n     pub fn keys(&self) -> &[K] {\n-        self.reborrow().into_slices().0\n+        self.reborrow().into_key_slice()\n     }\n \n-    pub fn vals(&self) -> &[V] {\n-        self.reborrow().into_slices().1\n+    fn vals(&self) -> &[V] {\n+        self.reborrow().into_val_slice()\n     }\n \n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n@@ -433,6 +475,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n             marker::Edge\n         >\n     > {\n+        debug_assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n         Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n@@ -500,30 +543,51 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    pub fn keys_mut(&mut self) -> &mut [K] {\n-        unsafe { self.reborrow_mut().into_slices_mut().0 }\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    pub fn vals_mut(&mut self) -> &mut [V] {\n-        unsafe { self.reborrow_mut().into_slices_mut().1 }\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    pub fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        unsafe {\n-            (\n+    fn into_key_slice(self) -> &'a [K] {\n+        // When taking a pointer to the keys, if our key has a stricter\n+        // alignment requirement than the shared root does, then the pointer\n+        // would be out of bounds, which LLVM assumes will not happen. If the\n+        // alignment is more strict, we need to make an empty slice that doesn't\n+        // use an out of bounds pointer.\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &[]\n+        } else {\n+            // Here either it's not the root, or the alignment is less strict,\n+            // in which case the keys pointer will point \"one-past-the-end\" of\n+            // the node, which is allowed by LLVM.\n+            unsafe {\n                 slice::from_raw_parts(\n                     self.as_leaf().keys.as_ptr(),\n                     self.len()\n-                ),\n-                slice::from_raw_parts(\n-                    self.as_leaf().vals.as_ptr(),\n-                    self.len()\n                 )\n+            }\n+        }\n+    }\n+\n+    fn into_val_slice(self) -> &'a [V] {\n+        debug_assert!(!self.is_shared_root());\n+        unsafe {\n+            slice::from_raw_parts(\n+                self.as_leaf().vals.as_ptr(),\n+                self.len()\n             )\n         }\n     }\n+\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        let k = unsafe { ptr::read(&self) };\n+        (k.into_key_slice(), self.into_val_slice())\n+    }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n@@ -535,27 +599,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    pub fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe {\n-            (\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &mut []\n+        } else {\n+            unsafe {\n                 slice::from_raw_parts_mut(\n                     &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n                     self.len()\n-                ),\n-                slice::from_raw_parts_mut(\n-                    &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n-                    self.len()\n                 )\n+            }\n+        }\n+    }\n+\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        debug_assert!(!self.is_shared_root());\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n+                self.len()\n             )\n         }\n     }\n+\n+    fn into_slices_mut(self) -> (&'a mut [K], &'a mut [V]) {\n+        let k = unsafe { ptr::read(&self) };\n+        (k.into_key_slice_mut(), self.into_val_slice_mut())\n+    }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -571,6 +649,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -884,6 +963,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n+        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -1061,6 +1141,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     ///   allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+        debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1098,6 +1179,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// now adjacent key/value pairs to the left and right of this handle.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+        debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);"}]}