{"sha": "cf4afa1cee4770f28a8dee5edba60a0240bbb392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNGFmYTFjZWU0NzcwZjI4YThkZWU1ZWRiYTYwYTAyNDBiYmIzOTI=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T09:05:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-10T09:05:46Z"}, "message": "Merge pull request #137 from oli-obk/master\n\nautogenerate markdown for rustc test suite result", "tree": {"sha": "90c1c26385a4cf2296be3a52d4249799a2d6927c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90c1c26385a4cf2296be3a52d4249799a2d6927c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf4afa1cee4770f28a8dee5edba60a0240bbb392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4afa1cee4770f28a8dee5edba60a0240bbb392", "html_url": "https://github.com/rust-lang/rust/commit/cf4afa1cee4770f28a8dee5edba60a0240bbb392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf4afa1cee4770f28a8dee5edba60a0240bbb392/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "html_url": "https://github.com/rust-lang/rust/commit/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6"}, {"sha": "6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "html_url": "https://github.com/rust-lang/rust/commit/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e"}], "stats": {"total": 100, "additions": 92, "deletions": 8}, "files": [{"sha": "100b79401dfbb1918e73c349e8aa728c2017489d", "filename": "tests/compiletest.rs", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/cf4afa1cee4770f28a8dee5edba60a0240bbb392/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf4afa1cee4770f28a8dee5edba60a0240bbb392/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=cf4afa1cee4770f28a8dee5edba60a0240bbb392", "patch": "@@ -83,10 +83,15 @@ fn compile_test() {\n     let host = host.split(\"\\n\").next().expect(\"no \\n after host\");\n \n     if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        let mut mir_not_found = 0;\n-        let mut crate_not_found = 0;\n+        let mut mir_not_found = Vec::new();\n+        let mut crate_not_found = Vec::new();\n         let mut success = 0;\n-        let mut failed = 0;\n+        let mut failed = Vec::new();\n+        let mut c_abi_fns = Vec::new();\n+        let mut abi = Vec::new();\n+        let mut unsupported = Vec::new();\n+        let mut unimplemented_intrinsic = Vec::new();\n+        let mut limits = Vec::new();\n         for file in std::fs::read_dir(path).unwrap() {\n             let file = file.unwrap();\n             let path = file.path();\n@@ -110,15 +115,37 @@ fn compile_test() {\n                 Ok(output) => {\n                     let output_err = std::str::from_utf8(&output.stderr).unwrap();\n                     if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n-                        mir_not_found += 1;\n                         let end = text.find('`').unwrap();\n+                        mir_not_found.push(text[..end].to_string());\n                         writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n                     } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n-                        crate_not_found += 1;\n                         let end = text.find('`').unwrap();\n+                        crate_not_found.push(text[..end].to_string());\n                         writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n                     } else {\n-                        failed += 1;\n+                        for text in output_err.split(\"error: \").skip(1) {\n+                            let end = text.find('\\n').unwrap_or(text.len());\n+                            let c_abi = \"can't call C ABI function: \";\n+                            let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n+                            let unsupported_s = \"miri does not support \";\n+                            let abi_s = \"can't handle function with \";\n+                            let limit_s = \"reached the configured maximum \";\n+                            if text.starts_with(c_abi) {\n+                                c_abi_fns.push(text[c_abi.len()..end].to_string());\n+                            } else if text.starts_with(unimplemented_intrinsic_s) {\n+                                unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n+                            } else if text.starts_with(unsupported_s) {\n+                                unsupported.push(text[unsupported_s.len()..end].to_string());\n+                            } else if text.starts_with(abi_s) {\n+                                abi.push(text[abi_s.len()..end].to_string());\n+                            } else if text.starts_with(limit_s) {\n+                                limits.push(text[limit_s.len()..end].to_string());\n+                            } else {\n+                                if text.find(\"aborting\").is_none() {\n+                                    failed.push(text[..end].to_string());\n+                                }\n+                            }\n+                        }\n                         writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n                         writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                         writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n@@ -131,8 +158,34 @@ fn compile_test() {\n             }\n         }\n         let stderr = std::io::stderr();\n-        writeln!(stderr.lock(), \"{} success, {} mir not found, {} crate not found, {} failed\", success, mir_not_found, crate_not_found, failed).unwrap();\n-        assert_eq!(failed, 0, \"some tests failed\");\n+        let mut stderr = stderr.lock();\n+        writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n+                          {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n+                          success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n+                          c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n+        writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n+        writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n+        print_vec(&mut stderr, failed);\n+\n+        writeln!(stderr, \"# can't call C ABI function\").unwrap();\n+        print_vec(&mut stderr, c_abi_fns);\n+\n+        writeln!(stderr, \"# unsupported ABI\").unwrap();\n+        print_vec(&mut stderr, abi);\n+\n+        writeln!(stderr, \"# unsupported\").unwrap();\n+        print_vec(&mut stderr, unsupported);\n+\n+        writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n+        print_vec(&mut stderr, unimplemented_intrinsic);\n+\n+        writeln!(stderr, \"# mir not found\").unwrap();\n+        print_vec(&mut stderr, mir_not_found);\n+\n+        writeln!(stderr, \"# crate not found\").unwrap();\n+        print_vec(&mut stderr, crate_not_found);\n+\n+        panic!(\"ran miri on rustc test suite. Test failing for convenience\");\n     } else {\n         run_pass();\n         for_all_targets(&sysroot, |target| {\n@@ -141,3 +194,34 @@ fn compile_test() {\n         compile_fail(&sysroot);\n     }\n }\n+\n+fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n+    writeln!(stderr, \"```\").unwrap();\n+    for (n, s) in vec_to_hist(v).into_iter().rev() {\n+        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n+    }\n+    writeln!(stderr, \"```\").unwrap();\n+}\n+\n+fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n+    v.sort();\n+    let mut v = v.into_iter();\n+    let mut result = Vec::new();\n+    let mut current = v.next();\n+    'outer: while let Some(current_val) = current {\n+        let mut n = 1;\n+        while let Some(next) = v.next() {\n+            if next == current_val {\n+                n += 1;\n+            } else {\n+                result.push((n, current_val));\n+                current = Some(next);\n+                continue 'outer;\n+            }\n+        }\n+        result.push((n, current_val));\n+        break;\n+    }\n+    result.sort();\n+    result\n+}"}]}