{"sha": "8e6d66280f7824e24021a15c7075ecdfbfd19b28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNmQ2NjI4MGY3ODI0ZTI0MDIxYTE1YzcwNzVlY2RmYmZkMTliMjg=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-17T23:03:54Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-18T00:03:14Z"}, "message": "dlist enhancements: concat/append/prepend/reverse/each_node (close #2917)", "tree": {"sha": "bf805b869591333dac5347d904e38c4e898d49be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf805b869591333dac5347d904e38c4e898d49be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e6d66280f7824e24021a15c7075ecdfbfd19b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d66280f7824e24021a15c7075ecdfbfd19b28", "html_url": "https://github.com/rust-lang/rust/commit/8e6d66280f7824e24021a15c7075ecdfbfd19b28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e6d66280f7824e24021a15c7075ecdfbfd19b28/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57745b48c6a032da10d497e2bee6c2b2a11637b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57745b48c6a032da10d497e2bee6c2b2a11637b", "html_url": "https://github.com/rust-lang/rust/commit/e57745b48c6a032da10d497e2bee6c2b2a11637b"}], "stats": {"total": 378, "additions": 302, "deletions": 76}, "files": [{"sha": "087194f721dfae06bf5de4b31a724f4ad6d901fd", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 292, "deletions": 66, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d66280f7824e24021a15c7075ecdfbfd19b28/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d66280f7824e24021a15c7075ecdfbfd19b28/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=8e6d66280f7824e24021a15c7075ecdfbfd19b28", "patch": "@@ -7,13 +7,13 @@\n import dlist_iter::extensions;\n \n export dlist, dlist_node;\n-export create, from_elt, from_vec, extensions;\n+export new_dlist, from_elem, from_vec, extensions;\n \n type dlist_link<T> = option<dlist_node<T>>;\n \n enum dlist_node<T> = @{\n     data: T,\n-    mut root: option<dlist<T>>,\n+    mut linked: bool, // for assertions\n     mut prev: dlist_link<T>,\n     mut next: dlist_link<T>\n };\n@@ -81,57 +81,67 @@ impl extensions<T> for dlist_node<T> {\n             none       { fail ~\"This dlist node has no previous neighbour.\" }\n         }\n     }\n-\n-    /// Remove a node from whatever dlist it's on (failing if none).\n-    fn remove() {\n-        if option::is_some(self.root) {\n-            option::get(self.root).remove(self);\n-        } else {\n-            fail ~\"Removing an orphaned dlist node - what do I remove from?\"\n-        }\n-    }\n }\n \n /// Creates a new dlist node with the given data.\n-pure fn create_node<T>(+data: T) -> dlist_node<T> {\n-    dlist_node(@{data: data, mut root: none, mut prev: none, mut next: none})\n+pure fn new_dlist_node<T>(+data: T) -> dlist_node<T> {\n+    dlist_node(@{data: data, mut linked: false,\n+                 mut prev: none, mut next: none})\n }\n \n /// Creates a new, empty dlist.\n-pure fn create<T>() -> dlist<T> {\n+pure fn new_dlist<T>() -> dlist<T> {\n     dlist(@{mut size: 0, mut hd: none, mut tl: none})\n }\n \n /// Creates a new dlist with a single element\n-fn from_elt<T>(+data: T) -> dlist<T> {\n-    let list = create();\n-    list.push(data);\n+pure fn from_elem<T>(+data: T) -> dlist<T> {\n+    let list = new_dlist();\n+    unchecked { list.push(data); }\n     list\n }\n \n fn from_vec<T: copy>(+vec: &[T]) -> dlist<T> {\n-    do vec::foldl(create(), vec) |list,data| {\n+    do vec::foldl(new_dlist(), vec) |list,data| {\n         list.push(data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }\n }\n \n+/// Produce a list from a list of lists, leaving no elements behind in the\n+/// input. O(number of sub-lists).\n+fn concat<T>(lists: dlist<dlist<T>>) -> dlist<T> {\n+    let result = new_dlist();\n+    while !lists.is_empty() {\n+        result.append(lists.pop().get());\n+    }\n+    result\n+}\n+\n impl private_methods<T> for dlist<T> {\n     pure fn new_link(-data: T) -> dlist_link<T> {\n-        some(dlist_node(@{data: data, mut root: some(self),\n+        some(dlist_node(@{data: data, mut linked: true,\n                           mut prev: none, mut next: none}))\n     }\n     pure fn assert_mine(nobe: dlist_node<T>) {\n-        alt nobe.root {\n-            some(me) { assert box::ptr_eq(*self, *me); }\n-            none     { fail ~\"This node isn't on this dlist.\" }\n+        // These asserts could be stronger if we had node-root back-pointers,\n+        // but those wouldn't allow for O(1) append.\n+        if self.size == 0 {\n+            fail ~\"This dlist is empty; that node can't be on it.\"\n+        }\n+        if !nobe.linked { fail ~\"That node isn't linked to any dlist.\" }\n+        if !((nobe.prev.is_some()\n+              || box::ptr_eq(*self.hd.expect(~\"headless dlist?\"), *nobe)) &&\n+             (nobe.next.is_some()\n+              || box::ptr_eq(*self.tl.expect(~\"tailless dlist?\"), *nobe))) {\n+            fail ~\"That node isn't on this dlist.\"\n         }\n     }\n     fn make_mine(nobe: dlist_node<T>) {\n-        if option::is_some(nobe.root) {\n+        if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             fail ~\"Cannot insert node that's already on a dlist!\"\n         }\n-        nobe.root = some(self);\n+        nobe.linked = true;\n     }\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n@@ -153,7 +163,7 @@ impl private_methods<T> for dlist<T> {\n         self.link(nobe.prev, nobe.next);\n         nobe.prev = none; // Release extraneous references.\n         nobe.next = none;\n-        nobe.root = none;\n+        nobe.linked = false;\n         self.size -= 1;\n     }\n \n@@ -278,6 +288,20 @@ impl extensions<T> for dlist<T> {\n         tl.map(|nobe| self.unlink(nobe));\n         tl\n     }\n+    /// Remove data from the head of the list. O(1).\n+    fn pop() -> option<T> {\n+        do option::map_consume(self.pop_n()) |nobe| {\n+            let dlist_node(@{ data: x, _ }) <- nobe;\n+            x\n+        }\n+    }\n+    /// Remove data from the tail of the list. O(1).\n+    fn pop_tail() -> option<T> {\n+        do option::map_consume(self.pop_tail_n()) |nobe| {\n+            let dlist_node(@{ data: x, _ }) <- nobe;\n+            x\n+        }\n+    }\n     /// Get the node at the list's head. O(1).\n     pure fn peek_n() -> option<dlist_node<T>> { self.hd }\n     /// Get the node at the list's tail. O(1).\n@@ -305,6 +329,64 @@ impl extensions<T> for dlist<T> {\n     /// Remove a node from anywhere in the list. O(1).\n     fn remove(nobe: dlist_node<T>) { self.unlink(nobe); }\n \n+    /**\n+     * Empty another list onto the end of this list, joining this list's tail\n+     * to the other list's head. O(1).\n+     */\n+    fn append(them: dlist<T>) {\n+        if box::ptr_eq(*self, *them) {\n+            fail ~\"Cannot append a dlist to itself!\"\n+        }\n+        if them.len() > 0 {\n+            self.link(self.tl, them.hd);\n+            self.tl    = them.tl;\n+            self.size += them.size;\n+            them.size  = 0;\n+            them.hd    = none;\n+            them.tl    = none;\n+        }\n+    }\n+    /**\n+     * Empty another list onto the start of this list, joining the other\n+     * list's tail to this list's head. O(1).\n+     */\n+    fn prepend(them: dlist<T>) {\n+        if box::ptr_eq(*self, *them) {\n+            fail ~\"Cannot prepend a dlist to itself!\"\n+        }\n+        if them.len() > 0 {\n+            self.link(them.tl, self.hd);\n+            self.hd    = them.hd;\n+            self.size += them.size;\n+            them.size  = 0;\n+            them.hd    = none;\n+            them.tl    = none;\n+        }\n+    }\n+\n+    /// Reverse the list's elements in place. O(n).\n+    fn reverse() {\n+        let temp = new_dlist::<T>();\n+        while !self.is_empty() {\n+            let nobe = self.pop_n().get();\n+            nobe.linked = true; // meh, kind of disorganised.\n+            temp.add_head(some(nobe));\n+        }\n+        self.hd   = temp.hd;\n+        self.tl   = temp.tl;\n+        self.size = temp.size;\n+    }\n+\n+    /// Iterate over nodes.\n+    pure fn each_node(f: fn(dlist_node<T>) -> bool) {\n+        let mut link = self.peek_n();\n+        while link.is_some() {\n+            let nobe = link.get();\n+            if !f(nobe) { break; }\n+            link = nobe.next_link();\n+        }\n+    }\n+\n     /// Check data structure integrity. O(n).\n     fn assert_consistent() {\n         if option::is_none(self.hd) || option::is_none(self.tl) {\n@@ -316,9 +398,7 @@ impl extensions<T> for dlist<T> {\n         let mut rabbit = link;\n         while option::is_some(link) {\n             let nobe = option::get(link);\n-            // check self on this list\n-            assert option::is_some(nobe.root) &&\n-                box::ptr_eq(*option::get(nobe.root), *self);\n+            assert nobe.linked;\n             // check cycle\n             if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n             if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n@@ -335,9 +415,7 @@ impl extensions<T> for dlist<T> {\n         rabbit = link;\n         while option::is_some(link) {\n             let nobe = option::get(link);\n-            // check self on this list\n-            assert option::is_some(nobe.root) &&\n-                box::ptr_eq(*option::get(nobe.root), *self);\n+            assert nobe.linked;\n             // check cycle\n             if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n             if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n@@ -353,25 +431,173 @@ impl extensions<T> for dlist<T> {\n }\n \n impl extensions<T: copy> for dlist<T> {\n-    /// Remove data from the head of the list. O(1).\n-    fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n-    /// Remove data from the tail of the list. O(1).\n-    fn pop_tail()  -> option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n     /// Get data at the list's head. O(1).\n-    fn peek()      -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n+    pure fn peek() -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n     /// Get data at the list's tail. O(1).\n-    fn peek_tail() -> option<T> { self.peek_tail_n().map (|nobe| nobe.data) }\n+    pure fn peek_tail() -> option<T> {\n+        self.peek_tail_n().map (|nobe| nobe.data)\n+    }\n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head() -> T         { self.head_n().data }\n+    pure fn head() -> T { self.head_n().data }\n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail() -> T         { self.tail_n().data }\n+    pure fn tail() -> T { self.tail_n().data }\n+    /// Get the elements of the list as a vector. O(n).\n+    pure fn to_vec() -> ~[mut T] {\n+        let mut v = ~[mut];\n+        unchecked {\n+            vec::reserve(v, self.size);\n+            // Take this out of the unchecked when iter's functions are pure\n+            for self.eachi |index,data| {\n+                v[index] = data;\n+            }\n+        }\n+        v\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n+    #[test]\n+    fn test_dlist_concat() {\n+        let a = from_vec(~[1,2]);\n+        let b = from_vec(~[3,4]);\n+        let c = from_vec(~[5,6]);\n+        let d = from_vec(~[7,8]);\n+        let ab = from_vec(~[a,b]);\n+        let cd = from_vec(~[c,d]);\n+        let abcd = concat(concat(from_vec(~[ab,cd])));\n+        abcd.assert_consistent(); assert abcd.len() == 8;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 1;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 2;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 3;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 4;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 5;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 6;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 7;\n+        abcd.assert_consistent(); assert abcd.pop().get() == 8;\n+        abcd.assert_consistent(); assert abcd.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_append() {\n+        let a = from_vec(~[1,2,3]);\n+        let b = from_vec(~[4,5,6]);\n+        a.append(b);\n+        assert a.len() == 6;\n+        assert b.len() == 0;\n+        b.assert_consistent();\n+        a.assert_consistent(); assert a.pop().get() == 1;\n+        a.assert_consistent(); assert a.pop().get() == 2;\n+        a.assert_consistent(); assert a.pop().get() == 3;\n+        a.assert_consistent(); assert a.pop().get() == 4;\n+        a.assert_consistent(); assert a.pop().get() == 5;\n+        a.assert_consistent(); assert a.pop().get() == 6;\n+        a.assert_consistent(); assert a.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_append_empty() {\n+        let a = from_vec(~[1,2,3]);\n+        let b = new_dlist::<int>();\n+        a.append(b);\n+        assert a.len() == 3;\n+        assert b.len() == 0;\n+        b.assert_consistent();\n+        a.assert_consistent(); assert a.pop().get() == 1;\n+        a.assert_consistent(); assert a.pop().get() == 2;\n+        a.assert_consistent(); assert a.pop().get() == 3;\n+        a.assert_consistent(); assert a.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_append_to_empty() {\n+        let a = new_dlist::<int>();\n+        let b = from_vec(~[4,5,6]);\n+        a.append(b);\n+        assert a.len() == 3;\n+        assert b.len() == 0;\n+        b.assert_consistent();\n+        a.assert_consistent(); assert a.pop().get() == 4;\n+        a.assert_consistent(); assert a.pop().get() == 5;\n+        a.assert_consistent(); assert a.pop().get() == 6;\n+        a.assert_consistent(); assert a.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_append_two_empty() {\n+        let a = new_dlist::<int>();\n+        let b = new_dlist::<int>();\n+        a.append(b);\n+        assert a.len() == 0;\n+        assert b.len() == 0;\n+        b.assert_consistent();\n+        a.assert_consistent();\n+    }\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_dlist_append_self() {\n+        let a = new_dlist::<int>();\n+        a.append(a);\n+    }\n+    #[test]\n+    #[ignore(cfg(windows))]\n+    #[should_fail]\n+    fn test_dlist_prepend_self() {\n+        let a = new_dlist::<int>();\n+        a.prepend(a);\n+    }\n+    #[test]\n+    fn test_dlist_prepend() {\n+        let a = from_vec(~[1,2,3]);\n+        let b = from_vec(~[4,5,6]);\n+        b.prepend(a);\n+        assert a.len() == 0;\n+        assert b.len() == 6;\n+        a.assert_consistent();\n+        b.assert_consistent(); assert b.pop().get() == 1;\n+        b.assert_consistent(); assert b.pop().get() == 2;\n+        b.assert_consistent(); assert b.pop().get() == 3;\n+        b.assert_consistent(); assert b.pop().get() == 4;\n+        b.assert_consistent(); assert b.pop().get() == 5;\n+        b.assert_consistent(); assert b.pop().get() == 6;\n+        b.assert_consistent(); assert b.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_reverse() {\n+        let a = from_vec(~[5,4,3,2,1]);\n+        a.reverse();\n+        assert a.len() == 5;\n+        a.assert_consistent(); assert a.pop().get() == 1;\n+        a.assert_consistent(); assert a.pop().get() == 2;\n+        a.assert_consistent(); assert a.pop().get() == 3;\n+        a.assert_consistent(); assert a.pop().get() == 4;\n+        a.assert_consistent(); assert a.pop().get() == 5;\n+        a.assert_consistent(); assert a.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_reverse_empty() {\n+        let a = new_dlist::<int>();\n+        a.reverse();\n+        assert a.len() == 0;\n+        a.assert_consistent();\n+    }\n+    #[test]\n+    fn test_dlist_each_node() {\n+        let a = from_vec(~[1,2,4,5]);\n+        for a.each_node |nobe| {\n+            if nobe.data > 3 {\n+                a.insert_before(3, nobe);\n+            }\n+        }\n+        assert a.len() == 6;\n+        a.assert_consistent(); assert a.pop().get() == 1;\n+        a.assert_consistent(); assert a.pop().get() == 2;\n+        a.assert_consistent(); assert a.pop().get() == 3;\n+        a.assert_consistent(); assert a.pop().get() == 4;\n+        a.assert_consistent(); assert a.pop().get() == 3;\n+        a.assert_consistent(); assert a.pop().get() == 5;\n+        a.assert_consistent(); assert a.is_empty();\n+    }\n     #[test]\n     fn test_dlist_is_empty() {\n-        let empty = create::<int>();\n+        let empty = new_dlist::<int>();\n         let full1 = from_vec(~[1,2,3]);\n         assert empty.is_empty();\n         assert !full1.is_empty();\n@@ -413,7 +639,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_push() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.push(1);\n         assert l.head() == 1;\n         assert l.tail() == 1;\n@@ -427,7 +653,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_push_head() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.push_head(3);\n         assert l.head() == 3;\n         assert l.tail() == 3;\n@@ -456,7 +682,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_head() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n@@ -471,7 +697,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_mid() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n@@ -486,7 +712,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_tail() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n@@ -501,7 +727,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_one_two() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let _three = l.push_n(3);\n@@ -517,7 +743,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_one_three() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n@@ -532,7 +758,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_two_three() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n@@ -547,7 +773,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_remove_all() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); let three = l.push_n(3);\n@@ -560,10 +786,10 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_insert_n_before() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n-        l.assert_consistent(); let three = create_node(3);\n+        l.assert_consistent(); let three = new_dlist_node(3);\n         l.assert_consistent(); assert l.len() == 2;\n         l.assert_consistent(); l.insert_n_before(three, two);\n         l.assert_consistent(); assert l.len() == 3;\n@@ -576,10 +802,10 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_insert_n_after() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n-        l.assert_consistent(); let three = create_node(3);\n+        l.assert_consistent(); let three = new_dlist_node(3);\n         l.assert_consistent(); assert l.len() == 2;\n         l.assert_consistent(); l.insert_n_after(three, one);\n         l.assert_consistent(); assert l.len() == 3;\n@@ -592,7 +818,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_insert_before_head() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let one = l.push_n(1);\n         l.assert_consistent(); let _two = l.push_n(2);\n         l.assert_consistent(); assert l.len() == 2;\n@@ -607,7 +833,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_insert_after_tail() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         l.assert_consistent(); let _one = l.push_n(1);\n         l.assert_consistent(); let two = l.push_n(2);\n         l.assert_consistent(); assert l.len() == 2;\n@@ -622,15 +848,15 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_asymmetric_link() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         let _one = l.push_n(1);\n         let two = l.push_n(2);\n         two.prev = none;\n         l.assert_consistent();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_cyclic_list() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let _two = l.push_n(2);\n         let three = l.push_n(3);\n@@ -640,34 +866,34 @@ mod tests {\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_headless() {\n-        create::<int>().head();\n+        new_dlist::<int>().head();\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_insert_already_present_before() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_before(two, one);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_insert_already_present_after() {\n-        let l = create::<int>();\n+        let l = new_dlist::<int>();\n         let one = l.push_n(1);\n         let two = l.push_n(2);\n         l.insert_n_after(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_insert_before_orphan() {\n-        let l = create::<int>();\n-        let one = create_node(1);\n-        let two = create_node(2);\n+        let l = new_dlist::<int>();\n+        let one = new_dlist_node(1);\n+        let two = new_dlist_node(2);\n         l.insert_n_before(one, two);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_insert_after_orphan() {\n-        let l = create::<int>();\n-        let one = create_node(1);\n-        let two = create_node(2);\n+        let l = new_dlist::<int>();\n+        let one = new_dlist_node(1);\n+        let two = new_dlist_node(2);\n         l.insert_n_after(two, one);\n     }\n }"}, {"sha": "1cf7fb980cd22616bb0ba80fadc08cc3eec99650", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8e6d66280f7824e24021a15c7075ecdfbfd19b28/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6d66280f7824e24021a15c7075ecdfbfd19b28/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=8e6d66280f7824e24021a15c7075ecdfbfd19b28", "patch": "@@ -13,17 +13,17 @@ fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     let mut link = self.peek_n();\n     while option::is_some(link) {\n         let nobe = option::get(link);\n-        // Check dlist invariant.\n-        if !option::is_some(nobe.root) ||\n-           !box::ptr_eq(*option::get(nobe.root), *self) {\n-            fail ~\"Iteration encountered a dlist node not on this dlist.\"\n-        }\n+        assert nobe.linked;\n         if !f(nobe.data) { break; }\n-        // Check that the user didn't do a remove.\n-        // Note that this makes it ok for the user to remove the node and then\n-        // immediately put it back in a different position. I allow this.\n-        if !option::is_some(nobe.root) ||\n-           !box::ptr_eq(*option::get(nobe.root), *self) {\n+        // Check (weakly) that the user didn't do a remove.\n+        if self.size == 0 {\n+            fail ~\"The dlist became empty during iteration??\"\n+        }\n+        if !nobe.linked ||\n+           (!((nobe.prev.is_some()\n+               || box::ptr_eq(*self.hd.expect(~\"headless dlist?\"), *nobe)) &&\n+              (nobe.next.is_some()\n+               || box::ptr_eq(*self.tl.expect(~\"tailless dlist?\"), *nobe)))) {\n             fail ~\"Removing a dlist node during iteration is forbidden!\"\n         }\n         link = nobe.next_link();"}]}