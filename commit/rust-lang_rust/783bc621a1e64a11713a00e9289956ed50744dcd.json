{"sha": "783bc621a1e64a11713a00e9289956ed50744dcd", "node_id": "C_kwDOAAsO6NoAKDc4M2JjNjIxYTFlNjRhMTE3MTNhMDBlOTI4OTk1NmVkNTA3NDRkY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T15:24:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-05T15:24:36Z"}, "message": "Auto merge of #10438 - Jarcho:use_snip_ctxt, r=dswij\n\nUse `snippet_with_context` more\n\nNo tests at the moment. Need to find a way to write macro tests without writing a pile of macros.\n\nchangelog: None", "tree": {"sha": "55b907520626e9b129bb91c8203e6bcbb2000250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55b907520626e9b129bb91c8203e6bcbb2000250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/783bc621a1e64a11713a00e9289956ed50744dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/783bc621a1e64a11713a00e9289956ed50744dcd", "html_url": "https://github.com/rust-lang/rust/commit/783bc621a1e64a11713a00e9289956ed50744dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/783bc621a1e64a11713a00e9289956ed50744dcd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70e85d146fee03c09e28a02c9c18d56e74254f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/70e85d146fee03c09e28a02c9c18d56e74254f3c", "html_url": "https://github.com/rust-lang/rust/commit/70e85d146fee03c09e28a02c9c18d56e74254f3c"}, {"sha": "efbcb99b73d3180f6d667fdad2efdbe6317c30d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbcb99b73d3180f6d667fdad2efdbe6317c30d4", "html_url": "https://github.com/rust-lang/rust/commit/efbcb99b73d3180f6d667fdad2efdbe6317c30d4"}], "stats": {"total": 288, "additions": 159, "deletions": 129}, "files": [{"sha": "1233c632a7948b6f2487548fbbe6b675c0a48d56", "filename": "clippy_lints/src/casts/cast_slice_from_raw_parts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_from_raw_parts.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -34,15 +34,17 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>,\n         if let ExprKind::Path(ref qpath) = fun.kind;\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if let Some(rpk) = raw_parts_kind(cx, fun_def_id);\n+        let ctxt = expr.span.ctxt();\n+        if cast_expr.span.ctxt() == ctxt;\n         then {\n             let func = match rpk {\n                 RawPartsKind::Immutable => \"from_raw_parts\",\n                 RawPartsKind::Mutable => \"from_raw_parts_mut\"\n             };\n             let span = expr.span;\n             let mut applicability = Applicability::MachineApplicable;\n-            let ptr = snippet_with_applicability(cx, ptr_arg.span, \"ptr\", &mut applicability);\n-            let len = snippet_with_applicability(cx, len_arg.span, \"len\", &mut applicability);\n+            let ptr = snippet_with_context(cx, ptr_arg.span, ctxt, \"ptr\", &mut applicability).0;\n+            let len = snippet_with_context(cx, len_arg.span, ctxt, \"len\", &mut applicability).0;\n             span_lint_and_sugg(\n                 cx,\n                 CAST_SLICE_FROM_RAW_PARTS,"}, {"sha": "f296b80d283d8025c52cd1ad6b053862a138f34d", "filename": "clippy_lints/src/default_instead_of_iter_empty.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_instead_of_iter_empty.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::last_path_segment;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::{match_def_path, paths};\n use rustc_errors::Applicability;\n use rustc_hir::{def, Expr, ExprKind, GenericArg, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::SyntaxContext;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -38,9 +39,11 @@ impl<'tcx> LateLintPass<'tcx> for DefaultIterEmpty {\n             && let QPath::Resolved(None, path) = ty_path\n             && let def::Res::Def(_, def_id) = &path.res\n             && match_def_path(cx, *def_id, &paths::ITER_EMPTY)\n+            && let ctxt = expr.span.ctxt()\n+            && ty.span.ctxt() == ctxt\n         {\n             let mut applicability = Applicability::MachineApplicable;\n-            let sugg = make_sugg(cx, ty_path, &mut applicability);\n+            let sugg = make_sugg(cx, ty_path, ctxt, &mut applicability);\n             span_lint_and_sugg(\n                 cx,\n                 DEFAULT_INSTEAD_OF_ITER_EMPTY,\n@@ -54,14 +57,19 @@ impl<'tcx> LateLintPass<'tcx> for DefaultIterEmpty {\n     }\n }\n \n-fn make_sugg(cx: &LateContext<'_>, ty_path: &rustc_hir::QPath<'_>, applicability: &mut Applicability) -> String {\n+fn make_sugg(\n+    cx: &LateContext<'_>,\n+    ty_path: &rustc_hir::QPath<'_>,\n+    ctxt: SyntaxContext,\n+    applicability: &mut Applicability,\n+) -> String {\n     if let Some(last) = last_path_segment(ty_path).args\n         && let Some(iter_ty) = last.args.iter().find_map(|arg| match arg {\n             GenericArg::Type(ty) => Some(ty),\n             _ => None,\n         })\n     {\n-        format!(\"std::iter::empty::<{}>()\", snippet_with_applicability(cx, iter_ty.span, \"..\", applicability))\n+        format!(\"std::iter::empty::<{}>()\", snippet_with_context(cx, iter_ty.span, ctxt, \"..\", applicability).0)\n     } else {\n         \"std::iter::empty()\".to_owned()\n     }"}, {"sha": "8040938c6263ed64b7606b1eed9fff682cfdcd73", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::{root_macro_call_first_node, FormatArgsExpn};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -84,9 +84,9 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                         _ => false,\n                     };\n                     let sugg = if is_new_string {\n-                        snippet_with_applicability(cx, value.span, \"..\", &mut applicability).into_owned()\n+                        snippet_with_context(cx, value.span, call_site.ctxt(), \"..\", &mut applicability).0.into_owned()\n                     } else {\n-                        let sugg = Sugg::hir_with_applicability(cx, value, \"<arg>\", &mut applicability);\n+                        let sugg = Sugg::hir_with_context(cx, value, call_site.ctxt(), \"<arg>\", &mut applicability);\n                         format!(\"{}.to_string()\", sugg.maybe_par())\n                     };\n                     span_useless_format(cx, call_site, sugg, applicability);"}, {"sha": "57e6caa8711165e32d5c3c43e0177af54a918678", "filename": "clippy_lints/src/implicit_saturating_add.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_add.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::get_parent_expr;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use if_chain::if_chain;\n use rustc_ast::ast::{LitIntType, LitKind};\n use rustc_errors::Applicability;\n@@ -55,15 +55,25 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingAdd {\n             if let ExprKind::AssignOp(op1, target, value) = ex.kind;\n             let ty = cx.typeck_results().expr_ty(target);\n             if Some(c) == get_int_max(ty);\n+            let ctxt = expr.span.ctxt();\n+            if ex.span.ctxt() == ctxt;\n+            if expr1.span.ctxt() == ctxt;\n             if clippy_utils::SpanlessEq::new(cx).eq_expr(l, target);\n             if BinOpKind::Add == op1.node;\n             if let ExprKind::Lit(ref lit) = value.kind;\n             if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n             if block.expr.is_none();\n             then {\n                 let mut app = Applicability::MachineApplicable;\n-                let code = snippet_with_applicability(cx, target.span, \"_\", &mut app);\n-                let sugg = if let Some(parent) = get_parent_expr(cx, expr) && let ExprKind::If(_cond, _then, Some(else_)) = parent.kind && else_.hir_id == expr.hir_id {format!(\"{{{code} = {code}.saturating_add(1); }}\")} else {format!(\"{code} = {code}.saturating_add(1);\")};\n+                let code = snippet_with_context(cx, target.span, ctxt, \"_\", &mut app).0;\n+                let sugg = if let Some(parent) = get_parent_expr(cx, expr)\n+                    && let ExprKind::If(_cond, _then, Some(else_)) = parent.kind\n+                    && else_.hir_id == expr.hir_id\n+                {\n+                    format!(\"{{{code} = {code}.saturating_add(1); }}\")\n+                } else {\n+                    format!(\"{code} = {code}.saturating_add(1);\")\n+                };\n                 span_lint_and_sugg(cx, IMPLICIT_SATURATING_ADD, expr.span, \"manual saturating add detected\", \"use instead\", sugg, app);\n             }\n         }"}, {"sha": "34e9991582c0160b17adb6750e87567cef77320c", "filename": "clippy_lints/src/instant_subtraction.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Finstant_subtraction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Finstant_subtraction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finstant_subtraction.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{self, span_lint_and_sugg};\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::source;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty;\n use rustc_errors::Applicability;\n@@ -161,14 +161,9 @@ fn print_unchecked_duration_subtraction_sugg(\n ) {\n     let mut applicability = Applicability::MachineApplicable;\n \n-    let left_expr =\n-        source::snippet_with_applicability(cx, left_expr.span, \"std::time::Instant::now()\", &mut applicability);\n-    let right_expr = source::snippet_with_applicability(\n-        cx,\n-        right_expr.span,\n-        \"std::time::Duration::from_secs(1)\",\n-        &mut applicability,\n-    );\n+    let ctxt = expr.span.ctxt();\n+    let left_expr = snippet_with_context(cx, left_expr.span, ctxt, \"<instant>\", &mut applicability).0;\n+    let right_expr = snippet_with_context(cx, right_expr.span, ctxt, \"<duration>\", &mut applicability).0;\n \n     diagnostics::span_lint_and_sugg(\n         cx,"}, {"sha": "6c32393dc0136186ff2389c9999e896b43de4789", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,13 +1,13 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_item_name, get_parent_as_impl, is_lint_allowed, peel_ref_operators};\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::{get_item_name, get_parent_as_impl, is_lint_allowed, peel_ref_operators, sugg::Sugg};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefIdSet;\n use rustc_hir::{\n     def_id::DefId, AssocItemKind, BinOpKind, Expr, ExprKind, FnRetTy, ImplItem, ImplItemKind, ImplicitSelfKind, Item,\n-    ItemKind, Mutability, Node, TraitItemRef, TyKind, UnOp,\n+    ItemKind, Mutability, Node, TraitItemRef, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, AssocKind, FnSig, Ty};\n@@ -16,7 +16,6 @@ use rustc_span::{\n     source_map::{Span, Spanned, Symbol},\n     symbol::sym,\n };\n-use std::borrow::Cow;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -431,7 +430,7 @@ fn check_len(\n                 &format!(\"using `{op}is_empty` is clearer and more explicit\"),\n                 format!(\n                     \"{op}{}.is_empty()\",\n-                    snippet_with_applicability(cx, receiver.span, \"_\", &mut applicability)\n+                    snippet_with_context(cx, receiver.span, span.ctxt(), \"_\", &mut applicability).0,\n                 ),\n                 applicability,\n             );\n@@ -444,13 +443,7 @@ fn check_empty_expr(cx: &LateContext<'_>, span: Span, lit1: &Expr<'_>, lit2: &Ex\n         let mut applicability = Applicability::MachineApplicable;\n \n         let lit1 = peel_ref_operators(cx, lit1);\n-        let mut lit_str = snippet_with_applicability(cx, lit1.span, \"_\", &mut applicability);\n-\n-        // Wrap the expression in parentheses if it's a deref expression. Otherwise operator precedence will\n-        // cause the code to dereference boolean(won't compile).\n-        if let ExprKind::Unary(UnOp::Deref, _) = lit1.kind {\n-            lit_str = Cow::from(format!(\"({lit_str})\"));\n-        }\n+        let lit_str = Sugg::hir_with_context(cx, lit1, span.ctxt(), \"_\", &mut applicability).maybe_par();\n \n         span_lint_and_sugg(\n             cx,"}, {"sha": "bc815dc4a260ae8327940778a893235c3eb899e2", "filename": "clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_bits.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::get_parent_expr;\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, GenericArg, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::sym;\n@@ -55,13 +56,17 @@ impl<'tcx> LateLintPass<'tcx> for ManualBits {\n         if_chain! {\n             if let ExprKind::Binary(bin_op, left_expr, right_expr) = expr.kind;\n             if let BinOpKind::Mul = &bin_op.node;\n+            if !in_external_macro(cx.sess(), expr.span);\n+            let ctxt = expr.span.ctxt();\n+            if left_expr.span.ctxt() == ctxt;\n+            if right_expr.span.ctxt() == ctxt;\n             if let Some((real_ty, resolved_ty, other_expr)) = get_one_size_of_ty(cx, left_expr, right_expr);\n             if matches!(resolved_ty.kind(), ty::Int(_) | ty::Uint(_));\n             if let ExprKind::Lit(lit) = &other_expr.kind;\n             if let LitKind::Int(8, _) = lit.node;\n             then {\n                 let mut app = Applicability::MachineApplicable;\n-                let ty_snip = snippet_with_applicability(cx, real_ty.span, \"..\", &mut app);\n+                let ty_snip = snippet_with_context(cx, real_ty.span, ctxt, \"..\", &mut app).0;\n                 let sugg = create_sugg(cx, expr, format!(\"{ty_snip}::BITS\"));\n \n                 span_lint_and_sugg("}, {"sha": "31264261f5dbd7032dbceaa502e5bb3737a2d73c", "filename": "clippy_lints/src/manual_is_ascii_check.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_is_ascii_check.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::{diagnostics::span_lint_and_sugg, higher, in_constant, macros::root_macro_call, source::snippet};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, higher, in_constant, macros::root_macro_call, sugg::Sugg};\n use rustc_ast::ast::RangeLimits;\n use rustc_ast::LitKind::{Byte, Char};\n use rustc_errors::Applicability;\n@@ -115,15 +115,8 @@ fn check_is_ascii(cx: &LateContext<'_>, span: Span, recv: &Expr<'_>, range: &Cha\n         CharRange::Otherwise => None,\n     } {\n         let default_snip = \"..\";\n-        // `snippet_with_applicability` may set applicability to `MaybeIncorrect` for\n-        // macro span, so we check applicability manually by comparing `recv` is not default.\n-        let recv = snippet(cx, recv.span, default_snip);\n-\n-        let applicability = if recv == default_snip {\n-            Applicability::HasPlaceholders\n-        } else {\n-            Applicability::MachineApplicable\n-        };\n+        let mut app = Applicability::MachineApplicable;\n+        let recv = Sugg::hir_with_context(cx, recv, span.ctxt(), default_snip, &mut app).maybe_par();\n \n         span_lint_and_sugg(\n             cx,\n@@ -132,7 +125,7 @@ fn check_is_ascii(cx: &LateContext<'_>, span: Span, recv: &Expr<'_>, range: &Cha\n             \"manual check for common ascii range\",\n             \"try\",\n             format!(\"{recv}.{sugg}()\"),\n-            applicability,\n+            app,\n         );\n     }\n }"}, {"sha": "aafee92713fe1fd1b9b8e501682f67b487a97e7b", "filename": "clippy_lints/src/manual_rem_euclid.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_rem_euclid.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::consts::{constant_full_int, FullInt};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::msrvs::{self, Msrv};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::{in_constant, path_to_local};\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, Node, TyKind};\n@@ -60,12 +60,16 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n             return;\n         }\n \n+        // (x % c + c) % c\n         if let ExprKind::Binary(op1, expr1, right) = expr.kind\n             && op1.node == BinOpKind::Rem\n+            && let ctxt = expr.span.ctxt()\n+            && expr1.span.ctxt() == ctxt\n             && let Some(const1) = check_for_unsigned_int_constant(cx, right)\n             && let ExprKind::Binary(op2, left, right) = expr1.kind\n             && op2.node == BinOpKind::Add\n             && let Some((const2, expr2)) = check_for_either_unsigned_int_constant(cx, left, right)\n+            && expr2.span.ctxt() == ctxt\n             && let ExprKind::Binary(op3, expr3, right) = expr2.kind\n             && op3.node == BinOpKind::Rem\n             && let Some(const3) = check_for_unsigned_int_constant(cx, right)\n@@ -86,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualRemEuclid {\n                 };\n \n                 let mut app = Applicability::MachineApplicable;\n-                let rem_of = snippet_with_applicability(cx, expr3.span, \"_\", &mut app);\n+                let rem_of = snippet_with_context(cx, expr3.span, ctxt, \"_\", &mut app).0;\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_REM_EUCLID,"}, {"sha": "6ec9784038c378ddd41eb823b51a49d7ad808d74", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::method_chain_args;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::is_res_lang_ctor;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, PatKind, QPath};\n+use rustc_hir::{Expr, ExprKind, LangItem, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -58,17 +58,18 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n             };\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ok_path, result_types_0, ..) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n-            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n-            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);\n-            if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n-\n+            if let ExprKind::MethodCall(ok_path, recv, [], ..) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(ref pat_path, [ok_pat], _)  = let_pat.kind; //get operation\n+            if ok_path.ident.as_str() == \"ok\";\n+            if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(recv), sym::Result);\n+            if is_res_lang_ctor(cx, cx.qpath_res(pat_path, let_pat.hir_id), LangItem::OptionSome);\n+            let ctxt = expr.span.ctxt();\n+            if let_expr.span.ctxt() == ctxt;\n+            if let_pat.span.ctxt() == ctxt;\n             then {\n-\n                 let mut applicability = Applicability::MachineApplicable;\n-                let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_path.ident.span), \"\", &mut applicability);\n+                let some_expr_string = snippet_with_context(cx, ok_pat.span, ctxt, \"\", &mut applicability).0;\n+                let trimmed_ok = snippet_with_context(cx, recv.span, ctxt, \"\", &mut applicability).0;\n                 let sugg = format!(\n                     \"{ifwhile} let Ok({some_expr_string}) = {}\",\n                     trimmed_ok.trim().trim_end_matches('.'),"}, {"sha": "ed3e2c6e7f49248a5fd212f71b64ac2ba9019238", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{self, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg::has_enclosing_paren;\n use if_chain::if_chain;\n use rustc_ast::util::parser::PREC_PREFIX;\n@@ -60,8 +60,8 @@ fn check_mul(cx: &LateContext<'_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n \n         then {\n             let mut applicability = Applicability::MachineApplicable;\n-            let snip = snippet_with_applicability(cx, exp.span, \"..\", &mut applicability);\n-            let suggestion = if exp.precedence().order() < PREC_PREFIX && !has_enclosing_paren(&snip) {\n+            let (snip, from_macro) = snippet_with_context(cx, exp.span, span.ctxt(), \"..\", &mut applicability);\n+            let suggestion = if !from_macro && exp.precedence().order() < PREC_PREFIX && !has_enclosing_paren(&snip) {\n                 format!(\"-({snip})\")\n             } else {\n                 format!(\"-{snip}\")"}, {"sha": "e1de494eb41c03411d729dbfb3e2743833c91242", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -53,6 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                             || is_type_diagnostic_item(cx, obj_ty, sym::DirBuilder)))\n                         || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n                     if let ExprKind::Lit(_) = param.kind;\n+                    if param.span.ctxt() == expr.span.ctxt();\n \n                     then {\n                         let Some(snip) = snippet_opt(cx, param.span) else {\n@@ -71,6 +72,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                     if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n                     if match_def_path(cx, def_id, &paths::PERMISSIONS_FROM_MODE);\n                     if let ExprKind::Lit(_) = param.kind;\n+                    if param.span.ctxt() == expr.span.ctxt();\n                     if let Some(snip) = snippet_opt(cx, param.span);\n                     if !snip.starts_with(\"0o\");\n                     then {"}, {"sha": "1aeac724ab13885ef09ebcfc46f9f9fb3a62abf3", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 64, "deletions": 47, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{can_mut_borrow_both, eq_expr_value, in_constant, std_or_core};\n@@ -10,6 +10,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n+use rustc_span::SyntaxContext;\n use rustc_span::{sym, symbol::Ident, Span};\n \n declare_clippy_lint! {\n@@ -80,43 +81,45 @@ impl<'tcx> LateLintPass<'tcx> for Swap {\n }\n \n fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, span: Span, is_xor_based: bool) {\n+    let ctxt = span.ctxt();\n     let mut applicability = Applicability::MachineApplicable;\n \n     if !can_mut_borrow_both(cx, e1, e2) {\n-        if let ExprKind::Index(lhs1, idx1) = e1.kind {\n-            if let ExprKind::Index(lhs2, idx2) = e2.kind {\n-                if eq_expr_value(cx, lhs1, lhs2) {\n-                    let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n+        if let ExprKind::Index(lhs1, idx1) = e1.kind\n+            && let ExprKind::Index(lhs2, idx2) = e2.kind\n+            && eq_expr_value(cx, lhs1, lhs2)\n+            && e1.span.ctxt() == ctxt\n+            && e2.span.ctxt() == ctxt\n+        {\n+            let ty = cx.typeck_results().expr_ty(lhs1).peel_refs();\n \n-                    if matches!(ty.kind(), ty::Slice(_))\n-                        || matches!(ty.kind(), ty::Array(_, _))\n-                        || is_type_diagnostic_item(cx, ty, sym::Vec)\n-                        || is_type_diagnostic_item(cx, ty, sym::VecDeque)\n-                    {\n-                        let slice = Sugg::hir_with_applicability(cx, lhs1, \"<slice>\", &mut applicability);\n-                        span_lint_and_sugg(\n-                            cx,\n-                            MANUAL_SWAP,\n-                            span,\n-                            &format!(\"this looks like you are swapping elements of `{slice}` manually\"),\n-                            \"try\",\n-                            format!(\n-                                \"{}.swap({}, {})\",\n-                                slice.maybe_par(),\n-                                snippet_with_applicability(cx, idx1.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, idx2.span, \"..\", &mut applicability),\n-                            ),\n-                            applicability,\n-                        );\n-                    }\n-                }\n+            if matches!(ty.kind(), ty::Slice(_))\n+                || matches!(ty.kind(), ty::Array(_, _))\n+                || is_type_diagnostic_item(cx, ty, sym::Vec)\n+                || is_type_diagnostic_item(cx, ty, sym::VecDeque)\n+            {\n+                let slice = Sugg::hir_with_applicability(cx, lhs1, \"<slice>\", &mut applicability);\n+                span_lint_and_sugg(\n+                    cx,\n+                    MANUAL_SWAP,\n+                    span,\n+                    &format!(\"this looks like you are swapping elements of `{slice}` manually\"),\n+                    \"try\",\n+                    format!(\n+                        \"{}.swap({}, {});\",\n+                        slice.maybe_par(),\n+                        snippet_with_context(cx, idx1.span, ctxt, \"..\", &mut applicability).0,\n+                        snippet_with_context(cx, idx2.span, ctxt, \"..\", &mut applicability).0,\n+                    ),\n+                    applicability,\n+                );\n             }\n         }\n         return;\n     }\n \n-    let first = Sugg::hir_with_applicability(cx, e1, \"..\", &mut applicability);\n-    let second = Sugg::hir_with_applicability(cx, e2, \"..\", &mut applicability);\n+    let first = Sugg::hir_with_context(cx, e1, ctxt, \"..\", &mut applicability);\n+    let second = Sugg::hir_with_context(cx, e2, ctxt, \"..\", &mut applicability);\n     let Some(sugg) = std_or_core(cx) else { return };\n \n     span_lint_and_then(\n@@ -128,7 +131,7 @@ fn generate_swap_warning(cx: &LateContext<'_>, e1: &Expr<'_>, e2: &Expr<'_>, spa\n             diag.span_suggestion(\n                 span,\n                 \"try\",\n-                format!(\"{sugg}::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()),\n+                format!(\"{sugg}::mem::swap({}, {});\", first.mut_addr(), second.mut_addr()),\n                 applicability,\n             );\n             if !is_xor_based {\n@@ -144,28 +147,35 @@ fn check_manual_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n         return;\n     }\n \n-    for w in block.stmts.windows(3) {\n+    for [s1, s2, s3] in block.stmts.array_windows::<3>() {\n         if_chain! {\n             // let t = foo();\n-            if let StmtKind::Local(tmp) = w[0].kind;\n+            if let StmtKind::Local(tmp) = s1.kind;\n             if let Some(tmp_init) = tmp.init;\n             if let PatKind::Binding(.., ident, None) = tmp.pat.kind;\n \n             // foo() = bar();\n-            if let StmtKind::Semi(first) = w[1].kind;\n+            if let StmtKind::Semi(first) = s2.kind;\n             if let ExprKind::Assign(lhs1, rhs1, _) = first.kind;\n \n             // bar() = t;\n-            if let StmtKind::Semi(second) = w[2].kind;\n+            if let StmtKind::Semi(second) = s3.kind;\n             if let ExprKind::Assign(lhs2, rhs2, _) = second.kind;\n             if let ExprKind::Path(QPath::Resolved(None, rhs2)) = rhs2.kind;\n             if rhs2.segments.len() == 1;\n \n             if ident.name == rhs2.segments[0].ident.name;\n             if eq_expr_value(cx, tmp_init, lhs1);\n             if eq_expr_value(cx, rhs1, lhs2);\n+\n+            let ctxt = s1.span.ctxt();\n+            if s2.span.ctxt() == ctxt;\n+            if s3.span.ctxt() == ctxt;\n+            if first.span.ctxt() == ctxt;\n+            if second.span.ctxt() == ctxt;\n+\n             then {\n-                let span = w[0].span.to(second.span);\n+                let span = s1.span.to(s3.span);\n                 generate_swap_warning(cx, lhs1, lhs2, span, false);\n             }\n         }\n@@ -246,37 +256,44 @@ fn parse<'a, 'hir>(stmt: &'a Stmt<'hir>) -> Option<(ExprOrIdent<'hir>, &'a Expr<\n \n /// Implementation of the xor case for `MANUAL_SWAP` lint.\n fn check_xor_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n-    for window in block.stmts.windows(3) {\n+    for [s1, s2, s3] in block.stmts.array_windows::<3>() {\n         if_chain! {\n-            if let Some((lhs0, rhs0)) = extract_sides_of_xor_assign(&window[0]);\n-            if let Some((lhs1, rhs1)) = extract_sides_of_xor_assign(&window[1]);\n-            if let Some((lhs2, rhs2)) = extract_sides_of_xor_assign(&window[2]);\n+            let ctxt = s1.span.ctxt();\n+            if let Some((lhs0, rhs0)) = extract_sides_of_xor_assign(s1, ctxt);\n+            if let Some((lhs1, rhs1)) = extract_sides_of_xor_assign(s2, ctxt);\n+            if let Some((lhs2, rhs2)) = extract_sides_of_xor_assign(s3, ctxt);\n             if eq_expr_value(cx, lhs0, rhs1);\n             if eq_expr_value(cx, lhs2, rhs1);\n             if eq_expr_value(cx, lhs1, rhs0);\n             if eq_expr_value(cx, lhs1, rhs2);\n+            if s2.span.ctxt() == ctxt;\n+            if s3.span.ctxt() == ctxt;\n             then {\n-                let span = window[0].span.to(window[2].span);\n+                let span = s1.span.to(s3.span);\n                 generate_swap_warning(cx, lhs0, rhs0, span, true);\n             }\n         };\n     }\n }\n \n /// Returns the lhs and rhs of an xor assignment statement.\n-fn extract_sides_of_xor_assign<'a, 'hir>(stmt: &'a Stmt<'hir>) -> Option<(&'a Expr<'hir>, &'a Expr<'hir>)> {\n-    if let StmtKind::Semi(expr) = stmt.kind {\n-        if let ExprKind::AssignOp(\n+fn extract_sides_of_xor_assign<'a, 'hir>(\n+    stmt: &'a Stmt<'hir>,\n+    ctxt: SyntaxContext,\n+) -> Option<(&'a Expr<'hir>, &'a Expr<'hir>)> {\n+    if let StmtKind::Semi(expr) = stmt.kind\n+        && let ExprKind::AssignOp(\n             Spanned {\n                 node: BinOpKind::BitXor,\n                 ..\n             },\n             lhs,\n             rhs,\n         ) = expr.kind\n-        {\n-            return Some((lhs, rhs));\n-        }\n+        && expr.span.ctxt() == ctxt\n+    {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n     }\n-    None\n }"}, {"sha": "10ae1ee5245eb852f6bfe15997718dc4274718f4", "filename": "tests/ui/match_result_ok.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fmatch_result_ok.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fmatch_result_ok.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_result_ok.fixed?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -16,7 +16,7 @@ fn str_to_int_ok(x: &str) -> i32 {\n #[rustfmt::skip]\n fn strange_some_no_else(x: &str) -> i32 {\n     {\n-        if let Ok(y) = x   .   parse()       {\n+        if let Ok(y) = x   .   parse()    {\n             return y;\n         };\n         0"}, {"sha": "cbdc56aa28c445db4767fb258c714a6c3bcca5fb", "filename": "tests/ui/match_result_ok.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fmatch_result_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fmatch_result_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_result_ok.stderr?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -18,7 +18,7 @@ LL |         if let Some(y) = x   .   parse()   .   ok   ()    {\n    |\n help: consider matching on `Ok(y)` and removing the call to `ok` instead\n    |\n-LL |         if let Ok(y) = x   .   parse()       {\n+LL |         if let Ok(y) = x   .   parse()    {\n    |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: matching on `Some` with `ok()` is redundant"}, {"sha": "04008c0d9b31ca696ff88efe7682bfeb7b43d300", "filename": "tests/ui/swap.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fswap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fswap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.fixed?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -65,19 +65,19 @@ fn xor_swap_locals() {\n     // This is an xor-based swap of local variables.\n     let mut a = 0;\n     let mut b = 1;\n-    std::mem::swap(&mut a, &mut b)\n+    std::mem::swap(&mut a, &mut b);\n }\n \n fn xor_field_swap() {\n     // This is an xor-based swap of fields in a struct.\n     let mut bar = Bar { a: 0, b: 1 };\n-    std::mem::swap(&mut bar.a, &mut bar.b)\n+    std::mem::swap(&mut bar.a, &mut bar.b);\n }\n \n fn xor_slice_swap() {\n     // This is an xor-based swap of a slice\n     let foo = &mut [1, 2];\n-    foo.swap(0, 1)\n+    foo.swap(0, 1);\n }\n \n fn xor_no_swap() {"}, {"sha": "825c9261e19837bc270a2d431c183798e913630f", "filename": "tests/ui/swap.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fswap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/783bc621a1e64a11713a00e9289956ed50744dcd/tests%2Fui%2Fswap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fswap.stderr?ref=783bc621a1e64a11713a00e9289956ed50744dcd", "patch": "@@ -4,7 +4,7 @@ error: this looks like you are swapping `bar.a` and `bar.b` manually\n LL | /     let temp = bar.a;\n LL | |     bar.a = bar.b;\n LL | |     bar.b = temp;\n-   | |________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+   | |_________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n    = note: `-D clippy::manual-swap` implied by `-D warnings`\n@@ -15,55 +15,55 @@ error: this looks like you are swapping elements of `foo` manually\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n-   | |_________________^ help: try: `foo.swap(0, 1)`\n+   | |__________________^ help: try: `foo.swap(0, 1);`\n \n error: this looks like you are swapping elements of `foo` manually\n   --> $DIR/swap.rs:46:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n-   | |_________________^ help: try: `foo.swap(0, 1)`\n+   | |__________________^ help: try: `foo.swap(0, 1);`\n \n error: this looks like you are swapping elements of `foo` manually\n   --> $DIR/swap.rs:65:5\n    |\n LL | /     let temp = foo[0];\n LL | |     foo[0] = foo[1];\n LL | |     foo[1] = temp;\n-   | |_________________^ help: try: `foo.swap(0, 1)`\n+   | |__________________^ help: try: `foo.swap(0, 1);`\n \n error: this looks like you are swapping `a` and `b` manually\n   --> $DIR/swap.rs:76:5\n    |\n LL | /     a ^= b;\n LL | |     b ^= a;\n LL | |     a ^= b;\n-   | |___________^ help: try: `std::mem::swap(&mut a, &mut b)`\n+   | |___________^ help: try: `std::mem::swap(&mut a, &mut b);`\n \n error: this looks like you are swapping `bar.a` and `bar.b` manually\n   --> $DIR/swap.rs:84:5\n    |\n LL | /     bar.a ^= bar.b;\n LL | |     bar.b ^= bar.a;\n LL | |     bar.a ^= bar.b;\n-   | |___________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b)`\n+   | |___________________^ help: try: `std::mem::swap(&mut bar.a, &mut bar.b);`\n \n error: this looks like you are swapping elements of `foo` manually\n   --> $DIR/swap.rs:92:5\n    |\n LL | /     foo[0] ^= foo[1];\n LL | |     foo[1] ^= foo[0];\n LL | |     foo[0] ^= foo[1];\n-   | |_____________________^ help: try: `foo.swap(0, 1)`\n+   | |_____________________^ help: try: `foo.swap(0, 1);`\n \n error: this looks like you are swapping `foo[0][1]` and `bar[1][0]` manually\n   --> $DIR/swap.rs:121:5\n    |\n LL | /     let temp = foo[0][1];\n LL | |     foo[0][1] = bar[1][0];\n LL | |     bar[1][0] = temp;\n-   | |____________________^ help: try: `std::mem::swap(&mut foo[0][1], &mut bar[1][0])`\n+   | |_____________________^ help: try: `std::mem::swap(&mut foo[0][1], &mut bar[1][0]);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n@@ -74,7 +74,7 @@ LL |       ; let t = a;\n    |  _______^\n LL | |     a = b;\n LL | |     b = t;\n-   | |_________^ help: try: `std::mem::swap(&mut a, &mut b)`\n+   | |__________^ help: try: `std::mem::swap(&mut a, &mut b);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n@@ -85,7 +85,7 @@ LL |       ; let t = c.0;\n    |  _______^\n LL | |     c.0 = a;\n LL | |     a = t;\n-   | |_________^ help: try: `std::mem::swap(&mut c.0, &mut a)`\n+   | |__________^ help: try: `std::mem::swap(&mut c.0, &mut a);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n@@ -95,7 +95,7 @@ error: this looks like you are swapping `b` and `a` manually\n LL | /     let t = b;\n LL | |     b = a;\n LL | |     a = t;\n-   | |_________^ help: try: `std::mem::swap(&mut b, &mut a)`\n+   | |__________^ help: try: `std::mem::swap(&mut b, &mut a);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n \n@@ -151,7 +151,7 @@ error: this looks like you are swapping `s.0.x` and `s.0.y` manually\n LL | /     let t = s.0.x;\n LL | |     s.0.x = s.0.y;\n LL | |     s.0.y = t;\n-   | |_____________^ help: try: `std::mem::swap(&mut s.0.x, &mut s.0.y)`\n+   | |______________^ help: try: `std::mem::swap(&mut s.0.x, &mut s.0.y);`\n    |\n    = note: or maybe you should use `std::mem::replace`?\n "}]}