{"sha": "f13c98034bff751cfb617409211f2beb9933818a", "node_id": "C_kwDOAAsO6NoAKGYxM2M5ODAzNGJmZjc1MWNmYjYxNzQwOTIxMWYyYmViOTkzMzgxOGE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-21T11:57:57Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-22T09:20:44Z"}, "message": "Make replace_derive_with_manual_impl work again", "tree": {"sha": "6756a39e23c422185b3dd198c2c143fc0d966128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6756a39e23c422185b3dd198c2c143fc0d966128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f13c98034bff751cfb617409211f2beb9933818a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f13c98034bff751cfb617409211f2beb9933818a", "html_url": "https://github.com/rust-lang/rust/commit/f13c98034bff751cfb617409211f2beb9933818a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f13c98034bff751cfb617409211f2beb9933818a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b", "html_url": "https://github.com/rust-lang/rust/commit/be3168dabe0b5ee3d7fed4a5e7133e5f2d4f3a4b"}], "stats": {"total": 248, "additions": 118, "deletions": 130}, "files": [{"sha": "423b46cc61802f731ddeee331fda44f7e99ab8aa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -1792,6 +1792,13 @@ impl MacroDef {\n         }\n     }\n \n+    pub fn is_builtin_derive(&self) -> bool {\n+        match self.id.kind {\n+            MacroDefKind::BuiltInAttr(exp, _) => exp.is_derive(),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_attr(&self) -> bool {\n         matches!(self.kind(), MacroKind::Attr)\n     }"}, {"sha": "8803dac0975375fe2b6c504436851055a0bd0602", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -386,6 +386,17 @@ impl MacroCallKind {\n             MacroCallKind::Derive { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n+            MacroCallKind::Attr { ast_id, is_derive: true, invoc_attr_index, .. } => {\n+                ast_id.with_value(ast_id.to_node(db)).map(|it| {\n+                    it.doc_comments_and_attrs()\n+                        .nth(*invoc_attr_index as usize)\n+                        .and_then(|it| match it {\n+                            Either::Left(attr) => Some(attr.syntax().clone()),\n+                            Either::Right(_) => None,\n+                        })\n+                        .unwrap_or_else(|| it.syntax().clone())\n+                })\n+            }\n             MacroCallKind::Attr { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }"}, {"sha": "f7326747253a0580eb1261e901f9fa4c52fb292e", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -3,8 +3,7 @@ use ide_db::{\n     helpers::{insert_whitespace_into_node::insert_ws_into, pick_best_token},\n     RootDatabase,\n };\n-use itertools::Itertools;\n-use syntax::{ast, ted, AstNode, SyntaxKind, SyntaxNode};\n+use syntax::{ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, T};\n \n use crate::FilePosition;\n \n@@ -52,7 +51,17 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         let token = hir::InFile::new(hir_file, descended).upmap(db)?.value;\n         let attr = token.ancestors().find_map(ast::Attr::cast)?;\n         let expansions = sema.expand_derive_macro(&attr)?;\n-        Some(ExpandedMacro { name, expansion: expansions.into_iter().map(insert_ws_into).join(\"\") })\n+        let idx = attr\n+            .token_tree()?\n+            .token_trees_and_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .take_while(|it| it == &token)\n+            .filter(|it| it.kind() == T![,])\n+            .count();\n+        Some(ExpandedMacro {\n+            name,\n+            expansion: expansions.get(idx).cloned().map(insert_ws_into)?.to_string(),\n+        })\n     });\n \n     if derive.is_some() {\n@@ -370,11 +379,9 @@ struct Foo {}\n struct Foo {}\n \"#,\n             expect![[r#\"\n-                Copy, Clone\n+                Copy\n                 impl < >core::marker::Copy for Foo< >{}\n \n-                impl < >core::clone::Clone for Foo< >{}\n-\n             \"#]],\n         );\n     }"}, {"sha": "9c0233b028f600c2ce86455f3affd0e8682736b5", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -3,7 +3,7 @@ use ide_db::helpers::{\n     insert_use::{insert_use, ImportScope},\n     mod_path_to_ast,\n };\n-use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxElement};\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxElement};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists, GroupLabel};\n \n@@ -139,9 +139,7 @@ pub(super) fn find_importable_node(ctx: &AssistContext) -> Option<(ImportAssets,\n     {\n         ImportAssets::for_ident_pat(&ctx.sema, &pat).zip(Some(pat.syntax().clone().into()))\n     } else {\n-        // FIXME: Descend?\n-        let ident = ctx.find_token_at_offset()?;\n-        ImportAssets::for_derive_ident(&ctx.sema, &ident).zip(Some(ident.syntax().clone().into()))\n+        None\n     }\n }\n "}, {"sha": "8ac05bf5ff51c460ecfa750cd319d3f645159b64", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -1,13 +1,13 @@\n-use hir::ModuleDef;\n-use ide_db::helpers::insert_whitespace_into_node::insert_ws_into;\n-use ide_db::helpers::{\n-    get_path_at_cursor_in_tt, import_assets::NameToImport, mod_path_to_ast,\n-    parse_tt_as_comma_sep_paths,\n+use hir::{InFile, ModuleDef};\n+use ide_db::{\n+    helpers::{\n+        import_assets::NameToImport, insert_whitespace_into_node::insert_ws_into, mod_path_to_ast,\n+    },\n+    items_locator,\n };\n-use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, AstToken, HasName},\n+    ast::{self, AstNode, HasName},\n     SyntaxKind::WHITESPACE,\n };\n \n@@ -25,6 +25,7 @@ use crate::{\n // Converts a `derive` impl into a manual one.\n //\n // ```\n+// # //- minicore: derive\n // # trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n // #[derive(Deb$0ug, Display)]\n // struct S;\n@@ -45,28 +46,38 @@ pub(crate) fn replace_derive_with_manual_impl(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n ) -> Option<()> {\n-    let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n-    let (name, args) = attr.as_simple_call()?;\n-    if name != \"derive\" {\n+    let attr = ctx.find_node_at_offset_with_descend::<ast::Attr>()?;\n+    let path = attr.path()?;\n+    let hir_file = ctx.sema.hir_file_for(attr.syntax());\n+    if !hir_file.is_derive_attr_macro(ctx.db()) {\n         return None;\n     }\n \n-    if !args.syntax().text_range().contains(ctx.offset()) {\n-        cov_mark::hit!(outside_of_attr_args);\n+    let InFile { file_id, value } = hir_file.call_node(ctx.db())?;\n+    if file_id.is_macro() {\n+        // FIXME: make this work in macro files\n         return None;\n     }\n+    // collect the derive paths from the #[derive] expansion\n+    let current_derives = ctx\n+        .sema\n+        .parse_or_expand(hir_file)?\n+        .descendants()\n+        .filter_map(ast::Attr::cast)\n+        .filter_map(|attr| attr.path())\n+        .collect::<Vec<_>>();\n \n-    let ident = args.syntax().token_at_offset(ctx.offset()).find_map(ast::Ident::cast)?;\n-    let trait_path = get_path_at_cursor_in_tt(&ident)?;\n-    let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+    let adt = value.parent().and_then(ast::Adt::cast)?;\n+    let attr = ast::Attr::cast(value)?;\n+    let args = attr.token_tree()?;\n \n     let current_module = ctx.sema.scope(adt.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n     let found_traits = items_locator::items_with_name(\n         &ctx.sema,\n         current_crate,\n-        NameToImport::exact_case_sensitive(trait_path.segments().last()?.to_string()),\n+        NameToImport::exact_case_sensitive(path.segments().last()?.to_string()),\n         items_locator::AssocItemSearch::Exclude,\n         Some(items_locator::DEFAULT_QUERY_SEARCH_LIMIT.inner()),\n     )\n@@ -83,23 +94,21 @@ pub(crate) fn replace_derive_with_manual_impl(\n     });\n \n     let mut no_traits_found = true;\n-    let current_derives = parse_tt_as_comma_sep_paths(args.clone())?;\n-    let current_derives = current_derives.as_slice();\n     for (replace_trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {\n         add_assist(\n             acc,\n             ctx,\n             &attr,\n             &current_derives,\n             &args,\n-            &trait_path,\n+            &path,\n             &replace_trait_path,\n             Some(trait_),\n             &adt,\n         )?;\n     }\n     if no_traits_found {\n-        add_assist(acc, ctx, &attr, &current_derives, &args, &trait_path, &trait_path, None, &adt)?;\n+        add_assist(acc, ctx, &attr, &current_derives, &args, &path, &path, None, &adt)?;\n     }\n     Some(())\n }\n@@ -128,7 +137,7 @@ fn add_assist(\n             let impl_def_with_items =\n                 impl_def_from_trait(&ctx.sema, adt, &annotated_name, trait_, replace_trait_path);\n             update_attribute(builder, old_derives, old_tree, old_trait_path, attr);\n-            let trait_path = format!(\"{}\", replace_trait_path);\n+            let trait_path = replace_trait_path.to_string();\n             match (ctx.config.snippet_cap, impl_def_with_items) {\n                 (None, _) => {\n                     builder.insert(insert_pos, generate_trait_impl_text(adt, &trait_path, \"\"))\n@@ -258,7 +267,7 @@ mod tests {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo {\n     bar: String,\n@@ -282,7 +291,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo(String, usize);\n \"#,\n@@ -301,7 +310,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n struct Foo;\n \"#,\n@@ -321,7 +330,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar,\n@@ -351,7 +360,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar(usize, usize),\n@@ -380,7 +389,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(Debu$0g)]\n enum Foo {\n     Bar {\n@@ -415,7 +424,7 @@ impl core::fmt::Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo {\n     foo: usize,\n@@ -439,7 +448,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo(usize);\n \"#,\n@@ -459,7 +468,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo;\n \"#,\n@@ -480,7 +489,7 @@ impl Default for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n struct Foo {\n     bin: usize,\n@@ -508,7 +517,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n struct Foo(usize, usize);\n \"#,\n@@ -530,7 +539,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: hash\n+//- minicore: hash, derive\n #[derive(Has$0h)]\n enum Foo {\n     Bar,\n@@ -557,7 +566,7 @@ impl core::hash::Hash for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo {\n     bin: usize,\n@@ -584,7 +593,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo(usize, usize);\n \"#,\n@@ -605,7 +614,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo;\n \"#,\n@@ -626,7 +635,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar,\n@@ -656,7 +665,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar(String),\n@@ -686,7 +695,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n enum Foo {\n     Bar {\n@@ -720,7 +729,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo {\n     bin: usize,\n@@ -745,7 +754,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo {\n     bin: usize,\n@@ -782,7 +791,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: ord\n+//- minicore: ord, derive\n #[derive(Partial$0Ord)]\n struct Foo(usize, usize, usize);\n \"#,\n@@ -811,7 +820,7 @@ impl PartialOrd for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo {\n     bin: usize,\n@@ -838,7 +847,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo(usize, usize);\n \"#,\n@@ -859,7 +868,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n struct Foo;\n \"#,\n@@ -880,7 +889,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar,\n@@ -907,7 +916,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar(String),\n@@ -937,7 +946,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: eq\n+//- minicore: eq, derive\n #[derive(Partial$0Eq)]\n enum Foo {\n     Bar {\n@@ -981,6 +990,7 @@ impl PartialEq for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n mod foo {\n     pub trait Bar {\n         type Qux;\n@@ -1026,10 +1036,11 @@ impl foo::Bar for Foo {\n         )\n     }\n     #[test]\n-    fn add_custom_impl_for_unique_input() {\n+    fn add_custom_impl_for_unique_input_unknown() {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Debu$0g)]\n struct Foo {\n     bar: String,\n@@ -1052,6 +1063,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Debug$0)]\n pub struct Foo {\n     bar: String,\n@@ -1074,6 +1086,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive(Display, Debug$0, Serialize)]\n struct Foo {}\n             \"#,\n@@ -1093,7 +1106,7 @@ impl Debug for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: default\n+//- minicore: default, derive\n #[derive(Defau$0lt)]\n struct Foo<T, U> {\n     foo: T,\n@@ -1120,7 +1133,7 @@ impl<T, U> Default for Foo<T, U> {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(Clo$0ne)]\n struct Foo<T: Clone>(T, usize);\n \"#,\n@@ -1141,6 +1154,7 @@ impl<T: Clone> Clone for Foo<T> {\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[derive($0)]\n struct Foo {}\n             \"#,\n@@ -1152,6 +1166,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n #[derive$0(Debug)]\n struct Foo {}\n             \"#,\n@@ -1160,6 +1175,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n #[derive(Debug)$0]\n struct Foo {}\n             \"#,\n@@ -1171,6 +1187,7 @@ struct Foo {}\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive\n #[allow(non_camel_$0case_types)]\n struct Foo {}\n             \"#,\n@@ -1179,10 +1196,10 @@ struct Foo {}\n \n     #[test]\n     fn works_at_start_of_file() {\n-        cov_mark::check!(outside_of_attr_args);\n         check_assist_not_applicable(\n             replace_derive_with_manual_impl,\n             r#\"\n+//- minicore: derive, fmt\n $0#[derive(Debug)]\n struct S;\n             \"#,\n@@ -1194,7 +1211,7 @@ struct S;\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: clone\n+//- minicore: clone, derive\n #[derive(std::fmt::Debug, Clo$0ne)]\n pub struct Foo;\n \"#,\n@@ -1216,7 +1233,7 @@ impl Clone for Foo {\n         check_assist(\n             replace_derive_with_manual_impl,\n             r#\"\n-//- minicore: fmt\n+//- minicore: fmt, derive\n #[derive(core::fmt::Deb$0ug, Clone)]\n pub struct Foo;\n \"#,"}, {"sha": "485b807d0556d23118294d6e0b3323a5f598f004", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -1766,6 +1766,7 @@ fn doctest_replace_derive_with_manual_impl() {\n     check_doc_test(\n         \"replace_derive_with_manual_impl\",\n         r#####\"\n+//- minicore: derive\n trait Debug { fn fmt(&self, f: &mut Formatter) -> Result<()>; }\n #[derive(Deb$0ug, Display)]\n struct S;"}, {"sha": "6357b6c30bb923b7b936315f76a9010e46a12dd0", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -9,15 +9,14 @@ pub mod node_ext;\n pub mod rust_doc;\n pub mod format_string;\n \n-use std::{collections::VecDeque, iter};\n+use std::collections::VecDeque;\n \n use base_db::FileId;\n-use hir::{ItemInNs, MacroDef, ModuleDef, Name, PathResolution, Semantics};\n+use hir::{ItemInNs, MacroDef, ModuleDef, Name, Semantics};\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, HasLoopBody},\n-    AstNode, AstToken, Direction, SyntaxElement, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent,\n-    T,\n+    AstNode, SyntaxKind, SyntaxToken, TokenAtOffset, WalkEvent, T,\n };\n \n use crate::{defs::Definition, RootDatabase};\n@@ -32,49 +31,6 @@ pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n     }\n }\n \n-/// Parses and returns the derive path at the cursor position in the given attribute, if it is a derive.\n-/// This special case is required because the derive macro is a compiler builtin that discards the input derives.\n-///\n-/// The returned path is synthesized from TokenTree tokens and as such cannot be used with the [`Semantics`].\n-pub fn get_path_in_derive_attr(\n-    sema: &hir::Semantics<RootDatabase>,\n-    attr: &ast::Attr,\n-    cursor: &ast::Ident,\n-) -> Option<ast::Path> {\n-    let path = attr.path()?;\n-    let tt = attr.token_tree()?;\n-    if !tt.syntax().text_range().contains_range(cursor.syntax().text_range()) {\n-        return None;\n-    }\n-    let scope = sema.scope(attr.syntax());\n-    let resolved_attr = sema.resolve_path(&path)?;\n-    let derive = FamousDefs(sema, scope.krate()).core_macros_builtin_derive()?;\n-    if PathResolution::Macro(derive) != resolved_attr {\n-        return None;\n-    }\n-    get_path_at_cursor_in_tt(cursor)\n-}\n-\n-/// Parses the path the identifier is part of inside a token tree.\n-pub fn get_path_at_cursor_in_tt(cursor: &ast::Ident) -> Option<ast::Path> {\n-    let cursor = cursor.syntax();\n-    let first = cursor\n-        .siblings_with_tokens(Direction::Prev)\n-        .filter_map(SyntaxElement::into_token)\n-        .take_while(|tok| tok.kind() != T!['('] && tok.kind() != T![,])\n-        .last()?;\n-    let path_tokens = first\n-        .siblings_with_tokens(Direction::Next)\n-        .filter_map(SyntaxElement::into_token)\n-        .take_while(|tok| tok != cursor);\n-\n-    syntax::hacks::parse_expr_from_str(&path_tokens.chain(iter::once(cursor.clone())).join(\"\"))\n-        .and_then(|expr| match expr {\n-            ast::Expr::PathExpr(it) => it.path(),\n-            _ => None,\n-        })\n-}\n-\n /// Picks the token with the highest rank returned by the passed in function.\n pub fn pick_best_token(\n     tokens: TokenAtOffset<SyntaxToken>,"}, {"sha": "319a21735297a82a2e3e703248e49f3536744b54", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -8,11 +8,10 @@ use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, HasName},\n     utils::path_to_string_stripping_turbo_fish,\n-    AstNode, AstToken, SyntaxNode,\n+    AstNode, SyntaxNode,\n };\n \n use crate::{\n-    helpers::get_path_in_derive_attr,\n     items_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n     RootDatabase,\n };\n@@ -139,23 +138,6 @@ impl ImportAssets {\n         })\n     }\n \n-    pub fn for_derive_ident(sema: &Semantics<RootDatabase>, ident: &ast::Ident) -> Option<Self> {\n-        let attr = ident.syntax().ancestors().find_map(ast::Attr::cast)?;\n-        let path = get_path_in_derive_attr(sema, &attr, ident)?;\n-\n-        if let Some(_) = path.qualifier() {\n-            return None;\n-        }\n-\n-        let name = NameToImport::exact_case_sensitive(path.segment()?.name_ref()?.to_string());\n-        let candidate_node = attr.syntax().clone();\n-        Some(Self {\n-            import_candidate: ImportCandidate::Path(PathImportCandidate { qualifier: None, name }),\n-            module_with_candidate: sema.scope(&candidate_node).module()?,\n-            candidate_node,\n-        })\n-    }\n-\n     pub fn for_fuzzy_path(\n         module_with_candidate: Module,\n         qualifier: Option<ast::Path>,"}, {"sha": "1b916e91bfdea77b87324e3c307114b1f1ef5c74", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f13c98034bff751cfb617409211f2beb9933818a/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=f13c98034bff751cfb617409211f2beb9933818a", "patch": "@@ -705,6 +705,15 @@ impl ast::RangePat {\n }\n \n impl ast::TokenTree {\n+    pub fn token_trees_and_tokens(\n+        &self,\n+    ) -> impl Iterator<Item = NodeOrToken<ast::TokenTree, SyntaxToken>> {\n+        self.syntax().children_with_tokens().filter_map(|not| match not {\n+            NodeOrToken::Node(node) => ast::TokenTree::cast(node).map(NodeOrToken::Node),\n+            NodeOrToken::Token(t) => Some(NodeOrToken::Token(t)),\n+        })\n+    }\n+\n     pub fn left_delimiter_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .first_child_or_token()?"}]}