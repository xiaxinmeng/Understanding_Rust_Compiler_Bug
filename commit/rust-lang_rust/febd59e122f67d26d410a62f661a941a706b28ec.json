{"sha": "febd59e122f67d26d410a62f661a941a706b28ec", "node_id": "C_kwDOAAsO6NoAKGZlYmQ1OWUxMjJmNjdkMjZkNDEwYTYyZjY2MWE5NDFhNzA2YjI4ZWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T17:33:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T17:33:20Z"}, "message": "Auto merge of #109384 - matthiaskrgr:rollup-hu348gs, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #109170 (Set `CMAKE_SYSTEM_NAME` for Linux targets)\n - #109266 (rustdoc: Correctly merge import's and its target's docs in one more case)\n - #109267 (Add tests for configure.py)\n - #109273 (Make `slice::is_sorted_by` implementation nicer)\n - #109277 (Fix generics_of for impl's RPITIT synthesized associated type)\n - #109307 (Ignore `Inlined` spans when computing caller location.)\n - #109364 (Only expect a GAT const param for `type_of` of GAT const arg)\n - #109365 (Update mdbook)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b1c9e364e49e8376a8ce23adff790632c3013043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c9e364e49e8376a8ce23adff790632c3013043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/febd59e122f67d26d410a62f661a941a706b28ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/febd59e122f67d26d410a62f661a941a706b28ec", "html_url": "https://github.com/rust-lang/rust/commit/febd59e122f67d26d410a62f661a941a706b28ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/febd59e122f67d26d410a62f661a941a706b28ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13b7aa4d7faafbed78d195c27f6868f6bd90c2f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/13b7aa4d7faafbed78d195c27f6868f6bd90c2f8", "html_url": "https://github.com/rust-lang/rust/commit/13b7aa4d7faafbed78d195c27f6868f6bd90c2f8"}, {"sha": "58ffabbb90cb4f4a74b9a38c425e57f733f7c0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/58ffabbb90cb4f4a74b9a38c425e57f733f7c0f5", "html_url": "https://github.com/rust-lang/rust/commit/58ffabbb90cb4f4a74b9a38c425e57f733f7c0f5"}], "stats": {"total": 720, "additions": 460, "deletions": 260}, "files": [{"sha": "931848ea73980cf8f611123872feb0eb5a2c7f27", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -3103,9 +3103,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.25\"\n+version = \"0.4.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d1ed28d5903dde77bd5182645078a37ee57014cac6ccb2d54e1d6496386648e4\"\n+checksum = \"764dcbfc2e5f868bc1b566eb179dff1a06458fd0cff846aae2579392dd3f01a0\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\","}, {"sha": "bdfc0aa1c30c7b9b2c3f07b4d759223dafd7102f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1475,7 +1475,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> OperandRef<'tcx, Bx::Value> {\n         let tcx = bx.tcx();\n \n-        let mut span_to_caller_location = |span: Span| {\n+        let mut span_to_caller_location = |mut span: Span| {\n+            // Remove `Inlined` marks as they pollute `expansion_cause`.\n+            while span.is_inlined() {\n+                span.remove_mark();\n+            }\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location(("}, {"sha": "76c8d0a975ac0b882812f5345e2fff60d2ce9ae9", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -111,7 +111,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    pub(crate) fn location_triple_for_span(&self, mut span: Span) -> (Symbol, u32, u32) {\n+        // Remove `Inlined` marks as they pollute `expansion_cause`.\n+        while span.is_inlined() {\n+            span.remove_mark();\n+        }\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "6a27383121d2ddd72f6b3ec8ea313fd01e20e657", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -3152,8 +3152,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"impl_trait_ty_to_ty: generics={:?}\", generics);\n         let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n-            if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n-                // Our own parameters are the resolved lifetimes.\n+            // We use `generics.count() - lifetimes.len()` here instead of `generics.parent_count`\n+            // since return-position impl trait in trait squashes all of the generics from its source fn\n+            // into its own generics, so the opaque's \"own\" params isn't always just lifetimes.\n+            if let Some(i) = (param.index as usize).checked_sub(generics.count() - lifetimes.len())\n+            {\n+                // Resolve our own lifetime parameters.\n                 let GenericParamDefKind::Lifetime { .. } = param.kind else { bug!() };\n                 let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] else { bug!() };\n                 self.ast_region_to_region(lifetime, None).into()"}, {"sha": "4bbea87890429237bec62a80acd1499de5125b08", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -278,8 +278,11 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n             }\n             TraitItemKind::Const(ty, body_id) => body_id\n                 .and_then(|body_id| {\n-                    is_suggestable_infer_ty(ty)\n-                        .then(|| infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident, \"constant\",))\n+                    is_suggestable_infer_ty(ty).then(|| {\n+                        infer_placeholder_type(\n+                            tcx, def_id, body_id, ty.span, item.ident, \"constant\",\n+                        )\n+                    })\n                 })\n                 .unwrap_or_else(|| icx.to_ty(ty)),\n             TraitItemKind::Type(_, Some(ty)) => icx.to_ty(ty),\n@@ -335,14 +338,15 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     }\n                 }\n                 ItemKind::TyAlias(self_ty, _) => icx.to_ty(self_ty),\n-                ItemKind::Impl(hir::Impl { self_ty, .. }) => {\n-                    match self_ty.find_self_aliases() {\n-                        spans if spans.len() > 0 => {\n-                            let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf { span: spans.into(), note: () });\n-                            tcx.ty_error(guar)\n-                        },\n-                        _ => icx.to_ty(*self_ty),\n+                ItemKind::Impl(hir::Impl { self_ty, .. }) => match self_ty.find_self_aliases() {\n+                    spans if spans.len() > 0 => {\n+                        let guar = tcx.sess.emit_err(crate::errors::SelfInImplSelf {\n+                            span: spans.into(),\n+                            note: (),\n+                        });\n+                        tcx.ty_error(guar)\n                     }\n+                    _ => icx.to_ty(*self_ty),\n                 },\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -364,7 +368,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     ..\n                 }) => {\n                     if in_trait && !tcx.impl_defaultness(owner).has_value() {\n-                        span_bug!(tcx.def_span(def_id), \"tried to get type of this RPITIT with no definition\");\n+                        span_bug!(\n+                            tcx.def_span(def_id),\n+                            \"tried to get type of this RPITIT with no definition\"\n+                        );\n                     }\n                     find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }\n@@ -453,15 +460,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n                 }\n \n-                Node::TypeBinding(\n-                    TypeBinding {\n-                        hir_id: binding_id,\n-                        kind: TypeBindingKind::Equality { term: Term::Const(e) },\n-                        ident,\n-                        ..\n-                    },\n-                ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(*binding_id)\n+                Node::TypeBinding(TypeBinding {\n+                    hir_id: binding_id,\n+                    kind: TypeBindingKind::Equality { term: Term::Const(e) },\n+                    ident,\n+                    ..\n+                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n                     && e.hir_id == hir_id =>\n                 {\n                     let Some(trait_def_id) = trait_ref.trait_def_id() else {\n@@ -475,7 +479,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                         def_id.to_def_id(),\n                     );\n                     if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(assoc_item.def_id).subst_identity()\n+                        tcx.type_of(assoc_item.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\")\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n@@ -485,10 +491,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                     }\n                 }\n \n-                Node::TypeBinding(\n-                    TypeBinding { hir_id: binding_id, gen_args, kind, ident, .. },\n-                ) if let Node::TraitRef(trait_ref) =\n-                    tcx.hir().get_parent(*binding_id)\n+                Node::TypeBinding(TypeBinding {\n+                    hir_id: binding_id,\n+                    gen_args,\n+                    kind,\n+                    ident,\n+                    ..\n+                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n                     && let Some((idx, _)) =\n                         gen_args.args.iter().enumerate().find(|(_, arg)| {\n                             if let GenericArg::Const(ct) = arg {\n@@ -517,15 +526,18 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::EarlyBinder<Ty<'_>>\n                         },\n                         def_id.to_def_id(),\n                     );\n-                    if let Some(param)\n-                        = assoc_item.map(|item| &tcx.generics_of(item.def_id).params[idx]).filter(|param| param.kind.is_ty_or_const())\n+                    if let Some(assoc_item) = assoc_item\n+                        && let param = &tcx.generics_of(assoc_item.def_id).params[idx]\n+                        && matches!(param.kind, ty::GenericParamDefKind::Const { .. })\n                     {\n-                        tcx.type_of(param.def_id).subst_identity()\n+                        tcx.type_of(param.def_id)\n+                            .no_bound_vars()\n+                            .expect(\"const parameter types cannot be generic\")\n                     } else {\n                         // FIXME(associated_const_equality): add a useful error message here.\n                         tcx.ty_error_with_message(\n                             DUMMY_SP,\n-                            \"Could not find associated const on trait\",\n+                            \"Could not find const param on associated item\",\n                         )\n                     }\n                 }"}, {"sha": "d727aba6de5f91fb4cf65a49a54debd006e4f8e7", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -880,7 +880,7 @@ impl Span {\n     pub fn fresh_expansion(self, expn_id: LocalExpnId) -> Span {\n         HygieneData::with(|data| {\n             self.with_ctxt(data.apply_mark(\n-                SyntaxContext::root(),\n+                self.ctxt(),\n                 expn_id.to_expn_id(),\n                 Transparency::Transparent,\n             ))"}, {"sha": "87fdaa14f6be0e54bc028d102af9e0d08d1e4598", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -396,6 +396,8 @@ fn associated_type_for_impl_trait_in_impl(\n     impl_assoc_ty.impl_defaultness(tcx.impl_defaultness(impl_fn_def_id));\n \n     // Copy generics_of the trait's associated item but the impl as the parent.\n+    // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty) resolves to the trait instead of the impl\n+    // generics.\n     impl_assoc_ty.generics_of({\n         let trait_assoc_generics = tcx.generics_of(trait_assoc_def_id);\n         let trait_assoc_parent_count = trait_assoc_generics.parent_count;\n@@ -404,16 +406,10 @@ fn associated_type_for_impl_trait_in_impl(\n         let parent_generics = tcx.generics_of(impl_def_id);\n         let parent_count = parent_generics.parent_count + parent_generics.params.len();\n \n-        let mut impl_fn_params = tcx.generics_of(impl_fn_def_id).params.clone();\n-\n         for param in &mut params {\n-            param.index = param.index + parent_count as u32 + impl_fn_params.len() as u32\n-                - trait_assoc_parent_count as u32;\n+            param.index = param.index + parent_count as u32 - trait_assoc_parent_count as u32;\n         }\n \n-        impl_fn_params.extend(params);\n-        params = impl_fn_params;\n-\n         let param_def_id_to_index =\n             params.iter().map(|param| (param.def_id, param.index)).collect();\n "}, {"sha": "88b84bd1352cc8c7baccd8730c353fac1dae81cc", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -132,9 +132,7 @@ iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, {\n         Self: Sized,\n         F: FnMut(&Self::Item, &Self::Item) -> Option<Ordering>,\n     {\n-        self.as_slice().windows(2).all(|w| {\n-            compare(&&w[0], &&w[1]).map(|o| o != Ordering::Greater).unwrap_or(false)\n-        })\n+        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n     }\n }}\n "}, {"sha": "57b6e0ce4bb238b215efefe9e93bc85d3fadb926", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -3822,7 +3822,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&'a T, &'a T) -> Option<Ordering>,\n     {\n-        self.iter().is_sorted_by(|a, b| compare(*a, *b))\n+        self.array_windows().all(|[a, b]| compare(a, b).map_or(false, Ordering::is_le))\n     }\n \n     /// Checks if the elements of this slice are sorted using the given key extraction function."}, {"sha": "20bd71f06e918e1dfe1d1f8cb0e8839ba9d79161", "filename": "src/bootstrap/bootstrap_test.py", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fbootstrap_test.py", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fbootstrap_test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap_test.py?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -11,6 +11,7 @@\n from shutil import rmtree\n \n import bootstrap\n+import configure\n \n \n class VerifyTestCase(unittest.TestCase):\n@@ -74,12 +75,50 @@ def test_same_dates(self):\n         self.assertFalse(self.build.program_out_of_date(self.rustc_stamp_path, self.key))\n \n \n+class GenerateAndParseConfig(unittest.TestCase):\n+    \"\"\"Test that we can serialize and deserialize a config.toml file\"\"\"\n+    def serialize_and_parse(self, args):\n+        from io import StringIO\n+\n+        section_order, sections, targets = configure.parse_args(args)\n+        buffer = StringIO()\n+        configure.write_config_toml(buffer, section_order, targets, sections)\n+        build = bootstrap.RustBuild()\n+        build.config_toml = buffer.getvalue()\n+\n+        try:\n+            import tomllib\n+            # Verify this is actually valid TOML.\n+            tomllib.loads(build.config_toml)\n+        except ImportError:\n+            print(\"warning: skipping TOML validation, need at least python 3.11\", file=sys.stderr)\n+        return build\n+\n+    def test_no_args(self):\n+        build = self.serialize_and_parse([])\n+        self.assertEqual(build.get_toml(\"changelog-seen\"), '2')\n+        self.assertIsNone(build.get_toml(\"llvm.download-ci-llvm\"))\n+\n+    def test_set_section(self):\n+        build = self.serialize_and_parse([\"--set\", \"llvm.download-ci-llvm\"])\n+        self.assertEqual(build.get_toml(\"download-ci-llvm\", section=\"llvm\"), 'true')\n+\n+    def test_set_target(self):\n+        build = self.serialize_and_parse([\"--set\", \"target.x86_64-unknown-linux-gnu.cc=gcc\"])\n+        self.assertEqual(build.get_toml(\"cc\", section=\"target.x86_64-unknown-linux-gnu\"), 'gcc')\n+\n+    # Uncomment when #108928 is fixed.\n+    # def test_set_top_level(self):\n+    #     build = self.serialize_and_parse([\"--set\", \"profile=compiler\"])\n+    #     self.assertEqual(build.get_toml(\"profile\"), 'compiler')\n+\n if __name__ == '__main__':\n     SUITE = unittest.TestSuite()\n     TEST_LOADER = unittest.TestLoader()\n     SUITE.addTest(doctest.DocTestSuite(bootstrap))\n     SUITE.addTests([\n         TEST_LOADER.loadTestsFromTestCase(VerifyTestCase),\n+        TEST_LOADER.loadTestsFromTestCase(GenerateAndParseConfig),\n         TEST_LOADER.loadTestsFromTestCase(ProgramOutOfDate)])\n \n     RUNNER = unittest.TextTestRunner(stream=sys.stdout, verbosity=2)"}, {"sha": "abd28b4005d0be6faa8a796f935496e15012b489", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 219, "deletions": 198, "changes": 417, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -205,77 +205,78 @@ def err(msg):\n \n # Parse all command line arguments into one of these three lists, handling\n # boolean and value-based options separately\n-unknown_args = []\n-need_value_args = []\n-known_args = {}\n-\n-p(\"processing command line\")\n-i = 1\n-while i < len(sys.argv):\n-    arg = sys.argv[i]\n-    i += 1\n-    if not arg.startswith('--'):\n-        unknown_args.append(arg)\n-        continue\n-\n-    found = False\n-    for option in options:\n-        value = None\n-        if option.value:\n-            keyval = arg[2:].split('=', 1)\n-            key = keyval[0]\n-            if option.name != key:\n-                continue\n+def parse_args(args):\n+    unknown_args = []\n+    need_value_args = []\n+    known_args = {}\n+\n+    i = 0\n+    while i < len(args):\n+        arg = args[i]\n+        i += 1\n+        if not arg.startswith('--'):\n+            unknown_args.append(arg)\n+            continue\n \n-            if len(keyval) > 1:\n-                value = keyval[1]\n-            elif i < len(sys.argv):\n-                value = sys.argv[i]\n-                i += 1\n-            else:\n-                need_value_args.append(arg)\n-                continue\n-        else:\n-            if arg[2:] == 'enable-' + option.name:\n-                value = True\n-            elif arg[2:] == 'disable-' + option.name:\n-                value = False\n+        found = False\n+        for option in options:\n+            value = None\n+            if option.value:\n+                keyval = arg[2:].split('=', 1)\n+                key = keyval[0]\n+                if option.name != key:\n+                    continue\n+\n+                if len(keyval) > 1:\n+                    value = keyval[1]\n+                elif i < len(args):\n+                    value = args[i]\n+                    i += 1\n+                else:\n+                    need_value_args.append(arg)\n+                    continue\n             else:\n-                continue\n+                if arg[2:] == 'enable-' + option.name:\n+                    value = True\n+                elif arg[2:] == 'disable-' + option.name:\n+                    value = False\n+                else:\n+                    continue\n+\n+            found = True\n+            if option.name not in known_args:\n+                known_args[option.name] = []\n+            known_args[option.name].append((option, value))\n+            break\n+\n+        if not found:\n+            unknown_args.append(arg)\n+\n+    # Note: here and a few other places, we use [-1] to apply the *last* value\n+    # passed.  But if option-checking is enabled, then the known_args loop will\n+    # also assert that options are only passed once.\n+    option_checking = ('option-checking' not in known_args\n+                    or known_args['option-checking'][-1][1])\n+    if option_checking:\n+        if len(unknown_args) > 0:\n+            err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n+        if len(need_value_args) > 0:\n+            err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n+\n+    config = {}\n+\n+    set('build.configure-args', sys.argv[1:], config)\n+    apply_args(known_args, option_checking, config)\n+    return parse_example_config(known_args, config)\n \n-        found = True\n-        if option.name not in known_args:\n-            known_args[option.name] = []\n-        known_args[option.name].append((option, value))\n-        break\n-\n-    if not found:\n-        unknown_args.append(arg)\n-p(\"\")\n-\n-# Note: here and a few other places, we use [-1] to apply the *last* value\n-# passed.  But if option-checking is enabled, then the known_args loop will\n-# also assert that options are only passed once.\n-option_checking = ('option-checking' not in known_args\n-                   or known_args['option-checking'][-1][1])\n-if option_checking:\n-    if len(unknown_args) > 0:\n-        err(\"Option '\" + unknown_args[0] + \"' is not recognized\")\n-    if len(need_value_args) > 0:\n-        err(\"Option '{0}' needs a value ({0}=val)\".format(need_value_args[0]))\n-\n-# Parse all known arguments into a configuration structure that reflects the\n-# TOML we're going to write out\n-config = {}\n-\n-\n-def build():\n+\n+def build(known_args):\n     if 'build' in known_args:\n         return known_args['build'][-1][1]\n     return bootstrap.default_build_triple(verbose=False)\n \n \n-def set(key, value):\n+def set(key, value, config):\n     if isinstance(value, list):\n         # Remove empty values, which value.split(',') tends to generate.\n         value = [v for v in value if v]\n@@ -297,122 +298,127 @@ def set(key, value):\n             arr = arr[part]\n \n \n-for key in known_args:\n-    # The `set` option is special and can be passed a bunch of times\n-    if key == 'set':\n-        for option, value in known_args[key]:\n-            keyval = value.split('=', 1)\n-            if len(keyval) == 1 or keyval[1] == \"true\":\n-                value = True\n-            elif keyval[1] == \"false\":\n-                value = False\n-            else:\n-                value = keyval[1]\n-            set(keyval[0], value)\n-        continue\n-\n-    # Ensure each option is only passed once\n-    arr = known_args[key]\n-    if option_checking and len(arr) > 1:\n-        err(\"Option '{}' provided more than once\".format(key))\n-    option, value = arr[-1]\n-\n-    # If we have a clear avenue to set our value in rustbuild, do so\n-    if option.rustbuild is not None:\n-        set(option.rustbuild, value)\n-        continue\n-\n-    # Otherwise we're a \"special\" option and need some extra handling, so do\n-    # that here.\n-    if option.name == 'sccache':\n-        set('llvm.ccache', 'sccache')\n-    elif option.name == 'local-rust':\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/rustc'):\n-                set('build.rustc', path + '/rustc')\n-                break\n-        for path in os.environ['PATH'].split(os.pathsep):\n-            if os.path.exists(path + '/cargo'):\n-                set('build.cargo', path + '/cargo')\n-                break\n-    elif option.name == 'local-rust-root':\n-        set('build.rustc', value + '/bin/rustc')\n-        set('build.cargo', value + '/bin/cargo')\n-    elif option.name == 'llvm-root':\n-        set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n-    elif option.name == 'llvm-config':\n-        set('target.{}.llvm-config'.format(build()), value)\n-    elif option.name == 'llvm-filecheck':\n-        set('target.{}.llvm-filecheck'.format(build()), value)\n-    elif option.name == 'tools':\n-        set('build.tools', value.split(','))\n-    elif option.name == 'codegen-backends':\n-        set('rust.codegen-backends', value.split(','))\n-    elif option.name == 'host':\n-        set('build.host', value.split(','))\n-    elif option.name == 'target':\n-        set('build.target', value.split(','))\n-    elif option.name == 'full-tools':\n-        set('rust.codegen-backends', ['llvm'])\n-        set('rust.lld', True)\n-        set('rust.llvm-tools', True)\n-        set('build.extended', True)\n-    elif option.name == 'option-checking':\n-        # this was handled above\n-        pass\n-    elif option.name == 'dist-compression-formats':\n-        set('dist.compression-formats', value.split(','))\n-    else:\n-        raise RuntimeError(\"unhandled option {}\".format(option.name))\n+def apply_args(known_args, option_checking, config):\n+    for key in known_args:\n+        # The `set` option is special and can be passed a bunch of times\n+        if key == 'set':\n+            for option, value in known_args[key]:\n+                keyval = value.split('=', 1)\n+                if len(keyval) == 1 or keyval[1] == \"true\":\n+                    value = True\n+                elif keyval[1] == \"false\":\n+                    value = False\n+                else:\n+                    value = keyval[1]\n+                set(keyval[0], value, config)\n+            continue\n \n-set('build.configure-args', sys.argv[1:])\n+        # Ensure each option is only passed once\n+        arr = known_args[key]\n+        if option_checking and len(arr) > 1:\n+            err(\"Option '{}' provided more than once\".format(key))\n+        option, value = arr[-1]\n+\n+        # If we have a clear avenue to set our value in rustbuild, do so\n+        if option.rustbuild is not None:\n+            set(option.rustbuild, value, config)\n+            continue\n+\n+        # Otherwise we're a \"special\" option and need some extra handling, so do\n+        # that here.\n+        build_triple = build(known_args)\n+\n+        if option.name == 'sccache':\n+            set('llvm.ccache', 'sccache', config)\n+        elif option.name == 'local-rust':\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/rustc'):\n+                    set('build.rustc', path + '/rustc', config)\n+                    break\n+            for path in os.environ['PATH'].split(os.pathsep):\n+                if os.path.exists(path + '/cargo'):\n+                    set('build.cargo', path + '/cargo', config)\n+                    break\n+        elif option.name == 'local-rust-root':\n+            set('build.rustc', value + '/bin/rustc', config)\n+            set('build.cargo', value + '/bin/cargo', config)\n+        elif option.name == 'llvm-root':\n+            set('target.{}.llvm-config'.format(build_triple), value + '/bin/llvm-config', config)\n+        elif option.name == 'llvm-config':\n+            set('target.{}.llvm-config'.format(build_triple), value, config)\n+        elif option.name == 'llvm-filecheck':\n+            set('target.{}.llvm-filecheck'.format(build_triple), value, config)\n+        elif option.name == 'tools':\n+            set('build.tools', value.split(','), config)\n+        elif option.name == 'codegen-backends':\n+            set('rust.codegen-backends', value.split(','), config)\n+        elif option.name == 'host':\n+            set('build.host', value.split(','), config)\n+        elif option.name == 'target':\n+            set('build.target', value.split(','), config)\n+        elif option.name == 'full-tools':\n+            set('rust.codegen-backends', ['llvm'], config)\n+            set('rust.lld', True, config)\n+            set('rust.llvm-tools', True, config)\n+            set('build.extended', True, config)\n+        elif option.name == 'option-checking':\n+            # this was handled above\n+            pass\n+        elif option.name == 'dist-compression-formats':\n+            set('dist.compression-formats', value.split(','), config)\n+        else:\n+            raise RuntimeError(\"unhandled option {}\".format(option.name))\n \n # \"Parse\" the `config.example.toml` file into the various sections, and we'll\n # use this as a template of a `config.toml` to write out which preserves\n # all the various comments and whatnot.\n #\n # Note that the `target` section is handled separately as we'll duplicate it\n # per configured target, so there's a bit of special handling for that here.\n-sections = {}\n-cur_section = None\n-sections[None] = []\n-section_order = [None]\n-targets = {}\n-top_level_keys = []\n-\n-for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n-    if cur_section == None:\n-        if line.count('=') == 1:\n-            top_level_key = line.split('=')[0]\n-            top_level_key = top_level_key.strip(' #')\n-            top_level_keys.append(top_level_key)\n-    if line.startswith('['):\n-        cur_section = line[1:-1]\n-        if cur_section.startswith('target'):\n-            cur_section = 'target'\n-        elif '.' in cur_section:\n-            raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n-        sections[cur_section] = [line]\n-        section_order.append(cur_section)\n-    else:\n-        sections[cur_section].append(line)\n-\n-# Fill out the `targets` array by giving all configured targets a copy of the\n-# `target` section we just loaded from the example config\n-configured_targets = [build()]\n-if 'build' in config:\n-    if 'host' in config['build']:\n-        configured_targets += config['build']['host']\n-    if 'target' in config['build']:\n-        configured_targets += config['build']['target']\n-if 'target' in config:\n-    for target in config['target']:\n-        configured_targets.append(target)\n-for target in configured_targets:\n-    targets[target] = sections['target'][:]\n-    # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n-    # Avoid using quotes unless it's necessary.\n-    targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+def parse_example_config(known_args, config):\n+    sections = {}\n+    cur_section = None\n+    sections[None] = []\n+    section_order = [None]\n+    targets = {}\n+    top_level_keys = []\n+\n+    for line in open(rust_dir + '/config.example.toml').read().split(\"\\n\"):\n+        if cur_section == None:\n+            if line.count('=') == 1:\n+                top_level_key = line.split('=')[0]\n+                top_level_key = top_level_key.strip(' #')\n+                top_level_keys.append(top_level_key)\n+        if line.startswith('['):\n+            cur_section = line[1:-1]\n+            if cur_section.startswith('target'):\n+                cur_section = 'target'\n+            elif '.' in cur_section:\n+                raise RuntimeError(\"don't know how to deal with section: {}\".format(cur_section))\n+            sections[cur_section] = [line]\n+            section_order.append(cur_section)\n+        else:\n+            sections[cur_section].append(line)\n+\n+    # Fill out the `targets` array by giving all configured targets a copy of the\n+    # `target` section we just loaded from the example config\n+    configured_targets = [build(known_args)]\n+    if 'build' in config:\n+        if 'host' in config['build']:\n+            configured_targets += config['build']['host']\n+        if 'target' in config['build']:\n+            configured_targets += config['build']['target']\n+    if 'target' in config:\n+        for target in config['target']:\n+            configured_targets.append(target)\n+    for target in configured_targets:\n+        targets[target] = sections['target'][:]\n+        # For `.` to be valid TOML, it needs to be quoted. But `bootstrap.py` doesn't use a proper TOML parser and fails to parse the target.\n+        # Avoid using quotes unless it's necessary.\n+        targets[target][0] = targets[target][0].replace(\"x86_64-unknown-linux-gnu\", \"'{}'\".format(target) if \".\" in target else target)\n+\n+    configure_file(sections, top_level_keys, targets, config)\n+    return section_order, sections, targets\n \n \n def is_number(value):\n@@ -475,17 +481,20 @@ def configure_top_level_key(lines, top_level_key, value):\n     raise RuntimeError(\"failed to find config line for {}\".format(top_level_key))\n \n \n-for section_key, section_config in config.items():\n-    if section_key not in sections and section_key not in top_level_keys:\n-        raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n-    if section_key in top_level_keys:\n-        configure_top_level_key(sections[None], section_key, section_config)\n+# Modify `sections` to reflect the parsed arguments and example configs.\n+def configure_file(sections, top_level_keys, targets, config):\n+    for section_key, section_config in config.items():\n+        if section_key not in sections and section_key not in top_level_keys:\n+            raise RuntimeError(\"config key {} not in sections or top_level_keys\".format(section_key))\n+        if section_key in top_level_keys:\n+            configure_top_level_key(sections[None], section_key, section_config)\n+\n+        elif  section_key == 'target':\n+            for target in section_config:\n+                configure_section(targets[target], section_config[target])\n+        else:\n+            configure_section(sections[section_key], section_config)\n \n-    elif  section_key == 'target':\n-        for target in section_config:\n-            configure_section(targets[target], section_config[target])\n-    else:\n-        configure_section(sections[section_key], section_config)\n \n def write_uncommented(target, f):\n     block = []\n@@ -503,24 +512,36 @@ def write_uncommented(target, f):\n         is_comment = is_comment and line.startswith('#')\n     return f\n \n-# Now that we've built up our `config.toml`, write it all out in the same\n-# order that we read it in.\n-p(\"\")\n-p(\"writing `config.toml` in current directory\")\n-with bootstrap.output('config.toml') as f:\n+\n+def write_config_toml(writer, section_order, targets, sections):\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n-                f = write_uncommented(targets[target], f)\n+                writer = write_uncommented(targets[target], writer)\n         else:\n-            f = write_uncommented(sections[section], f)\n-\n-with bootstrap.output('Makefile') as f:\n-    contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n-    contents = open(contents).read()\n-    contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n-    contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n-    f.write(contents)\n-\n-p(\"\")\n-p(\"run `python {}/x.py --help`\".format(rust_dir))\n+            writer = write_uncommented(sections[section], writer)\n+\n+\n+if __name__ == \"__main__\":\n+    p(\"processing command line\")\n+    # Parse all known arguments into a configuration structure that reflects the\n+    # TOML we're going to write out\n+    p(\"\")\n+    section_order, sections, targets = parse_args(sys.argv[1:])\n+\n+    # Now that we've built up our `config.toml`, write it all out in the same\n+    # order that we read it in.\n+    p(\"\")\n+    p(\"writing `config.toml` in current directory\")\n+    with bootstrap.output('config.toml') as f:\n+        write_config_toml(f, section_order, targets, sections)\n+\n+    with bootstrap.output('Makefile') as f:\n+        contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n+        contents = open(contents).read()\n+        contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')\n+        contents = contents.replace(\"$(CFG_PYTHON)\", sys.executable)\n+        f.write(contents)\n+\n+    p(\"\")\n+    p(\"run `python {}/x.py --help`\".format(rust_dir))"}, {"sha": "dff46b500e3ad2653ac0edd7a012e3e0305d2e3b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -567,6 +567,8 @@ fn configure_cmake(\n             cfg.define(\"CMAKE_SYSTEM_NAME\", \"Haiku\");\n         } else if target.contains(\"solaris\") || target.contains(\"illumos\") {\n             cfg.define(\"CMAKE_SYSTEM_NAME\", \"SunOS\");\n+        } else if target.contains(\"linux\") {\n+            cfg.define(\"CMAKE_SYSTEM_NAME\", \"Linux\");\n         }\n         // When cross-compiling we should also set CMAKE_SYSTEM_VERSION, but in\n         // that case like CMake we cannot easily determine system version either."}, {"sha": "b5715024a8484533d8ecf55736e39f0b061084df", "filename": "src/ci/docker/host-x86_64/mingw-check-tidy/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check-tidy%2FDockerfile?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,13 +1,16 @@\n FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n+# NOTE: intentionally uses python2 for x.py so we can test it still works.\n+# validate-toolstate only runs in our CI, so it's ok for it to only support python3.\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\\n   ninja-build \\\n   file \\\n   curl \\\n   ca-certificates \\\n+  python2.7 \\\n   python3 \\\n   python3-pip \\\n   python3-pkg-resources \\\n@@ -30,4 +33,4 @@ RUN pip3 install --no-deps --no-cache-dir --require-hashes -r /tmp/reuse-require\n COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n COPY host-x86_64/mingw-check/validate-error-codes.sh /scripts/\n \n-ENV SCRIPT python3 ../x.py test --stage 0 src/tools/tidy tidyselftest\n+ENV SCRIPT python2.7 ../x.py test --stage 0 src/tools/tidy tidyselftest"}, {"sha": "dc8a4aac76873e3fcb3feb1ea412f9ba70acdf4f", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-14/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-14%2FDockerfile?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -2,7 +2,6 @@ FROM ubuntu:22.04\n \n ARG DEBIAN_FRONTEND=noninteractive\n \n-# NOTE: intentionally installs both python2 and python3 so we can test support for both.\n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   gcc-multilib \\\n@@ -11,8 +10,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   file \\\n   curl \\\n   ca-certificates \\\n-  python2.7 \\\n-  python3 \\\n+  python3.11 \\\n   git \\\n   cmake \\\n   sudo \\"}, {"sha": "e3e5454ef5443072d7ed3998a559430f69e533b4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -39,6 +39,7 @@ use std::hash::Hash;\n use std::mem;\n use thin_vec::ThinVec;\n \n+use crate::clean::inline::merge_attrs;\n use crate::core::{self, DocContext, ImplTraitParam};\n use crate::formats::item_type::ItemType;\n use crate::visit_ast::Module as DocModule;\n@@ -2373,21 +2374,22 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let mut extra_attrs = Vec::new();\n+        let mut import_attrs = Vec::new();\n+        let mut target_attrs = Vec::new();\n         if let Some(import_id) = import_id &&\n             let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n             let is_inline = inline::load_attrs(cx, import_id.to_def_id()).lists(sym::doc).get_word_attr(sym::inline).is_some();\n             // Then we get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs, is_inline);\n-            add_without_unwanted_attributes(&mut extra_attrs, inline::load_attrs(cx, def_id), is_inline);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut import_attrs, is_inline);\n+            add_without_unwanted_attributes(&mut target_attrs, inline::load_attrs(cx, def_id), is_inline);\n         } else {\n             // We only keep the item's attributes.\n-            extra_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n+            target_attrs.extend_from_slice(inline::load_attrs(cx, def_id));\n         }\n \n-        let attrs = Attributes::from_ast(&extra_attrs);\n-        let cfg = extra_attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+        let import_parent = import_id.map(|import_id| cx.tcx.local_parent(import_id).to_def_id());\n+        let (attrs, cfg) =  merge_attrs(cx, import_parent, &target_attrs, Some(&import_attrs));\n \n         let mut item =\n             Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);"}, {"sha": "8286bd506bca7838ca24d99eb0944b461d00cd7b", "filename": "src/tools/rustbook/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/src%2Ftools%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/src%2Ftools%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustbook%2FCargo.toml?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -9,6 +9,6 @@ clap = \"4.0.32\"\n env_logger = \"0.7.1\"\n \n [dependencies.mdbook]\n-version = \"0.4.25\"\n+version = \"0.4.28\"\n default-features = false\n features = [\"search\"]"}, {"sha": "31fef032b0fc959cfca692666144c9a22e36fcd3", "filename": "tests/rustdoc-ui/intra-doc/import-inline-merge.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Fimport-inline-merge.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,16 @@\n+// Import for `A` is inlined and doc comments on the import and `A` itself are merged.\n+// After the merge they still have correct parent scopes to resolve both `[A]` and `[B]`.\n+\n+// check-pass\n+\n+#![allow(rustdoc::private_intra_doc_links)]\n+\n+mod m {\n+    /// [B]\n+    pub struct A {}\n+\n+    pub struct B {}\n+}\n+\n+/// [A]\n+pub use m::A;"}, {"sha": "8e5dbd08eb98bb9302596514849b95f78822cfe9", "filename": "tests/ui/async-await/in-trait/issue-102310.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Fissue-102310.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "0e9477544a4a6febde94fbb27295f994278be3fb", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.current.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.current.stderr?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/lifetime-mismatch.rs:3:12\n+  --> $DIR/lifetime-mismatch.rs:5:12\n    |\n LL | #![feature(async_fn_in_trait)]\n    |            ^^^^^^^^^^^^^^^^^\n@@ -8,7 +8,7 @@ LL | #![feature(async_fn_in_trait)]\n    = note: `#[warn(incomplete_features)]` on by default\n \n error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n-  --> $DIR/lifetime-mismatch.rs:12:17\n+  --> $DIR/lifetime-mismatch.rs:14:17\n    |\n LL |     async fn foo<'a>(&self);\n    |                 ---- lifetimes in impl do not match this method in trait", "previous_filename": "tests/ui/async-await/in-trait/lifetime-mismatch.stderr"}, {"sha": "0e9477544a4a6febde94fbb27295f994278be3fb", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.next.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.next.stderr?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/lifetime-mismatch.rs:5:12\n+   |\n+LL | #![feature(async_fn_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0195]: lifetime parameters or bounds on method `foo` do not match the trait declaration\n+  --> $DIR/lifetime-mismatch.rs:14:17\n+   |\n+LL |     async fn foo<'a>(&self);\n+   |                 ---- lifetimes in impl do not match this method in trait\n+...\n+LL |     async fn foo(&self) {}\n+   |                 ^ lifetimes do not match method in trait\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0195`."}, {"sha": "5ff5a01a1ee0356a3c63d4c069bc72705c69e548", "filename": "tests/ui/async-await/in-trait/lifetime-mismatch.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fin-trait%2Flifetime-mismatch.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,4 +1,6 @@\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait)]\n //~^ WARN the feature `async_fn_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes"}, {"sha": "734a37862940f05badaae18ecfb6232f24b8258d", "filename": "tests/ui/const-generics/generic_const_exprs/mismatched-gat-subst-kind.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,11 @@\n+#![feature(generic_const_exprs)]\n+//~^ WARN the feature `generic_const_exprs` is incomplete\n+\n+trait B {\n+    type U<T>;\n+}\n+\n+fn f<T: B<U<1i32> = ()>>() {}\n+//~^ ERROR constant provided when a type was expected\n+\n+fn main() {}"}, {"sha": "8b6eb5b75940f052edd9252e2d6758d590800a9b", "filename": "tests/ui/const-generics/generic_const_exprs/mismatched-gat-subst-kind.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fmismatched-gat-subst-kind.stderr?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,18 @@\n+warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mismatched-gat-subst-kind.rs:1:12\n+   |\n+LL | #![feature(generic_const_exprs)]\n+   |            ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0747]: constant provided when a type was expected\n+  --> $DIR/mismatched-gat-subst-kind.rs:8:13\n+   |\n+LL | fn f<T: B<U<1i32> = ()>>() {}\n+   |             ^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0747`."}, {"sha": "831033a588061cc0efc2cefacfd8818b27e8f07e", "filename": "tests/ui/impl-trait/in-trait/early.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fearly.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition:2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(async_fn_in_trait, return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "1329ca29d06aa99fcebd360cfc22662a6e244420", "filename": "tests/ui/impl-trait/in-trait/issue-102301.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fissue-102301.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "f48d9fa26c003ce40d4af5d812b48f61b8c7820d", "filename": "tests/ui/impl-trait/in-trait/opaque-in-impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fopaque-in-impl.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,4 +1,6 @@\n // check-pass\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "64c942705cf8e5ab86f7147101ee3d94c3f06740", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.current.stderr?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,5 @@\n error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n-  --> $DIR/trait-more-generics-than-impl.rs:11:11\n+  --> $DIR/trait-more-generics-than-impl.rs:14:11\n    |\n LL |     fn bar<T>() -> impl Sized;\n    |            - expected 1 type parameter", "previous_filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.stderr"}, {"sha": "64c942705cf8e5ab86f7147101ee3d94c3f06740", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.next.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.next.stderr?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,12 @@\n+error[E0049]: method `bar` has 0 type parameters but its trait declaration has 1 type parameter\n+  --> $DIR/trait-more-generics-than-impl.rs:14:11\n+   |\n+LL |     fn bar<T>() -> impl Sized;\n+   |            - expected 1 type parameter\n+...\n+LL |     fn bar() -> impl Sized {}\n+   |           ^ found 0 type parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0049`."}, {"sha": "c2e394a1f664518a7eb58f1fa468da59d1b3daa1", "filename": "tests/ui/impl-trait/in-trait/trait-more-generics-than-impl.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Ftrait-more-generics-than-impl.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,3 +1,6 @@\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n+\n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]\n "}, {"sha": "88d86e2b541929fc5dc0672cd923c87a9feee633", "filename": "tests/ui/impl-trait/in-trait/where-clause.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fwhere-clause.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,7 @@\n // check-pass\n // edition: 2021\n+// [next] compile-flags: -Zlower-impl-trait-in-trait-to-assoc-ty\n+// revisions: current next\n \n #![feature(return_position_impl_trait_in_trait)]\n #![allow(incomplete_features)]"}, {"sha": "23d2a4b0a99c642103b2587668bbad5fca5e858d", "filename": "tests/ui/rfc-2091-track-caller/intrinsic-wrapper.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2091-track-caller%2Fintrinsic-wrapper.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -1,5 +1,6 @@\n // run-pass\n // revisions: default mir-opt\n+//[default] compile-flags: -Zinline-mir=no\n //[mir-opt] compile-flags: -Zmir-opt-level=4\n \n macro_rules! caller_location_from_macro {\n@@ -9,13 +10,13 @@ macro_rules! caller_location_from_macro {\n fn main() {\n     let loc = core::panic::Location::caller();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 10);\n+    assert_eq!(loc.line(), 11);\n     assert_eq!(loc.column(), 15);\n \n     // `Location::caller()` in a macro should behave similarly to `file!` and `line!`,\n     // i.e. point to where the macro was invoked, instead of the macro itself.\n     let loc2 = caller_location_from_macro!();\n     assert_eq!(loc2.file(), file!());\n-    assert_eq!(loc2.line(), 17);\n+    assert_eq!(loc2.line(), 18);\n     assert_eq!(loc2.column(), 16);\n }"}, {"sha": "a2e8eb27edeacbf58e967b8fc3efa0cd649ffd1b", "filename": "tests/ui/rfc-2091-track-caller/mir-inlined-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febd59e122f67d26d410a62f661a941a706b28ec/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2091-track-caller%2Fmir-inlined-macro.rs?ref=febd59e122f67d26d410a62f661a941a706b28ec", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+// revisions: default mir-opt\n+//[default] compile-flags: -Zinline-mir=no\n+//[mir-opt] compile-flags: -Zmir-opt-level=4\n+\n+use std::panic::Location;\n+\n+macro_rules! f {\n+    () => {\n+        Location::caller()\n+    };\n+}\n+\n+#[inline(always)]\n+fn g() -> &'static Location<'static> {\n+    f!()\n+}\n+\n+fn main() {\n+    let loc = g();\n+    assert_eq!(loc.line(), 16);\n+    assert_eq!(loc.column(), 5);\n+}"}]}