{"sha": "1016deb592cec6d02e963bb3ffbfbb2c4f9309b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTZkZWI1OTJjZWM2ZDAyZTk2M2JiM2ZmYmZiYjJjNGY5MzA5Yjg=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-12T18:50:17Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-12T18:50:17Z"}, "message": "Small cleanups in Windows Mutex.\n\n- Move `held` into the boxed part, since the SRW lock implementation\n  does not use this. This makes the Mutex 50% smaller.\n- Use `Cell` instead of `UnsafeCell` for `held`, such that `.replace()`\n  can be used.\n- Add some comments.", "tree": {"sha": "45038fd9e8eb9cd3353bce32fc83d490e54877df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45038fd9e8eb9cd3353bce32fc83d490e54877df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8", "html_url": "https://github.com/rust-lang/rust/commit/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03", "html_url": "https://github.com/rust-lang/rust/commit/2d6cbd21b2c5819c7fa42eb5a3713667b67e4f03"}], "stats": {"total": 64, "additions": 32, "deletions": 32}, "files": [{"sha": "f2c57025a55ba6f2e86e819c9958f7dc47c2de3a", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1016deb592cec6d02e963bb3ffbfbb2c4f9309b8/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=1016deb592cec6d02e963bb3ffbfbb2c4f9309b8", "patch": "@@ -19,20 +19,25 @@\n //! CriticalSection is used and we keep track of who's holding the mutex to\n //! detect recursive locks.\n \n-use crate::cell::UnsafeCell;\n+use crate::cell::{Cell, UnsafeCell};\n use crate::mem::{self, MaybeUninit};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n use crate::sys::compat;\n \n pub struct Mutex {\n+    // This is either directly an SRWLOCK (if supported), or a Box<Inner> otherwise.\n     lock: AtomicUsize,\n-    held: UnsafeCell<bool>,\n }\n \n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n+struct Inner {\n+    remutex: ReentrantMutex,\n+    held: Cell<bool>,\n+}\n+\n #[derive(Clone, Copy)]\n enum Kind {\n     SRWLock = 1,\n@@ -51,7 +56,6 @@ impl Mutex {\n             // This works because SRWLOCK_INIT is 0 (wrapped in a struct), so we are also properly\n             // initializing an SRWLOCK here.\n             lock: AtomicUsize::new(0),\n-            held: UnsafeCell::new(false),\n         }\n     }\n     #[inline]\n@@ -60,10 +64,11 @@ impl Mutex {\n         match kind() {\n             Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),\n             Kind::CriticalSection => {\n-                let re = self.remutex();\n-                (*re).lock();\n-                if !self.flag_locked() {\n-                    (*re).unlock();\n+                let inner = &mut *self.inner();\n+                inner.remutex.lock();\n+                if inner.held.replace(true) {\n+                    // It was already locked, so we got a recursive lock which we do not want.\n+                    inner.remutex.unlock();\n                     panic!(\"cannot recursively lock a mutex\");\n                 }\n             }\n@@ -73,23 +78,27 @@ impl Mutex {\n         match kind() {\n             Kind::SRWLock => c::TryAcquireSRWLockExclusive(raw(self)) != 0,\n             Kind::CriticalSection => {\n-                let re = self.remutex();\n-                if !(*re).try_lock() {\n+                let inner = &mut *self.inner();\n+                if !inner.remutex.try_lock() {\n                     false\n-                } else if self.flag_locked() {\n-                    true\n-                } else {\n-                    (*re).unlock();\n+                } else if inner.held.replace(true) {\n+                    // It was already locked, so we got a recursive lock which we do not want.\n+                    inner.remutex.unlock();\n                     false\n+                } else {\n+                    true\n                 }\n             }\n         }\n     }\n     pub unsafe fn unlock(&self) {\n-        *self.held.get() = false;\n         match kind() {\n             Kind::SRWLock => c::ReleaseSRWLockExclusive(raw(self)),\n-            Kind::CriticalSection => (*self.remutex()).unlock(),\n+            Kind::CriticalSection => {\n+                let inner = &mut *(self.lock.load(Ordering::SeqCst) as *mut Inner);\n+                inner.held.set(false);\n+                inner.remutex.unlock();\n+            }\n         }\n     }\n     pub unsafe fn destroy(&self) {\n@@ -98,37 +107,28 @@ impl Mutex {\n             Kind::CriticalSection => match self.lock.load(Ordering::SeqCst) {\n                 0 => {}\n                 n => {\n-                    Box::from_raw(n as *mut ReentrantMutex).destroy();\n+                    Box::from_raw(n as *mut Inner).remutex.destroy();\n                 }\n             },\n         }\n     }\n \n-    unsafe fn remutex(&self) -> *mut ReentrantMutex {\n+    unsafe fn inner(&self) -> *mut Inner {\n         match self.lock.load(Ordering::SeqCst) {\n             0 => {}\n             n => return n as *mut _,\n         }\n-        let re = box ReentrantMutex::uninitialized();\n-        re.init();\n-        let re = Box::into_raw(re);\n-        match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n-            0 => re,\n+        let inner = box Inner { remutex: ReentrantMutex::uninitialized(), held: Cell::new(false) };\n+        inner.remutex.init();\n+        let inner = Box::into_raw(inner);\n+        match self.lock.compare_and_swap(0, inner as usize, Ordering::SeqCst) {\n+            0 => inner,\n             n => {\n-                Box::from_raw(re).destroy();\n+                Box::from_raw(inner).remutex.destroy();\n                 n as *mut _\n             }\n         }\n     }\n-\n-    unsafe fn flag_locked(&self) -> bool {\n-        if *self.held.get() {\n-            false\n-        } else {\n-            *self.held.get() = true;\n-            true\n-        }\n-    }\n }\n \n fn kind() -> Kind {"}]}