{"sha": "5e55fe875855a39ed87584d155d26c8c54d3adff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNTVmZTg3NTg1NWEzOWVkODc1ODRkMTU1ZDI2YzhjNTRkM2FkZmY=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-01-30T04:13:12Z"}, "committer": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-01-31T04:21:16Z"}, "message": "Revert RIMOV for libcore", "tree": {"sha": "4e099901f3bde8e3bb204343254959101dc5e269", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e099901f3bde8e3bb204343254959101dc5e269"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e55fe875855a39ed87584d155d26c8c54d3adff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e55fe875855a39ed87584d155d26c8c54d3adff", "html_url": "https://github.com/rust-lang/rust/commit/5e55fe875855a39ed87584d155d26c8c54d3adff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e55fe875855a39ed87584d155d26c8c54d3adff/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc3bb7b68a2e7e43b244a00c4ff96d14b74de251", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc3bb7b68a2e7e43b244a00c4ff96d14b74de251", "html_url": "https://github.com/rust-lang/rust/commit/cc3bb7b68a2e7e43b244a00c4ff96d14b74de251"}], "stats": {"total": 70, "additions": 35, "deletions": 35}, "files": [{"sha": "34b058f6a3b3c9cae595c8e0311c2d195676dd13", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -46,7 +46,7 @@ use vec;\n  * # WARNING\n  *\n  * For maximum performance, this type is implemented using some rather\n- * unsafe code.  In particular, this innocent looking `~[A]` pointer\n+ * unsafe code.  In particular, this innocent looking `~[mut A]` pointer\n  * *may be null!*  Therefore, it is important you not reach into the\n  * data structure manually but instead use the provided extensions.\n  *\n@@ -143,7 +143,7 @@ impl<A> DVec<A> {\n      * and return a new vector to replace it with.\n      */\n     #[inline(always)]\n-    fn swap_mut(f: &fn(v: ~[A]) -> ~[A]) {\n+    fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n         do self.swap |v| {\n             vec::cast_from_mut(f(vec::cast_to_mut(move v)))\n         }\n@@ -223,7 +223,7 @@ impl<A> DVec<A> {\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n-    fn borrow_mut<R>(op: fn(x: &mut [A]) -> R) -> R {\n+    fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n         do self.check_out |v| {\n             let mut v = move v;\n             let result = op(v);"}, {"sha": "d3d6c5ae2424ba760d82f6a871359e19c19e9c8d", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -169,7 +169,7 @@ struct SipState {\n     mut v1: u64,\n     mut v2: u64,\n     mut v3: u64,\n-    mut tail: [u8 * 8], // unprocessed bytes\n+    tail: [mut u8 * 8], // unprocessed bytes\n     mut ntail: uint,  // how many bytes in tail are valid\n }\n \n@@ -183,7 +183,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n         mut v1 : 0u64,\n         mut v2 : 0u64,\n         mut v3 : 0u64,\n-        mut tail : [0u8,0,0,0,0,0,0,0],\n+        tail : [mut 0u8,0,0,0,0,0,0,0],\n         mut ntail : 0u,\n     };\n     (&state).reset();"}, {"sha": "6d618627ece416ed1e5b1056869d8d9929835319", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -59,7 +59,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n \n     /// Read a single byte, returning a negative value for EOF or read error.\n     fn read_byte(&self) -> int;\n@@ -419,7 +419,7 @@ fn convert_whence(whence: SeekStyle) -> i32 {\n }\n \n impl *libc::FILE: Reader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         unsafe {\n             do vec::as_mut_buf(bytes) |buf_p, buf_len| {\n                 assert buf_len >= len;\n@@ -464,7 +464,7 @@ struct Wrapper<T, C> {\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n impl<R: Reader, C> Wrapper<R, C>: Reader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n     fn read_byte(&self) -> int { self.base.read_byte() }\n@@ -531,7 +531,7 @@ pub struct BytesReader {\n }\n \n impl BytesReader: Reader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n+    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         let count = uint::min(len, self.bytes.len() - self.pos);\n \n         let view = vec::view(self.bytes, self.pos, self.bytes.len());"}, {"sha": "976c186912b37032ff9cf638d57da4b3ae20d04a", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -254,7 +254,7 @@ impl Rng {\n     }\n \n     /// Shuffle a mutable vec in place\n-    fn shuffle_mut<T>(values: &mut [T]) {\n+    fn shuffle_mut<T>(values: &[mut T]) {\n         let mut i = values.len();\n         while i >= 2u {\n             // invariant: elements with index >= i have been locked in place."}, {"sha": "8aeae1adeec212d94e2d4e261c7306c533f5c842", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -289,7 +289,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n fn read_all(rd: io::Reader) -> ~str {\n     let buf = io::with_bytes_writer(|wr| {\n-        let mut bytes = [0, ..4096];\n+        let mut bytes = [mut 0, ..4096];\n         while !rd.eof() {\n             let nread = rd.read(bytes, bytes.len());\n             wr.write(bytes.view(0, nread));\n@@ -387,7 +387,7 @@ pub fn readclose(fd: c_int) -> ~str {\n         let file = os::fdopen(fd);\n         let reader = io::FILE_reader(file, false);\n         let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [0, ..4096];\n+            let mut bytes = [mut 0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n                 writer.write(bytes.view(0, nread));"}, {"sha": "e4cc66519585a5141ec38dff2dd79da1b37868ac", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -252,7 +252,7 @@ pub pure fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // Enough room to hold any number in any radix.\n     // Worst case: 64-bit number, binary-radix, with\n     // a leading negative sign = 65 bytes.\n-    let mut buf : [u8 * 65] = [0u8, ..65];\n+    let buf : [mut u8 * 65] = [mut 0u8, ..65];\n     let len = buf.len();\n \n     let mut i = len;"}, {"sha": "f516ed366de73939cb38a5180bf6c57fd433cd53", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e55fe875855a39ed87584d155d26c8c54d3adff/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5e55fe875855a39ed87584d155d26c8c54d3adff", "patch": "@@ -206,12 +206,12 @@ pub pure fn build_sized_opt<A>(size: Option<uint>,\n }\n \n /// Produces a mut vector from an immutable vector.\n-pub pure fn cast_to_mut<T>(v: ~[T]) -> ~[T] {\n+pub pure fn cast_to_mut<T>(v: ~[T]) -> ~[mut T] {\n     unsafe { ::cast::transmute(v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n-pub pure fn cast_from_mut<T>(v: ~[T]) -> ~[T] {\n+pub pure fn cast_from_mut<T>(v: ~[mut T]) -> ~[T] {\n     unsafe { ::cast::transmute(v) }\n }\n \n@@ -562,7 +562,7 @@ pub fn consume<T>(v: ~[T], f: fn(uint, v: T)) {\n     }\n }\n \n-pub fn consume_mut<T>(v: ~[T], f: fn(uint, v: T)) {\n+pub fn consume_mut<T>(v: ~[mut T], f: fn(uint, v: T)) {\n     consume(vec::cast_from_mut(v), f)\n }\n \n@@ -731,7 +731,7 @@ pub pure fn append_one<T>(lhs: ~[T], x: T) -> ~[T] {\n }\n \n #[inline(always)]\n-pub pure fn append_mut<T: Copy>(lhs: ~[T], rhs: &[const T]) -> ~[T] {\n+pub pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n     cast_to_mut(append(cast_from_mut(lhs), rhs))\n }\n \n@@ -1263,12 +1263,12 @@ pub pure fn zip<T, U>(v: ~[T], u: ~[U]) -> ~[(T, U)] {\n  * * a - The index of the first element\n  * * b - The index of the second element\n  */\n-pub fn swap<T>(v: &mut [T], a: uint, b: uint) {\n+pub fn swap<T>(v: &[mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n /// Reverse the order of elements in a vector, in place\n-pub fn reverse<T>(v: &mut [T]) {\n+pub fn reverse<T>(v: &[mut T]) {\n     let mut i: uint = 0;\n     let ln = len::<T>(v);\n     while i < ln / 2 { v[i] <-> v[ln - i - 1]; i += 1; }\n@@ -1349,7 +1349,7 @@ pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n /// a vector with mutable contents and you would like\n /// to mutate the contents as you iterate.\n #[inline(always)]\n-pub fn each_mut<T>(v: &mut [T], f: fn(elem: &mut T) -> bool) {\n+pub fn each_mut<T>(v: &[mut T], f: fn(elem: &mut T) -> bool) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {\n@@ -1519,7 +1519,7 @@ pub pure fn as_const_buf<T,U>(s: &[const T],\n \n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline(always)]\n-pub pure fn as_mut_buf<T,U>(s: &mut [T],\n+pub pure fn as_mut_buf<T,U>(s: &[mut T],\n                         f: fn(*mut T, uint) -> U) -> U {\n \n     unsafe {\n@@ -1640,9 +1640,9 @@ pub mod traits {\n         }\n     }\n \n-    impl<T: Copy> ~[T] : Add<&[const T],~[T]> {\n+    impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n         #[inline(always)]\n-        pure fn add(&self, rhs: & &self/[const T]) -> ~[T] {\n+        pure fn add(&self, rhs: & &self/[const T]) -> ~[mut T] {\n             append_mut(copy *self, (*rhs))\n         }\n     }\n@@ -2066,7 +2066,7 @@ pub mod raw {\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n-    pub unsafe fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n+    pub unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n         let repr: **SliceRepr = ::cast::transmute(&v);\n         return ::cast::reinterpret_cast(&addr_of(&((**repr).data)));\n     }\n@@ -2099,7 +2099,7 @@ pub mod raw {\n      * is newly allocated.\n      */\n     #[inline(always)]\n-    pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n+    pub unsafe fn init_elem<T>(v: &[mut T], i: uint, val: T) {\n         let mut box = Some(val);\n         do as_mut_buf(v) |p, _len| {\n             let mut box2 = None;\n@@ -2133,7 +2133,7 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[const T],\n+    pub unsafe fn copy_memory<T>(dst: &[mut T], src: &[const T],\n                                  count: uint) {\n         assert dst.len() >= count;\n         assert src.len() >= count;\n@@ -2200,7 +2200,7 @@ pub mod bytes {\n       * may overlap.\n       */\n     #[inline(always)]\n-    pub fn copy_memory(dst: &mut [u8], src: &[const u8], count: uint) {\n+    pub fn copy_memory(dst: &[mut u8], src: &[const u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n@@ -3155,7 +3155,7 @@ mod tests {\n \n     #[test]\n     fn reverse_and_reversed() {\n-        let mut v: ~[int] = ~[10, 20];\n+        let v: ~[mut int] = ~[mut 10, 20];\n         assert (v[0] == 10);\n         assert (v[1] == 20);\n         reverse(v);\n@@ -3170,13 +3170,13 @@ mod tests {\n \n         let v4 = reversed::<int>(~[]);\n         assert (v4 == ~[]);\n-        let mut v3: ~[int] = ~[];\n+        let v3: ~[mut int] = ~[mut];\n         reverse::<int>(v3);\n     }\n \n     #[test]\n     fn reversed_mut() {\n-        let mut v2 = reversed::<int>(~[10, 20]);\n+        let v2 = reversed::<int>(~[mut 10, 20]);\n         assert (v2[0] == 20);\n         assert (v2[1] == 10);\n     }\n@@ -3302,7 +3302,7 @@ mod tests {\n     #[test]\n     fn cast_from_mut_no_copy() {\n         unsafe {\n-            let mut x = ~[1, 2, 3];\n+            let x = ~[mut 1, 2, 3];\n             let addr = raw::to_ptr(x);\n             let x_imm = cast_from_mut(x);\n             let addr_imm = raw::to_ptr(x_imm);\n@@ -3564,7 +3564,7 @@ mod tests {\n     #[ignore(windows)]\n     #[should_fail]\n     fn test_consume_mut_fail() {\n-        let mut v = ~[(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let v = ~[mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n         do consume_mut(v) |_i, _elt| {\n             if i == 2 {\n@@ -3592,7 +3592,7 @@ mod tests {\n     #[ignore(windows)]\n     #[should_fail]\n     fn test_map_fail() {\n-        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n         do map(v) |_elt| {\n             if i == 2 {\n@@ -3918,7 +3918,7 @@ mod tests {\n     #[ignore(cfg(windows))]\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n-        let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let v = [mut (~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         do as_mut_buf(v) |_buf, _i| {\n             fail\n         }\n@@ -3929,7 +3929,7 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_copy_memory_oob() {\n         unsafe {\n-            let mut a = [1, 2, 3, 4];\n+            let a = [mut 1, 2, 3, 4];\n             let b = [1, 2, 3, 4, 5];\n             raw::copy_memory(a, b, 5);\n         }"}]}