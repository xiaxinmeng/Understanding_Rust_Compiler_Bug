{"sha": "af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmODFlYzJmNDNhZWFjMmRlNWVmYzdlMGQxYzZlNDU4OWI1N2Y3Zjg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T09:14:17Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-23T17:58:46Z"}, "message": "Rollup merge of #22559 - kmcallister:borrowck-readme, r=nikomatsakis\n\n And minor fixes to other docs.\n\nr? @nikomatsakis", "tree": {"sha": "14054acb9e94ba81bccbf489de2d3d7a1194976b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14054acb9e94ba81bccbf489de2d3d7a1194976b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "html_url": "https://github.com/rust-lang/rust/commit/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fab2b95354f519e89e07d4e4d723c24372e75fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fab2b95354f519e89e07d4e4d723c24372e75fd", "html_url": "https://github.com/rust-lang/rust/commit/0fab2b95354f519e89e07d4e4d723c24372e75fd"}, {"sha": "1597f915c55f5a5db3b76d9859ba8618c83b8c98", "url": "https://api.github.com/repos/rust-lang/rust/commits/1597f915c55f5a5db3b76d9859ba8618c83b8c98", "html_url": "https://github.com/rust-lang/rust/commit/1597f915c55f5a5db3b76d9859ba8618c83b8c98"}], "stats": {"total": 257, "additions": 103, "deletions": 154}, "files": [{"sha": "7d789bedc50b5c7f869ff943cda25c3315dfec65", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -465,7 +465,8 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * Replace all regions bound by `binder` with skolemized regions and\n      * return a map indicating which bound-region was replaced with what\n      * skolemized region. This is the first step of checking subtyping\n-     * when higher-ranked things are involved. See `doc.rs` for more details.\n+     * when higher-ranked things are involved. See `README.md` for more\n+     * details.\n      */\n \n     let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br| {\n@@ -490,7 +491,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n      * and checks to determine whether any of the skolemized regions created\n      * in `skol_map` would \"escape\" -- meaning that they are related to\n      * other regions in some way. If so, the higher-ranked subtyping doesn't\n-     * hold. See `doc.rs` for more details.\n+     * hold. See `README.md` for more details.\n      */\n \n     debug!(\"leak_check: skol_map={}\",\n@@ -533,7 +534,7 @@ pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n /// passed; currently, it's used in the trait matching code to create\n /// a set of nested obligations frmo an impl that matches against\n /// something higher-ranked.  More details can be found in\n-/// `middle::traits::doc.rs`.\n+/// `librustc/middle/traits/README.md`.\n ///\n /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n /// -> &'a int`, and the impl:"}, {"sha": "7800d99f8ed4ce7206bbe9b020b9255ae20d7a70", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See doc.rs\n+//! See README.md\n \n pub use self::Constraint::*;\n pub use self::Verify::*;"}, {"sha": "7db1138ac72f6e58a168ce6ca3fb08719141208b", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -852,7 +852,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n                 // The idea is that call.callee_id represents *the time when\n                 // the invoked function is actually running* and call.id\n                 // represents *the time to prepare the arguments and make the\n-                // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n+                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n                 // for an extended explanation of why this distinction is\n                 // important.\n                 //"}, {"sha": "9ef4a436b8d027b7093178d05c11338bc37ba9f0", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `doc.rs` for high-level documentation\n+//! See `README.md` for high-level documentation\n \n use super::Normalized;\n use super::SelectionContext;"}, {"sha": "2ce8eeb8f5a9583fc0aab4b74ab91b2234f1eb9d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! See `doc.rs` for high-level documentation\n+//! See `README.md` for high-level documentation\n #![allow(dead_code)] // FIXME -- just temporarily\n \n pub use self::MethodMatchResult::*;\n@@ -547,7 +547,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //\n     // The selection process begins by examining all in-scope impls,\n     // caller obligations, and so forth and assembling a list of\n-    // candidates. See `doc.rs` and the `Candidate` type for more details.\n+    // candidates. See `README.md` and the `Candidate` type for more\n+    // details.\n \n     fn candidate_from_obligation<'o>(&mut self,\n                                      stack: &TraitObligationStack<'o, 'tcx>)\n@@ -1619,7 +1620,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n-    // type error.  See `doc.rs` for more details.\n+    // type error.  See `README.md` for more details.\n \n     fn confirm_candidate(&mut self,\n                          obligation: &TraitObligation<'tcx>,"}, {"sha": "08f0897e7617e918e320dedd16d3ae3201cdd45b", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 75, "deletions": 126, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -53,8 +53,8 @@ Here `x` represents some variable, `LV.f` is a field reference,\n and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n-```text\n-struct S { f: uint }\n+```rust\n+struct S { f: i32 }\n ```\n \n and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n@@ -63,8 +63,8 @@ to an `LV` of `(*a).f`.\n Here is the formal grammar for the types we'll consider:\n \n ```text\n-TY = () | S<'LT...> | Box<TY> | & 'LT MQ TY\n-MQ = mut | imm | const\n+TY = i32 | bool | S<'LT...> | Box<TY> | & 'LT MQ TY\n+MQ = mut | imm\n ```\n \n Most of these types should be pretty self explanatory. Here `S` is a\n@@ -82,13 +82,13 @@ SD = struct S<'LT...> { (f: TY)... }\n \n Now, imagine we had a program like this:\n \n-```text\n-struct Foo { f: uint, g: uint }\n+```rust\n+struct Foo { f: i32, g: i32 }\n ...\n 'a: {\n-  let mut x: Box<Foo> = ...;\n-  let y = &mut (*x).f;\n-  x = ...;\n+    let mut x: Box<Foo> = ...;\n+    let y = &mut (*x).f;\n+    x = ...;\n }\n ```\n \n@@ -198,7 +198,7 @@ The kinds of expressions which in-scope loans can render illegal are:\n \n Now that we hopefully have some kind of intuitive feeling for how the\n borrow checker works, let's look a bit more closely now at the precise\n-conditions that it uses. For simplicity I will ignore const loans.\n+conditions that it uses.\n \n I will present the rules in a modified form of standard inference\n rules, which looks as follows:\n@@ -261,12 +261,11 @@ that will go into the final loan. We'll discuss in more detail below.\n ## Checking mutability\n \n Checking mutability is fairly straightforward. We just want to prevent\n-immutable data from being borrowed as mutable. Note that it is ok to\n-borrow mutable data as immutable, since that is simply a\n-freeze. Formally we define a predicate `MUTABLE(LV, MQ)` which, if\n-defined, means that \"borrowing `LV` with mutability `MQ` is ok. The\n-Rust code corresponding to this predicate is the function\n-`check_mutability` in `middle::borrowck::gather_loans`.\n+immutable data from being borrowed as mutable. Note that it is ok to borrow\n+mutable data as immutable, since that is simply a freeze. The judgement\n+`MUTABILITY(LV, MQ)` means the mutability of `LV` is compatible with a borrow\n+of mutability `MQ`. The Rust code corresponding to this predicate is the\n+function `check_mutability` in `middle::borrowck::gather_loans`.\n \n ### Checking mutability of variables\n \n@@ -275,15 +274,14 @@ but also the code in `mem_categorization`.\n \n Let's begin with the rules for variables, which state that if a\n variable is declared as mutable, it may be borrowed any which way, but\n-otherwise the variable must be borrowed as immutable or const:\n+otherwise the variable must be borrowed as immutable:\n \n ```text\n MUTABILITY(X, MQ)                   // M-Var-Mut\n   DECL(X) = mut\n \n-MUTABILITY(X, MQ)                   // M-Var-Imm\n+MUTABILITY(X, imm)                  // M-Var-Imm\n   DECL(X) = imm\n-  MQ = imm | const\n ```\n \n ### Checking mutability of owned content\n@@ -304,12 +302,11 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n ### Checking mutability of immutable pointer types\n \n Immutable pointer types like `&T` can only\n-be borrowed if MQ is immutable or const:\n+be borrowed if MQ is immutable:\n \n ```text\n-MUTABILITY(*LV, MQ)                // M-Deref-Borrowed-Imm\n+MUTABILITY(*LV, imm)               // M-Deref-Borrowed-Imm\n   TYPE(LV) = &Ty\n-  MQ == imm | const\n ```\n \n ### Checking mutability of mutable pointer types\n@@ -323,12 +320,11 @@ MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n \n ## Checking aliasability\n \n-The goal of the aliasability check is to ensure that we never permit\n-`&mut` borrows of aliasable data. Formally we define a predicate\n-`ALIASABLE(LV, MQ)` which if defined means that\n-\"borrowing `LV` with mutability `MQ` is ok\". The\n-Rust code corresponding to this predicate is the function\n-`check_aliasability()` in `middle::borrowck::gather_loans`.\n+The goal of the aliasability check is to ensure that we never permit `&mut`\n+borrows of aliasable data. The judgement `ALIASABLE(LV, MQ)` means the\n+aliasability of `LV` is compatible with a borrow of mutability `MQ`. The Rust\n+code corresponding to this predicate is the function `check_aliasability()` in\n+`middle::borrowck::gather_loans`.\n \n ### Checking aliasability of variables\n \n@@ -379,48 +375,14 @@ Formally, we define a predicate `LIFETIME(LV, LT, MQ)`, which states that\n `MQ`\". The Rust code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n-### The Scope function\n-\n-Several of the rules refer to a helper function `SCOPE(LV)=LT`.  The\n-`SCOPE(LV)` yields the lifetime `LT` for which the lvalue `LV` is\n-guaranteed to exist, presuming that no mutations occur.\n-\n-The scope of a local variable is the block where it is declared:\n-\n-```text\n-  SCOPE(X) = block where X is declared\n-```\n-\n-The scope of a field is the scope of the struct:\n-\n-```text\n-  SCOPE(LV.f) = SCOPE(LV)\n-```\n-\n-The scope of a unique referent is the scope of the pointer, since\n-(barring mutation or moves) the pointer will not be freed until\n-the pointer itself `LV` goes out of scope:\n-\n-```text\n-  SCOPE(*LV) = SCOPE(LV) if LV has type Box<T>\n-```\n-\n-The scope of a borrowed referent is the scope associated with the\n-pointer.  This is a conservative approximation, since the data that\n-the pointer points at may actually live longer:\n-\n-```text\n-  SCOPE(*LV) = LT if LV has type &'LT T or &'LT mut T\n-```\n-\n ### Checking lifetime of variables\n \n The rule for variables states that a variable can only be borrowed a\n lifetime `LT` that is a subregion of the variable's scope:\n \n ```text\n LIFETIME(X, LT, MQ)                 // L-Local\n-  LT <= SCOPE(X)\n+  LT <= block where X is declared\n ```\n \n ### Checking lifetime for owned content\n@@ -466,15 +428,12 @@ are computed based on the kind of borrow:\n ```text\n &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n-&const LV => RESTRICTIONS(LV, LT, [])\n ```\n \n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n (`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n permits other immutable borrows but forbids writes and mutable borrows.\n-Finally, a const borrow just wants to be sure that the value is not\n-moved out from under it, so no actions are forbidden.\n \n ### Restrictions for loans of a local variable\n \n@@ -548,8 +507,8 @@ specify that the lifetime of the loan must be less than the lifetime\n of the `&Ty` pointer. In simple cases, this clause is redundant, since\n the `LIFETIME()` function will already enforce the required rule:\n \n-```\n-fn foo(point: &'a Point) -> &'static f32 {\n+```rust\n+fn foo(point: &'a Point) -> &'static i32 {\n     &point.x // Error\n }\n ```\n@@ -558,8 +517,8 @@ The above example fails to compile both because of clause (1) above\n but also by the basic `LIFETIME()` check. However, in more advanced\n examples involving multiple nested pointers, clause (1) is needed:\n \n-```\n-fn foo(point: &'a &'b mut Point) -> &'b f32 {\n+```rust\n+fn foo(point: &'a &'b mut Point) -> &'b i32 {\n     &point.x // Error\n }\n ```\n@@ -577,8 +536,8 @@ which is only `'a`, not `'b`. Hence this example yields an error.\n As a final twist, consider the case of two nested *immutable*\n pointers, rather than a mutable pointer within an immutable one:\n \n-```\n-fn foo(point: &'a &'b Point) -> &'b f32 {\n+```rust\n+fn foo(point: &'a &'b Point) -> &'b i32 {\n     &point.x // OK\n }\n ```\n@@ -599,8 +558,8 @@ The rules pertaining to `LIFETIME` exist to ensure that we don't\n create a borrowed pointer that outlives the memory it points at. So\n `LIFETIME` prevents a function like this:\n \n-```\n-fn get_1<'a>() -> &'a int {\n+```rust\n+fn get_1<'a>() -> &'a i32 {\n     let x = 1;\n     &x\n }\n@@ -619,8 +578,8 @@ after we return and hence the remaining code in `'a` cannot possibly\n mutate it. This distinction is important for type checking functions\n like this one:\n \n-```\n-fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n+```rust\n+fn inc_and_get<'a>(p: &'a mut Point) -> &'a i32 {\n     p.x += 1;\n     &p.x\n }\n@@ -641,19 +600,6 @@ in terms of capability, the caller passed in the ability to mutate\n `*p` is borrowed since that would be a move of `p`, as `&mut` pointers\n are affine.)\n \n-### Restrictions for loans of const aliasable referents\n-\n-Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n-we can not prevent *anything* but moves in that case. So the\n-`RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n-Because moves from a `&const` lvalue are never legal, it is not\n-necessary to add any restrictions at all to the final result.\n-\n-```text\n-    RESTRICTIONS(*LV, LT, []) = []                // R-Deref-Freeze-Borrowed\n-      TYPE(LV) = &const Ty\n-```\n-\n ### Restrictions for loans of mutable borrowed referents\n \n Mutable borrowed pointers are guaranteed to be the only way to mutate\n@@ -685,7 +631,7 @@ maximum of `LT'`.\n \n Here is a concrete example of a bug this rule prevents:\n \n-```\n+```rust\n // Test region-reborrow-from-shorter-mut-ref.rs:\n fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n     &mut **p // ERROR due to clause (1)\n@@ -713,10 +659,10 @@ ways to violate the rules is to move the base pointer to a new name\n and access it via that new name, thus bypassing the restrictions on\n the old name. Here is an example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-fn foo(t0: &mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo(t0: &mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let t1 = t0;        //~ ERROR cannot move out of `t0`\n     *t1 = 22;           // OK, not a write through `*t0`\n }\n@@ -733,11 +679,11 @@ danger is to mutably borrow the base path. This can lead to two bad\n scenarios. The most obvious is that the mutable borrow itself becomes\n another path to access the same data, as shown here:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     let mut t2 = &mut t0;   //~ ERROR cannot borrow `t0`\n     **t2 += 1;              // Mutates `*t0`\n }\n@@ -754,11 +700,11 @@ of `t0`. Hence the claim `&mut t0` is illegal.\n Another danger with an `&mut` pointer is that we could swap the `t0`\n value away to create a new path:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0;     // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0;     // Freezes `*t0`\n     swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n     *t1 = 22;\n }\n@@ -772,37 +718,37 @@ careful to ensure this example is still illegal.\n referent is claimed, even freezing the base pointer can be dangerous,\n as shown in the following example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &mut int = &mut *t0; // Claims `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &mut i32 = &mut *t0; // Claims `*t0`\n     let mut t2 = &t0;           //~ ERROR cannot borrow `t0`\n-    let q: &int = &*t2;         // Freezes `*t0` but not through `*p`\n+    let q: &i32 = &*t2;         // Freezes `*t0` but not through `*p`\n     *p += 1;                    // violates type of `*q`\n }\n ```\n \n Here the problem is that `*t0` is claimed by `p`, and hence `p` wants\n to be the controlling pointer through which mutation or freezes occur.\n-But `t2` would -- if it were legal -- have the type `& &mut int`, and\n+But `t2` would -- if it were legal -- have the type `& &mut i32`, and\n hence would be a mutable pointer in an aliasable location, which is\n considered frozen (since no one can write to `**t2` as it is not a\n-unique path). Therefore, we could reasonably create a frozen `&int`\n+unique path). Therefore, we could reasonably create a frozen `&i32`\n pointer pointing at `*t0` that coexists with the mutable pointer `p`,\n which is clearly unsound.\n \n However, it is not always unsafe to freeze the base pointer. In\n particular, if the referent is frozen, there is no harm in it:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n-fn foo<'a>(mut t0: &'a mut int,\n-           mut t1: &'a mut int) {\n-    let p: &int = &*t0; // Freezes `*t0`\n+fn foo<'a>(mut t0: &'a mut i32,\n+           mut t1: &'a mut i32) {\n+    let p: &i32 = &*t0; // Freezes `*t0`\n     let mut t2 = &t0;\n-    let q: &int = &*t2; // Freezes `*t0`, but that's ok...\n-    let r: &int = &*t0; // ...after all, could do same thing directly.\n+    let q: &i32 = &*t2; // Freezes `*t0`, but that's ok...\n+    let r: &i32 = &*t0; // ...after all, could do same thing directly.\n }\n ```\n \n@@ -811,11 +757,11 @@ thing `t2` can be used for is to further freeze `*t0`, which is\n already frozen. In particular, we cannot assign to `*t0` through the\n new alias `t2`, as demonstrated in this test case:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n-fn foo(t0: & &mut int) {\n+fn foo(t0: & &mut i32) {\n     let t1 = t0;\n-    let p: &int = &**t0;\n+    let p: &i32 = &**t0;\n     **t1 = 22; //~ ERROR cannot assign\n }\n ```\n@@ -855,6 +801,9 @@ prohibited from both freezes and claims. This would avoid the need to\n prevent `const` borrows of the base pointer when the referent is\n borrowed.\n \n+[ Previous revisions of this document discussed `&const` in more detail.\n+See the revision history. ]\n+\n # Moves and initialization\n \n The borrow checker is also in charge of ensuring that:\n@@ -881,9 +830,9 @@ moves/uninitializations of the variable that is being used.\n \n Let's look at a simple example:\n \n-```\n-fn foo(a: Box<int>) {\n-    let b: Box<int>;   // Gen bit 0.\n+```rust\n+fn foo(a: Box<i32>) {\n+    let b: Box<i32>;   // Gen bit 0.\n \n     if cond {          // Bits: 0\n         use(&*a);\n@@ -897,7 +846,7 @@ fn foo(a: Box<int>) {\n     use(&*b);          // Error.\n }\n \n-fn use(a: &int) { }\n+fn use(a: &i32) { }\n ```\n \n In this example, the variable `b` is created uninitialized. In one\n@@ -1028,8 +977,8 @@ not) the destructor invocation for that path.\n A simple example of this is the following:\n \n ```rust\n-struct D { p: int }\n-impl D { fn new(x: int) -> D { ... }\n+struct D { p: i32 }\n+impl D { fn new(x: i32) -> D { ... }\n impl Drop for D { ... }\n \n fn foo(a: D, b: D, t: || -> bool) {\n@@ -1142,7 +1091,7 @@ the elements of an array that has been passed by value, such as\n the following:\n \n ```rust\n-fn foo(a: [D; 10], i: uint) -> D {\n+fn foo(a: [D; 10], i: i32) -> D {\n     a[i]\n }\n ```\n@@ -1158,7 +1107,7 @@ all-but-one element of the array.  A place where that distinction\n would arise is the following:\n \n ```rust\n-fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n+fn foo(a: [D; 10], b: [D; 10], i: i32, t: bool) -> D {\n     if t {\n         a[i]\n     } else {\n@@ -1173,7 +1122,7 @@ fn foo(a: [D; 10], b: [D; 10], i: uint, t: bool) -> D {\n \n There are a number of ways that the trans backend could choose to\n compile this (e.g. a `[bool; 10]` array for each such moved array;\n-or an `Option<uint>` for each moved array).  From the viewpoint of the\n+or an `Option<usize>` for each moved array).  From the viewpoint of the\n borrow-checker, the important thing is to record what kind of fragment\n is implied by the relevant moves.\n "}, {"sha": "8cb4090bf39290ed2330f78d21527e05790d449f", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -10,7 +10,7 @@\n \n //! Helper routines used for fragmenting structural paths due to moves for\n //! tracking drop obligations. Please see the extensive comments in the\n-//! section \"Structural fragments\" in `doc.rs`.\n+//! section \"Structural fragments\" in `README.md`.\n \n use self::Fragment::*;\n "}, {"sha": "9f7b4cf26e1c47fa60dabc40b6bdc37abb10c293", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -106,8 +106,6 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n-        // See the SCOPE(LV) function in doc.rs\n-\n         match cmt.cat {\n             mc::cat_rvalue(temp_scope) => {\n                 temp_scope"}, {"sha": "d51ad6e0c97b5f3b9a44b73454add2b96f471eae", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -173,7 +173,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n }\n \n-/// Implements the A-* rules in doc.rs.\n+/// Implements the A-* rules in README.md.\n fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 borrow_span: Span,\n                                 loan_cause: euv::LoanCause,\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                                       cmt: mc::cmt<'tcx>,\n                                       req_kind: ty::BorrowKind)\n                                       -> Result<(),()> {\n-            //! Implements the M-* rules in doc.rs.\n+            //! Implements the M-* rules in README.md.\n \n             match req_kind {\n                 ty::UniqueImmBorrow | ty::ImmBorrow => {"}, {"sha": "fd7880212f10b24e292a738d94fdcaaec4a36993", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -295,7 +295,7 @@ impl<'tcx> PartialEq for LoanPath<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n-    LpVar(ast::NodeId),                         // `x` in doc.rs\n+    LpVar(ast::NodeId),                         // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, ast::DefId), // `x` downcast to particular enum variant\n     LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n@@ -336,8 +336,8 @@ impl ToInteriorKind for mc::InteriorKind {\n \n #[derive(Copy, PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathElem {\n-    LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n-    LpInterior(InteriorKind),    // `LV.f` in doc.rs\n+    LpDeref(mc::PointerKind),    // `*LV` in README.md\n+    LpInterior(InteriorKind),    // `LV.f` in README.md\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,"}, {"sha": "0f7f8e61e37e0a1788c2a20ae0d79a48fd14ff22", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n //! Data structures used for tracking moves. Please see the extensive\n-//! comments in the section \"Moves and initialization\" in `doc.rs`.\n+//! comments in the section \"Moves and initialization\" in `README.md`.\n \n pub use self::MoveKind::*;\n \n@@ -33,7 +33,7 @@ use syntax::codemap::Span;\n pub mod fragments;\n \n pub struct MoveData<'tcx> {\n-    /// Move paths. See section \"Move paths\" in `doc.rs`.\n+    /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n \n     /// Cache of loan path to move path index, for easy lookup.\n@@ -464,7 +464,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n-    /// killed by scoping. See `doc.rs` for more details.\n+    /// killed by scoping. See `README.md` for more details.\n     fn add_gen_kills(&self,\n                      tcx: &ty::ctxt<'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,"}, {"sha": "e0598583a1954f61ac2e33854f95f64fa81b684c", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -122,7 +122,7 @@ use syntax::codemap::DUMMY_SP;\n /// A `Datum` encapsulates the result of evaluating an expression.  It\n /// describes where the value is stored, what Rust type the value has,\n /// whether it is addressed by reference, and so forth. Please refer\n-/// the section on datums in `doc.rs` for more details.\n+/// the section on datums in `README.md` for more details.\n #[derive(Clone, Copy)]\n pub struct Datum<'tcx, K> {\n     /// The llvm value.  This is either a pointer to the Rust value or"}, {"sha": "256cd415a33afbf9a07ea87a8042cdd794e8f328", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Method lookup: the secret sauce of Rust. See `doc.rs`.\n+//! Method lookup: the secret sauce of Rust. See `README.md`.\n \n use astconv::AstConv;\n use check::{FnCtxt};"}, {"sha": "df2fb538c0a5080d034e72fd0fac78f5cb71cf25", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -203,7 +203,7 @@ fn test_resize_policy() {\n // produces identical results to a linear naive reinsertion from the same\n // element.\n //\n-// FIXME(Gankro, pczarn): review the proof and put it all in a separate doc.rs\n+// FIXME(Gankro, pczarn): review the proof and put it all in a separate README.md\n \n /// A hash map implementation which uses linear probing with Robin\n /// Hood bucket stealing."}, {"sha": "d60751eddc7bc201866255cb0b129c90744be516", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to reborrow an `&mut` pointer in an aliasable\n // location yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo(t0: & &mut isize) {\n     let t1 = t0;"}, {"sha": "2fb89e6364bb1e8b24a8607cd18d46f9329fe502", "filename": "src/test/compile-fail/borrowck-move-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to move `&mut` pointer while pointee is borrowed\n // yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo(t0: &mut isize) {\n     let p: &isize = &*t0; // Freezes `*t0`"}, {"sha": "bdeb7ea69bdfb84d416420bc26f3474e373d6c90", "filename": "src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-borrow-of-mut-base-ptr.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to mutably borrow `&mut` pointer while pointee is\n // borrowed yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo<'a>(mut t0: &'a mut isize,\n            mut t1: &'a mut isize) {"}, {"sha": "552fcec8e2858e921fd6a8842b3981667986e5a0", "filename": "src/test/compile-fail/borrowck-swap-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -11,7 +11,7 @@\n // Test that attempt to swap `&mut` pointer while pointee is borrowed\n // yields an error.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n use std::mem::swap;\n "}, {"sha": "48129f2b6ddc3ebe2b1251bca6e41085c305bc45", "filename": "src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-of-mut-base-ptr-safe.rs?ref=af81ec2f43aeac2de5efc7e0d1c6e4589b57f7f8", "patch": "@@ -11,7 +11,7 @@\n // Test that freezing an `&mut` pointer while referent is\n // frozen is legal.\n //\n-// Example from src/middle/borrowck/doc.rs\n+// Example from src/librustc_borrowck/borrowck/README.md\n \n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {"}]}