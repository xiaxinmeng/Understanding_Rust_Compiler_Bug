{"sha": "46f9253098ce2793c57e28bf3f79ace0946ccb3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjkyNTMwOThjZTI3OTNjNTdlMjhiZjNmNzlhY2UwOTQ2Y2NiM2U=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-03-03T07:27:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-03T07:27:39Z"}, "message": "Rollup merge of #82439 - ssomers:btree_fix_unsafety, r=Mark-Simulacrum\n\nBTree: fix untrue safety\n\nFix needless and missing `unsafe` tags.\n\nr? ````@Mark-Simulacrum````", "tree": {"sha": "f9395abec5e69e8aa23ab279d97a540d8a493f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9395abec5e69e8aa23ab279d97a540d8a493f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f9253098ce2793c57e28bf3f79ace0946ccb3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgPzprCRBK7hj4Ov3rIwAAdHIIADeI/4wutwGDWAV+Si5RQDL3\nPMqRYOd5fHXQjmlHZvjZqBuQEgY/p8T39Pa1SeCDYp9NwjE4JFa9hJVw6ZKhx47c\nWXcCjggbWillNZtZTnywkcFruk4r0K/vmReic2gFFVUwnfSPXl6U6oz7ZCEwmmEA\n4/0oMXtKCZTGnMkGWD219J+hkbIEX5+hxfcRp71i9O0RNa8CEIV6KjPxP+q80XmO\neIHDrEev9jG0L/ExYNktp0YblCbrvRuWKlKMVQnb4QaEuYVPADv8/VPzaiGV0vb6\nXJ2l1CDBUnVJti3Cwov8UTgZjJnyfVGS90TYmQbO2EGYWZytgwHW36JrWXRpDgQ=\n=UMYE\n-----END PGP SIGNATURE-----\n", "payload": "tree f9395abec5e69e8aa23ab279d97a540d8a493f40\nparent 9a827d9f7e3d0f256f832b6f42f87aefa4648d0a\nparent 986a1833377a4fd6f534ac877b2a65ea98f657b7\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1614756459 +0900\ncommitter GitHub <noreply@github.com> 1614756459 +0900\n\nRollup merge of #82439 - ssomers:btree_fix_unsafety, r=Mark-Simulacrum\n\nBTree: fix untrue safety\n\nFix needless and missing `unsafe` tags.\n\nr? ````@Mark-Simulacrum````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f9253098ce2793c57e28bf3f79ace0946ccb3e", "html_url": "https://github.com/rust-lang/rust/commit/46f9253098ce2793c57e28bf3f79ace0946ccb3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f9253098ce2793c57e28bf3f79ace0946ccb3e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a827d9f7e3d0f256f832b6f42f87aefa4648d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a827d9f7e3d0f256f832b6f42f87aefa4648d0a", "html_url": "https://github.com/rust-lang/rust/commit/9a827d9f7e3d0f256f832b6f42f87aefa4648d0a"}, {"sha": "986a1833377a4fd6f534ac877b2a65ea98f657b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/986a1833377a4fd6f534ac877b2a65ea98f657b7", "html_url": "https://github.com/rust-lang/rust/commit/986a1833377a4fd6f534ac877b2a65ea98f657b7"}], "stats": {"total": 31, "additions": 15, "deletions": 16}, "files": [{"sha": "9a7119470f370ad4871f4b2514034d699c1e0606", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/46f9253098ce2793c57e28bf3f79ace0946ccb3e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f9253098ce2793c57e28bf3f79ace0946ccb3e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=46f9253098ce2793c57e28bf3f79ace0946ccb3e", "patch": "@@ -77,9 +77,8 @@ impl<K, V> LeafNode<K, V> {\n         }\n     }\n \n-    /// Creates a new boxed `LeafNode`. Unsafe because all nodes should really be hidden behind\n-    /// `BoxedNode`, preventing accidental dropping of uninitialized keys and values.\n-    unsafe fn new() -> Box<Self> {\n+    /// Creates a new boxed `LeafNode`.\n+    fn new() -> Box<Self> {\n         unsafe {\n             let mut leaf = Box::new_uninit();\n             LeafNode::init(leaf.as_mut_ptr());\n@@ -107,10 +106,9 @@ struct InternalNode<K, V> {\n impl<K, V> InternalNode<K, V> {\n     /// Creates a new boxed `InternalNode`.\n     ///\n-    /// This is unsafe for two reasons. First, it returns an owned `InternalNode` in a box, risking\n-    /// dropping of uninitialized fields. Second, an invariant of internal nodes is that `len + 1`\n-    /// edges are initialized and valid, meaning that even when the node is empty (having a\n-    /// `len` of 0), there must be one initialized and valid edge. This function does not set up\n+    /// # Safety\n+    /// An invariant of internal nodes is that they have at least one\n+    /// initialized and valid edge. This function does not set up\n     /// such an edge.\n     unsafe fn new() -> Box<Self> {\n         unsafe {\n@@ -144,7 +142,7 @@ impl<K, V> Root<K, V> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     fn new_leaf() -> Self {\n-        Self::from_new_leaf(unsafe { LeafNode::new() })\n+        Self::from_new_leaf(LeafNode::new())\n     }\n \n     fn from_new_leaf(leaf: Box<LeafNode<K, V>>) -> Self {\n@@ -156,10 +154,13 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     fn new_internal(child: Root<K, V>) -> Self {\n         let mut new_node = unsafe { InternalNode::new() };\n         new_node.edges[0].write(child.node);\n-        NodeRef::from_new_internal(new_node, child.height + 1)\n+        unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }\n     }\n \n-    fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n+    /// # Safety\n+    /// `height` must not be zero.\n+    unsafe fn from_new_internal(internal: Box<InternalNode<K, V>>, height: usize) -> Self {\n+        debug_assert!(height > 0);\n         let node = NonNull::from(Box::leak(internal)).cast();\n         let mut this = NodeRef { height, node, _marker: PhantomData };\n         this.borrow_mut().correct_all_childrens_parent_links();\n@@ -1080,14 +1081,12 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n     /// - All the key-value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Leaf> {\n-        unsafe {\n-            let mut new_node = LeafNode::new();\n+        let mut new_node = LeafNode::new();\n \n-            let kv = self.split_leaf_data(&mut new_node);\n+        let kv = self.split_leaf_data(&mut new_node);\n \n-            let right = NodeRef::from_new_leaf(new_node);\n-            SplitResult { left: self.node, kv, right }\n-        }\n+        let right = NodeRef::from_new_leaf(new_node);\n+        SplitResult { left: self.node, kv, right }\n     }\n \n     /// Removes the key-value pair pointed to by this handle and returns it, along with the edge"}]}