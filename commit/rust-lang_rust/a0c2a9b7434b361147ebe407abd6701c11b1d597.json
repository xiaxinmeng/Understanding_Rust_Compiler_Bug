{"sha": "a0c2a9b7434b361147ebe407abd6701c11b1d597", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYzJhOWI3NDM0YjM2MTE0N2ViZTQwN2FiZDY3MDFjMTFiMWQ1OTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-10T07:17:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-11T05:44:59Z"}, "message": "librustc: Implement a #[no_mangle] attribute to suppress name mangling. r=brson\n\nThis is very helpful for SDL, as SDL wants you to define a function named\n`SDL_main`.", "tree": {"sha": "40bf6fa5577fe3a30c376f89640eb693e137d35d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40bf6fa5577fe3a30c376f89640eb693e137d35d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0c2a9b7434b361147ebe407abd6701c11b1d597", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c2a9b7434b361147ebe407abd6701c11b1d597", "html_url": "https://github.com/rust-lang/rust/commit/a0c2a9b7434b361147ebe407abd6701c11b1d597", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0c2a9b7434b361147ebe407abd6701c11b1d597/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c05a6c092ac80904b6c3054688f23337b126f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c05a6c092ac80904b6c3054688f23337b126f3c", "html_url": "https://github.com/rust-lang/rust/commit/0c05a6c092ac80904b6c3054688f23337b126f3c"}], "stats": {"total": 90, "additions": 59, "deletions": 31}, "files": [{"sha": "81f748a3e602dfe0816fb8ccf0866a0947103a30", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -171,8 +171,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n }\n \n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n-    let ignoreattrs = attr::find_attrs_by_name(/*bad*/copy i.attrs,\n-                                               ~\"ignore\");\n+    let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n         |i| attr::get_meta_item_list(*i)));"}, {"sha": "4627516416214202d664db07361ad6ce1b199c6b", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -147,8 +147,7 @@ fn visit_item(e: env, i: @ast::item) {\n \n         let cstore = e.cstore;\n         let mut already_added = false;\n-        let link_args = attr::find_attrs_by_name(/*bad*/copy i.attrs,\n-                                                 ~\"link_args\");\n+        let link_args = attr::find_attrs_by_name(i.attrs, \"link_args\");\n \n         match fm.sort {\n           ast::named => {"}, {"sha": "02264d1ea93b9a9f9ad945c784dd7d44d18d5a9b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -329,8 +329,7 @@ impl ctxt {\n         for [allow, warn, deny, forbid].each |level| {\n             let level_name = level_to_str(*level);\n             let metas =\n-                attr::attr_metas(attr::find_attrs_by_name(/*bad*/copy attrs,\n-                                                          level_name));\n+                attr::attr_metas(attr::find_attrs_by_name(attrs, level_name));\n             for metas.each |meta| {\n                 match /*bad*/copy meta.node {\n                   ast::meta_list(_, metas) => {"}, {"sha": "0134e1a7285a1cf456ea279342f916075bf3ccb5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 42, "deletions": 18, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -76,7 +76,7 @@ use core::uint;\n use std::map::HashMap;\n use std::smallintmap;\n use std::{map, time, list};\n-use syntax::ast_map::{path, path_mod, path_name};\n+use syntax::ast_map::{path, path_elt_to_str, path_mod, path_name};\n use syntax::ast_util::{def_id_of_def, local_def, path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n@@ -2086,28 +2086,44 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n fn register_fn(ccx: @crate_ctxt,\n                sp: span,\n                +path: path,\n-               node_id: ast::node_id)\n+               node_id: ast::node_id,\n+               attrs: &[ast::attribute])\n             -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    register_fn_full(ccx, sp, path, node_id, t)\n+    register_fn_full(ccx, sp, path, node_id, attrs, t)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt, sp: span, +path: path,\n-                    node_id: ast::node_id, node_type: ty::t) -> ValueRef {\n+fn register_fn_full(ccx: @crate_ctxt,\n+                    sp: span,\n+                    +path: path,\n+                    node_id: ast::node_id,\n+                    attrs: &[ast::attribute],\n+                    node_type: ty::t)\n+                 -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n-    register_fn_fuller(ccx, sp, path, node_id, node_type,\n+    register_fn_fuller(ccx, sp, path, node_id, attrs, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n \n-fn register_fn_fuller(ccx: @crate_ctxt, sp: span, +path: path,\n-                      node_id: ast::node_id, node_type: ty::t,\n-                      cc: lib::llvm::CallConv, llfty: TypeRef) -> ValueRef {\n+fn register_fn_fuller(ccx: @crate_ctxt,\n+                      sp: span,\n+                      +path: path,\n+                      node_id: ast::node_id,\n+                      attrs: &[ast::attribute],\n+                      node_type: ty::t,\n+                      cc: lib::llvm::CallConv,\n+                      llfty: TypeRef)\n+                   -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n \n-    // XXX: Bad copy.\n-    let ps: ~str = mangle_exported_name(ccx, copy path, node_type);\n+    let ps = if attr::attrs_contains_name(attrs, \"no_mangle\") {\n+        path_elt_to_str(path.last(), ccx.sess.parse_sess.interner)\n+    } else {\n+        mangle_exported_name(ccx, /*bad*/copy path, node_type)\n+    };\n+\n     // XXX: Bad copy.\n     let llfn: ValueRef = decl_fn(ccx.llmod, copy ps, cc, llfty);\n     ccx.item_symbols.insert(node_id, ps);\n@@ -2281,9 +2297,13 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n               }\n               ast::item_fn(_, purity, _, _) => {\n                 let llfn = if purity != ast::extern_fn {\n-                    register_fn(ccx, i.span, my_path, i.id)\n+                    register_fn(ccx, i.span, my_path, i.id, i.attrs)\n                 } else {\n-                    foreign::register_foreign_fn(ccx, i.span, my_path, i.id)\n+                    foreign::register_foreign_fn(ccx,\n+                                                 i.span,\n+                                                 my_path,\n+                                                 i.id,\n+                                                 i.attrs)\n                 };\n                 set_inline_hint_if_appr(/*bad*/copy i.attrs, llfn);\n                 llfn\n@@ -2315,7 +2335,8 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                     register_fn(ccx, ni.span,\n                                 vec::append(/*bad*/copy *pth,\n                                             ~[path_name(ni.ident)]),\n-                                ni.id)\n+                                ni.id,\n+                                ni.attrs)\n                 }\n                 ast::foreign_item_const(*) => {\n                     let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n@@ -2366,7 +2387,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                                             path_name((*v).node.name)]);\n                     llfn = match enm.node {\n                       ast::item_enum(_, _) => {\n-                        register_fn(ccx, (*v).span, pth, id)\n+                        register_fn(ccx, (*v).span, pth, id, enm.attrs)\n                       }\n                       _ => fail ~\"node_variant, shouldn't happen\"\n                     };\n@@ -2390,8 +2411,11 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                                        a non-tuple-like struct\")\n                 }\n                 Some(ctor_id) => {\n-                    let llfn = register_fn(ccx, struct_item.span,\n-                                           /*bad*/copy *struct_path, ctor_id);\n+                    let llfn = register_fn(ccx,\n+                                           struct_item.span,\n+                                           /*bad*/copy *struct_path,\n+                                           ctor_id,\n+                                           struct_item.attrs);\n                     set_inline_hint(llfn);\n                     llfn\n                 }\n@@ -2416,7 +2440,7 @@ fn register_method(ccx: @crate_ctxt, id: ast::node_id, pth: @ast_map::path,\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n     let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(~\"meth\")),\n                                   path_name(m.ident)]);\n-    let llfn = register_fn_full(ccx, m.span, pth, id, mty);\n+    let llfn = register_fn_full(ccx, m.span, pth, id, m.attrs, mty);\n     set_inline_hint_if_appr(/*bad*/copy m.attrs, llfn);\n     llfn\n }"}, {"sha": "194641f9cda4eb3ee11bab663236310c2a8ba6e9", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -809,8 +809,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n           if abi != ast::foreign_abi_rust_intrinsic {\n               let llwrapfn = get_item_val(ccx, id);\n               let tys = c_stack_tys(ccx, id);\n-              if attr::attrs_contains_name(/*bad*/copy foreign_item.attrs,\n-                                           ~\"rust_stack\") {\n+              if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n                   build_direct_fn(ccx, llwrapfn, *foreign_item, tys, cc);\n               } else {\n                   let llshimfn = build_shim_fn(ccx, *foreign_item, tys, cc);\n@@ -1479,7 +1478,8 @@ fn trans_foreign_fn(ccx: @crate_ctxt, +path: ast_map::path,\n fn register_foreign_fn(ccx: @crate_ctxt,\n                        sp: span,\n                        +path: ast_map::path,\n-                       node_id: ast::node_id)\n+                       node_id: ast::node_id,\n+                       attrs: &[ast::attribute])\n                     -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n@@ -1488,12 +1488,12 @@ fn register_foreign_fn(ccx: @crate_ctxt,\n         let ret_def = !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty);\n         let x86_64 = x86_64_tys(llargtys, llretty, ret_def);\n         do decl_x86_64_fn(x86_64) |fnty| {\n-            register_fn_fuller(ccx, sp, /*bad*/copy path, node_id,\n+            register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n                                t, lib::llvm::CCallConv, fnty)\n         }\n     } else {\n         let llfty = T_fn(llargtys, llretty);\n-        register_fn_fuller(ccx, sp, path, node_id,\n+        register_fn_fuller(ccx, sp, path, node_id, attrs,\n                            t, lib::llvm::CCallConv, llfty)\n     }\n }"}, {"sha": "fffed43e5f1deda0ffc00f9536ae24bf7e7dbe23", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -80,6 +80,13 @@ fn path_to_str(p: path, itr: @ident_interner) -> ~str {\n     path_to_str_with_sep(p, ~\"::\", itr)\n }\n \n+fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n+    match pe {\n+        path_mod(s) => *itr.get(s),\n+        path_name(s) => *itr.get(s)\n+    }\n+}\n+\n enum ast_node {\n     node_item(@item, @path),\n     node_foreign_item(@foreign_item, foreign_abi, @path),"}, {"sha": "f80ef965d1ef33f4f561de45cbd2f84098bd878c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c2a9b7434b361147ebe407abd6701c11b1d597/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a0c2a9b7434b361147ebe407abd6701c11b1d597", "patch": "@@ -180,7 +180,7 @@ fn get_name_value_str_pair(item: @ast::meta_item) -> Option<(~str, ~str)> {\n /* Searching */\n \n /// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: ~[ast::attribute], name: &str) ->\n+fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n     let filter: &fn(a: &ast::attribute) -> Option<ast::attribute> = |a| {\n         if name == get_attr_name(*a) {\n@@ -242,7 +242,7 @@ fn contains_name(metas: ~[@ast::meta_item], name: ~str) -> bool {\n     return vec::len(matches) > 0u;\n }\n \n-fn attrs_contains_name(attrs: ~[ast::attribute], name: ~str) -> bool {\n+fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n     vec::is_not_empty(find_attrs_by_name(attrs, name))\n }\n "}]}