{"sha": "0a8275f8b677304458c6161e26436dfe67ab766b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhODI3NWY4YjY3NzMwNDQ1OGM2MTYxZTI2NDM2ZGZlNjdhYjc2NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-14T06:24:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-14T06:24:42Z"}, "message": "Auto merge of #52244 - glandium:issue52097, r=estebank\n\nDon't display default generic parameters in diagnostics that compare types\n\nIn errors like:\n```\n   expected type: `RawVec<foo, Global>`\n      found type: `foo`\n```\n\n`RawVec` being defined as `RawVec<T, A: Alloc = Global>`, the error is better written as\n```\n   expected type: `RawVec<foo>`\n      found type: `foo`\n```\n\nIn fact, that is already what happens when `foo` is not an ADT, because in that case, the diagnostic handler doesn't try to highlight something, and just uses the `Display` trait instead of its own logic.\n\ne.g.\n```\n   expected type: `RawVec<usize>`\n      found type: `usize`\n```", "tree": {"sha": "a5d160f108f84428c9d9e89fa2768b57393e7e16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5d160f108f84428c9d9e89fa2768b57393e7e16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a8275f8b677304458c6161e26436dfe67ab766b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8275f8b677304458c6161e26436dfe67ab766b", "html_url": "https://github.com/rust-lang/rust/commit/0a8275f8b677304458c6161e26436dfe67ab766b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a8275f8b677304458c6161e26436dfe67ab766b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccade97544d34f42c37fc27fe8c7edba05d3eddb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccade97544d34f42c37fc27fe8c7edba05d3eddb", "html_url": "https://github.com/rust-lang/rust/commit/ccade97544d34f42c37fc27fe8c7edba05d3eddb"}, {"sha": "b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "html_url": "https://github.com/rust-lang/rust/commit/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095"}], "stats": {"total": 588, "additions": 581, "deletions": 7}, "files": [{"sha": "432826238dbca169e4ab23f668ac619aceb01ab1", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0a8275f8b677304458c6161e26436dfe67ab766b", "patch": "@@ -60,13 +60,13 @@ use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePa\n use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n-use std::fmt;\n+use std::{cmp, fmt};\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, Region, Ty, TyCtxt, TypeFoldable, TypeVariants};\n+use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TypeVariants};\n use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n@@ -652,6 +652,43 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// For generic types with parameters with defaults, remove the parameters corresponding to\n+    /// the defaults. This repeats a lot of the logic found in `PrintContext::parameterized`.\n+    fn strip_generic_default_params(\n+        &self,\n+        def_id: DefId,\n+        substs: &ty::subst::Substs<'tcx>\n+    ) -> &'tcx ty::subst::Substs<'tcx> {\n+        let generics = self.tcx.generics_of(def_id);\n+        let mut num_supplied_defaults = 0;\n+        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { has_default, .. } => {\n+                Some((param.def_id, has_default))\n+            }\n+        }).peekable();\n+        let has_default = {\n+            let has_default = type_params.peek().map(|(_, has_default)| has_default);\n+            *has_default.unwrap_or(&false)\n+        };\n+        if has_default {\n+            let types = substs.types().rev();\n+            for ((def_id, has_default), actual) in type_params.zip(types) {\n+                if !has_default {\n+                    break;\n+                }\n+                if self.tcx.type_of(def_id).subst(self.tcx, substs) != actual {\n+                    break;\n+                }\n+                num_supplied_defaults += 1;\n+            }\n+        }\n+        let len = generics.params.len();\n+        let mut generics = generics.clone();\n+        generics.params.truncate(len - num_supplied_defaults);\n+        substs.truncate_to(self.tcx, &generics)\n+    }\n+\n     /// Compare two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n@@ -693,6 +730,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         match (&t1.sty, &t2.sty) {\n             (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+                let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n+                let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 let path1 = self.tcx.item_path_str(def1.did.clone());\n                 let path2 = self.tcx.item_path_str(def2.did.clone());\n@@ -708,8 +747,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     values.0.push_normal(path1);\n                     values.1.push_normal(path2);\n \n+                    // Avoid printing out default generic parameters that are common to both\n+                    // types.\n+                    let len1 = sub_no_defaults_1.len();\n+                    let len2 = sub_no_defaults_2.len();\n+                    let common_len = cmp::min(len1, len2);\n+                    let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n+                    let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n+                    let common_default_params =\n+                        remainder1.iter().rev().zip(remainder2.iter().rev())\n+                                               .filter(|(a, b)| a == b).count();\n+                    let len = sub1.len() - common_default_params;\n+\n                     // Only draw `<...>` if there're lifetime/type arguments.\n-                    let len = sub1.len();\n                     if len > 0 {\n                         values.0.push_normal(\"<\");\n                         values.1.push_normal(\"<\");\n@@ -754,7 +804,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //         ^ elided type as this type argument was the same in both sides\n                     let type_arguments = sub1.types().zip(sub2.types());\n                     let regions_len = sub1.regions().collect::<Vec<_>>().len();\n-                    for (i, (ta1, ta2)) in type_arguments.enumerate() {\n+                    for (i, (ta1, ta2)) in type_arguments.take(len).enumerate() {\n                         let i = i + regions_len;\n                         if ta1 == ta2 {\n                             values.0.push_normal(\"_\");\n@@ -784,7 +834,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         &mut values.0,\n                         &mut values.1,\n                         path1.clone(),\n-                        sub1,\n+                        sub_no_defaults_1,\n                         path2.clone(),\n                         &t2,\n                     ).is_some()\n@@ -796,8 +846,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //     Bar<Qux>\n                     //     Foo<Bar<Qux>>\n                     //         ------- this type argument is exactly the same as the other type\n-                    if self.cmp_type_arg(&mut values.1, &mut values.0, path2, sub2, path1, &t1)\n-                        .is_some()\n+                    if self.cmp_type_arg(\n+                        &mut values.1,\n+                        &mut values.0,\n+                        path2,\n+                        sub_no_defaults_2,\n+                        path1,\n+                        &t1,\n+                    ).is_some()\n                     {\n                         return values;\n                     }"}, {"sha": "2592b07eda781ee78f6fbda415cc6e2d82183694", "filename": "src/test/ui/type-mismatch.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Ftest%2Fui%2Ftype-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Ftest%2Fui%2Ftype-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-mismatch.rs?ref=0a8275f8b677304458c6161e26436dfe67ab766b", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Qux {}\n+struct A;\n+struct B;\n+impl Qux for A {}\n+impl Qux for B {}\n+\n+struct Foo<T, U: Qux = A, V: Qux = B>(T, U, V);\n+\n+struct foo;\n+struct bar;\n+\n+fn want<T>(t: T) {}\n+\n+fn have_usize(f: usize) {\n+    want::<foo>(f); //~ ERROR mismatched types\n+    want::<bar>(f); //~ ERROR mismatched types\n+    want::<Foo<usize>>(f); //~ ERROR mismatched types\n+    want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+}\n+\n+fn have_foo(f: foo) {\n+    want::<usize>(f); //~ ERROR mismatched types\n+    want::<bar>(f); //~ ERROR mismatched types\n+    want::<Foo<usize>>(f); //~ ERROR mismatched types\n+    want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+}\n+\n+fn have_foo_foo(f: Foo<foo>) {\n+    want::<usize>(f); //~ ERROR mismatched types\n+    want::<foo>(f); //~ ERROR mismatched types\n+    want::<bar>(f); //~ ERROR mismatched types\n+    want::<Foo<usize>>(f); //~ ERROR mismatched types\n+    want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+}\n+\n+fn have_foo_foo_b(f: Foo<foo, B>) {\n+    want::<usize>(f); //~ ERROR mismatched types\n+    want::<foo>(f); //~ ERROR mismatched types\n+    want::<bar>(f); //~ ERROR mismatched types\n+    want::<Foo<usize>>(f); //~ ERROR mismatched types\n+    want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+}\n+\n+fn have_foo_foo_b_a(f: Foo<foo, B, A>) {\n+    want::<usize>(f); //~ ERROR mismatched types\n+    want::<foo>(f); //~ ERROR mismatched types\n+    want::<bar>(f); //~ ERROR mismatched types\n+    want::<Foo<usize>>(f); //~ ERROR mismatched types\n+    want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar>>(f); //~ ERROR mismatched types\n+    want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+    want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "4ba1a7f37c4a14e63a0dd0d594f5346b211e1e89", "filename": "src/test/ui/type-mismatch.stderr", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Ftest%2Fui%2Ftype-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a8275f8b677304458c6161e26436dfe67ab766b/src%2Ftest%2Fui%2Ftype-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-mismatch.stderr?ref=0a8275f8b677304458c6161e26436dfe67ab766b", "patch": "@@ -0,0 +1,432 @@\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:25:17\n+   |\n+LL |     want::<foo>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `foo`, found usize\n+   |\n+   = note: expected type `foo`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:26:17\n+   |\n+LL |     want::<bar>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `bar`, found usize\n+   |\n+   = note: expected type `bar`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:27:24\n+   |\n+LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n+   |                        ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<usize>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:28:27\n+   |\n+LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+   |                           ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<usize, B>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:29:22\n+   |\n+LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<foo>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:30:25\n+   |\n+LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<foo, B>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:31:22\n+   |\n+LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<bar>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:32:25\n+   |\n+LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `Foo`, found usize\n+   |\n+   = note: expected type `Foo<bar, B>`\n+              found type `usize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:36:19\n+   |\n+LL |     want::<usize>(f); //~ ERROR mismatched types\n+   |                   ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `usize`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:37:17\n+   |\n+LL |     want::<bar>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `bar`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:38:24\n+   |\n+LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n+   |                        ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:39:27\n+   |\n+LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+   |                           ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, B>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:40:22\n+   |\n+LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<foo>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:41:25\n+   |\n+LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<foo, B>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:42:22\n+   |\n+LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:43:25\n+   |\n+LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `Foo`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, B>`\n+              found type `foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:47:19\n+   |\n+LL |     want::<usize>(f); //~ ERROR mismatched types\n+   |                   ^ expected usize, found struct `Foo`\n+   |\n+   = note: expected type `usize`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:48:17\n+   |\n+LL |     want::<foo>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `foo`, found struct `Foo`\n+   |\n+   = note: expected type `foo`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:49:17\n+   |\n+LL |     want::<bar>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `bar`, found struct `Foo`\n+   |\n+   = note: expected type `bar`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:50:24\n+   |\n+LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n+   |                        ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize>`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:51:27\n+   |\n+LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+   |                           ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, B>`\n+              found type `Foo<foo, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:52:25\n+   |\n+LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected type `Foo<_, B>`\n+              found type `Foo<_, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:53:22\n+   |\n+LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar>`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:54:25\n+   |\n+LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, B>`\n+              found type `Foo<foo, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:55:23\n+   |\n+LL |     want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+   |                       ^\n+   |                       |\n+   |                       expected &Foo<foo>, found struct `Foo`\n+   |                       help: consider borrowing here: `&f`\n+   |\n+   = note: expected type `&Foo<foo>`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:56:26\n+   |\n+LL |     want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                          ^ expected reference, found struct `Foo`\n+   |\n+   = note: expected type `&Foo<foo, B>`\n+              found type `Foo<foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:60:19\n+   |\n+LL |     want::<usize>(f); //~ ERROR mismatched types\n+   |                   ^ expected usize, found struct `Foo`\n+   |\n+   = note: expected type `usize`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:61:17\n+   |\n+LL |     want::<foo>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `foo`, found struct `Foo`\n+   |\n+   = note: expected type `foo`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:62:17\n+   |\n+LL |     want::<bar>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `bar`, found struct `Foo`\n+   |\n+   = note: expected type `bar`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:63:24\n+   |\n+LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n+   |                        ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, A>`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:64:27\n+   |\n+LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+   |                           ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, _>`\n+              found type `Foo<foo, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:65:22\n+   |\n+LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `A`, found struct `B`\n+   |\n+   = note: expected type `Foo<_, A>`\n+              found type `Foo<_, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:66:22\n+   |\n+LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, A>`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:67:25\n+   |\n+LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, _>`\n+              found type `Foo<foo, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:68:23\n+   |\n+LL |     want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+   |                       ^ expected &Foo<foo>, found struct `Foo`\n+   |\n+   = note: expected type `&Foo<foo>`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:69:26\n+   |\n+LL |     want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                          ^\n+   |                          |\n+   |                          expected reference, found struct `Foo`\n+   |                          help: consider borrowing here: `&f`\n+   |\n+   = note: expected type `&Foo<foo, B>`\n+              found type `Foo<foo, B>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:73:19\n+   |\n+LL |     want::<usize>(f); //~ ERROR mismatched types\n+   |                   ^ expected usize, found struct `Foo`\n+   |\n+   = note: expected type `usize`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:74:17\n+   |\n+LL |     want::<foo>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `foo`, found struct `Foo`\n+   |\n+   = note: expected type `foo`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:75:17\n+   |\n+LL |     want::<bar>(f); //~ ERROR mismatched types\n+   |                 ^ expected struct `bar`, found struct `Foo`\n+   |\n+   = note: expected type `bar`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:76:24\n+   |\n+LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n+   |                        ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, A, B>`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:77:27\n+   |\n+LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n+   |                           ^ expected usize, found struct `foo`\n+   |\n+   = note: expected type `Foo<usize, _, B>`\n+              found type `Foo<foo, _, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:78:22\n+   |\n+LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `A`, found struct `B`\n+   |\n+   = note: expected type `Foo<_, A, B>`\n+              found type `Foo<_, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:79:25\n+   |\n+LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected type `Foo<_, _, B>`\n+              found type `Foo<_, _, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:80:22\n+   |\n+LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n+   |                      ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, A, B>`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:81:25\n+   |\n+LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n+   |                         ^ expected struct `bar`, found struct `foo`\n+   |\n+   = note: expected type `Foo<bar, _, B>`\n+              found type `Foo<foo, _, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:82:23\n+   |\n+LL |     want::<&Foo<foo>>(f); //~ ERROR mismatched types\n+   |                       ^ expected &Foo<foo>, found struct `Foo`\n+   |\n+   = note: expected type `&Foo<foo>`\n+              found type `Foo<foo, B, A>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/type-mismatch.rs:83:26\n+   |\n+LL |     want::<&Foo<foo, B>>(f); //~ ERROR mismatched types\n+   |                          ^ expected reference, found struct `Foo`\n+   |\n+   = note: expected type `&Foo<foo, B>`\n+              found type `Foo<foo, B, A>`\n+\n+error: aborting due to 47 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}