{"sha": "43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZGZkMjlkOGRiOGFjYzEzZWZhMWRhM2RkYWE0Y2FkMjM2M2RlYTk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-01T17:20:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T17:20:02Z"}, "message": "Merge #5174\n\n5174: Colorize more test fixtures r=matklad a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>", "tree": {"sha": "37eec94f6d13b491a610f32f1a5cf1a7f7419eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37eec94f6d13b491a610f32f1a5cf1a7f7419eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/MXCCRBK7hj4Ov3rIwAAdHIIAEaIcYUWv3f9cNfyJIcpByhR\nnAv2K7gBl0C7AvT0f2fblSUivaY+FOCuMS1noSD5ZW2b8llPsMHC3m99zdDyxdeL\nJqFUy3/vG//r7uJkhB7++C39bu58SvfFTCzhzy3kbe/1jv04oa4gTKlEs7+vicx8\nvvxIsyviOJZLs9KavJl5FZ69zA2FiG341btTl2tHYfn+/q2vqrUu2BtqZdKQjdEo\nh7+r9ir/stlQ51anASFotQ7pAUpTnDlOmzkupiKn0UdplMT6ZNH40hj/DpwYQVSZ\nX7ivvhIeEfsuLpmdcSPWYvTkyeoODnQT4lJMK5yxL8/qUNqB8suiYdk8BQUsjSM=\n=Oz2E\n-----END PGP SIGNATURE-----\n", "payload": "tree 37eec94f6d13b491a610f32f1a5cf1a7f7419eb0\nparent ad1a0e626b725cbd34dc0f290e5878264ab28b85\nparent dbb940fa7d040c7b46a8fba8d222fc9fac812bea\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593624002 +0000\ncommitter GitHub <noreply@github.com> 1593624002 +0000\n\nMerge #5174\n\n5174: Colorize more test fixtures r=matklad a=lnicola\n\n\n\nCo-authored-by: Lauren\u021biu Nicola <lnicola@dend.ro>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "html_url": "https://github.com/rust-lang/rust/commit/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad1a0e626b725cbd34dc0f290e5878264ab28b85", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad1a0e626b725cbd34dc0f290e5878264ab28b85", "html_url": "https://github.com/rust-lang/rust/commit/ad1a0e626b725cbd34dc0f290e5878264ab28b85"}, {"sha": "dbb940fa7d040c7b46a8fba8d222fc9fac812bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb940fa7d040c7b46a8fba8d222fc9fac812bea", "html_url": "https://github.com/rust-lang/rust/commit/dbb940fa7d040c7b46a8fba8d222fc9fac812bea"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "69ea754b3dc85d307452ab17891683748075a29f", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -137,8 +137,8 @@ mod tests {\n         documentation: &'a str,\n     }\n \n-    fn check_detail_and_documentation(fixture: &str, expected: DetailAndDocumentation) {\n-        let (analysis, position) = analysis_and_position(fixture);\n+    fn check_detail_and_documentation(ra_fixture: &str, expected: DetailAndDocumentation) {\n+        let (analysis, position) = analysis_and_position(ra_fixture);\n         let config = CompletionConfig::default();\n         let completions = analysis.completions(&config, position).unwrap().unwrap();\n         for item in completions {"}, {"sha": "46f8c31c7a51bafc644795051de880e0a0663c30", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -324,10 +324,10 @@ mod tests {\n     ///  * a diagnostic is produced\n     ///  * this diagnostic touches the input cursor position\n     ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n-    fn check_apply_diagnostic_fix_from_position(fixture: &str, after: &str) {\n+    fn check_apply_diagnostic_fix_from_position(ra_fixture: &str, after: &str) {\n         let after = trim_indent(after);\n \n-        let (analysis, file_position) = analysis_and_position(fixture);\n+        let (analysis, file_position) = analysis_and_position(ra_fixture);\n         let diagnostic = analysis.diagnostics(file_position.file_id).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n@@ -365,14 +365,14 @@ mod tests {\n \n     /// Takes a multi-file input fixture with annotated cursor position and checks that no diagnostics\n     /// apply to the file containing the cursor.\n-    fn check_no_diagnostic_for_target_file(fixture: &str) {\n-        let (analysis, file_position) = analysis_and_position(fixture);\n+    fn check_no_diagnostic_for_target_file(ra_fixture: &str) {\n+        let (analysis, file_position) = analysis_and_position(ra_fixture);\n         let diagnostics = analysis.diagnostics(file_position.file_id).unwrap();\n         assert_eq!(diagnostics.len(), 0);\n     }\n \n-    fn check_no_diagnostic(content: &str) {\n-        let (analysis, file_id) = single_file(content);\n+    fn check_no_diagnostic(ra_fixture: &str) {\n+        let (analysis, file_id) = single_file(ra_fixture);\n         let diagnostics = analysis.diagnostics(file_id).unwrap();\n         assert_eq!(diagnostics.len(), 0, \"expected no diagnostic, found one\");\n     }\n@@ -473,7 +473,8 @@ mod tests {\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        let content = r#\"\n+        check_no_diagnostic_for_target_file(\n+            r\"\n             //- /main.rs\n             use core::result::Result::{self, Ok, Err};\n \n@@ -485,13 +486,14 @@ mod tests {\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n-        \"#;\n-        check_no_diagnostic_for_target_file(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn test_wrap_return_type_not_applicable_when_return_type_is_not_result() {\n-        let content = r#\"\n+        check_no_diagnostic_for_target_file(\n+            r\"\n             //- /main.rs\n             use core::result::Result::{self, Ok, Err};\n \n@@ -508,8 +510,8 @@ mod tests {\n             pub mod result {\n                 pub enum Result<T, E> { Ok(T), Err(E) }\n             }\n-        \"#;\n-        check_no_diagnostic_for_target_file(content);\n+        \",\n+        );\n     }\n \n     #[test]\n@@ -618,7 +620,8 @@ mod tests {\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             struct TestStruct {\n                 one: i32,\n                 two: i64,\n@@ -628,14 +631,14 @@ mod tests {\n                 let one = 1;\n                 let s = TestStruct{ one, two: 2 };\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]\n     fn test_fill_struct_fields_no_diagnostic_on_spread() {\n-        let content = r\"\n+        check_no_diagnostic(\n+            r\"\n             struct TestStruct {\n                 one: i32,\n                 two: i64,\n@@ -645,9 +648,8 @@ mod tests {\n                 let one = 1;\n                 let s = TestStruct{ ..a };\n             }\n-        \";\n-\n-        check_no_diagnostic(content);\n+        \",\n+        );\n     }\n \n     #[test]"}, {"sha": "7eb40d637a798b5f3e39cd4aa99e80d3215c4a87", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -55,8 +55,8 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n mod tests {\n     use crate::mock_analysis::analysis_and_position;\n \n-    fn check_goto(fixture: &str, expected: &str) {\n-        let (analysis, pos) = analysis_and_position(fixture);\n+    fn check_goto(ra_fixture: &str, expected: &str) {\n+        let (analysis, pos) = analysis_and_position(ra_fixture);\n \n         let mut navs = analysis.goto_type_definition(pos).unwrap().unwrap().info;\n         assert_eq!(navs.len(), 1);\n@@ -67,7 +67,7 @@ mod tests {\n     #[test]\n     fn goto_type_definition_works_simple() {\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo;\n             fn foo() {\n@@ -82,7 +82,7 @@ mod tests {\n     #[test]\n     fn goto_type_definition_works_simple_ref() {\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo;\n             fn foo() {\n@@ -97,7 +97,7 @@ mod tests {\n     #[test]\n     fn goto_type_definition_works_through_macro() {\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             macro_rules! id {\n                 ($($tt:tt)*) => { $($tt)* }\n@@ -116,7 +116,7 @@ mod tests {\n     #[test]\n     fn goto_type_definition_for_param() {\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo;\n             fn foo(<|>f: Foo) {}\n@@ -128,7 +128,7 @@ mod tests {\n     #[test]\n     fn goto_type_definition_for_tuple_field() {\n         check_goto(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct Foo;\n             struct Bar(Foo);"}, {"sha": "eaba2b61ed1d8efb90f12c62b0e1ce4831678f84", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -417,8 +417,8 @@ mod tests {\n         assert_eq!(offset, position.into());\n     }\n \n-    fn check_hover_result(fixture: &str, expected: &[&str]) -> (String, Vec<HoverAction>) {\n-        let (analysis, position) = analysis_and_position(fixture);\n+    fn check_hover_result(ra_fixture: &str, expected: &[&str]) -> (String, Vec<HoverAction>) {\n+        let (analysis, position) = analysis_and_position(ra_fixture);\n         let hover = analysis.hover(position).unwrap().unwrap();\n         let mut results = Vec::from(hover.info.results());\n         results.sort();\n@@ -435,8 +435,8 @@ mod tests {\n         (content[hover.range].to_string(), hover.info.actions().to_vec())\n     }\n \n-    fn check_hover_no_result(fixture: &str) {\n-        let (analysis, position) = analysis_and_position(fixture);\n+    fn check_hover_no_result(ra_fixture: &str) {\n+        let (analysis, position) = analysis_and_position(ra_fixture);\n         assert!(analysis.hover(position).unwrap().is_none());\n     }\n \n@@ -923,7 +923,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_through_macro() {\n         let (hover_on, _) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             macro_rules! id {\n                 ($($tt:tt)*) => { $($tt)* }\n@@ -944,7 +944,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_through_expr_in_macro() {\n         let (hover_on, _) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             macro_rules! id {\n                 ($($tt:tt)*) => { $($tt)* }\n@@ -962,7 +962,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_through_expr_in_macro_recursive() {\n         let (hover_on, _) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             macro_rules! id_deep {\n                 ($($tt:tt)*) => { $($tt)* }\n@@ -983,7 +983,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_through_func_in_macro_recursive() {\n         let (hover_on, _) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             macro_rules! id_deep {\n                 ($($tt:tt)*) => { $($tt)* }\n@@ -1026,7 +1026,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_through_assert_macro() {\n         let (hover_on, _) = check_hover_result(\n-            r#\"\n+            r\"\n             //- /lib.rs\n             #[rustc_builtin_macro]\n             macro_rules! assert {}\n@@ -1035,7 +1035,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             fn foo() {\n                 assert!(ba<|>r());\n             }\n-            \"#,\n+            \",\n             &[\"fn bar() -> bool\"],\n         );\n \n@@ -1077,14 +1077,14 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_function_show_qualifiers() {\n         check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             async fn foo<|>() {}\n             \",\n             &[\"async fn foo()\"],\n         );\n         check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             pub const unsafe fn foo<|>() {}\n             \",\n@@ -1102,7 +1102,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_trait_show_qualifiers() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             unsafe trait foo<|>() {}\n             \",\n@@ -1114,7 +1114,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_mod_with_same_name_as_function() {\n         check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             use self::m<|>y::Bar;\n \n@@ -1237,7 +1237,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_trait_has_impl_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait foo<|>() {}\n             \",\n@@ -1249,7 +1249,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_struct_has_impl_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             struct foo<|>() {}\n             \",\n@@ -1261,7 +1261,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_union_has_impl_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             union foo<|>() {}\n             \",\n@@ -1273,7 +1273,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_enum_has_impl_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             enum foo<|>() {\n                 A,\n@@ -1288,7 +1288,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_test_has_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             #[test]\n             fn foo_<|>test() {}\n@@ -1332,7 +1332,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_test_mod_has_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             mod tests<|> {\n                 #[test]\n@@ -1373,7 +1373,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_struct_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             struct S{ f1: u32 }\n \n@@ -1416,7 +1416,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_generic_struct_has_goto_type_actions() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             struct Arg(u32);\n             struct S<T>{ f1: T }\n@@ -1479,7 +1479,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_generic_struct_has_flattened_goto_type_actions() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             struct Arg(u32);\n             struct S<T>{ f1: T }\n@@ -1542,7 +1542,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_tuple_has_goto_type_actions() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             struct A(u32);\n             struct B(u32);\n@@ -1627,7 +1627,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_return_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo {}\n \n@@ -1672,7 +1672,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_generic_return_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo<T> {}\n             struct S;\n@@ -1737,7 +1737,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_return_impl_traits_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo {}\n             trait Bar {}\n@@ -1802,7 +1802,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_generic_return_impl_traits_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo<T> {}\n             trait Bar<T> {}\n@@ -1907,7 +1907,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_arg_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait Foo {}\n             fn foo(ar<|>g: &impl Foo) {}\n@@ -1947,7 +1947,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_arg_impl_traits_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait Foo {}\n             trait Bar<T> {}\n@@ -2028,7 +2028,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_arg_generic_impl_trait_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait Foo<T> {}\n             struct S {}\n@@ -2088,7 +2088,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_dyn_return_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo {}\n             struct S;\n@@ -2156,7 +2156,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_dyn_arg_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait Foo {}\n             fn foo(ar<|>g: &dyn Foo) {}\n@@ -2196,7 +2196,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_generic_dyn_arg_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait Foo<T> {}\n             struct S {}\n@@ -2256,7 +2256,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_goto_type_action_links_order() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /lib.rs\n             trait ImplTrait<T> {}\n             trait DynTrait<T> {}\n@@ -2357,7 +2357,7 @@ fn func(foo: i32) { if true { <|>foo; }; }\n     #[test]\n     fn test_hover_associated_type_has_goto_type_action() {\n         let (_, actions) = check_hover_result(\n-            \"\n+            r\"\n             //- /main.rs\n             trait Foo {\n                 type Item;"}, {"sha": "8e6f28abdf50c7f3cbf9489272fcd65e729d56f4", "filename": "crates/ra_proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -11,7 +11,7 @@ fn test_derive_serialize_proc_macro() {\n         \"serde_derive\",\n         \"Serialize\",\n         \"1.0\",\n-        r##\"struct Foo {}\"##,\n+        r\"struct Foo {}\",\n         include_str!(\"fixtures/test_serialize_proc_macro.txt\"),\n     );\n }\n@@ -22,9 +22,7 @@ fn test_derive_serialize_proc_macro_failed() {\n         \"serde_derive\",\n         \"Serialize\",\n         \"1.0\",\n-        r##\"\n-    struct {}\n-\"##,\n+        r\"struct {}\",\n         r##\"\n SUBTREE $\n   IDENT   compile_error 4294967295"}, {"sha": "dcb00671ffb80c0a7c1deada655ed638627773bf", "filename": "crates/ra_proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43dfd29d8db8acc13efa1da3ddaa4cad2363dea9/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=43dfd29d8db8acc13efa1da3ddaa4cad2363dea9", "patch": "@@ -44,12 +44,12 @@ pub fn assert_expand(\n     crate_name: &str,\n     macro_name: &str,\n     version: &str,\n-    fixture: &str,\n+    ra_fixture: &str,\n     expect: &str,\n ) {\n     let path = fixtures::dylib_path(crate_name, version);\n     let expander = dylib::Expander::new(&path).unwrap();\n-    let fixture = parse_string(fixture).unwrap();\n+    let fixture = parse_string(ra_fixture).unwrap();\n \n     let res = expander.expand(macro_name, &fixture.subtree, None).unwrap();\n     assert_eq_text!(&format!(\"{:?}\", res), &expect.trim());"}]}