{"sha": "e511476f240dfbb67b9d94a71ea45db9624e1519", "node_id": "C_kwDOAAsO6NoAKGU1MTE0NzZmMjQwZGZiYjY3YjlkOTRhNzFlYTQ1ZGI5NjI0ZTE1MTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T20:09:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-28T20:09:18Z"}, "message": "Auto merge of #8479 - smoelius:unnecessary-filter-map, r=llogiq\n\nFix some `unnecessary_filter_map` false positives\n\nThis is a proposed fix for #4433.\n\nIt moves `clone_or_copy_needed` out of `unnecessary_iter_cloned.rs` and into `methods::utils`. It then adds a check of this function to `unnecessary_filter_map::check`.\n\nFixes #4433\n\nchangelog: none", "tree": {"sha": "780936189225e9619017c74964dda955ef3f5d86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/780936189225e9619017c74964dda955ef3f5d86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e511476f240dfbb67b9d94a71ea45db9624e1519", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e511476f240dfbb67b9d94a71ea45db9624e1519", "html_url": "https://github.com/rust-lang/rust/commit/e511476f240dfbb67b9d94a71ea45db9624e1519", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e511476f240dfbb67b9d94a71ea45db9624e1519/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d12cd47790d1547a0d9bb8c592a3875666e26ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d12cd47790d1547a0d9bb8c592a3875666e26ca", "html_url": "https://github.com/rust-lang/rust/commit/8d12cd47790d1547a0d9bb8c592a3875666e26ca"}, {"sha": "d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5", "html_url": "https://github.com/rust-lang/rust/commit/d123ffc6c754b25cc68a67ffab0b5c7707eac6e5"}], "stats": {"total": 322, "additions": 228, "deletions": 94}, "files": [{"sha": "108e143f33737d631231061bf56b6ba53c83898d", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=e511476f240dfbb67b9d94a71ea45db9624e1519", "patch": "@@ -1,4 +1,6 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n use rustc_hir as hir;\n@@ -20,6 +22,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         let arg_id = body.params[0].pat.hir_id;\n         let mutates_arg =\n             mutated_variables(&body.value, cx).map_or(true, |used_mutably| used_mutably.contains(&arg_id));\n+        let (clone_or_copy_needed, _) = clone_or_copy_needed(cx, body.params[0].pat, &body.value);\n \n         let (mut found_mapping, mut found_filtering) = check_expression(cx, arg_id, &body.value);\n \n@@ -28,10 +31,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n+        let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n         let sugg = if !found_filtering {\n             \"map\"\n-        } else if !found_mapping && !mutates_arg {\n-            let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n+        } else if !found_mapping && !mutates_arg && (!clone_or_copy_needed || is_copy(cx, in_ty)) {\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n                 ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && in_ty == subst.type_at(0) => {\n                     \"filter\""}, {"sha": "7a39557ad5757971a1bdcfddc31697232184f29e", "filename": "clippy_lints/src/methods/unnecessary_iter_cloned.rs", "status": "modified", "additions": 3, "deletions": 88, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_iter_cloned.rs?ref=e511476f240dfbb67b9d94a71ea45db9624e1519", "patch": "@@ -1,14 +1,12 @@\n+use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait};\n-use clippy_utils::{fn_def_id, get_parent_expr, path_to_local_id, usage};\n+use clippy_utils::{fn_def_id, get_parent_expr};\n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind, HirId, LangItem, Mutability, Pat};\n+use rustc_hir::{def_id::DefId, Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty;\n use rustc_span::{sym, Symbol};\n \n use super::UNNECESSARY_TO_OWNED;\n@@ -100,89 +98,6 @@ pub fn check_for_loop_iter(\n     false\n }\n \n-/// The core logic of `check_for_loop_iter` above, this function wraps a use of\n-/// `CloneOrCopyVisitor`.\n-fn clone_or_copy_needed<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &Pat<'tcx>,\n-    body: &'tcx Expr<'tcx>,\n-) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n-    let mut visitor = CloneOrCopyVisitor {\n-        cx,\n-        binding_hir_ids: pat_bindings(pat),\n-        clone_or_copy_needed: false,\n-        addr_of_exprs: Vec::new(),\n-    };\n-    visitor.visit_expr(body);\n-    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n-}\n-\n-/// Returns a vector of all `HirId`s bound by the pattern.\n-fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n-    let mut collector = usage::ParamBindingIdCollector {\n-        binding_hir_ids: Vec::new(),\n-    };\n-    collector.visit_pat(pat);\n-    collector.binding_hir_ids\n-}\n-\n-/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n-/// operations performed on `binding_hir_ids` are:\n-/// * to take non-mutable references to them\n-/// * to use them as non-mutable `&self` in method calls\n-/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n-/// when `CloneOrCopyVisitor` is done visiting.\n-struct CloneOrCopyVisitor<'cx, 'tcx> {\n-    cx: &'cx LateContext<'tcx>,\n-    binding_hir_ids: Vec<HirId>,\n-    clone_or_copy_needed: bool,\n-    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n-}\n-\n-impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n-    type NestedFilter = nested_filter::OnlyBodies;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        walk_expr(self, expr);\n-        if self.is_binding(expr) {\n-            if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                match parent.kind {\n-                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n-                        self.addr_of_exprs.push(parent);\n-                        return;\n-                    },\n-                    ExprKind::MethodCall(_, args, _) => {\n-                        if_chain! {\n-                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n-                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n-                            let method_ty = self.cx.tcx.type_of(method_def_id);\n-                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n-                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n-                            then {\n-                                return;\n-                            }\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-            self.clone_or_copy_needed = true;\n-        }\n-    }\n-}\n-\n-impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n-    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n-        self.binding_hir_ids\n-            .iter()\n-            .any(|hir_id| path_to_local_id(expr, *hir_id))\n-    }\n-}\n-\n /// Returns true if the named method is `IntoIterator::into_iter`.\n pub fn is_into_iter(cx: &LateContext<'_>, callee_def_id: DefId) -> bool {\n     cx.tcx.lang_items().require(LangItem::IntoIterIntoIter) == Ok(callee_def_id)"}, {"sha": "3015531e8439327c1337e21e89acb6367fb437fa", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e511476f240dfbb67b9d94a71ea45db9624e1519/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=e511476f240dfbb67b9d94a71ea45db9624e1519", "patch": "@@ -1,10 +1,14 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{get_parent_expr, path_to_local_id, usage};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId, Mutability, Pat};\n use rustc_lint::LateContext;\n+use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n \n@@ -79,3 +83,86 @@ pub(super) fn get_hint_if_single_char_arg(\n         }\n     }\n }\n+\n+/// The core logic of `check_for_loop_iter` in `unnecessary_iter_cloned.rs`, this function wraps a\n+/// use of `CloneOrCopyVisitor`.\n+pub(super) fn clone_or_copy_needed<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'tcx>,\n+    body: &'tcx Expr<'tcx>,\n+) -> (bool, Vec<&'tcx Expr<'tcx>>) {\n+    let mut visitor = CloneOrCopyVisitor {\n+        cx,\n+        binding_hir_ids: pat_bindings(pat),\n+        clone_or_copy_needed: false,\n+        addr_of_exprs: Vec::new(),\n+    };\n+    visitor.visit_expr(body);\n+    (visitor.clone_or_copy_needed, visitor.addr_of_exprs)\n+}\n+\n+/// Returns a vector of all `HirId`s bound by the pattern.\n+fn pat_bindings(pat: &Pat<'_>) -> Vec<HirId> {\n+    let mut collector = usage::ParamBindingIdCollector {\n+        binding_hir_ids: Vec::new(),\n+    };\n+    collector.visit_pat(pat);\n+    collector.binding_hir_ids\n+}\n+\n+/// `clone_or_copy_needed` will be false when `CloneOrCopyVisitor` is done visiting if the only\n+/// operations performed on `binding_hir_ids` are:\n+/// * to take non-mutable references to them\n+/// * to use them as non-mutable `&self` in method calls\n+/// If any of `binding_hir_ids` is used in any other way, then `clone_or_copy_needed` will be true\n+/// when `CloneOrCopyVisitor` is done visiting.\n+struct CloneOrCopyVisitor<'cx, 'tcx> {\n+    cx: &'cx LateContext<'tcx>,\n+    binding_hir_ids: Vec<HirId>,\n+    clone_or_copy_needed: bool,\n+    addr_of_exprs: Vec<&'tcx Expr<'tcx>>,\n+}\n+\n+impl<'cx, 'tcx> Visitor<'tcx> for CloneOrCopyVisitor<'cx, 'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        walk_expr(self, expr);\n+        if self.is_binding(expr) {\n+            if let Some(parent) = get_parent_expr(self.cx, expr) {\n+                match parent.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) => {\n+                        self.addr_of_exprs.push(parent);\n+                        return;\n+                    },\n+                    ExprKind::MethodCall(_, args, _) => {\n+                        if_chain! {\n+                            if args.iter().skip(1).all(|arg| !self.is_binding(arg));\n+                            if let Some(method_def_id) = self.cx.typeck_results().type_dependent_def_id(parent.hir_id);\n+                            let method_ty = self.cx.tcx.type_of(method_def_id);\n+                            let self_ty = method_ty.fn_sig(self.cx.tcx).input(0).skip_binder();\n+                            if matches!(self_ty.kind(), ty::Ref(_, _, Mutability::Not));\n+                            then {\n+                                return;\n+                            }\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            self.clone_or_copy_needed = true;\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx> CloneOrCopyVisitor<'cx, 'tcx> {\n+    fn is_binding(&self, expr: &Expr<'tcx>) -> bool {\n+        self.binding_hir_ids\n+            .iter()\n+            .any(|hir_id| path_to_local_id(expr, *hir_id))\n+    }\n+}"}, {"sha": "8e01c2674f1671361fc691d9a34c91311ae9d495", "filename": "tests/ui/unnecessary_filter_map.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/e511476f240dfbb67b9d94a71ea45db9624e1519/tests%2Fui%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e511476f240dfbb67b9d94a71ea45db9624e1519/tests%2Fui%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_filter_map.rs?ref=e511476f240dfbb67b9d94a71ea45db9624e1519", "patch": "@@ -1,3 +1,5 @@\n+#![allow(dead_code)]\n+\n fn main() {\n     let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n     let _ = (0..4).filter_map(|x| {\n@@ -19,3 +21,130 @@ fn main() {\n fn filter_map_none_changes_item_type() -> impl Iterator<Item = bool> {\n     \"\".chars().filter_map(|_| None)\n }\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issue-483920107\n+mod comment_483920107 {\n+    enum Severity {\n+        Warning,\n+        Other,\n+    }\n+\n+    struct ServerError;\n+\n+    impl ServerError {\n+        fn severity(&self) -> Severity {\n+            Severity::Warning\n+        }\n+    }\n+\n+    struct S {\n+        warnings: Vec<ServerError>,\n+    }\n+\n+    impl S {\n+        fn foo(&mut self, server_errors: Vec<ServerError>) {\n+            #[allow(unused_variables)]\n+            let errors: Vec<ServerError> = server_errors\n+                .into_iter()\n+                .filter_map(|se| match se.severity() {\n+                    Severity::Warning => {\n+                        self.warnings.push(se);\n+                        None\n+                    },\n+                    _ => Some(se),\n+                })\n+                .collect();\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-611006622\n+mod comment_611006622 {\n+    struct PendingRequest {\n+        reply_to: u8,\n+        token: u8,\n+        expires: u8,\n+        group_id: u8,\n+    }\n+\n+    enum Value {\n+        Null,\n+    }\n+\n+    struct Node;\n+\n+    impl Node {\n+        fn send_response(&self, _reply_to: u8, _token: u8, _value: Value) -> &Self {\n+            self\n+        }\n+        fn on_error_warn(&self) -> &Self {\n+            self\n+        }\n+    }\n+\n+    struct S {\n+        pending_requests: Vec<PendingRequest>,\n+    }\n+\n+    impl S {\n+        fn foo(&mut self, node: Node, now: u8, group_id: u8) {\n+            // \"drain_filter\"\n+            self.pending_requests = self\n+                .pending_requests\n+                .drain(..)\n+                .filter_map(|pending| {\n+                    if pending.expires <= now {\n+                        return None; // Expired, remove\n+                    }\n+\n+                    if pending.group_id == group_id {\n+                        // Matched - reuse strings and remove\n+                        node.send_response(pending.reply_to, pending.token, Value::Null)\n+                            .on_error_warn();\n+                        None\n+                    } else {\n+                        // Keep waiting\n+                        Some(pending)\n+                    }\n+                })\n+                .collect();\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-621925270\n+// This extrapolation doesn't reproduce the false positive. Additional context seems necessary.\n+mod comment_621925270 {\n+    struct Signature(u8);\n+\n+    fn foo(sig_packets: impl Iterator<Item = Result<Signature, ()>>) -> impl Iterator<Item = u8> {\n+        sig_packets.filter_map(|res| match res {\n+            Ok(Signature(sig_packet)) => Some(sig_packet),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/4433#issuecomment-1052978898\n+mod comment_1052978898 {\n+    #![allow(clippy::redundant_closure)]\n+\n+    pub struct S(u8);\n+\n+    impl S {\n+        pub fn consume(self) {\n+            println!(\"yum\");\n+        }\n+    }\n+\n+    pub fn filter_owned() -> impl Iterator<Item = S> {\n+        (0..10).map(|i| S(i)).filter_map(|s| {\n+            if s.0 & 1 == 0 {\n+                s.consume();\n+                None\n+            } else {\n+                Some(s)\n+            }\n+        })\n+    }\n+}"}, {"sha": "5585b10ab903d1c606c5e6084ed448323f371566", "filename": "tests/ui/unnecessary_filter_map.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e511476f240dfbb67b9d94a71ea45db9624e1519/tests%2Fui%2Funnecessary_filter_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e511476f240dfbb67b9d94a71ea45db9624e1519/tests%2Fui%2Funnecessary_filter_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_filter_map.stderr?ref=e511476f240dfbb67b9d94a71ea45db9624e1519", "patch": "@@ -1,13 +1,13 @@\n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:2:13\n+  --> $DIR/unnecessary_filter_map.rs:4:13\n    |\n LL |     let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::unnecessary-filter-map` implied by `-D warnings`\n \n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:3:13\n+  --> $DIR/unnecessary_filter_map.rs:5:13\n    |\n LL |       let _ = (0..4).filter_map(|x| {\n    |  _____________^\n@@ -19,7 +19,7 @@ LL | |     });\n    | |______^\n \n error: this `.filter_map` can be written more simply using `.filter`\n-  --> $DIR/unnecessary_filter_map.rs:9:13\n+  --> $DIR/unnecessary_filter_map.rs:11:13\n    |\n LL |       let _ = (0..4).filter_map(|x| match x {\n    |  _____________^\n@@ -29,7 +29,7 @@ LL | |     });\n    | |______^\n \n error: this `.filter_map` can be written more simply using `.map`\n-  --> $DIR/unnecessary_filter_map.rs:14:13\n+  --> $DIR/unnecessary_filter_map.rs:16:13\n    |\n LL |     let _ = (0..4).filter_map(|x| Some(x + 1));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}]}