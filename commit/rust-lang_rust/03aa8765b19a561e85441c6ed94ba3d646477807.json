{"sha": "03aa8765b19a561e85441c6ed94ba3d646477807", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYWE4NzY1YjE5YTU2MWU4NTQ0MWM2ZWQ5NGJhM2Q2NDY0Nzc4MDc=", "commit": {"author": {"name": "David Renshaw", "email": "dwrenshaw@gmail.com", "date": "2018-01-02T22:43:03Z"}, "committer": {"name": "David Renshaw", "email": "dwrenshaw@gmail.com", "date": "2018-01-02T22:43:03Z"}, "message": "pass typecheck", "tree": {"sha": "c7e784835cbe4ce0b069a241d18b9cbe85273854", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7e784835cbe4ce0b069a241d18b9cbe85273854"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03aa8765b19a561e85441c6ed94ba3d646477807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03aa8765b19a561e85441c6ed94ba3d646477807", "html_url": "https://github.com/rust-lang/rust/commit/03aa8765b19a561e85441c6ed94ba3d646477807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03aa8765b19a561e85441c6ed94ba3d646477807/comments", "author": {"login": "dwrensha", "id": 495768, "node_id": "MDQ6VXNlcjQ5NTc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwrensha", "html_url": "https://github.com/dwrensha", "followers_url": "https://api.github.com/users/dwrensha/followers", "following_url": "https://api.github.com/users/dwrensha/following{/other_user}", "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions", "organizations_url": "https://api.github.com/users/dwrensha/orgs", "repos_url": "https://api.github.com/users/dwrensha/repos", "events_url": "https://api.github.com/users/dwrensha/events{/privacy}", "received_events_url": "https://api.github.com/users/dwrensha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dwrensha", "id": 495768, "node_id": "MDQ6VXNlcjQ5NTc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/495768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dwrensha", "html_url": "https://github.com/dwrensha", "followers_url": "https://api.github.com/users/dwrensha/followers", "following_url": "https://api.github.com/users/dwrensha/following{/other_user}", "gists_url": "https://api.github.com/users/dwrensha/gists{/gist_id}", "starred_url": "https://api.github.com/users/dwrensha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dwrensha/subscriptions", "organizations_url": "https://api.github.com/users/dwrensha/orgs", "repos_url": "https://api.github.com/users/dwrensha/repos", "events_url": "https://api.github.com/users/dwrensha/events{/privacy}", "received_events_url": "https://api.github.com/users/dwrensha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30496f5dd27b02c5433956c2704cef41a5b119ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/30496f5dd27b02c5433956c2704cef41a5b119ad", "html_url": "https://github.com/rust-lang/rust/commit/30496f5dd27b02c5433956c2704cef41a5b119ad"}], "stats": {"total": 123, "additions": 67, "deletions": 56}, "files": [{"sha": "df101739ed91926e2e373fbe2f3ec12fe4237bcb", "filename": "miri/fn_call.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Ffn_call.rs?ref=03aa8765b19a561e85441c6ed94ba3d646477807", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{Align, LayoutOf};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::mir;\n use syntax::attr;\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if size == 0 {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    let align = self.memory.pointer_size();\n+                    let align = self.tcx.data_layout.pointer_align;\n                     let ptr = self.memory.allocate(size, align, Some(MemoryKind::C.into()))?;\n                     self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n                 }\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                     // +1 for the null terminator\n                     let value_copy = self.memory.allocate(\n                         (value.len() + 1) as u64,\n-                        1,\n+                        Align::from_bytes(1, 1).unwrap(),\n                         Some(MemoryKind::Env.into()),\n                     )?;\n                     self.memory.write_bytes(value_copy.into(), &value)?;\n@@ -369,6 +369,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"sysconf\" => {\n                 let name = self.value_to_primval(args[0])?.to_u64()?;\n+                let name_align = self.layout_of(args[0].ty)?.align;\n+\n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n@@ -387,7 +389,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                             Some(ptr) => ptr,\n                             None => eval_body(self.tcx, instance, ty::ParamEnv::empty(traits::Reveal::All))?.0,\n                         };\n-                        let val = self.value_to_primval(ValTy { value: Value::ByRef(val), ty: args[0].ty })?.to_u64()?;\n+                        let val = self.value_to_primval(ValTy { value: Value::ByRef(val, name_align),\n+                                                                ty: args[0].ty })?.to_u64()?;\n                         if val == name {\n                             result = Some(path_value);\n                             break;\n@@ -406,6 +409,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n                 let key_ptr = self.into_ptr(args[0].value)?;\n+                let key_align = self.layout_of(args[0].ty)?.align;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.into_ptr(args[1].value)?.into_inner_primval() {\n@@ -427,6 +431,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 }\n                 self.memory.write_primval(\n                     key_ptr.to_ptr()?,\n+                    key_align,\n                     PrimVal::Bytes(key),\n                     key_size.bytes(),\n                     false,\n@@ -559,7 +564,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Some(MemoryKind::Rust.into()))?;\n+                let ptr = self.memory.allocate(size,\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               Some(MemoryKind::Rust.into()))?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::heap::::__rust_alloc_zeroed\" => {\n@@ -571,7 +578,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(size, align, Some(MemoryKind::Rust.into()))?;\n+                let ptr = self.memory.allocate(size,\n+                                               Align::from_bytes(align, align).unwrap(),\n+                                               Some(MemoryKind::Rust.into()))?;\n                 self.memory.write_repeat(ptr.into(), 0, size)?;\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n@@ -587,7 +596,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 }\n                 self.memory.deallocate(\n                     ptr,\n-                    Some((old_size, align)),\n+                    Some((old_size, Align::from_bytes(align, align).unwrap())),\n                     MemoryKind::Rust.into(),\n                 )?;\n             }\n@@ -609,9 +618,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 let new_ptr = self.memory.reallocate(\n                     ptr,\n                     old_size,\n-                    old_align,\n+                    Align::from_bytes(old_align, old_align).unwrap(),\n                     new_size,\n-                    new_align,\n+                    Align::from_bytes(new_align, new_align).unwrap(),\n                     MemoryKind::Rust.into(),\n                 )?;\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;"}, {"sha": "3357f0bba392758aced11531f1422ab2f412e7ba", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=03aa8765b19a561e85441c6ed94ba3d646477807", "patch": "@@ -3,7 +3,7 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, Pointer, AccessKind, PtrAndAlign};\n+use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, Pointer};\n use rustc_mir::interpret::{Place, PlaceExtra, HasMemory, EvalContext, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n@@ -87,8 +87,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_load_acq\" |\n             \"volatile_load\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n+                let align = self.layout_of(args[0].ty)?.align;\n+\n                 let valty = ValTy {\n-                    value: Value::by_ref(ptr),\n+                    value: Value::ByRef(ptr, align),\n                     ty: substs.type_at(0),\n                 };\n                 self.write_value(valty, dest)?;\n@@ -99,8 +101,9 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_store_rel\" |\n             \"volatile_store\" => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let dest = self.into_ptr(args[0].value)?;\n-                self.write_value_to_ptr(args[1].value, dest, ty)?;\n+                self.write_value_to_ptr(args[1].value, dest, align, ty)?;\n             }\n \n             \"atomic_fence_acq\" => {\n@@ -109,28 +112,30 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n                 self.write_primval(\n-                    Place::from_primval_ptr(ptr),\n+                    Place::from_primval_ptr(ptr, align),\n                     change,\n                     ty,\n                 )?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let expect_old = self.value_to_primval(args[1])?;\n                 let change = self.value_to_primval(args[2])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n@@ -143,7 +148,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 };\n                 self.write_value(valty, dest)?;\n                 self.write_primval(\n-                    Place::from_primval_ptr(ptr),\n+                    Place::from_primval_ptr(ptr, dest_layout.align),\n                     change,\n                     ty,\n                 )?;\n@@ -175,9 +180,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n                 let ty = substs.type_at(0);\n+                let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n                 let change = self.value_to_primval(args[1])?;\n-                let old = self.read_value(ptr, ty)?;\n+                let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n                     Value::ByVal(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n@@ -196,7 +202,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 };\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Place::from_primval_ptr(ptr), val, ty)?;\n+                self.write_primval(Place::from_primval_ptr(ptr, dest_layout.align), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -210,14 +216,16 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if count * elem_size != 0 {\n                     // TODO: We do not even validate alignment for the 0-bytes case.  libstd relies on this in vec::IntoIter::next.\n                     // Also see the write_bytes intrinsic.\n-                    let elem_align = elem_layout.align.abi();\n+                    let elem_align = elem_layout.align;\n                     let src = self.into_ptr(args[0].value)?;\n+                    let src_align = self.layout_of(args[0].ty)?.align;\n                     let dest = self.into_ptr(args[1].value)?;\n                     self.memory.copy(\n                         src,\n+                        src_align,\n                         dest,\n-                        count * elem_size,\n                         elem_align,\n+                        count * elem_size,\n                         intrinsic_name.ends_with(\"_nonoverlapping\"),\n                     )?;\n                 }\n@@ -241,7 +249,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = self.into_ptr(args[0].value)?;\n-                let place = Place::from_primval_ptr(adt_ptr);\n+                let adt_align = self.layout_of(args[0].ty)?.align;\n+                let place = Place::from_primval_ptr(adt_ptr, adt_align);\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n                 self.write_primval(dest, PrimVal::Bytes(discr_val), dest_layout.ty)?;\n             }\n@@ -312,7 +321,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 let size = dest_layout.size.bytes();\n                 let init = |this: &mut Self, val: Value| {\n                     let zero_val = match val {\n-                        Value::ByRef(PtrAndAlign { ptr, .. }) => {\n+                        Value::ByRef(ptr, _) => {\n                             // These writes have no alignment restriction anyway.\n                             this.memory.write_repeat(ptr, 0, size)?;\n                             val\n@@ -326,7 +335,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                                     let ptr = this.alloc_ptr(dest_layout.ty)?;\n                                     let ptr = Pointer::from(PrimVal::Ptr(ptr));\n                                     this.memory.write_repeat(ptr, 0, size)?;\n-                                    Value::by_ref(ptr)\n+                                    Value::ByRef(ptr, dest_layout.align)\n                                 }\n                             }\n                         }\n@@ -340,12 +349,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, init)?,\n                     Place::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        ptr: ptr,\n+                        align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.write_repeat(ptr, 0, size)?,\n-                    Place::Ptr { .. } => {\n-                        bug!(\"init intrinsic tried to write to fat or unaligned ptr target\")\n-                    }\n+                    _ => bug!(\"TODO\"),\n                 }\n             }\n \n@@ -367,7 +375,8 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"move_val_init\" => {\n                 let ty = substs.type_at(0);\n                 let ptr = self.into_ptr(args[0].value)?;\n-                self.write_value_to_ptr(args[1].value, ptr, ty)?;\n+                let align = self.layout_of(args[0].ty)?.align;\n+                self.write_value_to_ptr(args[1].value, ptr, align, ty)?;\n             }\n \n             \"needs_drop\" => {\n@@ -533,14 +542,10 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n \n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n+                let src_align = self.layout_of(src_ty)?.align;\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.write_maybe_aligned_mut(\n-                    /*aligned*/\n-                    false,\n-                    |ectx| {\n-                        ectx.write_value_to_ptr(args[0].value, ptr.into(), src_ty)\n-                    },\n-                )?;\n+                let dest_align = self.layout_of(substs.type_at(1))?.align;\n+                self.write_value_to_ptr(args[0].value, ptr.into(), dest_align, src_ty);\n             }\n \n             \"unchecked_shl\" => {\n@@ -612,7 +617,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             \"uninit\" => {\n                 let size = dest_layout.size.bytes();\n                 let uninit = |this: &mut Self, val: Value| match val {\n-                    Value::ByRef(PtrAndAlign { ptr, .. }) => {\n+                    Value::ByRef(ptr, _) => {\n                         this.memory.mark_definedness(ptr, size, false)?;\n                         Ok(val)\n                     }\n@@ -621,12 +626,11 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n                     Place::Ptr {\n-                        ptr: PtrAndAlign { ptr, aligned: true },\n+                        ptr: ptr,\n+                        align: _align,\n                         extra: PlaceExtra::None,\n                     } => self.memory.mark_definedness(ptr, size, false)?,\n-                    Place::Ptr { .. } => {\n-                        bug!(\"uninit intrinsic tried to write to fat or unaligned ptr target\")\n-                    }\n+                    _ => bug!(\"todo\"),\n                 }\n             }\n \n@@ -639,7 +643,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_layout.align.abi(), Some(AccessKind::Write))?;\n+                    self.memory.check_align(ptr, ty_layout.align)?;\n                     self.memory.write_repeat(ptr, val_byte, ty_layout.size.bytes() * count)?;\n                 }\n             }"}, {"sha": "d458a3c47e8c363e1a70237430a6d8718bcff43a", "filename": "miri/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Flib.rs?ref=03aa8765b19a561e85441c6ed94ba3d646477807", "patch": "@@ -20,7 +20,6 @@ extern crate lazy_static;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::{TyLayout, LayoutOf};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n use rustc::mir;\n use rustc::traits;\n \n@@ -87,7 +86,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n             // Return value\n             let size = ecx.tcx.data_layout.pointer_size.bytes();\n-            let align = ecx.tcx.data_layout.pointer_align.abi();\n+            let align = ecx.tcx.data_layout.pointer_align;\n             let ret_ptr = ecx.memory_mut().allocate(size, align, Some(MemoryKind::Stack))?;\n             cleanup_ptr = Some(ret_ptr);\n \n@@ -96,7 +95,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 start_instance,\n                 start_mir.span,\n                 start_mir,\n-                Place::from_ptr(ret_ptr),\n+                Place::from_ptr(ret_ptr, align),\n                 StackPopCleanup::None,\n             )?;\n \n@@ -126,8 +125,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let ty = ecx.tcx.mk_imm_ptr(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8));\n             let foo = ecx.memory.allocate_cached(b\"foo\\0\");\n             let ptr_size = ecx.memory.pointer_size();\n-            let foo_ptr = ecx.memory.allocate(ptr_size * 1, ptr_size, None)?;\n-            ecx.memory.write_primval(foo_ptr.into(), PrimVal::Ptr(foo.into()), ptr_size, false)?;\n+            let ptr_align = ecx.tcx.data_layout.pointer_align;\n+            let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n+            ecx.memory.write_primval(foo_ptr, ptr_align, PrimVal::Ptr(foo.into()), ptr_size, false)?;\n             ecx.memory.mark_static_initalized(foo_ptr.alloc_id, Mutability::Immutable)?;\n             ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n \n@@ -158,7 +158,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n         Ok(())\n     }\n \n-    let mut ecx = EvalContext::new(tcx, ty::ParamEnv::empty(traits::Reveal::All), limits, Default::default(), Default::default(), Substs::empty());\n+    let mut ecx = EvalContext::new(tcx, ty::ParamEnv::empty(traits::Reveal::All), limits, Default::default(), Default::default());\n     match run_main(&mut ecx, main_id, start_wrapper) {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n@@ -310,22 +310,20 @@ impl<'tcx> Machine<'tcx> for Evaluator<'tcx> {\n         // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n         trace!(\"Initializing an extern global with NULL\");\n         let ptr_size = ecx.memory.pointer_size();\n+        let ptr_align = ecx.tcx.data_layout.pointer_align;\n         let ptr = ecx.memory.allocate(\n             ptr_size,\n-            ptr_size,\n+            ptr_align,\n             None,\n         )?;\n-        ecx.memory.write_ptr_sized_unsigned(ptr, PrimVal::Bytes(0))?;\n+        ecx.memory.write_ptr_sized_unsigned(ptr, ptr_align, PrimVal::Bytes(0))?;\n         ecx.memory.mark_static_initalized(ptr.alloc_id, mutability)?;\n         ecx.tcx.interpret_interner.borrow_mut().cache(\n             GlobalId {\n                 instance,\n                 promoted: None,\n             },\n-            PtrAndAlign {\n-                ptr: ptr.into(),\n-                aligned: true,\n-            },\n+            ptr.into(),\n         );\n         Ok(())\n     }"}, {"sha": "919997a5217cba746edae2ad1104eae6b1387b02", "filename": "miri/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Foperator.rs?ref=03aa8765b19a561e85441c6ed94ba3d646477807", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n                 map_to_primval(left.overflowing_offset(right as u64, self)),\n \n             BitAnd if !signed => {\n-                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align - 1);\n+                let base_mask : u64 = !(self.memory.get(left.alloc_id)?.align.abi() - 1);\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there"}, {"sha": "843dcd4041d775f6f8f641faa5c3c2d01662e4e0", "filename": "miri/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03aa8765b19a561e85441c6ed94ba3d646477807/miri%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fvalidation.rs?ref=03aa8765b19a561e85441c6ed94ba3d646477807", "patch": "@@ -509,7 +509,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = self.into_ptr(val)?;\n-        self.memory.check_align(ptr, align.abi(), None)?;\n+        self.memory.check_align(ptr, align)?;\n \n         // Recurse\n         let pointee_place = self.val_to_place(val, pointee_ty)?;\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator<'\n             // Tracking the same state for locals not backed by memory would just duplicate too\n             // much machinery.\n             // FIXME: We ignore alignment.\n-            let (ptr, extra) = self.force_allocation(query.place.1)?.to_ptr_extra_aligned();\n+            let (ptr, _, extra) = self.force_allocation(query.place.1)?.to_ptr_align_extra();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Places?\n             let layout = self.layout_of(query.ty)?;"}]}