{"sha": "696f16ec2e54e8563702b1cdbbaaa1877562aa60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NmYxNmVjMmU1NGU4NTYzNzAyYjFjZGJiYWFhMTg3NzU2MmFhNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T03:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T03:51:31Z"}, "message": "auto merge of #13398 : nick29581/rust/unsized-enum, r=nikomatsakis\n\nNow with proper checking of enums and allows unsized fields as the last field in a struct or variant. This PR only checks passing of unsized types and distinguishing them from sized ones. To be safe we also need to control storage.\r\n\r\nCloses issues #12969 and #13121, supersedes #13375 (all the discussion there is valid here too).", "tree": {"sha": "10336f159476418bd7a39af74a87359319ad5522", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10336f159476418bd7a39af74a87359319ad5522"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/696f16ec2e54e8563702b1cdbbaaa1877562aa60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/696f16ec2e54e8563702b1cdbbaaa1877562aa60", "html_url": "https://github.com/rust-lang/rust/commit/696f16ec2e54e8563702b1cdbbaaa1877562aa60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/696f16ec2e54e8563702b1cdbbaaa1877562aa60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcc3e8c0d44bbbbf752db45a9c85f7ac4b4d61ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc3e8c0d44bbbbf752db45a9c85f7ac4b4d61ce", "html_url": "https://github.com/rust-lang/rust/commit/bcc3e8c0d44bbbbf752db45a9c85f7ac4b4d61ce"}, {"sha": "5729d9b41392ad153224acc2160f62205c9c1374", "url": "https://api.github.com/repos/rust-lang/rust/commits/5729d9b41392ad153224acc2160f62205c9c1374", "html_url": "https://github.com/rust-lang/rust/commit/5729d9b41392ad153224acc2160f62205c9c1374"}], "stats": {"total": 727, "additions": 643, "deletions": 84}, "files": [{"sha": "b8f20b5e43968fad8fe43cac13dd5df7b89b9afa", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -103,12 +103,12 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n                 .map(|x| *x).collect();\n             ast::ItemImpl((*a).clone(), (*b).clone(), c, methods)\n         }\n-        ast::ItemTrait(ref a, ref b, ref methods) => {\n+        ast::ItemTrait(ref a, b, ref c, ref methods) => {\n             let methods = methods.iter()\n                                  .filter(|m| trait_method_in_cfg(cx, *m) )\n                                  .map(|x| (*x).clone())\n                                  .collect();\n-            ast::ItemTrait((*a).clone(), (*b).clone(), methods)\n+            ast::ItemTrait((*a).clone(), b, (*c).clone(), methods)\n         }\n         ast::ItemStruct(def, ref generics) => {\n             ast::ItemStruct(fold_struct(cx, def), generics.clone())"}, {"sha": "0ea6598a99f00afe7456963a18c0900a19a935bb", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -170,6 +170,7 @@ pub static tag_lang_items_item_node_id: uint = 0x73;\n \n pub static tag_item_unnamed_field: uint = 0x74;\n pub static tag_items_data_item_visibility: uint = 0x76;\n+pub static tag_items_data_item_sized: uint = 0x77;\n \n pub static tag_item_method_tps: uint = 0x79;\n pub static tag_item_method_fty: uint = 0x7a;"}, {"sha": "b76b6d0c380659fa4ba37084741bd7d6c2144f63", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -164,6 +164,19 @@ fn item_visibility(item: ebml::Doc) -> ast::Visibility {\n     }\n }\n \n+fn item_sized(item: ebml::Doc) -> ast::Sized {\n+    match reader::maybe_get_doc(item, tag_items_data_item_sized) {\n+        None => ast::StaticSize,\n+        Some(sized_doc) => {\n+            match reader::doc_as_u8(sized_doc) as char {\n+                'd' => ast::DynSize,\n+                's' => ast::StaticSize,\n+                _ => fail!(\"unknown sized-ness character\")\n+            }\n+        }\n+    }\n+}\n+\n fn item_method_sort(item: ebml::Doc) -> char {\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_method_sort, |doc| {\n@@ -371,6 +384,7 @@ pub fn get_trait_def(cdata: Cmd,\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n     let rp_defs = item_region_param_defs(item_doc, cdata);\n+    let sized = item_sized(item_doc);\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n@@ -382,6 +396,13 @@ pub fn get_trait_def(cdata: Cmd,\n         });\n         true\n     });\n+    // Turn sized into a bound, FIXME(#8559).\n+    if sized == ast::StaticSize {\n+        tcx.lang_items.to_builtin_kind(tcx.lang_items.sized_trait().unwrap()).map(|bound| {\n+            bounds.add(bound);\n+        });\n+    }\n+\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param_defs: rp_defs},"}, {"sha": "d5ee1b15ae252ac4a988dd82ffc0d8f233aa8736", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -832,6 +832,16 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n     }\n }\n \n+fn encode_sized(ebml_w: &mut Encoder, sized: Sized) {\n+    ebml_w.start_tag(tag_items_data_item_sized);\n+    let ch = match sized {\n+        DynSize => 'd',\n+        StaticSize => 's',\n+    };\n+    ebml_w.wr_str(str::from_char(ch));\n+    ebml_w.end_tag();\n+}\n+\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut Encoder,\n                         item: &Item,\n@@ -1070,7 +1080,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                    ast_method)\n         }\n       }\n-      ItemTrait(_, ref super_traits, ref ms) => {\n+      ItemTrait(_, sized, ref super_traits, ref ms) => {\n         add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -1084,6 +1094,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n         encode_attributes(ebml_w, item.attrs.as_slice());\n+        // When we fix the rest of the supertrait nastiness (FIXME(#8559)), we\n+        // should no longer need this ugly little hack either.\n+        encode_sized(ebml_w, sized);\n         encode_visibility(ebml_w, vis);\n         for &method_def_id in ty::trait_method_def_ids(tcx, def_id).iter() {\n             ebml_w.start_tag(tag_item_trait_method);"}, {"sha": "eeccd1ca334497c6498dc09b7ba66aa6c70120f8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -79,7 +79,7 @@ impl Visitor<()> for ParentVisitor {\n             // method to the root. In this case, if the trait is private, then\n             // parent all the methods to the trait to indicate that they're\n             // private.\n-            ast::ItemTrait(_, _, ref methods) if item.vis != ast::Public => {\n+            ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Provided(ref m) => self.parents.insert(m.id, item.id),\n@@ -274,7 +274,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n \n             // Default methods on traits are all public so long as the trait\n             // is public\n-            ast::ItemTrait(_, _, ref methods) if public_first => {\n+            ast::ItemTrait(_, _, _, ref methods) if public_first => {\n                 for method in methods.iter() {\n                     match *method {\n                         ast::Provided(ref m) => {\n@@ -1082,7 +1082,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemTrait(_, _, ref methods) => {\n+            ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Provided(ref m) => {\n@@ -1142,7 +1142,7 @@ impl<'a> SanePrivacyVisitor<'a> {\n \n             ast::ItemStruct(ref def, _) => check_struct(def),\n \n-            ast::ItemTrait(_, _, ref methods) => {\n+            ast::ItemTrait(_, _, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n                         ast::Required(..) => {}"}, {"sha": "ab345ecb243541d713fa9ff15794d9ddcf7fcce8", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -1326,7 +1326,7 @@ impl<'a> Resolver<'a> {\n \n             ItemImpl(_, Some(_), _, _) => parent,\n \n-            ItemTrait(_, _, ref methods) => {\n+            ItemTrait(_, _, _, ref methods) => {\n                 let name_bindings =\n                     self.add_child(ident, parent.clone(), ForbidDuplicateTypes, sp);\n \n@@ -3579,7 +3579,7 @@ impl<'a> Resolver<'a> {\n                                             methods.as_slice());\n             }\n \n-            ItemTrait(ref generics, ref traits, ref methods) => {\n+            ItemTrait(ref generics, _, ref traits, ref methods) => {\n                 // Create a new rib for the self type.\n                 let self_type_rib = Rib::new(NormalRibKind);\n                 // plain insert (no renaming)\n@@ -3787,9 +3787,8 @@ impl<'a> Resolver<'a> {\n                 }\n                 Some(declaration) => {\n                     for argument in declaration.inputs.iter() {\n-                        let binding_mode = ArgumentIrrefutableMode;\n                         this.resolve_pattern(argument.pat,\n-                                             binding_mode,\n+                                             ArgumentIrrefutableMode,\n                                              None);\n \n                         this.resolve_type(argument.ty);"}, {"sha": "88989f7ce08245b4dbceb3884e1c40d7dd4a9016", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n             ast::ItemImpl(ref generics, _, _, _) |\n-            ast::ItemTrait(ref generics, _, _) => {\n+            ast::ItemTrait(ref generics, _, _, _) => {\n                 self.check_lifetime_names(&generics.lifetimes);\n                 EarlyScope(0, &generics.lifetimes, &root)\n             }"}, {"sha": "30d75eda3efdcebb95736f179fab239efb5d4c07", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -2595,18 +2595,7 @@ pub fn type_is_machine(ty: t) -> bool {\n // Is the type's representation size known at compile time?\n #[allow(dead_code)] // leaving in for DST\n pub fn type_is_sized(cx: &ctxt, ty: ty::t) -> bool {\n-    match get(ty).sty {\n-        // FIXME(#6308) add trait, vec, str, etc here.\n-        ty_param(p) => {\n-            let ty_param_defs = cx.ty_param_defs.borrow();\n-            let param_def = ty_param_defs.get(&p.def_id.node);\n-            if param_def.bounds.builtin_bounds.contains_elem(BoundSized) {\n-                return true;\n-            }\n-            return false;\n-        },\n-        _ => return true,\n-    }\n+    type_contents(cx, ty).is_sized(cx)\n }\n \n // Whether a type is enum like, that is an enum type with only nullary\n@@ -3500,7 +3489,7 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n         match cx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ItemTrait(_, _, ref ms) => {\n+                    ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n                         p.iter().map(|m| method(cx, ast_util::local_def(m.id))).collect()\n                     }"}, {"sha": "5e05be1ac915245a0dca96577f7d12452977873b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 110, "deletions": 20, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -317,9 +317,23 @@ impl<'a> Visitor<()> for CheckItemTypesVisitor<'a> {\n     }\n }\n \n+struct CheckItemSizedTypesVisitor<'a> { ccx: &'a CrateCtxt<'a> }\n+\n+impl<'a> Visitor<()> for CheckItemSizedTypesVisitor<'a> {\n+    fn visit_item(&mut self, i: &ast::Item, _: ()) {\n+        check_item_sized(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n pub fn check_item_types(ccx: &CrateCtxt, krate: &ast::Crate) {\n     let mut visit = CheckItemTypesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate, ());\n+\n+    ccx.tcx.sess.abort_if_errors();\n+\n+    let mut visit = CheckItemSizedTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate, ());\n }\n \n fn check_bare_fn(ccx: &CrateCtxt,\n@@ -369,21 +383,21 @@ impl<'a> GatherLocalsVisitor<'a> {\n }\n \n impl<'a> Visitor<()> for GatherLocalsVisitor<'a> {\n-        // Add explicitly-declared locals.\n+    // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &ast::Local, _: ()) {\n-            let o_ty = match local.ty.node {\n-              ast::TyInfer => None,\n-              _ => Some(self.fcx.to_ty(local.ty))\n-            };\n-            self.assign(local.id, o_ty);\n-            debug!(\"Local variable {} is assigned type {}\",\n-                   self.fcx.pat_to_str(local.pat),\n-                   self.fcx.infcx().ty_to_str(\n-                       self.fcx.inh.locals.borrow().get_copy(&local.id)));\n-            visit::walk_local(self, local, ());\n-\n+        let o_ty = match local.ty.node {\n+            ast::TyInfer => None,\n+            _ => Some(self.fcx.to_ty(local.ty))\n+        };\n+        self.assign(local.id, o_ty);\n+        debug!(\"Local variable {} is assigned type {}\",\n+               self.fcx.pat_to_str(local.pat),\n+               self.fcx.infcx().ty_to_str(\n+                   self.fcx.inh.locals.borrow().get_copy(&local.id)));\n+        visit::walk_local(self, local, ());\n     }\n-        // Add pattern bindings.\n+\n+    // Add pattern bindings.\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n             match p.node {\n               ast::PatIdent(_, ref path, _)\n@@ -561,13 +575,35 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n     }\n }\n \n+fn check_fields_sized(tcx: &ty::ctxt,\n+                      struct_def: &ast::StructDef) {\n+    let len = struct_def.fields.len();\n+    if len == 0 {\n+        return;\n+    }\n+    for f in struct_def.fields.slice_to(len - 1).iter() {\n+        let t = ty::node_id_to_type(tcx, f.node.id);\n+        if !ty::type_is_sized(tcx, t) {\n+            match f.node.kind {\n+                ast::NamedField(ident, _) => {\n+                    tcx.sess.span_err(f.span, format!(\"type `{}` is dynamically sized. \\\n+                                                       dynamically sized types may only \\\n+                                                       appear as the type of the final \\\n+                                                       field in a struct\",\n+                                                      token::get_ident(ident)));\n+                }\n+                ast::UnnamedField(_) => {\n+                    tcx.sess.span_err(f.span, \"dynamically sized type in field\");\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n-    // Check that the struct is representable\n     check_representable(tcx, span, id, \"struct\");\n-\n-    // Check that the struct is instantiable\n     check_instantiable(tcx, span, id);\n \n     // Check there are no overlapping fields in super-structs\n@@ -578,6 +614,24 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n+pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n+    debug!(\"check_item(it.id={}, it.ident={})\",\n+           it.id,\n+           ty::item_path_str(ccx.tcx, local_def(it.id)));\n+    let _indenter = indenter();\n+\n+    match it.node {\n+        ast::ItemEnum(ref enum_definition, _) => {\n+            check_enum_variants_sized(ccx,\n+                                      enum_definition.variants.as_slice());\n+        }\n+        ast::ItemStruct(..) => {\n+            check_fields_sized(ccx.tcx, ccx.tcx.map.expect_struct(it.id));\n+        }\n+        _ => {}\n+    }\n+}\n+\n pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -630,7 +684,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         }\n \n       }\n-      ast::ItemTrait(_, _, ref trait_methods) => {\n+      ast::ItemTrait(_, _, _, ref trait_methods) => {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n@@ -3436,7 +3490,7 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n-                           designation: &str) {\n+                           designation: &str) -> bool {\n     let rty = ty::node_id_to_type(tcx, item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -3450,9 +3504,11 @@ pub fn check_representable(tcx: &ty::ctxt,\n           sp, format!(\"illegal recursive {} type; \\\n                        wrap the inner value in a box to make it representable\",\n                       designation));\n+        return false\n       }\n       ty::Representable | ty::ContainsRecursive => (),\n     }\n+    return true\n }\n \n /// Checks whether a type can be created without an instance of itself.\n@@ -3468,13 +3524,17 @@ pub fn check_representable(tcx: &ty::ctxt,\n /// is representable, but not instantiable.\n pub fn check_instantiable(tcx: &ty::ctxt,\n                           sp: Span,\n-                          item_id: ast::NodeId) {\n+                          item_id: ast::NodeId)\n+                          -> bool {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n         tcx.sess.span_err(sp, format!(\"this type cannot be instantiated \\\n                   without an instance of itself; \\\n                   consider using `Option<{}>`\",\n                                    ppaux::ty_to_str(tcx, item_ty)));\n+        false\n+    } else {\n+        true\n     }\n }\n \n@@ -3507,6 +3567,37 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n+pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n+                                 vs: &[ast::P<ast::Variant>]) {\n+    for &v in vs.iter() {\n+        match v.node.kind {\n+            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n+                let arg_tys: Vec<ty::t> = ty::ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n+                let len = arg_tys.len();\n+                if len == 0 {\n+                    return;\n+                }\n+                for (i, t) in arg_tys.slice_to(len - 1).iter().enumerate() {\n+                    // Allow the last field in an enum to be unsized.\n+                    // We want to do this so that we can support smart pointers.\n+                    // A struct value with an unsized final field is itself\n+                    // unsized and we must track this in the type system.\n+                    if !ty::type_is_sized(ccx.tcx, *t) {\n+                        ccx.tcx.sess.span_err(args.get(i).ty.span,\n+                                              format!(\"type `{}` is dynamically sized. \\\n+                                                       dynamically sized types may only \\\n+                                                       appear as the final type in a variant\",\n+                                                      ppaux::ty_to_str(ccx.tcx, *t)));\n+                    }\n+                }\n+            },\n+            ast::StructVariantKind(struct_def) => check_fields_sized(ccx.tcx, struct_def),\n+            _ => {}\n+        }\n+    }\n+}\n+\n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[ast::P<ast::Variant>],\n@@ -3627,7 +3718,6 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     // cache so that ty::enum_variants won't repeat this work\n     ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n \n-    // Check that it is possible to represent this enum.\n     check_representable(ccx.tcx, sp, id, \"enum\");\n \n     // Check that it is possible to instantiate this enum:"}, {"sha": "9c49512d4dc0d76dc3a8c4d9d107e242b9010dbf", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -32,6 +32,7 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n+use middle::lang_items::SizedTraitLangItem;\n use middle::resolve_lifetime;\n use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n use middle::ty::{ty_param_bounds_and_ty};\n@@ -189,7 +190,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n     match tcx.map.get(trait_id) {\n         ast_map::NodeItem(item) => {\n             match item.node {\n-                ast::ItemTrait(ref generics, _, ref ms) => {\n+                ast::ItemTrait(ref generics, _, _, ref ms) => {\n                     let trait_ty_generics = ty_generics_for_type(ccx, generics);\n \n                     // For each method, construct a suitable ty::Method and\n@@ -402,7 +403,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::NodeId,\n                           sp: codemap::Span,\n-                          ast_trait_refs: &[ast::TraitRef])\n+                          ast_trait_refs: &[ast::TraitRef],\n+                          sized: ast::Sized)\n                           -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n@@ -433,6 +435,12 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n             }\n         }\n     }\n+    if sized == ast::StaticSize {\n+        match tcx.lang_items.require(SizedTraitLangItem) {\n+            Ok(def_id) => { ty::try_add_builtin_trait(tcx, def_id, &mut bounds); },\n+            Err(s) => tcx.sess.err(s),\n+        };\n+    }\n \n     tcx.supertraits.borrow_mut().insert(local_def(id), Rc::new(ty_trait_refs));\n     bounds\n@@ -562,8 +570,7 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n         if ty_param.bounds.len() > 0 {\n             ccx.tcx.sess.span_err(\n                 span,\n-                format!(\"trait bounds are not allowed in {} definitions\",\n-                     thing));\n+                format!(\"trait bounds are not allowed in {} definitions\", thing));\n         }\n     }\n }\n@@ -634,7 +641,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n         },\n-        ast::ItemTrait(ref generics, _, ref trait_methods) => {\n+        ast::ItemTrait(ref generics, _, _, ref trait_methods) => {\n             let trait_def = trait_def_of_item(ccx, it);\n \n             // Run convert_methods on the provided methods.\n@@ -863,14 +870,15 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     }\n \n     match it.node {\n-        ast::ItemTrait(ref generics, ref supertraits, _) => {\n+        ast::ItemTrait(ref generics, sized, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n             let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n             let bounds = ensure_supertraits(ccx,\n                                             it.id,\n                                             it.span,\n-                                            supertraits.as_slice());\n+                                            supertraits.as_slice(),\n+                                            sized);\n             let trait_def = Rc::new(ty::TraitDef {\n                 generics: ty_generics,\n                 bounds: bounds,\n@@ -1032,7 +1040,12 @@ fn ty_generics(ccx: &CrateCtxt,\n             existing_def_opt.unwrap_or_else(|| {\n                 let param_ty = ty::param_ty {idx: base_index + offset,\n                                              def_id: local_def(param.id)};\n-                let bounds = Rc::new(compute_bounds(ccx, param_ty, &param.bounds));\n+                let bounds = Rc::new(compute_bounds(ccx,\n+                                                    param_ty,\n+                                                    &param.bounds,\n+                                                    param.sized,\n+                                                    param.ident,\n+                                                    param.span));\n                 let default = param.default.map(|path| {\n                     let ty = ast_ty_to_ty(ccx, &ExplicitRscope, path);\n                     let cur_idx = param_ty.idx;\n@@ -1067,7 +1080,10 @@ fn ty_generics(ccx: &CrateCtxt,\n     fn compute_bounds(\n         ccx: &CrateCtxt,\n         param_ty: ty::param_ty,\n-        ast_bounds: &OwnedSlice<ast::TyParamBound>) -> ty::ParamBounds\n+        ast_bounds: &OwnedSlice<ast::TyParamBound>,\n+        sized: ast::Sized,\n+        ident: ast::Ident,\n+        span: Span) -> ty::ParamBounds\n     {\n         /*!\n          * Translate the AST's notion of ty param bounds (which are an\n@@ -1086,9 +1102,8 @@ fn ty_generics(ccx: &CrateCtxt,\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n                     let trait_ref = instantiate_trait_ref(ccx, b, ty);\n                     if !ty::try_add_builtin_trait(\n-                        ccx.tcx, trait_ref.def_id,\n-                        &mut param_bounds.builtin_bounds)\n-                    {\n+                            ccx.tcx, trait_ref.def_id,\n+                            &mut param_bounds.builtin_bounds) {\n                         // Must be a user-defined trait\n                         param_bounds.trait_bounds.push(trait_ref);\n                     }\n@@ -1100,8 +1115,43 @@ fn ty_generics(ccx: &CrateCtxt,\n             }\n         }\n \n+        if sized == ast::StaticSize {\n+            match ccx.tcx.lang_items.require(SizedTraitLangItem) {\n+                Ok(def_id) => { ty::try_add_builtin_trait(ccx.tcx,\n+                                                          def_id,\n+                                                          &mut param_bounds.builtin_bounds); },\n+                // Fixme(13367) after `type` makes it into the snapshot, we can check this properly\n+                Err(_s) => {}, //ccx.tcx.sess.err(s),\n+            }\n+        }\n+\n+        check_bounds_compatible(ccx.tcx, &param_bounds, ident, span);\n+\n         param_bounds\n     }\n+\n+    fn check_bounds_compatible(tcx: &ty::ctxt,\n+                               param_bounds: &ty::ParamBounds,\n+                               ident: ast::Ident,\n+                               span: Span) {\n+        // Currently the only bound which is incompatible with other bounds is\n+        // Sized/Unsized.\n+        if !param_bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+            ty::each_bound_trait_and_supertraits(tcx,\n+                                                 param_bounds.trait_bounds.as_slice(),\n+                                                 |trait_ref| {\n+                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+                if trait_def.bounds.contains_elem(ty::BoundSized) {\n+                    tcx.sess.span_err(span,\n+                        format!(\"incompatible bounds on type parameter {}, \\\n+                                 bound {} does not allow unsized type\",\n+                        token::get_ident(ident),\n+                        ppaux::trait_ref_to_str(tcx, &*trait_ref)));\n+                }\n+                true\n+            });\n+        }\n+    }\n }\n \n pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,"}, {"sha": "bb9c6a87babda986c32e8fe24e58ffa165d9e88a", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -878,6 +878,8 @@ impl<'a> Rebuilder<'a> {\n                 id: ty_param.id,\n                 bounds: bounds,\n                 default: ty_param.default,\n+                span: ty_param.span,\n+                sized: ty_param.sized,\n             }\n         })\n     }"}, {"sha": "5485cddb4763a4992ac703073f0c1fba2194986c", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -347,7 +347,7 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n         match item.node {\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(ref generics, _, _) => {\n+            ast::ItemTrait(ref generics, _, _, _) => {\n                 for (i, p) in generics.lifetimes.iter().enumerate() {\n                     self.add_inferred(item.id, RegionParam, i, p.id);\n                 }"}, {"sha": "3fc65dd9647cdcb1cd1b5b2109957ac6378b2b35", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -261,7 +261,7 @@ impl<'a> RustdocVisitor<'a> {\n                 };\n                 om.statics.push(s);\n             },\n-            ast::ItemTrait(ref gen, ref tr, ref met) => {\n+            ast::ItemTrait(ref gen, _, ref tr, ref met) => {\n                 let t = Trait {\n                     name: item.ident,\n                     methods: met.iter().map(|x| (*x).clone()).collect(),"}, {"sha": "116411c9e05102dd5de552a4dde4d5cde5e65b5b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -180,8 +180,10 @@ pub enum TyParamBound {\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n+    pub sized: Sized,\n     pub bounds: OwnedSlice<TyParamBound>,\n-    pub default: Option<P<Ty>>\n+    pub default: Option<P<Ty>>,\n+    pub span: Span\n }\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n@@ -1051,6 +1053,12 @@ impl Visibility {\n     }\n }\n \n+#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n+pub enum Sized {\n+    DynSize,\n+    StaticSize,\n+}\n+\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n@@ -1109,7 +1117,7 @@ pub enum Item_ {\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n     ItemStruct(@StructDef, Generics),\n-    ItemTrait(Generics, Vec<TraitRef> , Vec<TraitMethod> ),\n+    ItemTrait(Generics, Sized, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self"}, {"sha": "7a167237d3e5db38f8a8d1adcbef41dd24d58835", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -265,6 +265,31 @@ impl Map {\n         }\n     }\n \n+    pub fn expect_struct(&self, id: NodeId) -> @StructDef {\n+        match self.find(id) {\n+            Some(NodeItem(i)) => {\n+                match i.node {\n+                    ItemStruct(struct_def, _) => struct_def,\n+                    _ => fail!(\"struct ID bound to non-struct\")\n+                }\n+            }\n+            Some(NodeVariant(ref variant)) => {\n+                match (*variant).node.kind {\n+                    StructVariantKind(struct_def) => struct_def,\n+                    _ => fail!(\"struct ID bound to enum variant that isn't struct-like\"),\n+                }\n+            }\n+            _ => fail!(format!(\"expected struct, found {}\", self.node_to_str(id))),\n+        }\n+    }\n+\n+    pub fn expect_variant(&self, id: NodeId) -> P<Variant> {\n+        match self.find(id) {\n+            Some(NodeVariant(variant)) => variant,\n+            _ => fail!(format!(\"expected variant, found {}\", self.node_to_str(id))),\n+        }\n+    }\n+\n     pub fn expect_foreign_item(&self, id: NodeId) -> @ForeignItem {\n         match self.find(id) {\n             Some(NodeForeignItem(item)) => item,\n@@ -453,7 +478,7 @@ impl<'a, F: FoldOps> Folder for Ctx<'a, F> {\n                     None => {}\n                 }\n             }\n-            ItemTrait(_, ref traits, ref methods) => {\n+            ItemTrait(_, _, ref traits, ref methods) => {\n                 for t in traits.iter() {\n                     self.insert(t.ref_id, EntryItem(self.parent, i));\n                 }"}, {"sha": "e1174ea6cc434283c7a7e023ee74ed262c800ecf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -66,7 +66,9 @@ pub trait AstBuilder {\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self,\n+               span: Span,\n                id: ast::Ident,\n+               sized: ast::Sized,\n                bounds: OwnedSlice<ast::TyParamBound>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n@@ -368,14 +370,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn typaram(&self,\n+               span: Span,\n                id: ast::Ident,\n+               sized: ast::Sized,\n                bounds: OwnedSlice<ast::TyParamBound>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n             id: ast::DUMMY_NODE_ID,\n+            sized: sized,\n             bounds: bounds,\n-            default: default\n+            default: default,\n+            span: span\n         }\n     }\n "}, {"sha": "35a1eb0bb8381206a23b0d166044d5c7fe77adfe", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -13,6 +13,7 @@ The compiler code necessary for `#[deriving(Decodable)]`. See\n encodable.rs for more.\n */\n \n+use ast;\n use ast::{MetaItem, Item, Expr, MutMutable, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n@@ -35,10 +36,10 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__D\", vec!(Path::new_(\n+            bounds: vec!((\"__D\", ast::StaticSize, vec!(Path::new_(\n                             vec!(\"serialize\", \"Decoder\"), None,\n                             vec!(~Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", vec!()))\n+                         (\"__E\", ast::StaticSize, vec!()))\n         },\n         methods: vec!(\n             MethodDef {"}, {"sha": "806560f6826adbda053b77e0a34e9fb6a772a194", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -82,6 +82,7 @@ would yield functions like:\n ```\n */\n \n+use ast;\n use ast::{MetaItem, Item, Expr, ExprRet, MutMutable, LitNil};\n use codemap::Span;\n use ext::base::ExtCtxt;\n@@ -103,10 +104,10 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__S\", vec!(Path::new_(\n+            bounds: vec!((\"__S\", ast::StaticSize, vec!(Path::new_(\n                             vec!(\"serialize\", \"Encoder\"), None,\n                             vec!(~Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", vec!()))\n+                         (\"__E\", ast::StaticSize, vec!()))\n         },\n         methods: vec!(\n             MethodDef {"}, {"sha": "914451fb4024e9a71b8ad770c17f334334d763f6", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -380,7 +380,11 @@ impl<'a> TraitDef<'a> {\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n \n-            cx.typaram(ty_param.ident, OwnedSlice::from_vec(bounds), None)\n+            cx.typaram(self.span,\n+                       ty_param.ident,\n+                       ty_param.sized,\n+                       OwnedSlice::from_vec(bounds),\n+                       None)\n         }));\n         let trait_generics = Generics {\n             lifetimes: lifetimes,"}, {"sha": "d22027d203facff771de33f17bc4489945a3a876", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use ast;\n use ast::{MetaItem, Item, Expr, MutMutable};\n use codemap::Span;\n use ext::base::ExtCtxt;\n@@ -25,7 +26,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                     vec!(~Literal(Path::new_local(\"__S\"))), true),\n          LifetimeBounds {\n              lifetimes: Vec::new(),\n-             bounds: vec!((\"__S\", vec!(Path::new(vec!(\"std\", \"io\", \"Writer\"))))),\n+             bounds: vec!((\"__S\", ast::StaticSize, vec!(Path::new(vec!(\"std\", \"io\", \"Writer\"))))),\n          },\n          Path::new_local(\"__S\"))\n     } else {"}, {"sha": "e81aa55d10d32c2b8ed1a4a4239f89702913c7bd", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -32,7 +32,8 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds {\n                     lifetimes: Vec::new(),\n                     bounds: vec!((\"R\",\n-                               vec!( Path::new(vec!(\"rand\", \"Rng\")) )))\n+                                  ast::StaticSize,\n+                                  vec!( Path::new(vec!(\"rand\", \"Rng\")) )))\n                 },\n                 explicit_self: None,\n                 args: vec!("}, {"sha": "6e3327b40392ea5206cc8206f276fe35ceaeb380", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -186,14 +186,14 @@ impl<'a> Ty<'a> {\n }\n \n \n-fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, bounds: &[Path],\n+fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str, sized: ast::Sized, bounds: &[Path],\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds =\n         bounds.iter().map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n         }).collect();\n-    cx.typaram(cx.ident_of(name), bounds, None)\n+    cx.typaram(span, cx.ident_of(name), sized, bounds, None)\n }\n \n fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -> Generics {\n@@ -206,7 +206,7 @@ fn mk_generics(lifetimes: Vec<ast::Lifetime> ,  ty_params: Vec<ast::TyParam> ) -\n /// Lifetimes and bounds on type parameters\n pub struct LifetimeBounds<'a> {\n     pub lifetimes: Vec<&'a str>,\n-    pub bounds: Vec<(&'a str, Vec<Path<'a>>)>,\n+    pub bounds: Vec<(&'a str, ast::Sized, Vec<Path<'a>>)>,\n }\n \n impl<'a> LifetimeBounds<'a> {\n@@ -226,10 +226,11 @@ impl<'a> LifetimeBounds<'a> {\n         }).collect();\n         let ty_params = self.bounds.iter().map(|t| {\n             match t {\n-                &(ref name, ref bounds) => {\n+                &(ref name, sized, ref bounds) => {\n                     mk_ty_param(cx,\n                                 span,\n                                 *name,\n+                                sized,\n                                 bounds.as_slice(),\n                                 self_ty,\n                                 self_generics)"}, {"sha": "04b289b9fca4676ec589adec4f5f44ce21ce79c1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -447,8 +447,10 @@ pub fn fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n     TyParam {\n         ident: tp.ident,\n         id: id,\n+        sized: tp.sized,\n         bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld)),\n-        default: tp.default.map(|x| fld.fold_ty(x))\n+        default: tp.default.map(|x| fld.fold_ty(x)),\n+        span: tp.span\n     }\n }\n \n@@ -619,14 +621,15 @@ pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_\n                      methods.iter().map(|x| folder.fold_method(*x)).collect()\n             )\n         }\n-        ItemTrait(ref generics, ref traits, ref methods) => {\n+        ItemTrait(ref generics, ref sized, ref traits, ref methods) => {\n             let methods = methods.iter().map(|method| {\n                 match *method {\n                     Required(ref m) => Required(folder.fold_type_method(m)),\n                     Provided(method) => Provided(folder.fold_method(method))\n                 }\n             }).collect();\n             ItemTrait(fold_generics(generics, folder),\n+                      *sized,\n                       traits.iter().map(|p| fold_trait_ref(p, folder)).collect(),\n                       methods)\n         }"}, {"sha": "8808312bed75951e3060fe78c72bea5245571c78", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -42,6 +42,7 @@ use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatUniq, PatWild, PatWildMulti};\n use ast::{BiRem, Required};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n+use ast::{Sized, DynSize, StaticSize};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n use ast::StrStyle;\n@@ -3390,8 +3391,10 @@ impl<'a> Parser<'a> {\n         return (ret_lifetime, Some(OwnedSlice::from_vec(result)));\n     }\n \n-    // matches typaram = IDENT optbounds ( EQ ty )?\n+    // matches typaram = type? IDENT optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n+        let sized = self.parse_sized();\n+        let span = self.span;\n         let ident = self.parse_ident();\n         let (_, opt_bounds) = self.parse_optional_ty_param_bounds(false);\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n@@ -3406,8 +3409,10 @@ impl<'a> Parser<'a> {\n         TyParam {\n             ident: ident,\n             id: ast::DUMMY_NODE_ID,\n+            sized: sized,\n             bounds: bounds,\n-            default: default\n+            default: default,\n+            span: span,\n         }\n     }\n \n@@ -3795,6 +3800,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_trait(&mut self) -> ItemInfo {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n+        let sized = self.parse_for_sized();\n \n         // Parse traits, if necessary.\n         let traits;\n@@ -3806,7 +3812,7 @@ impl<'a> Parser<'a> {\n         }\n \n         let meths = self.parse_trait_methods();\n-        (ident, ItemTrait(tps, traits, meths), None)\n+        (ident, ItemTrait(tps, sized, traits, meths), None)\n     }\n \n     // Parses two variants (with the region/type params always optional):\n@@ -3997,6 +4003,23 @@ impl<'a> Parser<'a> {\n         else { Inherited }\n     }\n \n+    fn parse_sized(&mut self) -> Sized {\n+        if self.eat_keyword(keywords::Type) { DynSize }\n+        else { StaticSize }\n+    }\n+\n+    fn parse_for_sized(&mut self) -> Sized {\n+        if self.eat_keyword(keywords::For) {\n+            if !self.eat_keyword(keywords::Type) {\n+                self.span_err(self.last_span,\n+                    \"expected 'type' after for in trait item\");\n+            }\n+            DynSize\n+        } else {\n+            StaticSize\n+        }\n+    }\n+\n     // given a termination token and a vector of already-parsed\n     // attributes (of length 0 or 1), parse all of the items in a module\n     fn parse_mod_items(&mut self,"}, {"sha": "f768bf22ce0ceb190d5cbbc5c7f2e6bedc8828dc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -673,10 +673,14 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose(item.span));\n             }\n-            ast::ItemTrait(ref generics, ref traits, ref methods) => {\n+            ast::ItemTrait(ref generics, ref sized, ref traits, ref methods) => {\n                 try!(self.head(visibility_qualified(item.vis, \"trait\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(generics));\n+                if *sized == ast::DynSize {\n+                    try!(space(&mut self.s));\n+                    try!(word(&mut self.s, \"for type\"));\n+                }\n                 if traits.len() != 0u {\n                     try!(word(&mut self.s, \":\"));\n                     for (i, trait_) in traits.iter().enumerate() {\n@@ -1910,6 +1914,9 @@ impl<'a> State<'a> {\n                     } else {\n                         let idx = idx - generics.lifetimes.len();\n                         let param = generics.ty_params.get(idx);\n+                        if param.sized == ast::DynSize {\n+                            try!(s.word_space(\"type\"));\n+                        }\n                         try!(s.print_ident(param.ident));\n                         try!(s.print_bounds(&None, &param.bounds, false));\n                         match param.default {"}, {"sha": "e830daf8edeb66900f152393a24495b5b28cda7f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -257,7 +257,7 @@ pub fn walk_item<E: Clone, V: Visitor<E>>(visitor: &mut V, item: &Item, env: E)\n                                      item.id,\n                                      env)\n         }\n-        ItemTrait(ref generics, ref trait_paths, ref methods) => {\n+        ItemTrait(ref generics, _, ref trait_paths, ref methods) => {\n             visitor.visit_generics(generics, env.clone());\n             for trait_path in trait_paths.iter() {\n                 visitor.visit_path(&trait_path.path,"}, {"sha": "58ed6624cbf3ba445df1cf886f1d791e8daa989b", "filename": "src/test/compile-fail/bad-mid-path-type-params.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-mid-path-type-params.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -12,6 +12,9 @@\n \n #![no_std]\n \n+#[lang=\"sized\"]\n+pub trait Sized {}\n+\n struct S<T> {\n     contents: T,\n }"}, {"sha": "6940c85e0e63dec819117d4755df6c4d1b8effb2", "filename": "src/test/compile-fail/borrowck-move-subcomponent.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-subcomponent.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -13,6 +13,9 @@\n \n #![no_std]\n \n+#[lang=\"sized\"]\n+pub trait Sized {}\n+\n struct S {\n   x : ~int\n }"}, {"sha": "bbcc59f0d6cbddf0083e9c4c229c90e5d6f4e039", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -17,6 +17,10 @@\n #![crate_type=\"lib\"]\n \n pub use foo2::Bar2;\n+\n+#[lang=\"sized\"]\n+pub trait Sized {}\n+\n mod foo {\n     pub struct Bar; //~ ERROR: code is never used\n }"}, {"sha": "83141020b29e49226e317351d49f4ac9abb6fbae", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -11,6 +11,9 @@\n #![feature(globs)]\n #![no_std] // makes debugging this test *a lot* easier (during resolve)\n \n+#[lang=\"sized\"]\n+pub trait Sized {}\n+\n mod bar {\n     // shouln't bring in too much\n     pub use self::glob::*;"}, {"sha": "fd09d78a4fa625a4d45ca766482943a6789a728a", "filename": "src/test/compile-fail/unsized-bare-typaram.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-bare-typaram.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -10,5 +10,5 @@\n \n // error-pattern: instantiating a type parameter with an incompatible type\n fn bar<T: Sized>() { }\n-fn foo<T>() { bar::<T>() }\n+fn foo<type T>() { bar::<T>() }\n fn main() { }"}, {"sha": "f586fbb576b323110c24e5b6d9dac73b489254b4", "filename": "src/test/compile-fail/unsized-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-enum.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -10,5 +10,5 @@\n \n // error-pattern: instantiating a type parameter with an incompatible type\n fn bar<T: Sized>() { }\n-fn foo<T>() { bar::<Option<T>>() }\n+fn foo<type T>() { bar::<Option<T>>() }\n fn main() { }"}, {"sha": "9fab3accbb9de8dcb8b7ae03c1e33aebb4ee6916", "filename": "src/test/compile-fail/unsized-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized-struct.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -13,5 +13,5 @@\n struct Foo<T> { data: T }\n \n fn bar<T: Sized>() { }\n-fn foo<T>() { bar::<Foo<T>>() }\n+fn foo<type T>() { bar::<Foo<T>>() }\n fn main() { }"}, {"sha": "d5c2bbb21cad65c137c45168e32a00bf2ee5d52f", "filename": "src/test/compile-fail/unsized.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test syntax checks for `type` keyword.\n+\n+struct S1 for type; //~ ERROR expected `{`, `(`, or `;` after struct name but found `for`\n+\n+pub fn main() {\n+}"}, {"sha": "0c9d05e29883261d2856d241c653ecad46027459", "filename": "src/test/compile-fail/unsized2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized2.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test syntax checks for `type` keyword.\n+\n+fn f<X>() {}\n+\n+pub fn main() {\n+    f<type>(); //~ ERROR found `type` in ident position\n+}"}, {"sha": "0ff5b1c9b5ad8b76c1ca08b67e031567ac4153a8", "filename": "src/test/compile-fail/unsized3.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized3.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test sized-ness checking in substitution.\n+\n+// Unbounded.\n+fn f1<type X>(x: &X) {\n+    f2::<X>(x); //~ ERROR instantiating a type parameter with an incompatible type `X`, which does n\n+}\n+fn f2<X>(x: &X) {\n+}\n+\n+// Bounded.\n+trait T for type {}\n+fn f3<type X: T>(x: &X) {\n+    f4::<X>(x); //~ ERROR instantiating a type parameter with an incompatible type `X`, which does n\n+}\n+fn f4<X: T>(x: &X) {\n+}\n+\n+// Test with unsized enum.\n+enum E<type X> {\n+    V(X),\n+}\n+\n+fn f5<Y>(x: &Y) {}\n+fn f6<type X>(x: &X) {}\n+fn f7<type X>(x1: &E<X>, x2: &E<X>) {\n+    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `E<X>`, which does not\n+    f6(x2); // ok\n+}\n+\n+\n+// Test with unsized struct.\n+struct S<type X> {\n+    x: X,\n+}\n+\n+fn f8<type X>(x1: &S<X>, x2: &S<X>) {\n+    f5(x1); //~ERROR instantiating a type parameter with an incompatible type `S<X>`, which does not\n+    f6(x2); // ok\n+}\n+\n+// Test some tuples.\n+fn f9<type X>(x1: ~S<X>, x2: ~E<X>) {\n+    f5(&(*x1, 34)); //~ERROR instantiating a type parameter with an incompatible type `(S<X>,int)`,\n+    f5(&(32, *x2)); //~ERROR instantiating a type parameter with an incompatible type `(int,E<X>)`,\n+}\n+\n+// I would like these to fail eventually.\n+/*\n+// impl - bounded\n+trait T1<Z: T> {\n+}\n+struct S3<type Y>;\n+impl<type X: T> T1<X> for S3<X> { //ERROR instantiating a type parameter with an incompatible type\n+}\n+\n+// impl - unbounded\n+trait T2<Z> {\n+}\n+impl<type X> T2<X> for S3<X> { //ERROR instantiating a type parameter with an incompatible type `X`\n+\n+// impl - struct\n+trait T3<type Z> {\n+}\n+struct S4<Y>;\n+impl<type X> T3<X> for S4<X> { //ERROR instantiating a type parameter with an incompatible type `X`\n+}\n+*/\n+\n+pub fn main() {\n+}"}, {"sha": "968716320fd5ed6b63f1f842181622bac368729f", "filename": "src/test/compile-fail/unsized4.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized4.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that bounds are sized-compatible.\n+\n+trait T {}\n+fn f<type Y: T>() {\n+//~^ERROR incompatible bounds on type parameter Y, bound T does not allow unsized type\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "9608b7e6b202335e34cc72f99221770ea9296919", "filename": "src/test/compile-fail/unsized5.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant)]\n+\n+// Test `type` types not allowed in fields or local variables.\n+\n+/*trait T for type {}\n+\n+fn f5<type X>(x: &X) {\n+    let _: X; // ERROR local variable with dynamically sized type X\n+    let _: (int, (X, int)); // ERROR local variable with dynamically sized type (int,(X,int))\n+}\n+fn f6<type X: T>(x: &X) {\n+    let _: X; // ERROR local variable with dynamically sized type X\n+    let _: (int, (X, int)); // ERROR local variable with dynamically sized type (int,(X,int))\n+}*/\n+\n+struct S1<type X> {\n+    f1: X, //~ ERROR type `f1` is dynamically sized. dynamically sized types may only appear as the\n+    f2: int,\n+}\n+struct S2<type X> {\n+    f: int,\n+    g: X, //~ ERROR type `g` is dynamically sized. dynamically sized types may only appear as the ty\n+    h: int,\n+}\n+\n+enum E<type X> {\n+    V1(X, int), //~ERROR type `X` is dynamically sized. dynamically sized types may only appear as t\n+    V2{f1: X, f: int}, //~ERROR type `f1` is dynamically sized. dynamically sized types may only app\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "db0cc83d7866af826dcdadb3602850083b1b822c", "filename": "src/test/run-pass/unsized.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Frun-pass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Frun-pass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test syntax checks for `type` keyword.\n+\n+trait T1 for type {}\n+pub trait T2 for type {}\n+trait T3<X: T1> for type: T2 {}\n+trait T4<type X> {}\n+trait T5<type X, Y> {}\n+trait T6<Y, type X> {}\n+trait T7<type X, type Y> {}\n+trait T8<type X: T2> {}\n+struct S1<type X>;\n+enum E<type X> {}\n+impl <type X> T1 for S1<X> {}\n+fn f<type X>() {}\n+\n+pub fn main() {\n+}"}, {"sha": "7883adad46a3791365fc6a0e417da939881ba002", "filename": "src/test/run-pass/unsized2.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Frun-pass%2Funsized2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/696f16ec2e54e8563702b1cdbbaaa1877562aa60/src%2Ftest%2Frun-pass%2Funsized2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized2.rs?ref=696f16ec2e54e8563702b1cdbbaaa1877562aa60", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(struct_variant)]\n+\n+// Test sized-ness checking in substitution.\n+\n+// Unbounded.\n+fn f1<type X>(x: &X) {\n+    f1::<X>(x);\n+}\n+fn f2<X>(x: &X) {\n+    f1::<X>(x);\n+    f2::<X>(x);\n+}\n+\n+// Bounded.\n+trait T for type {}\n+fn f3<type X: T>(x: &X) {\n+    f3::<X>(x);\n+}\n+fn f4<X: T>(x: &X) {\n+    f3::<X>(x);\n+    f4::<X>(x);\n+}\n+\n+// Self type.\n+trait T2 for type {\n+    fn f() -> ~Self;\n+}\n+struct S;\n+impl T2 for S {\n+    fn f() -> ~S {\n+        ~S\n+    }\n+}\n+fn f5<type X: T2>(x: &X) {\n+    let _: ~X = T2::f();\n+}\n+fn f6<X: T2>(x: &X) {\n+    let _: ~X = T2::f();\n+}\n+\n+trait T3 for type {\n+    fn f() -> ~Self;\n+}\n+impl T3 for S {\n+    fn f() -> ~S {\n+        ~S\n+    }\n+}\n+fn f7<type X: T3>(x: &X) {\n+    // This is valid, but the unsized bound on X is irrelevant because any type\n+    // which implements T3 must have statically known size.\n+    let _: ~X = T3::f();\n+}\n+\n+trait T4<X> {\n+    fn m1(x: &T4<X>);\n+    fn m2(x: &T5<X>);\n+}\n+trait T5<type X> {\n+    // not an error (for now)\n+    fn m1(x: &T4<X>);\n+    fn m2(x: &T5<X>);\n+}\n+\n+trait T6<X: T> {\n+    fn m1(x: &T4<X>);\n+    fn m2(x: &T5<X>);\n+}\n+trait T7<type X: T> {\n+    // not an error (for now)\n+    fn m1(x: &T4<X>);\n+    fn m2(x: &T5<X>);\n+}\n+\n+// The last field in a struct or variant may be unsized\n+struct S2<type X> {\n+    f: X,\n+}\n+struct S3<type X> {\n+    f1: int,\n+    f2: X,\n+}\n+enum E<type X> {\n+    V1(X),\n+    V2{x: X},\n+    V3(int, X),\n+    V4{u: int, x: X},\n+}\n+\n+pub fn main() {\n+}"}]}