{"sha": "52445129fdb4ee847332acbf516ced8f73b7990a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNDQ1MTI5ZmRiNGVlODQ3MzMyYWNiZjUxNmNlZDhmNzNiNzk5MGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-09T05:31:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-14T05:15:46Z"}, "message": "std: remove unused unsafe blocks/functions", "tree": {"sha": "4e9ae621e947b49af1e6d84d725896bf293da7cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e9ae621e947b49af1e6d84d725896bf293da7cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52445129fdb4ee847332acbf516ced8f73b7990a", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52445129fdb4ee847332acbf516ced8f73b7990a", "html_url": "https://github.com/rust-lang/rust/commit/52445129fdb4ee847332acbf516ced8f73b7990a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52445129fdb4ee847332acbf516ced8f73b7990a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9595d1737677dd61d9f52f674c34f13d708e39c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9595d1737677dd61d9f52f674c34f13d708e39c", "html_url": "https://github.com/rust-lang/rust/commit/d9595d1737677dd61d9f52f674c34f13d708e39c"}], "stats": {"total": 860, "additions": 405, "deletions": 455}, "files": [{"sha": "a59c76c809b13152d4b809b59060053762a70d9b", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -57,11 +57,9 @@ struct DtorRes {\n #[unsafe_destructor]\n impl Drop for DtorRes {\n     fn finalize(&self) {\n-        unsafe {\n-            match self.dtor {\n-                option::None => (),\n-                option::Some(f) => f()\n-            }\n+        match self.dtor {\n+            option::None => (),\n+            option::Some(f) => f()\n         }\n     }\n }\n@@ -84,7 +82,7 @@ fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n  * * base - A foreign pointer to a buffer\n  * * len - The number of elements in the buffer\n  */\n-pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n+pub fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n     return CVec{\n         base: base,\n         len: len,\n@@ -103,7 +101,7 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  * * dtor - A function to run when the value is destructed, useful\n  *          for freeing the buffer, etc.\n  */\n-pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n+pub fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n   -> CVec<T> {\n     return CVec{\n         base: base,\n@@ -144,7 +142,7 @@ pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n pub fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n-pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n+pub fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n \n #[cfg(test)]\n mod tests {"}, {"sha": "b1e80718d8f74c050777b26874a482d7874f47e7", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 108, "deletions": 110, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -223,128 +223,126 @@ pub type Result = result::Result<Matches, Fail_>;\n  * Use <fail_str> to get an error message.\n  */\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n-    unsafe {\n-        let n_opts = opts.len();\n-        fn f(_x: uint) -> ~[Optval] { return ~[]; }\n-        let mut vals = vec::from_fn(n_opts, f);\n-        let mut free: ~[~str] = ~[];\n-        let l = args.len();\n-        let mut i = 0;\n-        while i < l {\n-            let cur = args[i];\n-            let curlen = cur.len();\n-            if !is_arg(cur) {\n-                free.push(cur);\n-            } else if cur == ~\"--\" {\n-                let mut j = i + 1;\n-                while j < l { free.push(args[j]); j += 1; }\n-                break;\n-            } else {\n-                let mut names;\n-                let mut i_arg = None;\n-                if cur[1] == '-' as u8 {\n-                    let tail = str::slice(cur, 2, curlen).to_owned();\n-                    let mut tail_eq = ~[];\n-                    for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n-                    if tail_eq.len() <= 1 {\n-                        names = ~[Long(tail)];\n-                    } else {\n-                        names =\n-                            ~[Long(tail_eq[0])];\n-                        i_arg = Some(tail_eq[1]);\n-                    }\n+    let n_opts = opts.len();\n+    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+    let mut vals = vec::from_fn(n_opts, f);\n+    let mut free: ~[~str] = ~[];\n+    let l = args.len();\n+    let mut i = 0;\n+    while i < l {\n+        let cur = args[i];\n+        let curlen = cur.len();\n+        if !is_arg(cur) {\n+            free.push(cur);\n+        } else if cur == ~\"--\" {\n+            let mut j = i + 1;\n+            while j < l { free.push(args[j]); j += 1; }\n+            break;\n+        } else {\n+            let mut names;\n+            let mut i_arg = None;\n+            if cur[1] == '-' as u8 {\n+                let tail = str::slice(cur, 2, curlen).to_owned();\n+                let mut tail_eq = ~[];\n+                for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n+                if tail_eq.len() <= 1 {\n+                    names = ~[Long(tail)];\n                 } else {\n-                    let mut j = 1;\n-                    let mut last_valid_opt_id = None;\n-                    names = ~[];\n-                    while j < curlen {\n-                        let range = str::char_range_at(cur, j);\n-                        let opt = Short(range.ch);\n-\n-                        /* In a series of potential options (eg. -aheJ), if we\n-                           see one which takes an argument, we assume all\n-                           subsequent characters make up the argument. This\n-                           allows options such as -L/usr/local/lib/foo to be\n-                           interpreted correctly\n-                        */\n-\n-                        match find_opt(opts, opt) {\n-                          Some(id) => last_valid_opt_id = Some(id),\n-                          None => {\n-                            let arg_follows =\n-                                last_valid_opt_id.is_some() &&\n-                                match opts[last_valid_opt_id.get()]\n-                                  .hasarg {\n-\n-                                  Yes | Maybe => true,\n-                                  No => false\n-                                };\n-                            if arg_follows && j < curlen {\n-                                i_arg = Some(cur.slice(j, curlen).to_owned());\n-                                break;\n-                            } else {\n-                                last_valid_opt_id = None;\n-                            }\n-                          }\n-                        }\n-                        names.push(opt);\n-                        j = range.next;\n-                    }\n+                    names =\n+                        ~[Long(tail_eq[0])];\n+                    i_arg = Some(tail_eq[1]);\n                 }\n-                let mut name_pos = 0;\n-                for names.each() |nm| {\n-                    name_pos += 1;\n-                    let optid = match find_opt(opts, *nm) {\n-                      Some(id) => id,\n-                      None => return Err(UnrecognizedOption(name_str(nm)))\n-                    };\n-                    match opts[optid].hasarg {\n-                      No => {\n-                        if !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(name_str(nm)));\n+            } else {\n+                let mut j = 1;\n+                let mut last_valid_opt_id = None;\n+                names = ~[];\n+                while j < curlen {\n+                    let range = str::char_range_at(cur, j);\n+                    let opt = Short(range.ch);\n+\n+                    /* In a series of potential options (eg. -aheJ), if we\n+                       see one which takes an argument, we assume all\n+                       subsequent characters make up the argument. This\n+                       allows options such as -L/usr/local/lib/foo to be\n+                       interpreted correctly\n+                    */\n+\n+                    match find_opt(opts, opt) {\n+                      Some(id) => last_valid_opt_id = Some(id),\n+                      None => {\n+                        let arg_follows =\n+                            last_valid_opt_id.is_some() &&\n+                            match opts[last_valid_opt_id.get()]\n+                              .hasarg {\n+\n+                              Yes | Maybe => true,\n+                              No => false\n+                            };\n+                        if arg_follows && j < curlen {\n+                            i_arg = Some(cur.slice(j, curlen).to_owned());\n+                            break;\n+                        } else {\n+                            last_valid_opt_id = None;\n                         }\n-                        vals[optid].push(Given);\n-                      }\n-                      Maybe => {\n-                        if !i_arg.is_none() {\n-                            vals[optid].push(Val(i_arg.get()));\n-                        } else if name_pos < names.len() ||\n-                                      i + 1 == l || is_arg(args[i + 1]) {\n-                            vals[optid].push(Given);\n-                        } else { i += 1; vals[optid].push(Val(args[i])); }\n-                      }\n-                      Yes => {\n-                        if !i_arg.is_none() {\n-                            vals[optid].push(Val(i_arg.get()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(name_str(nm)));\n-                        } else { i += 1; vals[optid].push(Val(args[i])); }\n                       }\n                     }\n+                    names.push(opt);\n+                    j = range.next;\n                 }\n             }\n-            i += 1;\n-        }\n-        i = 0u;\n-        while i < n_opts {\n-            let n = vals[i].len();\n-            let occ = opts[i].occur;\n-            if occ == Req {\n-                if n == 0 {\n-                    return Err(OptionMissing(name_str(&(opts[i].name))));\n+            let mut name_pos = 0;\n+            for names.each() |nm| {\n+                name_pos += 1;\n+                let optid = match find_opt(opts, *nm) {\n+                  Some(id) => id,\n+                  None => return Err(UnrecognizedOption(name_str(nm)))\n+                };\n+                match opts[optid].hasarg {\n+                  No => {\n+                    if !i_arg.is_none() {\n+                        return Err(UnexpectedArgument(name_str(nm)));\n+                    }\n+                    vals[optid].push(Given);\n+                  }\n+                  Maybe => {\n+                    if !i_arg.is_none() {\n+                        vals[optid].push(Val(i_arg.get()));\n+                    } else if name_pos < names.len() ||\n+                                  i + 1 == l || is_arg(args[i + 1]) {\n+                        vals[optid].push(Given);\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                  }\n+                  Yes => {\n+                    if !i_arg.is_none() {\n+                        vals[optid].push(Val(i_arg.get()));\n+                    } else if i + 1 == l {\n+                        return Err(ArgumentMissing(name_str(nm)));\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                  }\n                 }\n             }\n-            if occ != Multi {\n-                if n > 1 {\n-                    return Err(OptionDuplicated(name_str(&(opts[i].name))));\n-                }\n+        }\n+        i += 1;\n+    }\n+    i = 0u;\n+    while i < n_opts {\n+        let n = vals[i].len();\n+        let occ = opts[i].occur;\n+        if occ == Req {\n+            if n == 0 {\n+                return Err(OptionMissing(name_str(&(opts[i].name))));\n+            }\n+        }\n+        if occ != Multi {\n+            if n > 1 {\n+                return Err(OptionDuplicated(name_str(&(opts[i].name))));\n             }\n-            i += 1;\n         }\n-        return Ok(Matches {opts: vec::from_slice(opts),\n-                   vals: vals,\n-                   free: free});\n+        i += 1;\n     }\n+    return Ok(Matches {opts: vec::from_slice(opts),\n+               vals: vals,\n+               free: free});\n }\n \n fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {"}, {"sha": "e920ff20ac5dcd9773545569247967f6c85e68a3", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -116,35 +116,33 @@ pub fn get_addr(node: &str, iotask: &iotask)\n     let mut output_ch = Some(SharedChan(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n         let output_ch = output_ch.swap_unwrap();\n-        unsafe {\n-            debug!(\"slice len %?\", len);\n-            let handle = create_uv_getaddrinfo_t();\n-            let handle_ptr = ptr::addr_of(&handle);\n-            let handle_data = GetAddrData {\n-                output_ch: output_ch.clone()\n-            };\n-            let handle_data_ptr = ptr::addr_of(&handle_data);\n-            do interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    let result = uv_getaddrinfo(\n-                        loop_ptr,\n-                        handle_ptr,\n-                        get_addr_cb,\n-                        node_ptr,\n-                        ptr::null(),\n-                        ptr::null());\n-                    match result {\n-                        0i32 => {\n-                            set_data_for_req(handle_ptr, handle_data_ptr);\n-                        }\n-                        _ => {\n-                            output_ch.send(result::Err(GetAddrUnknownError));\n-                        }\n+        debug!(\"slice len %?\", len);\n+        let handle = create_uv_getaddrinfo_t();\n+        let handle_ptr = ptr::addr_of(&handle);\n+        let handle_data = GetAddrData {\n+            output_ch: output_ch.clone()\n+        };\n+        let handle_data_ptr = ptr::addr_of(&handle_data);\n+        do interact(iotask) |loop_ptr| {\n+            unsafe {\n+                let result = uv_getaddrinfo(\n+                    loop_ptr,\n+                    handle_ptr,\n+                    get_addr_cb,\n+                    node_ptr,\n+                    ptr::null(),\n+                    ptr::null());\n+                match result {\n+                    0i32 => {\n+                        set_data_for_req(handle_ptr, handle_data_ptr);\n+                    }\n+                    _ => {\n+                        output_ch.send(result::Err(GetAddrUnknownError));\n                     }\n                 }\n-            };\n-            output_po.recv()\n-        }\n+            }\n+        };\n+        output_po.recv()\n     }\n }\n "}, {"sha": "a8b2723bcfbc415154d4e4a5a49db2f2d25e26a8", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 147, "deletions": 160, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -57,9 +57,7 @@ pub struct TcpSocket {\n #[unsafe_destructor]\n impl Drop for TcpSocket {\n     fn finalize(&self) {\n-        unsafe {\n-            tear_down_socket_data(self.socket_data)\n-        }\n+        tear_down_socket_data(self.socket_data)\n     }\n }\n \n@@ -302,11 +300,10 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData> {\n-    unsafe {\n-        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-        write_common_impl(socket_data_ptr, raw_write_data)\n-    }\n+    -> result::Result<(), TcpErrData>\n+{\n+    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    write_common_impl(socket_data_ptr, raw_write_data)\n }\n \n /**\n@@ -341,13 +338,12 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n  * value as the `Err` variant\n  */\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> future::Future<result::Result<(), TcpErrData>> {\n-    unsafe {\n-        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-        do future_spawn {\n-            let data_copy = copy(raw_write_data);\n-            write_common_impl(socket_data_ptr, data_copy)\n-        }\n+    -> future::Future<result::Result<(), TcpErrData>>\n+{\n+    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    do future_spawn {\n+        let data_copy = copy(raw_write_data);\n+        write_common_impl(socket_data_ptr, data_copy)\n     }\n }\n \n@@ -369,10 +365,8 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n pub fn read_start(sock: &TcpSocket)\n     -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-    unsafe {\n-        let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n-        read_start_common_impl(socket_data)\n-    }\n+    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+    read_start_common_impl(socket_data)\n }\n \n /**\n@@ -382,12 +376,9 @@ pub fn read_start(sock: &TcpSocket)\n  *\n  * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n-pub fn read_stop(sock: &TcpSocket) ->\n-    result::Result<(), TcpErrData> {\n-    unsafe {\n-        let socket_data = ptr::addr_of(&(*sock.socket_data));\n-        read_stop_common_impl(socket_data)\n-    }\n+pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n+    let socket_data = ptr::addr_of(&(*sock.socket_data));\n+    read_stop_common_impl(socket_data)\n }\n \n /**\n@@ -654,150 +645,148 @@ fn listen_common(host_ip: ip::IpAddr,\n                  on_establish_cb: ~fn(SharedChan<Option<TcpErrData>>),\n                  on_connect_cb: ~fn(*uv::ll::uv_tcp_t))\n               -> result::Result<(), TcpListenErrData> {\n-    unsafe {\n-        let (stream_closed_po, stream_closed_ch) = stream::<()>();\n-        let stream_closed_ch = SharedChan(stream_closed_ch);\n-        let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n-        let kill_ch = SharedChan(kill_ch);\n-        let server_stream = uv::ll::tcp_t();\n-        let server_stream_ptr = ptr::addr_of(&server_stream);\n-        let server_data: TcpListenFcData = TcpListenFcData {\n-            server_stream_ptr: server_stream_ptr,\n-            stream_closed_ch: stream_closed_ch,\n-            kill_ch: kill_ch.clone(),\n-            on_connect_cb: on_connect_cb,\n-            iotask: iotask.clone(),\n-            ipv6: match &host_ip {\n-                &ip::Ipv4(_) => { false }\n-                &ip::Ipv6(_) => { true }\n-            },\n-            mut active: true\n-        };\n-        let server_data_ptr = ptr::addr_of(&server_data);\n-\n-        let (setup_po, setup_ch) = stream();\n-\n-        // this is to address a compiler warning about\n-        // an implicit copy.. it seems that double nested\n-        // will defeat a move sigil, as is done to the host_ip\n-        // arg above.. this same pattern works w/o complaint in\n-        // tcp::connect (because the iotask::interact cb isn't\n-        // nested within a core::comm::listen block)\n-        let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |loop_ptr| {\n-            unsafe {\n-                match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-                    0i32 => {\n-                        uv::ll::set_data_for_uv_handle(\n-                            server_stream_ptr,\n-                            server_data_ptr);\n-                        let addr_str = ip::format_addr(&loc_ip);\n-                        let bind_result = match loc_ip {\n-                            ip::Ipv4(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip4_addr(\n-                                    addr_str,\n-                                    port as int);\n-                                uv::ll::tcp_bind(server_stream_ptr,\n-                                                 ptr::addr_of(&in_addr))\n-                            }\n-                            ip::Ipv6(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip6_addr(\n-                                    addr_str,\n-                                    port as int);\n-                                uv::ll::tcp_bind6(server_stream_ptr,\n-                                                  ptr::addr_of(&in_addr))\n-                            }\n-                        };\n-                        match bind_result {\n-                            0i32 => {\n-                                match uv::ll::listen(\n-                                    server_stream_ptr,\n-                                    backlog as libc::c_int,\n-                                    tcp_lfc_on_connection_cb) {\n-                                    0i32 => setup_ch.send(None),\n-                                    _ => {\n-                                        debug!(\n-                                            \"failure to uv_tcp_init\");\n-                                        let err_data =\n-                                            uv::ll::get_last_err_data(\n-                                                loop_ptr);\n-                                        setup_ch.send(Some(err_data));\n-                                    }\n+    let (stream_closed_po, stream_closed_ch) = stream::<()>();\n+    let stream_closed_ch = SharedChan(stream_closed_ch);\n+    let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n+    let kill_ch = SharedChan(kill_ch);\n+    let server_stream = uv::ll::tcp_t();\n+    let server_stream_ptr = ptr::addr_of(&server_stream);\n+    let server_data: TcpListenFcData = TcpListenFcData {\n+        server_stream_ptr: server_stream_ptr,\n+        stream_closed_ch: stream_closed_ch,\n+        kill_ch: kill_ch.clone(),\n+        on_connect_cb: on_connect_cb,\n+        iotask: iotask.clone(),\n+        ipv6: match &host_ip {\n+            &ip::Ipv4(_) => { false }\n+            &ip::Ipv6(_) => { true }\n+        },\n+        mut active: true\n+    };\n+    let server_data_ptr = ptr::addr_of(&server_data);\n+\n+    let (setup_po, setup_ch) = stream();\n+\n+    // this is to address a compiler warning about\n+    // an implicit copy.. it seems that double nested\n+    // will defeat a move sigil, as is done to the host_ip\n+    // arg above.. this same pattern works w/o complaint in\n+    // tcp::connect (because the iotask::interact cb isn't\n+    // nested within a core::comm::listen block)\n+    let loc_ip = copy(host_ip);\n+    do iotask::interact(iotask) |loop_ptr| {\n+        unsafe {\n+            match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+                0i32 => {\n+                    uv::ll::set_data_for_uv_handle(\n+                        server_stream_ptr,\n+                        server_data_ptr);\n+                    let addr_str = ip::format_addr(&loc_ip);\n+                    let bind_result = match loc_ip {\n+                        ip::Ipv4(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip4_addr(\n+                                addr_str,\n+                                port as int);\n+                            uv::ll::tcp_bind(server_stream_ptr,\n+                                             ptr::addr_of(&in_addr))\n+                        }\n+                        ip::Ipv6(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip6_addr(\n+                                addr_str,\n+                                port as int);\n+                            uv::ll::tcp_bind6(server_stream_ptr,\n+                                              ptr::addr_of(&in_addr))\n+                        }\n+                    };\n+                    match bind_result {\n+                        0i32 => {\n+                            match uv::ll::listen(\n+                                server_stream_ptr,\n+                                backlog as libc::c_int,\n+                                tcp_lfc_on_connection_cb) {\n+                                0i32 => setup_ch.send(None),\n+                                _ => {\n+                                    debug!(\n+                                        \"failure to uv_tcp_init\");\n+                                    let err_data =\n+                                        uv::ll::get_last_err_data(\n+                                            loop_ptr);\n+                                    setup_ch.send(Some(err_data));\n                                 }\n                             }\n-                            _ => {\n-                                debug!(\"failure to uv_tcp_bind\");\n-                                let err_data = uv::ll::get_last_err_data(\n-                                    loop_ptr);\n-                                setup_ch.send(Some(err_data));\n-                            }\n                         }\n-                    }\n-                    _ => {\n-                        debug!(\"failure to uv_tcp_bind\");\n-                        let err_data = uv::ll::get_last_err_data(\n-                            loop_ptr);\n-                        setup_ch.send(Some(err_data));\n+                        _ => {\n+                            debug!(\"failure to uv_tcp_bind\");\n+                            let err_data = uv::ll::get_last_err_data(\n+                                loop_ptr);\n+                            setup_ch.send(Some(err_data));\n+                        }\n                     }\n                 }\n+                _ => {\n+                    debug!(\"failure to uv_tcp_bind\");\n+                    let err_data = uv::ll::get_last_err_data(\n+                        loop_ptr);\n+                    setup_ch.send(Some(err_data));\n+                }\n             }\n         }\n+    }\n \n-        let setup_result = setup_po.recv();\n+    let setup_result = setup_po.recv();\n \n-        match setup_result {\n-            Some(ref err_data) => {\n-                do iotask::interact(iotask) |loop_ptr| {\n-                    unsafe {\n-                        debug!(\n-                            \"tcp::listen post-kill recv hl interact %?\",\n-                                 loop_ptr);\n-                        (*server_data_ptr).active = false;\n-                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                    }\n-                };\n-                stream_closed_po.recv();\n-                match err_data.err_name {\n-                    ~\"EACCES\" => {\n-                        debug!(\"Got EACCES error\");\n-                        result::Err(AccessDenied)\n-                    }\n-                    ~\"EADDRINUSE\" => {\n-                        debug!(\"Got EADDRINUSE error\");\n-                        result::Err(AddressInUse)\n-                    }\n-                    _ => {\n-                        debug!(\"Got '%s' '%s' libuv error\",\n-                                        err_data.err_name, err_data.err_msg);\n-                        result::Err(\n-                            GenericListenErr(err_data.err_name,\n-                                             err_data.err_msg))\n-                    }\n+    match setup_result {\n+        Some(ref err_data) => {\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    debug!(\n+                        \"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr);\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+                }\n+            };\n+            stream_closed_po.recv();\n+            match err_data.err_name {\n+                ~\"EACCES\" => {\n+                    debug!(\"Got EACCES error\");\n+                    result::Err(AccessDenied)\n+                }\n+                ~\"EADDRINUSE\" => {\n+                    debug!(\"Got EADDRINUSE error\");\n+                    result::Err(AddressInUse)\n+                }\n+                _ => {\n+                    debug!(\"Got '%s' '%s' libuv error\",\n+                                    err_data.err_name, err_data.err_msg);\n+                    result::Err(\n+                        GenericListenErr(err_data.err_name,\n+                                         err_data.err_msg))\n                 }\n             }\n-            None => {\n-                on_establish_cb(kill_ch.clone());\n-                let kill_result = kill_po.recv();\n-                do iotask::interact(iotask) |loop_ptr| {\n-                    unsafe {\n-                        debug!(\n-                            \"tcp::listen post-kill recv hl interact %?\",\n-                                 loop_ptr);\n-                        (*server_data_ptr).active = false;\n-                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                    }\n-                };\n-                stream_closed_po.recv();\n-                match kill_result {\n-                    // some failure post bind/listen\n-                    Some(ref err_data) => result::Err(GenericListenErr(\n-                        err_data.err_name,\n-                        err_data.err_msg)),\n-                    // clean exit\n-                    None => result::Ok(())\n+        }\n+        None => {\n+            on_establish_cb(kill_ch.clone());\n+            let kill_result = kill_po.recv();\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    debug!(\n+                        \"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr);\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n+            };\n+            stream_closed_po.recv();\n+            match kill_result {\n+                // some failure post bind/listen\n+                Some(ref err_data) => result::Err(GenericListenErr(\n+                    err_data.err_name,\n+                    err_data.err_msg)),\n+                // clean exit\n+                None => result::Ok(())\n             }\n         }\n     }\n@@ -1382,9 +1371,7 @@ extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n }\n \n extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    unsafe {\n-        debug!(\"closed client tcp handle %?\", handle);\n-    }\n+    debug!(\"closed client tcp handle %?\", handle);\n }\n \n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,"}, {"sha": "9b8b0f9be0bcd19d77609b03ae8e3344549ebbee", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -118,8 +118,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n pub fn encode(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n-    unsafe {encode_inner(s, true)}\n+    encode_inner(s, true)\n }\n \n /**\n@@ -130,8 +129,7 @@ pub fn encode(s: &str) -> ~str {\n  */\n \n pub fn encode_component(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n-    unsafe {encode_inner(s, false)}\n+    encode_inner(s, false)\n }\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n@@ -178,16 +176,14 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  * This will only decode escape sequences generated by encode.\n  */\n pub fn decode(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {decode_inner(s, true)}\n+    decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n pub fn decode_component(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {decode_inner(s, false)}\n+    decode_inner(s, false)\n }\n \n fn encode_plus(s: &str) -> ~str {\n@@ -301,18 +297,15 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {\n-        do io::with_str_reader(s) |rdr| {\n-            let mut ch;\n-            while !rdr.eof() {\n-                ch = rdr.read_byte() as char;\n-                if ch == c {\n-                    // found a match, adjust markers\n-                    index = rdr.tell()-1;\n-                    mat = 1;\n-                    break;\n-                }\n+    do io::with_str_reader(s) |rdr| {\n+        let mut ch;\n+        while !rdr.eof() {\n+            ch = rdr.read_byte() as char;\n+            if ch == c {\n+                // found a match, adjust markers\n+                index = rdr.tell()-1;\n+                mat = 1;\n+                break;\n             }\n         }\n     }\n@@ -346,29 +339,25 @@ fn query_from_str(rawquery: &str) -> Query {\n     if str::len(rawquery) != 0 {\n         for str::each_split_char(rawquery, '&') |p| {\n             let (k, v) = split_char_first(p, '=');\n-            // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-            unsafe {query.push((decode_component(k), decode_component(v)));}\n+            query.push((decode_component(k), decode_component(v)));\n         };\n     }\n     return query;\n }\n \n pub fn query_to_str(query: &Query) -> ~str {\n-    unsafe {\n-        // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-        let mut strvec = ~[];\n-        for query.each |kv| {\n-            match kv {\n-                &(ref k, ref v) => {\n-                    strvec.push(fmt!(\"%s=%s\",\n-                        encode_component(*k),\n-                        encode_component(*v))\n-                    );\n-                }\n+    let mut strvec = ~[];\n+    for query.each |kv| {\n+        match kv {\n+            &(ref k, ref v) => {\n+                strvec.push(fmt!(\"%s=%s\",\n+                    encode_component(*k),\n+                    encode_component(*v))\n+                );\n             }\n         }\n-        return str::connect(strvec, ~\"&\");\n     }\n+    return str::connect(strvec, ~\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error"}, {"sha": "9f9f2323d271b344b334a832706994ec73b9edcf", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -59,12 +59,10 @@ pub unsafe fn load_history(file: ~str) -> bool {\n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: ~str) -> Option<~str> {\n     do str::as_c_str(prompt) |buf| {\n-        unsafe {\n-            let line = rustrt::linenoise(buf);\n+        let line = rustrt::linenoise(buf);\n \n-            if line.is_null() { None }\n-            else { Some(str::raw::from_c_str(line)) }\n-        }\n+        if line.is_null() { None }\n+        else { Some(str::raw::from_c_str(line)) }\n     }\n }\n \n@@ -74,22 +72,20 @@ fn complete_key(_v: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n-    unsafe {\n-        task::local_data::local_data_set(complete_key, @(cb));\n-\n-        extern fn callback(line: *c_char, completions: *()) {\n-            unsafe {\n-                let cb = *task::local_data::local_data_get(complete_key)\n-                    .get();\n-\n-                do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do str::as_c_str(suggestion) |buf| {\n-                        rustrt::linenoiseAddCompletion(completions, buf);\n-                    }\n+    task::local_data::local_data_set(complete_key, @(cb));\n+\n+    extern fn callback(line: *c_char, completions: *()) {\n+        unsafe {\n+            let cb = *task::local_data::local_data_get(complete_key)\n+                .get();\n+\n+            do cb(str::raw::from_c_str(line)) |suggestion| {\n+                do str::as_c_str(suggestion) |buf| {\n+                    rustrt::linenoiseAddCompletion(completions, buf);\n                 }\n             }\n         }\n-\n-        rustrt::linenoiseSetCompletionCallback(callback);\n     }\n+\n+    rustrt::linenoiseSetCompletionCallback(callback);\n }"}, {"sha": "653283f2e78b925a52b2fd83570072d177519e3c", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -862,17 +862,15 @@ pub mod node {\n      * This function executes in linear time.\n      */\n     pub fn flatten(node: @Node) -> @Node {\n-        unsafe {\n-            match (*node) {\n-                Leaf(_) => node,\n-                Concat(ref x) => {\n-                    @Leaf(Leaf {\n-                        byte_offset: 0u,\n-                        byte_len: x.byte_len,\n-                        char_len: x.char_len,\n-                        content: @serialize_node(node),\n-                    })\n-                }\n+        match (*node) {\n+            Leaf(_) => node,\n+            Concat(ref x) => {\n+                @Leaf(Leaf {\n+                    byte_offset: 0u,\n+                    byte_len: x.byte_len,\n+                    char_len: x.char_len,\n+                    content: @serialize_node(node),\n+                })\n             }\n         }\n     }"}, {"sha": "f2de8213a1b9e18c6691e9f7510cbf47b035ec7a", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -101,17 +101,15 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n pub impl<Q:Owned> Sem<Q> {\n     fn acquire(&self) {\n         let mut waiter_nobe = None;\n-        unsafe {\n-            do (**self).with |state| {\n-                state.count -= 1;\n-                if state.count < 0 {\n-                    // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = comm::oneshot();\n-                    // Tell outer scope we need to block.\n-                    waiter_nobe = Some(WaitEnd);\n-                    // Enqueue ourself.\n-                    state.waiters.tail.send(SignalEnd);\n-                }\n+        do (**self).with |state| {\n+            state.count -= 1;\n+            if state.count < 0 {\n+                // Create waiter nobe.\n+                let (WaitEnd, SignalEnd) = comm::oneshot();\n+                // Tell outer scope we need to block.\n+                waiter_nobe = Some(WaitEnd);\n+                // Enqueue ourself.\n+                state.waiters.tail.send(SignalEnd);\n             }\n         }\n         // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -122,12 +120,10 @@ pub impl<Q:Owned> Sem<Q> {\n         }\n     }\n     fn release(&self) {\n-        unsafe {\n-            do (**self).with |state| {\n-                state.count += 1;\n-                if state.count <= 0 {\n-                    signal_waitqueue(&state.waiters);\n-                }\n+        do (**self).with |state| {\n+            state.count += 1;\n+            if state.count <= 0 {\n+                signal_waitqueue(&state.waiters);\n             }\n         }\n     }\n@@ -169,9 +165,7 @@ struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n #[unsafe_destructor]\n impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n     fn finalize(&self) {\n-        unsafe {\n-            self.sem.release();\n-        }\n+        self.sem.release();\n     }\n }\n \n@@ -291,13 +285,11 @@ pub impl<'self> Condvar<'self> {\n     fn signal_on(&self, condvar_id: uint) -> bool {\n         let mut out_of_bounds = None;\n         let mut result = false;\n-        unsafe {\n-            do (**self.sem).with |state| {\n-                if condvar_id < vec::len(state.blocked) {\n-                    result = signal_waitqueue(&state.blocked[condvar_id]);\n-                } else {\n-                    out_of_bounds = Some(vec::len(state.blocked));\n-                }\n+        do (**self.sem).with |state| {\n+            if condvar_id < vec::len(state.blocked) {\n+                result = signal_waitqueue(&state.blocked[condvar_id]);\n+            } else {\n+                out_of_bounds = Some(vec::len(state.blocked));\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n@@ -312,17 +304,15 @@ pub impl<'self> Condvar<'self> {\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n-        unsafe {\n-            do (**self.sem).with |state| {\n-                if condvar_id < vec::len(state.blocked) {\n-                    // To avoid :broadcast_heavy, we make a new waitqueue,\n-                    // swap it out with the old one, and broadcast on the\n-                    // old one outside of the little-lock.\n-                    queue = Some(util::replace(&mut state.blocked[condvar_id],\n-                                               new_waitqueue()));\n-                } else {\n-                    out_of_bounds = Some(vec::len(state.blocked));\n-                }\n+        do (**self.sem).with |state| {\n+            if condvar_id < vec::len(state.blocked) {\n+                // To avoid :broadcast_heavy, we make a new waitqueue,\n+                // swap it out with the old one, and broadcast on the\n+                // old one outside of the little-lock.\n+                queue = Some(util::replace(&mut state.blocked[condvar_id],\n+                                           new_waitqueue()));\n+            } else {\n+                out_of_bounds = Some(vec::len(state.blocked));\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {"}, {"sha": "99e772b0c95a3ab332c8e22b266e3f58bfdf65ed", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -42,47 +42,45 @@ pub fn delayed_send<T:Owned>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: &Chan<T>,\n                               val: T) {\n+    let (timer_done_po, timer_done_ch) = stream::<()>();\n+    let timer_done_ch = SharedChan(timer_done_ch);\n+    let timer = uv::ll::timer_t();\n+    let timer_ptr = ptr::addr_of(&timer);\n+    do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n-            let (timer_done_po, timer_done_ch) = stream::<()>();\n-            let timer_done_ch = SharedChan(timer_done_ch);\n-            let timer = uv::ll::timer_t();\n-            let timer_ptr = ptr::addr_of(&timer);\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n-                    if (init_result == 0i32) {\n-                        let start_result = uv::ll::timer_start(\n-                            timer_ptr, delayed_send_cb, msecs, 0u);\n-                        if (start_result == 0i32) {\n-                            // Note: putting the channel into a ~\n-                            // to cast to *c_void\n-                            let timer_done_ch_clone = ~timer_done_ch.clone();\n-                            let timer_done_ch_ptr = transmute::<\n-                                ~SharedChan<()>, *c_void>(\n-                                timer_done_ch_clone);\n-                            uv::ll::set_data_for_uv_handle(\n-                                timer_ptr,\n-                                timer_done_ch_ptr);\n-                        } else {\n-                            let error_msg = uv::ll::get_last_err_info(\n-                                loop_ptr);\n-                            fail!(~\"timer::delayed_send() start failed: \" +\n-                                error_msg);\n-                        }\n-                    } else {\n-                        let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                        fail!(~\"timer::delayed_send() init failed: \" +\n-                            error_msg);\n-                    }\n+            let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n+            if (init_result == 0i32) {\n+                let start_result = uv::ll::timer_start(\n+                    timer_ptr, delayed_send_cb, msecs, 0u);\n+                if (start_result == 0i32) {\n+                    // Note: putting the channel into a ~\n+                    // to cast to *c_void\n+                    let timer_done_ch_clone = ~timer_done_ch.clone();\n+                    let timer_done_ch_ptr = transmute::<\n+                        ~SharedChan<()>, *c_void>(\n+                        timer_done_ch_clone);\n+                    uv::ll::set_data_for_uv_handle(\n+                        timer_ptr,\n+                        timer_done_ch_ptr);\n+                } else {\n+                    let error_msg = uv::ll::get_last_err_info(\n+                        loop_ptr);\n+                    fail!(~\"timer::delayed_send() start failed: \" +\n+                        error_msg);\n                 }\n-            };\n-            // delayed_send_cb has been processed by libuv\n-            timer_done_po.recv();\n-            // notify the caller immediately\n-            ch.send(val);\n-            // uv_close for this timer has been processed\n-            timer_done_po.recv();\n+            } else {\n+                let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+                fail!(~\"timer::delayed_send() init failed: \" +\n+                    error_msg);\n+            }\n+        }\n     };\n+    // delayed_send_cb has been processed by libuv\n+    timer_done_po.recv();\n+    // notify the caller immediately\n+    ch.send(val);\n+    // uv_close for this timer has been processed\n+    timer_done_po.recv();\n }\n \n /**"}, {"sha": "7a9d2438e6ada5180081ded3e3b7a6ed29aadd0c", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -75,7 +75,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-pub unsafe fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n+pub fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n     send_msg(iotask, Interaction(cb));\n }\n \n@@ -87,9 +87,7 @@ pub unsafe fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n  * closed, causing a failure otherwise.\n  */\n pub fn exit(iotask: &IoTask) {\n-    unsafe {\n-        send_msg(iotask, TeardownLoop);\n-    }\n+    send_msg(iotask, TeardownLoop);\n }\n \n "}, {"sha": "3bf297027d4d635b4f32586e8fe18346cd9553b0", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52445129fdb4ee847332acbf516ced8f73b7990a/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=52445129fdb4ee847332acbf516ced8f73b7990a", "patch": "@@ -1111,22 +1111,22 @@ pub unsafe fn freeaddrinfo(res: *addrinfo) {\n }\n \n // libuv struct initializers\n-pub unsafe fn tcp_t() -> uv_tcp_t {\n+pub fn tcp_t() -> uv_tcp_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n }\n-pub unsafe fn connect_t() -> uv_connect_t {\n+pub fn connect_t() -> uv_connect_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n }\n-pub unsafe fn write_t() -> uv_write_t {\n+pub fn write_t() -> uv_write_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n }\n-pub unsafe fn async_t() -> uv_async_t {\n+pub fn async_t() -> uv_async_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n }\n-pub unsafe fn timer_t() -> uv_timer_t {\n+pub fn timer_t() -> uv_timer_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n }\n-pub unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n+pub fn getaddrinfo_t() -> uv_getaddrinfo_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n }\n "}]}