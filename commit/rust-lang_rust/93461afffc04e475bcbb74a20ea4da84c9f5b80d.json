{"sha": "93461afffc04e475bcbb74a20ea4da84c9f5b80d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNDYxYWZmZmMwNGU0NzViY2JiNzRhMjBlYTRkYTg0YzlmNWI4MGQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-09T19:33:26Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-02-09T19:33:26Z"}, "message": "Merge branch 'pr-613'\n\nConflicts:\n\tsrc/lib.rs\n\tsrc/types.rs", "tree": {"sha": "a36f8abdb55326f312577ef3bd79ea115724b6fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a36f8abdb55326f312577ef3bd79ea115724b6fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93461afffc04e475bcbb74a20ea4da84c9f5b80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93461afffc04e475bcbb74a20ea4da84c9f5b80d", "html_url": "https://github.com/rust-lang/rust/commit/93461afffc04e475bcbb74a20ea4da84c9f5b80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93461afffc04e475bcbb74a20ea4da84c9f5b80d/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c886f1e752558e95d086deff4c1ccc61924873d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c886f1e752558e95d086deff4c1ccc61924873d", "html_url": "https://github.com/rust-lang/rust/commit/8c886f1e752558e95d086deff4c1ccc61924873d"}, {"sha": "908fb143ef06cc50f759ef38053a41d190dc73d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/908fb143ef06cc50f759ef38053a41d190dc73d5", "html_url": "https://github.com/rust-lang/rust/commit/908fb143ef06cc50f759ef38053a41d190dc73d5"}], "stats": {"total": 229, "additions": 183, "deletions": 46}, "files": [{"sha": "4d655c85951ce287880683b4497815c717de08cd", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93461afffc04e475bcbb74a20ea4da84c9f5b80d/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/93461afffc04e475bcbb74a20ea4da84c9f5b80d/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=93461afffc04e475bcbb74a20ea4da84c9f5b80d", "patch": "@@ -10,7 +10,7 @@ There are 117 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-[absurd_unsigned_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_unsigned_comparisons)     | warn    | testing whether an unsigned integer is non-positive\n+[absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)       | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n [approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                             | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                   | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)       | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`"}, {"sha": "cd9ac226321efe5787a92dabfa870f08fed31b84", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93461afffc04e475bcbb74a20ea4da84c9f5b80d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93461afffc04e475bcbb74a20ea4da84c9f5b80d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=93461afffc04e475bcbb74a20ea4da84c9f5b80d", "patch": "@@ -156,7 +156,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box print::PrintLint);\n     reg.register_late_lint_pass(box vec::UselessVec);\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n-    reg.register_late_lint_pass(box types::AbsurdUnsignedComparisons);\n+    reg.register_late_lint_pass(box types::AbsurdExtremeComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass);\n     reg.register_late_lint_pass(box copies::CopyAndPaste);\n \n@@ -271,7 +271,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         strings::STRING_LIT_AS_BYTES,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n         transmute::USELESS_TRANSMUTE,\n-        types::ABSURD_UNSIGNED_COMPARISONS,\n+        types::ABSURD_EXTREME_COMPARISONS,\n         types::BOX_VEC,\n         types::CHAR_LIT_AS_U8,\n         types::LET_UNIT_VALUE,"}, {"sha": "a48172c5980e55df87966f9aefddbd7d069f5bcf", "filename": "src/types.rs", "status": "modified", "additions": 136, "deletions": 29, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/93461afffc04e475bcbb74a20ea4da84c9f5b80d/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93461afffc04e475bcbb74a20ea4da84c9f5b80d/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=93461afffc04e475bcbb74a20ea4da84c9f5b80d", "patch": "@@ -5,6 +5,7 @@ use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::Span;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n+use rustc::middle::const_eval;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n \n use utils::*;\n@@ -579,54 +580,160 @@ impl LateLintPass for CharLitAsU8 {\n     }\n }\n \n-/// **What it does:** This lint checks for expressions where an unsigned integer is tested to be non-positive and suggests testing for equality with zero instead.\n+/// **What it does:** This lint checks for comparisons where one side of the relation is either the minimum or maximum value for its type and warns if it involves a case that is always true or always false. Only integer and boolean types are checked.\n ///\n-/// **Why is this bad?** `x <= 0` may mislead the reader into thinking `x` can be negative. `x == 0` makes explicit that zero is the only possibility.\n+/// **Why is this bad?** An expression like `min <= x` may misleadingly imply that is is possible for `x` to be less than the minimum. Expressions like `max < x` are probably mistakes.\n ///\n /// **Known problems:** None\n ///\n-/// **Example:** `vec.len() <= 0`\n+/// **Example:** `vec.len() <= 0`, `100 > std::i32::MAX`\n declare_lint! {\n-    pub ABSURD_UNSIGNED_COMPARISONS, Warn,\n-    \"testing whether an unsigned integer is non-positive\"\n+    pub ABSURD_EXTREME_COMPARISONS, Warn,\n+    \"a comparison involving a maximum or minimum value involves a case that is always \\\n+    true or always false\"\n }\n \n-pub struct AbsurdUnsignedComparisons;\n+pub struct AbsurdExtremeComparisons;\n \n-impl LintPass for AbsurdUnsignedComparisons {\n+impl LintPass for AbsurdExtremeComparisons {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ABSURD_UNSIGNED_COMPARISONS)\n+        lint_array!(ABSURD_EXTREME_COMPARISONS)\n     }\n }\n \n-fn is_zero_lit(expr: &Expr) -> bool {\n-    use syntax::ast::Lit_;\n+enum ExtremeType {\n+    Minimum,\n+    Maximum,\n+}\n+\n+struct ExtremeExpr<'a> {\n+    which: ExtremeType,\n+    expr: &'a Expr,\n+}\n+\n+enum AbsurdComparisonResult {\n+    AlwaysFalse,\n+    AlwaysTrue,\n+    InequalityImpossible,\n+}\n+\n+fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n+                            -> Option<(ExtremeExpr<'a>, AbsurdComparisonResult)> {\n+    use types::ExtremeType::*;\n+    use types::AbsurdComparisonResult::*;\n+    type Extr<'a> = ExtremeExpr<'a>;\n+\n+    // Put the expression in the form lhs < rhs or lhs <= rhs.\n+    enum Rel { Lt, Le };\n+    let (rel, lhs2, rhs2) = match op {\n+        BiLt => (Rel::Lt, lhs, rhs),\n+        BiLe => (Rel::Le, lhs, rhs),\n+        BiGt => (Rel::Lt, rhs, lhs),\n+        BiGe => (Rel::Le, rhs, lhs),\n+        _ => return None,\n+    };\n \n-    if let ExprLit(ref l) = expr.node {\n-        if let Lit_::LitInt(val, _) = l.node {\n-            return val == 0;\n+    let lx = detect_extreme_expr(cx, lhs2);\n+    let rx = detect_extreme_expr(cx, rhs2);\n+\n+    Some(match rel {\n+        Rel::Lt => {\n+            match (lx, rx) {\n+                (Some(l @ Extr { which: Maximum, ..}), _) => (l, AlwaysFalse), // max < x\n+                (_, Some(r @ Extr { which: Minimum, ..})) => (r, AlwaysFalse), // x < min\n+                _ => return None,\n+            }\n         }\n-    }\n-    false\n+        Rel::Le => {\n+            match (lx, rx) {\n+                (Some(l @ Extr { which: Minimum, ..}), _) => (l, AlwaysTrue), // min <= x\n+                (Some(l @ Extr { which: Maximum, ..}), _) => (l, InequalityImpossible), //max <= x\n+                (_, Some(r @ Extr { which: Minimum, ..})) => (r, InequalityImpossible), // x <= min\n+                (_, Some(r @ Extr { which: Maximum, ..})) => (r, AlwaysTrue), // x <= max\n+                _ => return None,\n+            }\n+        }\n+    })\n }\n \n-impl LateLintPass for AbsurdUnsignedComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n-            let op = cmp.node;\n+fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeExpr<'a>> {\n+    use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+    use types::ExtremeType::*;\n+    use rustc::middle::const_eval::ConstVal::*;\n \n-            let comparee = match op {\n-                BiLe if is_zero_lit(rhs) => lhs, // x <= 0\n-                BiGe if is_zero_lit(lhs) => rhs, // 0 >= x\n-                _ => return,\n-            };\n+    let ty = &cx.tcx.expr_ty(expr).sty;\n \n-            if let ty::TyUint(_) = cx.tcx.expr_ty(comparee).sty {\n+    match *ty {\n+        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n+        _ => return None,\n+    };\n+\n+    let cv = match const_eval::eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n+        Ok(val) => val,\n+        Err(_) => return None,\n+    };\n+\n+    let which = match (ty, cv) {\n+        (&ty::TyBool, Bool(false)) => Minimum,\n+\n+        (&ty::TyInt(IntTy::TyIs), Int(x)) if x == ::std::isize::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::TyI8), Int(x)) if x == ::std::i8::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::TyI16), Int(x)) if x == ::std::i16::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::TyI32), Int(x)) if x == ::std::i32::MIN as i64 => Minimum,\n+        (&ty::TyInt(IntTy::TyI64), Int(x)) if x == ::std::i64::MIN as i64 => Minimum,\n+\n+        (&ty::TyUint(UintTy::TyUs), Uint(x)) if x == ::std::usize::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::TyU8), Uint(x)) if x == ::std::u8::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::TyU16), Uint(x)) if x == ::std::u16::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::TyU32), Uint(x)) if x == ::std::u32::MIN as u64 => Minimum,\n+        (&ty::TyUint(UintTy::TyU64), Uint(x)) if x == ::std::u64::MIN as u64 => Minimum,\n+\n+        (&ty::TyBool, Bool(true)) => Maximum,\n+\n+        (&ty::TyInt(IntTy::TyIs), Int(x)) if x == ::std::isize::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::TyI8), Int(x)) if x == ::std::i8::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::TyI16), Int(x)) if x == ::std::i16::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::TyI32), Int(x)) if x == ::std::i32::MAX as i64 => Maximum,\n+        (&ty::TyInt(IntTy::TyI64), Int(x)) if x == ::std::i64::MAX as i64 => Maximum,\n+\n+        (&ty::TyUint(UintTy::TyUs), Uint(x)) if x == ::std::usize::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::TyU8), Uint(x)) if x == ::std::u8::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::TyU16), Uint(x)) if x == ::std::u16::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::TyU32), Uint(x)) if x == ::std::u32::MAX as u64 => Maximum,\n+        (&ty::TyUint(UintTy::TyU64), Uint(x)) if x == ::std::u64::MAX as u64 => Maximum,\n+\n+        _ => return None,\n+    };\n+    Some(ExtremeExpr { which: which, expr: expr })\n+}\n+\n+impl LateLintPass for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        use types::ExtremeType::*;\n+        use types::AbsurdComparisonResult::*;\n+\n+        if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n+            if let Some((culprit, result)) = detect_absurd_comparison(cx, cmp.node, lhs, rhs) {\n                 if !in_macro(cx, expr.span) {\n-                    let msg = \"testing whether an unsigned integer is non-positive\";\n-                    let help = format!(\"consider using {} == 0 instead\",\n-                                       snippet(cx, comparee.span, \"x\"));\n-                    span_help_and_lint(cx, ABSURD_UNSIGNED_COMPARISONS, expr.span, msg, &help);\n+                    let msg = \"this comparison involving the minimum or maximum element for this \\\n+                               type contains a case that is always true or always false\";\n+\n+                    let conclusion = match result {\n+                        AlwaysFalse => \"this comparison is always false\".to_owned(),\n+                        AlwaysTrue => \"this comparison is always true\".to_owned(),\n+                        InequalityImpossible =>\n+                            format!(\"the case where the two sides are not equal never occurs, \\\n+                                     consider using {} == {} instead\",\n+                                    snippet(cx, lhs.span, \"lhs\"),\n+                                    snippet(cx, rhs.span, \"rhs\")),\n+                    };\n+\n+                    let help = format!(\"because {} is the {} value for this type, {}\",\n+                                       snippet(cx, culprit.expr.span, \"x\"),\n+                                       match culprit.which { Minimum => \"minimum\", Maximum => \"maximum\" },\n+                                       conclusion);\n+\n+                    span_help_and_lint(cx, ABSURD_EXTREME_COMPARISONS, expr.span, msg, &help);\n                 }\n             }\n         }"}, {"sha": "9718225d20314b9db204a0a3887b0fe9b2870109", "filename": "tests/compile-fail/absurd-extreme-comparisons.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/93461afffc04e475bcbb74a20ea4da84c9f5b80d/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93461afffc04e475bcbb74a20ea4da84c9f5b80d/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fabsurd-extreme-comparisons.rs?ref=93461afffc04e475bcbb74a20ea4da84c9f5b80d", "patch": "@@ -0,0 +1,44 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(absurd_extreme_comparisons)]\n+#![allow(unused, eq_op)]\n+fn main() {\n+    const Z: u32 = 0;\n+\n+    let u: u32 = 42;\n+\n+    u <= 0; //~ERROR this comparison involving the minimum or maximum element for this type contains a case that is always true or always false\n+    u <= Z; //~ERROR this comparison involving\n+    u < Z; //~ERROR this comparison involving\n+    Z >= u; //~ERROR this comparison involving\n+    Z > u; //~ERROR this comparison involving\n+    u > std::u32::MAX; //~ERROR this comparison involving\n+    u >= std::u32::MAX; //~ERROR this comparison involving\n+    std::u32::MAX < u; //~ERROR this comparison involving\n+    std::u32::MAX <= u; //~ERROR this comparison involving\n+\n+    1-1 > u;\n+        //~^ ERROR this comparison involving\n+        //~| HELP because 1-1 is the minimum value for this type, this comparison is always false\n+    u >= !0;\n+        //~^ ERROR this comparison involving\n+        //~| HELP because !0 is the maximum value for this type, the case where the two sides are not equal never occurs, consider using u == !0 instead\n+    u <= 12 - 2*6;\n+        //~^ ERROR this comparison involving\n+        //~| HELP because 12 - 2*6 is the minimum value for this type, the case where the two sides are not equal never occurs, consider using u == 12 - 2*6 instead\n+\n+    let i: i8 = 0;\n+    i < -127 - 1; //~ERROR this comparison involving\n+    std::i8::MAX >= i; //~ERROR this comparison involving\n+    3-7 < std::i32::MIN; //~ERROR this comparison involving\n+\n+    let b = false;\n+    b >= true; //~ERROR this comparison involving\n+    false > b; //~ERROR this comparison involving\n+\n+    u > 0; // ok\n+\n+    // this is handled by unit_cmp\n+    () < {}; //~WARNING <-comparison of unit values detected.\n+}"}, {"sha": "d7817daf20410fb426f971ce2e4d4cfac740f6a8", "filename": "tests/compile-fail/absurd_unsigned_comparisons.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c886f1e752558e95d086deff4c1ccc61924873d/tests%2Fcompile-fail%2Fabsurd_unsigned_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c886f1e752558e95d086deff4c1ccc61924873d/tests%2Fcompile-fail%2Fabsurd_unsigned_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fabsurd_unsigned_comparisons.rs?ref=8c886f1e752558e95d086deff4c1ccc61924873d", "patch": "@@ -1,14 +0,0 @@\n-#![feature(plugin)]\n-#![plugin(clippy)]\n-\n-#![allow(unused)]\n-\n-#[deny(absurd_unsigned_comparisons)]\n-fn main() {\n-    1u32 <= 0; //~ERROR testing whether an unsigned integer is non-positive\n-    1u8 <= 0; //~ERROR testing whether an unsigned integer is non-positive\n-    1i32 <= 0;\n-    0 >= 1u32; //~ERROR testing whether an unsigned integer is non-positive\n-    0 >= 1;\n-    1u32 > 0;\n-}"}]}