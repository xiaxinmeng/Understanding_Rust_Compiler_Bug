{"sha": "0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMTUyMWU2ZDNlZDc1NmYzYjIwMjQyOTFlZGJlMGM5ZTc0Y2IwOGM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T16:51:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T16:43:55Z"}, "message": "Make rustc::traits::error_reporting::{recursive_type_with_infinite_size_error, report_object_safety_error} free functions.", "tree": {"sha": "cff8509ebb44e8819ee597197465b07057a9d24c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cff8509ebb44e8819ee597197465b07057a9d24c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "html_url": "https://github.com/rust-lang/rust/commit/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d53bf7a67657fc585e13d14cf5023b5ebdf81021", "url": "https://api.github.com/repos/rust-lang/rust/commits/d53bf7a67657fc585e13d14cf5023b5ebdf81021", "html_url": "https://github.com/rust-lang/rust/commit/d53bf7a67657fc585e13d14cf5023b5ebdf81021"}], "stats": {"total": 121, "additions": 62, "deletions": 59}, "files": [{"sha": "1d1135ef2ed25372d9d2eb83d1259765d06d4200", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "patch": "@@ -53,6 +53,7 @@ use crate::hir::map;\n use crate::infer::opaque_types;\n use crate::infer::{self, SuppressRegionErrors};\n use crate::middle::region;\n+use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n };\n@@ -1487,7 +1488,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let mut diag = match failure_code {\n             FailureCode::Error0038(did) => {\n                 let violations = self.tcx.object_safety_violations(did);\n-                self.tcx.report_object_safety_error(span, did, violations)\n+                report_object_safety_error(self.tcx, span, did, violations)\n             }\n             FailureCode::Error0317(failure_str) => {\n                 struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)"}, {"sha": "7fa5a495621ddafc8316cfffc993b8ff03642b17", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 53, "deletions": 55, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "patch": "@@ -916,7 +916,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        self.tcx.report_object_safety_error(span, trait_def_id, violations)\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n                     ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n@@ -1080,7 +1080,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             TraitNotObjectSafe(did) => {\n                 let violations = self.tcx.object_safety_violations(did);\n-                self.tcx.report_object_safety_error(span, did, violations)\n+                report_object_safety_error(self.tcx, span, did, violations)\n             }\n \n             // already reported in the query\n@@ -1945,64 +1945,62 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn recursive_type_with_infinite_size_error(\n-        self,\n-        type_def_id: DefId,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        assert!(type_def_id.is_local());\n-        let span = self.hir().span_if_local(type_def_id).unwrap();\n-        let span = self.sess.source_map().def_span(span);\n-        let mut err = struct_span_err!(\n-            self.sess,\n-            span,\n-            E0072,\n-            \"recursive type `{}` has infinite size\",\n-            self.def_path_str(type_def_id)\n-        );\n-        err.span_label(span, \"recursive type has infinite size\");\n-        err.help(&format!(\n-            \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n                            at some point to make `{}` representable\",\n-            self.def_path_str(type_def_id)\n-        ));\n-        err\n-    }\n-\n-    pub fn report_object_safety_error(\n-        self,\n-        span: Span,\n-        trait_def_id: DefId,\n-        violations: Vec<ObjectSafetyViolation>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let trait_str = self.def_path_str(trait_def_id);\n-        let span = self.sess.source_map().def_span(span);\n-        let mut err = struct_span_err!(\n-            self.sess,\n-            span,\n-            E0038,\n-            \"the trait `{}` cannot be made into an object\",\n-            trait_str\n-        );\n-        err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n-\n-        let mut reported_violations = FxHashSet::default();\n-        for violation in violations {\n-            if reported_violations.insert(violation.clone()) {\n-                match violation.span() {\n-                    Some(span) => err.span_label(span, violation.error_msg()),\n-                    None => err.note(&violation.error_msg()),\n-                };\n-            }\n-        }\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n \n-        if self.sess.trait_methods_not_found.borrow().contains(&span) {\n-            // Avoid emitting error caused by non-existing method (#58734)\n-            err.cancel();\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n         }\n+    }\n \n-        err\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n     }\n+\n+    err\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "a7da2df9fb79216babea2e1ad813d242c61d20f0", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "patch": "@@ -13,6 +13,7 @@ use errors::{Applicability, DiagnosticId};\n use rustc::hir::intravisit::Visitor;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n+use rustc::traits::error_reporting::report_object_safety_error;\n use rustc::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc::ty::wf::object_region_bounds;\n use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -1454,7 +1455,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let object_safety_violations =\n                 tcx.astconv_object_safety_violations(item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n-                tcx.report_object_safety_error(\n+                report_object_safety_error(\n+                    tcx,\n                     span,\n                     item.trait_ref().def_id(),\n                     object_safety_violations,"}, {"sha": "1a4aa089549e5181f9dfecc3de37f1eeea9d2551", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "patch": "@@ -37,6 +37,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::traits;\n+use rustc::traits::error_reporting::report_object_safety_error;\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::error::TypeError;\n@@ -519,7 +520,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n     fn report_object_unsafe_cast(&self, fcx: &FnCtxt<'a, 'tcx>, did: DefId) {\n         let violations = fcx.tcx.object_safety_violations(did);\n-        let mut err = fcx.tcx.report_object_safety_error(self.cast_span, did, violations);\n+        let mut err = report_object_safety_error(fcx.tcx, self.cast_span, did, violations);\n         err.note(&format!(\"required by cast to type '{}'\", fcx.ty_to_string(self.cast_ty)));\n         err.emit();\n     }"}, {"sha": "430513ba803ccea478d65105624d3107df106818", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b1521e6d3ed756f3b2024291edbe0c9e74cb08c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0b1521e6d3ed756f3b2024291edbe0c9e74cb08c", "patch": "@@ -100,6 +100,7 @@ use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n use rustc::middle::region;\n use rustc::mir::interpret::ConstValue;\n+use rustc::traits::error_reporting::recursive_type_with_infinite_size_error;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -2222,7 +2223,7 @@ fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: DefId) -> bool {\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive(spans) => {\n-            let mut err = tcx.recursive_type_with_infinite_size_error(item_def_id);\n+            let mut err = recursive_type_with_infinite_size_error(tcx, item_def_id);\n             for span in spans {\n                 err.span_label(span, \"recursive without indirection\");\n             }"}]}