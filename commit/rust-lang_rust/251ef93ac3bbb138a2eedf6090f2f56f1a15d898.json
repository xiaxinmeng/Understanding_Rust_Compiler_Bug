{"sha": "251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MWVmOTNhYzNiYmIxMzhhMmVlZGY2MDkwZjJmNTZmMWExNWQ4OTg=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2020-09-10T12:01:23Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2020-09-10T12:01:23Z"}, "message": "Implement async blocks", "tree": {"sha": "1a03960dfb5edfe5bca78c57610b3e52ec2dc74d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a03960dfb5edfe5bca78c57610b3e52ec2dc74d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl9aFZMACgkQztOS3gxI\nPQCvPA//RVsyrj2F0z0YYUMgIdun5NkDhLCtpjEB3lUkupDghTxTCiAhvqEjHXEC\n2L2oPrE1q5OkFFffznxQS6maaCeuisDpLgT5tpaYQRj8t7f9p5Lt7K/h4SrR+aBA\naR068Ox6yf07ed5fOmZkTnyphRQoNINviJHdNkhXIUwypeGOoBYoJSICZi7y9f5H\nldVP/dPp72105dSOi3031YEGyue6HxOtfnM4MuC2nqr3G57Dy7cYxxiXeh18MWik\nAD88zYc+dSjfAFCvGf1lqktqSa6yN0z5dw+QNlOt45ZAQAXZZQwn1jhNp0K8M3Q4\nqSEpmC7smxih1BWcuZVrcDSgju7Nzp30NcZadIa3fBL3uwp9AUXUYfG+st3MIlZm\nzUZqHN5HgfJDVuex2Q/ON2Hm0m0TDC0nx1TSKVAzG3+eSSQq94z3AweIhW/U6fue\n3r2vf6pxCsgleOSLMPOKnj+2kT98bIZ8KDt08ZHkxYTXesPW4RpT8xmhw2L33fda\nYmr+yqupgv1U/p96UpHlRVzxAOmXcc6q5jHQ0diIAt4BzhC0w5+UC2U7lDJDEo9k\n+MtZ2K5QVMtnXSYfOAB+J1Z/DP792TfDCsr9e/UrEBw2m3ARxLMNhTSTkdk5g93e\nyLajnSsa1RDJ5eCiT0fWLJCjX15VxNDHU+WFPex7/K87kMyKA+o=\n=2zKj\n-----END PGP SIGNATURE-----", "payload": "tree 1a03960dfb5edfe5bca78c57610b3e52ec2dc74d\nparent 0275b08d1521606fa733f76fe5d5707717456fb4\nauthor oxalica <oxalicc@pm.me> 1599739283 +0800\ncommitter oxalica <oxalicc@pm.me> 1599739283 +0800\n\nImplement async blocks\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "html_url": "https://github.com/rust-lang/rust/commit/251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0275b08d1521606fa733f76fe5d5707717456fb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0275b08d1521606fa733f76fe5d5707717456fb4", "html_url": "https://github.com/rust-lang/rust/commit/0275b08d1521606fa733f76fe5d5707717456fb4"}], "stats": {"total": 303, "additions": 248, "deletions": 55}, "files": [{"sha": "613b35afd86e968bb031e4f132b7195f01b3e19a", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -1283,6 +1283,8 @@ impl Type {\n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_future(&self, db: &dyn HirDatabase) -> bool {\n+        // No special case for the type of async block, since Chalk can figure it out.\n+\n         let krate = self.krate;\n \n         let std_future_trait ="}, {"sha": "c5ebc2aa063a06652eb5e4d2bf4a00d8806093b1", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -239,7 +239,10 @@ impl ExprCollector<'_> {\n                     None => self.missing_expr(),\n                 },\n                 // FIXME: we need to record these effects somewhere...\n-                ast::Effect::Async(_) => self.collect_block_opt(e.block_expr()),\n+                ast::Effect::Async(_) => {\n+                    let body = self.collect_block_opt(e.block_expr());\n+                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n+                }\n             },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {"}, {"sha": "e862c2080041f04b80ba9027453712742780c237", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -111,6 +111,9 @@ pub enum Expr {\n     TryBlock {\n         body: ExprId,\n     },\n+    Async {\n+        body: ExprId,\n+    },\n     Cast {\n         expr: ExprId,\n         type_ref: TypeRef,\n@@ -250,7 +253,7 @@ impl Expr {\n                     f(*expr);\n                 }\n             }\n-            Expr::TryBlock { body } | Expr::Unsafe { body } => f(*body),\n+            Expr::TryBlock { body } | Expr::Unsafe { body } | Expr::Async { body } => f(*body),\n             Expr::Loop { body, .. } => f(*body),\n             Expr::While { condition, body, .. } => {\n                 f(*condition);"}, {"sha": "efb48c7ee4bdece7ef7994793cac12db890f323c", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -381,19 +381,24 @@ impl HirDisplay for ApplicationTy {\n                 }\n             }\n             TypeCtor::OpaqueType(opaque_ty_id) => {\n-                let bounds = match opaque_ty_id {\n+                match opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.subst(&self.parameters)\n+                        let bounds = data.subst(&self.parameters);\n+                        write!(f, \"impl \")?;\n+                        write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                        // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n                     }\n-                };\n-                write!(f, \"impl \")?;\n-                write_bounds_like_dyn_trait(&bounds.value, f)?;\n-                // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                        write!(f, \"impl Future<Output = \")?;\n+                        self.parameters[0].hir_fmt(f)?;\n+                        write!(f, \">\")?;\n+                    }\n+                }\n             }\n             TypeCtor::Closure { .. } => {\n                 let sig = self.parameters[0].callable_sig(f.db);\n@@ -474,18 +479,21 @@ impl HirDisplay for Ty {\n                 write_bounds_like_dyn_trait(predicates, f)?;\n             }\n             Ty::Opaque(opaque_ty) => {\n-                let bounds = match opaque_ty.opaque_ty_id {\n+                match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n                             f.db.return_type_impl_traits(func).expect(\"impl trait id without data\");\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        data.subst(&opaque_ty.parameters)\n+                        let bounds = data.subst(&opaque_ty.parameters);\n+                        write!(f, \"impl \")?;\n+                        write_bounds_like_dyn_trait(&bounds.value, f)?;\n+                    }\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                        write!(f, \"{{async block}}\")?;\n                     }\n                 };\n-                write!(f, \"impl \")?;\n-                write_bounds_like_dyn_trait(&bounds.value, f)?;\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,"}, {"sha": "0a141b9cb947276183f348d5d8663d99f3dad9c0", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -17,8 +17,8 @@ use crate::{\n     autoderef, method_resolution, op,\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, Rawness, Substs,\n-    TraitRef, Ty, TypeCtor,\n+    ApplicationTy, Binders, CallableDefId, InferTy, IntTy, Mutability, Obligation, OpaqueTyId,\n+    Rawness, Substs, TraitRef, Ty, TypeCtor,\n };\n \n use super::{\n@@ -146,6 +146,13 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME should be std::result::Result<{inner}, _>\n                 Ty::Unknown\n             }\n+            Expr::Async { body } => {\n+                // Use the first type parameter as the output type of future.\n+                // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n+                let inner_ty = self.infer_expr(*body, &Expectation::none());\n+                let opaque_ty_id = OpaqueTyId::AsyncBlockTypeImplTrait(self.owner, *body);\n+                Ty::apply_one(TypeCtor::OpaqueType(opaque_ty_id), inner_ty)\n+            }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,"}, {"sha": "4a7d3a0d9d59366a9c565f32be6186a7c5627861", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -33,6 +33,7 @@ use hir_def::{\n     AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n     TypeParamId,\n };\n+use hir_expand::name::name;\n use itertools::Itertools;\n \n use crate::{\n@@ -129,8 +130,9 @@ pub enum TypeCtor {\n \n     /// This represents a placeholder for an opaque type in situations where we\n     /// don't know the hidden type (i.e. currently almost always). This is\n-    /// analogous to the `AssociatedType` type constructor. As with that one,\n-    /// these are only produced by Chalk.\n+    /// analogous to the `AssociatedType` type constructor.\n+    /// It is also used as the type of async block, with one type parameter\n+    /// representing the Future::Output type.\n     OpaqueType(OpaqueTyId),\n \n     /// The type of a specific closure.\n@@ -173,6 +175,8 @@ impl TypeCtor {\n                         let generic_params = generics(db.upcast(), func.into());\n                         generic_params.len()\n                     }\n+                    // 1 param representing Future::Output type.\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => 1,\n                 }\n             }\n             TypeCtor::FnPtr { num_args, is_varargs: _ } => num_args as usize + 1,\n@@ -205,6 +209,7 @@ impl TypeCtor {\n                 OpaqueTyId::ReturnTypeImplTrait(func, _) => {\n                     Some(func.lookup(db.upcast()).module(db.upcast()).krate)\n                 }\n+                OpaqueTyId::AsyncBlockTypeImplTrait(def, _) => Some(def.module(db.upcast()).krate),\n             },\n         }\n     }\n@@ -843,6 +848,33 @@ impl Ty {\n \n     pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<GenericPredicate>> {\n         match self {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::OpaqueType(opaque_ty_id), parameters }) => {\n+                match opaque_ty_id {\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(def, _expr) => {\n+                        let krate = def.module(db.upcast()).krate;\n+                        if let Some(future_output) = db\n+                            .lang_item(krate, \"future_trait\".into())\n+                            .and_then(|item| item.as_trait())\n+                            .and_then(|trait_| {\n+                                db.trait_data(trait_).associated_type_by_name(&name![Output])\n+                            })\n+                        {\n+                            let proj = GenericPredicate::Projection(ProjectionPredicate {\n+                                projection_ty: ProjectionTy {\n+                                    associated_ty: future_output,\n+                                    // Self type.\n+                                    parameters: Substs::single(self.clone()),\n+                                },\n+                                ty: parameters[0].clone(),\n+                            });\n+                            Some(vec![proj])\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    OpaqueTyId::ReturnTypeImplTrait(..) => None,\n+                }\n+            }\n             Ty::Opaque(opaque_ty) => {\n                 let predicates = match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n@@ -853,6 +885,8 @@ impl Ty {\n                             data.subst(&opaque_ty.parameters)\n                         })\n                     }\n+                    // It always has an parameter for Future::Output type.\n+                    OpaqueTyId::AsyncBlockTypeImplTrait(..) => unreachable!(),\n                 };\n \n                 predicates.map(|it| it.value)\n@@ -1065,6 +1099,7 @@ impl<T: TypeWalk> TypeWalk for Vec<T> {\n #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n pub enum OpaqueTyId {\n     ReturnTypeImplTrait(hir_def::FunctionId, u16),\n+    AsyncBlockTypeImplTrait(hir_def::DefWithBodyId, ExprId),\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "5b07948f3da5bf6b70befe7874d5b4944c50d7f3", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -1889,31 +1889,40 @@ fn fn_pointer_return() {\n fn effects_smoke_test() {\n     check_infer(\n         r#\"\n-        fn main() {\n+        async fn main() {\n             let x = unsafe { 92 };\n             let y = async { async { () }.await };\n             let z = try { () };\n             let t = 'a: { 92 };\n         }\n+\n+        #[prelude_import] use future::*;\n+\n+        mod future {\n+            #[lang = \"future_trait\"]\n+            pub trait Future { type Output; }\n+        }\n         \"#,\n         expect![[r#\"\n-            10..130 '{     ...2 }; }': ()\n-            20..21 'x': i32\n-            24..37 'unsafe { 92 }': i32\n-            31..37 '{ 92 }': i32\n-            33..35 '92': i32\n-            47..48 'y': {unknown}\n-            57..79 '{ asyn...wait }': {unknown}\n-            59..77 'async ....await': {unknown}\n-            65..71 '{ () }': ()\n-            67..69 '()': ()\n-            89..90 'z': {unknown}\n-            93..103 'try { () }': {unknown}\n-            97..103 '{ () }': ()\n-            99..101 '()': ()\n-            113..114 't': i32\n-            121..127 '{ 92 }': i32\n-            123..125 '92': i32\n+            16..136 '{     ...2 }; }': ()\n+            26..27 'x': i32\n+            30..43 'unsafe { 92 }': i32\n+            37..43 '{ 92 }': i32\n+            39..41 '92': i32\n+            53..54 'y': impl Future<Output = ()>\n+            57..85 'async ...wait }': impl Future<Output = ()>\n+            63..85 '{ asyn...wait }': ()\n+            65..77 'async { () }': impl Future<Output = ()>\n+            65..83 'async ....await': ()\n+            71..77 '{ () }': ()\n+            73..75 '()': ()\n+            95..96 'z': {unknown}\n+            99..109 'try { () }': {unknown}\n+            103..109 '{ () }': ()\n+            105..107 '()': ()\n+            119..120 't': i32\n+            127..133 '{ 92 }': i32\n+            129..131 '92': i32\n         \"#]],\n     )\n }"}, {"sha": "41d0975197beb5c7c6d09b09e0326ed4e20150ae", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -85,6 +85,46 @@ mod future {\n     );\n }\n \n+#[test]\n+fn infer_async_block() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:core\n+async fn test() {\n+    let a = async { 42 };\n+    a;\n+//  ^ impl Future<Output = i32>\n+    let x = a.await;\n+    x;\n+//  ^ i32\n+    let b = async {}.await;\n+    b;\n+//  ^ ()\n+    let c = async {\n+        let y = Option::None;\n+        y\n+    //  ^ Option<u64>\n+    };\n+    let _: Option<u64> = c.await;\n+    c;\n+//  ^ impl Future<Output = Option<u64>>\n+}\n+\n+enum Option<T> { None, Some(T) }\n+\n+//- /core.rs crate:core\n+#[prelude_import] use future::*;\n+mod future {\n+    #[lang = \"future_trait\"]\n+    trait Future {\n+        type Output;\n+    }\n+}\n+\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_try() {\n     check_types("}, {"sha": "25e8ac1868ae22a064dbd748aa965865107a2ae4", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -11,14 +11,16 @@ use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n     AssocContainerId, AssocItemId, HasModule, Lookup, TypeAliasId,\n };\n+use hir_expand::name::name;\n \n use super::ChalkContext;\n use crate::{\n     db::HirDatabase,\n     display::HirDisplay,\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     utils::generics,\n-    CallableDefId, DebruijnIndex, FnSig, GenericPredicate, Substs, Ty, TypeCtor,\n+    BoundVar, CallableDefId, DebruijnIndex, FnSig, GenericPredicate, ProjectionPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsValue,\n@@ -166,27 +168,86 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     fn opaque_ty_data(&self, id: chalk_ir::OpaqueTyId<Interner>) -> Arc<OpaqueTyDatum> {\n         let interned_id = crate::db::InternedOpaqueTyId::from(id);\n         let full_id = self.db.lookup_intern_impl_trait_id(interned_id);\n-        let (func, idx) = match full_id {\n-            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => (func, idx),\n-        };\n-        let datas =\n-            self.db.return_type_impl_traits(func).expect(\"impl trait id without impl traits\");\n-        let data = &datas.value.impl_traits[idx as usize];\n-        let bound = OpaqueTyDatumBound {\n-            bounds: make_binders(\n-                data.bounds\n-                    .value\n-                    .iter()\n-                    .cloned()\n-                    .filter(|b| !b.is_error())\n-                    .map(|b| b.to_chalk(self.db))\n-                    .collect(),\n-                1,\n-            ),\n-            where_clauses: make_binders(vec![], 0),\n+        let bound = match full_id {\n+            crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n+                let datas = self\n+                    .db\n+                    .return_type_impl_traits(func)\n+                    .expect(\"impl trait id without impl traits\");\n+                let data = &datas.value.impl_traits[idx as usize];\n+                let bound = OpaqueTyDatumBound {\n+                    bounds: make_binders(\n+                        data.bounds\n+                            .value\n+                            .iter()\n+                            .cloned()\n+                            .filter(|b| !b.is_error())\n+                            .map(|b| b.to_chalk(self.db))\n+                            .collect(),\n+                        1,\n+                    ),\n+                    where_clauses: make_binders(vec![], 0),\n+                };\n+                let num_vars = datas.num_binders;\n+                make_binders(bound, num_vars)\n+            }\n+            crate::OpaqueTyId::AsyncBlockTypeImplTrait(..) => {\n+                if let Some((future_trait, future_output)) = self\n+                    .db\n+                    .lang_item(self.krate, \"future_trait\".into())\n+                    .and_then(|item| item.as_trait())\n+                    .and_then(|trait_| {\n+                        let alias =\n+                            self.db.trait_data(trait_).associated_type_by_name(&name![Output])?;\n+                        Some((trait_, alias))\n+                    })\n+                {\n+                    // AsyncBlock<T>: Future</* Self */>\n+                    // This is required by `fn impls_future` to check if we need to provide `.await` completion.\n+                    let impl_bound = GenericPredicate::Implemented(TraitRef {\n+                        trait_: future_trait,\n+                        // Self type as the first parameter.\n+                        substs: Substs::single(Ty::Bound(BoundVar {\n+                            debruijn: DebruijnIndex::INNERMOST,\n+                            index: 0,\n+                        })),\n+                    });\n+                    // AsyncBlock<T>: Future</* Self, */ Output = T>;\n+                    // debruijn:  ^1  ^0\n+                    let proj_bound = GenericPredicate::Projection(ProjectionPredicate {\n+                        // The parameter of the opaque type.\n+                        ty: Ty::Bound(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 }),\n+                        projection_ty: ProjectionTy {\n+                            associated_ty: future_output,\n+                            // Self type as the first parameter.\n+                            parameters: Substs::single(Ty::Bound(BoundVar::new(\n+                                DebruijnIndex::INNERMOST,\n+                                0,\n+                            ))),\n+                        },\n+                    });\n+                    let bound = OpaqueTyDatumBound {\n+                        bounds: make_binders(\n+                            vec![impl_bound.to_chalk(self.db), proj_bound.to_chalk(self.db)],\n+                            1,\n+                        ),\n+                        where_clauses: make_binders(vec![], 0),\n+                    };\n+                    // The opaque type has 1 parameter.\n+                    make_binders(bound, 1)\n+                } else {\n+                    // If failed to find `Future::Output`, return empty bounds as fallback.\n+                    let bound = OpaqueTyDatumBound {\n+                        bounds: make_binders(vec![], 0),\n+                        where_clauses: make_binders(vec![], 0),\n+                    };\n+                    // The opaque type has 1 parameter.\n+                    make_binders(bound, 1)\n+                }\n+            }\n         };\n-        let num_vars = datas.num_binders;\n-        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound: make_binders(bound, num_vars) })\n+\n+        Arc::new(OpaqueTyDatum { opaque_ty_id: id, bound })\n     }\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {"}, {"sha": "cb6b0fe81fdeacc2eb4c0dc434aeb01a3914ba2c", "filename": "crates/hir_ty/src/traits/chalk/tls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -73,6 +73,9 @@ impl DebugContext<'_> {\n                 crate::OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                     write!(f, \"{{impl trait {} of {:?}}}\", idx, func)?;\n                 }\n+                crate::OpaqueTyId::AsyncBlockTypeImplTrait(def, idx) => {\n+                    write!(f, \"{{impl trait of async block {} of {:?}}}\", idx.into_raw(), def)?;\n+                }\n             },\n             TypeCtor::Closure { def, expr } => {\n                 write!(f, \"{{closure {:?} in \", expr.into_raw())?;"}, {"sha": "5645b41fa485c35e62949626c79b54e1cfa2741e", "filename": "crates/ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/251ef93ac3bbb138a2eedf6090f2f56f1a15d898/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=251ef93ac3bbb138a2eedf6090f2f56f1a15d898", "patch": "@@ -506,6 +506,28 @@ pub mod future {\n     #[lang = \"future_trait\"]\n     pub trait Future {}\n }\n+\"#,\n+            expect![[r#\"\n+                kw await expr.await\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+//- /main.rs\n+use std::future::*;\n+fn foo() {\n+    let a = async {};\n+    a.<|>\n+}\n+\n+//- /std/lib.rs\n+pub mod future {\n+    #[lang = \"future_trait\"]\n+    pub trait Future {\n+        type Output;\n+    }\n+}\n \"#,\n             expect![[r#\"\n                 kw await expr.await"}]}