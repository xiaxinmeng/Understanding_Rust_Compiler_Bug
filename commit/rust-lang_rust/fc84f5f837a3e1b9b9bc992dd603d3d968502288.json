{"sha": "fc84f5f837a3e1b9b9bc992dd603d3d968502288", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjODRmNWY4MzdhM2UxYjliOWJjOTkyZGQ2MDNkM2Q5Njg1MDIyODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T08:46:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-07T08:46:45Z"}, "message": "Auto merge of #56581 - kennytm:rollup, r=kennytm\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #56000 (Add Armv8-M Mainline targets)\n - #56250 (Introduce ptr::hash for references)\n - #56434 (Improve query cycle errors for parallel queries)\n - #56516 (Replace usages of `..i + 1` ranges with `..=i`.)\n - #56555 (Send textual profile data to stderr, not stdout)\n - #56561 (Fix bug in from_key_hashed_nocheck)\n - #56574 (Fix a stutter in the docs for slice::exact_chunks)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9e64c02fb9f8084d26a6a743c62ac54626e549d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e64c02fb9f8084d26a6a743c62ac54626e549d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc84f5f837a3e1b9b9bc992dd603d3d968502288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc84f5f837a3e1b9b9bc992dd603d3d968502288", "html_url": "https://github.com/rust-lang/rust/commit/fc84f5f837a3e1b9b9bc992dd603d3d968502288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc84f5f837a3e1b9b9bc992dd603d3d968502288/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a2607863fded7570cacfc7825702dde5a4234c", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a2607863fded7570cacfc7825702dde5a4234c", "html_url": "https://github.com/rust-lang/rust/commit/15a2607863fded7570cacfc7825702dde5a4234c"}, {"sha": "a40aa45980f45e26a227a889a69b54bcfcd68eba", "url": "https://api.github.com/repos/rust-lang/rust/commits/a40aa45980f45e26a227a889a69b54bcfcd68eba", "html_url": "https://github.com/rust-lang/rust/commit/a40aa45980f45e26a227a889a69b54bcfcd68eba"}], "stats": {"total": 302, "additions": 225, "deletions": 77}, "files": [{"sha": "c0adeca4eb5dfd4514dacd70bfec91ff1a630610", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -2795,7 +2795,7 @@ mod tests {\n             // 0, 1, 2, .., len - 1\n             let expected = (0..).take(len).collect::<VecDeque<_>>();\n             for tail_pos in 0..cap {\n-                for to_remove in 0..len + 1 {\n+                for to_remove in 0..=len {\n                     tester.tail = tail_pos;\n                     tester.head = tail_pos;\n                     for i in 0..len {\n@@ -2821,10 +2821,10 @@ mod tests {\n         let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n \n         let cap = tester.capacity();\n-        for len in 0..cap + 1 {\n-            for tail in 0..cap + 1 {\n-                for drain_start in 0..len + 1 {\n-                    for drain_end in drain_start..len + 1 {\n+        for len in 0..=cap {\n+            for tail in 0..=cap {\n+                for drain_start in 0..=len {\n+                    for drain_end in drain_start..=len {\n                         tester.tail = tail;\n                         tester.head = tail;\n                         for i in 0..len {\n@@ -2866,10 +2866,10 @@ mod tests {\n         tester.reserve(63);\n         let max_cap = tester.capacity();\n \n-        for len in 0..cap + 1 {\n+        for len in 0..=cap {\n             // 0, 1, 2, .., len - 1\n             let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..max_cap + 1 {\n+            for tail_pos in 0..=max_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n                 tester.reserve(63);\n@@ -2899,7 +2899,7 @@ mod tests {\n         // len is the length *before* splitting\n         for len in 0..cap {\n             // index to split at\n-            for at in 0..len + 1 {\n+            for at in 0..=len {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n                 let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n                 // at, at + 1, .., len - 1 (may be empty)\n@@ -2927,7 +2927,7 @@ mod tests {\n     fn test_from_vec() {\n         use vec::Vec;\n         for cap in 0..35 {\n-            for len in 0..cap + 1 {\n+            for len in 0..=cap {\n                 let mut vec = Vec::with_capacity(cap);\n                 vec.extend(0..len);\n "}, {"sha": "b0d8fa6bd69367af27c85c76c55d1b3851bb3ccf", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -318,11 +318,11 @@ fn panic_safe() {\n     const NTEST: usize = 10;\n \n     // don't use 0 in the data -- we want to catch the zeroed-out case.\n-    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+    let data = (1..=DATASZ).collect::<Vec<_>>();\n \n     // since it's a fuzzy test, run several tries.\n     for _ in 0..NTEST {\n-        for i in 1..DATASZ + 1 {\n+        for i in 1..=DATASZ {\n             DROP_COUNTER.store(0, Ordering::SeqCst);\n \n             let mut panic_ords: Vec<_> = data.iter()"}, {"sha": "33ef13ab811ce80ee6c951375faa3c34b9007a5b", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -302,7 +302,7 @@ fn test_range() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range((Included(&i), Included(&j))).map(|(&k, &v)| (k, v));\n-            let mut pairs = (i..j + 1).map(|i| (i, i));\n+            let mut pairs = (i..=j).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);\n@@ -321,7 +321,7 @@ fn test_range_mut() {\n     for i in 0..size {\n         for j in i..size {\n             let mut kvs = map.range_mut((Included(&i), Included(&j))).map(|(&k, &mut v)| (k, v));\n-            let mut pairs = (i..j + 1).map(|i| (i, i));\n+            let mut pairs = (i..=j).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);"}, {"sha": "494b36f85417d9fdac22b6c0da9051813376bf46", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -1378,7 +1378,7 @@ fn test_bool_from_str() {\n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n     for i in 0..s.len() {\n-        for j in i+1..s.len() + 1 {\n+        for j in i+1..=s.len() {\n             assert!(s.contains(&s[i..j]));\n         }\n     }"}, {"sha": "1f2a7211c657bec100a3631295a823fe01a6d351", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -861,15 +861,15 @@ fn test_as_slices() {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_slices();\n-        let expected: Vec<_> = (0..i + 1).collect();\n+        let expected: Vec<_> = (0..=i).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_slices();\n-        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n+        let expected_left: Vec<_> = (-last..=j).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);\n@@ -889,15 +889,15 @@ fn test_as_mut_slices() {\n         ring.push_back(i);\n \n         let (left, right) = ring.as_mut_slices();\n-        let expected: Vec<_> = (0..i + 1).collect();\n+        let expected: Vec<_> = (0..=i).collect();\n         assert_eq!(left, &expected[..]);\n         assert_eq!(right, []);\n     }\n \n     for j in -last..0 {\n         ring.push_front(j);\n         let (left, right) = ring.as_mut_slices();\n-        let expected_left: Vec<_> = (-last..j + 1).rev().collect();\n+        let expected_left: Vec<_> = (-last..=j).rev().collect();\n         let expected_right: Vec<_> = (0..first).collect();\n         assert_eq!(left, &expected_left[..]);\n         assert_eq!(right, &expected_right[..]);"}, {"sha": "8630dd402ef68043a34ec9523de66007296ba3fc", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -2516,6 +2516,36 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n     a == b\n }\n \n+/// Hash the raw pointer address behind a reference, rather than the value\n+/// it points to.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(ptr_hash)]\n+/// use std::collections::hash_map::DefaultHasher;\n+/// use std::hash::{Hash, Hasher};\n+/// use std::ptr;\n+///\n+/// let five = 5;\n+/// let five_ref = &five;\n+///\n+/// let mut hasher = DefaultHasher::new();\n+/// ptr::hash(five_ref, &mut hasher);\n+/// let actual = hasher.finish();\n+///\n+/// let mut hasher = DefaultHasher::new();\n+/// (five_ref as *const i32).hash(&mut hasher);\n+/// let expected = hasher.finish();\n+///\n+/// assert_eq!(actual, expected);\n+/// ```\n+#[unstable(feature = \"ptr_hash\", reason = \"newly added\", issue = \"56286\")]\n+pub fn hash<T, S: hash::Hasher>(hashee: *const T, into: &mut S) {\n+    use hash::Hash;\n+    hashee.hash(into);\n+}\n+\n // Impls for function pointers\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {"}, {"sha": "5b57dcabb8da9de963998b055d04c5389cb213f6", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -702,8 +702,7 @@ impl<T> [T] {\n     /// resulting code better than in the case of [`chunks`].\n     ///\n     /// See [`chunks`] for a variant of this iterator that also returns the remainder as a smaller\n-    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice of\n-    /// the slice.\n+    /// chunk, and [`rchunks_exact`] for the same iterator but starting at the end of the slice.\n     ///\n     /// # Panics\n     ///"}, {"sha": "58d1a780f129c9f841823d5be6774fa36106ab23", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n         if max != self.hir_ids_seen.len() - 1 {\n             // Collect the missing ItemLocalIds\n-            let missing: Vec<_> = (0 .. max as u32 + 1)\n+            let missing: Vec<_> = (0 ..= max as u32)\n               .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId::from_u32(i)))\n               .collect();\n "}, {"sha": "7259bbfb780bfe47b0368db6dabc235147565e37", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -339,7 +339,7 @@ impl<'tcx> Mir<'tcx> {\n     #[inline]\n     pub fn args_iter(&self) -> impl Iterator<Item = Local> {\n         let arg_count = self.arg_count;\n-        (1..arg_count + 1).map(Local::new)\n+        (1..=arg_count).map(Local::new)\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all"}, {"sha": "bd8b3e678d851630b3c60f8fdf4935c00c5b15fc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -1942,8 +1942,12 @@ pub mod tls {\n     /// This is a callback from libsyntax as it cannot access the implicit state\n     /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        with(|tcx| {\n-            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+        with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+            } else {\n+                syntax_pos::default_span_debug(span, f)\n+            }\n         })\n     }\n "}, {"sha": "1439e41bb31fd9ba5924683d19947288f657be9a", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -103,8 +103,11 @@ impl<'tcx> QueryJob<'tcx> {\n                     condvar: Condvar::new(),\n                 });\n                 self.latch.await(&waiter);\n-\n-                match Lrc::get_mut(&mut waiter).unwrap().cycle.get_mut().take() {\n+                // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+                // although another thread may still have a Lrc reference so we cannot\n+                // use Lrc::get_mut\n+                let mut cycle = waiter.cycle.lock();\n+                match cycle.take() {\n                     None => Ok(()),\n                     Some(cycle) => Err(cycle)\n                 }\n@@ -326,19 +329,17 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // This query is connected to the root (it has no query parent), return true\n-    if query.parent.is_none() {\n-        return true;\n-    }\n-\n     // We already visited this or we're deliberately ignoring it\n     if visited.contains(&query.as_ptr()) {\n         return false;\n     }\n \n-    visited.insert(query.as_ptr());\n+    // This query is connected to the root (it has no query parent), return true\n+    if query.parent.is_none() {\n+        return true;\n+    }\n \n-    let mut connected = false;\n+    visited.insert(query.as_ptr());\n \n     visit_waiters(query, |_, successor| {\n         if connected_to_root(successor, visited) {\n@@ -349,6 +350,28 @@ fn connected_to_root<'tcx>(\n     }).is_some()\n }\n \n+// Deterministically pick an query from a list\n+#[cfg(parallel_queries)]\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n+    tcx: TyCtxt<'_, 'tcx, '_>,\n+    queries: &'a [T],\n+    f: F\n+) -> &'a T {\n+    // Deterministically pick an entry point\n+    // FIXME: Sort this instead\n+    let mut hcx = tcx.create_stable_hashing_context();\n+    queries.iter().min_by_key(|v| {\n+        let (span, query) = f(v);\n+        let mut stable_hasher = StableHasher::<u64>::new();\n+        query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+        // Prefer entry points which have valid spans for nicer error messages\n+        // We add an integer to the tuple ensuring that entry points\n+        // with valid spans are picked first\n+        let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n+        (span_cmp, stable_hasher.finish())\n+    }).unwrap()\n+}\n+\n /// Looks for query cycles starting from the last query in `jobs`.\n /// If a cycle is found, all queries in the cycle is removed from `jobs` and\n /// the function return true.\n@@ -388,41 +411,52 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points = stack.iter().filter_map(|query| {\n-            // Mark all the other queries in the cycle as already visited\n-            let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n-                if q.1.as_ptr() != query.1.as_ptr() {\n-                    Some(q.1.as_ptr())\n-                } else {\n+        let entry_points: Vec<_> = stack.iter().filter_map(|(span, query)| {\n+            if query.parent.is_none() {\n+                // This query is connected to the root (it has no query parent)\n+                Some((*span, query.clone(), None))\n+            } else {\n+                let mut waiters = Vec::new();\n+                // Find all the direct waiters who lead to the root\n+                visit_waiters(query.clone(), |span, waiter| {\n+                    // Mark all the other queries in the cycle as already visited\n+                    let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1.as_ptr()));\n+\n+                    if connected_to_root(waiter.clone(), &mut visited) {\n+                        waiters.push((span, waiter));\n+                    }\n+\n+                    None\n+                });\n+                if waiters.is_empty() {\n                     None\n+                } else {\n+                    // Deterministically pick one of the waiters to show to the user\n+                    let waiter = pick_query(tcx, &waiters, |s| s.clone()).clone();\n+                    Some((*span, query.clone(), Some(waiter)))\n                 }\n-            }));\n-\n-            if connected_to_root(query.1.clone(), &mut visited) {\n-                Some(query.1.clone())\n-            } else {\n-                None\n             }\n-        });\n+        }).collect();\n+\n+        let entry_points: Vec<(Span, Lrc<QueryJob<'tcx>>, Option<(Span, Lrc<QueryJob<'tcx>>)>)>\n+         = entry_points;\n \n         // Deterministically pick an entry point\n-        // FIXME: Sort this instead\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.min_by_key(|q| {\n-            let mut stable_hasher = StableHasher::<u64>::new();\n-            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n-            stable_hasher.finish()\n-        }).unwrap().as_ptr();\n+        let (_, entry_point, usage) = pick_query(tcx, &entry_points, |e| (e.0, e.1.clone()));\n \n         // Shift the stack so that our entry point is first\n-        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        let entry_point_pos = stack.iter().position(|(_, query)| {\n+            query.as_ptr() == entry_point.as_ptr()\n+        });\n         if let Some(pos) = entry_point_pos {\n-            stack.rotate_right(pos);\n+            stack.rotate_left(pos);\n         }\n \n+        let usage = usage.as_ref().map(|(span, query)| (*span, query.info.query.clone()));\n+\n         // Create the cycle error\n         let mut error = CycleError {\n-            usage: None,\n+            usage,\n             cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n                 span: s,\n                 query: q.info.query.clone(),"}, {"sha": "1e648c45817332b57691a1e2942f4c744917767a", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -11,7 +11,7 @@\n use session::config::Options;\n \n use std::fs;\n-use std::io::{self, StdoutLock, Write};\n+use std::io::{self, StderrLock, Write};\n use std::time::{Duration, Instant};\n \n macro_rules! define_categories {\n@@ -61,7 +61,7 @@ macro_rules! define_categories {\n                 }\n             }\n \n-            fn print(&self, lock: &mut StdoutLock<'_>) {\n+            fn print(&self, lock: &mut StderrLock<'_>) {\n                 writeln!(lock, \"| Phase            | Time (ms)      | Queries        | Hits (%) |\")\n                     .unwrap();\n                 writeln!(lock, \"| ---------------- | -------------- | -------------- | -------- |\")\n@@ -235,7 +235,7 @@ impl SelfProfiler {\n             self.timer_stack.is_empty(),\n             \"there were timers running when print_results() was called\");\n \n-        let out = io::stdout();\n+        let out = io::stderr();\n         let mut lock = out.lock();\n \n         let crate_name ="}, {"sha": "2ad83fc93ef75c1c089e077ee3cfde9da9c75392", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -571,7 +571,7 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n             }\n             // Fill with zeros up to precision.\n             if !truncate_zero && precision > digits - 1 {\n-                for _ in 0..precision - digits + 1 {\n+                for _ in 0..=precision - digits {\n                     f.write_char('0')?;\n                 }\n             }\n@@ -1969,7 +1969,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         // in a Limb. When this would overflow do we do a single\n         // bignum multiplication, and then revert again to multiplication\n         // in a Limb.\n-        let mut chars = s[first_sig_digit..last_sig_digit + 1].chars();\n+        let mut chars = s[first_sig_digit..=last_sig_digit].chars();\n         loop {\n             let mut val = 0;\n             let mut multiplier = 1;"}, {"sha": "2b6bb34b146cb32d8abf25ef68a04a35e8e28342", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -98,7 +98,7 @@ fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n \n fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n where\n-    F: FnOnce(Env),\n+    F: FnOnce(Env) + sync::Send,\n {\n     syntax::with_globals(|| {\n         let mut options = config::Options::default();"}, {"sha": "ae9f6a5e140d3929b917d37b44a3b1befc3b95f1", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -549,7 +549,7 @@ impl EmitterWriter {\n         // 3 |\n         // 4 |   }\n         //   |\n-        for pos in 0..line_len + 1 {\n+        for pos in 0..=line_len {\n             draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n             buffer.putc(line_offset + pos + 1,\n                         width_offset - 2,\n@@ -617,7 +617,7 @@ impl EmitterWriter {\n             let pos = pos + 1;\n \n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n-                for p in line_offset + 1..line_offset + pos + 1 {\n+                for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n                                 code_offset + annotation.start_col,\n                                 '|',\n@@ -634,7 +634,7 @@ impl EmitterWriter {\n                     }\n                 }\n                 AnnotationType::MultilineEnd(depth) => {\n-                    for p in line_offset..line_offset + pos + 1 {\n+                    for p in line_offset..=line_offset + pos {\n                         buffer.putc(p,\n                                     width_offset + depth - 1,\n                                     '|',"}, {"sha": "11ce10fd4a77f3421bdb4472746e513659d944ca", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -354,7 +354,7 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n     }\n \n     // State: \"s-{timestamp}-{random-number}-\"\n-    let mut new_sub_dir_name = String::from(&old_sub_dir_name[.. dash_indices[2] + 1]);\n+    let mut new_sub_dir_name = String::from(&old_sub_dir_name[..= dash_indices[2]]);\n \n     // Append the svh\n     base_n::push_str(svh.as_u64() as u128, INT_ENCODE_BASE, &mut new_sub_dir_name);"}, {"sha": "c7512f4b67f25a9de67464eded5038486b8d9d0f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -48,7 +48,7 @@ impl RegionValueElements {\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n         for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n-            basic_blocks.extend((0..bb_data.statements.len() + 1).map(|_| bb));\n+            basic_blocks.extend((0..=bb_data.statements.len()).map(|_| bb));\n         }\n \n         Self {"}, {"sha": "172ff95ed10663318c4221c05d99af5c2b79560e", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n-        let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n+        let pre_binding_blocks: Vec<_> = (0..=candidate_count)\n             .map(|_| self.cfg.start_new_block())\n             .collect();\n "}, {"sha": "389be3f758e2415253dfcc5c28356c88c52bc151", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -3617,7 +3617,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let res = self.smart_resolve_path_fragment(\n                 id,\n                 None,\n-                &path[..qself.position + 1],\n+                &path[..=qself.position],\n                 span,\n                 PathSource::TraitItem(ns),\n                 CrateLint::QPathTrait {"}, {"sha": "a9aa721f5c3a7f534f8ba5ce15fe5dbc56203668", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -400,6 +400,8 @@ supported_targets! {\n     (\"thumbv7em-none-eabi\", thumbv7em_none_eabi),\n     (\"thumbv7em-none-eabihf\", thumbv7em_none_eabihf),\n     (\"thumbv8m.base-none-eabi\", thumbv8m_base_none_eabi),\n+    (\"thumbv8m.main-none-eabi\", thumbv8m_main_none_eabi),\n+    (\"thumbv8m.main-none-eabihf\", thumbv8m_main_none_eabihf),\n \n     (\"msp430-none-elf\", msp430_none_elf),\n "}, {"sha": "a5c4b8925e248e89cac7a7dc1d36d8744bc94df4", "filename": "src/librustc_target/spec/thumb_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumb_base.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -18,6 +18,7 @@\n // - Cortex-M4(F)\n // - Cortex-M7(F)\n // - Cortex-M23\n+// - Cortex-M33\n //\n // We have opted for these instead of one target per processor (e.g. `cortex-m0`, `cortex-m3`,\n // etc) because the differences between some processors like the cortex-m0 and cortex-m1 are almost"}, {"sha": "6dc203e81bf3f60eb1f2617d5690a8dc005413de", "filename": "src/librustc_target/spec/thumbv8m_main_none_eabi.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabi.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Targets the Cortex-M33 processor (Armv8-M Mainline architecture profile),\n+// without the Floating Point extension.\n+\n+use spec::{LinkerFlavor, LldFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"thumbv8m.main-none-eabi\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: String::new(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+\n+        options: TargetOptions {\n+            max_atomic_width: Some(32),\n+            .. super::thumb_base::opts()\n+        },\n+    })\n+}"}, {"sha": "dc7728c2bd5001e617b45cc04609d0ecfbe63352", "filename": "src/librustc_target/spec/thumbv8m_main_none_eabihf.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv8m_main_none_eabihf.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Targets the Cortex-M33 processor (Armv8-M Mainline architecture profile),\n+// with the Floating Point extension.\n+\n+use spec::{LinkerFlavor, LldFlavor, Target, TargetOptions, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    Ok(Target {\n+        llvm_target: \"thumbv8m.main-none-eabihf\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n+        arch: \"arm\".to_string(),\n+        target_os: \"none\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: String::new(),\n+        linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),\n+\n+        options: TargetOptions {\n+            // If the Floating Point extension is implemented in the Cortex-M33\n+            // processor, the Cortex-M33 Technical Reference Manual states that\n+            // the FPU uses the FPv5 architecture, single-precision instructions\n+            // and 16 D registers.\n+            // These parameters map to the following LLVM features.\n+            features: \"+fp-armv8,+fp-only-sp,+d16\".to_string(),\n+            max_atomic_width: Some(32),\n+            .. super::thumb_base::opts()\n+        },\n+    })\n+}"}, {"sha": "30054f66e2fe01f9ce39eb0d6b0ddda4e471e320", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -4798,7 +4798,7 @@ impl<'a> fmt::Display for Source<'a> {\n             tmp /= 10;\n         }\n         write!(fmt, \"<pre class=\\\"line-numbers\\\">\")?;\n-        for i in 1..lines + 1 {\n+        for i in 1..=lines {\n             write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols)?;\n         }\n         write!(fmt, \"</pre>\")?;"}, {"sha": "55a1a75d049e9900fb167a8efcb59d417868cab7", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -11,6 +11,7 @@\n use self::Entry::*;\n use self::VacantEntryState::*;\n \n+use intrinsics::unlikely;\n use collections::CollectionAllocErr;\n use cell::Cell;\n use borrow::Borrow;\n@@ -1992,6 +1993,9 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     fn search<F>(self, hash: u64, is_match: F, compare_hashes: bool) -> Option<(&'a K, &'a V)>\n         where F: FnMut(&K) -> bool\n     {\n+        if unsafe { unlikely(self.map.table.size() == 0) } {\n+            return None;\n+        }\n         match search_hashed_nonempty(&self.map.table,\n                                      SafeHash::new(hash),\n                                      is_match,\n@@ -3610,7 +3614,7 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.insert(i, i).is_none());\n \n-                for j in 1..i + 1 {\n+                for j in 1..=i {\n                     let r = m.get(&j);\n                     assert_eq!(r, Some(&j));\n                 }\n@@ -3629,7 +3633,7 @@ mod test_map {\n             for i in 1..1001 {\n                 assert!(m.remove(&i).is_some());\n \n-                for j in 1..i + 1 {\n+                for j in 1..=i {\n                     assert!(!m.contains_key(&j));\n                 }\n "}, {"sha": "7ede050da6c45fc57ec0ca0e478b8d489b61f011", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -918,7 +918,7 @@ impl<W: Write> Write for LineWriter<W> {\n         // some data then we *must* report that we wrote that data, so future\n         // errors are ignored. We set our internal `need_flush` flag, though, in\n         // case flushing fails and we need to try it first next time.\n-        let n = self.inner.write(&buf[..i + 1])?;\n+        let n = self.inner.write(&buf[..=i])?;\n         self.need_flush = true;\n         if self.flush().is_err() || n != i + 1 {\n             return Ok(n)"}, {"sha": "dc97701d889c4325ba9f7ea54df617f246f93f84", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -1261,7 +1261,7 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n             };\n             match memchr::memchr(delim, available) {\n                 Some(i) => {\n-                    buf.extend_from_slice(&available[..i + 1]);\n+                    buf.extend_from_slice(&available[..=i]);\n                     (true, i + 1)\n                 }\n                 None => {"}, {"sha": "03c1bb54af8a7095e67965ded5d8997415746148", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -487,7 +487,7 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n             } else {\n                 if x == '\"' as u16 {\n                     // Add n+1 backslashes to total 2n+1 before internal '\"'.\n-                    cmd.extend((0..(backslashes + 1)).map(|_| '\\\\' as u16));\n+                    cmd.extend((0..=backslashes).map(|_| '\\\\' as u16));\n                 }\n                 backslashes = 0;\n             }"}, {"sha": "e6b81a59d869b194fd039d01de49bcbbb91d6ff1", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -20,7 +20,7 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n         return a.chars().count();\n     }\n \n-    let mut dcol: Vec<_> = (0..b.len() + 1).collect();\n+    let mut dcol: Vec<_> = (0..=b.len()).collect();\n     let mut t_last = 0;\n \n     for (i, sc) in a.chars().enumerate() {"}, {"sha": "4e3d1e89a72194b1a72fa0f0f91a6f055293e19b", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc84f5f837a3e1b9b9bc992dd603d3d968502288/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=fc84f5f837a3e1b9b9bc992dd603d3d968502288", "patch": "@@ -611,7 +611,7 @@ impl serialize::UseSpecializedDecodable for Span {\n     }\n }\n \n-fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n+pub fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n     f.debug_struct(\"Span\")\n         .field(\"lo\", &span.lo())\n         .field(\"hi\", &span.hi())"}]}