{"sha": "51368793b462306724eafa7d9fb0797329b671f3", "node_id": "C_kwDOAAsO6NoAKDUxMzY4NzkzYjQ2MjMwNjcyNGVhZmE3ZDlmYjA3OTczMjliNjcxZjM", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-25T21:15:37Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-05-28T19:55:15Z"}, "message": "MIR episode 6", "tree": {"sha": "1b013f2ec009d038d627d9621d095006ca9ac762", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b013f2ec009d038d627d9621d095006ca9ac762"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51368793b462306724eafa7d9fb0797329b671f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51368793b462306724eafa7d9fb0797329b671f3", "html_url": "https://github.com/rust-lang/rust/commit/51368793b462306724eafa7d9fb0797329b671f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51368793b462306724eafa7d9fb0797329b671f3/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "505fd09f9e020b096d014e68b667268e743c2dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/505fd09f9e020b096d014e68b667268e743c2dd6", "html_url": "https://github.com/rust-lang/rust/commit/505fd09f9e020b096d014e68b667268e743c2dd6"}], "stats": {"total": 2030, "additions": 1474, "deletions": 556}, "files": [{"sha": "acc9943481a8c4f904b18df1565ee2a68280767c", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 130, "deletions": 27, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -31,8 +31,8 @@ use crate::{\n     expander::Expander,\n     hir::{\n         dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Expr,\n-        ExprId, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat,\n-        RecordLitField, Statement,\n+        ExprId, Label, LabelId, Literal, LiteralOrConst, MatchArm, Movability, Pat, PatId,\n+        RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n@@ -295,13 +295,7 @@ impl ExprCollector<'_> {\n \n                 self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n             }\n-            ast::Expr::ForExpr(e) => {\n-                let label = e.label().map(|label| self.collect_label(label));\n-                let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_top(e.pat());\n-                let body = self.collect_labelled_block_opt(label, e.loop_body());\n-                self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n-            }\n+            ast::Expr::ForExpr(e) => self.collect_for_loop(syntax_ptr, e),\n             ast::Expr::CallExpr(e) => {\n                 let is_rustc_box = {\n                     let attrs = e.attrs();\n@@ -703,6 +697,91 @@ impl ExprCollector<'_> {\n         expr_id\n     }\n \n+    /// Desugar `ast::ForExpr` from: `[opt_ident]: for <pat> in <head> <body>` into:\n+    /// ```ignore (pseudo-rust)\n+    /// match IntoIterator::into_iter(<head>) {\n+    ///     mut iter => {\n+    ///         [opt_ident]: loop {\n+    ///             match Iterator::next(&mut iter) {\n+    ///                 None => break,\n+    ///                 Some(<pat>) => <body>,\n+    ///             };\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    fn collect_for_loop(&mut self, syntax_ptr: AstPtr<ast::Expr>, e: ast::ForExpr) -> ExprId {\n+        let (into_iter_fn, iter_next_fn, option_some, option_none) = 'if_chain: {\n+            if let Some(into_iter_fn) = LangItem::IntoIterIntoIter.path(self.db, self.krate) {\n+                if let Some(iter_next_fn) = LangItem::IteratorNext.path(self.db, self.krate) {\n+                    if let Some(option_some) = LangItem::OptionSome.path(self.db, self.krate) {\n+                        if let Some(option_none) = LangItem::OptionNone.path(self.db, self.krate) {\n+                            break 'if_chain (into_iter_fn, iter_next_fn, option_some, option_none);\n+                        }\n+                    }\n+                }\n+            }\n+            // Some of the needed lang items are missing, so we can't desugar\n+            return self.alloc_expr(Expr::Missing, syntax_ptr);\n+        };\n+        let head = self.collect_expr_opt(e.iterable());\n+        let into_iter_fn_expr = self.alloc_expr(Expr::Path(into_iter_fn), syntax_ptr.clone());\n+        let iterator = self.alloc_expr(\n+            Expr::Call {\n+                callee: into_iter_fn_expr,\n+                args: Box::new([head]),\n+                is_assignee_expr: false,\n+            },\n+            syntax_ptr.clone(),\n+        );\n+        let none_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(Pat::Path(Box::new(option_none))),\n+            guard: None,\n+            expr: self.alloc_expr(Expr::Break { expr: None, label: None }, syntax_ptr.clone()),\n+        };\n+        let some_pat = Pat::TupleStruct {\n+            path: Some(Box::new(option_some)),\n+            args: Box::new([self.collect_pat_top(e.pat())]),\n+            ellipsis: None,\n+        };\n+        let some_arm = MatchArm {\n+            pat: self.alloc_pat_desugared(some_pat),\n+            guard: None,\n+            expr: self.collect_expr_opt(e.loop_body().map(|x| x.into())),\n+        };\n+        let iter_name = Name::generate_new_name();\n+        let iter_binding = self.alloc_binding(iter_name.clone(), BindingAnnotation::Mutable);\n+        let iter_expr = self.alloc_expr(Expr::Path(Path::from(iter_name)), syntax_ptr.clone());\n+        let iter_expr_mut = self.alloc_expr(\n+            Expr::Ref { expr: iter_expr, rawness: Rawness::Ref, mutability: Mutability::Mut },\n+            syntax_ptr.clone(),\n+        );\n+        let iter_next_fn_expr = self.alloc_expr(Expr::Path(iter_next_fn), syntax_ptr.clone());\n+        let iter_next_expr = self.alloc_expr(\n+            Expr::Call {\n+                callee: iter_next_fn_expr,\n+                args: Box::new([iter_expr_mut]),\n+                is_assignee_expr: false,\n+            },\n+            syntax_ptr.clone(),\n+        );\n+        let loop_inner = self.alloc_expr(\n+            Expr::Match { expr: iter_next_expr, arms: Box::new([none_arm, some_arm]) },\n+            syntax_ptr.clone(),\n+        );\n+        let label = e.label().map(|label| self.collect_label(label));\n+        let loop_outer =\n+            self.alloc_expr(Expr::Loop { body: loop_inner, label }, syntax_ptr.clone());\n+        let iter_pat = self.alloc_pat_desugared(Pat::Bind { id: iter_binding, subpat: None });\n+        self.alloc_expr(\n+            Expr::Match {\n+                expr: iterator,\n+                arms: Box::new([MatchArm { pat: iter_pat, guard: None, expr: loop_outer }]),\n+            },\n+            syntax_ptr.clone(),\n+        )\n+    }\n+\n     /// Desugar `ast::TryExpr` from: `<expr>?` into:\n     /// ```ignore (pseudo-rust)\n     /// match Try::branch(<expr>) {\n@@ -1159,22 +1238,12 @@ impl ExprCollector<'_> {\n             }\n             #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5676\n             ast::Pat::LiteralPat(lit) => 'b: {\n-                if let Some(ast_lit) = lit.literal() {\n-                    let mut hir_lit: Literal = ast_lit.kind().into();\n-                    if lit.minus_token().is_some() {\n-                        let Some(h) = hir_lit.negate() else {\n-                            break 'b Pat::Missing;\n-                        };\n-                        hir_lit = h;\n-                    }\n-                    let expr = Expr::Literal(hir_lit);\n-                    let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n-                    let expr_id = self.alloc_expr(expr, expr_ptr);\n-                    Pat::Lit(expr_id)\n-                } else {\n-                    Pat::Missing\n-                }\n-            },\n+                let Some((hir_lit, ast_lit)) = pat_literal_to_hir(lit) else { break 'b Pat::Missing };\n+                let expr = Expr::Literal(hir_lit);\n+                let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n+                let expr_id = self.alloc_expr(expr, expr_ptr);\n+                Pat::Lit(expr_id)\n+            }\n             ast::Pat::RestPat(_) => {\n                 // `RestPat` requires special handling and should not be mapped\n                 // to a Pat. Here we are using `Pat::Missing` as a fallback for\n@@ -1215,8 +1284,30 @@ impl ExprCollector<'_> {\n                 }\n                 None => Pat::Missing,\n             },\n-            // FIXME: implement\n-            ast::Pat::RangePat(_) => Pat::Missing,\n+            // FIXME: implement in a way that also builds source map and calculates assoc resolutions in type inference.\n+            ast::Pat::RangePat(p) => {\n+                let mut range_part_lower = |p: Option<ast::Pat>| {\n+                    p.and_then(|x| match &x {\n+                        ast::Pat::LiteralPat(x) => {\n+                            Some(Box::new(LiteralOrConst::Literal(pat_literal_to_hir(x)?.0)))\n+                        }\n+                        ast::Pat::IdentPat(p) => {\n+                            let name =\n+                                p.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                            Some(Box::new(LiteralOrConst::Const(name.into())))\n+                        }\n+                        ast::Pat::PathPat(p) => p\n+                            .path()\n+                            .and_then(|path| self.expander.parse_path(self.db, path))\n+                            .map(LiteralOrConst::Const)\n+                            .map(Box::new),\n+                        _ => None,\n+                    })\n+                };\n+                let start = range_part_lower(p.start());\n+                let end = range_part_lower(p.end());\n+                Pat::Range { start, end }\n+            }\n         };\n         let ptr = AstPtr::new(&pat);\n         self.alloc_pat(pattern, Either::Left(ptr))\n@@ -1338,6 +1429,18 @@ impl ExprCollector<'_> {\n     // endregion: labels\n }\n \n+fn pat_literal_to_hir(lit: &ast::LiteralPat) -> Option<(Literal, ast::Literal)> {\n+    let ast_lit = lit.literal()?;\n+    let mut hir_lit: Literal = ast_lit.kind().into();\n+    if lit.minus_token().is_some() {\n+        let Some(h) = hir_lit.negate() else {\n+            return None;\n+        };\n+        hir_lit = h;\n+    }\n+    Some((hir_lit, ast_lit))\n+}\n+\n impl ExprCollector<'_> {\n     fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n         let src = self.expander.to_source(ptr);"}, {"sha": "88380aa355d16c487632997f331942234c3ca541", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -7,7 +7,8 @@ use syntax::ast::HasName;\n \n use crate::{\n     hir::{\n-        Array, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Literal, Movability, Statement,\n+        Array, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Literal, LiteralOrConst,\n+        Movability, Statement,\n     },\n     pretty::{print_generic_args, print_path, print_type_ref},\n     type_ref::TypeRef,\n@@ -184,16 +185,6 @@ impl<'a> Printer<'a> {\n                 self.print_expr(*condition);\n                 self.print_expr(*body);\n             }\n-            Expr::For { iterable, pat, body, label } => {\n-                if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n-                }\n-                w!(self, \"for \");\n-                self.print_pat(*pat);\n-                w!(self, \" in \");\n-                self.print_expr(*iterable);\n-                self.print_expr(*body);\n-            }\n             Expr::Call { callee, args, is_assignee_expr: _ } => {\n                 self.print_expr(*callee);\n                 w!(self, \"(\");\n@@ -534,9 +525,13 @@ impl<'a> Printer<'a> {\n                 w!(self, \"}}\");\n             }\n             Pat::Range { start, end } => {\n-                self.print_expr(*start);\n-                w!(self, \"...\");\n-                self.print_expr(*end);\n+                if let Some(start) = start {\n+                    self.print_literal_or_const(start);\n+                }\n+                w!(self, \"..=\");\n+                if let Some(end) = end {\n+                    self.print_literal_or_const(end);\n+                }\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n                 w!(self, \"[\");\n@@ -627,6 +622,13 @@ impl<'a> Printer<'a> {\n         }\n     }\n \n+    fn print_literal_or_const(&mut self, literal_or_const: &LiteralOrConst) {\n+        match literal_or_const {\n+            LiteralOrConst::Literal(l) => self.print_literal(l),\n+            LiteralOrConst::Const(c) => self.print_path(c),\n+        }\n+    }\n+\n     fn print_literal(&mut self, literal: &Literal) {\n         match literal {\n             Literal::String(it) => w!(self, \"{:?}\", it),"}, {"sha": "69741c445fbae4e3f720f3ed8b09691db99aa82e", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -228,12 +228,6 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n-        Expr::For { iterable, pat, body: body_expr, label } => {\n-            compute_expr_scopes(*iterable, body, scopes, scope);\n-            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n-            scopes.add_pat_bindings(body, scope, *pat);\n-            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n-        }\n         Expr::While { condition, body: body_expr, label } => {\n             let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n             compute_expr_scopes(*condition, body, scopes, &mut scope);"}, {"sha": "8102efdba3089c489bb6edf5199e1a9e9e627cad", "filename": "crates/hir-def/src/hir.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -96,6 +96,13 @@ pub enum Literal {\n     Float(FloatTypeWrapper, Option<BuiltinFloat>),\n }\n \n+#[derive(Debug, Clone, Eq, PartialEq)]\n+/// Used in range patterns.\n+pub enum LiteralOrConst {\n+    Literal(Literal),\n+    Const(Path),\n+}\n+\n impl Literal {\n     pub fn negate(self) -> Option<Self> {\n         if let Literal::Int(i, k) = self {\n@@ -189,12 +196,6 @@ pub enum Expr {\n         body: ExprId,\n         label: Option<LabelId>,\n     },\n-    For {\n-        iterable: ExprId,\n-        pat: PatId,\n-        body: ExprId,\n-        label: Option<LabelId>,\n-    },\n     Call {\n         callee: ExprId,\n         args: Box<[ExprId]>,\n@@ -382,10 +383,6 @@ impl Expr {\n                 f(*condition);\n                 f(*body);\n             }\n-            Expr::For { iterable, body, .. } => {\n-                f(*iterable);\n-                f(*body);\n-            }\n             Expr::Call { callee, args, .. } => {\n                 f(*callee);\n                 args.iter().copied().for_each(f);\n@@ -526,7 +523,7 @@ pub enum Pat {\n     Tuple { args: Box<[PatId]>, ellipsis: Option<usize> },\n     Or(Box<[PatId]>),\n     Record { path: Option<Box<Path>>, args: Box<[RecordFieldPat]>, ellipsis: bool },\n-    Range { start: ExprId, end: ExprId },\n+    Range { start: Option<Box<LiteralOrConst>>, end: Option<Box<LiteralOrConst>> },\n     Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n     Path(Box<Path>),\n     Lit(ExprId),"}, {"sha": "40b63b17b5aa4805e6d3a9f9107d153407fa096a", "filename": "crates/hir-ty/src/consteval.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -14,9 +14,9 @@ use stdx::never;\n use triomphe::Arc;\n \n use crate::{\n-    db::HirDatabase, infer::InferenceContext, layout::layout_of_ty, lower::ParamLoweringMode,\n-    to_placeholder_idx, utils::Generics, Const, ConstData, ConstScalar, ConstValue, GenericArg,\n-    Interner, MemoryMap, Substitution, Ty, TyBuilder,\n+    db::HirDatabase, infer::InferenceContext, lower::ParamLoweringMode,\n+    mir::monomorphize_mir_body_bad, to_placeholder_idx, utils::Generics, Const, ConstData,\n+    ConstScalar, ConstValue, GenericArg, Interner, MemoryMap, Substitution, Ty, TyBuilder,\n };\n \n use super::mir::{interpret_mir, lower_to_mir, pad16, MirEvalError, MirLowerError};\n@@ -130,14 +130,15 @@ pub fn intern_const_scalar(value: ConstScalar, ty: Ty) -> Const {\n \n /// Interns a constant scalar with the given type\n pub fn intern_const_ref(db: &dyn HirDatabase, value: &ConstRef, ty: Ty, krate: CrateId) -> Const {\n+    let layout = db.layout_of_ty(ty.clone(), krate);\n     let bytes = match value {\n         ConstRef::Int(i) => {\n             // FIXME: We should handle failure of layout better.\n-            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            let size = layout.map(|x| x.size.bytes_usize()).unwrap_or(16);\n             ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n         }\n         ConstRef::UInt(i) => {\n-            let size = layout_of_ty(db, &ty, krate).map(|x| x.size.bytes_usize()).unwrap_or(16);\n+            let size = layout.map(|x| x.size.bytes_usize()).unwrap_or(16);\n             ConstScalar::Bytes(i.to_le_bytes()[0..size].to_vec(), MemoryMap::default())\n         }\n         ConstRef::Bool(b) => ConstScalar::Bytes(vec![*b as u8], MemoryMap::default()),\n@@ -206,24 +207,35 @@ pub(crate) fn const_eval_query(\n     subst: Substitution,\n ) -> Result<Const, ConstEvalError> {\n     let body = match def {\n-        GeneralConstId::ConstId(c) => db.mir_body(c.into())?,\n+        GeneralConstId::ConstId(c) => {\n+            db.monomorphized_mir_body(c.into(), subst, db.trait_environment(c.into()))?\n+        }\n         GeneralConstId::AnonymousConstId(c) => {\n             let (def, root) = db.lookup_intern_anonymous_const(c);\n             let body = db.body(def);\n             let infer = db.infer(def);\n-            Arc::new(lower_to_mir(db, def, &body, &infer, root)?)\n+            Arc::new(monomorphize_mir_body_bad(\n+                db,\n+                lower_to_mir(db, def, &body, &infer, root)?,\n+                subst,\n+                db.trait_environment_for_body(def),\n+            )?)\n         }\n     };\n-    let c = interpret_mir(db, &body, subst, false).0?;\n+    let c = interpret_mir(db, &body, false).0?;\n     Ok(c)\n }\n \n pub(crate) fn const_eval_static_query(\n     db: &dyn HirDatabase,\n     def: StaticId,\n ) -> Result<Const, ConstEvalError> {\n-    let body = db.mir_body(def.into())?;\n-    let c = interpret_mir(db, &body, Substitution::empty(Interner), false).0?;\n+    let body = db.monomorphized_mir_body(\n+        def.into(),\n+        Substitution::empty(Interner),\n+        db.trait_environment_for_body(def.into()),\n+    )?;\n+    let c = interpret_mir(db, &body, false).0?;\n     Ok(c)\n }\n \n@@ -245,8 +257,12 @@ pub(crate) fn const_eval_discriminant_variant(\n         };\n         return Ok(value);\n     }\n-    let mir_body = db.mir_body(def)?;\n-    let c = interpret_mir(db, &mir_body, Substitution::empty(Interner), false).0?;\n+    let mir_body = db.monomorphized_mir_body(\n+        def,\n+        Substitution::empty(Interner),\n+        db.trait_environment_for_body(def),\n+    )?;\n+    let c = interpret_mir(db, &mir_body, false).0?;\n     let c = try_const_usize(db, &c).unwrap() as i128;\n     Ok(c)\n }\n@@ -271,7 +287,7 @@ pub(crate) fn eval_to_const(\n     }\n     let infer = ctx.clone().resolve_all();\n     if let Ok(mir_body) = lower_to_mir(ctx.db, ctx.owner, &ctx.body, &infer, expr) {\n-        if let Ok(result) = interpret_mir(db, &mir_body, Substitution::empty(Interner), true).0 {\n+        if let Ok(result) = interpret_mir(db, &mir_body, true).0 {\n             return result;\n         }\n     }"}, {"sha": "6a7d045648635f346e8edfbb7186cb8f993d4f3a", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -156,11 +156,23 @@ fn casts() {\n     check_number(\n         r#\"\n     //- minicore: coerce_unsized, index, slice\n+    const GOAL: usize = {\n+        let a = &[10, 20, 30, 40] as &[i32];\n+        a.len()\n+    };\n+        \"#,\n+        4,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n     const GOAL: usize = {\n         let a = [10, 20, 3, 15];\n         let x: &[i32] = &a;\n         let y: *const [i32] = x;\n         let z = y as *const [u8]; // slice fat pointer cast don't touch metadata\n+        let q = z as *const str;\n+        let p = q as *const [u8];\n         let w = unsafe { &*z };\n         w.len()\n     };\n@@ -987,11 +999,15 @@ fn path_pattern_matching() {\n \n     const MY_SEASON: Season = Summer;\n \n+    impl Season {\n+        const FALL: Season = Fall;\n+    }\n+\n     const fn f(x: Season) -> i32 {\n         match x {\n             Spring => 1,\n             MY_SEASON => 2,\n-            Fall => 3,\n+            Season::FALL => 3,\n             Winter => 4,\n         }\n     }\n@@ -1031,6 +1047,27 @@ fn pattern_matching_literal() {\n     );\n }\n \n+#[test]\n+fn pattern_matching_range() {\n+    check_number(\n+        r#\"\n+    pub const L: i32 = 6;\n+    mod x {\n+        pub const R: i32 = 100;\n+    }\n+    const fn f(x: i32) -> i32 {\n+        match x {\n+            -1..=5 => x * 10,\n+            L..=x::R => x * 100,\n+            _ => x,\n+        }\n+    }\n+    const GOAL: i32 = f(-1) + f(2) + f(100) + f(-2) + f(1000);\n+        \"#,\n+        11008,\n+    );\n+}\n+\n #[test]\n fn pattern_matching_slice() {\n     check_number(\n@@ -1045,6 +1082,22 @@ fn pattern_matching_slice() {\n         \"#,\n         10 + 4 + 60 + 16,\n     );\n+    check_number(\n+        r#\"\n+    //- minicore: slice, index, coerce_unsized, copy\n+    const fn f(x: &[usize]) -> usize {\n+        match x {\n+            [] => 0,\n+            [a] => *a,\n+            &[a, b] => a + b,\n+            [a, b @ .., c, d] => *a + b.len() + *c + *d,\n+        }\n+    }\n+    const GOAL: usize = f(&[]) + f(&[10]) + f(&[100, 100])\n+        + f(&[1000, 1000, 1000]) + f(&[10000, 57, 34, 46, 10000, 10000]);\n+        \"#,\n+        33213,\n+    );\n }\n \n #[test]\n@@ -2105,6 +2158,26 @@ fn const_generic_subst_fn() {\n     \"#,\n         11,\n     );\n+    check_number(\n+        r#\"\n+    fn f<const N: usize>(x: [i32; N]) -> usize {\n+        N\n+    }\n+\n+    trait ArrayExt {\n+        fn f(self) -> usize;\n+    }\n+\n+    impl<T, const N: usize> ArrayExt for [T; N] {\n+        fn g(self) -> usize {\n+            f(self)\n+        }\n+    }\n+\n+    const GOAL: usize = f([1, 2, 5]);\n+    \"#,\n+        3,\n+    );\n }\n \n #[test]"}, {"sha": "1feb9a4441c03cb170c4c82ccfef6e39223da4e5", "filename": "crates/hir-ty/src/consteval/tests/intrinsics.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests%2Fintrinsics.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -67,6 +67,30 @@ fn wrapping_add() {\n     );\n }\n \n+#[test]\n+fn saturating_add() {\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn saturating_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: u8 = saturating_add(10, 250);\n+        \"#,\n+        255,\n+    );\n+    check_number(\n+        r#\"\n+        extern \"rust-intrinsic\" {\n+            pub fn saturating_add<T>(a: T, b: T) -> T;\n+        }\n+\n+        const GOAL: i8 = saturating_add(5, 8);\n+        \"#,\n+        13,\n+    );\n+}\n+\n #[test]\n fn allocator() {\n     check_number("}, {"sha": "ca8a394e360dcde383a386f57b0935d878f7e7c0", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -41,6 +41,23 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     #[salsa::invoke(crate::mir::mir_body_for_closure_query)]\n     fn mir_body_for_closure(&self, def: ClosureId) -> Result<Arc<MirBody>, MirLowerError>;\n \n+    #[salsa::invoke(crate::mir::monomorphized_mir_body_query)]\n+    #[salsa::cycle(crate::mir::monomorphized_mir_body_recover)]\n+    fn monomorphized_mir_body(\n+        &self,\n+        def: DefWithBodyId,\n+        subst: Substitution,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Result<Arc<MirBody>, MirLowerError>;\n+\n+    #[salsa::invoke(crate::mir::monomorphized_mir_body_for_closure_query)]\n+    fn monomorphized_mir_body_for_closure(\n+        &self,\n+        def: ClosureId,\n+        subst: Substitution,\n+        env: Arc<crate::TraitEnvironment>,\n+    ) -> Result<Arc<MirBody>, MirLowerError>;\n+\n     #[salsa::invoke(crate::mir::borrowck_query)]\n     fn borrowck(&self, def: DefWithBodyId) -> Result<Arc<[BorrowckResult]>, MirLowerError>;\n \n@@ -84,7 +101,11 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n         def: AdtId,\n         subst: Substitution,\n         krate: CrateId,\n-    ) -> Result<Layout, LayoutError>;\n+    ) -> Result<Arc<Layout>, LayoutError>;\n+\n+    #[salsa::invoke(crate::layout::layout_of_ty_query)]\n+    #[salsa::cycle(crate::layout::layout_of_ty_recover)]\n+    fn layout_of_ty(&self, ty: Ty, krate: CrateId) -> Result<Arc<Layout>, LayoutError>;\n \n     #[salsa::invoke(crate::layout::target_data_layout_query)]\n     fn target_data_layout(&self, krate: CrateId) -> Option<Arc<TargetDataLayout>>;"}, {"sha": "058d5059b1692423eacf7526479b0f6123227ffe", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -26,9 +26,7 @@ use stdx::never;\n \n use crate::{\n     db::HirDatabase,\n-    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx,\n-    layout::layout_of_ty,\n-    lt_from_placeholder_idx,\n+    from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n     mir::pad16,\n     primitive, to_assoc_type_id,\n@@ -309,6 +307,8 @@ pub enum ClosureStyle {\n     RANotation,\n     /// `{closure#14825}`, useful for some diagnostics (like type mismatch) and internal usage.\n     ClosureWithId,\n+    /// `{closure#14825}<i32, ()>`, useful for internal usage.\n+    ClosureWithSubst,\n     /// `\u2026`, which is the `TYPE_HINT_TRUNCATION`\n     Hide,\n }\n@@ -507,7 +507,7 @@ fn render_const_scalar(\n             _ => f.write_str(\"<ref-not-supported>\"),\n         },\n         chalk_ir::TyKind::Tuple(_, subst) => {\n-            let Ok(layout) = layout_of_ty(f.db, ty, krate) else {\n+            let Ok(layout) = f.db.layout_of_ty( ty.clone(), krate) else {\n                 return f.write_str(\"<layout-error>\");\n             };\n             f.write_str(\"(\")?;\n@@ -520,7 +520,7 @@ fn render_const_scalar(\n                 }\n                 let ty = ty.assert_ty_ref(Interner); // Tuple only has type argument\n                 let offset = layout.fields.offset(id).bytes_usize();\n-                let Ok(layout) = layout_of_ty(f.db, &ty, krate) else {\n+                let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n                     f.write_str(\"<layout-error>\")?;\n                     continue;\n                 };\n@@ -545,7 +545,7 @@ fn render_const_scalar(\n                                 .offset(u32::from(id.into_raw()) as usize)\n                                 .bytes_usize();\n                             let ty = field_types[id].clone().substitute(Interner, subst);\n-                            let Ok(layout) = layout_of_ty(f.db, &ty, krate) else {\n+                            let Ok(layout) = f.db.layout_of_ty(ty.clone(), krate) else {\n                                 return f.write_str(\"<layout-error>\");\n                             };\n                             let size = layout.size.bytes_usize();\n@@ -931,6 +931,10 @@ impl HirDisplay for Ty {\n                     ClosureStyle::ClosureWithId => {\n                         return write!(f, \"{{closure#{:?}}}\", id.0.as_u32())\n                     }\n+                    ClosureStyle::ClosureWithSubst => {\n+                        write!(f, \"{{closure#{:?}}}\", id.0.as_u32())?;\n+                        return hir_fmt_generics(f, substs, None);\n+                    }\n                     _ => (),\n                 }\n                 let sig = ClosureSubst(substs).sig_ty().callable_sig(db);"}, {"sha": "fa81fe39aa116c54b9091d4f5a4e32ffaa56f606", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -1153,22 +1153,6 @@ impl<'a> InferenceContext<'a> {\n         self.db.lang_item(krate, item)\n     }\n \n-    fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n-        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n-            .as_function()?\n-            .lookup(self.db.upcast()).container\n-        else { return None };\n-        self.db.trait_data(trait_).associated_type_by_name(&name![IntoIter])\n-    }\n-\n-    fn resolve_iterator_item(&self) -> Option<TypeAliasId> {\n-        let ItemContainerId::TraitId(trait_) = self.resolve_lang_item(LangItem::IteratorNext)?\n-            .as_function()?\n-            .lookup(self.db.upcast()).container\n-        else { return None };\n-        self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n-    }\n-\n     fn resolve_output_on(&self, trait_: TraitId) -> Option<TypeAliasId> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }"}, {"sha": "662f2e5fa161da9c086bf5895ea175e4270ad6db", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -5,7 +5,7 @@ use std::{cmp, collections::HashMap, convert::Infallible, mem};\n use chalk_ir::{\n     cast::Cast,\n     fold::{FallibleTypeFolder, TypeFoldable},\n-    AliasEq, AliasTy, BoundVar, DebruijnIndex, FnSubst, Mutability, TyKind, WhereClause,\n+    AliasEq, AliasTy, BoundVar, ConstData, DebruijnIndex, FnSubst, Mutability, TyKind, WhereClause,\n };\n use hir_def::{\n     data::adt::VariantData,\n@@ -29,8 +29,8 @@ use crate::{\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n     utils::{self, generics, pattern_matching_dereference_count, Generics},\n-    Adjust, Adjustment, Binders, ChalkTraitId, ClosureId, DynTy, FnPointer, FnSig, Interner,\n-    Substitution, Ty, TyExt,\n+    Adjust, Adjustment, Binders, ChalkTraitId, ClosureId, ConstValue, DynTy, FnPointer, FnSig,\n+    Interner, Substitution, Ty, TyExt,\n };\n \n use super::{Expectation, InferenceContext};\n@@ -259,6 +259,23 @@ impl CapturedItemWithoutTy {\n                     Interner\n                 }\n \n+                fn try_fold_free_placeholder_const(\n+                    &mut self,\n+                    ty: chalk_ir::Ty<Interner>,\n+                    idx: chalk_ir::PlaceholderIndex,\n+                    outer_binder: DebruijnIndex,\n+                ) -> Result<chalk_ir::Const<Interner>, Self::Error> {\n+                    let x = from_placeholder_idx(self.db, idx);\n+                    let Some(idx) = self.generics.param_idx(x) else {\n+                        return Err(());\n+                    };\n+                    Ok(ConstData {\n+                        ty,\n+                        value: ConstValue::BoundVar(BoundVar::new(outer_binder, idx)),\n+                    }\n+                    .intern(Interner))\n+                }\n+\n                 fn try_fold_free_placeholder_ty(\n                     &mut self,\n                     idx: chalk_ir::PlaceholderIndex,\n@@ -490,8 +507,7 @@ impl InferenceContext<'_> {\n                     self.consume_expr(*tail);\n                 }\n             }\n-            Expr::While { condition, body, label: _ }\n-            | Expr::For { iterable: condition, pat: _, body, label: _ } => {\n+            Expr::While { condition, body, label: _ } => {\n                 self.consume_expr(*condition);\n                 self.consume_expr(*body);\n             }"}, {"sha": "33e98ac86cf6b1f0f6c610c9a91a1c203817c748", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -211,24 +211,6 @@ impl<'a> InferenceContext<'a> {\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            &Expr::For { iterable, body, pat, label } => {\n-                let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n-                let into_iter_ty =\n-                    self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n-                let pat_ty = self\n-                    .resolve_associated_type(into_iter_ty.clone(), self.resolve_iterator_item());\n-\n-                self.result.type_of_for_iterator.insert(tgt_expr, into_iter_ty);\n-\n-                self.infer_top_pat(pat, &pat_ty);\n-                self.with_breakable_ctx(BreakableKind::Loop, None, label, |this| {\n-                    this.infer_expr(body, &Expectation::HasType(TyBuilder::unit()));\n-                });\n-\n-                // the body may not run, so it diverging doesn't mean we diverge\n-                self.diverges = Diverges::Maybe;\n-                TyBuilder::unit()\n-            }\n             Expr::Closure { body, args, ret_type, arg_types, closure_kind, capture_by: _ } => {\n                 assert_eq!(args.len(), arg_types.len());\n "}, {"sha": "447834243908a16c41cc4e602478e3f8d014086e", "filename": "crates/hir-ty/src/infer/mutability.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fmutability.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -69,8 +69,7 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_mut_expr(*tail, Mutability::Not);\n                 }\n             }\n-            &Expr::For { iterable: c, pat: _, body, label: _ }\n-            | &Expr::While { condition: c, body, label: _ } => {\n+            &Expr::While { condition: c, body, label: _ } => {\n                 self.infer_mut_expr(c, Mutability::Not);\n                 self.infer_mut_expr(body, Mutability::Not);\n             }"}, {"sha": "2480f8babac4f9398c4ef961c0e7451387bcea65", "filename": "crates/hir-ty/src/infer/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -255,9 +255,9 @@ impl<'a> InferenceContext<'a> {\n                 self.infer_slice_pat(&expected, prefix, slice, suffix, default_bm)\n             }\n             Pat::Wild => expected.clone(),\n-            Pat::Range { start, end } => {\n-                let start_ty = self.infer_expr(*start, &Expectation::has_type(expected.clone()));\n-                self.infer_expr(*end, &Expectation::has_type(start_ty))\n+            Pat::Range { .. } => {\n+                // FIXME: do some checks here.\n+                expected.clone()\n             }\n             &Pat::Lit(expr) => {\n                 // Don't emit type mismatches again, the expression lowering already did that."}, {"sha": "35d3407c16c1331688a0025ce137d281a1c96dd2", "filename": "crates/hir-ty/src/layout.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -77,14 +77,18 @@ impl<'a> LayoutCalculator for LayoutCx<'a> {\n     }\n }\n \n-pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Layout, LayoutError> {\n+pub fn layout_of_ty_query(\n+    db: &dyn HirDatabase,\n+    ty: Ty,\n+    krate: CrateId,\n+) -> Result<Arc<Layout>, LayoutError> {\n     let Some(target) = db.target_data_layout(krate) else { return Err(LayoutError::TargetLayoutNotAvailable) };\n     let cx = LayoutCx { krate, target: &target };\n     let dl = &*cx.current_data_layout();\n     let trait_env = Arc::new(TraitEnvironment::empty(krate));\n     let ty = normalize(db, trait_env, ty.clone());\n-    let layout = match ty.kind(Interner) {\n-        TyKind::Adt(AdtId(def), subst) => db.layout_of_adt(*def, subst.clone(), krate)?,\n+    let result = match ty.kind(Interner) {\n+        TyKind::Adt(AdtId(def), subst) => return db.layout_of_adt(*def, subst.clone(), krate),\n         TyKind::Scalar(s) => match s {\n             chalk_ir::Scalar::Bool => Layout::scalar(\n                 dl,\n@@ -141,17 +145,17 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n \n             let fields = tys\n                 .iter(Interner)\n-                .map(|k| layout_of_ty(db, k.assert_ty_ref(Interner), krate))\n+                .map(|k| db.layout_of_ty(k.assert_ty_ref(Interner).clone(), krate))\n                 .collect::<Result<Vec<_>, _>>()?;\n-            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().map(|x| &**x).collect::<Vec<_>>();\n             let fields = fields.iter().collect::<Vec<_>>();\n             cx.univariant(dl, &fields, &ReprOptions::default(), kind).ok_or(LayoutError::Unknown)?\n         }\n         TyKind::Array(element, count) => {\n             let count = try_const_usize(db, &count).ok_or(LayoutError::UserError(\n                 \"unevaluated or mistyped const generic parameter\".to_string(),\n             ))? as u64;\n-            let element = layout_of_ty(db, element, krate)?;\n+            let element = db.layout_of_ty(element.clone(), krate)?;\n             let size = element.size.checked_mul(count, dl).ok_or(LayoutError::SizeOverflow)?;\n \n             let abi = if count != 0 && matches!(element.abi, Abi::Uninhabited) {\n@@ -172,7 +176,7 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             }\n         }\n         TyKind::Slice(element) => {\n-            let element = layout_of_ty(db, element, krate)?;\n+            let element = db.layout_of_ty(element.clone(), krate)?;\n             Layout {\n                 variants: Variants::Single { index: struct_variant_idx() },\n                 fields: FieldsShape::Array { stride: element.size, count: 0 },\n@@ -206,7 +210,7 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n                 }\n                 _ => {\n                     // pointee is sized\n-                    return Ok(Layout::scalar(dl, data_ptr));\n+                    return Ok(Arc::new(Layout::scalar(dl, data_ptr)));\n                 }\n             };\n \n@@ -248,7 +252,7 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             match impl_trait_id {\n                 crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n                     let infer = db.infer(func.into());\n-                    layout_of_ty(db, &infer.type_of_rpit[idx], krate)?\n+                    return db.layout_of_ty(infer.type_of_rpit[idx].clone(), krate);\n                 }\n                 crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n                     return Err(LayoutError::NotImplemented)\n@@ -262,14 +266,13 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n             let fields = captures\n                 .iter()\n                 .map(|x| {\n-                    layout_of_ty(\n-                        db,\n-                        &x.ty.clone().substitute(Interner, ClosureSubst(subst).parent_subst()),\n+                    db.layout_of_ty(\n+                        x.ty.clone().substitute(Interner, ClosureSubst(subst).parent_subst()),\n                         krate,\n                     )\n                 })\n                 .collect::<Result<Vec<_>, _>>()?;\n-            let fields = fields.iter().collect::<Vec<_>>();\n+            let fields = fields.iter().map(|x| &**x).collect::<Vec<_>>();\n             let fields = fields.iter().collect::<Vec<_>>();\n             cx.univariant(dl, &fields, &ReprOptions::default(), StructKind::AlwaysSized)\n                 .ok_or(LayoutError::Unknown)?\n@@ -284,7 +287,16 @@ pub fn layout_of_ty(db: &dyn HirDatabase, ty: &Ty, krate: CrateId) -> Result<Lay\n         | TyKind::BoundVar(_)\n         | TyKind::InferenceVar(_, _) => return Err(LayoutError::HasPlaceholder),\n     };\n-    Ok(layout)\n+    Ok(Arc::new(result))\n+}\n+\n+pub fn layout_of_ty_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &Ty,\n+    _: &CrateId,\n+) -> Result<Arc<Layout>, LayoutError> {\n+    user_error!(\"infinite sized recursive type\");\n }\n \n fn layout_of_unit(cx: &LayoutCx<'_>, dl: &TargetDataLayout) -> Result<Layout, LayoutError> {"}, {"sha": "bd2752a7119ab98712a8385905c3ba6c34dc0faf", "filename": "crates/hir-ty/src/layout/adt.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Fadt.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -10,6 +10,7 @@ use hir_def::{\n };\n use la_arena::RawIdx;\n use smallvec::SmallVec;\n+use triomphe::Arc;\n \n use crate::{\n     db::HirDatabase,\n@@ -18,7 +19,7 @@ use crate::{\n     Substitution,\n };\n \n-use super::{layout_of_ty, LayoutCx};\n+use super::LayoutCx;\n \n pub(crate) fn struct_variant_idx() -> RustcEnumVariantIdx {\n     RustcEnumVariantIdx(LocalEnumVariantId::from_raw(RawIdx::from(0)))\n@@ -29,14 +30,14 @@ pub fn layout_of_adt_query(\n     def: AdtId,\n     subst: Substitution,\n     krate: CrateId,\n-) -> Result<Layout, LayoutError> {\n+) -> Result<Arc<Layout>, LayoutError> {\n     let Some(target) = db.target_data_layout(krate) else { return Err(LayoutError::TargetLayoutNotAvailable) };\n     let cx = LayoutCx { krate, target: &target };\n     let dl = cx.current_data_layout();\n     let handle_variant = |def: VariantId, var: &VariantData| {\n         var.fields()\n             .iter()\n-            .map(|(fd, _)| layout_of_ty(db, &field_ty(db, def, fd, &subst), cx.krate))\n+            .map(|(fd, _)| db.layout_of_ty(field_ty(db, def, fd, &subst), cx.krate))\n             .collect::<Result<Vec<_>, _>>()\n     };\n     let (variants, repr) = match def {\n@@ -67,11 +68,13 @@ pub fn layout_of_adt_query(\n             (r, data.repr.unwrap_or_default())\n         }\n     };\n-    let variants =\n-        variants.iter().map(|x| x.iter().collect::<Vec<_>>()).collect::<SmallVec<[_; 1]>>();\n+    let variants = variants\n+        .iter()\n+        .map(|x| x.iter().map(|x| &**x).collect::<Vec<_>>())\n+        .collect::<SmallVec<[_; 1]>>();\n     let variants = variants.iter().map(|x| x.iter().collect()).collect();\n-    if matches!(def, AdtId::UnionId(..)) {\n-        cx.layout_of_union(&repr, &variants).ok_or(LayoutError::Unknown)\n+    let result = if matches!(def, AdtId::UnionId(..)) {\n+        cx.layout_of_union(&repr, &variants).ok_or(LayoutError::Unknown)?\n     } else {\n         cx.layout_of_struct_or_enum(\n             &repr,\n@@ -103,8 +106,9 @@ pub fn layout_of_adt_query(\n                     .and_then(|x| x.last().map(|x| x.is_unsized()))\n                     .unwrap_or(true),\n         )\n-        .ok_or(LayoutError::SizeOverflow)\n-    }\n+        .ok_or(LayoutError::SizeOverflow)?\n+    };\n+    Ok(Arc::new(result))\n }\n \n fn layout_scalar_valid_range(db: &dyn HirDatabase, def: AdtId) -> (Bound<u128>, Bound<u128>) {\n@@ -129,7 +133,7 @@ pub fn layout_of_adt_recover(\n     _: &AdtId,\n     _: &Substitution,\n     _: &CrateId,\n-) -> Result<Layout, LayoutError> {\n+) -> Result<Arc<Layout>, LayoutError> {\n     user_error!(\"infinite sized recursive type\");\n }\n "}, {"sha": "fca2e09ff0a996be4c8af257384f65d778f0c0ad", "filename": "crates/hir-ty/src/layout/tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flayout%2Ftests.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -3,6 +3,7 @@ use std::collections::HashMap;\n use base_db::fixture::WithFixture;\n use chalk_ir::{AdtId, TyKind};\n use hir_def::db::DefDatabase;\n+use triomphe::Arc;\n \n use crate::{\n     db::HirDatabase,\n@@ -11,15 +12,13 @@ use crate::{\n     Interner, Substitution,\n };\n \n-use super::layout_of_ty;\n-\n mod closure;\n \n fn current_machine_data_layout() -> String {\n     project_model::target_data_layout::get(None, None, &HashMap::default()).unwrap()\n }\n \n-fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Arc<Layout>, LayoutError> {\n     let target_data_layout = current_machine_data_layout();\n     let ra_fixture = format!(\n         \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\n{ra_fixture}\",\n@@ -47,11 +46,11 @@ fn eval_goal(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n         })\n         .unwrap();\n     let goal_ty = TyKind::Adt(AdtId(adt_id), Substitution::empty(Interner)).intern(Interner);\n-    layout_of_ty(&db, &goal_ty, module_id.krate())\n+    db.layout_of_ty(goal_ty, module_id.krate())\n }\n \n /// A version of `eval_goal` for types that can not be expressed in ADTs, like closures and `impl Trait`\n-fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n+fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Arc<Layout>, LayoutError> {\n     let target_data_layout = current_machine_data_layout();\n     let ra_fixture = format!(\n         \"{minicore}//- /main.rs crate:test target_data_layout:{target_data_layout}\\nfn main(){{let goal = {{{ra_fixture}}};}}\",\n@@ -75,7 +74,7 @@ fn eval_expr(ra_fixture: &str, minicore: &str) -> Result<Layout, LayoutError> {\n     let b = hir_body.bindings.iter().find(|x| x.1.name.to_smol_str() == \"goal\").unwrap().0;\n     let infer = db.infer(adt_id.into());\n     let goal_ty = infer.type_of_binding[b].clone();\n-    layout_of_ty(&db, &goal_ty, module_id.krate())\n+    db.layout_of_ty(goal_ty, module_id.krate())\n }\n \n #[track_caller]"}, {"sha": "6fa3d1351a9167dfe83a4a449d77c40ed6e1dd8c", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -782,7 +782,9 @@ fn find_matching_impl(\n                 .into_iter()\n                 .map(|b| b.cast(Interner));\n             let goal = crate::Goal::all(Interner, wcs);\n-            table.try_obligation(goal).map(|_| (impl_data, table.resolve_completely(impl_substs)))\n+            table.try_obligation(goal.clone())?;\n+            table.register_obligation(goal);\n+            Some((impl_data, table.resolve_completely(impl_substs)))\n         })\n     })\n }"}, {"sha": "2345bab0bb4df4f859cfe5394fd5097b69fa4747", "filename": "crates/hir-ty/src/mir.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -19,12 +19,17 @@ mod eval;\n mod lower;\n mod borrowck;\n mod pretty;\n+mod monomorphization;\n \n pub use borrowck::{borrowck_query, BorrowckResult, MutabilityReason};\n pub use eval::{interpret_mir, pad16, Evaluator, MirEvalError, VTableMap};\n pub use lower::{\n     lower_to_mir, mir_body_for_closure_query, mir_body_query, mir_body_recover, MirLowerError,\n };\n+pub use monomorphization::{\n+    monomorphize_mir_body_bad, monomorphized_mir_body_for_closure_query,\n+    monomorphized_mir_body_query, monomorphized_mir_body_recover,\n+};\n use smallvec::{smallvec, SmallVec};\n use stdx::{impl_from, never};\n \n@@ -37,7 +42,7 @@ fn return_slot() -> LocalId {\n     LocalId::from_raw(RawIdx::from(0))\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Local {\n     pub ty: Ty,\n }\n@@ -780,7 +785,6 @@ pub enum CastKind {\n     FloatToInt,\n     FloatToFloat,\n     IntToFloat,\n-    PtrToPtr,\n     FnPtrToPtr,\n }\n \n@@ -952,7 +956,7 @@ pub struct Statement {\n     pub span: MirSpan,\n }\n \n-#[derive(Debug, Default, PartialEq, Eq)]\n+#[derive(Debug, Default, Clone, PartialEq, Eq)]\n pub struct BasicBlock {\n     /// List of statements in this block.\n     pub statements: Vec<Statement>,\n@@ -974,7 +978,7 @@ pub struct BasicBlock {\n     pub is_cleanup: bool,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct MirBody {\n     pub basic_blocks: Arena<BasicBlock>,\n     pub locals: Arena<Local>,"}, {"sha": "28e7759db39a12e7cb23937585c05180aaea0584", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 75, "deletions": 243, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -3,20 +3,17 @@\n use std::{borrow::Cow, collections::HashMap, fmt::Write, iter, ops::Range};\n \n use base_db::{CrateId, FileId};\n-use chalk_ir::{\n-    fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n-    DebruijnIndex, Mutability, ProjectionTy,\n-};\n+use chalk_ir::Mutability;\n use either::Either;\n use hir_def::{\n     builtin_type::BuiltinType,\n     data::adt::{StructFlags, VariantData},\n     lang_item::{lang_attr, LangItem},\n     layout::{TagEncoding, Variants},\n-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, GeneralConstId, HasModule, ItemContainerId,\n-    Lookup, StaticId, TypeOrConstParamId, VariantId,\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, StaticId,\n+    VariantId,\n };\n-use hir_expand::{name::Name, InFile};\n+use hir_expand::InFile;\n use intern::Interned;\n use la_arena::ArenaMap;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -27,14 +24,13 @@ use crate::{\n     consteval::{intern_const_scalar, try_const_usize, ConstEvalError},\n     db::HirDatabase,\n     display::{ClosureStyle, HirDisplay},\n-    from_placeholder_idx,\n-    infer::{normalize, PointerCast},\n-    layout::{layout_of_ty, Layout, LayoutError, RustcEnumVariantIdx},\n+    infer::PointerCast,\n+    layout::{Layout, LayoutError, RustcEnumVariantIdx},\n     mapping::from_chalk,\n-    method_resolution::{is_dyn_method, lookup_impl_const, lookup_impl_method},\n+    method_resolution::{is_dyn_method, lookup_impl_method},\n     name, static_lifetime,\n     traits::FnTrait,\n-    utils::{generics, ClosureSubst, Generics},\n+    utils::ClosureSubst,\n     CallableDefId, ClosureId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap,\n     Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind,\n };\n@@ -279,7 +275,6 @@ pub enum MirEvalError {\n     /// Means that code had undefined behavior. We don't try to actively detect UB, but if it was detected\n     /// then use this type of error.\n     UndefinedBehavior(String),\n-    GenericArgNotProvided(TypeOrConstParamId, Substitution),\n     Panic(String),\n     MirLowerError(FunctionId, MirLowerError),\n     MirLowerErrorForClosure(ClosureId, MirLowerError),\n@@ -348,20 +343,6 @@ impl MirEvalError {\n                     ty.display(db).with_closure_style(ClosureStyle::ClosureWithId).to_string()\n                 )?;\n             }\n-            MirEvalError::GenericArgNotProvided(id, subst) => {\n-                let parent = id.parent;\n-                let param = &db.generic_params(parent).type_or_consts[id.local_id];\n-                writeln!(\n-                    f,\n-                    \"Generic arg not provided for {}\",\n-                    param.name().unwrap_or(&Name::missing()).display(db.upcast())\n-                )?;\n-                writeln!(f, \"Provided args: [\")?;\n-                for g in subst.iter(Interner) {\n-                    write!(f, \"    {},\", g.display(db).to_string())?;\n-                }\n-                writeln!(f, \"]\")?;\n-            }\n             MirEvalError::MirLowerError(func, err) => {\n                 let function_name = db.function_data(*func);\n                 writeln!(\n@@ -416,7 +397,6 @@ impl std::fmt::Debug for MirEvalError {\n             Self::TypeIsUnsized(ty, it) => write!(f, \"{ty:?} is unsized. {it} should be sized.\"),\n             Self::ExecutionLimitExceeded => write!(f, \"execution limit exceeded\"),\n             Self::StackOverflow => write!(f, \"stack overflow\"),\n-            Self::GenericArgNotProvided(..) => f.debug_tuple(\"GenericArgNotProvided\").finish(),\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n@@ -471,14 +451,12 @@ impl DropFlags {\n struct Locals<'a> {\n     ptr: &'a ArenaMap<LocalId, Interval>,\n     body: &'a MirBody,\n-    subst: &'a Substitution,\n     drop_flags: DropFlags,\n }\n \n pub fn interpret_mir(\n     db: &dyn HirDatabase,\n     body: &MirBody,\n-    subst: Substitution,\n     // FIXME: This is workaround. Ideally, const generics should have a separate body (issue #7434), but now\n     // they share their body with their parent, so in MIR lowering we have locals of the parent body, which\n     // might have placeholders. With this argument, we (wrongly) assume that every placeholder type has\n@@ -489,17 +467,11 @@ pub fn interpret_mir(\n     let ty = body.locals[return_slot()].ty.clone();\n     let mut evaluator = Evaluator::new(db, body, assert_placeholder_ty_is_unused);\n     let x: Result<Const> = (|| {\n-        let ty = evaluator.ty_filler(&ty, &subst, body.owner)?;\n-        let bytes = evaluator.interpret_mir(&body, None.into_iter(), subst.clone())?;\n+        let bytes = evaluator.interpret_mir(&body, None.into_iter())?;\n         let mut memory_map = evaluator.create_memory_map(\n             &bytes,\n             &ty,\n-            &Locals {\n-                ptr: &ArenaMap::new(),\n-                body: &body,\n-                subst: &subst,\n-                drop_flags: DropFlags::default(),\n-            },\n+            &Locals { ptr: &ArenaMap::new(), body: &body, drop_flags: DropFlags::default() },\n         )?;\n         memory_map.vtable = evaluator.vtable_map.clone();\n         return Ok(intern_const_scalar(ConstScalar::Bytes(bytes, memory_map), ty));\n@@ -565,8 +537,7 @@ impl Evaluator<'_> {\n         locals: &'a Locals<'a>,\n     ) -> Result<(Address, Ty, Option<IntervalOrOwned>)> {\n         let mut addr = locals.ptr[p.local].addr;\n-        let mut ty: Ty =\n-            self.ty_filler(&locals.body.locals[p.local].ty, locals.subst, locals.body.owner)?;\n+        let mut ty: Ty = locals.body.locals[p.local].ty.clone();\n         let mut metadata: Option<IntervalOrOwned> = None; // locals are always sized\n         for proj in &*p.projection {\n             let prev_ty = ty.clone();\n@@ -689,17 +660,13 @@ impl Evaluator<'_> {\n         Ok((addr, ty, metadata))\n     }\n \n-    fn layout(&self, ty: &Ty) -> Result<Layout> {\n-        layout_of_ty(self.db, ty, self.crate_id)\n+    fn layout(&self, ty: &Ty) -> Result<Arc<Layout>> {\n+        self.db\n+            .layout_of_ty(ty.clone(), self.crate_id)\n             .map_err(|e| MirEvalError::LayoutError(e, ty.clone()))\n     }\n \n-    fn layout_filled(&self, ty: &Ty, locals: &Locals<'_>) -> Result<Layout> {\n-        let ty = &self.ty_filler(ty, locals.subst, locals.body.owner)?;\n-        self.layout(ty)\n-    }\n-\n-    fn layout_adt(&self, adt: AdtId, subst: Substitution) -> Result<Layout> {\n+    fn layout_adt(&self, adt: AdtId, subst: Substitution) -> Result<Arc<Layout>> {\n         self.db.layout_of_adt(adt, subst.clone(), self.crate_id).map_err(|e| {\n             MirEvalError::LayoutError(e, TyKind::Adt(chalk_ir::AdtId(adt), subst).intern(Interner))\n         })\n@@ -735,20 +702,15 @@ impl Evaluator<'_> {\n         &mut self,\n         body: &MirBody,\n         args: impl Iterator<Item = Vec<u8>>,\n-        subst: Substitution,\n     ) -> Result<Vec<u8>> {\n         if let Some(x) = self.stack_depth_limit.checked_sub(1) {\n             self.stack_depth_limit = x;\n         } else {\n             return Err(MirEvalError::StackOverflow);\n         }\n         let mut current_block_idx = body.start_block;\n-        let mut locals = Locals {\n-            ptr: &ArenaMap::new(),\n-            body: &body,\n-            subst: &subst,\n-            drop_flags: DropFlags::default(),\n-        };\n+        let mut locals =\n+            Locals { ptr: &ArenaMap::new(), body: &body, drop_flags: DropFlags::default() };\n         let (locals_ptr, stack_size) = {\n             let mut stack_ptr = self.stack.len();\n             let addr = body\n@@ -882,7 +844,17 @@ impl Evaluator<'_> {\n                 }\n                 Owned(r)\n             }\n-            Rvalue::Len(_) => not_supported!(\"rvalue len\"),\n+            Rvalue::Len(p) => {\n+                let (_, _, metadata) = self.place_addr_and_ty_and_metadata(p, locals)?;\n+                match metadata {\n+                    Some(m) => m,\n+                    None => {\n+                        return Err(MirEvalError::TypeError(\n+                            \"type without metadata is used for Rvalue::Len\",\n+                        ));\n+                    }\n+                }\n+            }\n             Rvalue::UnaryOp(op, val) => {\n                 let mut c = self.eval_operand(val, locals)?.get(&self)?;\n                 let mut ty = self.operand_ty(val, locals)?;\n@@ -1080,7 +1052,7 @@ impl Evaluator<'_> {\n                     }\n                     return Ok(Owned(0u128.to_le_bytes().to_vec()));\n                 };\n-                match layout.variants {\n+                match &layout.variants {\n                     Variants::Single { index } => {\n                         let r = self.const_eval_discriminant(EnumVariantId {\n                             parent: enum_id,\n@@ -1102,14 +1074,14 @@ impl Evaluator<'_> {\n                             TagEncoding::Niche { untagged_variant, niche_start, .. } => {\n                                 let tag = &bytes[offset..offset + size];\n                                 let candidate_tag = i128::from_le_bytes(pad16(tag, false))\n-                                    .wrapping_sub(niche_start as i128)\n+                                    .wrapping_sub(*niche_start as i128)\n                                     as usize;\n                                 let variant = variants\n                                     .iter_enumerated()\n                                     .map(|(x, _)| x)\n-                                    .filter(|x| *x != untagged_variant)\n+                                    .filter(|x| x != untagged_variant)\n                                     .nth(candidate_tag)\n-                                    .unwrap_or(untagged_variant)\n+                                    .unwrap_or(*untagged_variant)\n                                     .0;\n                                 let result = self.const_eval_discriminant(EnumVariantId {\n                                     parent: enum_id,\n@@ -1122,7 +1094,7 @@ impl Evaluator<'_> {\n                 }\n             }\n             Rvalue::Repeat(x, len) => {\n-                let len = match try_const_usize(self.db, len) {\n+                let len = match try_const_usize(self.db, &len) {\n                     Some(x) => x as usize,\n                     None => not_supported!(\"non evaluatable array len in repeat Rvalue\"),\n                 };\n@@ -1154,7 +1126,7 @@ impl Evaluator<'_> {\n                         Owned(r)\n                     }\n                     AggregateKind::Tuple(ty) => {\n-                        let layout = self.layout_filled(&ty, locals)?;\n+                        let layout = self.layout(&ty)?;\n                         Owned(self.make_by_layout(\n                             layout.size.bytes_usize(),\n                             &layout,\n@@ -1174,9 +1146,8 @@ impl Evaluator<'_> {\n                         Owned(result)\n                     }\n                     AggregateKind::Adt(x, subst) => {\n-                        let subst = self.subst_filler(subst, locals);\n                         let (size, variant_layout, tag) =\n-                            self.layout_of_variant(*x, subst, locals)?;\n+                            self.layout_of_variant(*x, subst.clone(), locals)?;\n                         Owned(self.make_by_layout(\n                             size,\n                             &variant_layout,\n@@ -1185,7 +1156,7 @@ impl Evaluator<'_> {\n                         )?)\n                     }\n                     AggregateKind::Closure(ty) => {\n-                        let layout = self.layout_filled(&ty, locals)?;\n+                        let layout = self.layout(&ty)?;\n                         Owned(self.make_by_layout(\n                             layout.size.bytes_usize(),\n                             &layout,\n@@ -1220,7 +1191,10 @@ impl Evaluator<'_> {\n                         // This is no-op\n                         Borrowed(self.eval_operand(operand, locals)?)\n                     }\n-                    x => not_supported!(\"pointer cast {x:?}\"),\n+                    PointerCast::ArrayToPointer => {\n+                        // We should remove the metadata part if the current type is slice\n+                        Borrowed(self.eval_operand(operand, locals)?.slice(0..self.ptr_size()))\n+                    }\n                 },\n                 CastKind::DynStar => not_supported!(\"dyn star cast\"),\n                 CastKind::IntToInt\n@@ -1235,12 +1209,6 @@ impl Evaluator<'_> {\n                 CastKind::FloatToInt => not_supported!(\"float to int cast\"),\n                 CastKind::FloatToFloat => not_supported!(\"float to float cast\"),\n                 CastKind::IntToFloat => not_supported!(\"float to int cast\"),\n-                CastKind::PtrToPtr => {\n-                    let current = pad16(self.eval_operand(operand, locals)?.get(&self)?, false);\n-                    let dest_size =\n-                        self.size_of_sized(target_ty, locals, \"destination of ptr to ptr cast\")?;\n-                    Owned(current[0..dest_size].to_vec())\n-                }\n                 CastKind::FnPtrToPtr => not_supported!(\"fn ptr to ptr cast\"),\n             },\n         })\n@@ -1300,8 +1268,8 @@ impl Evaluator<'_> {\n                                 r.extend(len.to_le_bytes().into_iter());\n                                 Owned(r)\n                             }\n-                            _ => {\n-                                not_supported!(\"slice unsizing from non arrays\")\n+                            t => {\n+                                not_supported!(\"slice unsizing from non array type {t:?}\")\n                             }\n                         },\n                     }\n@@ -1327,7 +1295,7 @@ impl Evaluator<'_> {\n         x: VariantId,\n         subst: Substitution,\n         locals: &Locals<'_>,\n-    ) -> Result<(usize, Layout, Option<(usize, usize, i128)>)> {\n+    ) -> Result<(usize, Arc<Layout>, Option<(usize, usize, i128)>)> {\n         let adt = x.adt_id();\n         if let DefWithBodyId::VariantId(f) = locals.body.owner {\n             if let VariantId::EnumVariantId(x) = x {\n@@ -1340,7 +1308,7 @@ impl Evaluator<'_> {\n             }\n         }\n         let layout = self.layout_adt(adt, subst)?;\n-        Ok(match layout.variants {\n+        Ok(match &layout.variants {\n             Variants::Single { .. } => (layout.size.bytes_usize(), layout, None),\n             Variants::Multiple { variants, tag, tag_encoding, .. } => {\n                 let cx = self\n@@ -1357,22 +1325,22 @@ impl Evaluator<'_> {\n                 let have_tag = match tag_encoding {\n                     TagEncoding::Direct => true,\n                     TagEncoding::Niche { untagged_variant, niche_variants: _, niche_start } => {\n-                        if untagged_variant == rustc_enum_variant_idx {\n+                        if *untagged_variant == rustc_enum_variant_idx {\n                             false\n                         } else {\n                             discriminant = (variants\n                                 .iter_enumerated()\n-                                .filter(|(x, _)| *x != untagged_variant)\n+                                .filter(|(x, _)| x != untagged_variant)\n                                 .position(|(x, _)| x == rustc_enum_variant_idx)\n                                 .unwrap() as i128)\n-                                .wrapping_add(niche_start as i128);\n+                                .wrapping_add(*niche_start as i128);\n                             true\n                         }\n                     }\n                 };\n                 (\n                     layout.size.bytes_usize(),\n-                    variant_layout,\n+                    Arc::new(variant_layout),\n                     if have_tag {\n                         Some((\n                             layout.fields.offset(0).bytes_usize(),\n@@ -1419,15 +1387,7 @@ impl Evaluator<'_> {\n             Operand::Constant(konst) => {\n                 let data = &konst.data(Interner);\n                 match &data.value {\n-                    chalk_ir::ConstValue::BoundVar(b) => {\n-                        let c = locals\n-                            .subst\n-                            .as_slice(Interner)\n-                            .get(b.index)\n-                            .ok_or(MirEvalError::TypeError(\"missing generic arg\"))?\n-                            .assert_const_ref(Interner);\n-                        self.eval_operand(&Operand::Constant(c.clone()), locals)?\n-                    }\n+                    chalk_ir::ConstValue::BoundVar(_) => not_supported!(\"bound var constant\"),\n                     chalk_ir::ConstValue::InferenceVar(_) => {\n                         not_supported!(\"inference var constant\")\n                     }\n@@ -1471,29 +1431,8 @@ impl Evaluator<'_> {\n                 self.patch_addresses(&patch_map, &memory_map.vtable, addr, ty, locals)?;\n                 Interval::new(addr, size)\n             }\n-            ConstScalar::UnevaluatedConst(const_id, subst) => {\n-                let mut const_id = *const_id;\n-                let mut subst = self.subst_filler(subst, locals);\n-                if let GeneralConstId::ConstId(c) = const_id {\n-                    let (c, s) = lookup_impl_const(\n-                        self.db,\n-                        self.db.trait_environment_for_body(locals.body.owner),\n-                        c,\n-                        subst,\n-                    );\n-                    const_id = GeneralConstId::ConstId(c);\n-                    subst = s;\n-                }\n-                let c = self.db.const_eval(const_id.into(), subst).map_err(|e| {\n-                    let name = const_id.name(self.db.upcast());\n-                    MirEvalError::ConstEvalError(name, Box::new(e))\n-                })?;\n-                if let chalk_ir::ConstValue::Concrete(c) = &c.data(Interner).value {\n-                    if let ConstScalar::Bytes(_, _) = &c.interned {\n-                        return self.allocate_const_in_heap(&c, ty, locals, konst);\n-                    }\n-                }\n-                not_supported!(\"failing at evaluating unevaluated const\");\n+            ConstScalar::UnevaluatedConst(..) => {\n+                not_supported!(\"unevaluated const present in monomorphized mir\");\n             }\n             ConstScalar::Unknown => not_supported!(\"evaluating unknown const\"),\n         })\n@@ -1555,7 +1494,7 @@ impl Evaluator<'_> {\n                 }\n             }\n         }\n-        let layout = self.layout_filled(ty, locals);\n+        let layout = self.layout(ty);\n         if self.assert_placeholder_ty_is_unused {\n             if matches!(layout, Err(MirEvalError::LayoutError(LayoutError::HasPlaceholder, _))) {\n                 return Ok(Some((0, 1)));\n@@ -1576,122 +1515,12 @@ impl Evaluator<'_> {\n         }\n     }\n \n-    /// Uses `ty_filler` to fill an entire subst\n-    fn subst_filler(&self, subst: &Substitution, locals: &Locals<'_>) -> Substitution {\n-        Substitution::from_iter(\n-            Interner,\n-            subst.iter(Interner).map(|x| match x.data(Interner) {\n-                chalk_ir::GenericArgData::Ty(ty) => {\n-                    let Ok(ty) = self.ty_filler(ty, locals.subst, locals.body.owner) else {\n-                        return x.clone();\n-                    };\n-                    chalk_ir::GenericArgData::Ty(ty).intern(Interner)\n-                }\n-                _ => x.clone(),\n-            }),\n-        )\n-    }\n-\n-    /// This function substitutes placeholders of the body with the provided subst, effectively plays\n-    /// the rule of monomorphization. In addition to placeholders, it substitutes opaque types (return\n-    /// position impl traits) with their underlying type.\n-    fn ty_filler(&self, ty: &Ty, subst: &Substitution, owner: DefWithBodyId) -> Result<Ty> {\n-        struct Filler<'a> {\n-            db: &'a dyn HirDatabase,\n-            subst: &'a Substitution,\n-            generics: Option<Generics>,\n-        }\n-        impl FallibleTypeFolder<Interner> for Filler<'_> {\n-            type Error = MirEvalError;\n-\n-            fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n-                self\n-            }\n-\n-            fn interner(&self) -> Interner {\n-                Interner\n-            }\n-\n-            fn try_fold_ty(\n-                &mut self,\n-                ty: Ty,\n-                outer_binder: DebruijnIndex,\n-            ) -> std::result::Result<Ty, Self::Error> {\n-                match ty.kind(Interner) {\n-                    TyKind::AssociatedType(id, subst) => {\n-                        // I don't know exactly if and why this is needed, but it looks like `normalize_ty` likes\n-                        // this kind of associated types.\n-                        Ok(TyKind::Alias(chalk_ir::AliasTy::Projection(ProjectionTy {\n-                            associated_ty_id: *id,\n-                            substitution: subst.clone().try_fold_with(self, outer_binder)?,\n-                        }))\n-                        .intern(Interner))\n-                    }\n-                    TyKind::OpaqueType(id, subst) => {\n-                        let impl_trait_id = self.db.lookup_intern_impl_trait_id((*id).into());\n-                        let subst = subst.clone().try_fold_with(self.as_dyn(), outer_binder)?;\n-                        match impl_trait_id {\n-                            crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n-                                let infer = self.db.infer(func.into());\n-                                let filler = &mut Filler {\n-                                    db: self.db,\n-                                    subst: &subst,\n-                                    generics: Some(generics(self.db.upcast(), func.into())),\n-                                };\n-                                filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n-                            }\n-                            crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n-                                not_supported!(\"async block impl trait\");\n-                            }\n-                        }\n-                    }\n-                    _ => ty.try_super_fold_with(self.as_dyn(), outer_binder),\n-                }\n-            }\n-\n-            fn try_fold_free_placeholder_ty(\n-                &mut self,\n-                idx: chalk_ir::PlaceholderIndex,\n-                _outer_binder: DebruijnIndex,\n-            ) -> std::result::Result<Ty, Self::Error> {\n-                let x = from_placeholder_idx(self.db, idx);\n-                let Some(idx) = self.generics.as_ref().and_then(|g| g.param_idx(x)) else {\n-                    not_supported!(\"missing idx in generics\");\n-                };\n-                Ok(self\n-                    .subst\n-                    .as_slice(Interner)\n-                    .get(idx)\n-                    .and_then(|x| x.ty(Interner))\n-                    .ok_or_else(|| MirEvalError::GenericArgNotProvided(x, self.subst.clone()))?\n-                    .clone())\n-            }\n-        }\n-        let g_def = match owner {\n-            DefWithBodyId::FunctionId(f) => Some(f.into()),\n-            DefWithBodyId::StaticId(_) => None,\n-            DefWithBodyId::ConstId(f) => Some(f.into()),\n-            DefWithBodyId::VariantId(f) => Some(f.into()),\n-        };\n-        let generics = g_def.map(|g_def| generics(self.db.upcast(), g_def));\n-        let filler = &mut Filler { db: self.db, subst, generics };\n-        Ok(normalize(\n-            self.db,\n-            self.trait_env.clone(),\n-            ty.clone().try_fold_with(filler, DebruijnIndex::INNERMOST)?,\n-        ))\n-    }\n-\n     fn heap_allocate(&mut self, size: usize, _align: usize) -> Address {\n         let pos = self.heap.len();\n         self.heap.extend(iter::repeat(0).take(size));\n         Address::Heap(pos)\n     }\n \n-    pub fn interpret_mir_with_no_arg(&mut self, body: &MirBody) -> Result<Vec<u8>> {\n-        self.interpret_mir(&body, vec![].into_iter(), Substitution::empty(Interner))\n-    }\n-\n     fn detect_fn_trait(&self, def: FunctionId) -> Option<FnTrait> {\n         use LangItem::*;\n         let ItemContainerId::TraitId(parent) = self.db.lookup_intern_function(def).container else {\n@@ -1849,21 +1678,24 @@ impl Evaluator<'_> {\n     ) -> Result<()> {\n         let mir_body = self\n             .db\n-            .mir_body_for_closure(closure)\n+            .monomorphized_mir_body_for_closure(\n+                closure,\n+                generic_args.clone(),\n+                self.trait_env.clone(),\n+            )\n             .map_err(|x| MirEvalError::MirLowerErrorForClosure(closure, x))?;\n-        let arg_bytes = iter::once(Ok(closure_data.get(self)?.to_owned()))\n+        let closure_data = if mir_body.locals[mir_body.param_locals[0]].ty.as_reference().is_some()\n+        {\n+            closure_data.addr.to_bytes()\n+        } else {\n+            closure_data.get(self)?.to_owned()\n+        };\n+        let arg_bytes = iter::once(Ok(closure_data))\n             .chain(args.iter().map(|x| Ok(x.get(&self)?.to_owned())))\n             .collect::<Result<Vec<_>>>()?;\n-        let bytes = self\n-            .interpret_mir(&mir_body, arg_bytes.into_iter(), generic_args.clone())\n-            .map_err(|e| {\n-                MirEvalError::InFunction(\n-                    Either::Right(closure),\n-                    Box::new(e),\n-                    span,\n-                    locals.body.owner,\n-                )\n-            })?;\n+        let bytes = self.interpret_mir(&mir_body, arg_bytes.into_iter()).map_err(|e| {\n+            MirEvalError::InFunction(Either::Right(closure), Box::new(e), span, locals.body.owner)\n+        })?;\n         destination.write_from_bytes(self, &bytes)\n     }\n \n@@ -1877,7 +1709,7 @@ impl Evaluator<'_> {\n         span: MirSpan,\n     ) -> Result<()> {\n         let def: CallableDefId = from_chalk(self.db, def);\n-        let generic_args = self.subst_filler(generic_args, &locals);\n+        let generic_args = generic_args.clone();\n         match def {\n             CallableDefId::FunctionId(def) => {\n                 if let Some(_) = self.detect_fn_trait(def) {\n@@ -1982,14 +1814,14 @@ impl Evaluator<'_> {\n         span: MirSpan,\n         destination: Interval,\n     ) -> Result<()> {\n-        let generic_args = self.subst_filler(&generic_args, &locals);\n         let def = imp.into();\n-        let mir_body = self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n-        let result = self\n-            .interpret_mir(&mir_body, arg_bytes.iter().cloned(), generic_args)\n-            .map_err(|e| {\n-                MirEvalError::InFunction(Either::Left(imp), Box::new(e), span, locals.body.owner)\n-            })?;\n+        let mir_body = self\n+            .db\n+            .monomorphized_mir_body(def, generic_args, self.trait_env.clone())\n+            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+        let result = self.interpret_mir(&mir_body, arg_bytes.iter().cloned()).map_err(|e| {\n+            MirEvalError::InFunction(Either::Left(imp), Box::new(e), span, locals.body.owner)\n+        })?;\n         destination.write_from_bytes(self, &result)?;\n         Ok(())\n     }"}, {"sha": "e05004eeb6a860c0f6409818781ea4f77dd7b77b", "filename": "crates/hir-ty/src/mir/eval/shim.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Fshim.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -1,6 +1,8 @@\n //! Interpret intrinsics, lang items and `extern \"C\"` wellknown functions which their implementation\n //! is not available.\n \n+use std::cmp;\n+\n use super::*;\n \n macro_rules! from_bytes {\n@@ -254,6 +256,7 @@ impl Evaluator<'_> {\n                     }\n                     _ => not_supported!(\"write to arbitrary file descriptor\"),\n                 }\n+                destination.write_from_interval(self, len.interval)?;\n                 Ok(())\n             }\n             \"pthread_key_create\" => {\n@@ -437,7 +440,7 @@ impl Evaluator<'_> {\n                 let Some(ty) = generic_args.as_slice(Interner).get(0).and_then(|x| x.ty(Interner)) else {\n                     return Err(MirEvalError::TypeError(\"align_of generic arg is not provided\"));\n                 };\n-                let align = self.layout_filled(ty, locals)?.align.abi.bytes();\n+                let align = self.layout(ty)?.align.abi.bytes();\n                 destination.write_from_bytes(self, &align.to_le_bytes()[0..destination.size])\n             }\n             \"needs_drop\" => {\n@@ -456,6 +459,22 @@ impl Evaluator<'_> {\n                 let ans = lhs.get(self)? == rhs.get(self)?;\n                 destination.write_from_bytes(self, &[u8::from(ans)])\n             }\n+            \"saturating_add\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"saturating_add args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.saturating_add(rhs);\n+                let bits = destination.size * 8;\n+                // FIXME: signed\n+                let is_signed = false;\n+                let mx: u128 = if is_signed { (1 << (bits - 1)) - 1 } else { (1 << bits) - 1 };\n+                // FIXME: signed\n+                let mn: u128 = 0;\n+                let ans = cmp::min(mx, cmp::max(mn, ans));\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n             \"wrapping_add\" | \"unchecked_add\" => {\n                 let [lhs, rhs] = args else {\n                     return Err(MirEvalError::TypeError(\"wrapping_add args are not provided\"));\n@@ -474,6 +493,15 @@ impl Evaluator<'_> {\n                 let ans = lhs.wrapping_sub(rhs);\n                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n             }\n+            \"wrapping_mul\" | \"unchecked_mul\" => {\n+                let [lhs, rhs] = args else {\n+                    return Err(MirEvalError::TypeError(\"wrapping_mul args are not provided\"));\n+                };\n+                let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n+                let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n+                let ans = lhs.wrapping_mul(rhs);\n+                destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n+            }\n             \"unchecked_rem\" => {\n                 // FIXME: signed\n                 let [lhs, rhs] = args else {\n@@ -498,7 +526,7 @@ impl Evaluator<'_> {\n                 })?;\n                 destination.write_from_bytes(self, &ans.to_le_bytes()[0..destination.size])\n             }\n-            \"add_with_overflow\" => {\n+            \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n                 let [lhs, rhs] = args else {\n                     return Err(MirEvalError::TypeError(\"const_eval_select args are not provided\"));\n                 };\n@@ -511,8 +539,14 @@ impl Evaluator<'_> {\n                     self.size_of_sized(&lhs.ty, locals, \"operand of add_with_overflow\")?;\n                 let lhs = u128::from_le_bytes(pad16(lhs.get(self)?, false));\n                 let rhs = u128::from_le_bytes(pad16(rhs.get(self)?, false));\n-                let ans = lhs.wrapping_add(rhs);\n-                let is_overflow = false;\n+                let (ans, u128overflow) = match as_str {\n+                    \"add_with_overflow\" => lhs.overflowing_add(rhs),\n+                    \"sub_with_overflow\" => lhs.overflowing_sub(rhs),\n+                    \"mul_with_overflow\" => lhs.overflowing_mul(rhs),\n+                    _ => unreachable!(),\n+                };\n+                let is_overflow = u128overflow\n+                    || ans.to_le_bytes()[op_size..].iter().any(|&x| x != 0 && x != 255);\n                 let is_overflow = vec![u8::from(is_overflow)];\n                 let layout = self.layout(&result_ty)?;\n                 let result = self.make_by_layout("}, {"sha": "453c93de8e765dfeeb1456bab66853866e3f3e04", "filename": "crates/hir-ty/src/mir/eval/tests.rs", "status": "modified", "additions": 248, "deletions": 5, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -21,10 +21,15 @@ fn eval_main(db: &TestDB, file_id: FileId) -> Result<(String, String), MirEvalEr\n             }\n             _ => None,\n         })\n-        .unwrap();\n-    let body =\n-        db.mir_body(func_id.into()).map_err(|e| MirEvalError::MirLowerError(func_id.into(), e))?;\n-    let (result, stdout, stderr) = interpret_mir(db, &body, Substitution::empty(Interner), false);\n+        .expect(\"no main function found\");\n+    let body = db\n+        .monomorphized_mir_body(\n+            func_id.into(),\n+            Substitution::empty(Interner),\n+            db.trait_environment(func_id.into()),\n+        )\n+        .map_err(|e| MirEvalError::MirLowerError(func_id.into(), e))?;\n+    let (result, stdout, stderr) = interpret_mir(db, &body, false);\n     result?;\n     Ok((stdout, stderr))\n }\n@@ -34,7 +39,8 @@ fn check_pass(ra_fixture: &str) {\n }\n \n fn check_pass_and_stdio(ra_fixture: &str, expected_stdout: &str, expected_stderr: &str) {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let (db, file_ids) = TestDB::with_many_files(ra_fixture);\n+    let file_id = *file_ids.last().unwrap();\n     let x = eval_main(&db, file_id);\n     match x {\n         Err(e) => {\n@@ -270,6 +276,243 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn from_fn() {\n+    check_pass(\n+        r#\"\n+//- minicore: fn, iterator\n+struct FromFn<F>(F);\n+\n+impl<T, F: FnMut() -> Option<T>> Iterator for FromFn<F> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.0)()\n+    }\n+}\n+\n+fn main() {\n+    let mut tokenize = {\n+        FromFn(move || Some(2))\n+    };\n+    let s = tokenize.next();\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn for_loop() {\n+    check_pass(\n+        r#\"\n+//- minicore: iterator, add\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+struct X;\n+struct XIter(i32);\n+\n+impl IntoIterator for X {\n+    type Item = i32;\n+\n+    type IntoIter = XIter;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        XIter(0)\n+    }\n+}\n+\n+impl Iterator for XIter {\n+    type Item = i32;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.0 == 5 {\n+            None\n+        } else {\n+            self.0 += 1;\n+            Some(self.0)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut s = 0;\n+    for x in X {\n+        s += x;\n+    }\n+    if s != 15 {\n+        should_not_reach();\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn field_with_associated_type() {\n+    check_pass(\n+        r#\"\n+//- /b/mod.rs crate:b\n+pub trait Tr {\n+    fn f(self);\n+}\n+\n+pub trait Tr2 {\n+    type Ty: Tr;\n+}\n+\n+pub struct S<T: Tr2> {\n+    pub t: T::Ty,\n+}\n+\n+impl<T: Tr2> S<T> {\n+    pub fn g(&self) {\n+        let k = (self.t, self.t);\n+        self.t.f();\n+    }\n+}\n+\n+//- /a/mod.rs crate:a deps:b\n+use b::{Tr, Tr2, S};\n+\n+struct A(i32);\n+struct B(u8);\n+\n+impl Tr for A {\n+    fn f(&self) {\n+    }\n+}\n+\n+impl Tr2 for B {\n+    type Ty = A;\n+}\n+\n+#[test]\n+fn main() {\n+    let s: S<B> = S { t: A(2) };\n+    s.g();\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn specialization_array_clone() {\n+    check_pass(\n+        r#\"\n+//- minicore: copy, derive, slice, index, coerce_unsized\n+impl<T: Clone, const N: usize> Clone for [T; N] {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        SpecArrayClone::clone(self)\n+    }\n+}\n+\n+trait SpecArrayClone: Clone {\n+    fn clone<const N: usize>(array: &[Self; N]) -> [Self; N];\n+}\n+\n+impl<T: Clone> SpecArrayClone for T {\n+    #[inline]\n+    default fn clone<const N: usize>(array: &[T; N]) -> [T; N] {\n+        // FIXME: panic here when we actually implement specialization.\n+        from_slice(array)\n+    }\n+}\n+\n+fn from_slice<T, const N: usize>(s: &[T]) -> [T; N] {\n+    [s[0]; N]\n+}\n+\n+impl<T: Copy> SpecArrayClone for T {\n+    #[inline]\n+    fn clone<const N: usize>(array: &[T; N]) -> [T; N] {\n+        *array\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+struct X(i32);\n+\n+fn main() {\n+    let ar = [X(1), X(2)];\n+    ar.clone();\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn short_circuit_operator() {\n+    check_pass(\n+        r#\"\n+fn should_not_reach() -> bool {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn main() {\n+    if false && should_not_reach() {\n+        should_not_reach();\n+    }\n+    true || should_not_reach();\n+\n+}\n+    \"#,\n+    );\n+}\n+\n+#[test]\n+fn closure_state() {\n+    check_pass(\n+        r#\"\n+//- minicore: fn, add, copy\n+fn should_not_reach() {\n+    _ // FIXME: replace this function with panic when that works\n+}\n+\n+fn main() {\n+    let mut x = 2;\n+    let mut c = move || {\n+        x += 1;\n+        x\n+    };\n+    c();\n+    c();\n+    c();\n+    if x != 2 {\n+        should_not_reach();\n+    }\n+    if c() != 6 {\n+        should_not_reach();\n+    }\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn closure_capture_array_const_generic() {\n+    check_pass(\n+        r#\"\n+//- minicore: fn, add, copy\n+struct X(i32);\n+\n+fn f<const N: usize>(mut x: [X; N]) { // -> impl FnOnce() {\n+    let c = || {\n+        x;\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    let s = f([X(1)]);\n+    //s();\n+}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn posix_tls() {\n     check_pass("}, {"sha": "6fe157f45cfe614a726c8fbd7b3e0e537e095bd9", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 123, "deletions": 80, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -8,14 +8,14 @@ use hir_def::{\n     body::Body,\n     data::adt::{StructKind, VariantData},\n     hir::{\n-        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm,\n-        Pat, PatId, RecordFieldPat, RecordLitField,\n+        ArithOp, Array, BinaryOp, BindingAnnotation, BindingId, ExprId, LabelId, Literal,\n+        LiteralOrConst, MatchArm, Pat, PatId, RecordFieldPat, RecordLitField,\n     },\n     lang_item::{LangItem, LangItemTarget},\n     path::Path,\n-    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n+    resolver::{resolver_for_expr, HasResolver, ResolveValueResult, ValueNs},\n     AdtId, DefWithBodyId, EnumVariantId, GeneralConstId, HasModule, ItemContainerId, LocalFieldId,\n-    TraitId,\n+    TraitId, TypeOrConstParamId,\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n@@ -29,9 +29,10 @@ use crate::{\n     display::HirDisplay,\n     infer::{CaptureKind, CapturedItem, TypeMismatch},\n     inhabitedness::is_ty_uninhabited_from,\n-    layout::{layout_of_ty, LayoutError},\n+    layout::LayoutError,\n     mapping::ToChalk,\n     static_lifetime,\n+    traits::FnTrait,\n     utils::{generics, ClosureSubst},\n     Adjust, Adjustment, AutoBorrow, CallableDefId, TyBuilder, TyExt,\n };\n@@ -41,8 +42,6 @@ use super::*;\n mod as_place;\n mod pattern_matching;\n \n-use pattern_matching::AdtPatternShape;\n-\n #[derive(Debug, Clone)]\n struct LoopBlocks {\n     begin: BasicBlockId,\n@@ -74,6 +73,7 @@ pub enum MirLowerError {\n     ConstEvalError(String, Box<ConstEvalError>),\n     LayoutError(LayoutError),\n     IncompleteExpr,\n+    IncompletePattern,\n     /// Trying to lower a trait function, instead of an implementation\n     TraitFunctionDefinition(TraitId, Name),\n     UnresolvedName(String),\n@@ -96,6 +96,9 @@ pub enum MirLowerError {\n     UnresolvedLabel,\n     UnresolvedUpvar(Place),\n     UnaccessableLocal,\n+\n+    // monomorphization errors:\n+    GenericArgNotProvided(TypeOrConstParamId, Substitution),\n }\n \n impl MirLowerError {\n@@ -129,9 +132,24 @@ impl MirLowerError {\n                     e.actual.display(db),\n                 )?;\n             }\n+            MirLowerError::GenericArgNotProvided(id, subst) => {\n+                let parent = id.parent;\n+                let param = &db.generic_params(parent).type_or_consts[id.local_id];\n+                writeln!(\n+                    f,\n+                    \"Generic arg not provided for {}\",\n+                    param.name().unwrap_or(&Name::missing()).display(db.upcast())\n+                )?;\n+                writeln!(f, \"Provided args: [\")?;\n+                for g in subst.iter(Interner) {\n+                    write!(f, \"    {},\", g.display(db).to_string())?;\n+                }\n+                writeln!(f, \"]\")?;\n+            }\n             MirLowerError::LayoutError(_)\n             | MirLowerError::UnsizedTemporary(_)\n             | MirLowerError::IncompleteExpr\n+            | MirLowerError::IncompletePattern\n             | MirLowerError::UnaccessableLocal\n             | MirLowerError::TraitFunctionDefinition(_, _)\n             | MirLowerError::UnresolvedName(_)\n@@ -528,61 +546,6 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                     Ok(())\n                 })\n             }\n-            &Expr::For { iterable, pat, body, label } => {\n-                let into_iter_fn = self.resolve_lang_item(LangItem::IntoIterIntoIter)?\n-                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IntoIterIntoIter))?;\n-                let iter_next_fn = self.resolve_lang_item(LangItem::IteratorNext)?\n-                    .as_function().ok_or(MirLowerError::LangItemNotFound(LangItem::IteratorNext))?;\n-                let option_some = self.resolve_lang_item(LangItem::OptionSome)?\n-                    .as_enum_variant().ok_or(MirLowerError::LangItemNotFound(LangItem::OptionSome))?;\n-                let option = option_some.parent;\n-                let into_iter_fn_op = Operand::const_zst(\n-                    TyKind::FnDef(\n-                        self.db.intern_callable_def(CallableDefId::FunctionId(into_iter_fn)).into(),\n-                        Substitution::from1(Interner, self.expr_ty_without_adjust(iterable))\n-                    ).intern(Interner));\n-                let iter_next_fn_op = Operand::const_zst(\n-                    TyKind::FnDef(\n-                        self.db.intern_callable_def(CallableDefId::FunctionId(iter_next_fn)).into(),\n-                        Substitution::from1(Interner, self.expr_ty_without_adjust(iterable))\n-                    ).intern(Interner));\n-                let &Some(iterator_ty) = &self.infer.type_of_for_iterator.get(&expr_id) else {\n-                    return Err(MirLowerError::TypeError(\"unknown for loop iterator type\"));\n-                };\n-                let ref_mut_iterator_ty = TyKind::Ref(Mutability::Mut, static_lifetime(), iterator_ty.clone()).intern(Interner);\n-                let item_ty = &self.infer.type_of_pat[pat];\n-                let option_item_ty = TyKind::Adt(chalk_ir::AdtId(option.into()), Substitution::from1(Interner, item_ty.clone())).intern(Interner);\n-                let iterator_place: Place = self.temp(iterator_ty.clone(), current, expr_id.into())?.into();\n-                let option_item_place: Place = self.temp(option_item_ty.clone(), current, expr_id.into())?.into();\n-                let ref_mut_iterator_place: Place = self.temp(ref_mut_iterator_ty, current, expr_id.into())?.into();\n-                let Some(current) = self.lower_call_and_args(into_iter_fn_op, Some(iterable).into_iter(), iterator_place.clone(), current, false, expr_id.into())?\n-                else {\n-                    return Ok(None);\n-                };\n-                self.push_assignment(current, ref_mut_iterator_place.clone(), Rvalue::Ref(BorrowKind::Mut { allow_two_phase_borrow: false }, iterator_place), expr_id.into());\n-                self.lower_loop(current, place, label, expr_id.into(), |this, begin| {\n-                    let Some(current) = this.lower_call(iter_next_fn_op, Box::new([Operand::Copy(ref_mut_iterator_place)]), option_item_place.clone(), begin, false, expr_id.into())?\n-                    else {\n-                        return Ok(());\n-                    };\n-                    let end = this.current_loop_end()?;\n-                    let (current, _) = this.pattern_matching_variant(\n-                        option_item_ty.clone(),\n-                        BindingAnnotation::Unannotated,\n-                        option_item_place.into(),\n-                        option_some.into(),\n-                        current,\n-                        pat.into(),\n-                        Some(end),\n-                        AdtPatternShape::Tuple { args: &[pat], ellipsis: None },\n-                    )?;\n-                    if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n-                        let block = this.pop_drop_scope(block);\n-                        this.set_goto(block, begin, expr_id.into());\n-                    }\n-                    Ok(())\n-                })\n-            },\n             Expr::Call { callee, args, .. } => {\n                 if let Some((func_id, generic_args)) =\n                     self.infer.method_resolution(expr_id) {\n@@ -918,6 +881,27 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 let Some((lhs_op, current)) = self.lower_expr_to_some_operand(*lhs, current)? else {\n                     return Ok(None);\n                 };\n+                if let hir_def::hir::BinaryOp::LogicOp(op) = op {\n+                    let value_to_short = match op {\n+                        syntax::ast::LogicOp::And => 0,\n+                        syntax::ast::LogicOp::Or => 1,\n+                    };\n+                    let start_of_then = self.new_basic_block();\n+                    self.push_assignment(start_of_then, place.clone(), lhs_op.clone().into(), expr_id.into());\n+                    let end_of_then = Some(start_of_then);\n+                    let start_of_else = self.new_basic_block();\n+                    let end_of_else =\n+                        self.lower_expr_to_place(*rhs, place, start_of_else)?;\n+                    self.set_terminator(\n+                        current,\n+                        TerminatorKind::SwitchInt {\n+                            discr: lhs_op,\n+                            targets: SwitchTargets::static_if(value_to_short, start_of_then, start_of_else),\n+                        },\n+                        expr_id.into(),\n+                    );\n+                    return Ok(self.merge_blocks(end_of_then, end_of_else, expr_id.into()));\n+                }\n                 let Some((rhs_op, current)) = self.lower_expr_to_some_operand(*rhs, current)? else {\n                     return Ok(None);\n                 };\n@@ -1135,8 +1119,39 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         Ok(())\n     }\n \n+    fn lower_literal_or_const_to_operand(\n+        &mut self,\n+        ty: Ty,\n+        loc: &LiteralOrConst,\n+    ) -> Result<Operand> {\n+        match loc {\n+            LiteralOrConst::Literal(l) => self.lower_literal_to_operand(ty, l),\n+            LiteralOrConst::Const(c) => {\n+                let unresolved_name = || MirLowerError::unresolved_path(self.db, c);\n+                let resolver = self.owner.resolver(self.db.upcast());\n+                let pr = resolver\n+                    .resolve_path_in_value_ns(self.db.upcast(), c)\n+                    .ok_or_else(unresolved_name)?;\n+                match pr {\n+                    ResolveValueResult::ValueNs(v) => {\n+                        if let ValueNs::ConstId(c) = v {\n+                            self.lower_const_to_operand(Substitution::empty(Interner), c.into(), ty)\n+                        } else {\n+                            not_supported!(\"bad path in range pattern\");\n+                        }\n+                    }\n+                    ResolveValueResult::Partial(_, _) => {\n+                        not_supported!(\"associated constants in range pattern\")\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn lower_literal_to_operand(&mut self, ty: Ty, l: &Literal) -> Result<Operand> {\n-        let size = layout_of_ty(self.db, &ty, self.owner.module(self.db.upcast()).krate())?\n+        let size = self\n+            .db\n+            .layout_of_ty(ty.clone(), self.owner.module(self.db.upcast()).krate())?\n             .size\n             .bytes_usize();\n         let bytes = match l {\n@@ -1196,6 +1211,17 @@ impl<'ctx> MirLowerCtx<'ctx> {\n         span: MirSpan,\n         ty: Ty,\n     ) -> Result<()> {\n+        let c = self.lower_const_to_operand(subst, const_id, ty)?;\n+        self.push_assignment(prev_block, place, c.into(), span);\n+        Ok(())\n+    }\n+\n+    fn lower_const_to_operand(\n+        &mut self,\n+        subst: Substitution,\n+        const_id: GeneralConstId,\n+        ty: Ty,\n+    ) -> Result<Operand> {\n         let c = if subst.len(Interner) != 0 {\n             // We can't evaluate constant with substitution now, as generics are not monomorphized in lowering.\n             intern_const_scalar(ConstScalar::UnevaluatedConst(const_id, subst), ty)\n@@ -1205,18 +1231,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n                 .const_eval(const_id.into(), subst)\n                 .map_err(|e| MirLowerError::ConstEvalError(name, Box::new(e)))?\n         };\n-        self.write_const_to_place(c, prev_block, place, span)\n-    }\n-\n-    fn write_const_to_place(\n-        &mut self,\n-        c: Const,\n-        prev_block: BasicBlockId,\n-        place: Place,\n-        span: MirSpan,\n-    ) -> Result<()> {\n-        self.push_assignment(prev_block, place, Operand::Constant(c).into(), span);\n-        Ok(())\n+        Ok(Operand::Constant(c))\n     }\n \n     fn write_bytes_to_place(\n@@ -1673,8 +1688,23 @@ fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n         },\n         (TyKind::Scalar(_), TyKind::Raw(..)) => CastKind::PointerFromExposedAddress,\n         (TyKind::Raw(..), TyKind::Scalar(_)) => CastKind::PointerExposeAddress,\n-        (TyKind::Raw(..) | TyKind::Ref(..), TyKind::Raw(..) | TyKind::Ref(..)) => {\n-            CastKind::PtrToPtr\n+        (TyKind::Raw(_, a) | TyKind::Ref(_, _, a), TyKind::Raw(_, b) | TyKind::Ref(_, _, b)) => {\n+            CastKind::Pointer(if a == b {\n+                PointerCast::MutToConstPointer\n+            } else if matches!(a.kind(Interner), TyKind::Slice(_) | TyKind::Str)\n+                && matches!(b.kind(Interner), TyKind::Slice(_) | TyKind::Str)\n+            {\n+                // slice to slice cast is no-op (metadata is not touched), so we use this\n+                PointerCast::MutToConstPointer\n+            } else if matches!(b.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n+                PointerCast::Unsize\n+            } else if matches!(a.kind(Interner), TyKind::Slice(s) if s == b) {\n+                PointerCast::ArrayToPointer\n+            } else {\n+                // cast between two sized pointer, like *const i32 to *const i8. There is no specific variant\n+                // for it in `PointerCast` so we use `MutToConstPointer`\n+                PointerCast::MutToConstPointer\n+            })\n         }\n         // Enum to int casts\n         (TyKind::Scalar(_), TyKind::Adt(..)) | (TyKind::Adt(..), TyKind::Scalar(_)) => {\n@@ -1697,11 +1727,19 @@ pub fn mir_body_for_closure_query(\n     let TyKind::Closure(_, substs) = &infer[expr].kind(Interner) else {\n         implementation_error!(\"closure expression is not closure\");\n     };\n-    let (captures, _) = infer.closure_info(&closure);\n+    let (captures, kind) = infer.closure_info(&closure);\n     let mut ctx = MirLowerCtx::new(db, owner, &body, &infer);\n     // 0 is return local\n     ctx.result.locals.alloc(Local { ty: infer[*root].clone() });\n-    let closure_local = ctx.result.locals.alloc(Local { ty: infer[expr].clone() });\n+    let closure_local = ctx.result.locals.alloc(Local {\n+        ty: match kind {\n+            FnTrait::FnOnce => infer[expr].clone(),\n+            FnTrait::FnMut => TyKind::Ref(Mutability::Mut, static_lifetime(), infer[expr].clone())\n+                .intern(Interner),\n+            FnTrait::Fn => TyKind::Ref(Mutability::Not, static_lifetime(), infer[expr].clone())\n+                .intern(Interner),\n+        },\n+    });\n     ctx.result.param_locals.push(closure_local);\n     let Some(sig) = ClosureSubst(substs).sig_ty().callable_sig(db) else {\n         implementation_error!(\"closure has not callable sig\");\n@@ -1721,6 +1759,10 @@ pub fn mir_body_for_closure_query(\n     }\n     let mut err = None;\n     let closure_local = ctx.result.locals.iter().nth(1).unwrap().0;\n+    let closure_projection = match kind {\n+        FnTrait::FnOnce => vec![],\n+        FnTrait::FnMut | FnTrait::Fn => vec![ProjectionElem::Deref],\n+    };\n     ctx.result.walk_places(|p| {\n         if let Some(x) = upvar_map.get(&p.local) {\n             let r = x.iter().find(|x| {\n@@ -1743,7 +1785,8 @@ pub fn mir_body_for_closure_query(\n             match r {\n                 Some(x) => {\n                     p.local = closure_local;\n-                    let mut next_projs = vec![PlaceElem::TupleOrClosureField(x.1)];\n+                    let mut next_projs = closure_projection.clone();\n+                    next_projs.push(PlaceElem::TupleOrClosureField(x.1));\n                     let prev_projs = mem::take(&mut p.projection);\n                     if x.0.kind != CaptureKind::ByValue {\n                         next_projs.push(ProjectionElem::Deref);"}, {"sha": "ee2a0306d5ee9f4830c667aa9e387a44685cb22e", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "modified", "additions": 122, "deletions": 48, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -1,6 +1,6 @@\n //! MIR lowering for patterns\n \n-use hir_def::resolver::HasResolver;\n+use hir_def::{hir::LiteralOrConst, resolver::HasResolver, AssocItemId};\n \n use crate::utils::pattern_matching_dereference_count;\n \n@@ -38,7 +38,7 @@ impl MirLowerCtx<'_> {\n         mut binding_mode: BindingAnnotation,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         Ok(match &self.body.pats[pattern] {\n-            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n+            Pat::Missing => return Err(MirLowerError::IncompletePattern),\n             Pat::Wild => (current, current_else),\n             Pat::Tuple { args, ellipsis } => {\n                 pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n@@ -106,9 +106,92 @@ impl MirLowerCtx<'_> {\n                     AdtPatternShape::Record { args: &*args },\n                 )?\n             }\n-            Pat::Range { .. } => not_supported!(\"range pattern\"),\n+            Pat::Range { start, end } => {\n+                let mut add_check = |l: &LiteralOrConst, binop| -> Result<()> {\n+                    let lv = self.lower_literal_or_const_to_operand(cond_ty.clone(), l)?;\n+                    let else_target = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                    let next = self.new_basic_block();\n+                    let discr: Place =\n+                        self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n+                    self.push_assignment(\n+                        current,\n+                        discr.clone(),\n+                        Rvalue::CheckedBinaryOp(binop, lv, Operand::Copy(cond_place.clone())),\n+                        pattern.into(),\n+                    );\n+                    let discr = Operand::Copy(discr);\n+                    self.set_terminator(\n+                        current,\n+                        TerminatorKind::SwitchInt {\n+                            discr,\n+                            targets: SwitchTargets::static_if(1, next, else_target),\n+                        },\n+                        pattern.into(),\n+                    );\n+                    current = next;\n+                    Ok(())\n+                };\n+                if let Some(start) = start {\n+                    add_check(start, BinOp::Le)?;\n+                }\n+                if let Some(end) = end {\n+                    add_check(end, BinOp::Ge)?;\n+                }\n+                (current, current_else)\n+            }\n             Pat::Slice { prefix, slice, suffix } => {\n                 pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                if let TyKind::Slice(_) = cond_ty.kind(Interner) {\n+                    let pattern_len = prefix.len() + suffix.len();\n+                    let place_len: Place =\n+                        self.temp(TyBuilder::usize(), current, pattern.into())?.into();\n+                    self.push_assignment(\n+                        current,\n+                        place_len.clone(),\n+                        Rvalue::Len(cond_place.clone()),\n+                        pattern.into(),\n+                    );\n+                    let else_target = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                    let next = self.new_basic_block();\n+                    if slice.is_none() {\n+                        self.set_terminator(\n+                            current,\n+                            TerminatorKind::SwitchInt {\n+                                discr: Operand::Copy(place_len),\n+                                targets: SwitchTargets::static_if(\n+                                    pattern_len as u128,\n+                                    next,\n+                                    else_target,\n+                                ),\n+                            },\n+                            pattern.into(),\n+                        );\n+                    } else {\n+                        let c = Operand::from_concrete_const(\n+                            pattern_len.to_le_bytes().to_vec(),\n+                            MemoryMap::default(),\n+                            TyBuilder::usize(),\n+                        );\n+                        let discr: Place =\n+                            self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n+                        self.push_assignment(\n+                            current,\n+                            discr.clone(),\n+                            Rvalue::CheckedBinaryOp(BinOp::Le, c, Operand::Copy(place_len)),\n+                            pattern.into(),\n+                        );\n+                        let discr = Operand::Copy(discr);\n+                        self.set_terminator(\n+                            current,\n+                            TerminatorKind::SwitchInt {\n+                                discr,\n+                                targets: SwitchTargets::static_if(1, next, else_target),\n+                            },\n+                            pattern.into(),\n+                        );\n+                    }\n+                    current = next;\n+                }\n                 for (i, &pat) in prefix.iter().enumerate() {\n                     let next_place = cond_place.project(ProjectionElem::ConstantIndex {\n                         offset: i as u64,\n@@ -174,53 +257,44 @@ impl MirLowerCtx<'_> {\n                     let pr = resolver\n                         .resolve_path_in_value_ns(self.db.upcast(), p)\n                         .ok_or_else(unresolved_name)?;\n-                    match pr {\n-                        ResolveValueResult::ValueNs(v) => match v {\n-                            ValueNs::ConstId(c) => {\n-                                let tmp: Place =\n-                                    self.temp(cond_ty.clone(), current, pattern.into())?.into();\n-                                let span = pattern.into();\n-                                self.lower_const(\n-                                    c.into(),\n-                                    current,\n-                                    tmp.clone(),\n-                                    Substitution::empty(Interner),\n-                                    span,\n-                                    cond_ty.clone(),\n-                                )?;\n-                                let tmp2: Place =\n-                                    self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n-                                self.push_assignment(\n-                                    current,\n-                                    tmp2.clone(),\n-                                    Rvalue::CheckedBinaryOp(\n-                                        BinOp::Eq,\n-                                        Operand::Copy(tmp),\n-                                        Operand::Copy(cond_place),\n-                                    ),\n-                                    span,\n-                                );\n-                                let next = self.new_basic_block();\n-                                let else_target =\n-                                    current_else.unwrap_or_else(|| self.new_basic_block());\n-                                self.set_terminator(\n-                                    current,\n-                                    TerminatorKind::SwitchInt {\n-                                        discr: Operand::Copy(tmp2),\n-                                        targets: SwitchTargets::static_if(1, next, else_target),\n-                                    },\n-                                    span,\n-                                );\n-                                (next, Some(else_target))\n+                    let (c, subst) = 'b: {\n+                        if let Some(x) = self.infer.assoc_resolutions_for_pat(pattern) {\n+                            if let AssocItemId::ConstId(c) = x.0 {\n+                                break 'b (c, x.1);\n                             }\n-                            _ => not_supported!(\n-                                \"path in pattern position that is not const or variant\"\n-                            ),\n-                        },\n-                        ResolveValueResult::Partial(_, _) => {\n-                            not_supported!(\"assoc const in patterns\")\n                         }\n-                    }\n+                        if let ResolveValueResult::ValueNs(v) = pr {\n+                            if let ValueNs::ConstId(c) = v {\n+                                break 'b (c, Substitution::empty(Interner));\n+                            }\n+                        }\n+                        not_supported!(\"path in pattern position that is not const or variant\")\n+                    };\n+                    let tmp: Place = self.temp(cond_ty.clone(), current, pattern.into())?.into();\n+                    let span = pattern.into();\n+                    self.lower_const(c.into(), current, tmp.clone(), subst, span, cond_ty.clone())?;\n+                    let tmp2: Place = self.temp(TyBuilder::bool(), current, pattern.into())?.into();\n+                    self.push_assignment(\n+                        current,\n+                        tmp2.clone(),\n+                        Rvalue::CheckedBinaryOp(\n+                            BinOp::Eq,\n+                            Operand::Copy(tmp),\n+                            Operand::Copy(cond_place),\n+                        ),\n+                        span,\n+                    );\n+                    let next = self.new_basic_block();\n+                    let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                    self.set_terminator(\n+                        current,\n+                        TerminatorKind::SwitchInt {\n+                            discr: Operand::Copy(tmp2),\n+                            targets: SwitchTargets::static_if(1, next, else_target),\n+                        },\n+                        span,\n+                    );\n+                    (next, Some(else_target))\n                 }\n             },\n             Pat::Lit(l) => match &self.body.exprs[*l] {"}, {"sha": "b17ac58365699f96442e8576b07cfc4e61cd7508", "filename": "crates/hir-ty/src/mir/monomorphization.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fmonomorphization.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -0,0 +1,369 @@\n+//! Monomorphization of mir, which is used in mir interpreter and const eval.\n+//!\n+//! The job of monomorphization is:\n+//! * Monomorphization. That is, replacing `Option<T>` with `Option<i32>` where `T:=i32` substitution\n+//!   is provided\n+//! * Normalizing types, for example replacing RPIT of other functions called in this body.\n+//!\n+//! So the monomorphization should be called even if the substitution is empty.\n+\n+use std::mem;\n+\n+use chalk_ir::{\n+    fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable},\n+    ConstData, DebruijnIndex,\n+};\n+use hir_def::{DefWithBodyId, GeneralConstId};\n+use triomphe::Arc;\n+\n+use crate::{\n+    consteval::unknown_const,\n+    db::HirDatabase,\n+    from_placeholder_idx,\n+    infer::normalize,\n+    method_resolution::lookup_impl_const,\n+    utils::{generics, Generics},\n+    ClosureId, Const, Interner, ProjectionTy, Substitution, TraitEnvironment, Ty, TyKind,\n+};\n+\n+use super::{MirBody, MirLowerError, Operand, Rvalue, StatementKind, TerminatorKind};\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+struct Filler<'a> {\n+    db: &'a dyn HirDatabase,\n+    trait_env: Arc<TraitEnvironment>,\n+    subst: &'a Substitution,\n+    generics: Option<Generics>,\n+    owner: DefWithBodyId,\n+}\n+impl FallibleTypeFolder<Interner> for Filler<'_> {\n+    type Error = MirLowerError;\n+\n+    fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n+        self\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+\n+    fn try_fold_ty(\n+        &mut self,\n+        ty: Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> std::result::Result<Ty, Self::Error> {\n+        match ty.kind(Interner) {\n+            TyKind::AssociatedType(id, subst) => {\n+                // I don't know exactly if and why this is needed, but it looks like `normalize_ty` likes\n+                // this kind of associated types.\n+                Ok(TyKind::Alias(chalk_ir::AliasTy::Projection(ProjectionTy {\n+                    associated_ty_id: *id,\n+                    substitution: subst.clone().try_fold_with(self, outer_binder)?,\n+                }))\n+                .intern(Interner))\n+            }\n+            TyKind::OpaqueType(id, subst) => {\n+                let impl_trait_id = self.db.lookup_intern_impl_trait_id((*id).into());\n+                let subst = subst.clone().try_fold_with(self.as_dyn(), outer_binder)?;\n+                match impl_trait_id {\n+                    crate::ImplTraitId::ReturnTypeImplTrait(func, idx) => {\n+                        let infer = self.db.infer(func.into());\n+                        let filler = &mut Filler {\n+                            db: self.db,\n+                            owner: self.owner,\n+                            trait_env: self.trait_env.clone(),\n+                            subst: &subst,\n+                            generics: Some(generics(self.db.upcast(), func.into())),\n+                        };\n+                        filler.try_fold_ty(infer.type_of_rpit[idx].clone(), outer_binder)\n+                    }\n+                    crate::ImplTraitId::AsyncBlockTypeImplTrait(_, _) => {\n+                        not_supported!(\"async block impl trait\");\n+                    }\n+                }\n+            }\n+            _ => ty.try_super_fold_with(self.as_dyn(), outer_binder),\n+        }\n+    }\n+\n+    fn try_fold_free_placeholder_const(\n+        &mut self,\n+        _ty: chalk_ir::Ty<Interner>,\n+        idx: chalk_ir::PlaceholderIndex,\n+        _outer_binder: DebruijnIndex,\n+    ) -> std::result::Result<chalk_ir::Const<Interner>, Self::Error> {\n+        let x = from_placeholder_idx(self.db, idx);\n+        let Some(idx) = self.generics.as_ref().and_then(|g| g.param_idx(x)) else {\n+            not_supported!(\"missing idx in generics\");\n+        };\n+        Ok(self\n+            .subst\n+            .as_slice(Interner)\n+            .get(idx)\n+            .and_then(|x| x.constant(Interner))\n+            .ok_or_else(|| MirLowerError::GenericArgNotProvided(x, self.subst.clone()))?\n+            .clone())\n+    }\n+\n+    fn try_fold_free_placeholder_ty(\n+        &mut self,\n+        idx: chalk_ir::PlaceholderIndex,\n+        _outer_binder: DebruijnIndex,\n+    ) -> std::result::Result<Ty, Self::Error> {\n+        let x = from_placeholder_idx(self.db, idx);\n+        let Some(idx) = self.generics.as_ref().and_then(|g| g.param_idx(x)) else {\n+            not_supported!(\"missing idx in generics\");\n+        };\n+        Ok(self\n+            .subst\n+            .as_slice(Interner)\n+            .get(idx)\n+            .and_then(|x| x.ty(Interner))\n+            .ok_or_else(|| MirLowerError::GenericArgNotProvided(x, self.subst.clone()))?\n+            .clone())\n+    }\n+\n+    fn try_fold_const(\n+        &mut self,\n+        constant: chalk_ir::Const<Interner>,\n+        outer_binder: DebruijnIndex,\n+    ) -> Result<chalk_ir::Const<Interner>, Self::Error> {\n+        let next_ty = normalize(\n+            self.db,\n+            self.trait_env.clone(),\n+            constant.data(Interner).ty.clone().try_fold_with(self, outer_binder)?,\n+        );\n+        ConstData { ty: next_ty, value: constant.data(Interner).value.clone() }\n+            .intern(Interner)\n+            .try_super_fold_with(self, outer_binder)\n+    }\n+}\n+\n+impl Filler<'_> {\n+    fn fill_ty(&mut self, ty: &mut Ty) -> Result<(), MirLowerError> {\n+        let tmp = mem::replace(ty, TyKind::Error.intern(Interner));\n+        *ty = normalize(\n+            self.db,\n+            self.trait_env.clone(),\n+            tmp.try_fold_with(self, DebruijnIndex::INNERMOST)?,\n+        );\n+        Ok(())\n+    }\n+\n+    fn fill_const(&mut self, c: &mut Const) -> Result<(), MirLowerError> {\n+        let tmp = mem::replace(c, unknown_const(c.data(Interner).ty.clone()));\n+        *c = tmp.try_fold_with(self, DebruijnIndex::INNERMOST)?;\n+        Ok(())\n+    }\n+\n+    fn fill_subst(&mut self, ty: &mut Substitution) -> Result<(), MirLowerError> {\n+        let tmp = mem::replace(ty, Substitution::empty(Interner));\n+        *ty = tmp.try_fold_with(self, DebruijnIndex::INNERMOST)?;\n+        Ok(())\n+    }\n+\n+    fn fill_operand(&mut self, op: &mut Operand) -> Result<(), MirLowerError> {\n+        match op {\n+            Operand::Constant(c) => {\n+                match &c.data(Interner).value {\n+                    chalk_ir::ConstValue::BoundVar(b) => {\n+                        let resolved = self\n+                            .subst\n+                            .as_slice(Interner)\n+                            .get(b.index)\n+                            .ok_or_else(|| {\n+                                MirLowerError::GenericArgNotProvided(\n+                                    self.generics\n+                                        .as_ref()\n+                                        .and_then(|x| x.iter().nth(b.index))\n+                                        .unwrap()\n+                                        .0,\n+                                    self.subst.clone(),\n+                                )\n+                            })?\n+                            .assert_const_ref(Interner);\n+                        *c = resolved.clone();\n+                    }\n+                    chalk_ir::ConstValue::InferenceVar(_)\n+                    | chalk_ir::ConstValue::Placeholder(_) => {}\n+                    chalk_ir::ConstValue::Concrete(cc) => match &cc.interned {\n+                        crate::ConstScalar::UnevaluatedConst(const_id, subst) => {\n+                            let mut const_id = *const_id;\n+                            let mut subst = subst.clone();\n+                            self.fill_subst(&mut subst)?;\n+                            if let GeneralConstId::ConstId(c) = const_id {\n+                                let (c, s) = lookup_impl_const(\n+                                    self.db,\n+                                    self.db.trait_environment_for_body(self.owner),\n+                                    c,\n+                                    subst,\n+                                );\n+                                const_id = GeneralConstId::ConstId(c);\n+                                subst = s;\n+                            }\n+                            let result =\n+                                self.db.const_eval(const_id.into(), subst).map_err(|e| {\n+                                    let name = const_id.name(self.db.upcast());\n+                                    MirLowerError::ConstEvalError(name, Box::new(e))\n+                                })?;\n+                            *c = result;\n+                        }\n+                        crate::ConstScalar::Bytes(_, _) | crate::ConstScalar::Unknown => (),\n+                    },\n+                }\n+                self.fill_const(c)?;\n+            }\n+            Operand::Copy(_) | Operand::Move(_) | Operand::Static(_) => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn fill_body(&mut self, body: &mut MirBody) -> Result<(), MirLowerError> {\n+        for (_, l) in body.locals.iter_mut() {\n+            self.fill_ty(&mut l.ty)?;\n+        }\n+        for (_, bb) in body.basic_blocks.iter_mut() {\n+            for statement in &mut bb.statements {\n+                match &mut statement.kind {\n+                    StatementKind::Assign(_, r) => match r {\n+                        Rvalue::Aggregate(ak, ops) => {\n+                            for op in &mut **ops {\n+                                self.fill_operand(op)?;\n+                            }\n+                            match ak {\n+                                super::AggregateKind::Array(ty)\n+                                | super::AggregateKind::Tuple(ty)\n+                                | super::AggregateKind::Closure(ty) => self.fill_ty(ty)?,\n+                                super::AggregateKind::Adt(_, subst) => self.fill_subst(subst)?,\n+                                super::AggregateKind::Union(_, _) => (),\n+                            }\n+                        }\n+                        Rvalue::ShallowInitBox(_, ty) | Rvalue::ShallowInitBoxWithAlloc(ty) => {\n+                            self.fill_ty(ty)?;\n+                        }\n+                        Rvalue::Use(op) => {\n+                            self.fill_operand(op)?;\n+                        }\n+                        Rvalue::Repeat(op, len) => {\n+                            self.fill_operand(op)?;\n+                            self.fill_const(len)?;\n+                        }\n+                        Rvalue::Ref(_, _)\n+                        | Rvalue::Len(_)\n+                        | Rvalue::Cast(_, _, _)\n+                        | Rvalue::CheckedBinaryOp(_, _, _)\n+                        | Rvalue::UnaryOp(_, _)\n+                        | Rvalue::Discriminant(_)\n+                        | Rvalue::CopyForDeref(_) => (),\n+                    },\n+                    StatementKind::Deinit(_)\n+                    | StatementKind::StorageLive(_)\n+                    | StatementKind::StorageDead(_)\n+                    | StatementKind::Nop => (),\n+                }\n+            }\n+            if let Some(terminator) = &mut bb.terminator {\n+                match &mut terminator.kind {\n+                    TerminatorKind::Call { func, args, .. } => {\n+                        self.fill_operand(func)?;\n+                        for op in &mut **args {\n+                            self.fill_operand(op)?;\n+                        }\n+                    }\n+                    TerminatorKind::SwitchInt { discr, .. } => {\n+                        self.fill_operand(discr)?;\n+                    }\n+                    TerminatorKind::Goto { .. }\n+                    | TerminatorKind::Resume\n+                    | TerminatorKind::Abort\n+                    | TerminatorKind::Return\n+                    | TerminatorKind::Unreachable\n+                    | TerminatorKind::Drop { .. }\n+                    | TerminatorKind::DropAndReplace { .. }\n+                    | TerminatorKind::Assert { .. }\n+                    | TerminatorKind::Yield { .. }\n+                    | TerminatorKind::GeneratorDrop\n+                    | TerminatorKind::FalseEdge { .. }\n+                    | TerminatorKind::FalseUnwind { .. } => (),\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+pub fn monomorphized_mir_body_query(\n+    db: &dyn HirDatabase,\n+    owner: DefWithBodyId,\n+    subst: Substitution,\n+    trait_env: Arc<crate::TraitEnvironment>,\n+) -> Result<Arc<MirBody>, MirLowerError> {\n+    let g_def = match owner {\n+        DefWithBodyId::FunctionId(f) => Some(f.into()),\n+        DefWithBodyId::StaticId(_) => None,\n+        DefWithBodyId::ConstId(f) => Some(f.into()),\n+        DefWithBodyId::VariantId(f) => Some(f.into()),\n+    };\n+    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n+    let body = db.mir_body(owner)?;\n+    let mut body = (*body).clone();\n+    filler.fill_body(&mut body)?;\n+    Ok(Arc::new(body))\n+}\n+\n+pub fn monomorphized_mir_body_recover(\n+    _: &dyn HirDatabase,\n+    _: &[String],\n+    _: &DefWithBodyId,\n+    _: &Substitution,\n+    _: &Arc<crate::TraitEnvironment>,\n+) -> Result<Arc<MirBody>, MirLowerError> {\n+    return Err(MirLowerError::Loop);\n+}\n+\n+pub fn monomorphized_mir_body_for_closure_query(\n+    db: &dyn HirDatabase,\n+    closure: ClosureId,\n+    subst: Substitution,\n+    trait_env: Arc<crate::TraitEnvironment>,\n+) -> Result<Arc<MirBody>, MirLowerError> {\n+    let (owner, _) = db.lookup_intern_closure(closure.into());\n+    let g_def = match owner {\n+        DefWithBodyId::FunctionId(f) => Some(f.into()),\n+        DefWithBodyId::StaticId(_) => None,\n+        DefWithBodyId::ConstId(f) => Some(f.into()),\n+        DefWithBodyId::VariantId(f) => Some(f.into()),\n+    };\n+    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n+    let body = db.mir_body_for_closure(closure)?;\n+    let mut body = (*body).clone();\n+    filler.fill_body(&mut body)?;\n+    Ok(Arc::new(body))\n+}\n+\n+// FIXME: remove this function. Monomorphization is a time consuming job and should always be a query.\n+pub fn monomorphize_mir_body_bad(\n+    db: &dyn HirDatabase,\n+    mut body: MirBody,\n+    subst: Substitution,\n+    trait_env: Arc<crate::TraitEnvironment>,\n+) -> Result<MirBody, MirLowerError> {\n+    let owner = body.owner;\n+    let g_def = match owner {\n+        DefWithBodyId::FunctionId(f) => Some(f.into()),\n+        DefWithBodyId::StaticId(_) => None,\n+        DefWithBodyId::ConstId(f) => Some(f.into()),\n+        DefWithBodyId::VariantId(f) => Some(f.into()),\n+    };\n+    let generics = g_def.map(|g_def| generics(db.upcast(), g_def));\n+    let filler = &mut Filler { db, subst: &subst, trait_env, generics, owner };\n+    filler.fill_body(&mut body)?;\n+    Ok(body)\n+}"}, {"sha": "58662b01b99b190221a2f9f0fd889e7f17cb9349", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -437,6 +437,6 @@ impl<'a> MirPrettyCtx<'a> {\n     }\n \n     fn hir_display<T: HirDisplay>(&self, ty: &'a T) -> impl Display + 'a {\n-        ty.display(self.db).with_closure_style(ClosureStyle::ClosureWithId)\n+        ty.display(self.db).with_closure_style(ClosureStyle::ClosureWithSubst)\n     }\n }"}, {"sha": "111ac0b618eb2d32f90e5dc69042ceb62734a911", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -140,6 +140,7 @@ fn infer_path_qualified_macros_expanded() {\n fn expr_macro_def_expanded_in_various_places() {\n     check_infer(\n         r#\"\n+        //- minicore: iterator\n         macro spam() {\n             1isize\n         }\n@@ -195,8 +196,17 @@ fn expr_macro_def_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             39..442 '{     ...!(); }': ()\n             73..94 'spam!(...am!())': {unknown}\n+            100..119 'for _ ...!() {}': fn into_iter<isize>(isize) -> <isize as IntoIterator>::IntoIter\n+            100..119 'for _ ...!() {}': IntoIterator::IntoIter<isize>\n+            100..119 'for _ ...!() {}': !\n+            100..119 'for _ ...!() {}': IntoIterator::IntoIter<isize>\n+            100..119 'for _ ...!() {}': &mut IntoIterator::IntoIter<isize>\n+            100..119 'for _ ...!() {}': fn next<IntoIterator::IntoIter<isize>>(&mut IntoIterator::IntoIter<isize>) -> Option<<IntoIterator::IntoIter<isize> as Iterator>::Item>\n+            100..119 'for _ ...!() {}': Option<Iterator::Item<IntoIterator::IntoIter<isize>>>\n             100..119 'for _ ...!() {}': ()\n-            104..105 '_': {unknown}\n+            100..119 'for _ ...!() {}': ()\n+            100..119 'for _ ...!() {}': ()\n+            104..105 '_': Iterator::Item<IntoIterator::IntoIter<isize>>\n             117..119 '{}': ()\n             124..134 '|| spam!()': impl Fn() -> isize\n             140..156 'while ...!() {}': ()\n@@ -221,6 +231,7 @@ fn expr_macro_def_expanded_in_various_places() {\n fn expr_macro_rules_expanded_in_various_places() {\n     check_infer(\n         r#\"\n+        //- minicore: iterator\n         macro_rules! spam {\n             () => (1isize);\n         }\n@@ -276,8 +287,17 @@ fn expr_macro_rules_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             53..456 '{     ...!(); }': ()\n             87..108 'spam!(...am!())': {unknown}\n+            114..133 'for _ ...!() {}': fn into_iter<isize>(isize) -> <isize as IntoIterator>::IntoIter\n+            114..133 'for _ ...!() {}': IntoIterator::IntoIter<isize>\n+            114..133 'for _ ...!() {}': !\n+            114..133 'for _ ...!() {}': IntoIterator::IntoIter<isize>\n+            114..133 'for _ ...!() {}': &mut IntoIterator::IntoIter<isize>\n+            114..133 'for _ ...!() {}': fn next<IntoIterator::IntoIter<isize>>(&mut IntoIterator::IntoIter<isize>) -> Option<<IntoIterator::IntoIter<isize> as Iterator>::Item>\n+            114..133 'for _ ...!() {}': Option<Iterator::Item<IntoIterator::IntoIter<isize>>>\n+            114..133 'for _ ...!() {}': ()\n+            114..133 'for _ ...!() {}': ()\n             114..133 'for _ ...!() {}': ()\n-            118..119 '_': {unknown}\n+            118..119 '_': Iterator::Item<IntoIterator::IntoIter<isize>>\n             131..133 '{}': ()\n             138..148 '|| spam!()': impl Fn() -> isize\n             154..170 'while ...!() {}': ()"}, {"sha": "59046c0435a3a5ef95b6f921d9b26b1f600a0269", "filename": "crates/hir-ty/src/tests/never_type.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -327,6 +327,7 @@ fn diverging_expression_2() {\n fn diverging_expression_3_break() {\n     check_infer_with_mismatches(\n         r\"\n+        //- minicore: iterator\n         //- /main.rs\n         fn test1() {\n             // should give type mismatch\n@@ -360,19 +361,46 @@ fn diverging_expression_3_break() {\n             97..343 '{     ...; }; }': ()\n             140..141 'x': u32\n             149..175 '{ for ...; }; }': u32\n+            151..172 'for a ...eak; }': fn into_iter<{unknown}>({unknown}) -> <{unknown} as IntoIterator>::IntoIter\n+            151..172 'for a ...eak; }': {unknown}\n+            151..172 'for a ...eak; }': !\n+            151..172 'for a ...eak; }': {unknown}\n+            151..172 'for a ...eak; }': &mut {unknown}\n+            151..172 'for a ...eak; }': fn next<{unknown}>(&mut {unknown}) -> Option<<{unknown} as Iterator>::Item>\n+            151..172 'for a ...eak; }': Option<{unknown}>\n+            151..172 'for a ...eak; }': ()\n+            151..172 'for a ...eak; }': ()\n             151..172 'for a ...eak; }': ()\n             155..156 'a': {unknown}\n             160..161 'b': {unknown}\n             162..172 '{ break; }': ()\n             164..169 'break': !\n             226..227 'x': u32\n             235..253 '{ for ... {}; }': u32\n+            237..250 'for a in b {}': fn into_iter<{unknown}>({unknown}) -> <{unknown} as IntoIterator>::IntoIter\n+            237..250 'for a in b {}': {unknown}\n+            237..250 'for a in b {}': !\n+            237..250 'for a in b {}': {unknown}\n+            237..250 'for a in b {}': &mut {unknown}\n+            237..250 'for a in b {}': fn next<{unknown}>(&mut {unknown}) -> Option<<{unknown} as Iterator>::Item>\n+            237..250 'for a in b {}': Option<{unknown}>\n+            237..250 'for a in b {}': ()\n+            237..250 'for a in b {}': ()\n             237..250 'for a in b {}': ()\n             241..242 'a': {unknown}\n             246..247 'b': {unknown}\n             248..250 '{}': ()\n             304..305 'x': u32\n             313..340 '{ for ...; }; }': u32\n+            315..337 'for a ...urn; }': fn into_iter<{unknown}>({unknown}) -> <{unknown} as IntoIterator>::IntoIter\n+            315..337 'for a ...urn; }': {unknown}\n+            315..337 'for a ...urn; }': !\n+            315..337 'for a ...urn; }': {unknown}\n+            315..337 'for a ...urn; }': &mut {unknown}\n+            315..337 'for a ...urn; }': fn next<{unknown}>(&mut {unknown}) -> Option<<{unknown} as Iterator>::Item>\n+            315..337 'for a ...urn; }': Option<{unknown}>\n+            315..337 'for a ...urn; }': ()\n+            315..337 'for a ...urn; }': ()\n             315..337 'for a ...urn; }': ()\n             319..320 'a': {unknown}\n             324..325 'b': {unknown}"}, {"sha": "d683113d5d65e7f844392c66653e0ccd5f2dfac2", "filename": "crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -6,6 +6,7 @@ use super::{check, check_infer, check_infer_with_mismatches, check_no_mismatches\n fn infer_pattern() {\n     check_infer(\n         r#\"\n+        //- minicore: iterator\n         fn test(x: &i32) {\n             let y = x;\n             let &z = x;\n@@ -46,6 +47,15 @@ fn infer_pattern() {\n             82..94 '(1, \"hello\")': (i32, &str)\n             83..84 '1': i32\n             86..93 '\"hello\"': &str\n+            101..151 'for (e...     }': fn into_iter<{unknown}>({unknown}) -> <{unknown} as IntoIterator>::IntoIter\n+            101..151 'for (e...     }': {unknown}\n+            101..151 'for (e...     }': !\n+            101..151 'for (e...     }': {unknown}\n+            101..151 'for (e...     }': &mut {unknown}\n+            101..151 'for (e...     }': fn next<{unknown}>(&mut {unknown}) -> Option<<{unknown} as Iterator>::Item>\n+            101..151 'for (e...     }': Option<({unknown}, {unknown})>\n+            101..151 'for (e...     }': ()\n+            101..151 'for (e...     }': ()\n             101..151 'for (e...     }': ()\n             105..111 '(e, f)': ({unknown}, {unknown})\n             106..107 'e': {unknown}"}, {"sha": "a7b0f46e5e54a7ab318f6feab586c2b34e20832e", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -246,6 +246,7 @@ fn infer_std_crash_5() {\n     // taken from rustc\n     check_infer(\n         r#\"\n+        //- minicore: iterator\n         fn extra_compiler_flags() {\n             for content in doesnt_matter {\n                 let name = if doesnt_matter {\n@@ -264,6 +265,15 @@ fn infer_std_crash_5() {\n         \"#,\n         expect![[r#\"\n             26..322 '{     ...   } }': ()\n+            32..320 'for co...     }': fn into_iter<{unknown}>({unknown}) -> <{unknown} as IntoIterator>::IntoIter\n+            32..320 'for co...     }': {unknown}\n+            32..320 'for co...     }': !\n+            32..320 'for co...     }': {unknown}\n+            32..320 'for co...     }': &mut {unknown}\n+            32..320 'for co...     }': fn next<{unknown}>(&mut {unknown}) -> Option<<{unknown} as Iterator>::Item>\n+            32..320 'for co...     }': Option<{unknown}>\n+            32..320 'for co...     }': ()\n+            32..320 'for co...     }': ()\n             32..320 'for co...     }': ()\n             36..43 'content': {unknown}\n             47..60 'doesnt_matter': {unknown}\n@@ -1215,6 +1225,7 @@ fn mamba(a: U32!(), p: u32) -> u32 {\n fn for_loop_block_expr_iterable() {\n     check_infer(\n         r#\"\n+//- minicore: iterator\n fn test() {\n     for _ in { let x = 0; } {\n         let y = 0;\n@@ -1223,8 +1234,17 @@ fn test() {\n         \"#,\n         expect![[r#\"\n             10..68 '{     ...   } }': ()\n+            16..66 'for _ ...     }': fn into_iter<()>(()) -> <() as IntoIterator>::IntoIter\n+            16..66 'for _ ...     }': IntoIterator::IntoIter<()>\n+            16..66 'for _ ...     }': !\n+            16..66 'for _ ...     }': IntoIterator::IntoIter<()>\n+            16..66 'for _ ...     }': &mut IntoIterator::IntoIter<()>\n+            16..66 'for _ ...     }': fn next<IntoIterator::IntoIter<()>>(&mut IntoIterator::IntoIter<()>) -> Option<<IntoIterator::IntoIter<()> as Iterator>::Item>\n+            16..66 'for _ ...     }': Option<Iterator::Item<IntoIterator::IntoIter<()>>>\n+            16..66 'for _ ...     }': ()\n+            16..66 'for _ ...     }': ()\n             16..66 'for _ ...     }': ()\n-            20..21 '_': {unknown}\n+            20..21 '_': Iterator::Item<IntoIterator::IntoIter<()>>\n             25..39 '{ let x = 0; }': ()\n             31..32 'x': i32\n             35..36 '0': i32"}, {"sha": "38add4eda1ad02f9b5d9195127ac31ec05688a8e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -62,7 +62,7 @@ use hir_ty::{\n     consteval::{try_const_usize, unknown_const_as_generic, ConstEvalError, ConstExt},\n     diagnostics::BodyValidationDiagnostic,\n     display::HexifiedConst,\n-    layout::{layout_of_ty, Layout, LayoutError, RustcEnumVariantIdx, TagEncoding},\n+    layout::{Layout, LayoutError, RustcEnumVariantIdx, TagEncoding},\n     method_resolution::{self, TyFingerprint},\n     mir::{self, interpret_mir},\n     primitive::UintTy,\n@@ -961,8 +961,8 @@ impl Field {\n         Type::new(db, var_id, ty)\n     }\n \n-    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n-        layout_of_ty(db, &self.ty(db).ty, self.parent.module(db).krate().into())\n+    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Arc<Layout>, LayoutError> {\n+        db.layout_of_ty(self.ty(db).ty.clone(), self.parent.module(db).krate().into())\n     }\n \n     pub fn parent_def(&self, _db: &dyn HirDatabase) -> VariantDef {\n@@ -1135,7 +1135,7 @@ impl Enum {\n         self.variants(db).iter().any(|v| !matches!(v.kind(db), StructKind::Unit))\n     }\n \n-    pub fn layout(self, db: &dyn HirDatabase) -> Result<(Layout, usize), LayoutError> {\n+    pub fn layout(self, db: &dyn HirDatabase) -> Result<(Arc<Layout>, usize), LayoutError> {\n         let layout = Adt::from(self).layout(db)?;\n         let tag_size =\n             if let layout::Variants::Multiple { tag, tag_encoding, .. } = &layout.variants {\n@@ -1219,11 +1219,11 @@ impl Variant {\n         let parent_enum = self.parent_enum(db);\n         let (parent_layout, tag_size) = parent_enum.layout(db)?;\n         Ok((\n-            match parent_layout.variants {\n+            match &parent_layout.variants {\n                 layout::Variants::Multiple { variants, .. } => {\n                     variants[RustcEnumVariantIdx(self.id)].clone()\n                 }\n-                _ => parent_layout,\n+                _ => (*parent_layout).clone(),\n             },\n             tag_size,\n         ))\n@@ -1255,7 +1255,7 @@ impl Adt {\n         })\n     }\n \n-    pub fn layout(self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n+    pub fn layout(self, db: &dyn HirDatabase) -> Result<Arc<Layout>, LayoutError> {\n         if db.generic_params(self.into()).iter().count() != 0 {\n             return Err(LayoutError::HasPlaceholder);\n         }\n@@ -1949,16 +1949,19 @@ impl Function {\n         db: &dyn HirDatabase,\n         span_formatter: impl Fn(FileId, TextRange) -> String,\n     ) -> String {\n-        let body = match db.mir_body(self.id.into()) {\n+        let body = match db.monomorphized_mir_body(\n+            self.id.into(),\n+            Substitution::empty(Interner),\n+            db.trait_environment(self.id.into()),\n+        ) {\n             Ok(body) => body,\n             Err(e) => {\n                 let mut r = String::new();\n                 _ = e.pretty_print(&mut r, db, &span_formatter);\n                 return r;\n             }\n         };\n-        let (result, stdout, stderr) =\n-            interpret_mir(db, &body, Substitution::empty(Interner), false);\n+        let (result, stdout, stderr) = interpret_mir(db, &body, false);\n         let mut text = match result {\n             Ok(_) => \"pass\".to_string(),\n             Err(e) => {\n@@ -4240,8 +4243,8 @@ impl Type {\n             .collect()\n     }\n \n-    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Layout, LayoutError> {\n-        layout_of_ty(db, &self.ty, self.env.krate)\n+    pub fn layout(&self, db: &dyn HirDatabase) -> Result<Arc<Layout>, LayoutError> {\n+        db.layout_of_ty(self.ty.clone(), self.env.krate)\n     }\n }\n "}, {"sha": "7587aea55cfa3246c961e116759458fbd07aaaa7", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -4728,6 +4728,7 @@ const fn $0fun_name() {\n         check_assist(\n             extract_function,\n             r#\"\n+//- minicore: iterator\n fn foo() {\n     let mut x = 5;\n     for _ in 0..10 {\n@@ -4751,6 +4752,7 @@ fn $0fun_name(x: &mut i32) {\n         check_assist(\n             extract_function,\n             r#\"\n+//- minicore: iterator\n fn foo() {\n     for _ in 0..10 {\n         let mut x = 5;\n@@ -4774,6 +4776,7 @@ fn $0fun_name(mut x: i32) {\n         check_assist(\n             extract_function,\n             r#\"\n+//- minicore: iterator\n fn foo() {\n     loop {\n         let mut x = 5;"}, {"sha": "2c6cbf6146a956cb6c8d67479d97b6098379a62a", "filename": "crates/ide-completion/src/completions/lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -329,6 +329,7 @@ fn foo() {\n     fn complete_label_in_for_iterable() {\n         check(\n             r#\"\n+//- minicore: iterator\n fn foo() {\n     'outer: for _ in [{ 'inner: loop { break '$0 } }] {}\n }"}, {"sha": "30576c71fb7c2b9132d8c5ab34b820a5258d1356", "filename": "crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -124,12 +124,14 @@ fn foo() {\n \n     #[test]\n     fn value_break_in_for_loop() {\n+        // FIXME: the error is correct, but the message is terrible\n         check_diagnostics(\n             r#\"\n+//- minicore: iterator\n fn test() {\n     for _ in [()] {\n         break 3;\n-     // ^^^^^^^ error: can't break with a value in this position\n+           // ^ error: expected (), found i32\n     }\n }\n \"#,"}, {"sha": "887d18b989a14f48fd34d3b7e0f79ba739de8d1e", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51368793b462306724eafa7d9fb0797329b671f3/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=51368793b462306724eafa7d9fb0797329b671f3", "patch": "@@ -1137,5 +1137,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1170);\n+    assert_eq!(hash, 1169);\n }"}]}