{"sha": "c09eaea484c8f7a01741188982447eec88b5caa8", "node_id": "C_kwDOAAsO6NoAKGMwOWVhZWE0ODRjOGY3YTAxNzQxMTg4OTgyNDQ3ZWVjODhiNWNhYTg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-28T19:23:10Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-09T21:14:59Z"}, "message": "Make index_hir incremental.", "tree": {"sha": "c21ceb83af9ea65b04e38d26488ff23579d4c378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c21ceb83af9ea65b04e38d26488ff23579d4c378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c09eaea484c8f7a01741188982447eec88b5caa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c09eaea484c8f7a01741188982447eec88b5caa8", "html_url": "https://github.com/rust-lang/rust/commit/c09eaea484c8f7a01741188982447eec88b5caa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c09eaea484c8f7a01741188982447eec88b5caa8/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed3c8e86cbface5f050b8911b0de02c196d840eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed3c8e86cbface5f050b8911b0de02c196d840eb", "html_url": "https://github.com/rust-lang/rust/commit/ed3c8e86cbface5f050b8911b0de02c196d840eb"}], "stats": {"total": 257, "additions": 115, "deletions": 142}, "files": [{"sha": "b7bdc9a1414ace1b9d8264a3f2ceb1adab2b715e", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -92,6 +92,12 @@ impl DefPathTable {\n             .iter_enumerated()\n             .map(move |(index, key)| (index, key, &self.def_path_hashes[index]))\n     }\n+\n+    pub fn all_def_path_hashes_and_def_ids(\n+        &self,\n+    ) -> impl Iterator<Item = (&DefPathHash, DefIndex)> + '_ {\n+        self.def_path_hashes.iter_enumerated().map(move |(index, hash)| (hash, index))\n+    }\n }\n \n /// The definition table containing node definitions."}, {"sha": "2986e8c7a06db2b38fb0e5d24f98c64ec43e3c00", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -93,10 +93,7 @@ macro_rules! arena_types {\n             [] predicates: rustc_middle::ty::PredicateInner<$tcx>,\n \n             // HIR query types\n-            [few] indexed_hir: rustc_middle::hir::IndexedHir<$tcx>,\n-            [few] hir_definitions: rustc_hir::definitions::Definitions,\n-            [] hir_owner: rustc_middle::hir::Owner<$tcx>,\n-            [] hir_owner_nodes: rustc_middle::hir::OwnerNodes<$tcx>,\n+            [] indexed_hir: rustc_middle::hir::IndexedHir<$tcx>,\n \n             // Note that this deliberately duplicates items in the `rustc_hir::arena`,\n             // since we need to allocate this type on both the `rustc_hir` arena"}, {"sha": "a9e676b9e30f4b1394744919987486f60e9f95e7", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 68, "deletions": 96, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -1,10 +1,8 @@\n-use crate::arena::Arena;\n use crate::hir::map::Map;\n use crate::hir::{IndexedHir, OwnerNodes, ParentedNode};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n@@ -17,21 +15,19 @@ use std::iter::repeat;\n \n /// A visitor that walks over the HIR and collects `Node`s into a HIR map.\n pub(super) struct NodeCollector<'a, 'hir> {\n-    arena: &'hir Arena<'hir>,\n-\n     /// The crate\n     krate: &'hir Crate<'hir>,\n \n     /// Source map\n     source_map: &'a SourceMap,\n \n-    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n-    parenting: FxHashMap<LocalDefId, HirId>,\n+    nodes: OwnerNodes<'hir>,\n+    parenting: FxHashMap<LocalDefId, ItemLocalId>,\n \n     /// The parent of this node\n-    parent_node: hir::HirId,\n+    parent_node: hir::ItemLocalId,\n \n-    current_dep_node_owner: LocalDefId,\n+    owner: LocalDefId,\n \n     definitions: &'a definitions::Definitions,\n }\n@@ -46,53 +42,51 @@ fn insert_vec_map<K: Idx, V: Clone>(map: &mut IndexVec<K, Option<V>>, k: K, v: V\n     map[k] = Some(v);\n }\n \n-impl<'a, 'hir: 'a> NodeCollector<'a, 'hir> {\n-    pub(super) fn root(\n-        sess: &'a Session,\n-        arena: &'hir Arena<'hir>,\n-        krate: &'hir Crate<'hir>,\n-        definitions: &'a definitions::Definitions,\n-    ) -> NodeCollector<'a, 'hir> {\n-        let mut collector = NodeCollector {\n-            arena,\n-            krate,\n-            source_map: sess.source_map(),\n-            parent_node: hir::CRATE_HIR_ID,\n-            current_dep_node_owner: CRATE_DEF_ID,\n-            definitions,\n-            map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n-            parenting: FxHashMap::default(),\n-        };\n-        collector.insert_owner(CRATE_DEF_ID, OwnerNode::Crate(krate.module()));\n-\n-        collector\n-    }\n-\n-    pub(super) fn finalize_and_compute_crate_hash(self) -> IndexedHir<'hir> {\n-        IndexedHir { map: self.map, parenting: self.parenting }\n-    }\n-\n-    fn insert_owner(&mut self, owner: LocalDefId, node: OwnerNode<'hir>) {\n-        let mut nodes = IndexVec::new();\n-        nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: node.into() }));\n-\n-        let info = self.krate.owners[owner].as_ref().unwrap();\n-        let hash = info.hash;\n-        let node_hash = info.node_hash;\n-        let bodies = &info.bodies;\n-\n-        debug_assert!(self.map[owner].is_none());\n-        self.map[owner] = Some(self.arena.alloc(OwnerNodes { hash, node_hash, nodes, bodies }));\n-    }\n+pub(super) fn collect<'a, 'hir: 'a>(\n+    sess: &'a Session,\n+    krate: &'hir Crate<'hir>,\n+    definitions: &'a definitions::Definitions,\n+    owner: LocalDefId,\n+) -> Option<IndexedHir<'hir>> {\n+    let info = krate.owners.get(owner)?.as_ref()?;\n+    let item = info.node;\n+    let mut nodes = IndexVec::new();\n+    nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: item.into() }));\n+    let mut collector = NodeCollector {\n+        krate,\n+        source_map: sess.source_map(),\n+        owner,\n+        parent_node: ItemLocalId::new(0),\n+        definitions,\n+        nodes: OwnerNodes {\n+            hash: info.hash,\n+            node_hash: info.node_hash,\n+            nodes,\n+            bodies: &info.bodies,\n+        },\n+        parenting: FxHashMap::default(),\n+    };\n+\n+    match item {\n+        OwnerNode::Crate(citem) => collector.visit_mod(&citem, citem.inner, hir::CRATE_HIR_ID),\n+        OwnerNode::Item(item) => collector.visit_item(item),\n+        OwnerNode::TraitItem(item) => collector.visit_trait_item(item),\n+        OwnerNode::ImplItem(item) => collector.visit_impl_item(item),\n+        OwnerNode::ForeignItem(item) => collector.visit_foreign_item(item),\n+    };\n+\n+    Some(IndexedHir { nodes: collector.nodes, parenting: collector.parenting })\n+}\n \n+impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n-        debug_assert_eq!(self.current_dep_node_owner, hir_id.owner);\n+        debug_assert_eq!(self.owner, hir_id.owner);\n         debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            if hir_id.owner != self.current_dep_node_owner {\n+            if hir_id.owner != self.owner {\n                 let node_str = match self.definitions.opt_hir_id_to_local_def_id(hir_id) {\n                     Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate_verbose(),\n                     None => format!(\"{:?}\", node),\n@@ -104,62 +98,41 @@ impl<'a, 'hir: 'a> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node_str,\n-                    self.definitions\n-                        .def_path(self.current_dep_node_owner)\n-                        .to_string_no_crate_verbose(),\n-                    self.current_dep_node_owner,\n+                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.owner,\n                     self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n         }\n \n-        let nodes = self.map[hir_id.owner].as_mut().unwrap();\n-\n-        debug_assert_eq!(self.parent_node.owner, self.current_dep_node_owner);\n         insert_vec_map(\n-            &mut nodes.nodes,\n+            &mut self.nodes.nodes,\n             hir_id.local_id,\n-            ParentedNode { parent: self.parent_node.local_id, node: node },\n+            ParentedNode { parent: self.parent_node, node: node },\n         );\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_node_id: HirId, f: F) {\n+        debug_assert_eq!(parent_node_id.owner, self.owner);\n         let parent_node = self.parent_node;\n-        self.parent_node = parent_node_id;\n+        self.parent_node = parent_node_id.local_id;\n         f(self);\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner(&mut self, dep_node_owner: LocalDefId, f: impl FnOnce(&mut Self)) {\n-        let prev_owner = self.current_dep_node_owner;\n-        let prev_parent = self.parent_node;\n-\n-        self.current_dep_node_owner = dep_node_owner;\n-        self.parent_node = HirId::make_owner(dep_node_owner);\n-        f(self);\n-        self.current_dep_node_owner = prev_owner;\n-        self.parent_node = prev_parent;\n-    }\n-\n     fn insert_nested(&mut self, item: LocalDefId) {\n-        #[cfg(debug_assertions)]\n-        {\n-            let dk_parent = self.definitions.def_key(item).parent.unwrap();\n-            let dk_parent = LocalDefId { local_def_index: dk_parent };\n-            let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n-            debug_assert_eq!(\n-                dk_parent.owner, self.parent_node.owner,\n-                \"Different parents for {:?}\",\n-                item\n-            )\n+        let dk_parent = self.definitions.def_key(item).parent.unwrap();\n+        let dk_parent = LocalDefId { local_def_index: dk_parent };\n+        let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n+        debug_assert_eq!(dk_parent.owner, self.owner, \"Different parents for {:?}\", item);\n+        if dk_parent.local_id != self.parent_node {\n+            self.parenting.insert(item, self.parent_node);\n         }\n-\n-        assert_eq!(self.parenting.insert(item, self.parent_node), None);\n     }\n }\n \n-impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n+impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     type Map = Map<'hir>;\n \n     /// Because we want to track parent items and so forth, enable\n@@ -173,26 +146,24 @@ impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n         self.insert_nested(item.def_id);\n-        self.visit_item(self.krate.item(item));\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n         self.insert_nested(item_id.def_id);\n-        self.visit_trait_item(self.krate.trait_item(item_id));\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n         self.insert_nested(item_id.def_id);\n-        self.visit_impl_item(self.krate.impl_item(item_id));\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n         self.insert_nested(foreign_id.def_id);\n-        self.visit_foreign_item(self.krate.foreign_item(foreign_id));\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        self.visit_body(self.krate.body(id));\n+        let body = self.krate.body(id);\n+        debug_assert_eq!(id.hir_id.owner, self.owner);\n+        self.visit_body(body);\n     }\n \n     fn visit_param(&mut self, param: &'hir Param<'hir>) {\n@@ -205,8 +176,8 @@ impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.insert_owner(i.def_id, OwnerNode::Item(i));\n-        self.with_dep_node_owner(i.def_id, |this| {\n+        debug_assert_eq!(i.def_id, self.owner);\n+        self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n@@ -218,8 +189,8 @@ impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        self.insert_owner(fi.def_id, OwnerNode::ForeignItem(fi));\n-        self.with_dep_node_owner(fi.def_id, |this| {\n+        debug_assert_eq!(fi.def_id, self.owner);\n+        self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n     }\n@@ -236,15 +207,15 @@ impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        self.insert_owner(ti.def_id, OwnerNode::TraitItem(ti));\n-        self.with_dep_node_owner(ti.def_id, |this| {\n+        debug_assert_eq!(ti.def_id, self.owner);\n+        self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        self.insert_owner(ii.def_id, OwnerNode::ImplItem(ii));\n-        self.with_dep_node_owner(ii.def_id, |this| {\n+        debug_assert_eq!(ii.def_id, self.owner);\n+        self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });\n     }\n@@ -332,7 +303,8 @@ impl<'a, 'hir: 'a> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         s: Span,\n         id: HirId,\n     ) {\n-        assert_eq!(self.parent_node, id);\n+        assert_eq!(self.owner, id.owner);\n+        assert_eq!(self.parent_node, id.local_id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n "}, {"sha": "1a63cc1d8fedd044178fe12dbc9f540205000174", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -1,5 +1,3 @@\n-use self::collector::NodeCollector;\n-\n use crate::hir::{IndexedHir, ModuleItems, Owner};\n use crate::ty::TyCtxt;\n use rustc_ast as ast;\n@@ -318,7 +316,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id).unwrap_or(CRATE_HIR_ID)\n+        self.find_parent_node(hir_id).unwrap()\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n@@ -1067,36 +1065,30 @@ impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     }\n }\n \n-pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx IndexedHir<'tcx> {\n-    let _prof_timer = tcx.sess.prof.generic_activity(\"build_hir_map\");\n-\n-    // We can access untracked state since we are an eval_always query.\n-    let mut collector = NodeCollector::root(\n+pub(super) fn index_hir<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    owner: LocalDefId,\n+) -> Option<&'tcx IndexedHir<'tcx>> {\n+    let map = collector::collect(\n         tcx.sess,\n-        &**tcx.arena,\n         tcx.untracked_crate,\n         &tcx.untracked_resolutions.definitions,\n-    );\n-    let top_mod = tcx.untracked_crate.module();\n-    collector.visit_mod(top_mod, top_mod.inner, CRATE_HIR_ID);\n+        owner,\n+    )?;\n \n-    let map = collector.finalize_and_compute_crate_hash();\n-    tcx.arena.alloc(map)\n+    Some(&*tcx.arena.alloc(map))\n }\n \n pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-\n-    // We can access untracked state since we are an eval_always query.\n-    let mut hcx = tcx.create_stable_hashing_context();\n-\n+    debug_assert_eq!(crate_num, LOCAL_CRATE);\n     let mut hir_body_nodes: Vec<_> = tcx\n-        .index_hir(())\n-        .map\n-        .iter_enumerated()\n-        .filter_map(|(def_id, hod)| {\n-            let def_path_hash = tcx.untracked_resolutions.definitions.def_path_hash(def_id);\n-            let hash = hod.as_ref()?.hash;\n+        .untracked_resolutions\n+        .definitions\n+        .def_path_table()\n+        .all_def_path_hashes_and_def_ids()\n+        .filter_map(|(def_path_hash, local_def_index)| {\n+            let def_id = LocalDefId { local_def_index };\n+            let hash = tcx.index_hir(def_id).as_ref()?.nodes.hash;\n             Some((def_path_hash, hash, def_id))\n         })\n         .collect();\n@@ -1120,6 +1112,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n \n     source_file_names.sort_unstable();\n \n+    let mut hcx = tcx.create_stable_hashing_context();\n     let mut stable_hasher = StableHasher::new();\n     for (def_path_hash, fingerprint, def_id) in hir_body_nodes.iter() {\n         def_path_hash.0.hash_stable(&mut hcx, &mut stable_hasher);"}, {"sha": "2ac647307184eb244872bbe30647ad1743fd0c02", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -19,16 +19,13 @@ use rustc_query_system::ich::StableHashingContext;\n use rustc_span::DUMMY_SP;\n use std::collections::BTreeMap;\n \n-/// Result of HIR indexing.\n-#[derive(Debug)]\n+/// Result of HIR indexing for a given HIR owner.\n+#[derive(Debug, HashStable)]\n pub struct IndexedHir<'hir> {\n-    /// Contents of the HIR owned by each definition. None for definitions that are not HIR owners.\n-    // The `mut` comes from construction time, and is harmless since we only ever hand out\n-    // immutable refs to IndexedHir.\n-    map: IndexVec<LocalDefId, Option<&'hir mut OwnerNodes<'hir>>>,\n-    /// Map from each owner to its parent's HirId inside another owner.\n-    // This map is separate from `map` to eventually allow for per-owner indexing.\n-    parenting: FxHashMap<LocalDefId, HirId>,\n+    /// Contents of the HIR.\n+    nodes: OwnerNodes<'hir>,\n+    /// Map from each nested owner to its parent's local id.\n+    parenting: FxHashMap<LocalDefId, ItemLocalId>,\n }\n \n /// Top-level HIR node for current owner. This only contains the node for which\n@@ -132,15 +129,24 @@ pub fn provide(providers: &mut Providers) {\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.index_hir(()).map[id].as_ref()?;\n-        let node = owner.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let owner = tcx.index_hir(id)?;\n+        let node = owner.nodes.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n         let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n-        Some(Owner { node, node_hash: owner.node_hash })\n+        Some(Owner { node, node_hash: owner.nodes.node_hash })\n     };\n-    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();\n+    providers.hir_owner_nodes = |tcx, id| tcx.index_hir(id).map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n-        let index = tcx.index_hir(());\n-        index.parenting.get(&id).copied().unwrap_or(CRATE_HIR_ID)\n+        let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n+        let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n+            let def_id = LocalDefId { local_def_index };\n+            let mut parent_hir_id =\n+                tcx.untracked_resolutions.definitions.local_def_id_to_hir_id(def_id);\n+            if let Some(local_id) = tcx.index_hir(parent_hir_id.owner).unwrap().parenting.get(&id) {\n+                parent_hir_id.local_id = *local_id;\n+            }\n+            parent_hir_id\n+        });\n+        parent\n     };\n     providers.hir_attrs = |tcx, id| AttributeMap::new(&tcx.hir_crate(()).owners[id]);\n     providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);"}, {"sha": "bfded8f710ac81d009447ca1d3b3eaa9a52eb78c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c09eaea484c8f7a01741188982447eec88b5caa8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c09eaea484c8f7a01741188982447eec88b5caa8", "patch": "@@ -42,9 +42,8 @@ rustc_queries! {\n \n     /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n     /// Avoid calling this query directly.\n-    query index_hir(_: ()) -> &'tcx crate::hir::IndexedHir<'tcx> {\n+    query index_hir(_: LocalDefId) -> Option<&'tcx crate::hir::IndexedHir<'tcx>> {\n         eval_always\n-        no_hash\n         desc { \"index HIR\" }\n     }\n "}]}