{"sha": "c64b73e520fccd31a4500b2526a56f6521323568", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NGI3M2U1MjBmY2NkMzFhNDUwMGIyNTI2YTU2ZjY1MjEzMjM1Njg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T18:58:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-02T18:58:10Z"}, "message": "rollup merge of #21817: edwardw/symmetric-binop\n\nFor \"symmetric\" binary operators, meaning the types of two sides must be\nequal, if the type of LHS doesn't know yet but RHS does, use that as an\nhint to infer LHS' type.\n\nCloses #21634", "tree": {"sha": "4c4a998c81fec0afd2d956ff1f6f299fae5264ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c4a998c81fec0afd2d956ff1f6f299fae5264ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c64b73e520fccd31a4500b2526a56f6521323568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c64b73e520fccd31a4500b2526a56f6521323568", "html_url": "https://github.com/rust-lang/rust/commit/c64b73e520fccd31a4500b2526a56f6521323568", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c64b73e520fccd31a4500b2526a56f6521323568/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22fdf97035990f544a44e53db3ad31bf938a9b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/22fdf97035990f544a44e53db3ad31bf938a9b98", "html_url": "https://github.com/rust-lang/rust/commit/22fdf97035990f544a44e53db3ad31bf938a9b98"}, {"sha": "60fa1ff347588027c4a1786b978f386447c35016", "url": "https://api.github.com/repos/rust-lang/rust/commits/60fa1ff347588027c4a1786b978f386447c35016", "html_url": "https://github.com/rust-lang/rust/commit/60fa1ff347588027c4a1786b978f386447c35016"}], "stats": {"total": 99, "additions": 80, "deletions": 19}, "files": [{"sha": "2b4bded76a1805adb24b80a4bc28f8af60d41fde", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c64b73e520fccd31a4500b2526a56f6521323568/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64b73e520fccd31a4500b2526a56f6521323568/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c64b73e520fccd31a4500b2526a56f6521323568", "patch": "@@ -2858,11 +2858,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             BinopAssignment => PreferMutLvalue,\n             SimpleBinop => NoPreference\n         };\n-        check_expr_with_lvalue_pref(fcx, &*lhs, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n \n         // Callee does bot / err checking\n-        let lhs_t = structurally_resolved_type(fcx, lhs.span,\n-                                               fcx.expr_ty(&*lhs));\n+        let lhs_t =\n+            structurally_resolve_type_or_else(fcx, lhs.span, fcx.expr_ty(lhs), || {\n+                if ast_util::is_symmetric_binop(op.node) {\n+                    // Try RHS first\n+                    check_expr(fcx, &**rhs);\n+                    fcx.expr_ty(&**rhs)\n+                } else {\n+                    fcx.tcx().types.err\n+                }\n+            });\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n@@ -5114,28 +5122,45 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-// Resolves `typ` by a single level if `typ` is a type variable.  If no\n-// resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                            sp: Span,\n-                                            ty: Ty<'tcx>)\n-                                            -> Ty<'tcx>\n+fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  sp: Span,\n+                                                  ty: Ty<'tcx>,\n+                                                  f: F) -> Ty<'tcx>\n+    where F: Fn() -> Ty<'tcx>\n {\n     let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n-    // If not, error.\n     if ty::type_is_ty_var(ty) {\n-        fcx.type_error_message(sp, |_actual| {\n-            \"the type of this value must be known in this \\\n-             context\".to_string()\n-        }, ty, None);\n-        demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n-        ty = fcx.tcx().types.err;\n+        let alternative = f();\n+\n+        // If not, error.\n+        if ty::type_is_ty_var(alternative) || ty::type_is_error(alternative) {\n+            fcx.type_error_message(sp, |_actual| {\n+                \"the type of this value must be known in this context\".to_string()\n+            }, ty, None);\n+            demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n+            ty = fcx.tcx().types.err;\n+        } else {\n+            demand::suptype(fcx, sp, alternative, ty);\n+            ty = alternative;\n+        }\n     }\n \n     ty\n }\n \n+// Resolves `typ` by a single level if `typ` is a type variable.  If no\n+// resolution is possible, then an error is reported.\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    structurally_resolve_type_or_else(fcx, sp, ty, || {\n+        fcx.tcx().types.err\n+    })\n+}\n+\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "bd4a9f8efde4c9a2af13b8e1553dafef7cea05b6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c64b73e520fccd31a4500b2526a56f6521323568/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64b73e520fccd31a4500b2526a56f6521323568/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c64b73e520fccd31a4500b2526a56f6521323568", "patch": "@@ -102,6 +102,20 @@ pub fn is_by_value_binop(b: BinOp_) -> bool {\n     }\n }\n \n+/// Returns `true` if the binary operator is symmetric in the sense that LHS\n+/// and RHS must have the same type. So the type of LHS can serve as an hint\n+/// for the type of RHS and vice versa.\n+pub fn is_symmetric_binop(b: BinOp_) -> bool {\n+    match b {\n+        BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+        BiBitXor | BiBitAnd | BiBitOr |\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => {\n+            true\n+        }\n+        _ => false\n+    }\n+}\n+\n /// Returns `true` if the unary operator takes its argument by value\n pub fn is_by_value_unop(u: UnOp) -> bool {\n     match u {"}, {"sha": "b35d5131c781aa24f9a5354754b74d68a922c678", "filename": "src/test/compile-fail/associated-types-ICE-when-projecting-out-of-err.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-ICE-when-projecting-out-of-err.rs?ref=c64b73e520fccd31a4500b2526a56f6521323568", "patch": "@@ -29,6 +29,6 @@ trait Add<RHS=Self> {\n \n fn ice<A>(a: A) {\n     let r = loop {};\n-    r = r + a; // here the type `r` is not yet inferred, hence `r+a` generates an error.\n-    //~^ ERROR type of this value must be known\n+    r = r + a;\n+    //~^ ERROR binary operation `+` cannot be applied to type `A`\n }"}, {"sha": "4852dfc9a02bc7cc5f2312a5ca32191fba39491a", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=c64b73e520fccd31a4500b2526a56f6521323568", "patch": "@@ -16,7 +16,7 @@ impl<A> vec_monad<A> for Vec<A> {\n     fn bind<B, F>(&self, mut f: F) where F: FnMut(A) -> Vec<B> {\n         let mut r = panic!();\n         for elt in self.iter() { r = r + f(*elt); }\n-        //~^ ERROR the type of this value must be known\n+        //~^ ERROR binary operation `+` cannot be applied to type `collections::vec::Vec<B>`\n    }\n }\n fn main() {"}, {"sha": "e5a2790917ff0a638424375e9721d5ecefd2f052", "filename": "src/test/run-pass/issue-21634.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c64b73e520fccd31a4500b2526a56f6521323568/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21634.rs?ref=c64b73e520fccd31a4500b2526a56f6521323568", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn main() {\n+    if let Ok(x) = \"3.1415\".parse() {\n+        assert_eq!(false, x <= 0.0);\n+    }\n+    if let Ok(x) = \"3.1415\".parse() {\n+        assert_eq!(3.1415, x + 0.0);\n+    }\n+    if let Ok(mut x) = \"3.1415\".parse() {\n+        assert_eq!(8.1415, { x += 5.0; x });\n+    }\n+}"}]}