{"sha": "96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NTcyY2I1ZjhlOWFhYjNlMzkxNjJmZjEwZmM2YjhhNDFkZGU0ZWQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-08-19T15:36:04Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-09-22T19:01:21Z"}, "message": "panic when instantiating an uninhabited type via mem::{uninitialized,zeroed}", "tree": {"sha": "3449e95f8b25a61f651925f6b0f3890a7b63b237", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3449e95f8b25a61f651925f6b0f3890a7b63b237"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "html_url": "https://github.com/rust-lang/rust/commit/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "851acdd22dd2e99759e7f2f3e613ee9566ea0dcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/851acdd22dd2e99759e7f2f3e613ee9566ea0dcc", "html_url": "https://github.com/rust-lang/rust/commit/851acdd22dd2e99759e7f2f3e613ee9566ea0dcc"}], "stats": {"total": 88, "additions": 88, "deletions": 0}, "files": [{"sha": "72fb9df6f81bdaca8821b89d5c452a08088aa05c", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "patch": "@@ -463,6 +463,55 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     return;\n                 }\n \n+                if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n+                    bx.cx.layout_of(sig.output()).abi.is_uninhabited()\n+                {\n+                    let loc = bx.sess().codemap().lookup_char_pos(span.lo());\n+                    let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+                    let filename = C_str_slice(bx.cx, filename);\n+                    let line = C_u32(bx.cx, loc.line as u32);\n+                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                    let align = tcx.data_layout.aggregate_align\n+                        .max(tcx.data_layout.i32_align)\n+                        .max(tcx.data_layout.pointer_align);\n+\n+                    let str = if intrinsic == Some(\"init\") {\n+                        \"Attempted to instantiate an uninhabited type (e.g. `!`) \\\n+                         using mem::zeroed()\"\n+                    } else {\n+                        \"Attempted to instantiate an uninhabited type (e.g. `!`) \\\n+                         using mem::uninitialized()\"\n+                    };\n+                    let msg_str = Symbol::intern(str).as_str();\n+                    let msg_str = C_str_slice(bx.cx, msg_str);\n+                    let msg_file_line_col = C_struct(bx.cx,\n+                                                    &[msg_str, filename, line, col],\n+                                                    false);\n+                    let msg_file_line_col = consts::addr_of(bx.cx,\n+                                                            msg_file_line_col,\n+                                                            align,\n+                                                            Some(\"panic_loc\"));\n+\n+                    // Obtain the panic entry point.\n+                    let def_id =\n+                        common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n+                    let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                    let fn_ty = FnType::of_instance(bx.cx, &instance);\n+                    let llfn = callee::get_fn(bx.cx, instance);\n+\n+                    // Codegen the actual panic invoke/call.\n+                    do_call(\n+                        self,\n+                        bx,\n+                        fn_ty,\n+                        llfn,\n+                        &[msg_file_line_col],\n+                        destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n+                        cleanup,\n+                    );\n+                    return;\n+                }\n+\n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n                     let op_ty = op_arg.ty(self.mir, bx.tcx());"}, {"sha": "96eb69163220e7b33c57287bd9ac35596ab6b589", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "patch": "@@ -802,6 +802,14 @@ impl Abi {\n             _ => false,\n         }\n     }\n+\n+    /// Returns true if this is an uninhabited type\n+    pub fn is_uninhabited(&self) -> bool {\n+        match *self {\n+            Abi::Uninhabited => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Debug)]"}, {"sha": "a4115f8fa1d65c7a8dd1fe479da080d98990fa4c", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=96572cb5f8e9aab3e39162ff10fc6b8a41dde4ed", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n+// in a runtime panic.\n+\n+#![feature(never_type)]\n+\n+use std::{mem, panic};\n+\n+struct Foo {\n+    x: u8,\n+    y: !,\n+}\n+\n+fn main() {\n+    unsafe {\n+        panic::catch_unwind(|| mem::uninitialized::<!>()).is_err();\n+        panic::catch_unwind(|| mem::zeroed::<!>()).is_err();\n+\n+        panic::catch_unwind(|| mem::uninitialized::<Foo>()).is_err();\n+        panic::catch_unwind(|| mem::zeroed::<Foo>()).is_err();\n+    }\n+}"}]}