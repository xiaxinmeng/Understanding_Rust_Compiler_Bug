{"sha": "34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YjdkYjNiYmMzMjkwODYyNmNkNDYzNWE0YzUxZjRhZWM1ZmZhMmU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-11-20T00:10:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-11-20T00:10:31Z"}, "message": "Merge pull request #4001 from jesse99/features/docs\n\nFeatures/docs", "tree": {"sha": "d77a2e3c7de868dd5eab5662374ec99665b4dcc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77a2e3c7de868dd5eab5662374ec99665b4dcc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "html_url": "https://github.com/rust-lang/rust/commit/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "318e534895f20e7991abbc644eec311816010ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/318e534895f20e7991abbc644eec311816010ef1", "html_url": "https://github.com/rust-lang/rust/commit/318e534895f20e7991abbc644eec311816010ef1"}, {"sha": "ca332a68fa810de4bc1d8abc16020fdb3027333f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca332a68fa810de4bc1d8abc16020fdb3027333f", "html_url": "https://github.com/rust-lang/rust/commit/ca332a68fa810de4bc1d8abc16020fdb3027333f"}], "stats": {"total": 128, "additions": 104, "deletions": 24}, "files": [{"sha": "505b5383dcd805c34c07a64c0d8620e83ab24748", "filename": "doc/README", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/doc%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/doc%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FREADME?ref=34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "patch": "@@ -0,0 +1,13 @@\n+The markdown docs are only generated by make when node is installed (use\n+`make doc`). If you don't have node installed you can generate them yourself. \n+Unfortunately there's no real standard for markdown and all the tools work \n+differently. pandoc is one that seems to work well.\n+\n+To generate an html version of a doc do something like:\n+pandoc --from=markdown --to=html --number-sections -o build/doc/rust.html doc/rust.md && git web--browse build/doc/rust.html\n+\n+The syntax for pandoc flavored markdown can be found at:\n+http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown\n+\n+A nice quick reference (for non-pandoc markdown) is at:\n+http://kramdown.rubyforge.org/quickref.html\n\\ No newline at end of file"}, {"sha": "2a99acdef41acd240e308b4744001cdee9446062", "filename": "doc/rust.md", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "patch": "@@ -510,9 +510,8 @@ For parsing reasons, delimiters must be balanced, but they are otherwise not spe\n \n In the matcher, `$` _name_ `:` _designator_ matches the nonterminal in the\n Rust syntax named by _designator_. Valid designators are `item`, `block`,\n-`stmt`, `pat`, `expr`, `ty`, `ident`, `path`, `tt`, `matchers`. The last two\n-are the right-hand side and the left-hand side respectively of the `=>` in\n-macro rules. In the transcriber, the designator is already known, and so only\n+`stmt`, `pat`, `expr`, `ty` (type), `ident`, `path`, `matchers` (lhs of the `=>` in macro rules), \n+`tt` (rhs of the `=>` in macro rules). In the transcriber, the designator is already known, and so only\n the name of a matched nonterminal comes after the dollar sign.\n \n In both the matcher and transcriber, the Kleene star-like operator indicates repetition.\n@@ -799,7 +798,7 @@ extern mod ruststd (name = \"std\"); // linking to 'std' under another name\n ##### Use declarations\n \n ~~~~~~~~ {.ebnf .gram}\n-use_decl : \"use\" ident [ '=' path\n+use_decl : \"pub\"? \"use\" ident [ '=' path\n                           | \"::\" path_glob ] ;\n \n path_glob : ident [ \"::\" path_glob ] ?\n@@ -1104,6 +1103,17 @@ Constants are declared with the `const` keyword.\n A constant item must have an expression giving its definition.\n The definition expression of a constant is limited to expression forms that can be evaluated at compile time.\n \n+Constants must be explicitly typed. The type may be ```bool```, ```char```, a number, or a type derived from\n+those primitive types. The derived types are borrowed pointers, static arrays, tuples, and structs.\n+\n+~~~~\n+const bit1: uint = 1 << 0;\n+const bit2: uint = 1 << 1;\n+\n+const bits: [uint * 2] = [bit1, bit2];\n+const bits_r: &[uint] = &bits;\n+~~~~\n+\n ### Traits\n \n A _trait_ describes a set of method types.\n@@ -1175,6 +1185,9 @@ Values with a trait type can have [methods called](#method-call-expressions) on\n for any method in the trait,\n and can be used to instantiate type parameters that are bounded by the trait.\n \n+Trait methods may be static. Currently implementations of static methods behave like\n+functions declared in the implentation's module.\n+\n ### Implementations\n \n An _implementation_ is an item that implements a [trait](#traits) for a specific type.\n@@ -1304,9 +1317,8 @@ Attributes may appear as any of\n * An identifier followed by the equals sign '=' and a literal, providing a key/value pair\n * An identifier followed by a parenthesized list of sub-attribute arguments\n \n-Attributes are applied to an entity by placing them within a hash-list\n-(`#[...]`) as either a prefix to the entity or as a semicolon-delimited\n-declaration within the entity body.\n+Attributes terminated by a semi-colon apply to the entity that the attribute is declared\n+within. Attributes that are not terminated by a semi-colon apply to the next entity.\n \n An example of attributes:\n \n@@ -1326,9 +1338,9 @@ mod bar {\n   ...\n }\n \n-// A documentation attribute\n-#[doc = \"Add two numbers together.\"]\n-fn add(x: int, y: int) { x + y }\n+// A lint attribute used to suppress a warning/error\n+#[allow(non_camel_case_types)]\n+pub type int8_t = i8;\n ~~~~~~~~\n \n > **Note:** In future versions of Rust, user-provided extensions to the compiler will be able to interpret attributes.\n@@ -1341,6 +1353,8 @@ names are effectively reserved. Some significant attributes include:\n * The `cfg` attribute, for conditional-compilation by build-configuration.\n * The `link` attribute, for describing linkage metadata for a crate.\n * The `test` attribute, for marking functions as unit tests.\n+* The `allow`, `warn`, `forbid`, and `deny` attributes, for controling lint checks. Lint checks supported\n+by the compiler can be found via `rustc -W help`.\n \n Other attributes may be added or removed during development of the language.\n \n@@ -1546,7 +1560,9 @@ it is automatically derferenced to make the field access possible.\n ### Vector expressions\n \n ~~~~~~~~{.ebnf .gram}\n-vec_expr : '[' \"mut\" ? [ expr [ ',' expr ] * ] ? ']'\n+vec_expr : '[' \"mut\"? vec_elems? ']'\n+\n+vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr]\n ~~~~~~~~\n \n A [_vector_](#vector-types) _expression_ is written by enclosing zero or\n@@ -1558,6 +1574,7 @@ When no mutability is specified, the vector is immutable.\n ~~~~\n [1, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n+[0, ..128];             // vector with 128 zeros\n [mut 0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n@@ -1889,7 +1906,7 @@ let x: int = add(1, 2);\n \n ~~~~~~~~ {.abnf .gram}\n ident_list : [ ident [ ',' ident ]* ] ? ;\n-lambda_expr : '|' ident_list '| expr ;\n+lambda_expr : '|' ident_list '|' expr ;\n ~~~~~~~~\n \n A _lambda expression_ (a.k.a. \"anonymous function expression\") defines a function and denotes it as a value,\n@@ -2169,17 +2186,6 @@ Records and structures can also be pattern-matched and their fields bound to var\n When matching fields of a record,\n the fields being matched are specified first,\n then a placeholder (`_`) represents the remaining fields.\n-\n-A pattern that's just a variable binding,\n-like `Nil` in the previous answer,\n-could either refer to an enum variant that's in scope,\n-or bind a new variable.\n-The compiler resolves this ambiguity by forbidding variable bindings that occur in ```match``` patterns from shadowing names of variants that are in scope.\n-For example, wherever ```List``` is in scope,\n-a ```match``` pattern would not be able to bind ```Nil``` as a new name.\n-The compiler interprets a variable pattern `x` as a binding _only_ if there is no variant named `x` in scope.\n-A convention you can use to avoid conflicts is simply to name variants with upper-case letters,\n-and local variables with lower-case letters.\n  \n ~~~~\n # type options = {choose: bool, size: ~str};\n@@ -2212,6 +2218,22 @@ fn main() {\n }\n ~~~~\n \n+Patterns that bind variables default to binding to a copy of the matched value. This can be made\n+explicit using the ```copy``` keyword, changed to bind to a borrowed pointer by using the ```ref```\n+keyword, or to a mutable borrowed pointer using ```ref mut```, or the value can be moved into\n+the new binding using ```move```.\n+\n+A pattern that's just an identifier,\n+like `Nil` in the previous answer,\n+could either refer to an enum variant that's in scope,\n+or bind a new variable.\n+The compiler resolves this ambiguity by forbidding variable bindings that occur in ```match``` patterns from shadowing names of variants that are in scope.\n+For example, wherever ```List``` is in scope,\n+a ```match``` pattern would not be able to bind ```Nil``` as a new name.\n+The compiler interprets a variable pattern `x` as a binding _only_ if there is no variant named `x` in scope.\n+A convention you can use to avoid conflicts is simply to name variants with upper-case letters,\n+and local variables with lower-case letters.\n+\n Multiple match patterns may be joined with the `|` operator.  A\n range of values may be specified with `..`. For example:\n "}, {"sha": "a9989f5d37d73a280a68a0cc5a924102d926470c", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b7db3bbc32908626cd4635a4c51f4aec5ffa2e/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=34b7db3bbc32908626cd4635a4c51f4aec5ffa2e", "patch": "@@ -1,4 +1,46 @@\n-#[doc(hidden)];\n+//! Support for fmt! expressions.\n+//!\n+//! The syntax is close to that of Posix format strings:\n+//!\n+//! ~~~~~~\n+//! Format := '%' Parameter? Flag* Width? Precision? Type\n+//! Parameter := [0-9]+ '$'\n+//! Flag := [ 0#+-]\n+//! Width := Parameter | [0-9]+\n+//! Precision := '.' [0-9]+\n+//! Type := [bcdfiostuxX?]\n+//! ~~~~~~\n+//!\n+//! * Parameter is the 1-based argument to apply the format to. Currently not\n+//! implemented.\n+//! * Flag 0 causes leading zeros to be used for padding when converting\n+//! numbers.\n+//! * Flag # causes the conversion to be done in an *alternative* manner.\n+//! Currently not implemented.\n+//! * Flag + causes signed numbers to always be prepended with a sign\n+//! character.\n+//! * Flag - left justifies the result\n+//! * Width specifies the minimum field width of the result. By default\n+//! leading spaces are added.\n+//! * Precision specifies the minimum number of digits for integral types\n+//! and the minimum number\n+//! of decimal places for float.\n+//!\n+//! The types currently supported are:\n+//!\n+//! * b - bool\n+//! * c - char\n+//! * d - int\n+//! * f - float\n+//! * i - int (same as d)\n+//! * o - uint as octal\n+//! * t - uint as binary\n+//! * u - uint\n+//! * x - uint as lower-case hexadecimal\n+//! * X - uint as upper-case hexadecimal\n+//! * s - str (any flavor)\n+//! * ? - arbitrary type (does not use the to_str trait)\n+\n // NB: transitionary, de-mode-ing.\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n@@ -44,6 +86,7 @@ use option::{Some, None};\n  */\n \n // Functions used by the fmt extension at compile time\n+#[doc(hidden)]\n pub mod ct {\n     pub enum Signedness { Signed, Unsigned, }\n     pub enum Caseness { CaseUpper, CaseLower, }\n@@ -277,6 +320,7 @@ pub mod ct {\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n // implement it 0this way, I think.\n+#[doc(hidden)]\n pub mod rt {\n     pub const flag_none : u32 = 0u32;\n     pub const flag_left_justify   : u32 = 0b00000000000001u32;\n@@ -483,6 +527,7 @@ pub mod rt {\n     }\n }\n \n+// Bulk of the tests are in src/test/run-pass/syntax-extension-fmt.rs\n #[cfg(test)]\n mod test {\n     #[test]"}]}