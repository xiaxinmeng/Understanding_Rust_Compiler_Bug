{"sha": "9efcd996d528b7da9beb0a9743b6659c667154d6", "node_id": "C_kwDOAAsO6NoAKDllZmNkOTk2ZDUyOGI3ZGE5YmViMGE5NzQzYjY2NTljNjY3MTU0ZDY", "commit": {"author": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-27T19:06:06Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:18:27Z"}, "message": "Add even more details to top-level pointer docs", "tree": {"sha": "93df5e7e042af059f88e1ec4c067365bf41de5ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93df5e7e042af059f88e1ec4c067365bf41de5ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9efcd996d528b7da9beb0a9743b6659c667154d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9efcd996d528b7da9beb0a9743b6659c667154d6", "html_url": "https://github.com/rust-lang/rust/commit/9efcd996d528b7da9beb0a9743b6659c667154d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9efcd996d528b7da9beb0a9743b6659c667154d6/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7514d760b8fabd46e4874520b653ab8803c3517e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7514d760b8fabd46e4874520b653ab8803c3517e", "html_url": "https://github.com/rust-lang/rust/commit/7514d760b8fabd46e4874520b653ab8803c3517e"}], "stats": {"total": 24, "additions": 20, "deletions": 4}, "files": [{"sha": "d988edb213e5887270da40e7d9e6fc35a6b15f64", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9efcd996d528b7da9beb0a9743b6659c667154d6/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9efcd996d528b7da9beb0a9743b6659c667154d6/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=9efcd996d528b7da9beb0a9743b6659c667154d6", "patch": "@@ -153,8 +153,8 @@\n //! integers is very useful, so what can we do?\n //!\n //! Strict Provenance attempts to square this circle by decoupling Rust's traditional conflation\n-//! of pointers and `usize` (and `isize`), defining a pointer to semantically contain the following\n-//! information:\n+//! of pointers and `usize` (and `isize`), and defining a pointer to semantically contain the\n+//! following information:\n //!\n //! * The **address-space** it is part of.\n //! * The **address** it points to, which can be represented by a `usize`.\n@@ -235,6 +235,10 @@\n //! }\n //! ```\n //!\n+//! (Yes, if you've been using AtomicUsize for pointers in concurrent datastructures, you should\n+//! be using AtomicPtr instead. If that messes up the way you atomically manipulate pointers,\n+//! we would like to know why, and what needs to be done to fix it.)\n+//!\n //! Something more complicated and just generally *evil* like a XOR-List requires more significant\n //! changes like allocating all nodes in a pre-allocated Vec or Arena and using a pointer\n //! to the whole allocation to reconstitute the XORed addresses.\n@@ -258,11 +262,13 @@\n //!\n //! * Create an invalid pointer from just an address (see [`ptr::invalid`][]). This can\n //!   be used for sentinel values like `null` *or* to represent a tagged pointer that will\n-//!   never be dereferencable.\n+//!   never be dereferencable. In general, it is always sound for an integer to pretend\n+//!   to be a pointer \"for fun\" as long as you don't use operations on it which require\n+//!   it to be valid (offset, read, write, etc).\n //!\n //! * Forge an allocation of size zero at any sufficiently aligned non-null address.\n //!   i.e. the usual \"ZSTs are fake, do what you want\" rules apply *but* this only applies\n-//!   for actual forgery (integers cast to pointers). If you borrow some structs subfield\n+//!   for actual forgery (integers cast to pointers). If you borrow some struct's field\n //!   that *happens* to be zero-sized, the resulting pointer will have provenance tied to\n //!   that allocation and it will still get invalidated if the allocation gets deallocated.\n //!   In the future we may introduce an API to make such a forged allocation explicit.\n@@ -277,6 +283,16 @@\n //!   and based on alignment, but the buffer on either side of the pointer's range is pretty\n //!   generous (think kilobytes, not bytes).\n //!\n+//! * Compare arbitrary pointers by address. Addresses *are* just integers and so there is\n+//!   always a coherent answer, even if the pointers are invalid or from different\n+//!   address-spaces/provenances. Of course, comparing addresses from different address-spaces\n+//!   is generally going to be *meaningless*, but so is comparing Kilograms to Meters, and Rust\n+//!   doesn't prevent that either. Similarly, if you get \"lucky\" and notice that a pointer\n+//!   one-past-the-end is the \"same\" address as the start of an unrelated allocation, anything\n+//!   you do with that fact is *probably* going to be gibberish. The scope of that gibberish\n+//!   is kept under control by the fact that the two pointers *still* aren't allowed to access\n+//!   the other's allocation (bytes), because they still have different provenance.\n+//!\n //! * Perform pointer tagging tricks. This falls out of [`wrapping_offset`] but is worth\n //!   mentioning in more detail because of the limitations of [CHERI][]. Low-bit tagging\n //!   is very robust, and often doesn't even go out of bounds because types have a"}]}