{"sha": "513d392f7e66b416e5ba6f4f778ae2cfadb10832", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxM2QzOTJmN2U2NmI0MTZlNWJhNmY0Zjc3OGFlMmNmYWRiMTA4MzI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-03T01:56:42Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Replace &'a TyCtxt<'tcx> with a TyCtxt<'a, 'tcx> wrapper.", "tree": {"sha": "0999a16d87052034ad6b9a6624dcd71972ffd525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0999a16d87052034ad6b9a6624dcd71972ffd525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/513d392f7e66b416e5ba6f4f778ae2cfadb10832", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/513d392f7e66b416e5ba6f4f778ae2cfadb10832", "html_url": "https://github.com/rust-lang/rust/commit/513d392f7e66b416e5ba6f4f778ae2cfadb10832", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/513d392f7e66b416e5ba6f4f778ae2cfadb10832/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "html_url": "https://github.com/rust-lang/rust/commit/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a"}], "stats": {"total": 2669, "additions": 1331, "deletions": 1338}, "files": [{"sha": "a1f1fdb6b0e598f6d889e64fb9679d06f1bab601", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -19,7 +19,7 @@ use syntax::ptr::P;\n use hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -32,7 +32,7 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-pub fn construct(tcx: &TyCtxt,\n+pub fn construct(tcx: TyCtxt,\n                  blk: &hir::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);"}, {"sha": "e9c4dd1d87dcbf5cfea9e7def947ac233defb0cc", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -58,7 +58,7 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new(tcx: &TyCtxt,\n+    pub fn new(tcx: TyCtxt,\n                blk: &hir::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }"}, {"sha": "4cc3f138dddbf80a4d4a036fcd35c55e8cc50078", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -22,13 +22,13 @@ use super::dep_node::DepNode;\n /// read edge from the corresponding AST node. This is used in\n /// compiler passes to automatically record the item that they are\n /// working on.\n-pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n-                                          mut dep_node_fn: F,\n-                                          visitor: &mut V)\n+pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx>,\n+                                                mut dep_node_fn: F,\n+                                                visitor: &mut V)\n     where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n {\n     struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: &'visit TyCtxt<'tcx>,\n+        tcx: TyCtxt<'visit, 'tcx>,\n         dep_node_fn: &'visit mut F,\n         visitor: &'visit mut V\n     }"}, {"sha": "17ad2189f68a414a6b53a7c86b512cb04118d458", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -209,7 +209,7 @@ pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     }\n }\n \n-pub fn def_to_path(tcx: &TyCtxt, id: DefId) -> hir::Path {\n+pub fn def_to_path(tcx: TyCtxt, id: DefId) -> hir::Path {\n     let name = tcx.item_name(id);\n     hir::Path::from_ident(DUMMY_SP, hir::Ident::from_name(name))\n }"}, {"sha": "71058647c36da7c235665a20e6ccfd304d87aaf9", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "96b0dba9d39011b23aab1e3564f880daa15d5c2f", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -151,7 +151,7 @@ fn unify_float_variable(&self,\n }\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -300,7 +300,7 @@ struct Generalizer<'cx, 'tcx:'cx> {\n }\n \n impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "eff66469c4edaee889ebc2c4eca2bb2f1ed049c8", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "66e5f52544d4e20e05769ced3c75599a98aa7768", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -95,8 +95,8 @@ use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_region(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region,\n@@ -112,7 +112,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        fn explain_span(tcx: &TyCtxt, heading: &str, span: Span)\n+        fn explain_span(tcx: TyCtxt, heading: &str, span: Span)\n                         -> (String, Option<Span>) {\n             let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n             (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n@@ -474,7 +474,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn free_regions_from_same_fn(tcx: &TyCtxt,\n+        fn free_regions_from_same_fn(tcx: TyCtxt,\n                                      sub: Region,\n                                      sup: Region)\n                                      -> Option<FreeRegionsFromSameFn> {\n@@ -1109,7 +1109,7 @@ struct RebuildPathInfo<'a> {\n }\n \n struct Rebuilder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n     expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n@@ -1125,7 +1125,7 @@ enum FreshOrKept {\n }\n \n impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n            expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n@@ -1929,7 +1929,7 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     }\n }\n \n-fn lifetimes_in_scope(tcx: &TyCtxt,\n+fn lifetimes_in_scope(tcx: TyCtxt,\n                       scope_id: ast::NodeId)\n                       -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();"}, {"sha": "7c87c0a87918a9f005aaff5f4619caf3129810c0", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> &'b TyCtxt<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "da7d5894da9b6b89c59ba5e704c2967187ec30bf", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "546bfe65fe93d8ba3be37d0de2595ece090f33b6", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -329,10 +329,10 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T, F>(tcx: &TyCtxt<'tcx>,\n-                               unbound_value: &T,\n-                               mut fldr: F)\n-                               -> T\n+fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx>,\n+                                   unbound_value: &T,\n+                                   mut fldr: F)\n+                                   -> T\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {"}, {"sha": "6bb4a22b4c784fcd04aba3bddddc6a6413b1e6b2", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "1036b918b9a4a09e346634a0ba7e790ecb515fee", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -74,7 +74,7 @@ pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n \n     pub tables: &'a RefCell<ty::Tables<'tcx>>,\n \n@@ -385,7 +385,7 @@ impl fmt::Display for FixupError {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>,\n                tables: &'a RefCell<ty::Tables<'tcx>>,\n                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n                projection_mode: ProjectionMode)\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn normalizing(tcx: &'a TyCtxt<'tcx>,\n+    pub fn normalizing(tcx: TyCtxt<'a, 'tcx>,\n                        tables: &'a RefCell<ty::Tables<'tcx>>,\n                        projection_mode: ProjectionMode)\n                        -> Self {\n@@ -441,8 +441,8 @@ pub struct CombinedSnapshot {\n }\n \n // NOTE: Callable from trans only!\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn normalize_associated_type<T>(&self, value: &T) -> T\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn normalize_associated_type<T>(self, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         debug!(\"normalize_associated_type(t={:?})\", value);\n@@ -1523,7 +1523,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n     }\n }\n \n-impl<'tcx> TypeTrace<'tcx> {\n+impl<'a, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n@@ -1539,7 +1539,7 @@ impl<'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: &TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'a, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(ExpectedFound {"}, {"sha": "05303ae1376dd8011c6845fc23e2aa8a5737c1fd", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -119,7 +119,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n }\n \n struct ConstraintGraph<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n@@ -139,7 +139,7 @@ enum Edge {\n }\n \n impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            name: String,\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'tcx> {\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n+fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n                                             map: &ConstraintMap<'tcx>,\n                                             path: &str)\n                                             -> io::Result<()> {"}, {"sha": "9dcc19d76b5c64106fdb850ef71311bf013e969a", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -191,7 +191,7 @@ impl SameRegions {\n pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -254,7 +254,7 @@ pub struct RegionSnapshot {\n }\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -1362,8 +1362,8 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     }\n }\n \n-impl<'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+impl<'a, 'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n@@ -1424,12 +1424,11 @@ impl VerifyBound {\n         }\n     }\n \n-    fn is_met<'tcx>(&self,\n-                    tcx: &TyCtxt<'tcx>,\n-                    free_regions: &FreeRegionMap,\n-                    var_values: &Vec<VarValue>,\n-                    min: ty::Region)\n-                    -> bool {\n+    fn is_met(&self, tcx: TyCtxt,\n+              free_regions: &FreeRegionMap,\n+              var_values: &Vec<VarValue>,\n+              min: ty::Region)\n+              -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()"}, {"sha": "c2f38332f54fb31f22d1a5bfd3f42c5edfc6c962", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -30,7 +30,7 @@ impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -58,7 +58,7 @@ impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -104,7 +104,7 @@ struct FullTypeResolver<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "d6a16727363070978fd34db5b664b59b95da59ae", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "bf54e7c1b39f93ef0897b2ffa3c18605808bf5f5", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -13,7 +13,7 @@ use ty::{self, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{Combine, UnifyKey};\n \n pub trait ToType<'tcx> {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -51,7 +51,7 @@ impl UnifyKey for ty::RegionVid {\n }\n \n impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -69,7 +69,7 @@ impl UnifyKey for ty::FloatVid {\n }\n \n impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "a6d6895154c237c4b28c8c02ed5d3d1b26085cf5", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -297,7 +297,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n \n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n@@ -652,7 +652,7 @@ impl<'a> EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            krate: &'a hir::Crate,\n            access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n@@ -740,7 +740,8 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, it: &hir::Item) {\n@@ -1219,7 +1220,7 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n /// Perform lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate(tcx: &TyCtxt, access_levels: &AccessLevels) {\n+pub fn check_crate(tcx: TyCtxt, access_levels: &AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n     let krate = tcx.map.krate();"}, {"sha": "de0d41ea64ba60155ecec7fe63e7e7c4bf00a63d", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -20,8 +20,8 @@ use ty::{Ty, TyCtxt};\n use syntax::codemap::Span;\n use hir as ast;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-pub fn prohibit_type_params(&self, segments: &[ast::PathSegment]) {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n     for segment in segments {\n         for typ in segment.parameters.types() {\n             span_err!(self.sess, typ.span, E0109,\n@@ -40,13 +40,13 @@ pub fn prohibit_type_params(&self, segments: &[ast::PathSegment]) {\n     }\n }\n \n-pub fn prohibit_projection(&self, span: Span)\n+pub fn prohibit_projection(self, span: Span)\n {\n     span_err!(self.sess, span, E0229,\n               \"associated type bindings are not allowed here\");\n }\n \n-pub fn prim_ty_to_ty(&self,\n+pub fn prim_ty_to_ty(self,\n                      segments: &[ast::PathSegment],\n                      nty: ast::PrimTy)\n                      -> Ty<'tcx> {\n@@ -63,7 +63,7 @@ pub fn prim_ty_to_ty(&self,\n \n /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n /// to it.\n-pub fn ast_ty_to_prim_ty(&self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n+pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n     if let ast::TyPath(None, ref path) = ast_ty.node {\n         let def = match self.def_map.borrow().get(&ast_ty.id) {\n             None => {"}, {"sha": "e3d94c7a5d3b8b5bd0cac465a90e1327d4282c7d", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 79, "deletions": 82, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -160,57 +160,56 @@ pub trait CrateStore<'tcx> : Any {\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                    -> ty::ClosureKind;\n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                  -> ty::ClosureTy<'tcx>;\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+                      -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx>;\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx>;\n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx>;\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx>;\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn item_symbol(&self, def: DefId) -> String;\n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn method_arg_names(&self, did: DefId) -> Vec<String>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>>;\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>>;\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId>;\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>;\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                     -> Option<DefId>;\n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>>;\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+                         -> Option<DefId>;\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool;\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n@@ -251,10 +250,10 @@ pub trait CrateStore<'tcx> : Any {\n     fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n \n     // misc. metadata\n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx>;\n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>>;\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx>;\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -266,22 +265,21 @@ pub trait CrateStore<'tcx> : Any {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8>;\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       -> Vec<u8>;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8>;\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -339,63 +337,63 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                    -> ty::ClosureKind  { bug!(\"closure_kind\") }\n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                  -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+                      -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n     fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn item_symbol(&self, def: DefId) -> String { bug!(\"item_symbol\") }\n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n     fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n         { bug!(\"impl_items\") }\n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                     -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+                         -> Option<DefId> { bug!(\"trait_of_item\") }\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool { bug!(\"is_extern_item\") }\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool\n+        { bug!(\"is_extern_item\") }\n     fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n@@ -448,10 +446,10 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -465,25 +463,24 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8> {\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       -> Vec<u8> {\n         bug!(\"encode_type\")\n     }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8> { vec![] }\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n@@ -510,7 +507,7 @@ pub mod tls {\n     use hir::def_id::DefId;\n \n     pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n         fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n         fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n     }\n@@ -577,7 +574,7 @@ pub mod tls {\n     }\n \n     pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n         fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n         fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;"}, {"sha": "dc58a663195f572e73954647ea759b098783eec7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -37,7 +37,7 @@ pub enum EntryOrExit {\n \n #[derive(Clone)]\n pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -222,7 +222,7 @@ pub enum KillFrom {\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>,\n                analysis_name: &'static str,\n                decl: Option<&hir::FnDecl>,\n                cfg: &cfg::CFG,"}, {"sha": "a1fe1b521f5f08fcd3b3965138073f8cbcb130f7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -31,7 +31,7 @@ use syntax::attr;\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: &TyCtxt, node_id: ast::NodeId) -> bool {\n+fn should_explore(tcx: TyCtxt, node_id: ast::NodeId) -> bool {\n     match tcx.map.find(node_id) {\n         Some(ast_map::NodeItem(..)) |\n         Some(ast_map::NodeImplItem(..)) |\n@@ -45,7 +45,7 @@ fn should_explore(tcx: &TyCtxt, node_id: ast::NodeId) -> bool {\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n@@ -54,7 +54,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n@@ -362,7 +362,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n     }\n }\n \n-fn create_and_seed_worklist(tcx: &TyCtxt,\n+fn create_and_seed_worklist(tcx: TyCtxt,\n                             access_levels: &privacy::AccessLevels,\n                             krate: &hir::Crate) -> Vec<ast::NodeId> {\n     let mut worklist = Vec::new();\n@@ -385,7 +385,7 @@ fn create_and_seed_worklist(tcx: &TyCtxt,\n     return life_seeder.worklist;\n }\n \n-fn find_live(tcx: &TyCtxt,\n+fn find_live(tcx: TyCtxt,\n              access_levels: &privacy::AccessLevels,\n              krate: &hir::Crate)\n              -> Box<HashSet<ast::NodeId>> {\n@@ -405,7 +405,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n }\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n@@ -504,7 +504,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -582,7 +583,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt, access_levels: &privacy::AccessLevels) {\n+pub fn check_crate(tcx: TyCtxt, access_levels: &privacy::AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n     let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "55a130697fe3431db538f9906bba9da170ff3f10", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -51,7 +51,7 @@ fn type_is_unsafe_function(ty: Ty) -> bool {\n }\n \n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     let _task = tcx.dep_graph.in_task(DepNode::EffectCheck);\n \n     let mut visitor = EffectCheckVisitor {"}, {"sha": "b662dc81d94fa3f82bdce4069b5599a6aa0b4626", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -209,7 +209,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: &TyCtxt, trait_id: DefId)\n+    fn from_trait_id(tcx: TyCtxt, trait_id: DefId)\n                      -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n@@ -227,7 +227,7 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: &TyCtxt, method_id: DefId)\n+    fn from_method_id(tcx: TyCtxt, method_id: DefId)\n                       -> OverloadedCallType {\n         let method = tcx.impl_or_trait_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container().id())\n@@ -306,7 +306,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &'t TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'t, 'tcx> {\n         self.typer.tcx\n     }\n "}, {"sha": "e4ce89767139a23157a2f29543d288f4ae0dd724", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -121,7 +121,7 @@ impl FreeRegionMap {\n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n-                           tcx: &TyCtxt,\n+                           tcx: TyCtxt,\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {"}, {"sha": "ee201335b11c1e3fa795664216b773ef8c056c32", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -22,15 +22,15 @@ use syntax::codemap::Span;\n use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     let mut visitor = ItemVisitor {\n         tcx: tcx\n     };\n     tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>\n+    tcx: TyCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {"}, {"sha": "2d26913393265e34c1f56d9895e24e6f97fc459b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -169,7 +169,7 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: &TyCtxt) -> String {\n+fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n     let cm = tcx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => {\n@@ -195,7 +195,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n     tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n     tcx.sess.abort_if_errors();\n@@ -263,7 +263,7 @@ enum VarKind {\n }\n \n struct IrMaps<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n \n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -275,7 +275,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> IrMaps<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx>) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx: tcx,\n             num_live_nodes: 0,\n@@ -1486,9 +1486,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ty::FnConverging(t_ret)\n                     if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n \n-                let param_env = ParameterEnvironment::for_item(&self.ir.tcx, id);\n-                let t_ret_subst = t_ret.subst(&self.ir.tcx, &param_env.free_substs);\n-                let infcx = InferCtxt::new(&self.ir.tcx,\n+                let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n+                let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n+                let infcx = InferCtxt::new(self.ir.tcx,\n                                            &self.ir.tcx.tables,\n                                            Some(param_env),\n                                            ProjectionMode::Any);"}, {"sha": "9faae0c098db2e01551888726a94d45a8e7d4865", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -302,7 +302,7 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: &TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n                 PatKind::Ident(bind_mode, _, _) => {\n@@ -363,7 +363,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         MemCategorizationContext { typer: typer }\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.typer.tcx\n     }\n \n@@ -1082,7 +1082,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n         /// have to recurse through rptrs.\n-        fn vec_slice_info(tcx: &TyCtxt,\n+        fn vec_slice_info(tcx: TyCtxt,\n                           pat: &hir::Pat,\n                           slice_ty: Ty)\n                           -> (hir::Mutability, ty::Region) {\n@@ -1463,7 +1463,7 @@ impl<'tcx> cmt_<'tcx> {\n     }\n \n \n-    pub fn descriptive_string(&self, tcx: &TyCtxt) -> String {\n+    pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".to_string()"}, {"sha": "b2036d7a4c0bf4648e66e450e7ca71cd2f60a9b0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -55,7 +55,7 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: &TyCtxt, sig: &hir::MethodSig,\n+fn method_might_be_inlined(tcx: TyCtxt, sig: &hir::MethodSig,\n                            impl_item: &hir::ImplItem,\n                            impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n@@ -77,7 +77,7 @@ fn method_might_be_inlined(tcx: &TyCtxt, sig: &hir::MethodSig,\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> ReachableContext<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty != config::CrateTypeExecutable\n         });\n@@ -344,7 +344,7 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     }\n }\n \n-pub fn find_reachable(tcx: &TyCtxt,\n+pub fn find_reachable(tcx: TyCtxt,\n                       access_levels: &privacy::AccessLevels)\n                       -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);"}, {"sha": "6edbb6c584fc211a041e402a4f0e0f8b71c72997", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -72,7 +72,7 @@ pub struct Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<Deprecation>,\n@@ -203,7 +203,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, i: &Item) {\n@@ -277,9 +278,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Index<'tcx> {\n+impl<'a, 'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &TyCtxt<'tcx>, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx>, access_levels: &AccessLevels) {\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n@@ -319,7 +320,7 @@ impl<'tcx> Index<'tcx> {\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n-pub fn check_unstable_api_usage(tcx: &TyCtxt)\n+pub fn check_unstable_api_usage(tcx: TyCtxt)\n                                 -> FnvHashMap<InternedString, StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n@@ -339,7 +340,7 @@ pub fn check_unstable_api_usage(tcx: &TyCtxt)\n }\n \n struct Checker<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     active_features: FnvHashSet<InternedString>,\n     used_features: FnvHashMap<InternedString, StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n@@ -411,7 +412,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -466,7 +468,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: &TyCtxt, item: &hir::Item, warn_about_defns: bool,\n+pub fn check_item(tcx: TyCtxt, item: &hir::Item, warn_about_defns: bool,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n@@ -503,7 +505,7 @@ pub fn check_item(tcx: &TyCtxt, item: &hir::Item, warn_about_defns: bool,\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n+pub fn check_expr(tcx: TyCtxt, e: &hir::Expr,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     let span;\n     let id = match e.node {\n@@ -564,7 +566,7 @@ pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n-pub fn check_path(tcx: &TyCtxt, path: &hir::Path, id: ast::NodeId,\n+pub fn check_path(tcx: TyCtxt, path: &hir::Path, id: ast::NodeId,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n@@ -576,7 +578,7 @@ pub fn check_path(tcx: &TyCtxt, path: &hir::Path, id: ast::NodeId,\n     }\n }\n \n-pub fn check_path_list_item(tcx: &TyCtxt, item: &hir::PathListItem,\n+pub fn check_path_list_item(tcx: TyCtxt, item: &hir::PathListItem,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n@@ -587,7 +589,7 @@ pub fn check_path_list_item(tcx: &TyCtxt, item: &hir::PathListItem,\n     }\n }\n \n-pub fn check_pat(tcx: &TyCtxt, pat: &hir::Pat,\n+pub fn check_pat(tcx: TyCtxt, pat: &hir::Pat,\n                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n@@ -616,7 +618,7 @@ pub fn check_pat(tcx: &TyCtxt, pat: &hir::Pat,\n     }\n }\n \n-fn maybe_do_stability_check(tcx: &TyCtxt, id: DefId, span: Span,\n+fn maybe_do_stability_check(tcx: TyCtxt, id: DefId, span: Span,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>, &Option<Deprecation>)) {\n     if is_internal(tcx, span) {\n@@ -634,11 +636,11 @@ fn maybe_do_stability_check(tcx: &TyCtxt, id: DefId, span: Span,\n     cb(id, span, &stability, &deprecation);\n }\n \n-fn is_internal(tcx: &TyCtxt, span: Span) -> bool {\n+fn is_internal(tcx: TyCtxt, span: Span) -> bool {\n     tcx.sess.codemap().span_allows_unstable(span)\n }\n \n-fn is_staged_api(tcx: &TyCtxt, id: DefId) -> bool {\n+fn is_staged_api(tcx: TyCtxt, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n             if trait_method_id != id => {\n@@ -651,10 +653,10 @@ fn is_staged_api(tcx: &TyCtxt, id: DefId) -> bool {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup_stability(&self, id: DefId) -> Option<&'tcx Stability> {\n+pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n     if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n         return *st;\n     }\n@@ -664,7 +666,7 @@ pub fn lookup_stability(&self, id: DefId) -> Option<&'tcx Stability> {\n     st\n }\n \n-pub fn lookup_deprecation(&self, id: DefId) -> Option<Deprecation> {\n+pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n     if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n         return depr.clone();\n     }\n@@ -674,7 +676,7 @@ pub fn lookup_deprecation(&self, id: DefId) -> Option<Deprecation> {\n     depr\n }\n \n-fn lookup_stability_uncached(&self, id: DefId) -> Option<&'tcx Stability> {\n+fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n     debug!(\"lookup(id={:?})\", id);\n     if id.is_local() {\n         None // The stability cache is filled partially lazily\n@@ -683,7 +685,7 @@ fn lookup_stability_uncached(&self, id: DefId) -> Option<&'tcx Stability> {\n     }\n }\n \n-fn lookup_deprecation_uncached(&self, id: DefId) -> Option<Deprecation> {\n+fn lookup_deprecation_uncached(self, id: DefId) -> Option<Deprecation> {\n     debug!(\"lookup(id={:?})\", id);\n     if id.is_local() {\n         None // The stability cache is filled partially lazily"}, {"sha": "3d59f8965ed033acbe58af7c57c0855123f2164b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -30,12 +30,12 @@ pub enum LvalueTy<'tcx> {\n                variant_index: usize },\n }\n \n-impl<'tcx> LvalueTy<'tcx> {\n+impl<'a, 'tcx> LvalueTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n         LvalueTy::Ty { ty: ty }\n     }\n \n-    pub fn to_ty(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             LvalueTy::Ty { ty } =>\n                 ty,\n@@ -44,8 +44,7 @@ impl<'tcx> LvalueTy<'tcx> {\n         }\n     }\n \n-    pub fn projection_ty(self,\n-                         tcx: &TyCtxt<'tcx>,\n+    pub fn projection_ty(self, tcx: TyCtxt<'a, 'tcx>,\n                          elem: &LvalueElem<'tcx>)\n                          -> LvalueTy<'tcx>\n     {\n@@ -101,9 +100,8 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self,\n-                      tcx: &TyCtxt<'tcx>,\n+impl<'a, 'tcx> Mir<'tcx> {\n+    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                       operand: &Operand<'tcx>)\n                       -> Ty<'tcx>\n     {\n@@ -113,8 +111,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn binop_ty(&self,\n-                    tcx: &TyCtxt<'tcx>,\n+    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                     op: BinOp,\n                     lhs_ty: Ty<'tcx>,\n                     rhs_ty: Ty<'tcx>)\n@@ -138,8 +135,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn lvalue_ty(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n                      -> LvalueTy<'tcx>\n     {\n@@ -159,8 +155,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn rvalue_ty(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                      rvalue: &Rvalue<'tcx>)\n                      -> Option<Ty<'tcx>>\n     {"}, {"sha": "1d8ca5f84d15e02c94a19c94c831213518baf92a", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -34,7 +34,7 @@ pub enum MirSource {\n }\n \n impl MirSource {\n-    pub fn from_node(tcx: &TyCtxt, id: NodeId) -> MirSource {\n+    pub fn from_node(tcx: TyCtxt, id: NodeId) -> MirSource {\n         use hir::*;\n \n         // Handle constants in enum discriminants, types, and repeat expressions.\n@@ -79,21 +79,21 @@ pub trait Pass {\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>);\n }\n \n /// A pass which inspects Mir of functions in isolation.\n pub trait MirPass<'tcx>: Pass {\n-    fn run_pass_on_promoted(&mut self, tcx: &TyCtxt<'tcx>,\n-                            item_id: NodeId, index: usize,\n-                            mir: &mut Mir<'tcx>) {\n+    fn run_pass_on_promoted<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+                                item_id: NodeId, index: usize,\n+                                mir: &mut Mir<'tcx>) {\n         self.run_pass(tcx, MirSource::Promoted(item_id, index), mir);\n     }\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n         for (&id, mir) in &mut map.map {\n             let def_id = tcx.map.local_def_id(id);\n             let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n@@ -114,7 +114,7 @@ pub struct Passes {\n     plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n }\n \n-impl Passes {\n+impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n         let passes = Passes {\n             passes: Vec::new(),\n@@ -123,17 +123,17 @@ impl Passes {\n         passes\n     }\n \n-    pub fn run_passes<'tcx>(&mut self, pcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n         for pass in &mut self.plugin_passes {\n-            pass.run_pass(pcx, map);\n+            pass.run_pass(tcx, map);\n         }\n         for pass in &mut self.passes {\n-            pass.run_pass(pcx, map);\n+            pass.run_pass(tcx, map);\n         }\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass(&mut self, pass: Box<for<'a> MirMapPass<'a>>) {\n+    pub fn push_pass(&mut self, pass: Box<for<'b> MirMapPass<'b>>) {\n         self.passes.push(pass);\n     }\n }"}, {"sha": "03478eaf61a095a44507d60025234850c02ee10d", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -86,7 +86,8 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n-pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n+pub fn trait_ref_is_knowable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                       trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n@@ -128,9 +129,9 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          impl_def_id: DefId)\n-                          -> Result<(), OrphanCheckErr<'tcx>>\n+pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                              impl_def_id: DefId)\n+                              -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n@@ -149,10 +150,10 @@ pub fn orphan_check<'tcx>(tcx: &TyCtxt<'tcx>,\n     orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n-fn orphan_check_trait_ref<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                trait_ref: &ty::TraitRef<'tcx>,\n-                                infer_is_local: InferIsLocal)\n-                                -> Result<(), OrphanCheckErr<'tcx>>\n+fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                    trait_ref: &ty::TraitRef<'tcx>,\n+                                    infer_is_local: InferIsLocal)\n+                                    -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n            trait_ref, infer_is_local.0);\n@@ -197,10 +198,10 @@ fn orphan_check_trait_ref<'tcx>(tcx: &TyCtxt<'tcx>,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'tcx>(tcx: &TyCtxt<'tcx>,\n-                       ty: Ty<'tcx>,\n-                       infer_is_local: InferIsLocal)\n-                       -> Vec<Ty<'tcx>>\n+fn uncovered_tys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                           ty: Ty<'tcx>,\n+                           infer_is_local: InferIsLocal)\n+                           -> Vec<Ty<'tcx>>\n {\n     if ty_is_local_constructor(tcx, ty, infer_is_local) {\n         vec![]\n@@ -221,13 +222,13 @@ fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn ty_is_local<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n+fn ty_is_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n {\n     ty_is_local_constructor(tcx, ty, infer_is_local) ||\n         fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n-fn fundamental_ty<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool\n+fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool\n {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n@@ -241,10 +242,10 @@ fn fundamental_ty<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool\n     }\n }\n \n-fn ty_is_local_constructor<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 infer_is_local: InferIsLocal)\n-                                 -> bool\n+fn ty_is_local_constructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                     ty: Ty<'tcx>,\n+                                     infer_is_local: InferIsLocal)\n+                                     -> bool\n {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n "}, {"sha": "f1fe990863a4a5c5e9478900283f99ec74903a9b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -558,8 +558,8 @@ pub fn report_selection_error(&self,\n }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-pub fn recursive_type_with_infinite_size_error(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+pub fn recursive_type_with_infinite_size_error(self,\n                                                type_def_id: DefId)\n                                                -> DiagnosticBuilder<'tcx>\n {\n@@ -573,7 +573,7 @@ pub fn recursive_type_with_infinite_size_error(&self,\n     err\n }\n \n-pub fn report_object_safety_error(&self,\n+pub fn report_object_safety_error(self,\n                                   span: Span,\n                                   trait_def_id: DefId,\n                                   warning_node_id: Option<ast::NodeId>,\n@@ -744,7 +744,7 @@ fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n \n     impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx>\n     {\n-        fn tcx(&self) -> &TyCtxt<'tcx> { self.infcx.tcx }\n+        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.infcx.tcx }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             if let ty::TyParam(..) = ty.sty {"}, {"sha": "c7061fc8c2f1bf71f4b4b483f107493c2447ea44", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -111,7 +111,7 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-impl<'tcx> FulfillmentContext<'tcx> {\n+impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n@@ -129,11 +129,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type<'a>(&mut self,\n-                                         infcx: &InferCtxt<'a,'tcx>,\n-                                         projection_ty: ty::ProjectionTy<'tcx>,\n-                                         cause: ObligationCause<'tcx>)\n-                                         -> Ty<'tcx>\n+    pub fn normalize_projection_type(&mut self,\n+                                     infcx: &InferCtxt<'a,'tcx>,\n+                                     projection_ty: ty::ProjectionTy<'tcx>,\n+                                     cause: ObligationCause<'tcx>)\n+                                     -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -154,11 +154,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n-    pub fn register_builtin_bound<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>,\n-                                      ty: Ty<'tcx>,\n-                                      builtin_bound: ty::BuiltinBound,\n-                                      cause: ObligationCause<'tcx>)\n+    pub fn register_builtin_bound(&mut self,\n+                                  infcx: &InferCtxt<'a, 'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: ObligationCause<'tcx>)\n     {\n         match infcx.tcx.predicate_for_builtin_bound(cause, builtin_bound, 0, ty) {\n             Ok(predicate) => {\n@@ -168,17 +168,17 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn register_region_obligation<'a>(&mut self,\n-                                          t_a: Ty<'tcx>,\n-                                          r_b: ty::Region,\n-                                          cause: ObligationCause<'tcx>)\n+    pub fn register_region_obligation(&mut self,\n+                                      t_a: Ty<'tcx>,\n+                                      r_b: ty::Region,\n+                                      cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n-    pub fn register_predicate_obligation<'a>(&mut self,\n-                                             infcx: &InferCtxt<'a,'tcx>,\n-                                             obligation: PredicateObligation<'tcx>)\n+    pub fn register_predicate_obligation(&mut self,\n+                                         infcx: &InferCtxt<'a, 'tcx>,\n+                                         obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -199,9 +199,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n     }\n \n-    pub fn register_rfc1592_obligation<'a>(&mut self,\n-                                           _infcx: &InferCtxt<'a,'tcx>,\n-                                           obligation: PredicateObligation<'tcx>)\n+    pub fn register_rfc1592_obligation(&mut self,\n+                                       _infcx: &InferCtxt<'a,'tcx>,\n+                                       obligation: PredicateObligation<'tcx>)\n     {\n         self.rfc1592_obligations.push(obligation);\n     }\n@@ -216,7 +216,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_rfc1592_obligations<'a>(&mut self,\n+    pub fn select_rfc1592_obligations(&mut self,\n                                       infcx: &InferCtxt<'a,'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n@@ -230,9 +230,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         Ok(())\n     }\n-    pub fn select_all_or_error<'a>(&mut self,\n-                                   infcx: &InferCtxt<'a,'tcx>)\n-                                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n+\n+    pub fn select_all_or_error(&mut self,\n+                               infcx: &InferCtxt<'a,'tcx>)\n+                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -248,9 +249,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible<'a>(&mut self,\n-                                     infcx: &InferCtxt<'a,'tcx>)\n-                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    pub fn select_where_possible(&mut self,\n+                                 infcx: &InferCtxt<'a, 'tcx>)\n+                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n@@ -260,8 +261,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self,\n-                           tcx: &TyCtxt<'tcx>,\n+    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // For \"global\" predicates -- that is, predicates that don't\n@@ -289,10 +289,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n-    fn select<'a>(&mut self,\n-                  selcx: &mut SelectionContext<'a, 'tcx>)\n-                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n@@ -466,7 +464,7 @@ struct AncestorSet<'b, 'tcx: 'b> {\n     backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n }\n \n-impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n+impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n     fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n         AncestorSet {\n             populated: false,\n@@ -479,10 +477,10 @@ impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n     /// to `predicate` (`predicate` is assumed to be fully\n     /// type-resolved).  Returns `None` if not; otherwise, returns\n     /// `Some` with the index within the backtrace.\n-    fn has<'a>(&mut self,\n-               infcx: &InferCtxt<'a, 'tcx>,\n-               predicate: &ty::Predicate<'tcx>)\n-               -> Option<usize> {\n+    fn has(&mut self,\n+           infcx: &InferCtxt<'a, 'tcx>,\n+           predicate: &ty::Predicate<'tcx>)\n+           -> Option<usize> {\n         // the first time, we have to populate the cache\n         if !self.populated {\n             let backtrace = self.backtrace.clone();"}, {"sha": "5419994cdd1f7c81c304776a558a1ebf9e5ad4aa", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -53,8 +53,8 @@ pub enum MethodViolationCode {\n     Generic,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-pub fn is_object_safe(&self, trait_def_id: DefId) -> bool {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n     // Because we query yes/no results frequently, we keep a cache:\n     let def = self.lookup_trait_def(trait_def_id);\n \n@@ -78,7 +78,7 @@ pub fn is_object_safe(&self, trait_def_id: DefId) -> bool {\n /// astconv - currently, Self in supertraits. This is needed\n /// because `object_safety_violations` can't be used during\n /// type collection.\n-pub fn astconv_object_safety_violations(&self, trait_def_id: DefId)\n+pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n                                         -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     let mut violations = vec![];\n@@ -94,15 +94,15 @@ pub fn astconv_object_safety_violations(&self, trait_def_id: DefId)\n     violations\n }\n \n-pub fn object_safety_violations(&self, trait_def_id: DefId)\n+pub fn object_safety_violations(self, trait_def_id: DefId)\n                                 -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     traits::supertrait_def_ids(self, trait_def_id)\n         .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n         .collect()\n }\n \n-fn object_safety_violations_for_trait(&self, trait_def_id: DefId)\n+fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n                                       -> Vec<ObjectSafetyViolation<'tcx>>\n {\n     // Check methods for violations.\n@@ -134,7 +134,7 @@ fn object_safety_violations_for_trait(&self, trait_def_id: DefId)\n     violations\n }\n \n-fn supertraits_reference_self(&self, trait_def_id: DefId) -> bool {\n+fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n     let trait_def = self.lookup_trait_def(trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n     let trait_ref = trait_ref.to_poly_trait_ref();\n@@ -166,13 +166,13 @@ fn supertraits_reference_self(&self, trait_def_id: DefId) -> bool {\n         })\n }\n \n-fn trait_has_sized_self(&self, trait_def_id: DefId) -> bool {\n+fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n     let trait_def = self.lookup_trait_def(trait_def_id);\n     let trait_predicates = self.lookup_predicates(trait_def_id);\n     self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n }\n \n-fn generics_require_sized_self(&self,\n+fn generics_require_sized_self(self,\n                                generics: &ty::Generics<'tcx>,\n                                predicates: &ty::GenericPredicates<'tcx>)\n                                -> bool\n@@ -208,7 +208,7 @@ fn generics_require_sized_self(&self,\n }\n \n /// Returns `Some(_)` if this method makes the containing trait not object safe.\n-fn object_safety_violation_for_method(&self,\n+fn object_safety_violation_for_method(self,\n                                       trait_def_id: DefId,\n                                       method: &ty::Method<'tcx>)\n                                       -> Option<MethodViolationCode>\n@@ -226,7 +226,7 @@ fn object_safety_violation_for_method(&self,\n /// object.  Note that object-safe traits can have some\n /// non-vtable-safe methods, so long as they require `Self:Sized` or\n /// otherwise ensure that they cannot be used when `Self=Trait`.\n-pub fn is_vtable_safe_method(&self,\n+pub fn is_vtable_safe_method(self,\n                              trait_def_id: DefId,\n                              method: &ty::Method<'tcx>)\n                              -> bool\n@@ -238,7 +238,7 @@ pub fn is_vtable_safe_method(&self,\n /// object; this does not necessarily imply that the enclosing trait\n /// is not object safe, because the method might have a where clause\n /// `Self:Sized`.\n-fn virtual_call_violation_for_method(&self,\n+fn virtual_call_violation_for_method(self,\n                                      trait_def_id: DefId,\n                                      method: &ty::Method<'tcx>)\n                                      -> Option<MethodViolationCode>\n@@ -279,7 +279,7 @@ fn virtual_call_violation_for_method(&self,\n     None\n }\n \n-fn contains_illegal_self_type_reference(&self,\n+fn contains_illegal_self_type_reference(self,\n                                         trait_def_id: DefId,\n                                         ty: Ty<'tcx>)\n                                         -> bool"}, {"sha": "49f40e1533d2d7a7958d82852d06351930de50c1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -354,7 +354,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n }\n \n impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx> {\n         self.selcx.tcx()\n     }\n "}, {"sha": "861810de22c2f856a842a78033ce63f150ea01be", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -283,7 +283,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> &'cx TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "0e96f96823f1cf5d0af9e26098452af6882c6561", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -108,7 +108,7 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n-pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+pub fn specializes(tcx: TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     if !tcx.sess.features.borrow().specialization &&"}, {"sha": "b88028a4aae4f1a78bcf2f5746dc219c3d7366ef", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -81,7 +81,7 @@ enum InsertResult<'a, 'tcx: 'a> {\n     Overlapped(Overlap<'a, 'tcx>),\n }\n \n-impl Children {\n+impl<'a, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n             nonblanket_impls: FnvHashMap(),\n@@ -90,7 +90,7 @@ impl Children {\n     }\n \n     /// Insert an impl into this set of children without comparing to any existing impls\n-    fn insert_blindly(&mut self, tcx: &TyCtxt, impl_def_id: DefId) {\n+    fn insert_blindly(&mut self, tcx: TyCtxt, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             self.nonblanket_impls.entry(sty).or_insert(vec![]).push(impl_def_id)\n@@ -101,11 +101,11 @@ impl Children {\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialiation relationships.\n-    fn insert<'a, 'tcx>(&mut self,\n-                        tcx: &'a TyCtxt<'tcx>,\n-                        impl_def_id: DefId,\n-                        simplified_self: Option<SimplifiedType>)\n-                        -> InsertResult<'a, 'tcx>\n+    fn insert(&mut self,\n+              tcx: TyCtxt<'a, 'tcx>,\n+              impl_def_id: DefId,\n+              simplified_self: Option<SimplifiedType>)\n+              -> InsertResult<'a, 'tcx>\n     {\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n@@ -150,19 +150,19 @@ impl Children {\n         InsertResult::BecameNewSibling\n     }\n \n-    fn iter_mut<'a>(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+    fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter_mut());\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }\n \n-    fn filtered_mut<'a>(&'a mut self, sty: SimplifiedType)\n-                        -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+    fn filtered_mut(&'a mut self, sty: SimplifiedType)\n+                    -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.entry(sty).or_insert(vec![]).iter_mut();\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }\n }\n \n-impl Graph {\n+impl<'a, 'tcx> Graph {\n     pub fn new() -> Graph {\n         Graph {\n             parent: Default::default(),\n@@ -173,10 +173,10 @@ impl Graph {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert<'a, 'tcx>(&mut self,\n-                            tcx: &'a TyCtxt<'tcx>,\n-                            impl_def_id: DefId)\n-                            -> Result<(), Overlap<'a, 'tcx>> {\n+    pub fn insert(&mut self,\n+                  tcx: TyCtxt<'a, 'tcx>,\n+                  impl_def_id: DefId)\n+                  -> Result<(), Overlap<'a, 'tcx>> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -235,7 +235,7 @@ impl Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, tcx: &TyCtxt, parent: DefId, child: DefId) {\n+    pub fn record_impl_from_cstore(&mut self, tcx: TyCtxt, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -260,7 +260,7 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl Node {\n+impl<'a, 'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n         match *self {\n             Node::Trait(..) => true,\n@@ -269,7 +269,7 @@ impl Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items<'a, 'tcx>(&self, tcx: &'a TyCtxt<'tcx>) -> NodeItems<'a, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'a, 'tcx>) -> NodeItems<'a, 'tcx> {\n         match *self {\n             Node::Impl(impl_def_id) => {\n                 NodeItems::Impl {\n@@ -299,7 +299,7 @@ impl Node {\n /// An iterator over the items defined within a trait or impl.\n pub enum NodeItems<'a, 'tcx: 'a> {\n     Impl {\n-        tcx: &'a TyCtxt<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx>,\n         items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n         idx: usize,\n     },\n@@ -411,7 +411,7 @@ impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n     /// Search the items from the given ancestors, returning each type definition\n     /// with the given name.\n-    pub fn type_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+    pub fn type_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each fn definition\n     /// with the given name.\n-    pub fn fn_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+    pub fn fn_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -453,7 +453,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each const\n     /// definition with the given name.\n-    pub fn const_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+    pub fn const_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {"}, {"sha": "15819992222c80d749ab781cdb743f0338f37de2", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -18,8 +18,8 @@ use util::nodemap::FnvHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'tcx>(tcx: &TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>)\n-                             -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, pred: &ty::Predicate<'tcx>)\n+                                 -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -52,12 +52,12 @@ fn anonymize_predicate<'tcx>(tcx: &TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>)\n \n \n struct PredicateSet<'a,'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     set: FnvHashSet<ty::Predicate<'tcx>>,\n }\n \n impl<'a,'tcx> PredicateSet<'a,'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> PredicateSet<'a,'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx>) -> PredicateSet<'a,'tcx> {\n         PredicateSet { tcx: tcx, set: FnvHashSet() }\n     }\n \n@@ -88,21 +88,21 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n /// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n /// 'static`.\n pub struct Elaborator<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     stack: Vec<ty::Predicate<'tcx>>,\n     visited: PredicateSet<'cx,'tcx>,\n }\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n     -> Elaborator<'cx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     trait_refs: &[ty::PolyTraitRef<'tcx>])\n     -> Elaborator<'cx, 'tcx>\n {\n@@ -113,7 +113,7 @@ pub fn elaborate_trait_refs<'cx, 'tcx>(\n }\n \n pub fn elaborate_predicates<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>)\n     -> Elaborator<'cx, 'tcx>\n {\n@@ -222,14 +222,14 @@ impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n \n pub type Supertraits<'cx, 'tcx> = FilterToTraits<Elaborator<'cx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n+pub fn supertraits<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n                                     bounds: &[ty::PolyTraitRef<'tcx>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n@@ -240,12 +240,12 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n // Iterator over def-ids of supertraits\n \n pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FnvHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n+pub fn supertrait_def_ids<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n                                      trait_def_id: DefId)\n                                      -> SupertraitDefIds<'cx, 'tcx>\n {\n@@ -391,8 +391,8 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-pub fn trait_ref_for_builtin_bound(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+pub fn trait_ref_for_builtin_bound(self,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n     -> Result<ty::TraitRef<'tcx>, ErrorReported>\n@@ -411,7 +411,7 @@ pub fn trait_ref_for_builtin_bound(&self,\n     }\n }\n \n-pub fn predicate_for_trait_def(&self,\n+pub fn predicate_for_trait_def(self,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: DefId,\n     recursion_depth: usize,\n@@ -426,7 +426,7 @@ pub fn predicate_for_trait_def(&self,\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n-pub fn predicate_for_builtin_bound(&self,\n+pub fn predicate_for_builtin_bound(self,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     recursion_depth: usize,\n@@ -440,7 +440,7 @@ pub fn predicate_for_builtin_bound(&self,\n /// Cast a trait reference into a reference to one of its super\n /// traits; returns `None` if `target_trait_def_id` is not a\n /// supertrait.\n-pub fn upcast_choices(&self,\n+pub fn upcast_choices(self,\n                       source_trait_ref: ty::PolyTraitRef<'tcx>,\n                       target_trait_def_id: DefId)\n                       -> Vec<ty::PolyTraitRef<'tcx>>\n@@ -457,7 +457,7 @@ pub fn upcast_choices(&self,\n /// Given a trait `trait_ref`, returns the number of vtable entries\n /// that come from `trait_ref`, excluding its supertraits. Used in\n /// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n     let mut entries = 0;\n     // Count number of methods and add them to the total offset.\n     // Skip over associated types and constants.\n@@ -472,7 +472,7 @@ pub fn count_own_vtable_entries(&self, trait_ref: ty::PolyTraitRef<'tcx>) -> usi\n /// Given an upcast trait object described by `object`, returns the\n /// index of the method `method_def_id` (which should be part of\n /// `object.upcast_trait_ref`) within the vtable for `object`.\n-pub fn get_vtable_index_of_object_method(&self,\n+pub fn get_vtable_index_of_object_method(self,\n                                          object: &super::VtableObjectData<'tcx>,\n                                          method_def_id: DefId) -> usize {\n     // Count number of methods preceding the one we are selecting and\n@@ -498,7 +498,7 @@ pub fn get_vtable_index_of_object_method(&self,\n          method_def_id);\n }\n \n-pub fn closure_trait_ref_and_return_type(&self,\n+pub fn closure_trait_ref_and_return_type(self,\n     fn_trait_def_id: DefId,\n     self_ty: Ty<'tcx>,\n     sig: &ty::PolyFnSig<'tcx>,"}, {"sha": "c024611d769bfa2260e9b52e07e6befb5853bc90", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -29,18 +29,18 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>\n+    tcx: TyCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx> Match<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> Match<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> Match<'a, 'tcx> {\n         Match { tcx: tcx }\n     }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,"}, {"sha": "8cbe110baec8e2c5b67fb00daaf7936e6566f1c6", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -136,9 +136,10 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n+impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self, tcx: &TyCtxt<'tcx>,\n+    pub fn adjust<F>(&'tcx self,\n+                     tcx: TyCtxt<'a, 'tcx>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n@@ -215,7 +216,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   tcx: &TyCtxt<'tcx>,\n+                                   tcx: TyCtxt<'a, 'tcx>,\n                                    expr_id: ast::NodeId,\n                                    expr_span: Span,\n                                    autoderef: u32, // how many autoderefs so far?\n@@ -243,7 +244,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn adjust_for_autoref(&'tcx self, tcx: &TyCtxt<'tcx>,\n+    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {"}, {"sha": "381b07dc7c88e1bcacb0b9e1ccfc62d9344d1cb5", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -89,7 +89,7 @@ impl TypeContents {\n         self.intersects(TC::InteriorUnsafe)\n     }\n \n-    pub fn needs_drop(&self, _: &TyCtxt) -> bool {\n+    pub fn needs_drop(&self, _: TyCtxt) -> bool {\n         self.intersects(TC::NeedsDrop)\n     }\n \n@@ -139,13 +139,13 @@ impl fmt::Debug for TypeContents {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, tcx: &TyCtxt<'tcx>) -> TypeContents {\n+impl<'a, 'tcx> ty::TyS<'tcx> {\n+    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx>) -> TypeContents {\n         return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n \n-        fn tc_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                       ty: Ty<'tcx>,\n-                       cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                           ty: Ty<'tcx>,\n+                           cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n             // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic\n@@ -255,7 +255,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             result\n         }\n \n-        fn apply_lang_items(tcx: &TyCtxt, did: DefId, tc: TypeContents)\n+        fn apply_lang_items(tcx: TyCtxt, did: DefId, tc: TypeContents)\n                             -> TypeContents {\n             if Some(did) == tcx.lang_items.unsafe_cell_type() {\n                 tc | TC::InteriorUnsafe"}, {"sha": "95e3a5c104cb4b382d3bbef6d075cb9590455686", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 105, "deletions": 87, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -41,6 +41,7 @@ use arena::TypedArena;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n+use std::ops::Deref;\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -138,7 +139,7 @@ pub struct Tables<'tcx> {\n     pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n-impl<'tcx> Tables<'tcx> {\n+impl<'a, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n             node_types: FnvHashMap(),\n@@ -154,7 +155,7 @@ impl<'tcx> Tables<'tcx> {\n     }\n \n     pub fn closure_kind(this: &RefCell<Self>,\n-                        tcx: &TyCtxt<'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx>,\n                         def_id: DefId)\n                         -> ty::ClosureKind {\n         // If this is a local def-id, it should be inserted into the\n@@ -164,13 +165,13 @@ impl<'tcx> Tables<'tcx> {\n             return kind;\n         }\n \n-        let kind = tcx.sess.cstore.closure_kind(tcx, def_id);\n+        let kind = tcx.sess.cstore.closure_kind(def_id);\n         this.borrow_mut().closure_kinds.insert(def_id, kind);\n         kind\n     }\n \n     pub fn closure_type(this: &RefCell<Self>,\n-                        tcx: &TyCtxt<'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx>,\n                         def_id: DefId,\n                         substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n@@ -217,7 +218,19 @@ impl<'tcx> CommonTypes<'tcx> {\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n-pub struct TyCtxt<'tcx> {\n+#[derive(Copy, Clone)]\n+pub struct TyCtxt<'a, 'tcx: 'a> {\n+    gcx: &'a GlobalCtxt<'tcx>\n+}\n+\n+impl<'a, 'tcx> Deref for TyCtxt<'a, 'tcx> {\n+    type Target = &'a GlobalCtxt<'tcx>;\n+    fn deref(&self) -> &&'a GlobalCtxt<'tcx> {\n+        &self.gcx\n+    }\n+}\n+\n+pub struct GlobalCtxt<'tcx> {\n     /// The arenas that types etc are allocated from.\n     arenas: &'tcx CtxtArenas<'tcx>,\n \n@@ -432,43 +445,43 @@ pub struct TyCtxt<'tcx> {\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.crate_disambiguator.get().as_str()\n         } else {\n             self.sess.cstore.crate_disambiguator(cnum)\n         }\n     }\n \n-    pub fn type_parameter_def(&self,\n+    pub fn type_parameter_def(self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>\n     {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n         fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n             &tables.node_types\n         }\n \n         Ref::map(self.tables.borrow(), projection)\n     }\n \n-    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+    pub fn node_type_insert(self, id: NodeId, ty: Ty<'tcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n-    pub fn intern_trait_def(&self, def: ty::TraitDef<'tcx>)\n+    pub fn intern_trait_def(self, def: ty::TraitDef<'tcx>)\n                             -> &'tcx ty::TraitDef<'tcx> {\n         let did = def.trait_ref.def_id;\n         let interned = self.arenas.trait_defs.alloc(def);\n@@ -478,12 +491,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         interned\n     }\n \n-    pub fn alloc_trait_def(&self, def: ty::TraitDef<'tcx>)\n+    pub fn alloc_trait_def(self, def: ty::TraitDef<'tcx>)\n                            -> &'tcx ty::TraitDef<'tcx> {\n         self.arenas.trait_defs.alloc(def)\n     }\n \n-    pub fn intern_adt_def(&self,\n+    pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n                           variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n@@ -497,7 +510,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         interned\n     }\n \n-    pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n+    pub fn intern_stability(self, stab: attr::Stability) -> &'tcx attr::Stability {\n         if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n         }\n@@ -511,7 +524,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         interned\n     }\n \n-    pub fn intern_layout(&self, layout: Layout) -> &'tcx Layout {\n+    pub fn intern_layout(self, layout: Layout) -> &'tcx Layout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n         }\n@@ -525,44 +538,44 @@ impl<'tcx> TyCtxt<'tcx> {\n         interned\n     }\n \n-    pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n+    pub fn store_free_region_map(self, id: NodeId, map: FreeRegionMap) {\n         if self.free_region_maps.borrow_mut().insert(id, map).is_some() {\n             bug!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\", id)\n         }\n     }\n \n-    pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n+    pub fn free_region_map(self, id: NodeId) -> FreeRegionMap {\n         self.free_region_maps.borrow()[&id].clone()\n     }\n \n-    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n \n-    /// Create a type context and call the closure with a `&TyCtxt` reference\n+    /// Create a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                 arenas: &'tcx CtxtArenas<'tcx>,\n-                                 def_map: RefCell<DefMap>,\n-                                 named_region_map: resolve_lifetime::NamedRegionMap,\n-                                 map: ast_map::Map<'tcx>,\n-                                 freevars: FreevarMap,\n+                                  arenas: &'tcx CtxtArenas<'tcx>,\n+                                  def_map: RefCell<DefMap>,\n+                                  named_region_map: resolve_lifetime::NamedRegionMap,\n+                                  map: ast_map::Map<'tcx>,\n+                                  freevars: FreevarMap,\n                                  maybe_unused_trait_imports: NodeSet,\n-                                 region_maps: RegionMaps,\n-                                 lang_items: middle::lang_items::LanguageItems,\n-                                 stability: stability::Index<'tcx>,\n+                                  region_maps: RegionMaps,\n+                                  lang_items: middle::lang_items::LanguageItems,\n+                                  stability: stability::Index<'tcx>,\n                                  crate_name: &str,\n-                                 f: F) -> R\n-                                 where F: FnOnce(&TyCtxt<'tcx>) -> R\n+                                  f: F) -> R\n+                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx>) -> R\n     {\n         let data_layout = TargetDataLayout::parse(s);\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n-        tls::enter(TyCtxt {\n+        tls::enter(GlobalCtxt {\n             arenas: arenas,\n             interner: interner,\n             substs_interner: RefCell::new(FnvHashMap()),\n@@ -637,12 +650,12 @@ impl<'tcx> TyCtxt<'tcx> {\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx> {\n     type Lifted;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted>;\n }\n \n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Ty<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<Ty<'tcx>> {\n         if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n@@ -654,7 +667,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n         if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n@@ -666,7 +679,7 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n \n \n pub mod tls {\n-    use ty::TyCtxt;\n+    use super::{GlobalCtxt, TyCtxt};\n \n     use std::cell::Cell;\n     use std::fmt;\n@@ -675,10 +688,10 @@ pub mod tls {\n     /// Marker type used for the scoped TLS slot.\n     /// The type context cannot be used directly because the scoped TLS\n     /// in libstd doesn't allow types generic over lifetimes.\n-    struct ThreadLocalTyCx;\n+    enum ThreadLocalGlobalCtxt {}\n \n     thread_local! {\n-        static TLS_TCX: Cell<Option<*const ThreadLocalTyCx>> = Cell::new(None)\n+        static TLS_TCX: Cell<Option<*const ThreadLocalGlobalCtxt>> = Cell::new(None)\n     }\n \n     fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -687,15 +700,18 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F: FnOnce(&TyCtxt<'tcx>) -> R, R>(tcx: TyCtxt<'tcx>, f: F) -> R {\n+    pub fn enter<'tcx, F: for<'a> FnOnce(TyCtxt<'a, 'tcx>) -> R, R>(gcx: GlobalCtxt<'tcx>,\n+                                                                    f: F) -> R {\n         codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n-            let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n+            let tls_ptr = &gcx as *const _ as *const ThreadLocalGlobalCtxt;\n             let result = TLS_TCX.with(|tls| {\n                 let prev = tls.get();\n                 tls.set(Some(tls_ptr));\n-                let ret = f(&tcx);\n+                let ret = f(TyCtxt {\n+                    gcx: &gcx\n+                });\n                 tls.set(prev);\n                 ret\n             });\n@@ -704,14 +720,16 @@ pub mod tls {\n         })\n     }\n \n-    pub fn with<F: FnOnce(&TyCtxt) -> R, R>(f: F) -> R {\n+    pub fn with<F: FnOnce(TyCtxt) -> R, R>(f: F) -> R {\n         TLS_TCX.with(|tcx| {\n             let tcx = tcx.get().unwrap();\n-            f(unsafe { &*(tcx as *const TyCtxt) })\n+            f(TyCtxt {\n+                gcx: unsafe { &*(tcx as *const GlobalCtxt) }\n+            })\n         })\n     }\n \n-    pub fn with_opt<F: FnOnce(Option<&TyCtxt>) -> R, R>(f: F) -> R {\n+    pub fn with_opt<F: FnOnce(Option<TyCtxt>) -> R, R>(f: F) -> R {\n         if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n             with(|v| f(Some(v)))\n         } else {\n@@ -735,7 +753,7 @@ macro_rules! sty_debug_print {\n                 both_infer: usize,\n             }\n \n-            pub fn go(tcx: &TyCtxt) {\n+            pub fn go(tcx: TyCtxt) {\n                 let mut total = DebugStat {\n                     total: 0,\n                     region_infer: 0, ty_infer: 0, both_infer: 0,\n@@ -782,8 +800,8 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn print_debug_stats(&self) {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n             TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n@@ -830,9 +848,9 @@ fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     // Type constructors\n-    pub fn mk_substs(&self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n+    pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n         if let Some(substs) = self.substs_interner.borrow().get(&substs) {\n             return *substs;\n         }\n@@ -843,7 +861,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Create an unsafe fn ty based on a safe fn ty.\n-    pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n+    pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n         assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n         self.mk_fn_ptr(ty::BareFnTy {\n             unsafety: hir::Unsafety::Unsafe,\n@@ -852,7 +870,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n+    pub fn mk_bare_fn(self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n         if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n             return *bare_fn;\n         }\n@@ -862,7 +880,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         bare_fn\n     }\n \n-    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n+    pub fn mk_region(self, region: Region) -> &'tcx Region {\n         if let Some(region) = self.region_interner.borrow().get(&region) {\n             return *region;\n         }\n@@ -902,11 +920,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Interns a type/name combination, stores the resulting box in cx.interner,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n         TyCtxt::intern_ty(&self.arenas.type_, &self.interner, st)\n     }\n \n-    pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n+    pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Is   => self.types.isize,\n             ast::IntTy::I8   => self.types.i8,\n@@ -916,7 +934,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n+    pub fn mk_mach_uint(self, tm: ast::UintTy) -> Ty<'tcx> {\n         match tm {\n             ast::UintTy::Us   => self.types.usize,\n             ast::UintTy::U8   => self.types.u8,\n@@ -926,89 +944,89 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n+    pub fn mk_mach_float(self, tm: ast::FloatTy) -> Ty<'tcx> {\n         match tm {\n             ast::FloatTy::F32  => self.types.f32,\n             ast::FloatTy::F64  => self.types.f64,\n         }\n     }\n \n-    pub fn mk_str(&self) -> Ty<'tcx> {\n+    pub fn mk_str(self) -> Ty<'tcx> {\n         self.mk_ty(TyStr)\n     }\n \n-    pub fn mk_static_str(&self) -> Ty<'tcx> {\n+    pub fn mk_static_str(self) -> Ty<'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_enum(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyEnum(def, substs))\n     }\n \n-    pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyBox(ty))\n     }\n \n-    pub fn mk_ptr(&self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRawPtr(tm))\n     }\n \n-    pub fn mk_ref(&self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ref(self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRef(r, tm))\n     }\n \n-    pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n-    pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n-    pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n+    pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n         self.mk_imm_ptr(self.mk_nil())\n     }\n \n-    pub fn mk_array(&self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+    pub fn mk_array(self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, n))\n     }\n \n-    pub fn mk_slice(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TySlice(ty))\n     }\n \n-    pub fn mk_tup(&self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n+    pub fn mk_tup(self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n         self.mk_ty(TyTuple(ts))\n     }\n \n-    pub fn mk_nil(&self) -> Ty<'tcx> {\n+    pub fn mk_nil(self) -> Ty<'tcx> {\n         self.mk_tup(Vec::new())\n     }\n \n-    pub fn mk_bool(&self) -> Ty<'tcx> {\n+    pub fn mk_bool(self) -> Ty<'tcx> {\n         self.mk_ty(TyBool)\n     }\n \n-    pub fn mk_fn_def(&self, def_id: DefId,\n+    pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>,\n                      fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyFnDef(def_id, substs, self.mk_bare_fn(fty)))\n     }\n \n-    pub fn mk_fn_ptr(&self, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_fn_ptr(self, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyFnPtr(self.mk_bare_fn(fty)))\n     }\n \n-    pub fn mk_trait(&self,\n+    pub fn mk_trait(self,\n                     principal: ty::PolyTraitRef<'tcx>,\n                     bounds: ExistentialBounds<'tcx>)\n                     -> Ty<'tcx>\n@@ -1022,7 +1040,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(TyTrait(inner))\n     }\n \n-    pub fn mk_projection(&self,\n+    pub fn mk_projection(self,\n                          trait_ref: TraitRef<'tcx>,\n                          item_name: Name)\n                          -> Ty<'tcx> {\n@@ -1031,12 +1049,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_struct(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyStruct(def, substs))\n     }\n \n-    pub fn mk_closure(&self,\n+    pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,\n                       tys: Vec<Ty<'tcx>>)\n@@ -1047,45 +1065,45 @@ impl<'tcx> TyCtxt<'tcx> {\n         }))\n     }\n \n-    pub fn mk_closure_from_closure_substs(&self,\n+    pub fn mk_closure_from_closure_substs(self,\n                                           closure_id: DefId,\n                                           closure_substs: Box<ClosureSubsts<'tcx>>)\n                                           -> Ty<'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n-    pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n+    pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }\n \n-    pub fn mk_int_var(&self, v: IntVid) -> Ty<'tcx> {\n+    pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n         self.mk_infer(IntVar(v))\n     }\n \n-    pub fn mk_float_var(&self, v: FloatVid) -> Ty<'tcx> {\n+    pub fn mk_float_var(self, v: FloatVid) -> Ty<'tcx> {\n         self.mk_infer(FloatVar(v))\n     }\n \n-    pub fn mk_infer(&self, it: InferTy) -> Ty<'tcx> {\n+    pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n         self.mk_ty(TyInfer(it))\n     }\n \n-    pub fn mk_param(&self,\n+    pub fn mk_param(self,\n                     space: subst::ParamSpace,\n                     index: u32,\n                     name: Name) -> Ty<'tcx> {\n         self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n     }\n \n-    pub fn mk_self_type(&self) -> Ty<'tcx> {\n+    pub fn mk_self_type(self) -> Ty<'tcx> {\n         self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n-    pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+    pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n \n-    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n+    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.trait_item_def_ids(trait_did);\n             Rc::new(def_ids.iter()\n@@ -1095,7 +1113,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n+    pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {\n             Rc::new(if did.is_local() {\n                 self.get_attrs(did).iter().flat_map(|meta| {"}, {"sha": "48f3e0e0bf76ed2d557e1d840bb282be4c613a11", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n }\n \n impl<'tcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, tcx: &TyCtxt) -> String {\n+    fn sort_string(&self, tcx: TyCtxt) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n@@ -252,8 +252,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder,\n                                      err: &TypeError<'tcx>,\n                                      sp: Span) {"}, {"sha": "ff257e0c3b5283ec726f87e9c036622aa8d9da75", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -43,7 +43,7 @@ pub enum SimplifiedType {\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type(tcx: &TyCtxt,\n+pub fn simplify_type(tcx: TyCtxt,\n                      ty: Ty,\n                      can_simplify_params: bool)\n                      -> Option<SimplifiedType>"}, {"sha": "c01842d8af4208404b31317f62f3a1a2724d7d79", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -114,7 +114,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n pub trait TypeFolder<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -202,14 +202,14 @@ pub trait TypeVisitor<'tcx> : Sized {\n // Some sample folders\n \n pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub fldop: F,\n }\n \n impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = ty.super_fold_with(self);\n@@ -220,10 +220,10 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n-    pub fn collect_regions<T>(&self,\n+    pub fn collect_regions<T>(self,\n         value: &T,\n         region_set: &mut FnvHashSet<ty::Region>)\n         -> bool\n@@ -238,7 +238,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Folds the escaping and free regions in `value` using `f`, and\n     /// sets `skipped_regions` to true if any late-bound region was found\n     /// and skipped.\n-    pub fn fold_regions<T,F>(&self,\n+    pub fn fold_regions<T,F>(self,\n         value: &T,\n         skipped_regions: &mut bool,\n         mut f: F)\n@@ -260,14 +260,14 @@ impl<'tcx> TyCtxt<'tcx> {\n /// visited by `fld_r`.\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: &'a TyCtxt<'tcx>,\n+    pub fn new<F>(tcx: TyCtxt<'a, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -315,14 +315,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n // Replaces the escaping regions in a type.\n \n struct RegionReplacer<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn replace_late_bound_regions<T,F>(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n         -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n@@ -337,7 +337,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n-    pub fn liberate_late_bound_regions<T>(&self,\n+    pub fn liberate_late_bound_regions<T>(self,\n         all_outlive_scope: region::CodeExtent,\n         value: &Binder<T>)\n         -> T\n@@ -350,7 +350,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n-    pub fn flatten_late_bound_regions<T>(&self, bound2_value: &Binder<Binder<T>>)\n+    pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n                                          -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n@@ -371,7 +371,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         Binder(value)\n     }\n \n-    pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n+    pub fn no_late_bound_regions<T>(self, value: &Binder<T>) -> Option<T>\n         where T : TypeFoldable<'tcx>\n     {\n         if value.0.has_escaping_regions() {\n@@ -383,7 +383,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n     /// method lookup and a few other places where precise region relationships are not required.\n-    pub fn erase_late_bound_regions<T>(&self, value: &Binder<T>) -> T\n+    pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |_| ty::ReStatic).0\n@@ -397,7 +397,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n     /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(&self, sig: &Binder<T>) -> Binder<T>\n+    pub fn anonymize_late_bound_regions<T>(self, sig: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n@@ -409,7 +409,7 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n-    fn new<F>(tcx: &'a TyCtxt<'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n+    fn new<F>(tcx: TyCtxt<'a, 'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n     {\n         RegionReplacer {\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -463,22 +463,22 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n-    pub fn erase_regions<T>(&self, value: &T) -> T\n+    pub fn erase_regions<T>(self, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         let value1 = value.fold_with(&mut RegionEraser(self));\n         debug!(\"erase_regions({:?}) = {:?}\",\n                value, value1);\n         return value1;\n \n-        struct RegionEraser<'a, 'tcx: 'a>(&'a TyCtxt<'tcx>);\n+        struct RegionEraser<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx>);\n \n         impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-            fn tcx(&self) -> &TyCtxt<'tcx> { self.0 }\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.0 }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n@@ -543,8 +543,8 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &TyCtxt<'tcx>,\n-                                                 amount: u32, value: &T) -> T {\n+pub fn shift_regions<'a, 'tcx, T:TypeFoldable<'tcx>>(tcx: TyCtxt<'a, 'tcx>,\n+                                                     amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);\n "}, {"sha": "aef54b75db59cebe7cd102ec175cf7c54fde0491", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -14,24 +14,24 @@ use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root.\n-    pub fn item_path_str(&self, def_id: DefId) -> String {\n+    pub fn item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Local);\n         self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n     }\n \n     /// Returns a string identifying this local node-id.\n-    pub fn node_path_str(&self, id: ast::NodeId) -> String {\n+    pub fn node_path_str(self, id: ast::NodeId) -> String {\n         self.item_path_str(self.map.local_def_id(id))\n     }\n \n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_item_path_str(&self, def_id: DefId) -> String {\n+    pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n         self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n@@ -40,7 +40,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(&self, buffer: &mut T, cnum: ast::CrateNum)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: ast::CrateNum)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -83,7 +83,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n     /// declared with an `extern crate`, the path is guarenteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(&self, buffer: &mut T, external_def_id: DefId) -> bool\n+    pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n         where T: ItemPathBuffer\n     {\n         let visible_parent_map = self.sess.cstore.visible_parent_map();\n@@ -116,7 +116,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn push_item_path<T>(&self, buffer: &mut T, def_id: DefId)\n+    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -164,7 +164,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn push_impl_path<T>(&self,\n+    fn push_impl_path<T>(self,\n                          buffer: &mut T,\n                          impl_def_id: DefId)\n         where T: ItemPathBuffer\n@@ -253,7 +253,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn push_impl_path_fallback<T>(&self,\n+    fn push_impl_path_fallback<T>(self,\n                                   buffer: &mut T,\n                                   impl_def_id: DefId)\n         where T: ItemPathBuffer\n@@ -284,7 +284,7 @@ impl<'tcx> TyCtxt<'tcx> {\n /// function tries to find a \"characteristic def-id\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type<'tcx>(ty: Ty<'tcx>) -> Option<DefId> {\n+pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyStruct(adt_def, _) |\n         ty::TyEnum(adt_def, _) => Some(adt_def.did),"}, {"sha": "aef67552df59f2c206f718de7f51599b1265cbbc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -364,7 +364,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: &TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+    pub fn repr_discr(tcx: TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there"}, {"sha": "91cac6999aad66e7d4e00653fc84ffd8eae85388", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 91, "deletions": 94, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -165,10 +165,10 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-impl<'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars<'a>(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n-                                  impl_def_id: DefId)\n-                                  -> ImplHeader<'tcx>\n+impl<'a, 'tcx> ImplHeader<'tcx> {\n+    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n+                              impl_def_id: DefId)\n+                              -> ImplHeader<'tcx>\n     {\n         let tcx = selcx.tcx();\n         let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n@@ -303,7 +303,7 @@ impl<'a> NodeIdTree for ast_map::Map<'a> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n@@ -773,22 +773,21 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n-impl<'tcx> GenericPredicates<'tcx> {\n+impl<'a, 'tcx> GenericPredicates<'tcx> {\n     pub fn empty() -> GenericPredicates<'tcx> {\n         GenericPredicates {\n             predicates: VecPerParamSpace::empty(),\n         }\n     }\n \n-    pub fn instantiate(&self, tcx: &TyCtxt<'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'a, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n \n-    pub fn instantiate_supertrait(&self,\n-                                  tcx: &TyCtxt<'tcx>,\n+    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n@@ -833,14 +832,13 @@ pub enum Predicate<'tcx> {\n     ClosureKind(DefId, ClosureKind),\n }\n \n-impl<'tcx> Predicate<'tcx> {\n+impl<'a, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions.  See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self,\n-                            tcx: &TyCtxt<'tcx>,\n+    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n                             -> ty::Predicate<'tcx>\n     {\n@@ -1212,7 +1210,7 @@ impl<'tcx> TraitRef<'tcx> {\n /// more distinctions clearer.\n #[derive(Clone)]\n pub struct ParameterEnvironment<'a, 'tcx:'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n \n     /// See `construct_free_substs` for details.\n     pub free_substs: Substs<'tcx>,\n@@ -1262,7 +1260,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     }\n \n     /// Construct a parameter environment given an item, impl item, or trait item\n-    pub fn for_item(tcx: &'a TyCtxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n+    pub fn for_item(tcx: TyCtxt<'a, 'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n@@ -1570,8 +1568,8 @@ impl VariantKind {\n     }\n }\n \n-impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n-    fn new(tcx: &TyCtxt<'tcx>,\n+impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n            variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n@@ -1601,7 +1599,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n         }\n     }\n \n-    fn calculate_dtorck(&'tcx self, tcx: &TyCtxt<'tcx>) {\n+    fn calculate_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx>) {\n         if tcx.is_adt_dtorck(self) {\n             self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n@@ -1622,7 +1620,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n-    pub fn is_dtorck(&'tcx self, tcx: &TyCtxt<'tcx>) -> bool {\n+    pub fn is_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx>) -> bool {\n         if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n@@ -1663,12 +1661,12 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn type_scheme(&self, tcx: &TyCtxt<'tcx>) -> TypeScheme<'tcx> {\n+    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'tcx>) -> TypeScheme<'tcx> {\n         tcx.lookup_item_type(self.did)\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: &TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx>) -> GenericPredicates<'tcx> {\n         tcx.lookup_predicates(self.did)\n     }\n \n@@ -1756,7 +1754,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: &ty::TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         let dep_node = DepNode::SizedConstraint(self.did);\n         match self.sized_constraint.get(dep_node) {\n             None => {\n@@ -1769,7 +1767,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> AdtDefData<'tcx, 'tcx> {\n+impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     /// Calculates the Sized-constraint.\n     ///\n     /// As the Sized-constraint of enums can be a *set* of types,\n@@ -1785,7 +1783,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: TyCtxt<'a, 'tcx>,\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n \n@@ -1838,7 +1836,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n \n     fn sized_constraint_for_ty(\n         &'tcx self,\n-        tcx: &ty::TyCtxt<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx>,\n         stack: &mut Vec<AdtDefMaster<'tcx>>,\n         ty: Ty<'tcx>\n     ) -> Vec<Ty<'tcx>> {\n@@ -1953,7 +1951,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n+impl<'a, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n                vis: Visibility) -> Self {\n@@ -1965,7 +1963,7 @@ impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n         }\n     }\n \n-    pub fn ty(&self, tcx: &TyCtxt<'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'a, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         self.unsubst_ty().subst(tcx, subst)\n     }\n \n@@ -1996,7 +1994,7 @@ pub enum ClosureKind {\n }\n \n impl ClosureKind {\n-    pub fn trait_did(&self, tcx: &TyCtxt) -> DefId {\n+    pub fn trait_did(&self, tcx: TyCtxt) -> DefId {\n         let result = match *self {\n             ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n             ClosureKind::FnMut => {\n@@ -2146,20 +2144,20 @@ impl BorrowKind {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn node_id_to_type(self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n            None => bug!(\"node_id_to_type: no type for node `{}`\",\n                         self.map.node_to_string(id))\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'tcx>> {\n         self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(&self, id: NodeId) -> ItemSubsts<'tcx> {\n+    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'tcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n             None => ItemSubsts::empty(),\n             Some(ts) => ts.clone(),\n@@ -2168,10 +2166,10 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'tcx> {\n         self.node_id_to_type(pat.id)\n     }\n-    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n         self.node_id_to_type_opt(pat.id)\n     }\n \n@@ -2185,11 +2183,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'tcx> {\n         self.node_id_to_type(expr.id)\n     }\n \n-    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n@@ -2202,7 +2200,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// hard to do, I just hate that code so much I didn't want to touch it\n     /// unless it was to fix it properly, which seemed a distraction from the\n     /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'tcx> {\n         self.expr_ty(expr)\n             .adjust(self, expr.span, expr.id,\n                     self.tables.borrow().adjustments.get(&expr.id),\n@@ -2211,7 +2209,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n         self.expr_ty_opt(expr).map(|t| t.adjust(self,\n                                                 expr.span,\n                                                 expr.id,\n@@ -2221,7 +2219,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }))\n     }\n \n-    pub fn expr_span(&self, id: NodeId) -> Span {\n+    pub fn expr_span(self, id: NodeId) -> Span {\n         match self.map.find(id) {\n             Some(ast_map::NodeExpr(e)) => {\n                 e.span\n@@ -2235,7 +2233,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn local_var_name_str(&self, id: NodeId) -> InternedString {\n+    pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n@@ -2249,7 +2247,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(&self, expr: &hir::Expr) -> Def {\n+    pub fn resolve_expr(self, expr: &hir::Expr) -> Def {\n         match self.def_map.borrow().get(&expr.id) {\n             Some(def) => def.full_def(),\n             None => {\n@@ -2258,7 +2256,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn expr_is_lval(&self, expr: &hir::Expr) -> bool {\n+    pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(..) => {\n                 // We can't use resolve_expr here, as this needs to run on broken\n@@ -2320,7 +2318,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n                 ms.iter().filter_map(|ti| {\n@@ -2345,7 +2343,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn associated_consts(&self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n                 ItemTrait(_, _, _, ref tis) => {\n@@ -2389,7 +2387,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n+    pub fn trait_impl_polarity(self, id: DefId) -> Option<hir::ImplPolarity> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.find(id) {\n                 Some(ast_map::NodeItem(item)) => {\n@@ -2405,7 +2403,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n+    pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         self.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n@@ -2424,29 +2422,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n+    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n             || self.sess.cstore.impl_or_trait_item(self, id)\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn trait_item_def_ids(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n             \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n             || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n-    pub fn impl_trait_ref(&self, id: DefId) -> Option<TraitRef<'tcx>> {\n+    pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'tcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n             || self.sess.cstore.impl_trait_ref(self, id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(&self, id: DefId) -> bool {\n+    pub fn is_impl(self, id: DefId) -> bool {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             if let Some(ast_map::NodeItem(\n                 &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n@@ -2459,11 +2457,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(&self, tr: &hir::TraitRef) -> DefId {\n+    pub fn trait_ref_to_def_id(self, tr: &hir::TraitRef) -> DefId {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n-    pub fn def_key(&self, id: DefId) -> ast_map::DefKey {\n+    pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n             self.map.def_key(id)\n         } else {\n@@ -2474,15 +2472,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefPath` of an item. Note that if `id` is not\n     /// local to this crate -- or is inlined into this crate -- the\n     /// result will be a non-local `DefPath`.\n-    pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n+    pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n             self.sess.cstore.relative_def_path(id)\n         }\n     }\n \n-    pub fn item_name(&self, id: DefId) -> ast::Name {\n+    pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else {\n@@ -2491,20 +2489,20 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(&self, did: DefId, ty: TypeScheme<'tcx>) {\n+    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(&self, did: DefId) -> TypeScheme<'tcx> {\n+    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n             || self.sess.cstore.item_type(self, did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(&self, did: DefId) -> &'tcx TraitDef<'tcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'tcx TraitDef<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n             || self.alloc_trait_def(self.sess.cstore.trait_def(self, did))\n@@ -2514,29 +2512,29 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Given the did of an ADT, return a master reference to its\n     /// definition. Unless you are planning on fulfilling the ADT's fields,\n     /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(&self, did: DefId) -> AdtDefMaster<'tcx> {\n+    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n             || self.sess.cstore.adt_def(self, did)\n         )\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(&self, did: DefId) -> AdtDef<'tcx> {\n+    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'tcx> {\n         // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n         // would be needed here.\n         self.lookup_adt_def_master(did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n             || self.sess.cstore.item_predicates(self, did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'tcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n             || self.sess.cstore.item_super_predicates(self, did))\n@@ -2548,9 +2546,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `type_needs_drop` will definitely return `true` for `ty`.)\n-    pub fn type_needs_drop_given_env<'a>(&self,\n+    pub fn type_needs_drop_given_env<'b>(self,\n                                          ty: Ty<'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n+                                         param_env: &ty::ParameterEnvironment<'b,'tcx>) -> bool {\n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n         // know whether the type implements Copy (and thus needs no\n@@ -2576,7 +2574,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn get_attrs(self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {\n             Cow::Borrowed(self.map.attrs(id))\n         } else {\n@@ -2585,42 +2583,42 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Determine whether an item is annotated with an attribute\n-    pub fn has_attr(&self, did: DefId, attr: &str) -> bool {\n+    pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n         self.get_attrs(did).iter().any(|item| item.check_name(attr))\n     }\n \n     /// Determine whether an item is annotated with `#[repr(packed)]`\n-    pub fn lookup_packed(&self, did: DefId) -> bool {\n+    pub fn lookup_packed(self, did: DefId) -> bool {\n         self.lookup_repr_hints(did).contains(&attr::ReprPacked)\n     }\n \n     /// Determine whether an item is annotated with `#[simd]`\n-    pub fn lookup_simd(&self, did: DefId) -> bool {\n+    pub fn lookup_simd(self, did: DefId) -> bool {\n         self.has_attr(did, \"simd\")\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n+    pub fn item_variances(self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n             || Rc::new(self.sess.cstore.item_variances(item_id)))\n     }\n \n-    pub fn trait_has_default_impl(&self, trait_def_id: DefId) -> bool {\n+    pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n         self.populate_implementations_for_trait_if_necessary(trait_def_id);\n \n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n     /// Records a trait-to-implementation mapping.\n-    pub fn record_trait_has_default_impl(&self, trait_def_id: DefId) {\n+    pub fn record_trait_has_default_impl(self, trait_def_id: DefId) {\n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n     /// Load primitive inherent implementations if necessary\n-    pub fn populate_implementations_for_primitive_if_necessary(&self,\n+    pub fn populate_implementations_for_primitive_if_necessary(self,\n                                                                primitive_def_id: DefId) {\n         if primitive_def_id.is_local() {\n             return\n@@ -2646,7 +2644,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n-    pub fn populate_inherent_implementations_for_type_if_necessary(&self,\n+    pub fn populate_inherent_implementations_for_type_if_necessary(self,\n                                                                    type_id: DefId) {\n         if type_id.is_local() {\n             return\n@@ -2676,7 +2674,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(&self, trait_id: DefId) {\n+    pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n         if trait_id.is_local() {\n             return\n         }\n@@ -2723,11 +2721,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n \n-    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n+    pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n         Tables::closure_kind(&self.tables, self, def_id)\n     }\n \n-    pub fn closure_type(&self,\n+    pub fn closure_type(self,\n                         def_id: DefId,\n                         substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n@@ -2737,13 +2735,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n-    pub fn trait_id_of_impl(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n     /// If the given def ID describes a method belonging to an impl, return the\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n-    pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.impl_or_trait_item(self, def_id).and_then(|item| {\n                 match item.container() {\n@@ -2766,7 +2764,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// If the given def ID describes an item belonging to a trait (either a\n     /// default method or an implementation of a trait method), return the ID of\n     /// the trait that the method belongs to. Otherwise, return `None`.\n-    pub fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn trait_of_item(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n             return self.sess.cstore.trait_of_item(self, def_id);\n         }\n@@ -2787,7 +2785,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(&self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n         let impl_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n@@ -2805,8 +2803,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n-    pub fn empty_parameter_environment<'a>(&'a self)\n-                                           -> ParameterEnvironment<'a,'tcx> {\n+    pub fn empty_parameter_environment(self) -> ParameterEnvironment<'a,'tcx> {\n \n         // for an empty parameter environment, there ARE no free\n         // regions, so it shouldn't matter what we use for the free id\n@@ -2825,7 +2822,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(&self, generics: &Generics<'tcx>,\n+    pub fn construct_free_substs(self, generics: &Generics<'tcx>,\n                                  free_id_outlive: CodeExtent) -> Substs<'tcx> {\n         // map T => T\n         let mut types = VecPerParamSpace::empty();\n@@ -2854,12 +2851,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// See `ParameterEnvironment` struct def'n for details.\n     /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n     /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n-    pub fn construct_parameter_environment<'a>(&'a self,\n-                                               span: Span,\n-                                               generics: &ty::Generics<'tcx>,\n-                                               generic_predicates: &ty::GenericPredicates<'tcx>,\n-                                               free_id_outlive: CodeExtent)\n-                                               -> ParameterEnvironment<'a, 'tcx>\n+    pub fn construct_parameter_environment(self,\n+                                           span: Span,\n+                                           generics: &ty::Generics<'tcx>,\n+                                           generic_predicates: &ty::GenericPredicates<'tcx>,\n+                                           free_id_outlive: CodeExtent)\n+                                           -> ParameterEnvironment<'a, 'tcx>\n     {\n         //\n         // Construct the free substs.\n@@ -2902,20 +2899,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         traits::normalize_param_env_or_error(unnormalized_env, cause)\n     }\n \n-    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n-    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n                                                                             autoderefs))\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n-    pub fn visit_all_items_in_krate<V,F>(&self,\n+    pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n         where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n@@ -2925,7 +2922,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(&self, impl_did: DefId) -> Result<Span, InternedString> {\n+    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, InternedString> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))\n@@ -2944,8 +2941,8 @@ pub enum ExplicitSelfCategory {\n     ByBox,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn with_freevars<T, F>(&self, fid: NodeId, f: F) -> T where\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n         match self.freevars.borrow().get(&fid) {"}, {"sha": "9bddd8383cdaa62da9942411192d89380eb30697", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -29,7 +29,7 @@ pub enum Cause {\n }\n \n pub trait TypeRelation<'a,'tcx> : Sized {\n-    fn tcx(&self) -> &'a TyCtxt<'tcx>;\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;"}, {"sha": "d20417714e5a009de210c004f77c0a70a95596f6", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -24,14 +24,14 @@ use hir;\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -48,14 +48,14 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n \n impl<'tcx> Lift<'tcx> for ty::Region {\n     type Lifted = Self;\n-    fn lift_to_tcx(&self, _: &TyCtxt<'tcx>) -> Option<ty::Region> {\n+    fn lift_to_tcx(&self, _: TyCtxt) -> Option<ty::Region> {\n         Some(*self)\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n     type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<TraitRef<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| TraitRef {\n             def_id: self.def_id,\n             substs: substs\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref: trait_ref\n         })\n@@ -74,21 +74,21 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n     type Lifted = ty::EquatePredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n     }\n }\n \n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy {\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).map(|x| ty::Binder(x))\n     }\n }"}, {"sha": "6dd406c3f8c09449730b63d5b75285a7bd7ae079", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -270,7 +270,7 @@ pub struct TraitTy<'tcx> {\n     pub bounds: ExistentialBounds<'tcx>,\n }\n \n-impl<'tcx> TraitTy<'tcx> {\n+impl<'a, 'tcx> TraitTy<'tcx> {\n     pub fn principal_def_id(&self) -> DefId {\n         self.principal.0.def_id\n     }\n@@ -279,8 +279,7 @@ impl<'tcx> TraitTy<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self,\n-                                            tcx: &TyCtxt<'tcx>,\n+    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                                             self_ty: Ty<'tcx>)\n                                             -> ty::PolyTraitRef<'tcx>\n     {\n@@ -293,8 +292,7 @@ impl<'tcx> TraitTy<'tcx> {\n         })\n     }\n \n-    pub fn projection_bounds_with_self_ty(&self,\n-                                          tcx: &TyCtxt<'tcx>,\n+    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n                                           self_ty: Ty<'tcx>)\n                                           -> Vec<ty::PolyProjectionPredicate<'tcx>>\n     {\n@@ -523,7 +521,7 @@ pub struct ParamTy {\n     pub name: Name,\n }\n \n-impl ParamTy {\n+impl<'a, 'tcx> ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: u32,\n                name: Name)\n@@ -539,7 +537,7 @@ impl ParamTy {\n         ParamTy::new(def.space, def.index, def.name)\n     }\n \n-    pub fn to_ty<'tcx>(self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_param(self.space, self.idx, self.name)\n     }\n \n@@ -764,7 +762,7 @@ impl<'tcx> ExistentialBounds<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n-impl BuiltinBounds {\n+impl<'a, 'tcx> BuiltinBounds {\n     pub fn empty() -> BuiltinBounds {\n         BuiltinBounds(EnumSet::new())\n     }\n@@ -773,9 +771,9 @@ impl BuiltinBounds {\n         self.into_iter()\n     }\n \n-    pub fn to_predicates<'tcx>(&self,\n-                               tcx: &TyCtxt<'tcx>,\n-                               self_ty: Ty<'tcx>) -> Vec<ty::Predicate<'tcx>> {\n+    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'tcx>,\n+                         self_ty: Ty<'tcx>)\n+                         -> Vec<ty::Predicate<'tcx>> {\n         self.iter().filter_map(|builtin_bound|\n             match tcx.trait_ref_for_builtin_bound(builtin_bound, self_ty) {\n                 Ok(trait_ref) => Some(trait_ref.to_predicate()),\n@@ -821,8 +819,8 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn try_add_builtin_trait(&self,\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn try_add_builtin_trait(self,\n                                  trait_def_id: DefId,\n                                  builtin_bounds: &mut EnumSet<BuiltinBound>)\n                                  -> bool\n@@ -886,7 +884,7 @@ impl Region {\n }\n \n // Type utilities\n-impl<'tcx> TyS<'tcx> {\n+impl<'a, 'tcx> TyS<'tcx> {\n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n         match self.sty {\n             ty::TyParam(ref d) => Some(d.clone()),\n@@ -901,7 +899,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, _cx: &TyCtxt) -> bool {\n+    pub fn is_empty(&self, _cx: TyCtxt) -> bool {\n         // FIXME(#24885): be smarter here\n         match self.sty {\n             TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n@@ -973,15 +971,15 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n             TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n                 def.struct_variant().fields[0].ty(tcx, substs)\n@@ -990,7 +988,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn simd_size(&self, _cx: &TyCtxt) -> usize {\n+    pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n             TyStruct(def, _) => def.struct_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")"}, {"sha": "bb6d06d49e4b452de817483cb205b3e27f592827", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ pub struct Substs<'tcx> {\n     pub regions: VecPerParamSpace<ty::Region>,\n }\n \n-impl<'tcx> Substs<'tcx> {\n+impl<'a, 'tcx> Substs<'tcx> {\n     pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n                -> Substs<'tcx>\n@@ -122,7 +122,7 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: &TyCtxt<'tcx>, trait_id: DefId)\n+    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {\n         let Substs { mut types, mut regions } = self.clone();\n         types.truncate(FnSpace, 0);\n@@ -532,22 +532,21 @@ impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx> : Sized {\n-    fn subst(&self, tcx: &TyCtxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n+    fn subst<'a>(&self, tcx: TyCtxt<'a, 'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(&self, tcx: &TyCtxt<'tcx>,\n-                     substs: &Substs<'tcx>,\n-                     span: Option<Span>)\n-                     -> Self;\n+    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+                         substs: &Substs<'tcx>,\n+                         span: Option<Span>)\n+                         -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned(&self,\n-                     tcx: &TyCtxt<'tcx>,\n-                     substs: &Substs<'tcx>,\n-                     span: Option<Span>)\n-                     -> T\n+    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+                         substs: &Substs<'tcx>,\n+                         span: Option<Span>)\n+                         -> T\n     {\n         let mut folder = SubstFolder { tcx: tcx,\n                                        substs: substs,\n@@ -563,7 +562,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n // The actual substitution engine itself is a type folder.\n \n struct SubstFolder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n@@ -580,7 +579,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.region_binders_passed += 1;"}, {"sha": "1b9f4909e2bf2cc72180d1d12b4a76da65721e73", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -73,7 +73,7 @@ pub struct TraitDef<'tcx> {\n     pub flags: Cell<TraitFlags>\n }\n \n-impl<'tcx> TraitDef<'tcx> {\n+impl<'a, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                generics: ty::Generics<'tcx>,\n@@ -117,19 +117,18 @@ impl<'tcx> TraitDef<'tcx> {\n         );\n     }\n \n-    fn write_trait_impls(&self, tcx: &TyCtxt<'tcx>) {\n+    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'tcx>) {\n         tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    fn read_trait_impls(&self, tcx: &TyCtxt<'tcx>) {\n+    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'tcx>) {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n     ///\n     /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self,\n-                   tcx: &TyCtxt<'tcx>,\n+    fn record_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n                    impl_def_id: DefId,\n                    impl_trait_ref: TraitRef<'tcx>)\n                    -> bool {\n@@ -164,8 +163,7 @@ impl<'tcx> TraitDef<'tcx> {\n     }\n \n     /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self,\n-                             tcx: &TyCtxt<'tcx>,\n+    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n                              impl_def_id: DefId,\n                              impl_trait_ref: TraitRef<'tcx>) {\n         assert!(impl_def_id.is_local());\n@@ -178,8 +176,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n     /// trait's def ID if the impl is not a specialization -- information that\n     /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self,\n-                              tcx: &TyCtxt<'tcx>,\n+    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n                               impl_def_id: DefId,\n                               impl_trait_ref: TraitRef<'tcx>,\n                               parent_impl: DefId) {\n@@ -197,22 +194,21 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Adds a local impl into the specialization graph, returning an error with\n     /// overlap information if the impl overlaps but does not specialize an\n     /// existing impl.\n-    pub fn add_impl_for_specialization<'a>(&self,\n-                                           tcx: &'a TyCtxt<'tcx>,\n-                                           impl_def_id: DefId)\n-                                           -> Result<(), traits::Overlap<'a, 'tcx>> {\n+    pub fn add_impl_for_specialization(&self, tcx: TyCtxt<'a, 'tcx>,\n+                                       impl_def_id: DefId)\n+                                       -> Result<(), traits::Overlap<'a, 'tcx>> {\n         assert!(impl_def_id.is_local());\n \n         self.specialization_graph.borrow_mut()\n             .insert(tcx, impl_def_id)\n     }\n \n-    pub fn ancestors<'a>(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n-        pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n-            self.read_trait_impls(tcx);\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'tcx>, mut f: F) {\n+        self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n@@ -229,7 +225,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: &TyCtxt<'tcx>,\n+                                                   tcx: TyCtxt<'a, 'tcx>,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {"}, {"sha": "70f03d3c8e82aafca75effc130f2bd6ee4cd578a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -32,14 +32,14 @@ use syntax::codemap::Span;\n use hir;\n \n pub trait IntTypeExt {\n-    fn to_ty<'tcx>(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn disr_incr(&self, tcx: &TyCtxt, val: Option<Disr>) -> Option<Disr>;\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr(&self, tcx: TyCtxt, val: Option<Disr>) -> Option<Disr>;\n     fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n+    fn initial_discriminant(&self, tcx: TyCtxt) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'tcx>(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n             SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n@@ -54,7 +54,7 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr {\n+    fn initial_discriminant(&self, tcx: TyCtxt) -> Disr {\n         match *self {\n             SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n@@ -93,7 +93,7 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn disr_incr(&self, tcx: &TyCtxt, val: Option<Disr>) -> Option<Disr> {\n+    fn disr_incr(&self, tcx: TyCtxt, val: Option<Disr>) -> Option<Disr> {\n         if let Some(val) = val {\n             self.assert_ty_matches(val);\n             (val + ConstInt::Infer(1)).ok()\n@@ -170,18 +170,18 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+    pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n \n-    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n+    pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n         pat_util::arm_contains_ref_binding(&self.def_map, arm)\n     }\n \n     /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n     /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n-    pub fn positional_element_ty(&self,\n+    pub fn positional_element_ty(self,\n                                  ty: Ty<'tcx>,\n                                  i: usize,\n                                  variant: Option<DefId>) -> Option<Ty<'tcx>> {\n@@ -203,7 +203,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns the type of element at field `n` in struct or struct-like type `t`.\n     /// For an enum `t`, `variant` must be some def id.\n-    pub fn named_element_ty(&self,\n+    pub fn named_element_ty(self,\n                             ty: Ty<'tcx>,\n                             n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n@@ -221,7 +221,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the IntType representation.\n     /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n     /// by converting them to their actual types. That doesn't happen anymore.\n-    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n+    pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n         match opt_hint {\n             // Feed in the given type\n             Some(&attr::ReprInt(_, int_t)) => int_t,\n@@ -236,7 +236,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         while let TyStruct(def, substs) = ty.sty {\n             match def.struct_variant().fields.last() {\n                 Some(f) => ty = f.ty(self, substs),\n@@ -251,7 +251,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(&self,\n+    pub fn struct_lockstep_tails(self,\n                                  source: Ty<'tcx>,\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n@@ -286,7 +286,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// Requires that trait definitions have been processed so that we can\n     /// elaborate predicates and walk supertraits.\n-    pub fn required_region_bounds(&self,\n+    pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n                                   -> Vec<ty::Region>    {\n@@ -332,12 +332,12 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n-    pub fn hash_crate_independent(&self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n+    pub fn hash_crate_independent(self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n         let mut state = SipHasher::new();\n         helper(self, ty, svh, &mut state);\n         return state.finish();\n \n-        fn helper<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+        fn helper<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, svh: &Svh,\n                         state: &mut SipHasher) {\n             macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n             macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n@@ -487,7 +487,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n+    pub fn is_adt_dtorck(self, adt: ty::AdtDef<'tcx>) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n@@ -506,11 +506,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                       bound: ty::BuiltinBound,\n-                       span: Span)\n-                       -> bool\n+impl<'a, 'tcx> ty::TyS<'tcx> {\n+    fn impls_bound(&'tcx self, param_env: &ParameterEnvironment<'a, 'tcx>,\n+                   bound: ty::BuiltinBound,\n+                   span: Span)\n+                   -> bool\n     {\n         let tcx = param_env.tcx;\n         let infcx = InferCtxt::new(tcx, &tcx.tables, Some(param_env.clone()),\n@@ -526,8 +526,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     // FIXME (@jroesch): I made this public to use it, not sure if should be private\n-    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                           span: Span) -> bool {\n+    pub fn moves_by_default(&'tcx self, param_env: &ParameterEnvironment<'a, 'tcx>,\n+                            span: Span) -> bool {\n         if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n             return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n         }\n@@ -562,8 +562,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_sized<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                        span: Span) -> bool\n+    pub fn is_sized(&'tcx self, param_env: &ParameterEnvironment<'a, 'tcx>,\n+                    span: Span) -> bool\n     {\n         if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n             return self.flags.get().intersects(TypeFlags::IS_SIZED);\n@@ -572,8 +572,8 @@ impl<'tcx> ty::TyS<'tcx> {\n         self.is_sized_uncached(param_env, span)\n     }\n \n-    fn is_sized_uncached<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                             span: Span) -> bool {\n+    fn is_sized_uncached(&'tcx self, param_env: &ParameterEnvironment<'a, 'tcx>,\n+                         span: Span) -> bool {\n         assert!(!self.needs_infer());\n \n         // Fast-path for primitive types\n@@ -600,8 +600,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn layout<'a>(&'tcx self, infcx: &InferCtxt<'a, 'tcx>)\n-                      -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    pub fn layout(&'tcx self, infcx: &InferCtxt<'a, 'tcx>)\n+                  -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let can_cache = !self.has_param_types() && !self.has_self_ty();\n         if can_cache {\n             if let Some(&cached) = infcx.tcx.layout_cache.borrow().get(&self) {\n@@ -620,21 +620,22 @@ impl<'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: &TyCtxt<'tcx>, sp: Span) -> Representability {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx>, sp: Span) -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(tcx: &TyCtxt<'tcx>,\n-                                                                    sp: Span,\n-                                                                    seen: &mut Vec<Ty<'tcx>>,\n-                                                                    iter: It)\n-                                                                    -> Representability {\n+        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx>,\n+                                               sp: Span,\n+                                               seen: &mut Vec<Ty<'tcx>>,\n+                                               iter: It)\n+                                               -> Representability\n+        where It: Iterator<Item=Ty<'tcx>> {\n             iter.fold(Representability::Representable,\n                       |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n         }\n \n-        fn are_inner_types_recursive<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span,\n-                                           seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n-                                           -> Representability {\n+        fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, sp: Span,\n+                                               seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n+                                               -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts) => {\n                     find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n@@ -691,10 +692,10 @@ impl<'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                                sp: Span,\n-                                                seen: &mut Vec<Ty<'tcx>>,\n-                                                ty: Ty<'tcx>) -> Representability {\n+        fn is_type_structurally_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                                    sp: Span,\n+                                                    seen: &mut Vec<Ty<'tcx>>,\n+                                                    ty: Ty<'tcx>) -> Representability {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {"}, {"sha": "7fc1f159288f8ed083fc279428edf4a5fc416111", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -525,8 +525,8 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn object_region_bounds<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx>,\n     principal: &ty::PolyTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>"}, {"sha": "56c0fc248af84cc02ded102f40fc4517a67640ee", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -68,12 +68,12 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'tcx, GG>(tcx: &ty::TyCtxt<'tcx>,\n-                                         substs: &subst::Substs,\n-                                         space: subst::ParamSpace,\n-                                         get_generics: GG)\n-                                         -> usize\n-    where GG: FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n+fn number_of_supplied_defaults<'a, 'tcx, GG>(tcx: TyCtxt<'a, 'tcx>,\n+                                             substs: &subst::Substs,\n+                                             space: subst::ParamSpace,\n+                                             get_generics: GG)\n+                                             -> usize\n+    where GG: FnOnce(TyCtxt<'a, 'tcx>) -> ty::Generics<'tcx>\n {\n     let generics = get_generics(tcx);\n \n@@ -114,7 +114,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n                          projections: &[ty::ProjectionPredicate],\n                          get_generics: GG)\n                          -> fmt::Result\n-    where GG: for<'tcx> FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n+    where GG: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx>) -> ty::Generics<'tcx>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n         write!(f, \"<{} as \", self_ty)?;\n@@ -230,10 +230,10 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n-                         tcx: &TyCtxt<'tcx>,\n-                         original: &ty::Binder<T>,\n-                         lifted: Option<ty::Binder<U>>) -> fmt::Result\n+fn in_binder<'a, 'tcx, T, U>(f: &mut fmt::Formatter,\n+                             tcx: TyCtxt<'a, 'tcx>,\n+                             original: &ty::Binder<T>,\n+                             lifted: Option<ty::Binder<U>>) -> fmt::Result\n     where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n {\n     // Replace any anonymous late-bound regions with named"}, {"sha": "bec645c6ae0350176fb0450767a3b07e07dafd98", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -233,7 +233,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "4a6bc411b9110bc96d0debb841fa13729362d50c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -199,10 +199,10 @@ impl FragmentSets {\n     }\n }\n \n-pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: &TyCtxt<'tcx>,\n-                                       sp: Span,\n-                                       id: ast::NodeId) {\n+pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                           tcx: TyCtxt<'a, 'tcx>,\n+                                           sp: Span,\n+                                           id: ast::NodeId) {\n     let span_err = tcx.map.attrs(id).iter()\n                           .any(|a| a.check_name(\"rustc_move_fragments\"));\n     let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n@@ -245,7 +245,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n ///\n /// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n /// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &TyCtxt<'tcx>) {\n+pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx>) {\n \n     let mut fragments = this.fragments.borrow_mut();\n \n@@ -346,11 +346,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &TyCtxt<'tcx>) {\n /// Adds all of the precisely-tracked siblings of `lp` as potential move paths of interest. For\n /// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n /// siblings of `s.x.j`.\n-fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n-                               tcx: &TyCtxt<'tcx>,\n-                               gathered_fragments: &mut Vec<Fragment>,\n-                               lp: Rc<LoanPath<'tcx>>,\n-                               origin_id: Option<ast::NodeId>) {\n+fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                   tcx: TyCtxt<'a, 'tcx>,\n+                                   gathered_fragments: &mut Vec<Fragment>,\n+                                   lp: Rc<LoanPath<'tcx>>,\n+                                   origin_id: Option<ast::NodeId>) {\n     match lp.kind {\n         LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n \n@@ -405,16 +405,16 @@ fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n \n /// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n /// Based on this, add move paths for all of the siblings of `origin_lp`.\n-fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n-                                             tcx: &TyCtxt<'tcx>,\n-                                             gathered_fragments: &mut Vec<Fragment>,\n-                                             parent_lp: &Rc<LoanPath<'tcx>>,\n-                                             mc: mc::MutabilityCategory,\n-                                             origin_field_name: &mc::FieldName,\n-                                             origin_lp: &Rc<LoanPath<'tcx>>,\n-                                             origin_id: Option<ast::NodeId>,\n-                                             enum_variant_info: Option<(DefId,\n-                                                                        Rc<LoanPath<'tcx>>)>) {\n+fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                                 tcx: TyCtxt<'a, 'tcx>,\n+                                                 gathered_fragments: &mut Vec<Fragment>,\n+                                                 parent_lp: &Rc<LoanPath<'tcx>>,\n+                                                 mc: mc::MutabilityCategory,\n+                                                 origin_field_name: &mc::FieldName,\n+                                                 origin_lp: &Rc<LoanPath<'tcx>>,\n+                                                 origin_id: Option<ast::NodeId>,\n+                                                 enum_variant_info: Option<(DefId,\n+                                                    Rc<LoanPath<'tcx>>)>) {\n     let parent_ty = parent_lp.to_type();\n \n     let mut add_fragment_sibling_local = |field_name, variant_did| {\n@@ -504,14 +504,15 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n \n /// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n /// loan-path).\n-fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   gathered_fragments: &mut Vec<Fragment>,\n-                                   parent: Rc<LoanPath<'tcx>>,\n-                                   mc: mc::MutabilityCategory,\n-                                   new_field_name: mc::FieldName,\n-                                   origin_lp: &Rc<LoanPath<'tcx>>,\n-                                   enum_variant_did: Option<DefId>) -> MovePathIndex {\n+fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                       tcx: TyCtxt<'a, 'tcx>,\n+                                       gathered_fragments: &mut Vec<Fragment>,\n+                                       parent: Rc<LoanPath<'tcx>>,\n+                                       mc: mc::MutabilityCategory,\n+                                       new_field_name: mc::FieldName,\n+                                       origin_lp: &Rc<LoanPath<'tcx>>,\n+                                       enum_variant_did: Option<DefId>)\n+                                       -> MovePathIndex {\n     let opt_variant_did = match parent.kind {\n         LpDowncast(_, variant_did) => Some(variant_did),\n         LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,"}, {"sha": "ef2fb9e4fc0f265cf6bfa71080d57fba4ce02d78", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -255,7 +255,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,"}, {"sha": "de47fe86ed24b9d66798ccb889ae8cb01935c23e", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -458,8 +458,8 @@ impl<D: BitDenotation> DataflowState<D> {\n }\n \n \n-impl<'tcx> DataflowState<MoveData<'tcx>> {\n-    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> Self {\n+impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n+    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> Self {\n         let move_data = MoveData::gather_moves(mir, tcx);\n         DataflowState::new(mir, move_data)\n     }"}, {"sha": "2b835124fa1aa75d3f5359501b02a6cb898c5e9b", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -482,8 +482,8 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> Self {\n+impl<'a, 'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> Self {\n         gather_moves(mir, tcx)\n     }\n }\n@@ -494,7 +494,7 @@ enum StmtKind {\n     Aggregate, Drop, CallFn, CallArg, Return,\n }\n \n-fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n+fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n     let bbs = mir.all_basic_blocks();\n@@ -667,7 +667,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: &'b TyCtxt<'tcx>,\n+    tcx: TyCtxt<'b, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,"}, {"sha": "bec5ae03d3d4de8ee80cb9835244f0c8f0273cdb", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -46,11 +46,11 @@ pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n     }\n \n     let mut mbcx = MirBorrowckCtxt {\n+        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n         bcx: bcx,\n         mir: mir,\n         node_id: id,\n         attributes: attributes,\n-        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n     };\n \n     for bb in mir.all_basic_blocks() {"}, {"sha": "c9046374464a09a5ef37f51d5d3650081c3abef8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, mir_map: &MirMap<'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         mir_map: Some(mir_map),\n@@ -244,7 +244,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n@@ -278,7 +278,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // Type definitions\n \n pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n \n     // Hacky. As we visit various fns, we have to load up the\n     // free-region map for each one. This map is computed by during\n@@ -412,7 +412,7 @@ pub enum LoanPathElem {\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n-                        tcx: &TyCtxt) -> ast::NodeId {\n+                        tcx: TyCtxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(_, _, ref block, _) => {\n@@ -426,8 +426,8 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     }\n }\n \n-impl<'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: &TyCtxt<'tcx>) -> region::CodeExtent {\n+impl<'a, 'tcx> LoanPath<'tcx> {\n+    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n@@ -1109,7 +1109,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: &TyCtxt, region: ty::Region) -> Option<Span> {\n+fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n     match region {\n         ty::ReScope(scope) => {\n             match tcx.map.find(scope.node_id(&tcx.region_maps)) {"}, {"sha": "0f9e490322a6bfa91d96a404f9dab2c7799ec0a4", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -212,7 +212,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     }\n }\n \n-impl<'tcx> MoveData<'tcx> {\n+impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n@@ -272,8 +272,7 @@ impl<'tcx> MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx>,\n                      lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         match self.path_map.borrow().get(&lp) {\n             Some(&index) => {\n@@ -364,8 +363,7 @@ impl<'tcx> MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self,\n-                    tcx: &TyCtxt<'tcx>,\n+    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx>,\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n@@ -392,8 +390,7 @@ impl<'tcx> MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self,\n-                          tcx: &TyCtxt<'tcx>,\n+    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n@@ -437,8 +434,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// variant `lp`, that occurs at location `pattern_id`.  (One\n     /// should be able to recover the span info from the\n     /// `pattern_id` and the ast_map, I think.)\n-    pub fn add_variant_match(&self,\n-                             tcx: &TyCtxt<'tcx>,\n+    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n                              pattern_id: ast::NodeId,\n                              base_lp: Rc<LoanPath<'tcx>>,\n@@ -461,7 +457,7 @@ impl<'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: &TyCtxt<'tcx>) {\n+    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx>) {\n         fragments::fixup_fragment_sets(self, tcx)\n     }\n \n@@ -470,8 +466,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n@@ -600,7 +595,7 @@ impl<'tcx> MoveData<'tcx> {\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               tcx: &'a TyCtxt<'tcx>,\n+               tcx: TyCtxt<'a, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,"}, {"sha": "4a88b8c7d91ae4062179c74b9829a40422c9ba83", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -106,7 +106,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n \n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub param_env: ParameterEnvironment<'a, 'tcx>,\n }\n \n@@ -153,7 +153,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n         tcx: tcx,\n         param_env: tcx.empty_parameter_environment(),\n@@ -455,13 +455,13 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n }\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub failed: bool,\n     pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: &'b TyCtxt<'tcx>,\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx>,\n                    renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n                    -> StaticInliner<'b, 'tcx> {\n         StaticInliner {"}, {"sha": "445cb229bdbf2f1d9deae97b1ea4097ae2228adf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -54,10 +54,10 @@ macro_rules! math {\n     }\n }\n \n-fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n-                            enum_def: DefId,\n-                            variant_def: DefId)\n-                            -> Option<&'a Expr> {\n+fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                  enum_def: DefId,\n+                                  variant_def: DefId)\n+                                  -> Option<&'tcx Expr> {\n     fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n         for variant in variants {\n@@ -90,7 +90,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n                                         def_id: DefId,\n                                         substs: Option<subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n@@ -182,7 +182,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n     }\n }\n \n-fn inline_const_fn_from_external_crate(tcx: &TyCtxt, def_id: DefId)\n+fn inline_const_fn_from_external_crate(tcx: TyCtxt, def_id: DefId)\n                                        -> Option<ast::NodeId> {\n     match tcx.extern_const_fns.borrow().get(&def_id) {\n         Some(&ast::DUMMY_NODE_ID) => return None,\n@@ -205,8 +205,8 @@ fn inline_const_fn_from_external_crate(tcx: &TyCtxt, def_id: DefId)\n     fn_id\n }\n \n-pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                                   -> Option<FnLikeNode<'tcx>>\n+pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+                                       -> Option<FnLikeNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         node_id\n@@ -238,7 +238,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n+pub fn const_expr_to_pat(tcx: TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n                          -> Result<P<hir::Pat>, DefId> {\n     let pat_ty = tcx.expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n@@ -339,7 +339,7 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n-pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {\n+pub fn eval_const_expr(tcx: TyCtxt, e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n@@ -526,10 +526,10 @@ macro_rules! signal {\n /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n /// but a few places need to evaluate constants during type-checking, like\n /// computing the length of an array. (See also the FIXME above EvalHint.)\n-pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                     e: &Expr,\n-                                     ty_hint: EvalHint<'tcx>,\n-                                     fn_args: FnArgMap) -> EvalResult {\n+pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                         e: &Expr,\n+                                         ty_hint: EvalHint<'tcx>,\n+                                         fn_args: FnArgMap) -> EvalResult {\n     // Try to compute the type of the expression based on the EvalHint.\n     // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n     let ety = match ty_hint {\n@@ -931,11 +931,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn infer<'tcx>(\n-    i: ConstInt,\n-    tcx: &TyCtxt<'tcx>,\n-    ty_hint: &ty::TypeVariants<'tcx>,\n-) -> Result<ConstInt, ErrKind> {\n+fn infer<'a, 'tcx>(i: ConstInt,\n+                   tcx: TyCtxt<'a, 'tcx>,\n+                   ty_hint: &ty::TypeVariants<'tcx>)\n+                   -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n \n     match (ty_hint, i) {\n@@ -997,7 +996,7 @@ fn infer<'tcx>(\n     }\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n@@ -1054,7 +1053,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n     }\n }\n \n-fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n     let v = val.to_u64_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n@@ -1099,7 +1098,7 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n     }\n }\n \n-fn cast_const_float<'tcx>(tcx: &TyCtxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n     match ty.sty {\n         ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n         ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n@@ -1110,7 +1109,7 @@ fn cast_const_float<'tcx>(tcx: &TyCtxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult\n     }\n }\n \n-fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n         Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n@@ -1127,11 +1126,11 @@ fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult\n     }\n }\n \n-fn lit_to_const<'tcx>(lit: &ast::LitKind,\n-                      tcx: &TyCtxt<'tcx>,\n-                      ty_hint: Option<Ty<'tcx>>,\n-                      span: Span,\n-                      ) -> Result<ConstVal, ErrKind> {\n+fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n+                          tcx: TyCtxt<'a, 'tcx>,\n+                          ty_hint: Option<Ty<'tcx>>,\n+                          span: Span)\n+                          -> Result<ConstVal, ErrKind> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n@@ -1198,9 +1197,9 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     }\n }\n \n-pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,\n-                               a: &Expr,\n-                               b: &Expr) -> Option<Ordering> {\n+pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                   a: &Expr,\n+                                   b: &Expr) -> Option<Ordering> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n@@ -1220,7 +1219,7 @@ pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,\n \n \n /// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: &TyCtxt, count_expr: &hir::Expr) -> usize {\n+pub fn eval_repeat_count(tcx: TyCtxt, count_expr: &hir::Expr) -> usize {\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {"}, {"sha": "7707376f0a01abbf874228fa3de9514e44c2ed6b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -367,7 +367,7 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub resolutions: Option<&'a Resolutions>,\n     pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<&'b TyCtxt<'tcx>>,\n+    pub tcx: Option<TyCtxt<'b, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -464,7 +464,7 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis<'a>,\n                             mir_map: Option<&'b MirMap<'tcx>>,\n-                            tcx: &'b TyCtxt<'tcx>,\n+                            tcx: TyCtxt<'b, 'tcx>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n@@ -817,7 +817,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n-    where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n+    where F: for<'a> FnOnce(TyCtxt<'a, 'tcx>,\n+                            Option<MirMap<'tcx>>,\n+                            ty::CrateAnalysis,\n+                            CompileResult) -> R\n {\n     macro_rules! try_with_f {\n         ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n@@ -989,9 +992,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n-pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                       mut mir_map: MirMap<'tcx>,\n-                                       analysis: ty::CrateAnalysis) -> trans::CrateTranslation {\n+pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                           mut mir_map: MirMap<'tcx>,\n+                                           analysis: ty::CrateAnalysis)\n+                                           -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,"}, {"sha": "bb90789c14ab4b5f3d02ad2d222fa289b68f1bbf", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -469,7 +469,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n@@ -689,13 +689,13 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     }\n }\n \n-fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   code: blocks::Code,\n-                                   mode: PpFlowGraphMode,\n-                                   mut out: W)\n-                                   -> io::Result<()> {\n+fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                       tcx: TyCtxt<'a, 'tcx>,\n+                                       mir_map: Option<&MirMap<'tcx>>,\n+                                       code: blocks::Code,\n+                                       mode: PpFlowGraphMode,\n+                                       mut out: W)\n+                                       -> io::Result<()> {\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),"}, {"sha": "c92ede68b992086b9d97ccc600f664ad5fd7724e", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -160,7 +160,7 @@ fn test_env<F>(source_string: &str,\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n-    pub fn tcx(&self) -> &TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "3a41a377d20d3b4efe4717ccc9cc66bee6e8192e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -63,7 +63,7 @@ const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n const ID: &'static str = \"id\";\n \n-pub fn assert_dep_graph(tcx: &TyCtxt) {\n+pub fn assert_dep_graph(tcx: TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.debugging_opts.dump_dep_graph {\n@@ -98,7 +98,7 @@ type TargetHashMap =\n                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     if_this_changed: SourceHashMap,\n     then_this_would_need: TargetHashMap,\n }\n@@ -172,7 +172,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-fn check_paths(tcx: &TyCtxt,\n+fn check_paths(tcx: TyCtxt,\n                if_this_changed: &SourceHashMap,\n                then_this_would_need: &TargetHashMap)\n {\n@@ -213,7 +213,7 @@ fn check_paths(tcx: &TyCtxt,\n     }\n }\n \n-fn dump_graph(tcx: &TyCtxt) {\n+fn dump_graph(tcx: TyCtxt) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| format!(\"dep_graph\"));\n     let query = tcx.dep_graph.query();\n "}, {"sha": "73af4acfe49ad26f958287faba1e01bdd82c4335", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -14,21 +14,21 @@\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::svh::Svh;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc::hir::intravisit::{self, Visitor};\n \n use self::svh_visitor::StrictVersionHashVisitor;\n \n pub trait SvhCalculate {\n     /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(&self) -> Svh;\n+    fn calculate_krate_hash(self) -> Svh;\n \n     /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(&self, def_id: DefId) -> u64;\n+    fn calculate_item_hash(self, def_id: DefId) -> u64;\n }\n \n-impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n-    fn calculate_krate_hash(&self) -> Svh {\n+impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx> {\n+    fn calculate_krate_hash(self) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -75,7 +75,7 @@ impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n         Svh::from_hash(state.finish())\n     }\n \n-    fn calculate_item_hash(&self, def_id: DefId) -> u64 {\n+    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n         assert!(def_id.is_local());\n \n         let mut state = SipHasher::new();\n@@ -109,7 +109,7 @@ mod svh_visitor {\n     use syntax::ast::{self, Name, NodeId};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n-    use rustc::ty;\n+    use rustc::ty::TyCtxt;\n     use rustc::hir;\n     use rustc::hir::*;\n     use rustc::hir::intravisit as visit;\n@@ -118,13 +118,13 @@ mod svh_visitor {\n     use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-        pub tcx: &'a ty::TyCtxt<'tcx>,\n+        pub tcx: TyCtxt<'a, 'tcx>,\n         pub st: &'a mut SipHasher,\n     }\n \n     impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n         pub fn new(st: &'a mut SipHasher,\n-                   tcx: &'a ty::TyCtxt<'tcx>)\n+                   tcx: TyCtxt<'a, 'tcx>)\n                    -> Self {\n             StrictVersionHashVisitor { st: st, tcx: tcx }\n         }"}, {"sha": "299254959c7626ea631abbc6ff0859831163a448", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -16,7 +16,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::DefPath;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n \n@@ -39,7 +39,7 @@ impl DefIdDirectory {\n         DefIdDirectory { paths: vec![] }\n     }\n \n-    pub fn retrace(&self, tcx: &ty::TyCtxt) -> RetracedDefIdDirectory {\n+    pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n         let ids = self.paths.iter()\n                             .map(|path| tcx.map.retrace_path(path))\n                             .collect();\n@@ -63,13 +63,13 @@ impl RetracedDefIdDirectory {\n }\n \n pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n-    tcx: &'a ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     hash: DefIdMap<Option<DefPathIndex>>,\n     directory: DefIdDirectory,\n }\n \n impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::TyCtxt<'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n         DefIdDirectoryBuilder {\n             tcx: tcx,\n             hash: DefIdMap(),"}, {"sha": "9c1452acb84819bcafac3d3c6af2a66fbb8c9023", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -31,14 +31,14 @@ use rustc::hir::intravisit::Visitor;\n use syntax::ast::{self, Attribute, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n \n const DIRTY: &'static str = \"rustc_dirty\";\n const CLEAN: &'static str = \"rustc_clean\";\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n+pub fn check_dirty_clean_annotations(tcx: TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let query = tcx.dep_graph.query();\n     let krate = tcx.map.krate();\n@@ -49,7 +49,7 @@ pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n-    tcx: &'a ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n }\n "}, {"sha": "fbebb732e998201a3069c0a02915964fb641cb09", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -15,7 +15,7 @@ use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n use std::io::Read;\n@@ -37,7 +37,7 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+pub fn load_dep_graph(tcx: TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -47,7 +47,7 @@ pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n     }\n }\n \n-pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n+pub fn load_dep_graph_if_exists(tcx: TyCtxt, path: &Path) {\n     if !path.exists() {\n         return;\n     }\n@@ -74,8 +74,7 @@ pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n     }\n }\n \n-pub fn decode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>, data: &[u8])\n-                              -> Result<(), Error>\n+pub fn decode_dep_graph(tcx: TyCtxt, data: &[u8]) -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n     let mut decoder = Decoder::new(data, 0);\n@@ -129,10 +128,10 @@ pub fn decode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>, data: &[u8])\n     Ok(())\n }\n \n-fn initial_dirty_nodes<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n-                             hashed_items: &[SerializedHash],\n-                             retraced: &RetracedDefIdDirectory)\n-                             -> DirtyNodes {\n+fn initial_dirty_nodes(tcx: TyCtxt,\n+                       hashed_items: &[SerializedHash],\n+                       retraced: &RetracedDefIdDirectory)\n+                       -> DirtyNodes {\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n     for hashed_item in hashed_items {"}, {"sha": "2d40e78dee21a5612a4544d2f65b80b8da9173d9", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -11,7 +11,7 @@\n use calculate_svh::SvhCalculate;\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n@@ -20,7 +20,7 @@ use super::data::*;\n use super::directory::*;\n use super::util::*;\n \n-pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+pub fn save_dep_graph(tcx: TyCtxt) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -68,10 +68,7 @@ pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n     }\n }\n \n-pub fn encode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n-                              encoder: &mut Encoder)\n-                              -> io::Result<()>\n-{\n+pub fn encode_dep_graph(tcx: TyCtxt, encoder: &mut Encoder) -> io::Result<()> {\n     // Here we take advantage of how RBML allows us to skip around\n     // and encode the depgraph as a two-part structure:\n     //"}, {"sha": "8ebcbc0466f343238cb71edd05a141da0f991c19", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n \n use std::fs;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n+pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n     tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {"}, {"sha": "c73d0f368b76eaa340e3290b82340af53384d3ea", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -776,7 +776,7 @@ impl LateLintPass for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: &TyCtxt,\n+        fn expr_refers_to_this_fn(tcx: TyCtxt,\n                                   fn_id: ast::NodeId,\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n@@ -792,7 +792,7 @@ impl LateLintPass for UnconditionalRecursion {\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method(tcx: &TyCtxt,\n+        fn expr_refers_to_this_method(tcx: TyCtxt,\n                                       method: &ty::Method,\n                                       id: ast::NodeId) -> bool {\n             // Check for method calls and overloaded operators.\n@@ -840,11 +840,11 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n-        fn method_call_refers_to_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              method: &ty::Method,\n-                                              callee_id: DefId,\n-                                              callee_substs: &Substs<'tcx>,\n-                                              expr_id: ast::NodeId) -> bool {\n+        fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                                  method: &ty::Method,\n+                                                  callee_id: DefId,\n+                                                  callee_substs: &Substs<'tcx>,\n+                                                  expr_id: ast::NodeId) -> bool {\n             let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {"}, {"sha": "ebb348164e1ead44facfa7251fd07e218931af04", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -294,7 +294,7 @@ impl LateLintPass for TypeLimits {\n             }\n         }\n \n-        fn check_limits(tcx: &TyCtxt, binop: hir::BinOp,\n+        fn check_limits(tcx: TyCtxt, binop: hir::BinOp,\n                         l: &hir::Expr, r: &hir::Expr) -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n@@ -375,10 +375,10 @@ enum FfiResult {\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              def: ty::AdtDef<'tcx>,\n-                              substs: &Substs<'tcx>)\n-                              -> bool {\n+fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                  def: ty::AdtDef<'tcx>,\n+                                  substs: &Substs<'tcx>)\n+                                  -> bool {\n     if def.variants.len() == 2 {\n         let data_idx;\n \n@@ -409,7 +409,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                           ty: Ty<'tcx>)\n                           -> FfiResult {\n         use self::FfiResult::*;\n-        let cx = &self.cx.tcx;\n+        let cx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n         // `struct S(*mut S);`."}, {"sha": "377b93c28b5697451a1896444f5bc1362614a806", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -60,7 +60,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n #[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext, DummyResolver};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     cdata: &'b cstore::crate_metadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n@@ -122,13 +122,13 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n-                                 tcx: &TyCtxt<'tcx>,\n-                                 parent_def_path: ast_map::DefPath,\n-                                 parent_did: DefId,\n-                                 ast_doc: rbml::Doc,\n-                                 orig_did: DefId)\n-                                 -> &'tcx InlinedItem {\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n+                                     tcx: TyCtxt<'a, 'tcx>,\n+                                     parent_def_path: ast_map::DefPath,\n+                                     parent_did: DefId,\n+                                     ast_doc: rbml::Doc,\n+                                     orig_did: DefId)\n+                                     -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n     let mut ast_dsr = reader::Decoder::new(ast_doc);\n     let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -861,21 +861,19 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n \n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n-    fn read_ty_nodcx(&mut self,\n-                     tcx: &TyCtxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n-    fn read_tys_nodcx(&mut self,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n-    fn read_substs_nodcx(&mut self, tcx: &TyCtxt<'tcx>,\n-                         cdata: &cstore::crate_metadata)\n-                         -> subst::Substs<'tcx>;\n+    fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+                         cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n+    fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+    fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+                             cdata: &cstore::crate_metadata)\n+                             -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_ty_nodcx(&mut self,\n-                     tcx: &TyCtxt<'tcx>,\n-                     cdata: &cstore::crate_metadata)\n-                     -> Ty<'tcx> {\n+    fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+                         cdata: &cstore::crate_metadata)\n+                         -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n@@ -884,19 +882,17 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_tys_nodcx(&mut self,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n+    fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n-    fn read_substs_nodcx(&mut self,\n-                         tcx: &TyCtxt<'tcx>,\n-                         cdata: &cstore::crate_metadata)\n-                         -> subst::Substs<'tcx>\n+    fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+                             cdata: &cstore::crate_metadata)\n+                             -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok("}, {"sha": "70d4078a106147008cdc81a8bd72fd3a0e8e8788", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -54,14 +54,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_visibility(&cdata, def.index)\n     }\n \n-    fn closure_kind(&self, _tcx: &TyCtxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::closure_kind(&cdata, def_id.index)\n     }\n \n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n@@ -78,22 +78,22 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_repr_attrs(&cdata, def.index)\n     }\n \n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx>\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_type(&cdata, def.index, tcx)\n     }\n \n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx>\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_predicates(&cdata, def.index, tcx)\n     }\n \n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx>\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_super_predicates(&cdata, def.index, tcx)\n@@ -111,13 +111,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_symbol(&cdata, def.index)\n     }\n \n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_trait_def(&cdata, def.index, tcx)\n     }\n \n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n@@ -155,8 +155,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>>\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n@@ -181,8 +181,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_impl_polarity(&cdata, def.index)\n     }\n \n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_trait(&cdata, def.index, tcx)\n@@ -196,8 +196,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     // FIXME: killme\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n@@ -207,14 +207,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> Option<DefId>\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n     }\n \n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>>\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item(\n@@ -247,7 +247,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_default_impl(&cdata, impl_did.index)\n     }\n \n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool {\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool {\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n@@ -442,15 +442,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx>\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>> {\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n     }\n@@ -486,11 +486,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         loader::meta_section_name(target)\n     }\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8>\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       -> Vec<u8>\n     {\n         encoder::encoded_ty(tcx, ty, def_id_to_string)\n     }\n@@ -510,14 +510,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8>\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8>\n     {\n         let ecx = encoder::EncodeContext {\n             diag: tcx.sess.diagnostic(),"}, {"sha": "ce0856ce5af186350c0c9a8f1327d0b5a3b85b84", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 69, "deletions": 68, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -223,35 +223,35 @@ fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n     })\n }\n \n-fn doc_type<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_ty()\n }\n \n-fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n+fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n         TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                             &mut |did| translate_def_id(cdata, did))\n             .parse_ty()\n     })\n }\n \n-pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n-                       tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+pub fn item_type<'a, 'tcx>(_item_id: DefId, item: rbml::Doc,\n+                           tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd)\n-                       -> ty::TraitRef<'tcx> {\n+fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd)\n+                           -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_trait_ref()\n }\n \n-fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd)\n-                        -> ty::TraitRef<'tcx> {\n+fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd)\n+                            -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n@@ -350,9 +350,9 @@ fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n         .collect()\n }\n \n-pub fn get_trait_def<'tcx>(cdata: Cmd,\n-                           item_id: DefIndex,\n-                           tcx: &TyCtxt<'tcx>) -> ty::TraitDef<'tcx>\n+pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n+                               item_id: DefIndex,\n+                               tcx: TyCtxt<'a, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -367,10 +367,11 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n                       associated_type_names)\n }\n \n-pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n-                         cdata: Cmd,\n-                         item_id: DefIndex,\n-                         tcx: &TyCtxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n+pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n+                             cdata: Cmd,\n+                             item_id: DefIndex,\n+                             tcx: TyCtxt<'a, 'tcx>)\n+                             -> ty::AdtDefMaster<'tcx>\n {\n     fn expect_variant_kind(family: Family) -> ty::VariantKind {\n         match family_to_variant_kind(family) {\n@@ -495,26 +496,26 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     adt\n }\n \n-pub fn get_predicates<'tcx>(cdata: Cmd,\n-                            item_id: DefIndex,\n-                            tcx: &TyCtxt<'tcx>)\n-                            -> ty::GenericPredicates<'tcx>\n+pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n+                                item_id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx>)\n+                                -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n }\n \n-pub fn get_super_predicates<'tcx>(cdata: Cmd,\n-                                  item_id: DefIndex,\n-                                  tcx: &TyCtxt<'tcx>)\n-                                  -> ty::GenericPredicates<'tcx>\n+pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n+                                      item_id: DefIndex,\n+                                      tcx: TyCtxt<'a, 'tcx>)\n+                                      -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n-pub fn get_type<'tcx>(cdata: Cmd, id: DefIndex, tcx: &TyCtxt<'tcx>)\n-                      -> ty::TypeScheme<'tcx>\n+pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx>)\n+                          -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n     let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n@@ -590,10 +591,10 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n     })\n }\n \n-pub fn get_impl_trait<'tcx>(cdata: Cmd,\n-                            id: DefIndex,\n-                            tcx: &TyCtxt<'tcx>)\n-                            -> Option<ty::TraitRef<'tcx>>\n+pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n+                                id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx>)\n+                                -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = cdata.lookup_item(id);\n     let fam = item_family(item_doc);\n@@ -775,8 +776,8 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n-                                -> FoundAst<'tcx> {\n+pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx>, id: DefIndex)\n+                                    -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n@@ -827,10 +828,10 @@ pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n     false\n }\n \n-pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n-                                tcx: &TyCtxt<'tcx>,\n-                                id: DefIndex)\n-                                -> Option<mir::repr::Mir<'tcx>> {\n+pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n+                                    tcx: TyCtxt<'a, 'tcx>,\n+                                    id: DefIndex)\n+                                    -> Option<mir::repr::Mir<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n@@ -943,11 +944,11 @@ pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n-                                    cdata: Cmd,\n-                                    id: DefIndex,\n-                                    tcx: &TyCtxt<'tcx>)\n-                                    -> Option<ty::ImplOrTraitItem<'tcx>> {\n+pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                        cdata: Cmd,\n+                                        id: DefIndex,\n+                                        tcx: TyCtxt<'a, 'tcx>)\n+                                        -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n@@ -1038,11 +1039,11 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n-                                        cdata: Cmd,\n-                                        id: DefIndex,\n-                                        tcx: &TyCtxt<'tcx>)\n-                                        -> Vec<Rc<ty::Method<'tcx>>> {\n+pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                            cdata: Cmd,\n+                                            id: DefIndex,\n+                                            tcx: TyCtxt<'a, 'tcx>)\n+                                            -> Vec<Rc<ty::Method<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n@@ -1065,11 +1066,11 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n-                                   cdata: Cmd,\n-                                   id: DefIndex,\n-                                   tcx: &TyCtxt<'tcx>)\n-                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                       cdata: Cmd,\n+                                       id: DefIndex,\n+                                       tcx: TyCtxt<'a, 'tcx>)\n+                                       -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n@@ -1442,7 +1443,7 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: &TyCtxt)\n+pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: TyCtxt)\n                          -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n@@ -1577,7 +1578,7 @@ pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn is_extern_item(cdata: Cmd, id: DefIndex, tcx: &TyCtxt) -> bool {\n+pub fn is_extern_item(cdata: Cmd, id: DefIndex, tcx: TyCtxt) -> bool {\n     let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n@@ -1612,11 +1613,11 @@ pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-fn doc_generics<'tcx>(base_doc: rbml::Doc,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: Cmd,\n-                      tag: usize)\n-                      -> ty::Generics<'tcx>\n+fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n+                          tcx: TyCtxt<'a, 'tcx>,\n+                          cdata: Cmd,\n+                          tag: usize)\n+                          -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n@@ -1660,10 +1661,10 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     ty::Generics { types: types, regions: regions }\n }\n \n-fn doc_predicate<'tcx>(cdata: Cmd,\n-                       doc: rbml::Doc,\n-                       tcx: &TyCtxt<'tcx>)\n-                       -> ty::Predicate<'tcx>\n+fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n+                           doc: rbml::Doc,\n+                           tcx: TyCtxt<'a, 'tcx>)\n+                           -> ty::Predicate<'tcx>\n {\n     let predicate_pos = cdata.xref_index.lookup(\n         cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n@@ -1673,11 +1674,11 @@ fn doc_predicate<'tcx>(cdata: Cmd,\n     ).parse_predicate()\n }\n \n-fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n-                        tcx: &TyCtxt<'tcx>,\n-                        cdata: Cmd,\n-                        tag: usize)\n-                        -> ty::GenericPredicates<'tcx>\n+fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n+                            tcx: TyCtxt<'a, 'tcx>,\n+                            cdata: Cmd,\n+                            tag: usize)\n+                            -> ty::GenericPredicates<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n@@ -1729,8 +1730,8 @@ pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n     ty::ClosureKind::decode(&mut decoder).unwrap()\n }\n \n-pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &TyCtxt<'tcx>)\n-                        -> ty::ClosureTy<'tcx> {\n+pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx>)\n+                            -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n     let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n     TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))"}, {"sha": "7b39ec72ed23e7c5f25f29f198b78575c9fb120d", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -56,7 +56,7 @@ use rustc::hir::map::DefKey;\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n@@ -139,7 +139,7 @@ pub fn def_to_u64(did: DefId) -> u64 {\n     (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n }\n \n-pub fn def_to_string(_tcx: &TyCtxt, did: DefId) -> String {\n+pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n@@ -252,7 +252,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n     let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n-    let mut disr_val = repr_type.initial_discriminant(&ecx.tcx);\n+    let mut disr_val = repr_type.initial_discriminant(ecx.tcx);\n     let def = ecx.tcx.lookup_adt_def(did);\n     for variant in &def.variants {\n         let vid = variant.did;\n@@ -1697,7 +1697,7 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n \n \n struct ImplVisitor<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     impls: FnvHashMap<DefId, Vec<DefId>>\n }\n \n@@ -2016,10 +2016,10 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                        t: Ty<'tcx>,\n-                        def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                        -> Vec<u8> {\n+pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                            t: Ty<'tcx>,\n+                            def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                            -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "e1354307f7a4e4d78e1c8445bb22f3c188d2e7e6", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -25,8 +25,8 @@ use tyencode;\n \n impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> &'s TyCtxt<'tcx> {\n-        &self.tcx\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx> {\n+        self.tcx\n     }\n \n     fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: ty::Ty<'tcx>) {\n@@ -40,13 +40,13 @@ impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tc\n \n pub struct DecodingContext<'a, 'tcx: 'a> {\n     pub crate_metadata: Cmd<'a>,\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> &'s TyCtxt<'tcx> {\n-        &self.tcx\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx> {\n+        self.tcx\n     }\n \n     fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx> {"}, {"sha": "7d2f86c8768c81b6b2fb36675d7c94a4682d3708", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -41,12 +41,12 @@ pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: usize,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     conv_def_id: DefIdConvert<'a>,\n }\n \n impl<'a,'tcx> TyDecoder<'a,'tcx> {\n-    pub fn with_doc(tcx: &'a TyCtxt<'tcx>,\n+    pub fn with_doc(tcx: TyCtxt<'a, 'tcx>,\n                     crate_num: ast::CrateNum,\n                     doc: rbml::Doc<'a>,\n                     conv: DefIdConvert<'a>)\n@@ -57,7 +57,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     pub fn new(data: &'a [u8],\n                crate_num: ast::CrateNum,\n                pos: usize,\n-               tcx: &'a TyCtxt<'tcx>,\n+               tcx: TyCtxt<'a, 'tcx>,\n                conv: DefIdConvert<'a>)\n                -> TyDecoder<'a, 'tcx> {\n         TyDecoder {"}, {"sha": "03f2e2cfd375f89a55f5c2390b66d3db314c9855", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -37,9 +37,9 @@ use encoder;\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     // Def -> str Callback:\n-    pub ds: fn(&TyCtxt<'tcx>, DefId) -> String,\n+    pub ds: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String,\n     // The type context.\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub abbrevs: &'a abbrev_map<'tcx>\n }\n "}, {"sha": "98c2ece6f3968cb55828216670e2fe927a7c16b0", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -662,12 +662,12 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n-                             cfg: &mut CFG<'tcx>,\n-                             unit_temp: &Lvalue<'tcx>,\n-                             scope: &mut Scope<'tcx>,\n-                             mut target: BasicBlock)\n-                             -> BasicBlock\n+fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                 cfg: &mut CFG<'tcx>,\n+                                 unit_temp: &Lvalue<'tcx>,\n+                                 scope: &mut Scope<'tcx>,\n+                                 mut target: BasicBlock)\n+                                 -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n@@ -721,11 +721,11 @@ fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n     target\n }\n \n-fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    unit_temp: &Lvalue<'tcx>,\n-                    data: &FreeData<'tcx>,\n-                    target: BasicBlock)\n-                    -> TerminatorKind<'tcx> {\n+fn build_free<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                        unit_temp: &Lvalue<'tcx>,\n+                        data: &FreeData<'tcx>,\n+                        target: BasicBlock)\n+                        -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n     let substs = tcx.mk_substs(Substs::new("}, {"sha": "bbd741c68803d727d211450ef486d55a91a43c69", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -10,13 +10,15 @@\n \n use dot;\n use rustc::mir::repr::*;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n+pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx>,\n+                                              iter: I, w: &mut W)\n+                                              -> io::Result<()>\n where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     for (&nodeid, mir) in iter {\n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n@@ -116,7 +118,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n+fn write_graph_label<W: Write>(tcx: TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n "}, {"sha": "eda0d4da4f44a3813d8061218fbb1b9e890a3221", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -30,7 +30,7 @@ use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n pub struct Cx<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     constness: hir::Constness\n }\n@@ -144,7 +144,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "0114ee3c029d2e3a7be1371d03e3b5be398b9db2", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -34,7 +34,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n+pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>) -> MirMap<'tcx> {\n     let mut map = MirMap {\n         map: NodeMap(),\n     };\n@@ -52,7 +52,7 @@ pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     map: &'a mut MirMap<'tcx>,\n }\n \n@@ -180,7 +180,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n         };\n \n         let implicit_argument = if let FnKind::Closure(..) = fk {\n-            Some((closure_self_ty(&self.tcx, id, body.id), None))\n+            Some((closure_self_ty(self.tcx, id, body.id), None))\n         } else {\n             None\n         };\n@@ -202,10 +202,10 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     }\n }\n \n-fn closure_self_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                         closure_expr_id: ast::NodeId,\n-                         body_id: ast::NodeId)\n-                         -> Ty<'tcx> {\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                             closure_expr_id: ast::NodeId,\n+                             body_id: ast::NodeId)\n+                             -> Ty<'tcx> {\n     let closure_ty = tcx.node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be"}, {"sha": "8fb36c2e10c6cec3a237e351483f6279f596aa20", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -36,7 +36,7 @@ const INDENT: &'static str = \"    \";\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n                           src: MirSource,\n@@ -73,10 +73,10 @@ pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n-                                     iter: I,\n-                                     w: &mut Write)\n-                                     -> io::Result<()>\n+pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx>,\n+                                         iter: I,\n+                                         w: &mut Write)\n+                                         -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n     for (&id, mir) in iter {\n@@ -95,12 +95,12 @@ enum Annotation {\n     ExitScope(ScopeId),\n }\n \n-pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          src: MirSource,\n-                          mir: &Mir<'tcx>,\n-                          w: &mut Write,\n-                          auxiliary: Option<&ScopeAuxiliaryVec>)\n-                          -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                              src: MirSource,\n+                              mir: &Mir<'tcx>,\n+                              w: &mut Write,\n+                              auxiliary: Option<&ScopeAuxiliaryVec>)\n+                              -> io::Result<()> {\n     // compute scope/entry exit annotations\n     let mut annotations = FnvHashMap();\n     if let Some(auxiliary) = auxiliary {\n@@ -138,7 +138,7 @@ pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block(tcx: &TyCtxt,\n+fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write,\n@@ -182,14 +182,11 @@ fn write_basic_block(tcx: &TyCtxt,\n     writeln!(w, \"{}}}\", INDENT)\n }\n \n-fn comment(tcx: &TyCtxt,\n-           scope: ScopeId,\n-           span: Span)\n-           -> String {\n+fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n     format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n-fn write_scope_tree(tcx: &TyCtxt,\n+fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n                     auxiliary: Option<&ScopeAuxiliaryVec>,\n                     scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n@@ -222,7 +219,7 @@ fn write_scope_tree(tcx: &TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: &TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n+fn write_mir_intro(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n                    -> io::Result<()> {\n     match src {\n         MirSource::Fn(_) => write!(w, \"fn\")?,"}, {"sha": "1d8b9f39662df58774b08fe84fde670f0358fb85", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -42,7 +42,7 @@ pub struct BreakCriticalEdges;\n  */\n \n impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         break_critical_edges(mir);\n     }\n }"}, {"sha": "17a849c4cce73886316aa565335f75cb2ec1fd09", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -19,11 +19,11 @@ use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx: tcx\n         }\n@@ -46,7 +46,7 @@ pub struct EraseRegions;\n impl Pass for EraseRegions {}\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "1f6318ab72485668226a00c2205ed891f376c1b9", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -41,7 +41,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }"}, {"sha": "0f08c4af71f35d79596496320b8c5da8f6299046", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -330,10 +330,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'tcx>(mir: &mut Mir<'tcx>,\n-                                tcx: &TyCtxt<'tcx>,\n-                                mut temps: Vec<TempState>,\n-                                candidates: Vec<Candidate>) {\n+pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+                                    tcx: TyCtxt<'a, 'tcx>,\n+                                    mut temps: Vec<TempState>,\n+                                    candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     for candidate in candidates.into_iter().rev() {\n         let (span, ty) = match candidate {"}, {"sha": "1af9cf8376e3556b3c004df6afad9d202ac5d726", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -109,7 +109,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-fn is_const_fn(tcx: &TyCtxt, def_id: DefId) -> bool {\n+fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n         match fn_like.map(|f| f.kind()) {\n@@ -132,7 +132,7 @@ struct Qualifier<'a, 'tcx: 'a> {\n     def_id: DefId,\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     param_env: ty::ParameterEnvironment<'a, 'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n@@ -908,11 +908,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n     }\n }\n \n-fn qualify_const_item_cached<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   qualif_map: &mut DefIdMap<Qualif>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   def_id: DefId)\n-                                   -> Qualif {\n+fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                       qualif_map: &mut DefIdMap<Qualif>,\n+                                       mir_map: Option<&MirMap<'tcx>>,\n+                                       def_id: DefId)\n+                                       -> Qualif {\n     match qualif_map.entry(def_id) {\n         Entry::Occupied(entry) => return *entry.get(),\n         Entry::Vacant(entry) => {\n@@ -951,7 +951,7 @@ pub struct QualifyAndPromoteConstants;\n impl Pass for QualifyAndPromoteConstants {}\n \n impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n         let mut qualif_map = DefIdMap();\n \n         // First, visit `const` items, potentially recursing, to get"}, {"sha": "1cd8a569fe32632ecc0c8fb62c47ee8ccaad8622", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -40,7 +40,7 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n pub struct RemoveDeadBlocks;\n \n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n         // This block is always required.\n         seen.insert(START_BLOCK.index());"}, {"sha": "93534a694e4e0b37f39c92c31749b7d4cce1b7ba", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -111,7 +111,7 @@ impl SimplifyCfg {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut counter = 0;\n         let mut changed = true;\n         while changed {"}, {"sha": "8ccc621d224641a61bb516cbba9a46bf6a976250", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n@@ -349,7 +349,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -576,7 +576,7 @@ impl TypeckMir {\n }\n \n impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors."}, {"sha": "dfc59a6db5073210de687fbd8b39df3af261c0fa", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -68,7 +68,7 @@ enum Mode {\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n     rvalue_borrows: NodeMap<hir::Mutability>\n@@ -663,7 +663,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,"}, {"sha": "11ce3a17e9ea29f362738d34862a82d87904489c", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -23,13 +23,13 @@ use rustc::hir::intravisit;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n     tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n@@ -54,7 +54,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n }\n \n struct RvalueContextDelegate<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'a,'tcx>,\n }\n "}, {"sha": "d224c88d0ffa9fcdf5187d7c5bc9fab39246b639", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -58,7 +58,7 @@ type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     export_map: &'a def::ExportMap,\n \n     // Accessibility levels for reachable nodes\n@@ -128,7 +128,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -375,7 +376,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n ////////////////////////////////////////////////////////////////////////////////\n \n struct PrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n }\n@@ -417,7 +418,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -524,7 +526,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n@@ -595,7 +597,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // set of errors produced by this obsolete visitor\n@@ -679,7 +681,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -934,7 +937,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////////\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     /// The visitor checks that each component type is at least this visible\n     required_visibility: ty::Visibility,\n     /// The visibility of the least visible component that has been visited\n@@ -943,7 +946,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>, old_error_set: &'a NodeSet) -> Self {\n+    fn new(tcx: TyCtxt<'a, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: tcx,\n             min_visibility: ty::Visibility::Public,\n@@ -1015,7 +1018,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                         let item = self.tcx.map.expect_item(node_id);\n                         let vis = match self.substituted_alias_visibility(item, path) {\n                             Some(vis) => vis,\n-                            None => ty::Visibility::from_hir(&item.vis, node_id, &self.tcx),\n+                            None => ty::Visibility::from_hir(&item.vis, node_id, self.tcx),\n                         };\n \n                         if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n@@ -1047,7 +1050,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, node_id, &self.tcx);\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n             if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n                 self.min_visibility = vis;\n@@ -1079,7 +1082,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     old_error_set: &'a NodeSet,\n }\n \n@@ -1106,7 +1109,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n         };\n \n         let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, &self.tcx);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, self.tcx);\n \n         match item.node {\n             // Crates are always public\n@@ -1125,7 +1128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     check.required_visibility =\n-                        ty::Visibility::from_hir(&foreign_item.vis, item.id, &self.tcx);\n+                        ty::Visibility::from_hir(&foreign_item.vis, item.id, self.tcx);\n                     check.visit_foreign_item(foreign_item);\n                 }\n             }\n@@ -1135,7 +1138,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n                 check.visit_generics(generics);\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, &self.tcx);\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, self.tcx);\n                     check.required_visibility = min(item_visibility, field_visibility);\n                     check.visit_struct_field(field);\n                 }\n@@ -1151,7 +1154,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n \n                 for impl_item in impl_items {\n                     let impl_item_vis =\n-                        ty::Visibility::from_hir(&impl_item.vis, item.id, &self.tcx);\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n                     check.visit_impl_item(impl_item);\n                 }\n@@ -1170,7 +1173,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n+pub fn check_crate(tcx: TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n     let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n \n     let krate = tcx.map.krate();"}, {"sha": "cb4a9b20deaa6e5549a320bba3814b37cf33c5f7", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -62,7 +62,7 @@ macro_rules! down_cast_data {\n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n-    tcx: &'l TyCtxt<'tcx>,\n+    tcx: TyCtxt<'l, 'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n     dumper: &'ll mut D,\n \n@@ -79,7 +79,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n-    pub fn new(tcx: &'l TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'l, 'tcx>,\n                save_ctxt: SaveContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n                dumper: &'ll mut D)"}, {"sha": "51134f8383b368a5d7d18de4a83381208e6b7a75", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -19,7 +19,7 @@ use super::data;\n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n     type Target;\n-    fn lower(self, tcx: &TyCtxt) -> Self::Target;\n+    fn lower(self, tcx: TyCtxt) -> Self::Target;\n }\n \n fn make_def_id(id: NodeId, map: &Map) -> DefId {\n@@ -71,7 +71,7 @@ pub struct CratePreludeData {\n impl Lower for data::CratePreludeData {\n     type Target = CratePreludeData;\n \n-    fn lower(self, tcx: &TyCtxt) -> CratePreludeData {\n+    fn lower(self, tcx: TyCtxt) -> CratePreludeData {\n         CratePreludeData {\n             crate_name: self.crate_name,\n             crate_root: self.crate_root,\n@@ -94,7 +94,7 @@ pub struct EnumData {\n impl Lower for data::EnumData {\n     type Target = EnumData;\n \n-    fn lower(self, tcx: &TyCtxt) -> EnumData {\n+    fn lower(self, tcx: TyCtxt) -> EnumData {\n         EnumData {\n             id: make_def_id(self.id, &tcx.map),\n             value: self.value,\n@@ -119,7 +119,7 @@ pub struct ExternCrateData {\n impl Lower for data::ExternCrateData {\n     type Target = ExternCrateData;\n \n-    fn lower(self, tcx: &TyCtxt) -> ExternCrateData {\n+    fn lower(self, tcx: TyCtxt) -> ExternCrateData {\n         ExternCrateData {\n             id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n@@ -142,7 +142,7 @@ pub struct FunctionCallData {\n impl Lower for data::FunctionCallData {\n     type Target = FunctionCallData;\n \n-    fn lower(self, tcx: &TyCtxt) -> FunctionCallData {\n+    fn lower(self, tcx: TyCtxt) -> FunctionCallData {\n         FunctionCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -165,7 +165,7 @@ pub struct FunctionData {\n impl Lower for data::FunctionData {\n     type Target = FunctionData;\n \n-    fn lower(self, tcx: &TyCtxt) -> FunctionData {\n+    fn lower(self, tcx: TyCtxt) -> FunctionData {\n         FunctionData {\n             id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n@@ -188,7 +188,7 @@ pub struct FunctionRefData {\n impl Lower for data::FunctionRefData {\n     type Target = FunctionRefData;\n \n-    fn lower(self, tcx: &TyCtxt) -> FunctionRefData {\n+    fn lower(self, tcx: TyCtxt) -> FunctionRefData {\n         FunctionRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -208,7 +208,7 @@ pub struct ImplData {\n impl Lower for data::ImplData {\n     type Target = ImplData;\n \n-    fn lower(self, tcx: &TyCtxt) -> ImplData {\n+    fn lower(self, tcx: TyCtxt) -> ImplData {\n         ImplData {\n             id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -229,7 +229,7 @@ pub struct InheritanceData {\n impl Lower for data::InheritanceData {\n     type Target = InheritanceData;\n \n-    fn lower(self, tcx: &TyCtxt) -> InheritanceData {\n+    fn lower(self, tcx: TyCtxt) -> InheritanceData {\n         InheritanceData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             base_id: self.base_id,\n@@ -249,7 +249,7 @@ pub struct MacroData {\n impl Lower for data::MacroData {\n     type Target = MacroData;\n \n-    fn lower(self, tcx: &TyCtxt) -> MacroData {\n+    fn lower(self, tcx: TyCtxt) -> MacroData {\n         MacroData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n@@ -274,7 +274,7 @@ pub struct MacroUseData {\n impl Lower for data::MacroUseData {\n     type Target = MacroUseData;\n \n-    fn lower(self, tcx: &TyCtxt) -> MacroUseData {\n+    fn lower(self, tcx: TyCtxt) -> MacroUseData {\n         MacroUseData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             name: self.name,\n@@ -298,7 +298,7 @@ pub struct MethodCallData {\n impl Lower for data::MethodCallData {\n     type Target = MethodCallData;\n \n-    fn lower(self, tcx: &TyCtxt) -> MethodCallData {\n+    fn lower(self, tcx: TyCtxt) -> MethodCallData {\n         MethodCallData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -320,7 +320,7 @@ pub struct MethodData {\n impl Lower for data::MethodData {\n     type Target = MethodData;\n \n-    fn lower(self, tcx: &TyCtxt) -> MethodData {\n+    fn lower(self, tcx: TyCtxt) -> MethodData {\n         MethodData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -344,7 +344,7 @@ pub struct ModData {\n impl Lower for data::ModData {\n     type Target = ModData;\n \n-    fn lower(self, tcx: &TyCtxt) -> ModData {\n+    fn lower(self, tcx: TyCtxt) -> ModData {\n         ModData {\n             id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n@@ -368,7 +368,7 @@ pub struct ModRefData {\n impl Lower for data::ModRefData {\n     type Target = ModRefData;\n \n-    fn lower(self, tcx: &TyCtxt) -> ModRefData {\n+    fn lower(self, tcx: TyCtxt) -> ModRefData {\n         ModRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -391,7 +391,7 @@ pub struct StructData {\n impl Lower for data::StructData {\n     type Target = StructData;\n \n-    fn lower(self, tcx: &TyCtxt) -> StructData {\n+    fn lower(self, tcx: TyCtxt) -> StructData {\n         StructData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.map),\n@@ -416,7 +416,7 @@ pub struct StructVariantData {\n impl Lower for data::StructVariantData {\n     type Target = StructVariantData;\n \n-    fn lower(self, tcx: &TyCtxt) -> StructVariantData {\n+    fn lower(self, tcx: TyCtxt) -> StructVariantData {\n         StructVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.map),\n@@ -440,7 +440,7 @@ pub struct TraitData {\n impl Lower for data::TraitData {\n     type Target = TraitData;\n \n-    fn lower(self, tcx: &TyCtxt) -> TraitData {\n+    fn lower(self, tcx: TyCtxt) -> TraitData {\n         TraitData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.map),\n@@ -465,7 +465,7 @@ pub struct TupleVariantData {\n impl Lower for data::TupleVariantData {\n     type Target = TupleVariantData;\n \n-    fn lower(self, tcx: &TyCtxt) -> TupleVariantData {\n+    fn lower(self, tcx: TyCtxt) -> TupleVariantData {\n         TupleVariantData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             id: make_def_id(self.id, &tcx.map),\n@@ -490,7 +490,7 @@ pub struct TypedefData {\n impl Lower for data::TypedefData {\n     type Target = TypedefData;\n \n-    fn lower(self, tcx: &TyCtxt) -> TypedefData {\n+    fn lower(self, tcx: TyCtxt) -> TypedefData {\n         TypedefData {\n             id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -512,7 +512,7 @@ pub struct TypeRefData {\n impl Lower for data::TypeRefData {\n     type Target = TypeRefData;\n \n-    fn lower(self, tcx: &TyCtxt) -> TypeRefData {\n+    fn lower(self, tcx: TyCtxt) -> TypeRefData {\n         TypeRefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n@@ -534,7 +534,7 @@ pub struct UseData {\n impl Lower for data::UseData {\n     type Target = UseData;\n \n-    fn lower(self, tcx: &TyCtxt) -> UseData {\n+    fn lower(self, tcx: TyCtxt) -> UseData {\n         UseData {\n             id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -556,7 +556,7 @@ pub struct UseGlobData {\n impl Lower for data::UseGlobData {\n     type Target = UseGlobData;\n \n-    fn lower(self, tcx: &TyCtxt) -> UseGlobData {\n+    fn lower(self, tcx: TyCtxt) -> UseGlobData {\n         UseGlobData {\n             id: make_def_id(self.id, &tcx.map),\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n@@ -581,7 +581,7 @@ pub struct VariableData {\n impl Lower for data::VariableData {\n     type Target = VariableData;\n \n-    fn lower(self, tcx: &TyCtxt) -> VariableData {\n+    fn lower(self, tcx: TyCtxt) -> VariableData {\n         VariableData {\n             id: make_def_id(self.id, &tcx.map),\n             name: self.name,\n@@ -607,7 +607,7 @@ pub struct VariableRefData {\n impl Lower for data::VariableRefData {\n     type Target = VariableRefData;\n \n-    fn lower(self, tcx: &TyCtxt) -> VariableRefData {\n+    fn lower(self, tcx: TyCtxt) -> VariableRefData {\n         VariableRefData {\n             name: self.name,\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),"}, {"sha": "f64aa4347a800097c0b2e48652eca0a18702959e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -75,7 +75,7 @@ pub mod recorder {\n }\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    tcx: &'l TyCtxt<'tcx>,\n+    tcx: TyCtxt<'l, 'tcx>,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -84,12 +84,12 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l TyCtxt<'tcx>) -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'l, 'tcx>) -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         SaveContext::from_span_utils(tcx, span_utils)\n     }\n \n-    pub fn from_span_utils(tcx: &'l TyCtxt<'tcx>,\n+    pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx>,\n                            span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n@@ -699,7 +699,7 @@ impl Format {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n+pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx>,\n                                krate: &ast::Crate,\n                                analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,"}, {"sha": "83a7b52dfbd00ff94f0a77c4159ee25084c15f08", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -239,7 +239,7 @@ use syntax::ptr::P;\n struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n-    fn eq(self, other: ConstantExpr<'a>, tcx: &TyCtxt) -> bool {\n+    fn eq(self, other: ConstantExpr<'a>, tcx: TyCtxt) -> bool {\n         match compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n             None => bug!(\"compare_list_exprs: type mismatch\"),\n@@ -259,8 +259,8 @@ enum Opt<'a, 'tcx> {\n                               DebugLoc),\n }\n \n-impl<'a, 'tcx> Opt<'a, 'tcx> {\n-    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: &TyCtxt<'tcx>) -> bool {\n+impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n+    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: TyCtxt<'b, 'tcx>) -> bool {\n         match (self, other) {\n             (&ConstantValue(a, _), &ConstantValue(b, _)) => a.eq(b, tcx),\n             (&ConstantRange(a1, a2, _), &ConstantRange(b1, b2, _)) => {\n@@ -789,7 +789,7 @@ fn any_region_pat(m: &[Match], col: usize) -> bool {\n     any_pat!(m, col, PatKind::Ref(..))\n }\n \n-fn any_irrefutable_adt_pat(tcx: &TyCtxt, m: &[Match], col: usize) -> bool {\n+fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {"}, {"sha": "ceb5f6ae9e34dff320f992459b245e90f893f2ea", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -236,9 +236,9 @@ fn dtor_to_init_u8(dtor: bool) -> u8 {\n     if dtor { DTOR_NEEDED } else { 0 }\n }\n \n-pub trait GetDtorType<'tcx> { fn dtor_type(&self) -> Ty<'tcx>; }\n-impl<'tcx> GetDtorType<'tcx> for TyCtxt<'tcx> {\n-    fn dtor_type(&self) -> Ty<'tcx> { self.types.u8 }\n+pub trait GetDtorType<'tcx> { fn dtor_type(self) -> Ty<'tcx>; }\n+impl<'a, 'tcx> GetDtorType<'tcx> for TyCtxt<'a, 'tcx> {\n+    fn dtor_type(self) -> Ty<'tcx> { self.types.u8 }\n }\n \n fn dtor_active(flag: u8) -> bool {\n@@ -442,9 +442,10 @@ struct Case<'tcx> {\n /// This represents the (GEP) indices to follow to get to the discriminant field\n pub type DiscrField = Vec<usize>;\n \n-fn find_discr_field_candidate<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                    ty: Ty<'tcx>,\n-                                    mut path: DiscrField) -> Option<DiscrField> {\n+fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                        ty: Ty<'tcx>,\n+                                        mut path: DiscrField)\n+                                        -> Option<DiscrField> {\n     match ty.sty {\n         // Fat &T/&mut T/Box<T> i.e. T is [T], str, or Trait\n         ty::TyRef(_, ty::TypeAndMut { ty, .. }) | ty::TyBox(ty) if !type_is_sized(tcx, ty) => {\n@@ -544,10 +545,10 @@ impl<'tcx> Case<'tcx> {\n     }\n }\n \n-fn get_cases<'tcx>(tcx: &TyCtxt<'tcx>,\n-                   adt: ty::AdtDef<'tcx>,\n-                   substs: &subst::Substs<'tcx>)\n-                   -> Vec<Case<'tcx>> {\n+fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                       adt: ty::AdtDef<'tcx>,\n+                       substs: &subst::Substs<'tcx>)\n+                       -> Vec<Case<'tcx>> {\n     adt.variants.iter().map(|vi| {\n         let field_tys = vi.fields.iter().map(|field| {\n             monomorphize::field_ty(tcx, substs, field)\n@@ -668,7 +669,7 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-pub fn ty_of_inttype<'tcx>(tcx: &TyCtxt<'tcx>, ity: IntType) -> Ty<'tcx> {\n+pub fn ty_of_inttype<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n         attr::SignedInt(t) => tcx.mk_mach_int(t),\n         attr::UnsignedInt(t) => tcx.mk_mach_uint(t)"}, {"sha": "ec728da47476930a2142396b31ddce84b417b21f", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -124,9 +124,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n }\n \n-pub fn build_link_meta(tcx: &TyCtxt,\n-                       name: &str)\n-                       -> LinkMeta {\n+pub fn build_link_meta(tcx: TyCtxt, name: &str) -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n         crate_hash: tcx.calculate_krate_hash(),"}, {"sha": "cc353af81f51622b1dbfa11395f7523a10346f8e", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -103,20 +103,20 @@ use util::sha2::{Digest, Sha256};\n \n use rustc::middle::cstore;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n use std::fmt::Write;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n-pub fn def_id_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_id: DefId) -> String {\n+pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> String {\n     let def_path = tcx.def_path(def_id);\n     def_path_to_string(tcx, &def_path)\n }\n \n-pub fn def_path_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_path: &DefPath) -> String {\n+pub fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_path: &DefPath) -> String {\n     let mut s = String::with_capacity(def_path.data.len() * 16);\n \n     s.push_str(&tcx.crate_name(def_path.krate));"}, {"sha": "221d32528de579e6ce7dfb47c79d9f013e6869dc", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -1308,7 +1308,7 @@ impl<'v> Visitor<'v> for FindNestedReturn {\n     }\n }\n \n-fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n+fn build_cfg(tcx: TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n     let blk = match tcx.map.find(id) {\n         Some(hir_map::NodeItem(i)) => {\n             match i.node {\n@@ -1364,7 +1364,7 @@ fn build_cfg(tcx: &TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n // part of a larger expression that may have already partially-filled the\n // return slot alloca. This can cause errors related to clean-up due to\n // the clobbering of the existing value in the return slot.\n-fn has_nested_returns(tcx: &TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n+fn has_nested_returns(tcx: TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool {\n     for index in cfg.graph.depth_traverse(cfg.entry) {\n         let n = cfg.graph.node_data(index);\n         match tcx.map.find(n.id()) {\n@@ -2688,10 +2688,10 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n     }).collect()\n }\n \n-pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n-                         mir_map: &MirMap<'tcx>,\n-                         analysis: ty::CrateAnalysis)\n-                         -> CrateTranslation {\n+pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                             mir_map: &MirMap<'tcx>,\n+                             analysis: ty::CrateAnalysis)\n+                             -> CrateTranslation {\n     let _task = tcx.dep_graph.in_task(DepNode::TransCrate);\n \n     // Be careful with this krate: obviously it gives access to the\n@@ -2714,7 +2714,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         tcx.sess.opts.debug_assertions\n     };\n \n-    let link_meta = link::build_link_meta(&tcx, name);\n+    let link_meta = link::build_link_meta(tcx, name);\n \n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              &mir_map,"}, {"sha": "fd026067b88993094b233c74dcdfaa917623682f", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -275,10 +275,10 @@ impl<'tcx> Callee<'tcx> {\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n-fn def_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                def_id: DefId,\n-                substs: &'tcx subst::Substs<'tcx>)\n-                -> Ty<'tcx> {\n+fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                    def_id: DefId,\n+                    substs: &'tcx subst::Substs<'tcx>)\n+                    -> Ty<'tcx> {\n     let ty = tcx.lookup_item_type(def_id).ty;\n     monomorphize::apply_param_substs(tcx, substs, &ty)\n }\n@@ -442,7 +442,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // def_id to the local id of the inlined copy.\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n \n-    fn is_named_tuple_constructor(tcx: &TyCtxt, def_id: DefId) -> bool {\n+    fn is_named_tuple_constructor(tcx: TyCtxt, def_id: DefId) -> bool {\n         let node_id = match tcx.map.as_local_node_id(def_id) {\n             Some(n) => n,\n             None => { return false; }"}, {"sha": "3081f055bb4dd1065b975e7d99153f1856dd3052", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -1176,7 +1176,7 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n     }\n }\n \n-pub fn temporary_scope(tcx: &TyCtxt,\n+pub fn temporary_scope(tcx: TyCtxt,\n                        id: ast::NodeId)\n                        -> ScopeId {\n     match tcx.region_maps.temporary_scope(id) {\n@@ -1191,7 +1191,7 @@ pub fn temporary_scope(tcx: &TyCtxt,\n     }\n }\n \n-pub fn var_scope(tcx: &TyCtxt,\n+pub fn var_scope(tcx: TyCtxt,\n                  id: ast::NodeId)\n                  -> ScopeId {\n     let r = AstScope(tcx.region_maps.var_scope(id).node_id(&tcx.region_maps));"}, {"sha": "1bc99a9a6e95cd8c24b85e263a16f900973c276f", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -119,10 +119,10 @@ impl ClosureEnv {\n     }\n }\n \n-fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n-                       closure_id: DefId,\n-                       fn_ty: Ty<'tcx>)\n-                       -> Ty<'tcx> {\n+fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                           closure_id: DefId,\n+                           fn_ty: Ty<'tcx>)\n+                           -> Ty<'tcx> {\n     match tcx.closure_kind(closure_id) {\n         ty::ClosureKind::Fn => {\n             tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), fn_ty)"}, {"sha": "19b4e65b470240a77f0da85003d73e8d7f1eb658", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -432,10 +432,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'tcx>(tcx: &TyCtxt<'tcx>,\n-                           caller: TransItem<'tcx>,\n-                           callees: &[TransItem<'tcx>],\n-                           reference_map: &mut ReferenceMap<'tcx>) {\n+fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                               caller: TransItem<'tcx>,\n+                               callees: &[TransItem<'tcx>],\n+                               reference_map: &mut ReferenceMap<'tcx>) {\n     let iter = callees.into_iter()\n                       .map(|callee| {\n                         let is_inlining_candidate = callee.is_from_extern_crate() ||\n@@ -445,10 +445,10 @@ fn record_references<'tcx>(tcx: &TyCtxt<'tcx>,\n     reference_map.record_references(caller, iter);\n }\n \n-fn check_recursion_limit<'tcx>(tcx: &TyCtxt<'tcx>,\n-                               instance: Instance<'tcx>,\n-                               recursion_depths: &mut DefIdMap<usize>)\n-                               -> (DefId, usize) {\n+fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                   instance: Instance<'tcx>,\n+                                   recursion_depths: &mut DefIdMap<usize>)\n+                                   -> (DefId, usize) {\n     let recursion_depth = recursion_depths.get(&instance.def)\n                                           .map(|x| *x)\n                                           .unwrap_or(0);\n@@ -606,9 +606,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_operand(operand);\n \n-        fn can_result_in_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                          def_id: DefId)\n-                                          -> bool {\n+        fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                              def_id: DefId)\n+                                              -> bool {\n             if !match tcx.lookup_item_type(def_id).ty.sty {\n                 ty::TyFnDef(def_id, _, _) => {\n                     // Some constructors also have type TyFnDef but they are\n@@ -635,9 +635,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn can_have_local_instance<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                 def_id: DefId)\n-                                 -> bool {\n+fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                     def_id: DefId)\n+                                     -> bool {\n     // Take a look if we have the definition available. If not, we\n     // will not emit code for this item in the local crate, and thus\n     // don't create a translation item for it.\n@@ -960,11 +960,11 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              def_id: DefId,\n-                              fn_substs: &Substs<'tcx>,\n-                              param_substs: &Substs<'tcx>)\n-                              -> TransItem<'tcx> {\n+fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                  def_id: DefId,\n+                                  fn_substs: &Substs<'tcx>,\n+                                  param_substs: &Substs<'tcx>)\n+                                  -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(def_id={}, fn_substs={:?}, param_substs={:?})\",\n             def_id_to_string(tcx, def_id),\n             fn_substs,\n@@ -1146,9 +1146,9 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn create_trans_items_for_default_impls<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              item: &'tcx hir::Item,\n-                                              output: &mut Vec<TransItem<'tcx>>) {\n+fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                                  item: &'tcx hir::Item,\n+                                                  output: &mut Vec<TransItem<'tcx>>) {\n     match item.node {\n         hir::ItemImpl(_,\n                       _,\n@@ -1225,9 +1225,9 @@ fn create_trans_items_for_default_impls<'tcx>(tcx: &TyCtxt<'tcx>,\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   t: ty::Ty<'tcx>,\n-                                   output: &mut String) {\n+pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                       t: ty::Ty<'tcx>,\n+                                       output: &mut String) {\n     match t.sty {\n         ty::TyBool              => output.push_str(\"bool\"),\n         ty::TyChar              => output.push_str(\"char\"),\n@@ -1363,7 +1363,7 @@ pub fn push_unique_type_name<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn push_item_name(tcx: &TyCtxt,\n+fn push_item_name(tcx: TyCtxt,\n                   def_id: DefId,\n                   output: &mut String) {\n     let def_path = tcx.def_path(def_id);\n@@ -1384,10 +1384,10 @@ fn push_item_name(tcx: &TyCtxt,\n     output.pop();\n }\n \n-fn push_type_params<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                          projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                          output: &mut String) {\n+fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              output: &mut String) {\n     if types.is_empty() && projections.is_empty() {\n         return;\n     }\n@@ -1414,30 +1414,29 @@ fn push_type_params<'tcx>(tcx: &TyCtxt<'tcx>,\n     output.push('>');\n }\n \n-fn push_instance_as_string<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                 instance: Instance<'tcx>,\n-                                 output: &mut String) {\n+fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n     push_item_name(tcx, instance.def, output);\n     push_type_params(tcx, &instance.substs.types, &[], output);\n }\n \n-pub fn def_id_to_string(tcx: &TyCtxt, def_id: DefId) -> String {\n+pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n     let mut output = String::new();\n     push_item_name(tcx, def_id, &mut output);\n     output\n }\n \n-fn type_to_string<'tcx>(tcx: &TyCtxt<'tcx>,\n-                        ty: ty::Ty<'tcx>)\n-                        -> String {\n+fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                            ty: ty::Ty<'tcx>)\n+                            -> String {\n     let mut output = String::new();\n     push_unique_type_name(tcx, ty, &mut output);\n     output\n }\n \n-impl<'tcx> TransItem<'tcx> {\n-\n-    pub fn requests_inline(&self, tcx: &TyCtxt<'tcx>) -> bool {\n+impl<'a, 'tcx> TransItem<'tcx> {\n+    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 let attributes = tcx.get_attrs(instance.def);\n@@ -1464,7 +1463,7 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: &TyCtxt<'tcx>) -> Option<llvm::Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,\n             TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n@@ -1488,7 +1487,7 @@ impl<'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string(&self, tcx: &TyCtxt<'tcx>) -> String {\n+    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx>) -> String {\n         let hir_map = &tcx.map;\n \n         return match *self {\n@@ -1511,10 +1510,10 @@ impl<'tcx> TransItem<'tcx> {\n             },\n         };\n \n-        fn to_string_internal<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                    prefix: &str,\n-                                    instance: Instance<'tcx>)\n-                                    -> String {\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n             let mut result = String::with_capacity(32);\n             result.push_str(prefix);\n             push_instance_as_string(tcx, instance, &mut result);"}, {"sha": "5e69c775634add125d11bdadd602268b995d163a", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -58,11 +58,11 @@ use syntax::parse::token;\n pub use context::{CrateContext, SharedCrateContext};\n \n /// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n }\n \n-pub fn type_is_fat_ptr<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_fat_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n@@ -164,8 +164,8 @@ pub struct VariantInfo<'tcx> {\n     pub fields: Vec<Field<'tcx>>\n }\n \n-impl<'tcx> VariantInfo<'tcx> {\n-    pub fn from_ty(tcx: &TyCtxt<'tcx>,\n+impl<'a, 'tcx> VariantInfo<'tcx> {\n+    pub fn from_ty(tcx: TyCtxt<'a, 'tcx>,\n                    ty: Ty<'tcx>,\n                    opt_def: Option<Def>)\n                    -> Self\n@@ -201,7 +201,7 @@ impl<'tcx> VariantInfo<'tcx> {\n     }\n \n     /// Return the variant corresponding to a given node (e.g. expr)\n-    pub fn of_node(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n+    pub fn of_node(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n         let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n         Self::from_ty(tcx, ty, node_def)\n     }\n@@ -568,7 +568,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n         self.fcx\n     }\n-    pub fn tcx(&self) -> &'blk TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx> {\n         self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n@@ -694,7 +694,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n         self.bcx.fcx()\n     }\n-    pub fn tcx(&self) -> &'blk TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx> {\n         self.bcx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session {\n@@ -1119,9 +1119,9 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n /// returns false, then either normalize encountered an error or one\n /// of the predicates did not hold. Used when creating vtables to\n /// check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                           predicates: Vec<ty::Predicate<'tcx>>)\n-                                           -> bool\n+pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n {\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);"}, {"sha": "3fc9e89098c7104648442d1a930e0037c2ac43d1", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -472,7 +472,7 @@ fn check_unary_expr_validity(cx: &CrateContext, e: &hir::Expr, t: Ty,\n     Ok(())\n }\n \n-pub fn to_const_int(value: ValueRef, t: Ty, tcx: &TyCtxt) -> Option<ConstInt> {\n+pub fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n         ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n             ast::IntTy::I8 => {"}, {"sha": "49b71ae58896835b5bf19d22da6025ad07280acf", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -73,7 +73,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n@@ -331,7 +331,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n }\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(tcx: &'b TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'b, 'tcx>,\n                mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n@@ -450,7 +450,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.link_meta\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n         self.tcx\n     }\n \n@@ -640,7 +640,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n         self.shared.tcx\n     }\n "}, {"sha": "a5416c2fed1ad7a709e6ada3c14da789ee94c793", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -722,7 +722,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &hir::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk TyCtxt<'tcx>, &VariantInfo<'tcx>) -> usize,\n+    F: FnOnce(TyCtxt<'blk, 'tcx>, &VariantInfo<'tcx>) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -1826,11 +1826,11 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn cast_is_noop<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          expr: &hir::Expr,\n-                          t_in: Ty<'tcx>,\n-                          t_out: Ty<'tcx>)\n-                          -> bool {\n+pub fn cast_is_noop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                              expr: &hir::Expr,\n+                              t_in: Ty<'tcx>,\n+                              t_out: Ty<'tcx>)\n+                              -> bool {\n     if let Some(&CastKind::CoercionCast) = tcx.cast_kinds.borrow().get(&expr.id) {\n         return true;\n     }\n@@ -2185,7 +2185,7 @@ impl OverflowOpViaIntrinsic {\n         let name = self.to_intrinsic_name(bcx.tcx(), lhs_ty);\n         bcx.ccx().get_intrinsic(&name)\n     }\n-    fn to_intrinsic_name(&self, tcx: &TyCtxt, ty: Ty) -> &'static str {\n+    fn to_intrinsic_name(&self, tcx: TyCtxt, ty: Ty) -> &'static str {\n         use syntax::ast::IntTy::*;\n         use syntax::ast::UintTy::*;\n         use rustc::ty::{TyInt, TyUint};\n@@ -2377,7 +2377,7 @@ enum ExprKind {\n     RvalueStmt\n }\n \n-fn expr_kind(tcx: &TyCtxt, expr: &hir::Expr) -> ExprKind {\n+fn expr_kind(tcx: TyCtxt, expr: &hir::Expr) -> ExprKind {\n     if tcx.is_method_call(expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:"}, {"sha": "660ce0e0fcefedf7d7488e30be712d1139b0575c", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -89,12 +89,12 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn type_needs_drop<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n }\n \n-pub fn get_drop_glue_type<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                t: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                    t: Ty<'tcx>) -> Ty<'tcx> {\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr.\n     if !type_is_sized(tcx, t) {\n@@ -110,11 +110,11 @@ pub fn get_drop_glue_type<'tcx>(tcx: &TyCtxt<'tcx>,\n     // returned `tcx.types.i8` does not appear unsound. The impact on\n     // code quality is unknown at this time.)\n \n-    if !type_needs_drop(&tcx, t) {\n+    if !type_needs_drop(tcx, t) {\n         return tcx.types.i8;\n     }\n     match t.sty {\n-        ty::TyBox(typ) if !type_needs_drop(&tcx, typ)\n+        ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n             let infcx = InferCtxt::normalizing(tcx,\n                                                &tcx.tables,"}, {"sha": "e5f0f358f9688e11b470b2d81aab95a0cebadb40", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -215,10 +215,10 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub fn get_vtable_methods<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                impl_id: DefId,\n-                                substs: &'tcx subst::Substs<'tcx>)\n-                                -> Vec<Option<ImplMethod<'tcx>>>\n+pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                    impl_id: DefId,\n+                                    substs: &'tcx subst::Substs<'tcx>)\n+                                    -> Vec<Option<ImplMethod<'tcx>>>\n {\n     debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n \n@@ -304,11 +304,11 @@ pub struct ImplMethod<'tcx> {\n }\n \n /// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                             impl_def_id: DefId,\n-                             substs: &'tcx Substs<'tcx>,\n-                             name: Name)\n-                             -> ImplMethod<'tcx>\n+pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                 impl_def_id: DefId,\n+                                 substs: &'tcx Substs<'tcx>,\n+                                 name: Name)\n+                                 -> ImplMethod<'tcx>\n {\n     assert!(!substs.types.needs_infer());\n "}, {"sha": "97e9af5fb6eb4298aeebd753cdbfacfece5ea2d3", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -182,17 +182,17 @@ impl<'tcx> Instance<'tcx> {\n         assert!(substs.regions.iter().all(|&r| r == ty::ReStatic));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono(tcx: &TyCtxt<'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, &tcx.mk_substs(Substs::empty()))\n+    pub fn mono<'a>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+        Instance::new(def_id, tcx.mk_substs(Substs::empty()))\n     }\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'tcx,T>(tcx: &TyCtxt<'tcx>,\n-                                  param_substs: &Substs<'tcx>,\n-                                  value: &T)\n-                                  -> T\n+pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx>,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n     where T : TypeFoldable<'tcx>\n {\n     let substituted = value.subst(tcx, param_substs);\n@@ -201,10 +201,10 @@ pub fn apply_param_substs<'tcx,T>(tcx: &TyCtxt<'tcx>,\n \n \n /// Returns the normalized type of a struct field\n-pub fn field_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                      param_substs: &Substs<'tcx>,\n-                      f: ty::FieldDef<'tcx>)\n-                      -> Ty<'tcx>\n+pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                          param_substs: &Substs<'tcx>,\n+                          f: ty::FieldDef<'tcx>)\n+                          -> Ty<'tcx>\n {\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }"}, {"sha": "efeb0abe28c3be1e64479cb5d1e46a00a8a55752", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -153,11 +153,11 @@ pub enum PartitioningStrategy {\n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n-pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n-                          trans_items: I,\n-                          strategy: PartitioningStrategy,\n-                          reference_map: &ReferenceMap<'tcx>)\n-                          -> Vec<CodegenUnit<'tcx>>\n+pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx>,\n+                              trans_items: I,\n+                              strategy: PartitioningStrategy,\n+                              reference_map: &ReferenceMap<'tcx>)\n+                              -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     // In the first step, we place all regular translation items into their\n@@ -193,9 +193,9 @@ struct PreInliningPartitioning<'tcx> {\n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n-fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n-                                         trans_items: I)\n-                                         -> PreInliningPartitioning<'tcx>\n+fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx>,\n+                                             trans_items: I)\n+                                             -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let mut roots = FnvHashSet();\n@@ -375,9 +375,9 @@ fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n     PostDeclarationsPartitioning(codegen_units)\n }\n \n-fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                             trans_item: TransItem<'tcx>)\n-                                             -> Option<DefId> {\n+fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                                 trans_item: TransItem<'tcx>)\n+                                                 -> Option<DefId> {\n     match trans_item {\n         TransItem::Fn(instance) => {\n             // If this is a method, we want to put it into the same module as\n@@ -410,10 +410,10 @@ fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn compute_codegen_unit_name<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   def_id: DefId,\n-                                   volatile: bool)\n-                                   -> InternedString {\n+fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                                       def_id: DefId,\n+                                       volatile: bool)\n+                                       -> InternedString {\n     // Unfortunately we cannot just use the `ty::item_path` infrastructure here\n     // because we need paths to modules and the DefIds of those are not\n     // available anymore for external items."}, {"sha": "1ed09be8ae9b02ebdb4b2a0311319c8b14ae9a44", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -79,7 +79,7 @@ use rustc::hir;\n use rustc_back::slice;\n \n pub trait AstConv<'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n \n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n@@ -162,7 +162,7 @@ pub trait AstConv<'tcx> {\n     fn set_tainted_by_errors(&self);\n }\n \n-pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n+pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n                             -> ty::Region {\n     let r = match tcx.named_region_map.get(&lifetime.id) {\n         None => {\n@@ -1175,7 +1175,7 @@ fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n     tcx.mk_trait(object.principal, object.bounds)\n }\n \n-fn report_ambiguous_associated_type(tcx: &TyCtxt,\n+fn report_ambiguous_associated_type(tcx: TyCtxt,\n                                     span: Span,\n                                     type_str: &str,\n                                     trait_str: &str,\n@@ -2159,7 +2159,7 @@ pub struct PartitionedBounds<'a> {\n \n /// Divides a list of bounds from the AST into three groups: builtin bounds (Copy, Sized etc),\n /// general trait bounds, and region bounds.\n-pub fn partition_bounds<'a>(tcx: &TyCtxt,\n+pub fn partition_bounds<'a>(tcx: TyCtxt,\n                             _span: Span,\n                             ast_bounds: &'a [hir::TyParamBound])\n                             -> PartitionedBounds<'a>\n@@ -2208,7 +2208,7 @@ pub fn partition_bounds<'a>(tcx: &TyCtxt,\n     }\n }\n \n-fn check_type_argument_count(tcx: &TyCtxt, span: Span, supplied: usize,\n+fn check_type_argument_count(tcx: TyCtxt, span: Span, supplied: usize,\n                              required: usize, accepted: usize) {\n     if supplied < required {\n         let expected = if required < accepted {\n@@ -2233,7 +2233,7 @@ fn check_type_argument_count(tcx: &TyCtxt, span: Span, supplied: usize,\n     }\n }\n \n-fn report_lifetime_number_error(tcx: &TyCtxt, span: Span, number: usize, expected: usize) {\n+fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected: usize) {\n     span_err!(tcx.sess, span, E0107,\n               \"wrong number of lifetime parameters: expected {}, found {}\",\n               expected, number);\n@@ -2249,11 +2249,9 @@ pub struct Bounds<'tcx> {\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n }\n \n-impl<'tcx> Bounds<'tcx> {\n-    pub fn predicates(&self,\n-        tcx: &TyCtxt<'tcx>,\n-        param_ty: Ty<'tcx>)\n-        -> Vec<ty::Predicate<'tcx>>\n+impl<'a, 'tcx> Bounds<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx>, param_ty: Ty<'tcx>)\n+                      -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut vec = Vec::new();\n "}, {"sha": "d534e48dd05da612795efc38d732c7d923a5f88b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -107,7 +107,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'f, 'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "ab5342bfa1a39608f06fd583d20ff4bb249dc69d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -617,7 +617,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "3e997bc140ff9cee62c619555f0bb533b4d391bb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -267,7 +267,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.private_candidate = None;\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "76b0e9342bdb3d242e01c65f17822b980b45196c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -365,7 +365,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx>,\n            tables: &'a RefCell<ty::Tables<'tcx>>,\n            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx> {\n@@ -902,7 +902,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n-fn report_forbidden_specialization(tcx: &TyCtxt,\n+fn report_forbidden_specialization(tcx: TyCtxt,\n                                    impl_item: &hir::ImplItem,\n                                    parent_impl: DefId)\n {\n@@ -925,8 +925,8 @@ fn report_forbidden_specialization(tcx: &TyCtxt,\n     err.emit();\n }\n \n-fn check_specialization_validity<'tcx>(tcx: &TyCtxt<'tcx>, trait_def: &ty::TraitDef<'tcx>,\n-                                       impl_id: DefId, impl_item: &hir::ImplItem)\n+fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, trait_def: &ty::TraitDef<'tcx>,\n+                                           impl_id: DefId, impl_item: &hir::ImplItem)\n {\n     let ancestors = trait_def.ancestors(impl_id);\n \n@@ -1143,7 +1143,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-pub fn check_representable(tcx: &TyCtxt,\n+pub fn check_representable(tcx: TyCtxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n                            _designation: &str) -> bool {\n@@ -1165,7 +1165,7 @@ pub fn check_representable(tcx: &TyCtxt,\n     return true\n }\n \n-pub fn check_simd(tcx: &TyCtxt, sp: Span, id: ast::NodeId) {\n+pub fn check_simd(tcx: TyCtxt, sp: Span, id: ast::NodeId) {\n     let t = tcx.node_id_to_type(id);\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n@@ -1253,7 +1253,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.infcx().tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.infcx().tcx }\n \n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -1438,7 +1438,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn tcx(&self) -> &TyCtxt<'tcx> { self.infcx().tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.infcx().tcx }\n \n     pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {\n         &self.inh.infcx\n@@ -4688,7 +4688,7 @@ pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n }\n \n // Returns true if b contains a break that can exit from b\n-pub fn may_break(tcx: &TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n+pub fn may_break(tcx: TyCtxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n     (loop_query(&b, |e| {"}, {"sha": "3972bfce3fa0739905e9d2e6ab2deb043a2a0b12", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "940e662d5ce687a9bf7717db2b24e45f87679302", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -109,7 +109,7 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n         SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.fcx.tcx()\n     }\n "}, {"sha": "53c47b85fbe3d31b2de5a9d0a7f063945873ea3e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -40,7 +40,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'ccx, 'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -511,7 +511,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n }\n \n-fn reject_shadowing_type_parameters(tcx: &TyCtxt, span: Span, generics: &ty::Generics) {\n+fn reject_shadowing_type_parameters(tcx: TyCtxt, span: Span, generics: &ty::Generics) {\n     let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n         .map(|tp| tp.name).collect::<HashSet<_>>();\n \n@@ -615,7 +615,7 @@ fn error_392<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, span: Span, param_name: ast::N\n                      \"parameter `{}` is never used\", param_name)\n }\n \n-fn error_194(tcx: &TyCtxt, span: Span, name: ast::Name) {\n+fn error_194(tcx: TyCtxt, span: Span, name: ast::Name) {\n     span_err!(tcx.sess, span, E0194,\n               \"type parameter `{}` shadows another type parameter of the same name\",\n               name);"}, {"sha": "16e9297ec157af23ef1916e4e990482febd95595", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -83,7 +83,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         WritebackCx { fcx: fcx }\n     }\n \n-    fn tcx(&self) -> &'cx TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n@@ -379,7 +379,7 @@ enum ResolveReason {\n }\n \n impl ResolveReason {\n-    fn span(&self, tcx: &TyCtxt) -> Span {\n+    fn span(&self, tcx: TyCtxt) -> Span {\n         match *self {\n             ResolvingExpr(s) => s,\n             ResolvingLocal(s) => s,\n@@ -409,7 +409,7 @@ impl ResolveReason {\n // unresolved types and so forth.\n \n struct Resolver<'cx, 'tcx: 'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n     infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n     writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n@@ -481,7 +481,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n }\n \n impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "7f3ff3679946b71bcf1579bdab06a7d27af87b8b", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -19,7 +19,7 @@ use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n \n struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n@@ -57,7 +57,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate(tcx: TyCtxt) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n     let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n     tcx.map.krate().visit_all_items(&mut visitor);"}, {"sha": "95b7ce63e2090c3d55c79b5eb2af49d08d8c956f", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -485,7 +485,7 @@ fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n     }\n }\n \n-fn enforce_trait_manually_implementable(tcx: &TyCtxt, sp: Span, trait_def_id: DefId) {\n+fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n         // the feature gate allows all of them\n         return"}, {"sha": "7426b5ce27772193e4a0c7e7c9f14f33a6e8e57b", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -21,13 +21,13 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::intravisit;\n use rustc::hir;\n \n-pub fn check(tcx: &TyCtxt) {\n+pub fn check(tcx: TyCtxt) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>\n+    tcx: TyCtxt<'cx, 'tcx>\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {"}, {"sha": "d71ca657b8108eb1d7b0fdec7d6f4a9b918c547b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::intravisit;\n use util::nodemap::DefIdMap;\n use lint;\n \n-pub fn check(tcx: &TyCtxt) {\n+pub fn check(tcx: TyCtxt) {\n     let mut overlap = OverlapChecker { tcx: tcx,\n                                        default_impls: DefIdMap() };\n \n@@ -33,7 +33,7 @@ pub fn check(tcx: &TyCtxt) {\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx>,\n \n     // maps from a trait def-id to an impl id\n     default_impls: DefIdMap<ast::NodeId>,\n@@ -44,7 +44,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         #[derive(Copy, Clone, PartialEq)]\n         enum Namespace { Type, Value }\n \n-        fn name_and_namespace(tcx: &TyCtxt, item: &ty::ImplOrTraitItemId)\n+        fn name_and_namespace(tcx: TyCtxt, item: &ty::ImplOrTraitItemId)\n                               -> (ast::Name, Namespace)\n         {\n             let name = tcx.impl_or_trait_item(item.def_id()).name();\n@@ -58,10 +58,10 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         let impl_items = self.tcx.impl_items.borrow();\n \n         for item1 in &impl_items[&impl1] {\n-            let (name, namespace) = name_and_namespace(&self.tcx, item1);\n+            let (name, namespace) = name_and_namespace(self.tcx, item1);\n \n             for item2 in &impl_items[&impl2] {\n-                if (name, namespace) == name_and_namespace(&self.tcx, item2) {\n+                if (name, namespace) == name_and_namespace(self.tcx, item2) {\n                     let msg = format!(\"duplicate definitions with name `{}`\", name);\n                     let node_id = self.tcx.map.as_local_node_id(item1.def_id()).unwrap();\n                     self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,"}, {"sha": "d5912e224bc9352c38f3e19354cb75b117223b5e", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -15,13 +15,13 @@ use rustc::ty::TyCtxt;\n use rustc::hir::intravisit;\n use rustc::hir;\n \n-pub fn check(tcx: &TyCtxt) {\n+pub fn check(tcx: TyCtxt) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n     tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n struct UnsafetyChecker<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>\n+    tcx: TyCtxt<'cx, 'tcx>\n }\n \n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {"}, {"sha": "4b1be8b9a5e9da902edc9fcb9c4f36976abe7f7b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -296,7 +296,7 @@ impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n }\n \n impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.ccx.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.ccx.tcx }\n \n     fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -498,10 +498,10 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for hir::Generics {\n /// parameter with id `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'tcx>(tcx: &TyCtxt<'tcx>,\n-                  ast_ty: &hir::Ty,\n-                  param_id: ast::NodeId)\n-                  -> bool\n+fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+                      ast_ty: &hir::Ty,\n+                      param_id: ast::NodeId)\n+                      -> bool\n {\n     if let hir::TyPath(None, _) = ast_ty.node {\n         let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();"}, {"sha": "a86595bbc4ecea290f0389a7550fc428e7246d2e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -149,7 +149,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     /// Note that these cycles can cross multiple items.\n     pub stack: RefCell<Vec<collect::AstConvRequest>>,\n \n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n }\n \n // Functions that write types into the node type table\n@@ -173,7 +173,7 @@ fn write_substs_to_tcx<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn lookup_full_def(tcx: &TyCtxt, sp: Span, id: ast::NodeId) -> Def {\n+fn lookup_full_def(tcx: TyCtxt, sp: Span, id: ast::NodeId) -> Def {\n     match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.full_def(),\n         None => {\n@@ -182,7 +182,7 @@ fn lookup_full_def(tcx: &TyCtxt, sp: Span, id: ast::NodeId) -> Def {\n     }\n }\n \n-fn require_c_abi_if_variadic(tcx: &TyCtxt,\n+fn require_c_abi_if_variadic(tcx: TyCtxt,\n                              decl: &hir::FnDecl,\n                              abi: Abi,\n                              span: Span) {\n@@ -329,7 +329,7 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt, trait_map: hir::TraitMap) -> CompileResult {\n+pub fn check_crate(tcx: TyCtxt, trait_map: hir::TraitMap) -> CompileResult {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,"}, {"sha": "7ee56e7cb007ac2294514b3ee2e9238f76666997", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -127,7 +127,7 @@ fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n }\n \n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n         self.terms_cx.tcx\n     }\n "}, {"sha": "08d61d19fe693797b43282f45d20354020f58eb2", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -27,7 +27,7 @@ mod solve;\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance(tcx: &TyCtxt) {\n+pub fn infer_variance(tcx: TyCtxt) {\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);"}, {"sha": "270f79e7ed7207d886e21f084a56c7731e2c6fd3", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -59,7 +59,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n // The first pass over the crate simply builds up the set of inferreds.\n \n pub struct TermsContext<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n     pub empty_variances: Rc<ty::ItemVariances>,\n@@ -98,7 +98,7 @@ pub struct InferredInfo<'a> {\n }\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx>,\n     arena: &'a mut TypedArena<VarianceTerm<'a>>)\n     -> TermsContext<'a, 'tcx>\n {\n@@ -125,7 +125,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n     terms_cx\n }\n \n-fn lang_items(tcx: &TyCtxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n     let all = vec![\n         (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n         (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),"}, {"sha": "b592d94fff3097bed4c4110be60f66981ef3282f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -68,7 +68,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n     })\n }\n \n-fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n+fn try_inline_def(cx: &DocContext, tcx: TyCtxt,\n                   def: Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n     let did = def.def_id();\n@@ -130,7 +130,7 @@ fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n     Some(ret)\n }\n \n-pub fn load_attrs(cx: &DocContext, tcx: &TyCtxt,\n+pub fn load_attrs(cx: &DocContext, tcx: TyCtxt,\n                   did: DefId) -> Vec<clean::Attribute> {\n     tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n }\n@@ -150,7 +150,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     }\n }\n \n-pub fn build_external_trait(cx: &DocContext, tcx: &TyCtxt,\n+pub fn build_external_trait(cx: &DocContext, tcx: TyCtxt,\n                             did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n@@ -166,7 +166,7 @@ pub fn build_external_trait(cx: &DocContext, tcx: &TyCtxt,\n     }\n }\n \n-fn build_external_function(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::Function {\n+fn build_external_function(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::Function {\n     let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n         ty::TyFnDef(_, _, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n@@ -189,7 +189,7 @@ fn build_external_function(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::\n     }\n }\n \n-fn build_struct(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::Struct {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n@@ -207,7 +207,7 @@ fn build_struct(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_type(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::ItemEnum {\n+fn build_type(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n@@ -228,7 +228,7 @@ fn build_type(cx: &DocContext, tcx: &TyCtxt, did: DefId) -> clean::ItemEnum {\n }\n \n pub fn build_impls(cx: &DocContext,\n-                   tcx: &TyCtxt,\n+                   tcx: TyCtxt,\n                    did: DefId) -> Vec<clean::Item> {\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n@@ -252,7 +252,7 @@ pub fn build_impls(cx: &DocContext,\n             populate_impls(cx, tcx, item.def, &mut impls);\n         }\n \n-        fn populate_impls(cx: &DocContext, tcx: &TyCtxt,\n+        fn populate_impls(cx: &DocContext, tcx: TyCtxt,\n                           def: cstore::DefLike,\n                           impls: &mut Vec<clean::Item>) {\n             match def {\n@@ -271,7 +271,7 @@ pub fn build_impls(cx: &DocContext,\n }\n \n pub fn build_impl(cx: &DocContext,\n-                  tcx: &TyCtxt,\n+                  tcx: TyCtxt,\n                   did: DefId,\n                   ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n@@ -441,7 +441,7 @@ pub fn build_impl(cx: &DocContext,\n     });\n }\n \n-fn build_module(cx: &DocContext, tcx: &TyCtxt,\n+fn build_module(cx: &DocContext, tcx: TyCtxt,\n                 did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, tcx, did, &mut items);\n@@ -450,7 +450,7 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext, tcx: &TyCtxt, did: DefId,\n+    fn fill_in(cx: &DocContext, tcx: TyCtxt, did: DefId,\n                items: &mut Vec<clean::Item>) {\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n@@ -476,7 +476,7 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n     }\n }\n \n-fn build_const(cx: &DocContext, tcx: &TyCtxt,\n+fn build_const(cx: &DocContext, tcx: TyCtxt,\n                did: DefId) -> clean::Constant {\n     let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n@@ -491,7 +491,7 @@ fn build_const(cx: &DocContext, tcx: &TyCtxt,\n     }\n }\n \n-fn build_static(cx: &DocContext, tcx: &TyCtxt,\n+fn build_static(cx: &DocContext, tcx: TyCtxt,\n                 did: DefId,\n                 mutable: bool) -> clean::Static {\n     clean::Static {"}, {"sha": "245ebcdfe4f5b164df96047409c0e60b81e64060", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -42,7 +42,7 @@ pub use rustc::session::search_paths::SearchPaths;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'a, 'tcx: 'a> {\n-    Typed(&'a TyCtxt<'tcx>),\n+    Typed(TyCtxt<'a, 'tcx>),\n     NotTyped(&'a session::Session)\n }\n \n@@ -74,14 +74,14 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn tcx_opt<'a>(&'a self) -> Option<&'a TyCtxt<'tcx>> {\n+    pub fn tcx_opt<'a>(&'a self) -> Option<TyCtxt<'a, 'tcx>> {\n         match self.maybe_typed {\n             Typed(tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }"}, {"sha": "79226515ce3335ed70719fef4df78ecb02078f34", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/513d392f7e66b416e5ba6f4f778ae2cfadb10832/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=513d392f7e66b416e5ba6f4f778ae2cfadb10832", "patch": "@@ -21,7 +21,7 @@ extern crate syntax;\n use rustc::mir::transform::{self, MirPass, MirSource};\n use rustc::mir::repr::{Mir, Literal};\n use rustc::mir::visit::MutVisitor;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_math::ConstInt;\n use rustc_plugin::Registry;\n@@ -30,7 +30,7 @@ struct Pass;\n \n impl transform::Pass for Pass {}\n impl<'tcx> MirPass<'tcx> for Pass {\n-    fn run_pass(&mut self, _: &ty::TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}]}