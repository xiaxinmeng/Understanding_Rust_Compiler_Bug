{"sha": "bebcb285ad187153a71296c42a02e4bb9c2297f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlYmNiMjg1YWQxODcxNTNhNzEyOTZjNDJhMDJlNGJiOWMyMjk3ZjU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-06T18:27:34Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T20:17:00Z"}, "message": "Restructure trans_crate() so that codegen unit partitioning happens before creating LocalCrateContexts.", "tree": {"sha": "c2bc20e85d3f51751510f8781d283a4472254e6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2bc20e85d3f51751510f8781d283a4472254e6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bebcb285ad187153a71296c42a02e4bb9c2297f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bebcb285ad187153a71296c42a02e4bb9c2297f5", "html_url": "https://github.com/rust-lang/rust/commit/bebcb285ad187153a71296c42a02e4bb9c2297f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bebcb285ad187153a71296c42a02e4bb9c2297f5/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb8c8c58d3d6db6af12b69d047b30c0277ef7263", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8c8c58d3d6db6af12b69d047b30c0277ef7263", "html_url": "https://github.com/rust-lang/rust/commit/bb8c8c58d3d6db6af12b69d047b30c0277ef7263"}], "stats": {"total": 68, "additions": 45, "deletions": 23}, "files": [{"sha": "cf81777be261d4895af8c5c4841bb7d3c7f686d8", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bebcb285ad187153a71296c42a02e4bb9c2297f5", "patch": "@@ -639,7 +639,8 @@ pub fn run_passes(sess: &Session,\n     }\n \n     // Sanity check\n-    assert!(trans.modules.len() == sess.opts.cg.codegen_units);\n+    assert!(trans.modules.len() == sess.opts.cg.codegen_units ||\n+            sess.opts.debugging_opts.incremental.is_some());\n \n     let tm = create_target_machine(sess);\n "}, {"sha": "a8aff88dfc7c31cc15bf7e16cca1291d9e57883c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=bebcb285ad187153a71296c42a02e4bb9c2297f5", "patch": "@@ -81,7 +81,7 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, InstantiationMode};\n+use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n use symbol_names_test;\n use tvec;\n use type_::Type;\n@@ -2186,7 +2186,8 @@ pub fn update_linkage(ccx: &CrateContext,\n             // `llval` is a translation of an item defined in a separate\n             // compilation unit.  This only makes sense if there are at least\n             // two compilation units.\n-            assert!(ccx.sess().opts.cg.codegen_units > 1);\n+            assert!(ccx.sess().opts.cg.codegen_units > 1 ||\n+                    ccx.sess().opts.debugging_opts.incremental.is_some());\n             // `llval` is a copy of something defined elsewhere, so use\n             // `AvailableExternallyLinkage` to avoid duplicating code in the\n             // output.\n@@ -2723,12 +2724,15 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n                                              check_overflow,\n                                              check_dropflag);\n \n-    let codegen_units = tcx.sess.opts.cg.codegen_units;\n+    let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n+    let codegen_unit_count = codegen_units.len();\n+    assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n+            tcx.sess.opts.debugging_opts.incremental.is_some());\n+\n     let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n \n     {\n         let ccx = crate_context_list.get_ccx(0);\n-        collect_translation_items(&ccx);\n \n         // Translate all items. See `TransModVisitor` for\n         // details on why we walk in this particular way.\n@@ -2818,7 +2822,7 @@ pub fn trans_crate<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n     }\n \n-    if codegen_units > 1 {\n+    if codegen_unit_count > 1 {\n         internalize_symbols(&crate_context_list,\n                             &reachable_symbols.iter().map(|x| &x[..]).collect());\n     }\n@@ -2910,10 +2914,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n     }\n }\n \n-fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n-    let time_passes = ccx.sess().time_passes();\n+fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n+                                                     -> Vec<CodegenUnit<'tcx>> {\n+    let time_passes = scx.sess().time_passes();\n \n-    let collection_mode = match ccx.sess().opts.debugging_opts.print_trans_items {\n+    let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n         Some(ref s) => {\n             let mode_string = s.to_lowercase();\n             let mode_string = mode_string.trim();\n@@ -2924,7 +2929,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n                     let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n                                            Falling back to 'lazy' mode.\",\n                                            mode_string);\n-                    ccx.sess().warn(&message);\n+                    scx.sess().warn(&message);\n                 }\n \n                 TransItemCollectionMode::Lazy\n@@ -2934,27 +2939,27 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n     };\n \n     let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(ccx.shared(), collection_mode)\n+        collector::collect_crate_translation_items(scx, collection_mode)\n     });\n \n-    let strategy = if ccx.sess().opts.debugging_opts.incremental.is_some() {\n+    let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n-        PartitioningStrategy::FixedUnitCount(ccx.sess().opts.cg.codegen_units)\n+        PartitioningStrategy::FixedUnitCount(scx.sess().opts.cg.codegen_units)\n     };\n \n     let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n-        partitioning::partition(ccx.tcx(),\n+        partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n                                 &reference_map)\n     });\n \n-    if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n+    if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = HashMap::new();\n \n-        for cgu in codegen_units {\n-            for (trans_item, linkage) in cgu.items {\n+        for cgu in &codegen_units {\n+            for (&trans_item, &linkage) in &cgu.items {\n                 item_to_cgus.entry(trans_item)\n                             .or_insert(Vec::new())\n                             .push((cgu.name.clone(), linkage));\n@@ -2964,7 +2969,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         let mut item_keys: Vec<_> = items\n             .iter()\n             .map(|i| {\n-                let mut output = i.to_string(ccx.tcx());\n+                let mut output = i.to_string(scx.tcx());\n                 output.push_str(\" @@\");\n                 let mut empty = Vec::new();\n                 let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n@@ -3003,10 +3008,12 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n             println!(\"TRANS_ITEM {}\", item);\n         }\n \n-        let mut ccx_map = ccx.translation_items().borrow_mut();\n+        let mut ccx_map = scx.translation_items().borrow_mut();\n \n         for cgi in items {\n             ccx_map.insert(cgi, TransItemState::PredictedButNotGenerated);\n         }\n     }\n+\n+    codegen_units\n }"}, {"sha": "9f5fe28ee8218b0e031887415a621e482a0013b5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=bebcb285ad187153a71296c42a02e4bb9c2297f5", "patch": "@@ -28,6 +28,7 @@ use mir::CachedMir;\n use monomorphize::Instance;\n \n use collector::{TransItem, TransItemState};\n+use partitioning::CodegenUnit;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -196,11 +197,12 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n \n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n-               local_count: usize)\n+               codegen_units: Vec<CodegenUnit<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n-            local_ccxs: (0..local_count).map(|index| {\n+            // FIXME: We don't actually use the codegen unit partitioning yet.\n+            local_ccxs: codegen_units.iter().map(|cgu| {\n                 // Append \".rs\" to crate name as LLVM module identifier.\n                 //\n                 // LLVM code generator emits a \".file filename\" directive\n@@ -209,7 +211,7 @@ impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n                 // crashes if the module identifier is same as other symbols\n                 // such as a function name in the module.\n                 // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-                let llmod_id = format!(\"{}.{}.rs\", shared_ccx.link_meta.crate_name, index);\n+                let llmod_id = format!(\"{}.rs\", cgu.name);\n                 LocalCrateContext::new(shared_ccx, &llmod_id[..])\n             }).collect()\n         }"}, {"sha": "6e50292a91a580d482942035678b78b0668e1905", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bebcb285ad187153a71296c42a02e4bb9c2297f5/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=bebcb285ad187153a71296c42a02e4bb9c2297f5", "patch": "@@ -182,7 +182,19 @@ pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n     // easily determine which declarations need to be placed within each one.\n     let post_declarations = place_declarations(post_inlining, reference_map);\n \n-    post_declarations.0\n+    let mut final_partitioning = post_declarations.0;\n+\n+    if final_partitioning.len() == 0 {\n+        // Some crates don't contain anything that will result in a translation\n+        // item. We still want to have at least one (empty) codegen unit in that\n+        // case.\n+        final_partitioning.push(CodegenUnit {\n+            name: token::intern_and_get_ident(&format!(\"{}.0\", tcx.crate_name)[..]),\n+            items: FnvHashMap()\n+        });\n+    }\n+\n+    final_partitioning\n }\n \n struct PreInliningPartitioning<'tcx> {"}]}