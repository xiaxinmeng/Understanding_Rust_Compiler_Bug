{"sha": "b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "node_id": "C_kwDOAAsO6NoAKGI0MjI0NGMyYWI0NjJhNWFjNGM5MDFlODk4OGY5ZmNiNzg3NzZkOWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T08:00:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-08T08:00:57Z"}, "message": "Auto merge of #101560 - Dylan-DPC:rollup-8m8yr89, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #101153 (Migrate another part of rustc_infer to session diagnostic)\n - #101399 (Shrink span for bindings with subpatterns.)\n - #101422 (Hermit: Add File::set_time stub)\n - #101455 (Avoid UB in the Windows filesystem code in... bootstrap?)\n - #101498 (rustc: Parameterize `ty::Visibility` over used ID)\n - #101549 (Use HashStable_Generic in rustc_type_ir)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f017d4d18075c776a6c1a4a5b33b157621703145", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f017d4d18075c776a6c1a4a5b33b157621703145"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "html_url": "https://github.com/rust-lang/rust/commit/b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44adfccffe34d14079b06ae459982b8600f84577", "url": "https://api.github.com/repos/rust-lang/rust/commits/44adfccffe34d14079b06ae459982b8600f84577", "html_url": "https://github.com/rust-lang/rust/commit/44adfccffe34d14079b06ae459982b8600f84577"}, {"sha": "7f46d7313c5c17571f8d44b020fe83869e676ed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f46d7313c5c17571f8d44b020fe83869e676ed7", "html_url": "https://github.com/rust-lang/rust/commit/7f46d7313c5c17571f8d44b020fe83869e676ed7"}], "stats": {"total": 2007, "additions": 1200, "deletions": 807}, "files": [{"sha": "90bcc2e4be42a2d55449c7c41aa6596c3676a61e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -3958,6 +3958,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_type_ir\",\n  \"smallvec\",\n  \"thin-vec\",\n  \"tracing\","}, {"sha": "2899b8304bc14884338564a480a2ffc54cdaec05", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -104,9 +104,67 @@ infer_relate_object_bound = ...so that it can be closed over into an object\n infer_data_borrowed = ...so that the type `{$name}` is not borrowed for too long\n infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-[true] ...\n-*[false] {\"\"}\n+    [true] ...\n+    *[false] {\"\"}\n }\n infer_relate_param_bound_2 = ...that is required by this bound\n infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+\n+infer_nothing = {\"\"}\n+\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] -> {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] -> {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [reempty] the empty lifetime\n+    [reemptyuni] the empty lifetime in universe {$desc_arg}\n+    [revar] lifetime {$desc_arg}\n+\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [anon_num_here] the anonymous lifetime #{$desc_num_arg} defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+}\n+\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n+infer_msl_impl_note = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement"}, {"sha": "938f8aa77a5b4589f6e5eb2f5ed5956fce22ee8b", "filename": "compiler/rustc_infer/src/errors.rs", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/44adfccffe34d14079b06ae459982b8600f84577/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44adfccffe34d14079b06ae459982b8600f84577/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors.rs?ref=44adfccffe34d14079b06ae459982b8600f84577", "patch": "@@ -1,254 +0,0 @@\n-use rustc_errors::{fluent, AddSubdiagnostic, DiagnosticMessage, DiagnosticStyledString};\n-use rustc_hir::FnRetTy;\n-use rustc_macros::SessionDiagnostic;\n-use rustc_span::{BytePos, Span};\n-\n-use crate::infer::error_reporting::{\n-    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n-    ObligationCauseAsDiagArg,\n-};\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::opaque_hidden_type)]\n-pub struct OpaqueHiddenTypeDiag {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[note(infer::opaque_type)]\n-    pub opaque_type: Span,\n-    #[note(infer::hidden_type)]\n-    pub hidden_type: Span,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0282\")]\n-pub struct AnnotationRequired<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0283\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0283\")]\n-pub struct AmbigousImpl<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-// Copy of `AnnotationRequired` for E0284\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0284\")]\n-pub struct AmbigousReturn<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub source_kind: &'static str,\n-    pub source_name: &'a str,\n-    #[label]\n-    pub failure_span: Option<Span>,\n-    #[subdiagnostic]\n-    pub bad_label: Option<InferenceBadError<'a>>,\n-    #[subdiagnostic]\n-    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n-    #[subdiagnostic]\n-    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n-}\n-\n-#[derive(SessionDiagnostic)]\n-#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n-pub struct NeedTypeInfoInGenerator<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub generator_kind: GeneratorKindAsDiagArg,\n-    #[subdiagnostic]\n-    pub bad_label: InferenceBadError<'a>,\n-}\n-\n-// Used when a better one isn't available\n-#[derive(SessionSubdiagnostic)]\n-#[label(infer::label_bad)]\n-pub struct InferenceBadError<'a> {\n-    #[primary_span]\n-    pub span: Span,\n-    pub bad_kind: &'static str,\n-    pub prefix_kind: UnderspecifiedArgKind,\n-    pub has_parent: bool,\n-    pub prefix: &'a str,\n-    pub parent_prefix: &'a str,\n-    pub parent_name: String,\n-    pub name: String,\n-}\n-\n-#[derive(SessionSubdiagnostic)]\n-pub enum SourceKindSubdiag<'a> {\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_let,\n-        code = \": {type_name}\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    LetLike {\n-        #[primary_span]\n-        span: Span,\n-        name: String,\n-        type_name: String,\n-        kind: &'static str,\n-        x_kind: &'static str,\n-        prefix_kind: UnderspecifiedArgKind,\n-        prefix: &'a str,\n-        arg_name: String,\n-    },\n-    #[label(infer::source_kind_subdiag_generic_label)]\n-    GenericLabel {\n-        #[primary_span]\n-        span: Span,\n-        is_type: bool,\n-        param_name: String,\n-        parent_exists: bool,\n-        parent_prefix: String,\n-        parent_name: String,\n-    },\n-    #[suggestion_verbose(\n-        infer::source_kind_subdiag_generic_suggestion,\n-        code = \"::<{args}>\",\n-        applicability = \"has-placeholders\"\n-    )]\n-    GenericSuggestion {\n-        #[primary_span]\n-        span: Span,\n-        arg_count: usize,\n-        args: String,\n-    },\n-}\n-\n-// Has to be implemented manually because multipart suggestions are not supported by the derive macro.\n-// Would be a part of `SourceKindSubdiag` otherwise.\n-pub enum SourceKindMultiSuggestion<'a> {\n-    FullyQualified {\n-        span: Span,\n-        def_path: String,\n-        adjustment: &'a str,\n-        successor: (&'a str, BytePos),\n-    },\n-    ClosureReturn {\n-        ty_info: String,\n-        data: &'a FnRetTy<'a>,\n-        should_wrap_expr: Option<Span>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for SourceKindMultiSuggestion<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        match self {\n-            Self::FullyQualified { span, def_path, adjustment, successor } => {\n-                let suggestion = vec![\n-                    (span.shrink_to_lo(), format!(\"{def_path}({adjustment}\")),\n-                    (span.shrink_to_hi().with_hi(successor.1), successor.0.to_string()),\n-                ];\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_fully_qualified,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-            Self::ClosureReturn { ty_info, data, should_wrap_expr } => {\n-                let (arrow, post) = match data {\n-                    FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                    _ => (\"\", \"\"),\n-                };\n-                let suggestion = match should_wrap_expr {\n-                    Some(end_span) => vec![\n-                        (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post)),\n-                        (end_span, \" }\".to_string()),\n-                    ],\n-                    None => vec![(data.span(), format!(\"{}{}{}\", arrow, ty_info, post))],\n-                };\n-                diag.multipart_suggestion_verbose(\n-                    fluent::infer::source_kind_closure_return,\n-                    suggestion,\n-                    rustc_errors::Applicability::HasPlaceholders,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-pub enum RegionOriginNote<'a> {\n-    Plain {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    },\n-    WithName {\n-        span: Span,\n-        msg: DiagnosticMessage,\n-        name: &'a str,\n-        continues: bool,\n-    },\n-    WithRequirement {\n-        span: Span,\n-        requirement: ObligationCauseAsDiagArg<'a>,\n-        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n-    },\n-}\n-\n-impl AddSubdiagnostic for RegionOriginNote<'_> {\n-    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n-        let mut label_or_note = |span, msg: DiagnosticMessage| {\n-            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n-            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n-            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n-            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n-                diag.span_label(span, msg);\n-            } else if span_is_primary && expanded_sub_count == 0 {\n-                diag.note(msg);\n-            } else {\n-                diag.span_note(span, msg);\n-            }\n-        };\n-        match self {\n-            RegionOriginNote::Plain { span, msg } => {\n-                label_or_note(span, msg);\n-            }\n-            RegionOriginNote::WithName { span, msg, name, continues } => {\n-                label_or_note(span, msg);\n-                diag.set_arg(\"name\", name);\n-                diag.set_arg(\"continues\", continues);\n-            }\n-            RegionOriginNote::WithRequirement {\n-                span,\n-                requirement,\n-                expected_found: Some((expected, found)),\n-            } => {\n-                label_or_note(span, fluent::infer::subtype);\n-                diag.set_arg(\"requirement\", requirement);\n-\n-                diag.note_expected_found(&\"\", expected, &\"\", found);\n-            }\n-            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n-                // FIXME: this really should be handled at some earlier stage. Our\n-                // handling of region checking when type errors are present is\n-                // *terrible*.\n-                label_or_note(span, fluent::infer::subtype_2);\n-                diag.set_arg(\"requirement\", requirement);\n-            }\n-        };\n-    }\n-}"}, {"sha": "d232a186462444ada7ab0accb711002623226c5c", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -0,0 +1,499 @@\n+use hir::GenericParamKind;\n+use rustc_errors::{\n+    fluent, AddSubdiagnostic, Applicability, DiagnosticMessage, DiagnosticStyledString, MultiSpan,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::{FnRetTy, Ty};\n+use rustc_macros::SessionDiagnostic;\n+use rustc_middle::ty::{Region, TyCtxt};\n+use rustc_span::symbol::kw;\n+use rustc_span::{symbol::Ident, BytePos, Span};\n+\n+use crate::infer::error_reporting::{\n+    need_type_info::{GeneratorKindAsDiagArg, UnderspecifiedArgKind},\n+    ObligationCauseAsDiagArg,\n+};\n+\n+pub mod note_and_explain;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::opaque_hidden_type)]\n+pub struct OpaqueHiddenTypeDiag {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note(infer::opaque_type)]\n+    pub opaque_type: Span,\n+    #[note(infer::hidden_type)]\n+    pub hidden_type: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+pub struct AnnotationRequired<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0283\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+pub struct AmbigousImpl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+// Copy of `AnnotationRequired` for E0284\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+pub struct AmbigousReturn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub source_kind: &'static str,\n+    pub source_name: &'a str,\n+    #[label]\n+    pub failure_span: Option<Span>,\n+    #[subdiagnostic]\n+    pub bad_label: Option<InferenceBadError<'a>>,\n+    #[subdiagnostic]\n+    pub infer_subdiags: Vec<SourceKindSubdiag<'a>>,\n+    #[subdiagnostic]\n+    pub multi_suggestions: Vec<SourceKindMultiSuggestion<'a>>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+pub struct NeedTypeInfoInGenerator<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub generator_kind: GeneratorKindAsDiagArg,\n+    #[subdiagnostic]\n+    pub bad_label: InferenceBadError<'a>,\n+}\n+\n+// Used when a better one isn't available\n+#[derive(SessionSubdiagnostic)]\n+#[label(infer::label_bad)]\n+pub struct InferenceBadError<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub bad_kind: &'static str,\n+    pub prefix_kind: UnderspecifiedArgKind,\n+    pub has_parent: bool,\n+    pub prefix: &'a str,\n+    pub parent_prefix: &'a str,\n+    pub parent_name: String,\n+    pub name: String,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindSubdiag<'a> {\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_let,\n+        code = \": {type_name}\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    LetLike {\n+        #[primary_span]\n+        span: Span,\n+        name: String,\n+        type_name: String,\n+        kind: &'static str,\n+        x_kind: &'static str,\n+        prefix_kind: UnderspecifiedArgKind,\n+        prefix: &'a str,\n+        arg_name: String,\n+    },\n+    #[label(infer::source_kind_subdiag_generic_label)]\n+    GenericLabel {\n+        #[primary_span]\n+        span: Span,\n+        is_type: bool,\n+        param_name: String,\n+        parent_exists: bool,\n+        parent_prefix: String,\n+        parent_name: String,\n+    },\n+    #[suggestion_verbose(\n+        infer::source_kind_subdiag_generic_suggestion,\n+        code = \"::<{args}>\",\n+        applicability = \"has-placeholders\"\n+    )]\n+    GenericSuggestion {\n+        #[primary_span]\n+        span: Span,\n+        arg_count: usize,\n+        args: String,\n+    },\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum SourceKindMultiSuggestion<'a> {\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_fully_qualified,\n+        applicability = \"has-placeholders\"\n+    )]\n+    FullyQualified {\n+        #[suggestion_part(code = \"{def_path}({adjustment}\")]\n+        span_lo: Span,\n+        #[suggestion_part(code = \"{successor_pos}\")]\n+        span_hi: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor_pos: &'a str,\n+    },\n+    #[multipart_suggestion_verbose(\n+        infer::source_kind_closure_return,\n+        applicability = \"has-placeholders\"\n+    )]\n+    ClosureReturn {\n+        #[suggestion_part(code = \"{start_span_code}\")]\n+        start_span: Span,\n+        start_span_code: String,\n+        #[suggestion_part(code = \" }}\")]\n+        end_span: Option<Span>,\n+    },\n+}\n+\n+impl<'a> SourceKindMultiSuggestion<'a> {\n+    pub fn new_fully_qualified(\n+        span: Span,\n+        def_path: String,\n+        adjustment: &'a str,\n+        successor: (&'a str, BytePos),\n+    ) -> Self {\n+        Self::FullyQualified {\n+            span_lo: span.shrink_to_lo(),\n+            span_hi: span.shrink_to_hi().with_hi(successor.1),\n+            def_path,\n+            adjustment,\n+            successor_pos: successor.0,\n+        }\n+    }\n+\n+    pub fn new_closure_return(\n+        ty_info: String,\n+        data: &'a FnRetTy<'a>,\n+        should_wrap_expr: Option<Span>,\n+    ) -> Self {\n+        let (arrow, post) = match data {\n+            FnRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+            _ => (\"\", \"\"),\n+        };\n+        let (start_span, start_span_code, end_span) = match should_wrap_expr {\n+            Some(end_span) => {\n+                (data.span(), format!(\"{}{}{}{{ \", arrow, ty_info, post), Some(end_span))\n+            }\n+            None => (data.span(), format!(\"{}{}{}\", arrow, ty_info, post), None),\n+        };\n+        Self::ClosureReturn { start_span, start_span_code, end_span }\n+    }\n+}\n+\n+pub enum RegionOriginNote<'a> {\n+    Plain {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+    },\n+    WithName {\n+        span: Span,\n+        msg: DiagnosticMessage,\n+        name: &'a str,\n+        continues: bool,\n+    },\n+    WithRequirement {\n+        span: Span,\n+        requirement: ObligationCauseAsDiagArg<'a>,\n+        expected_found: Option<(DiagnosticStyledString, DiagnosticStyledString)>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for RegionOriginNote<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut label_or_note = |span, msg: DiagnosticMessage| {\n+            let sub_count = diag.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = diag.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = diag.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                diag.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                diag.note(msg);\n+            } else {\n+                diag.span_note(span, msg);\n+            }\n+        };\n+        match self {\n+            RegionOriginNote::Plain { span, msg } => {\n+                label_or_note(span, msg);\n+            }\n+            RegionOriginNote::WithName { span, msg, name, continues } => {\n+                label_or_note(span, msg);\n+                diag.set_arg(\"name\", name);\n+                diag.set_arg(\"continues\", continues);\n+            }\n+            RegionOriginNote::WithRequirement {\n+                span,\n+                requirement,\n+                expected_found: Some((expected, found)),\n+            } => {\n+                label_or_note(span, fluent::infer::subtype);\n+                diag.set_arg(\"requirement\", requirement);\n+\n+                diag.note_expected_found(&\"\", expected, &\"\", found);\n+            }\n+            RegionOriginNote::WithRequirement { span, requirement, expected_found: None } => {\n+                // FIXME: this really should be handled at some earlier stage. Our\n+                // handling of region checking when type errors are present is\n+                // *terrible*.\n+                label_or_note(span, fluent::infer::subtype_2);\n+                diag.set_arg(\"requirement\", requirement);\n+            }\n+        };\n+    }\n+}\n+\n+pub enum LifetimeMismatchLabels {\n+    InRet {\n+        param_span: Span,\n+        ret_span: Span,\n+        span: Span,\n+        label_var1: Option<Ident>,\n+    },\n+    Normal {\n+        hir_equal: bool,\n+        ty_sup: Span,\n+        ty_sub: Span,\n+        span: Span,\n+        sup: Option<Ident>,\n+        sub: Option<Ident>,\n+    },\n+}\n+\n+impl AddSubdiagnostic for LifetimeMismatchLabels {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n+                diag.span_label(param_span, fluent::infer::declared_different);\n+                diag.span_label(ret_span, fluent::infer::nothing);\n+                diag.span_label(span, fluent::infer::data_returned);\n+                diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n+            }\n+            LifetimeMismatchLabels::Normal {\n+                hir_equal,\n+                ty_sup,\n+                ty_sub,\n+                span,\n+                sup: label_var1,\n+                sub: label_var2,\n+            } => {\n+                if hir_equal {\n+                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                } else {\n+                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer::nothing);\n+                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n+                    diag.set_arg(\n+                        \"label_var1\",\n+                        label_var1.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                    diag.set_arg(\"label_var2_exists\", label_var2.is_some());\n+                    diag.set_arg(\n+                        \"label_var2\",\n+                        label_var2.map(|x| x.to_string()).unwrap_or_default(),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct AddLifetimeParamsSuggestion<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub sub: Region<'a>,\n+    pub ty_sup: &'a Ty<'a>,\n+    pub ty_sub: &'a Ty<'a>,\n+    pub add_note: bool,\n+}\n+\n+impl AddSubdiagnostic for AddLifetimeParamsSuggestion<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        let mut mk_suggestion = || {\n+            let (\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n+                hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n+            ) = (self.ty_sub, self.ty_sup) else {\n+                return false;\n+            };\n+\n+            if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n+                return false;\n+            };\n+\n+            let Some(anon_reg) = self.tcx.is_suitable_region(self.sub) else {\n+                return false;\n+            };\n+\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n+\n+            let node = self.tcx.hir().get(hir_id);\n+            let is_impl = matches!(&node, hir::Node::ImplItem(_));\n+            let generics = match node {\n+                hir::Node::Item(&hir::Item {\n+                    kind: hir::ItemKind::Fn(_, ref generics, ..),\n+                    ..\n+                })\n+                | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n+                | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n+                _ => return false,\n+            };\n+\n+            let suggestion_param_name = generics\n+                .params\n+                .iter()\n+                .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n+                .map(|p| p.name.ident().name)\n+                .find(|i| *i != kw::UnderscoreLifetime);\n+            let introduce_new = suggestion_param_name.is_none();\n+            let suggestion_param_name =\n+                suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n+\n+            debug!(?lifetime_sup.span);\n+            debug!(?lifetime_sub.span);\n+            let make_suggestion = |span: rustc_span::Span| {\n+                if span.is_empty() {\n+                    (span, format!(\"{}, \", suggestion_param_name))\n+                } else if let Ok(\"&\") = self.tcx.sess.source_map().span_to_snippet(span).as_deref()\n+                {\n+                    (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n+                } else {\n+                    (span, suggestion_param_name.clone())\n+                }\n+            };\n+            let mut suggestions =\n+                vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n+\n+            if introduce_new {\n+                let new_param_suggestion = if let Some(first) =\n+                    generics.params.iter().find(|p| !p.name.ident().span.is_empty())\n+                {\n+                    (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n+                } else {\n+                    (generics.span, format!(\"<{}>\", suggestion_param_name))\n+                };\n+\n+                suggestions.push(new_param_suggestion);\n+            }\n+\n+            diag.multipart_suggestion(\n+                fluent::infer::lifetime_param_suggestion,\n+                suggestions,\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.set_arg(\"is_impl\", is_impl);\n+            true\n+        };\n+        if mk_suggestion() && self.add_note {\n+            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+pub struct LifetimeMismatch<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub labels: LifetimeMismatchLabels,\n+    #[subdiagnostic]\n+    pub suggestion: AddLifetimeParamsSuggestion<'a>,\n+}\n+\n+pub struct IntroducesStaticBecauseUnmetLifetimeReq {\n+    pub unmet_requirements: MultiSpan,\n+    pub binding_span: Span,\n+}\n+\n+impl AddSubdiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n+    fn add_to_diagnostic(mut self, diag: &mut rustc_errors::Diagnostic) {\n+        self.unmet_requirements\n+            .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n+        diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n+    }\n+}\n+\n+pub struct ImplNote {\n+    pub impl_span: Option<Span>,\n+}\n+\n+impl AddSubdiagnostic for ImplNote {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self.impl_span {\n+            Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n+            None => diag.note(fluent::infer::msl_impl_note),\n+        };\n+    }\n+}\n+\n+pub enum TraitSubdiag {\n+    Note { span: Span },\n+    Sugg { span: Span },\n+}\n+\n+// FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n+impl AddSubdiagnostic for TraitSubdiag {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        match self {\n+            TraitSubdiag::Note { span } => {\n+                diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");\n+            }\n+            TraitSubdiag::Sugg { span } => {\n+                diag.span_suggestion_verbose(\n+                    span,\n+                    \"consider relaxing the implicit `'static` requirement\",\n+                    \" + '_\".to_owned(),\n+                    rustc_errors::Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(infer::mismatched_static_lifetime)]\n+pub struct MismatchedStaticLifetime<'a> {\n+    #[primary_span]\n+    pub cause_span: Span,\n+    #[subdiagnostic]\n+    pub unmet_lifetime_reqs: IntroducesStaticBecauseUnmetLifetimeReq,\n+    #[subdiagnostic]\n+    pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n+    #[subdiagnostic]\n+    pub impl_note: ImplNote,\n+    #[subdiagnostic]\n+    pub trait_subdiags: Vec<TraitSubdiag>,\n+}"}, {"sha": "6f1f9522c869da5a472f7f895f735fe099b26f04", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -0,0 +1,179 @@\n+use crate::infer::error_reporting::nice_region_error::find_anon_type;\n+use rustc_errors::{self, fluent, AddSubdiagnostic, IntoDiagnosticArg};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::{symbol::kw, Span};\n+\n+#[derive(Default)]\n+struct DescriptionCtx<'a> {\n+    span: Option<Span>,\n+    kind: &'a str,\n+    arg: String,\n+    num_arg: u32,\n+}\n+\n+impl<'a> DescriptionCtx<'a> {\n+    fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        me.span = alt_span;\n+        match *region {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                return Self::from_early_bound_and_free_regions(tcx, region);\n+            }\n+            ty::ReStatic => {\n+                me.kind = \"restatic\";\n+            }\n+\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => me.kind = \"reempty\",\n+\n+            ty::ReEmpty(ui) => {\n+                me.kind = \"reemptyuni\";\n+                me.arg = format!(\"{:?}\", ui);\n+            }\n+\n+            ty::RePlaceholder(_) => return None,\n+\n+            // FIXME(#13998) RePlaceholder should probably print like\n+            // ReFree rather than dumping Debug output on the user.\n+            //\n+            // We shouldn't really be having unification failures with ReVar\n+            // and ReLateBound though.\n+            ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n+                me.kind = \"revar\";\n+                me.arg = format!(\"{:?}\", region);\n+            }\n+        };\n+        Some(me)\n+    }\n+\n+    fn from_early_bound_and_free_regions<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+    ) -> Option<Self> {\n+        let mut me = DescriptionCtx::default();\n+        let scope = region.free_region_binding_scope(tcx).expect_local();\n+        match *region {\n+            ty::ReEarlyBound(ref br) => {\n+                let mut sp = tcx.def_span(scope);\n+                if let Some(param) =\n+                    tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n+                {\n+                    sp = param.span;\n+                }\n+                if br.has_name() {\n+                    me.kind = \"as_defined\";\n+                    me.arg = br.name.to_string();\n+                } else {\n+                    me.kind = \"as_defined_anon\";\n+                };\n+                me.span = Some(sp)\n+            }\n+            ty::ReFree(ref fr) => {\n+                if !fr.bound_region.is_named()\n+                    && let Some((ty, _)) = find_anon_type(tcx, region, &fr.bound_region)\n+                {\n+                    me.kind = \"defined_here\";\n+                    me.span = Some(ty.span);\n+                } else {\n+                    match fr.bound_region {\n+                        ty::BoundRegionKind::BrNamed(_, name) => {\n+                            let mut sp = tcx.def_span(scope);\n+                            if let Some(param) =\n+                                tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n+                            {\n+                                sp = param.span;\n+                            }\n+                            if name == kw::UnderscoreLifetime {\n+                                me.kind = \"as_defined_anon\";\n+                            } else {\n+                                me.kind = \"as_defined\";\n+                                me.arg = name.to_string();\n+                            };\n+                            me.span = Some(sp);\n+                        }\n+                        ty::BrAnon(idx) => {\n+                            me.kind = \"anon_num_here\";\n+                            me.num_arg = idx+1;\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                        _ => {\n+                            me.kind = \"defined_here_reg\";\n+                            me.arg = region.to_string();\n+                            me.span = Some(tcx.def_span(scope));\n+                        },\n+                    }\n+                }\n+            }\n+            _ => bug!(),\n+        }\n+        Some(me)\n+    }\n+\n+    fn add_to(self, diag: &mut rustc_errors::Diagnostic) {\n+        diag.set_arg(\"desc_kind\", self.kind);\n+        diag.set_arg(\"desc_arg\", self.arg);\n+        diag.set_arg(\"desc_num_arg\", self.num_arg);\n+    }\n+}\n+\n+pub enum PrefixKind {\n+    Empty,\n+}\n+\n+pub enum SuffixKind {\n+    Continues,\n+}\n+\n+impl IntoDiagnosticArg for PrefixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Empty => \"empty\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for SuffixKind {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        let kind = match self {\n+            Self::Continues => \"continues\",\n+        }\n+        .into();\n+        rustc_errors::DiagnosticArgValue::Str(kind)\n+    }\n+}\n+\n+pub struct RegionExplanation<'a> {\n+    desc: DescriptionCtx<'a>,\n+    prefix: PrefixKind,\n+    suffix: SuffixKind,\n+}\n+\n+impl RegionExplanation<'_> {\n+    pub fn new<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        region: ty::Region<'tcx>,\n+        alt_span: Option<Span>,\n+        prefix: PrefixKind,\n+        suffix: SuffixKind,\n+    ) -> Option<Self> {\n+        Some(Self { desc: DescriptionCtx::new(tcx, region, alt_span)?, prefix, suffix })\n+    }\n+}\n+\n+impl AddSubdiagnostic for RegionExplanation<'_> {\n+    fn add_to_diagnostic(self, diag: &mut rustc_errors::Diagnostic) {\n+        if let Some(span) = self.desc.span {\n+            diag.span_note(span, fluent::infer::region_explanation);\n+        } else {\n+            diag.note(fluent::infer::region_explanation);\n+        }\n+        self.desc.add_to(diag);\n+        diag.set_arg(\"pref_kind\", self.prefix);\n+        diag.set_arg(\"suff_kind\", self.suffix);\n+    }\n+}"}, {"sha": "cb2be93589d051b13da021d5a363b9416dd577c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -511,20 +511,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     _ => \"\",\n                 };\n \n-                multi_suggestions.push(SourceKindMultiSuggestion::FullyQualified {\n-                    span: receiver.span,\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_fully_qualified(\n+                    receiver.span,\n                     def_path,\n                     adjustment,\n                     successor,\n-                });\n+                ));\n             }\n             InferSourceKind::ClosureReturn { ty, data, should_wrap_expr } => {\n                 let ty_info = ty_to_string(self, ty);\n-                multi_suggestions.push(SourceKindMultiSuggestion::ClosureReturn {\n+                multi_suggestions.push(SourceKindMultiSuggestion::new_closure_return(\n                     ty_info,\n                     data,\n                     should_wrap_expr,\n-                });\n+                ));\n             }\n         }\n         match error_code {"}, {"sha": "3a4320a9a8f1d23f3d8874cf5fc8ba5d36e34303", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 31, "deletions": 116, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1,18 +1,20 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where both the regions are anonymous.\n \n+use crate::errors::AddLifetimeParamsSuggestion;\n+use crate::errors::LifetimeMismatch;\n+use crate::errors::LifetimeMismatchLabels;\n use crate::infer::error_reporting::nice_region_error::find_anon_type::find_anon_type;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::SubregionOrigin;\n use crate::infer::TyCtxt;\n \n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n-use rustc_hir as hir;\n-use rustc_hir::{GenericParamKind, Ty};\n+use rustc_errors::AddSubdiagnostic;\n+use rustc_errors::{Diagnostic, ErrorGuaranteed};\n+use rustc_hir::Ty;\n use rustc_middle::ty::Region;\n-use rustc_span::symbol::kw;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n@@ -98,137 +100,50 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n-        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n-            Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n-            None => String::new(),\n-        };\n-\n         debug!(\n             \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n             sub_is_ret_type, sup_is_ret_type\n         );\n \n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        match (sup_is_ret_type, sub_is_ret_type) {\n+        let labels = match (sup_is_ret_type, sub_is_ret_type) {\n             (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n                 let param_span =\n                     if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n-\n-                err.span_label(\n+                LifetimeMismatchLabels::InRet {\n                     param_span,\n-                    \"this parameter and the return type are declared with different lifetimes...\",\n-                );\n-                err.span_label(ret_span, \"\");\n-                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n-            }\n-\n-            (None, None) => {\n-                if ty_sup.hir_id == ty_sub.hir_id {\n-                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n-                } else {\n-                    err.span_label(\n-                        ty_sup.span,\n-                        \"these two types are declared with different lifetimes...\",\n-                    );\n-                    err.span_label(ty_sub.span, \"\");\n-                    err.span_label(\n-                        span,\n-                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                    );\n+                    ret_span,\n+                    span,\n+                    label_var1: anon_param_sup.pat.simple_ident(),\n                 }\n             }\n-        }\n \n-        if suggest_adding_lifetime_params(self.tcx(), sub, ty_sup, ty_sub, &mut err) {\n-            err.note(\"each elided lifetime in input position becomes a distinct lifetime\");\n-        }\n+            (None, None) => LifetimeMismatchLabels::Normal {\n+                hir_equal: ty_sup.hir_id == ty_sub.hir_id,\n+                ty_sup: ty_sup.span,\n+                ty_sub: ty_sub.span,\n+                span,\n+                sup: anon_param_sup.pat.simple_ident(),\n+                sub: anon_param_sub.pat.simple_ident(),\n+            },\n+        };\n \n-        let reported = err.emit();\n+        let suggestion =\n+            AddLifetimeParamsSuggestion { tcx: self.tcx(), sub, ty_sup, ty_sub, add_note: true };\n+        let err = LifetimeMismatch { span, labels, suggestion };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }\n \n+/// Currently only used in rustc_borrowck, probably should be\n+/// removed in favour of public_errors::AddLifetimeParamsSuggestion\n pub fn suggest_adding_lifetime_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sub: Region<'tcx>,\n-    ty_sup: &Ty<'_>,\n-    ty_sub: &Ty<'_>,\n+    ty_sup: &'tcx Ty<'_>,\n+    ty_sub: &'tcx Ty<'_>,\n     err: &mut Diagnostic,\n-) -> bool {\n-    let (\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sub, _), .. },\n-        hir::Ty { kind: hir::TyKind::Rptr(lifetime_sup, _), .. },\n-    ) = (ty_sub, ty_sup) else {\n-        return false;\n-    };\n-\n-    if !lifetime_sub.name.is_anonymous() || !lifetime_sup.name.is_anonymous() {\n-        return false;\n-    };\n-\n-    let Some(anon_reg) = tcx.is_suitable_region(sub) else {\n-        return false;\n-    };\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-\n-    let node = tcx.hir().get(hir_id);\n-    let is_impl = matches!(&node, hir::Node::ImplItem(_));\n-    let generics = match node {\n-        hir::Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, ref generics, ..), .. })\n-        | hir::Node::TraitItem(&hir::TraitItem { ref generics, .. })\n-        | hir::Node::ImplItem(&hir::ImplItem { ref generics, .. }) => generics,\n-        _ => return false,\n-    };\n-\n-    let suggestion_param_name = generics\n-        .params\n-        .iter()\n-        .filter(|p| matches!(p.kind, GenericParamKind::Lifetime { .. }))\n-        .map(|p| p.name.ident().name)\n-        .find(|i| *i != kw::UnderscoreLifetime);\n-    let introduce_new = suggestion_param_name.is_none();\n-    let suggestion_param_name =\n-        suggestion_param_name.map(|n| n.to_string()).unwrap_or_else(|| \"'a\".to_owned());\n-\n-    debug!(?lifetime_sup.span);\n-    debug!(?lifetime_sub.span);\n-    let make_suggestion = |span: rustc_span::Span| {\n-        if span.is_empty() {\n-            (span, format!(\"{}, \", suggestion_param_name))\n-        } else if let Ok(\"&\") = tcx.sess.source_map().span_to_snippet(span).as_deref() {\n-            (span.shrink_to_hi(), format!(\"{} \", suggestion_param_name))\n-        } else {\n-            (span, suggestion_param_name.clone())\n-        }\n-    };\n-    let mut suggestions =\n-        vec![make_suggestion(lifetime_sub.span), make_suggestion(lifetime_sup.span)];\n-\n-    if introduce_new {\n-        let new_param_suggestion =\n-            if let Some(first) = generics.params.iter().find(|p| !p.name.ident().span.is_empty()) {\n-                (first.span.shrink_to_lo(), format!(\"{}, \", suggestion_param_name))\n-            } else {\n-                (generics.span, format!(\"<{}>\", suggestion_param_name))\n-            };\n-\n-        suggestions.push(new_param_suggestion);\n-    }\n-\n-    let mut sugg = String::from(\"consider introducing a named lifetime parameter\");\n-    if is_impl {\n-        sugg.push_str(\" and update trait if needed\");\n-    }\n-    err.multipart_suggestion(sugg, suggestions, Applicability::MaybeIncorrect);\n-\n-    true\n+) {\n+    let suggestion = AddLifetimeParamsSuggestion { tcx, sub, ty_sup, ty_sub, add_note: false };\n+    suggestion.add_to_diagnostic(err);\n }"}, {"sha": "1410e2b63b0b87fbfa433ba727a410780b1354de", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1,13 +1,14 @@\n //! Error Reporting for when the lifetime for a type doesn't match the `impl` selected for a predicate\n //! to hold.\n \n+use crate::errors::{note_and_explain, IntroducesStaticBecauseUnmetLifetimeReq};\n+use crate::errors::{ImplNote, MismatchedStaticLifetime, TraitSubdiag};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::note_and_explain_region;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n use rustc_middle::ty::TypeVisitor;\n@@ -39,12 +40,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             = *parent.code() else {\n             return None;\n         };\n-        let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n+\n         // FIXME: we should point at the lifetime\n-        let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n-        err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n-        note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n+        let multi_span: MultiSpan = vec![binding_span].into();\n+        let multispan_subdiag = IntroducesStaticBecauseUnmetLifetimeReq {\n+            unmet_requirements: multi_span,\n+            binding_span,\n+        };\n+\n+        let expl = note_and_explain::RegionExplanation::new(\n+            self.tcx(),\n+            sup,\n+            Some(binding_span),\n+            note_and_explain::PrefixKind::Empty,\n+            note_and_explain::SuffixKind::Continues,\n+        );\n+        let mut impl_span = None;\n+        let mut trait_subdiags = Vec::new();\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n             // If an impl is local, then maybe this isn't what they want. Try to\n             // be as helpful as possible with implicit lifetimes.\n@@ -73,31 +85,30 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // there aren't trait objects or because none are implicit, then just\n                 // write a single note on the impl itself.\n \n-                let impl_span = self.tcx().def_span(*impl_def_id);\n-                err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+                impl_span = Some(self.tcx().def_span(*impl_def_id));\n             } else {\n                 // Otherwise, point at all implicit static lifetimes\n \n-                err.note(\"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n                 for span in &traits {\n-                    err.span_note(*span, \"this has an implicit `'static` lifetime requirement\");\n+                    trait_subdiags.push(TraitSubdiag::Note { span: *span });\n                     // It would be nice to put this immediately under the above note, but they get\n                     // pushed to the end.\n-                    err.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n-                        \"consider relaxing the implicit `'static` requirement\",\n-                        \" + '_\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    trait_subdiags.push(TraitSubdiag::Sugg { span: span.shrink_to_hi() });\n                 }\n             }\n         } else {\n             // Otherwise just point out the impl.\n \n-            let impl_span = self.tcx().def_span(*impl_def_id);\n-            err.span_note(impl_span, \"...does not necessarily outlive the static lifetime introduced by the compatible `impl`\");\n+            impl_span = Some(self.tcx().def_span(*impl_def_id));\n         }\n-        let reported = err.emit();\n+        let err = MismatchedStaticLifetime {\n+            cause_span: cause.span,\n+            unmet_lifetime_reqs: multispan_subdiag,\n+            expl,\n+            impl_note: ImplNote { impl_span },\n+            trait_subdiags,\n+        };\n+        let reported = self.tcx().sess.emit_err(err);\n         Some(reported)\n     }\n }"}, {"sha": "562246f4e8a1b239db23ab7af534d752cca14ba6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -911,8 +911,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n-    fn get_visibility(self, id: DefIndex) -> ty::Visibility {\n-        self.root.tables.visibility.get(self, id).unwrap().decode(self)\n+    fn get_visibility(self, id: DefIndex) -> ty::Visibility<DefId> {\n+        self.root\n+            .tables\n+            .visibility\n+            .get(self, id)\n+            .unwrap()\n+            .decode(self)\n+            .map_id(|index| self.local_def_id(index))\n     }\n \n     fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {\n@@ -1182,7 +1188,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n \n-    fn get_struct_field_visibilities(self, id: DefIndex) -> impl Iterator<Item = Visibility> + 'a {\n+    fn get_struct_field_visibilities(\n+        self,\n+        id: DefIndex,\n+    ) -> impl Iterator<Item = Visibility<DefId>> + 'a {\n         self.root\n             .tables\n             .children"}, {"sha": "dede1b2122a3cc06f62b8efb4b76f9f78f6b9419", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -210,7 +210,6 @@ provide! { tcx, def_id, other, cdata,\n     lookup_const_stability => { table }\n     lookup_default_body_stability => { table }\n     lookup_deprecation_entry => { table }\n-    visibility => { table }\n     unused_generic_params => { table }\n     opt_def_kind => { table_direct }\n     impl_parent => { table }\n@@ -225,6 +224,7 @@ provide! { tcx, def_id, other, cdata,\n     generator_kind => { table }\n     trait_def => { table }\n \n+    visibility => { cdata.get_visibility(def_id.index) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n@@ -485,15 +485,15 @@ impl CStore {\n     pub fn struct_field_visibilities_untracked(\n         &self,\n         def: DefId,\n-    ) -> impl Iterator<Item = Visibility> + '_ {\n+    ) -> impl Iterator<Item = Visibility<DefId>> + '_ {\n         self.get_crate_data(def.krate).get_struct_field_visibilities(def.index)\n     }\n \n     pub fn ctor_def_id_and_kind_untracked(&self, def: DefId) -> Option<(DefId, CtorKind)> {\n         self.get_crate_data(def.krate).get_ctor_def_id_and_kind(def.index)\n     }\n \n-    pub fn visibility_untracked(&self, def: DefId) -> Visibility {\n+    pub fn visibility_untracked(&self, def: DefId) -> Visibility<DefId> {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n "}, {"sha": "b807663b10fd05fd0642d059e5eebb841fab9a61", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1138,7 +1138,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.codegen_fn_attrs[def_id] <- self.tcx.codegen_fn_attrs(def_id));\n             }\n             if should_encode_visibility(def_kind) {\n-                record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n+                let vis =\n+                    self.tcx.local_visibility(local_id).map_id(|def_id| def_id.local_def_index);\n+                record!(self.tables.visibility[def_id] <- vis);\n             }\n             if should_encode_stability(def_kind) {\n                 self.encode_stability(def_id);\n@@ -1727,7 +1729,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             self.tables.opt_def_kind.set(LOCAL_CRATE.as_def_id().index, DefKind::Mod);\n             record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             self.encode_attrs(LOCAL_CRATE.as_def_id().expect_local());\n-            record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n+            let vis = tcx.local_visibility(CRATE_DEF_ID).map_id(|def_id| def_id.local_def_index);\n+            record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- vis);\n             if let Some(stability) = stability {\n                 record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n             }"}, {"sha": "748b3afec37c7b0661c7798b7f84a8945c013645", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -338,7 +338,7 @@ define_tables! {\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n \n     opt_def_kind: Table<DefIndex, DefKind>,\n-    visibility: Table<DefIndex, LazyValue<ty::Visibility>>,\n+    visibility: Table<DefIndex, LazyValue<ty::Visibility<DefIndex>>>,\n     def_span: Table<DefIndex, LazyValue<Span>>,\n     def_ident_span: Table<DefIndex, LazyValue<Span>>,\n     lookup_stability: Table<DefIndex, LazyValue<attr::Stability>>,"}, {"sha": "5ff014c7815a9c0ba52aaaffa49d29d0ffdce603", "filename": "compiler/rustc_middle/src/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmetadata.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,6 +2,7 @@ use crate::ty;\n \n use rustc_hir::def::Res;\n use rustc_macros::HashStable;\n+use rustc_span::def_id::DefId;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n@@ -18,7 +19,7 @@ pub struct ModChild {\n     /// Local variables cannot be exported, so this `Res` doesn't need the ID parameter.\n     pub res: Res<!>,\n     /// Visibility of the item.\n-    pub vis: ty::Visibility,\n+    pub vis: ty::Visibility<DefId>,\n     /// Span of the item.\n     pub span: Span,\n     /// A proper `macro_rules` item (not a reexport)."}, {"sha": "4478b45cf1437e833d4faa8e4a775f5b2932439e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1607,7 +1607,7 @@ rustc_queries! {\n         desc { \"looking up late bound vars\" }\n     }\n \n-    query visibility(def_id: DefId) -> ty::Visibility {\n+    query visibility(def_id: DefId) -> ty::Visibility<DefId> {\n         desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }"}, {"sha": "55ee5bd2f810d0999641b9e490e27c780cdab700", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -42,7 +42,7 @@ impl AssocItem {\n     }\n \n     #[inline]\n-    pub fn visibility(&self, tcx: TyCtxt<'_>) -> Visibility {\n+    pub fn visibility(&self, tcx: TyCtxt<'_>) -> Visibility<DefId> {\n         tcx.visibility(self.def_id)\n     }\n "}, {"sha": "c2e5decfc786ed2d8af6a9ac74df8cb58cfa746d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -22,6 +22,7 @@ use crate::ty::{\n     FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntTy, IntVar, IntVid, List,\n     ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, PredicateS, ProjectionTy, Region,\n     RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n+    Visibility,\n };\n use rustc_ast as ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -1728,6 +1729,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             .chain(self.crates(()).iter().copied())\n             .flat_map(move |cnum| self.traits_in_crate(cnum).iter().copied())\n     }\n+\n+    #[inline]\n+    pub fn local_visibility(self, def_id: LocalDefId) -> Visibility {\n+        self.visibility(def_id.to_def_id()).expect_local()\n+    }\n }\n \n /// A trait implemented for all `X<'a>` types that can be safely and"}, {"sha": "37136ff2ef5d324170e01e7848c4c6d3ef723a3d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -263,11 +263,11 @@ impl fmt::Display for ImplPolarity {\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, Encodable, Decodable, HashStable)]\n-pub enum Visibility {\n+pub enum Visibility<Id = LocalDefId> {\n     /// Visible everywhere (including in other crates).\n     Public,\n     /// Visible only in the given crate-local module.\n-    Restricted(DefId),\n+    Restricted(Id),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable)]\n@@ -358,28 +358,45 @@ impl<'tcx> DefIdTree for TyCtxt<'tcx> {\n     }\n }\n \n-impl Visibility {\n-    /// Returns `true` if an item with this visibility is accessible from the given block.\n-    pub fn is_accessible_from<T: DefIdTree>(self, module: DefId, tree: T) -> bool {\n-        let restriction = match self {\n-            // Public items are visible everywhere.\n-            Visibility::Public => return true,\n-            // Restricted items are visible in an arbitrary local module.\n-            Visibility::Restricted(other) if other.krate != module.krate => return false,\n-            Visibility::Restricted(module) => module,\n-        };\n+impl<Id> Visibility<Id> {\n+    pub fn is_public(self) -> bool {\n+        matches!(self, Visibility::Public)\n+    }\n+\n+    pub fn map_id<OutId>(self, f: impl FnOnce(Id) -> OutId) -> Visibility<OutId> {\n+        match self {\n+            Visibility::Public => Visibility::Public,\n+            Visibility::Restricted(id) => Visibility::Restricted(f(id)),\n+        }\n+    }\n+}\n+\n+impl<Id: Into<DefId>> Visibility<Id> {\n+    pub fn to_def_id(self) -> Visibility<DefId> {\n+        self.map_id(Into::into)\n+    }\n \n-        tree.is_descendant_of(module, restriction)\n+    /// Returns `true` if an item with this visibility is accessible from the given module.\n+    pub fn is_accessible_from(self, module: impl Into<DefId>, tree: impl DefIdTree) -> bool {\n+        match self {\n+            // Public items are visible everywhere.\n+            Visibility::Public => true,\n+            Visibility::Restricted(id) => tree.is_descendant_of(module.into(), id.into()),\n+        }\n     }\n \n     /// Returns `true` if this visibility is at least as accessible as the given visibility\n-    pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n-        let vis_restriction = match vis {\n-            Visibility::Public => return self == Visibility::Public,\n-            Visibility::Restricted(module) => module,\n-        };\n+    pub fn is_at_least(self, vis: Visibility<impl Into<DefId>>, tree: impl DefIdTree) -> bool {\n+        match vis {\n+            Visibility::Public => self.is_public(),\n+            Visibility::Restricted(id) => self.is_accessible_from(id, tree),\n+        }\n+    }\n+}\n \n-        self.is_accessible_from(vis_restriction, tree)\n+impl Visibility<DefId> {\n+    pub fn expect_local(self) -> Visibility {\n+        self.map_id(|id| id.expect_local())\n     }\n \n     // Returns `true` if this item is visible anywhere in the local crate.\n@@ -389,10 +406,6 @@ impl Visibility {\n             Visibility::Restricted(def_id) => def_id.is_local(),\n         }\n     }\n-\n-    pub fn is_public(self) -> bool {\n-        matches!(self, Visibility::Public)\n-    }\n }\n \n /// The crate variances map is computed during typeck and contains the\n@@ -1861,7 +1874,7 @@ pub enum VariantDiscr {\n pub struct FieldDef {\n     pub did: DefId,\n     pub name: Symbol,\n-    pub vis: Visibility,\n+    pub vis: Visibility<DefId>,\n }\n \n impl PartialEq for FieldDef {"}, {"sha": "9c8dc30e2db3fa0c55723b19576a2feaf74c32f2", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1,4 +1,4 @@\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_index::vec::{Idx, IndexVec};\n \n use crate::middle::exported_symbols::ExportedSymbol;\n@@ -60,7 +60,7 @@ trivially_parameterized_over_tcx! {\n     ty::ImplPolarity,\n     ty::ReprOptions,\n     ty::TraitDef,\n-    ty::Visibility,\n+    ty::Visibility<DefIndex>,\n     ty::adjustment::CoerceUnsizedInfo,\n     ty::fast_reject::SimplifiedTypeGen<DefId>,\n     rustc_ast::Attribute,"}, {"sha": "7f992c18a18e4ce7bd3f87cb1090e13d0bc8f0a1", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1036,7 +1036,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             VarBindingForm {\n                                 binding_mode,\n                                 opt_ty_info,\n-                                opt_match_place: Some((Some(place), span)),\n+                                opt_match_place: Some((None, span)),\n                                 pat_span: span,\n                             },\n                         )))))"}, {"sha": "7e09efe5972a3a100e9a5f07196861e60d5867c5", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -202,6 +202,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Box<Pat<'tcx>> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n+        let mut span = pat.span;\n \n         let kind = match pat.kind {\n             hir::PatKind::Wild => PatKind::Wild,\n@@ -262,6 +263,10 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             }\n \n             hir::PatKind::Binding(_, id, ident, ref sub) => {\n+                if let Some(ident_span) = ident.span.find_ancestor_inside(span) {\n+                    span = span.with_hi(ident_span.hi());\n+                }\n+\n                 let bm = *self\n                     .typeck_results\n                     .pat_binding_modes()\n@@ -326,7 +331,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             hir::PatKind::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n         };\n \n-        Box::new(Pat { span: pat.span, ty, kind })\n+        Box::new(Pat { span, ty, kind })\n     }\n \n     fn lower_tuple_subpats("}, {"sha": "b2966f0d21801319b72f022890c1ee507e771180", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 37, "deletions": 39, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(associated_type_defaults)]\n #![feature(control_flow_enum)]\n+#![feature(let_else)]\n #![feature(rustc_private)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n@@ -334,15 +335,17 @@ impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'tcx> for FindMin<'a, 'tcx, VL>\n         _kind: &str,\n         _descr: &dyn fmt::Display,\n     ) -> ControlFlow<Self::BreakTy> {\n-        self.min = VL::new_min(self, def_id);\n+        if let Some(def_id) = def_id.as_local() {\n+            self.min = VL::new_min(self, def_id);\n+        }\n         ControlFlow::CONTINUE\n     }\n }\n \n trait VisibilityLike: Sized {\n     const MAX: Self;\n     const SHALLOW: bool = false;\n-    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self;\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self;\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n@@ -357,8 +360,8 @@ trait VisibilityLike: Sized {\n }\n impl VisibilityLike for ty::Visibility {\n     const MAX: Self = ty::Visibility::Public;\n-    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n-        min(find.tcx.visibility(def_id), find.min, find.tcx)\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n+        min(find.tcx.local_visibility(def_id), find.min, find.tcx)\n     }\n }\n impl VisibilityLike for Option<AccessLevel> {\n@@ -373,15 +376,8 @@ impl VisibilityLike for Option<AccessLevel> {\n     // both \"shallow\" version of its self type and \"shallow\" version of its trait if it exists\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n-    fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n-        cmp::min(\n-            if let Some(def_id) = def_id.as_local() {\n-                find.access_levels.map.get(&def_id).copied()\n-            } else {\n-                Self::MAX\n-            },\n-            find.min,\n-        )\n+    fn new_min(find: &FindMin<'_, '_, Self>, def_id: LocalDefId) -> Self {\n+        cmp::min(find.access_levels.map.get(&def_id).copied(), find.min)\n     }\n }\n \n@@ -511,15 +507,15 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n             let def_kind = self.tcx.def_kind(item_id.def_id);\n-            let vis = self.tcx.visibility(item_id.def_id);\n+            let vis = self.tcx.local_visibility(item_id.def_id);\n             self.update_macro_reachable_def(item_id.def_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n             for export in exports {\n-                if export.vis.is_accessible_from(defining_mod.to_def_id(), self.tcx) {\n+                if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let vis = self.tcx.visibility(def_id.to_def_id());\n+                            let vis = self.tcx.local_visibility(def_id);\n                             self.update_macro_reachable_def(def_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -542,7 +538,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n             DefKind::Const | DefKind::Static(_) | DefKind::TraitAlias | DefKind::TyAlias => {\n-                if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                if vis.is_accessible_from(module, self.tcx) {\n                     self.update(def_id, level);\n                 }\n             }\n@@ -554,7 +550,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             DefKind::Macro(_) => {\n                 let item = self.tcx.hir().expect_item(def_id);\n                 if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }, _) = item.kind {\n-                    if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                    if vis.is_accessible_from(module, self.tcx) {\n                         self.update(def_id, level);\n                     }\n                 }\n@@ -565,7 +561,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n             // hygiene these don't need to be marked reachable. The contents of\n             // the module, however may be reachable.\n             DefKind::Mod => {\n-                if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                if vis.is_accessible_from(module, self.tcx) {\n                     self.update_macro_reachable(def_id, module);\n                 }\n             }\n@@ -579,8 +575,8 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n                     {\n                         for field in struct_def.fields() {\n                             let def_id = self.tcx.hir().local_def_id(field.hir_id);\n-                            let field_vis = self.tcx.visibility(def_id);\n-                            if field_vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                            let field_vis = self.tcx.local_visibility(def_id);\n+                            if field_vis.is_accessible_from(module, self.tcx) {\n                                 self.reach(def_id, level).ty();\n                             }\n                         }\n@@ -654,7 +650,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n                     if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.def_id) == ty::Visibility::Public\n+                        || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n                     {\n                         self.update(impl_item_ref.id.def_id, item_level);\n                     }\n@@ -682,7 +678,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.def_id) == ty::Visibility::Public {\n+                    if self.tcx.visibility(foreign_item.id.def_id).is_public() {\n                         self.update(foreign_item.id.def_id, item_level);\n                     }\n                 }\n@@ -1117,7 +1113,7 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     }\n \n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        self.tcx.visibility(did).is_accessible_from(self.current_item.to_def_id(), self.tcx)\n+        self.tcx.visibility(did).is_accessible_from(self.current_item, self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n@@ -1609,8 +1605,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n                         if self.access_levels.is_reachable(impl_item_ref.id.def_id)\n-                            || self.tcx.visibility(impl_item_ref.id.def_id)\n-                                == ty::Visibility::Public\n+                            || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n                         {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n@@ -1780,17 +1775,17 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n             );\n         }\n \n-        let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().local_def_id_to_hir_id(def_id),\n-            None => return false,\n+        let Some(local_def_id) = def_id.as_local() else {\n+            return false;\n         };\n \n-        let vis = self.tcx.visibility(def_id);\n+        let vis = self.tcx.local_visibility(local_def_id);\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n             let vis_descr = match vis {\n                 ty::Visibility::Public => \"public\",\n                 ty::Visibility::Restricted(vis_def_id) => {\n-                    if vis_def_id == self.tcx.parent_module(hir_id).to_def_id() {\n+                    if vis_def_id == self.tcx.parent_module(hir_id) {\n                         \"private\"\n                     } else if vis_def_id.is_top_level_module() {\n                         \"crate-private\"\n@@ -1906,7 +1901,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n \n     pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let item_visibility = tcx.visibility(id.def_id);\n+        let item_visibility = tcx.local_visibility(id.def_id);\n         let def_kind = tcx.def_kind(id.def_id);\n \n         match def_kind {\n@@ -1957,7 +1952,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n                     for foreign_item in items {\n-                        let vis = tcx.visibility(foreign_item.id.def_id);\n+                        let vis = tcx.local_visibility(foreign_item.id.def_id);\n                         self.check(foreign_item.id.def_id, vis).generics().predicates().ty();\n                     }\n                 }\n@@ -1972,7 +1967,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n \n                     for field in struct_def.fields() {\n                         let def_id = tcx.hir().local_def_id(field.hir_id);\n-                        let field_visibility = tcx.visibility(def_id);\n+                        let field_visibility = tcx.local_visibility(def_id);\n                         self.check(def_id, min(item_visibility, field_visibility, tcx)).ty();\n                     }\n                 }\n@@ -1992,7 +1987,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                     }\n                     for impl_item_ref in impl_.items {\n                         let impl_item_vis = if impl_.of_trait.is_none() {\n-                            min(tcx.visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n+                            min(tcx.local_visibility(impl_item_ref.id.def_id), impl_vis, tcx)\n                         } else {\n                             impl_vis\n                         };\n@@ -2019,8 +2014,11 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n-    let def_id = def_id.expect_local();\n+fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility<DefId> {\n+    local_visibility(tcx, def_id.expect_local()).to_def_id()\n+}\n+\n+fn local_visibility(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Visibility {\n     match tcx.resolutions(()).visibilities.get(&def_id) {\n         Some(vis) => *vis,\n         None => {\n@@ -2037,7 +2035,7 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n                 | Node::Item(hir::Item {\n                     kind: hir::ItemKind::Use(_, hir::UseKind::ListStem) | hir::ItemKind::OpaqueTy(..),\n                     ..\n-                }) => ty::Visibility::Restricted(tcx.parent_module(hir_id).to_def_id()),\n+                }) => ty::Visibility::Restricted(tcx.parent_module(hir_id)),\n                 // Visibilities of trait impl items are inherited from their traits\n                 // and are not filled in resolve.\n                 Node::ImplItem(impl_item) => {\n@@ -2050,7 +2048,7 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n                                 tcx.sess.delay_span_bug(tr.path.span, \"trait without a def-id\");\n                                 ty::Visibility::Public\n                             },\n-                            |def_id| tcx.visibility(def_id),\n+                            |def_id| tcx.visibility(def_id).expect_local(),\n                         ),\n                         _ => span_bug!(impl_item.span, \"the parent is not a trait impl\"),\n                     }"}, {"sha": "d7599a56c0b66972b42df897c1d4767adfd915ea", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -21,6 +21,7 @@ rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n thin-vec = \"0.2.8\"\n tracing = \"0.1\""}, {"sha": "0bc811eb04412544d2d783c0ca2400490bf081c8", "filename": "compiler/rustc_query_system/src/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -148,3 +148,5 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for rustc_feature::Features {\n         });\n     }\n }\n+\n+impl<'ctx> rustc_type_ir::HashStableContext for StableHashingContext<'ctx> {}"}, {"sha": "9cb735b36856c6aa09fa4d562683b42af7a36a42", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -39,24 +39,26 @@ use std::ptr;\n \n type Res = def::Res<NodeId>;\n \n-impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, LocalExpnId) {\n+impl<'a, Id: Into<DefId>> ToNameBinding<'a>\n+    for (Module<'a>, ty::Visibility<Id>, Span, LocalExpnId)\n+{\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n             ambiguity: None,\n-            vis: self.1,\n+            vis: self.1.to_def_id(),\n             span: self.2,\n             expansion: self.3,\n         })\n     }\n }\n \n-impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId) {\n+impl<'a, Id: Into<DefId>> ToNameBinding<'a> for (Res, ty::Visibility<Id>, Span, LocalExpnId) {\n     fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, false),\n             ambiguity: None,\n-            vis: self.1,\n+            vis: self.1.to_def_id(),\n             span: self.2,\n             expansion: self.3,\n         })\n@@ -70,7 +72,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroE\n         arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(self.0, true),\n             ambiguity: None,\n-            vis: self.1,\n+            vis: self.1.to_def_id(),\n             span: self.2,\n             expansion: self.3,\n         })\n@@ -260,7 +262,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         self.r.visibilities[&def_id.expect_local()]\n                     }\n                     // Otherwise, the visibility is restricted to the nearest parent `mod` item.\n-                    _ => ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod()),\n+                    _ => ty::Visibility::Restricted(\n+                        self.parent_scope.module.nearest_parent_mod().expect_local(),\n+                    ),\n                 })\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n@@ -311,7 +315,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             } else {\n                                 let vis = ty::Visibility::Restricted(res.def_id());\n                                 if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    Ok(vis)\n+                                    Ok(vis.expect_local())\n                                 } else {\n                                     Err(VisResolutionError::AncestorOnly(path.span))\n                                 }\n@@ -649,7 +653,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         true,\n                         // The whole `use` item\n                         item,\n-                        ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod()),\n+                        ty::Visibility::Restricted(\n+                            self.parent_scope.module.nearest_parent_mod().expect_local(),\n+                        ),\n                         root_span,\n                     );\n                 }\n@@ -765,10 +771,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 if let Some(ctor_node_id) = vdata.ctor_id() {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n-                    let mut ctor_vis = if vis == ty::Visibility::Public\n+                    let mut ctor_vis = if vis.is_public()\n                         && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n-                        ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id())\n+                        ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n                         vis\n                     };\n@@ -785,7 +791,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         if ctor_vis.is_at_least(field_vis, &*self.r) {\n                             ctor_vis = field_vis;\n                         }\n-                        ret_fields.push(field_vis);\n+                        ret_fields.push(field_vis.to_def_id());\n                     }\n                     let ctor_def_id = self.r.local_def_id(ctor_node_id);\n                     let ctor_res = Res::Def(\n@@ -795,7 +801,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n                     self.r.visibilities.insert(ctor_def_id, ctor_vis);\n \n-                    self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis, ret_fields));\n+                    self.r\n+                        .struct_constructors\n+                        .insert(def_id, (ctor_res, ctor_vis.to_def_id(), ret_fields));\n                 }\n             }\n \n@@ -867,8 +875,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n         .map(|module| {\n             let used = self.process_macro_use_imports(item, module);\n-            let binding =\n-                (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n+            let vis = ty::Visibility::<LocalDefId>::Public;\n+            let binding = (module, vis, sp, expansion).to_name_binding(self.r.arenas);\n             (used, Some(ModuleOrUniformRoot::Module(module)), binding)\n         })\n         .unwrap_or((true, None, self.r.dummy_binding));\n@@ -1117,7 +1125,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 root_span: span,\n                 span,\n                 module_path: Vec::new(),\n-                vis: Cell::new(Some(ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id()))),\n+                vis: Cell::new(Some(ty::Visibility::Restricted(CRATE_DEF_ID))),\n                 used: Cell::new(false),\n             })\n         };\n@@ -1263,7 +1271,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n-                ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id())\n+                ty::Visibility::Restricted(CRATE_DEF_ID)\n             };\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n@@ -1294,7 +1302,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 }\n                 _ => self.resolve_visibility(&item.vis),\n             };\n-            if vis != ty::Visibility::Public {\n+            if !vis.is_public() {\n                 self.insert_unused_macro(ident, def_id, item.id, &rule_spans);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n@@ -1507,10 +1515,10 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         self.r.visibilities.insert(def_id, vis);\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n-        let ctor_vis = if vis == ty::Visibility::Public\n+        let ctor_vis = if vis.is_public()\n             && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n         {\n-            ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id())\n+            ty::Visibility::Restricted(CRATE_DEF_ID)\n         } else {\n             vis\n         };"}, {"sha": "2287aa1eb2567691517b93d569b4a2934dacde84", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n use rustc_span::symbol::{kw, Ident};\n@@ -26,6 +27,8 @@ use Determinacy::*;\n use Namespace::*;\n use RibKind::*;\n \n+type Visibility = ty::Visibility<LocalDefId>;\n+\n impl<'a> Resolver<'a> {\n     /// A generic scope visitor.\n     /// Visits scopes in order to resolve some identifier in them or perform other actions.\n@@ -424,8 +427,7 @@ impl<'a> Resolver<'a> {\n                 let ident = Ident::new(orig_ident.name, orig_ident.span.with_ctxt(ctxt));\n                 let ok = |res, span, arenas| {\n                     Ok((\n-                        (res, ty::Visibility::Public, span, LocalExpnId::ROOT)\n-                            .to_name_binding(arenas),\n+                        (res, Visibility::Public, span, LocalExpnId::ROOT).to_name_binding(arenas),\n                         Flags::empty(),\n                     ))\n                 };\n@@ -438,7 +440,7 @@ impl<'a> Resolver<'a> {\n                         {\n                             let binding = (\n                                 Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                ty::Visibility::Public,\n+                                Visibility::Public,\n                                 attr.span,\n                                 expn_id,\n                             )\n@@ -841,9 +843,8 @@ impl<'a> Resolver<'a> {\n                 if ns == TypeNS {\n                     if ident.name == kw::Crate || ident.name == kw::DollarCrate {\n                         let module = self.resolve_crate_root(ident);\n-                        let binding =\n-                            (module, ty::Visibility::Public, module.span, LocalExpnId::ROOT)\n-                                .to_name_binding(self.arenas);\n+                        let binding = (module, Visibility::Public, module.span, LocalExpnId::ROOT)\n+                            .to_name_binding(self.arenas);\n                         return Ok(binding);\n                     } else if ident.name == kw::Super || ident.name == kw::SelfLower {\n                         // FIXME: Implement these with renaming requirements so that e.g."}, {"sha": "c133c272bac275e48625704d76255cbfc414c824", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -214,7 +214,7 @@ impl<'a> Resolver<'a> {\n         binding: &'a NameBinding<'a>,\n         import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let import_vis = import.expect_vis();\n+        let import_vis = import.expect_vis().to_def_id();\n         let vis = if binding.vis.is_at_least(import_vis, self)\n             || pub_use_of_private_extern_crate_hack(import, binding)\n         {\n@@ -227,7 +227,7 @@ impl<'a> Resolver<'a> {\n             if vis == import_vis\n                 || max_vis.get().map_or(true, |max_vis| vis.is_at_least(max_vis, self))\n             {\n-                max_vis.set(Some(vis))\n+                max_vis.set(Some(vis.expect_local()))\n             }\n         }\n "}, {"sha": "f7b7313d1049d2271a6930aa1863e4752c605d7c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -648,7 +648,7 @@ pub struct NameBinding<'a> {\n     ambiguity: Option<(&'a NameBinding<'a>, AmbiguityKind)>,\n     expansion: LocalExpnId,\n     span: Span,\n-    vis: ty::Visibility,\n+    vis: ty::Visibility<DefId>,\n }\n \n pub trait ToNameBinding<'a> {\n@@ -1012,7 +1012,7 @@ pub struct Resolver<'a> {\n     /// Table for mapping struct IDs into struct constructor IDs,\n     /// it's not used during normal resolution, only for better error reporting.\n     /// Also includes of list of each fields visibility\n-    struct_constructors: DefIdMap<(Res, ty::Visibility, Vec<ty::Visibility>)>,\n+    struct_constructors: DefIdMap<(Res, ty::Visibility<DefId>, Vec<ty::Visibility<DefId>>)>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n@@ -1808,7 +1808,11 @@ impl<'a> Resolver<'a> {\n         self.pat_span_map.insert(node, span);\n     }\n \n-    fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n+    fn is_accessible_from(\n+        &self,\n+        vis: ty::Visibility<impl Into<DefId>>,\n+        module: Module<'a>,\n+    ) -> bool {\n         vis.is_accessible_from(module.nearest_parent_mod(), self)\n     }\n \n@@ -1862,10 +1866,8 @@ impl<'a> Resolver<'a> {\n                     self.crate_loader.maybe_process_path_extern(ident.name)?\n                 };\n                 let crate_root = self.expect_module(crate_id.as_def_id());\n-                Some(\n-                    (crate_root, ty::Visibility::Public, DUMMY_SP, LocalExpnId::ROOT)\n-                        .to_name_binding(self.arenas),\n-                )\n+                let vis = ty::Visibility::<LocalDefId>::Public;\n+                Some((crate_root, vis, DUMMY_SP, LocalExpnId::ROOT).to_name_binding(self.arenas))\n             }\n         })\n     }"}, {"sha": "ceb6b6c68b0551cae87f27896980089a095ac310", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -305,6 +305,12 @@ impl DefId {\n     }\n }\n \n+impl From<LocalDefId> for DefId {\n+    fn from(local: LocalDefId) -> DefId {\n+        local.to_def_id()\n+    }\n+}\n+\n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) {\n         self.krate.encode(s);"}, {"sha": "efdb1ace1399294c498313512c5ec1f0a554f68a", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1895,9 +1895,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                         // FIXME(compiler-errors): This could be generalized, both to\n                         // be more granular, and probably look past other `#[fundamental]`\n                         // types, too.\n-                        self.tcx\n-                            .visibility(def.did())\n-                            .is_accessible_from(body_id.owner.to_def_id(), self.tcx)\n+                        self.tcx.visibility(def.did()).is_accessible_from(body_id.owner, self.tcx)\n                     } else {\n                         true\n                     }"}, {"sha": "da30344ef7ec090de63092ac9c795f3c1cf42c68", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 9, "deletions": 40, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -23,6 +23,9 @@ pub mod sty;\n pub use codec::*;\n pub use sty::*;\n \n+/// Needed so we can use #[derive(HashStable_Generic)]\n+pub trait HashStableContext {}\n+\n pub trait Interner {\n     type AdtDef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type SubstsRef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n@@ -295,6 +298,7 @@ rustc_index::newtype_index! {\n     /// is the outer fn.\n     ///\n     /// [dbi]: https://en.wikipedia.org/wiki/De_Bruijn_index\n+    #[derive(HashStable_Generic)]\n     pub struct DebruijnIndex {\n         DEBUG_FORMAT = \"DebruijnIndex({})\",\n         const INNERMOST = 0,\n@@ -366,7 +370,7 @@ impl DebruijnIndex {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(Encodable, Decodable)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -413,7 +417,7 @@ impl IntTy {\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n-#[derive(Encodable, Decodable)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -460,7 +464,7 @@ impl UintTy {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(Encodable, Decodable)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum FloatTy {\n     F32,\n     F64,\n@@ -597,7 +601,7 @@ impl UnifyKey for FloatVid {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Decodable, Encodable, Hash)]\n+#[derive(Copy, Clone, PartialEq, Decodable, Encodable, Hash, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub enum Variance {\n     Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n@@ -666,30 +670,6 @@ impl Variance {\n     }\n }\n \n-impl<CTX> HashStable<CTX> for DebruijnIndex {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        self.as_u32().hash_stable(ctx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for IntTy {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        discriminant(self).hash_stable(ctx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for UintTy {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        discriminant(self).hash_stable(ctx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for FloatTy {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        discriminant(self).hash_stable(ctx, hasher);\n-    }\n-}\n-\n impl<CTX> HashStable<CTX> for InferTy {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         use InferTy::*;\n@@ -703,12 +683,6 @@ impl<CTX> HashStable<CTX> for InferTy {\n     }\n }\n \n-impl<CTX> HashStable<CTX> for Variance {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        discriminant(self).hash_stable(ctx, hasher);\n-    }\n-}\n-\n impl fmt::Debug for IntVarValue {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -811,6 +785,7 @@ rustc_index::newtype_index! {\n     /// declared, but a type name in a non-zero universe is a placeholder\n     /// type -- an idealized representative of \"types in general\" that we\n     /// use for checking generic functions.\n+    #[derive(HashStable_Generic)]\n     pub struct UniverseIndex {\n         DEBUG_FORMAT = \"U{}\",\n     }\n@@ -850,9 +825,3 @@ impl UniverseIndex {\n         self.private < other.private\n     }\n }\n-\n-impl<CTX> HashStable<CTX> for UniverseIndex {\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        self.private.hash_stable(ctx, hasher);\n-    }\n-}"}, {"sha": "26e48d2d2147e9370433db2a081b56255e5e75ad", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -3,14 +3,14 @@\n use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n use std::{fmt, hash};\n \n-use crate::DebruijnIndex;\n use crate::FloatTy;\n use crate::IntTy;\n use crate::Interner;\n use crate::TyDecoder;\n use crate::TyEncoder;\n use crate::UintTy;\n use crate::UniverseIndex;\n+use crate::{DebruijnIndex, HashStableContext};\n \n use self::RegionKind::*;\n use self::TyKind::*;\n@@ -774,7 +774,7 @@ where\n \n // This is not a derived impl because a derive would require `I: HashStable`\n #[allow(rustc::usage_of_ty_tykind)]\n-impl<CTX, I: Interner> HashStable<CTX> for TyKind<I>\n+impl<CTX: HashStableContext, I: Interner> HashStable<CTX> for TyKind<I>\n where\n     I::AdtDef: HashStable<CTX>,\n     I::DefId: HashStable<CTX>,\n@@ -1286,7 +1286,7 @@ where\n }\n \n // This is not a derived impl because a derive would require `I: HashStable`\n-impl<CTX, I: Interner> HashStable<CTX> for RegionKind<I>\n+impl<CTX: HashStableContext, I: Interner> HashStable<CTX> for RegionKind<I>\n where\n     I::EarlyBoundRegion: HashStable<CTX>,\n     I::BoundRegion: HashStable<CTX>,"}, {"sha": "e1d55ff82cbadf12320e977c2152934f32302092", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -375,7 +375,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible =\n-                        sole_field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                        sole_field.vis.is_accessible_from(expr.hir_id.owner, self.tcx)\n                         // Skip suggestions for unstable public fields (for example `Pin::pointer`)\n                         && matches!(self.tcx.eval_stability(sole_field.did, None, expr.span, None), EvalResult::Allow | EvalResult::Unmarked);\n "}, {"sha": "0e6a8ef8265b2c15e8e2dbb965ad18ad87e243ab", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1729,9 +1729,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let private_fields: Vec<&ty::FieldDef> = variant\n                 .fields\n                 .iter()\n-                .filter(|field| {\n-                    !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n-                })\n+                .filter(|field| !field.vis.is_accessible_from(tcx.parent_module(expr_id), tcx))\n                 .collect();\n \n             if !private_fields.is_empty() {\n@@ -2343,7 +2341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let ty::Adt(def, _) = output_ty.kind() && !def.is_enum() {\n                 def.non_enum_variant().fields.iter().any(|field| {\n                     field.ident(self.tcx) == ident\n-                        && field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                        && field.vis.is_accessible_from(expr.hir_id.owner, self.tcx)\n                 })\n             } else if let ty::Tuple(tys) = output_ty.kind()\n                 && let Ok(idx) = ident.as_str().parse::<usize>()"}, {"sha": "8065b848ad6f88c6399a5c6f0f569b032223dca3", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1161,7 +1161,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => None,\n         });\n         if let Some((field, field_ty)) = field_receiver {\n-            let scope = tcx.parent_module(self.body_id).to_def_id();\n+            let scope = tcx.parent_module(self.body_id);\n             let is_accessible = field.vis.is_accessible_from(scope, tcx);\n \n             if is_accessible {"}, {"sha": "9fb915a056ab654b9be3f2241f3611bcd6c1a2cc", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1397,7 +1397,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .iter()\n                 .copied()\n                 .filter(|(field, _)| {\n-                    field.vis.is_accessible_from(tcx.parent_module(pat.hir_id).to_def_id(), tcx)\n+                    field.vis.is_accessible_from(tcx.parent_module(pat.hir_id), tcx)\n                         && !matches!(\n                             tcx.eval_stability(field.did, None, DUMMY_SP, None),\n                             EvalResult::Deny { .. }"}, {"sha": "f921839cf529f17cd59ca951b67bbe4d99460c61", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -41,6 +41,9 @@ pub struct OpenOptions {\n     mode: i32,\n }\n \n+#[derive(Copy, Clone, Debug, Default)]\n+pub struct FileTimes {}\n+\n pub struct FilePermissions(!);\n \n pub struct FileType(!);\n@@ -110,6 +113,11 @@ impl fmt::Debug for FilePermissions {\n     }\n }\n \n+impl FileTimes {\n+    pub fn set_accessed(&mut self, _t: SystemTime) {}\n+    pub fn set_modified(&mut self, _t: SystemTime) {}\n+}\n+\n impl FileType {\n     pub fn is_dir(&self) -> bool {\n         self.0\n@@ -344,6 +352,10 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         Err(Error::from_raw_os_error(22))\n     }\n+\n+    pub fn set_times(&self, _times: FileTimes) -> io::Result<()> {\n+        Err(Error::from_raw_os_error(22))\n+    }\n }\n \n impl DirBuilder {"}, {"sha": "95e711737738a4e661fe1f86c0b7edfb09e3241c", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -67,6 +67,7 @@ features = [\n     \"psapi\",\n     \"impl-default\",\n     \"timezoneapi\",\n+    \"winbase\",\n ]\n \n [dev-dependencies]"}, {"sha": "0ebabbd5ca5c04599f065a52f7654a93e6232fcc", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -197,9 +197,11 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n                 ptr::null_mut(),\n             );\n \n-            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize];\n-            let db = data.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n-            let buf = &mut (*db).ReparseTarget as *mut u16;\n+            #[repr(C, align(8))]\n+            struct Align8<T>(T);\n+            let mut data = Align8([0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize]);\n+            let db = data.0.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n+            let buf = core::ptr::addr_of_mut!((*db).ReparseTarget) as *mut u16;\n             let mut i = 0;\n             // FIXME: this conversion is very hacky\n             let v = br\"\\??\\\";\n@@ -219,7 +221,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             let res = DeviceIoControl(\n                 h as *mut _,\n                 FSCTL_SET_REPARSE_POINT,\n-                data.as_ptr() as *mut _,\n+                db.cast(),\n                 (*db).ReparseDataLength + 8,\n                 ptr::null_mut(),\n                 0,"}, {"sha": "c2baea839f6384eef1dc8e754a068ed2bf985db4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -1777,7 +1777,7 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-pub(crate) fn clean_visibility(vis: ty::Visibility) -> Visibility {\n+pub(crate) fn clean_visibility(vis: ty::Visibility<DefId>) -> Visibility {\n     match vis {\n         ty::Visibility::Public => Visibility::Public,\n         ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n@@ -2111,8 +2111,8 @@ fn clean_use_statement<'tcx>(\n     // `pub(super)` or higher. If the current module is the top level\n     // module, there isn't really a parent module, which makes the results\n     // meaningless. In this case, we make sure the answer is `false`.\n-    let is_visible_from_parent_mod = visibility.is_accessible_from(parent_mod.to_def_id(), cx.tcx)\n-        && !current_mod.is_top_level_module();\n+    let is_visible_from_parent_mod =\n+        visibility.is_accessible_from(parent_mod, cx.tcx) && !current_mod.is_top_level_module();\n \n     if pub_underscore {\n         if let Some(ref inline) = inline_attr {"}, {"sha": "96716a39a2bfdbbe57532361f0e2f5984b72c870", "filename": "src/test/mir-opt/exponential_or.match_tuple.SimplifyCfg-initial.after.mir", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fexponential_or.match_tuple.SimplifyCfg-initial.after.mir?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -8,13 +8,13 @@ fn match_tuple(_1: (u32, bool, Option<i32>, u32)) -> u32 {\n     let mut _4: bool;                    // in scope 0 at $DIR/exponential-or.rs:+2:70: +2:77\n     let mut _5: bool;                    // in scope 0 at $DIR/exponential-or.rs:+2:62: +2:67\n     let mut _6: bool;                    // in scope 0 at $DIR/exponential-or.rs:+2:62: +2:67\n-    let _7: u32;                         // in scope 0 at $DIR/exponential-or.rs:+2:10: +2:21\n-    let _8: u32;                         // in scope 0 at $DIR/exponential-or.rs:+2:57: +2:78\n+    let _7: u32;                         // in scope 0 at $DIR/exponential-or.rs:+2:10: +2:11\n+    let _8: u32;                         // in scope 0 at $DIR/exponential-or.rs:+2:57: +2:58\n     let mut _9: u32;                     // in scope 0 at $DIR/exponential-or.rs:+2:83: +2:84\n     let mut _10: u32;                    // in scope 0 at $DIR/exponential-or.rs:+2:87: +2:88\n     scope 1 {\n-        debug y => _7;                   // in scope 1 at $DIR/exponential-or.rs:+2:10: +2:21\n-        debug z => _8;                   // in scope 1 at $DIR/exponential-or.rs:+2:57: +2:78\n+        debug y => _7;                   // in scope 1 at $DIR/exponential-or.rs:+2:10: +2:11\n+        debug z => _8;                   // in scope 1 at $DIR/exponential-or.rs:+2:57: +2:58\n     }\n \n     bb0: {\n@@ -61,10 +61,10 @@ fn match_tuple(_1: (u32, bool, Option<i32>, u32)) -> u32 {\n     }\n \n     bb9: {\n-        StorageLive(_7);                 // scope 0 at $DIR/exponential-or.rs:+2:10: +2:21\n-        _7 = (_1.0: u32);                // scope 0 at $DIR/exponential-or.rs:+2:10: +2:21\n-        StorageLive(_8);                 // scope 0 at $DIR/exponential-or.rs:+2:57: +2:78\n-        _8 = (_1.3: u32);                // scope 0 at $DIR/exponential-or.rs:+2:57: +2:78\n+        StorageLive(_7);                 // scope 0 at $DIR/exponential-or.rs:+2:10: +2:11\n+        _7 = (_1.0: u32);                // scope 0 at $DIR/exponential-or.rs:+2:10: +2:11\n+        StorageLive(_8);                 // scope 0 at $DIR/exponential-or.rs:+2:57: +2:58\n+        _8 = (_1.3: u32);                // scope 0 at $DIR/exponential-or.rs:+2:57: +2:58\n         StorageLive(_9);                 // scope 1 at $DIR/exponential-or.rs:+2:83: +2:84\n         _9 = _7;                         // scope 1 at $DIR/exponential-or.rs:+2:83: +2:84\n         StorageLive(_10);                // scope 1 at $DIR/exponential-or.rs:+2:87: +2:88"}, {"sha": "6a5021139cf611f52de7fdf7deae94a04ffb0a9a", "filename": "src/test/mir-opt/uniform_array_move_out.move_out_by_subslice.mir_map.0.mir", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.move_out_by_subslice.mir_map.0.mir?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -15,9 +15,9 @@ fn move_out_by_subslice() -> () {\n     let mut _11: std::boxed::Box<i32>;   // in scope 0 at $DIR/uniform_array_move_out.rs:+1:21: +1:26\n     scope 1 {\n         debug a => _1;                   // in scope 1 at $DIR/uniform_array_move_out.rs:+1:9: +1:10\n-        let _12: [std::boxed::Box<i32>; 2]; // in scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:17\n+        let _12: [std::boxed::Box<i32>; 2]; // in scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:12\n         scope 4 {\n-            debug _y => _12;             // in scope 4 at $DIR/uniform_array_move_out.rs:+2:10: +2:17\n+            debug _y => _12;             // in scope 4 at $DIR/uniform_array_move_out.rs:+2:10: +2:12\n         }\n     }\n     scope 2 {\n@@ -77,8 +77,8 @@ fn move_out_by_subslice() -> () {\n     bb6: {\n         StorageDead(_2);                 // scope 0 at $DIR/uniform_array_move_out.rs:+1:26: +1:27\n         FakeRead(ForLet(None), _1);      // scope 0 at $DIR/uniform_array_move_out.rs:+1:9: +1:10\n-        StorageLive(_12);                // scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:17\n-        _12 = move _1[0..2];             // scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:17\n+        StorageLive(_12);                // scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:12\n+        _12 = move _1[0..2];             // scope 1 at $DIR/uniform_array_move_out.rs:+2:10: +2:12\n         _0 = const ();                   // scope 0 at $DIR/uniform_array_move_out.rs:+0:27: +3:2\n         drop(_12) -> [return: bb7, unwind: bb9]; // scope 1 at $DIR/uniform_array_move_out.rs:+3:1: +3:2\n     }"}, {"sha": "1fd1eb128511bee3f7e2e7e898e19ef69f18f9a1", "filename": "src/test/ui/borrowck/bindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fbindings-after-at-or-patterns-slice-patterns-box-patterns.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -23,7 +23,7 @@ LL | fn bindings_after_at_slice_patterns_move_binding(x: [String; 4]) {\n    |                                                  - move occurs because `x` has type `[String; 4]`, which does not implement the `Copy` trait\n LL |     match x {\n LL |         a @ [.., _] => (),\n-   |         ----------- value moved here\n+   |         - value moved here\n ...\n LL |     &x;\n    |     ^^ value borrowed here after move\n@@ -32,7 +32,7 @@ error[E0502]: cannot borrow `x` as immutable because it is also borrowed as muta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:28:5\n    |\n LL |         ref mut foo @ [.., _] => Some(foo),\n-   |         --------------------- mutable borrow occurs here\n+   |         ----------- mutable borrow occurs here\n ...\n LL |     &x;\n    |     ^^ immutable borrow occurs here\n@@ -44,7 +44,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:50:5\n    |\n LL |         [ref foo @ .., ref bar] => Some(foo),\n-   |          ------------ immutable borrow occurs here\n+   |          ------- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -56,7 +56,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:62:5\n    |\n LL |         ref foo @ [.., ref bar] => Some(foo),\n-   |         ----------------------- immutable borrow occurs here\n+   |         ------- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -71,7 +71,7 @@ LL | fn bindings_after_at_or_patterns_move(x: Option<Test>) {\n    |                                       - move occurs because `x` has type `Option<Test>`, which does not implement the `Copy` trait\n LL |     match x {\n LL |         foo @ Some(Test::Foo | Test::Bar) => (),\n-   |         ---------------------------------\n+   |         ---\n    |         |\n    |         value moved here\n    |         value moved here\n@@ -83,7 +83,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:86:5\n    |\n LL |         ref foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n-   |         ------------------------------------- immutable borrow occurs here\n+   |         ------- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -95,7 +95,7 @@ error[E0502]: cannot borrow `x` as immutable because it is also borrowed as muta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:98:5\n    |\n LL |         ref mut foo @ Some(Test::Foo | Test::Bar) => Some(foo),\n-   |         ----------------------------------------- mutable borrow occurs here\n+   |         ----------- mutable borrow occurs here\n ...\n LL |     &x;\n    |     ^^ immutable borrow occurs here\n@@ -107,7 +107,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:112:5\n    |\n LL |         ref foo @ Some(box ref s) => Some(foo),\n-   |         ------------------------- immutable borrow occurs here\n+   |         ------- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -122,7 +122,7 @@ LL | fn bindings_after_at_slice_patterns_or_patterns_moves(x: [Option<Test>; 4])\n    |                                                       - move occurs because `x` has type `[Option<Test>; 4]`, which does not implement the `Copy` trait\n LL |     match x {\n LL |         a @ [.., Some(Test::Foo | Test::Bar)] => (),\n-   |         -------------------------------------\n+   |         -\n    |         |\n    |         value moved here\n    |         value moved here\n@@ -134,7 +134,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:144:5\n    |\n LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(a),\n-   |         ------------------------------------------------- immutable borrow occurs here\n+   |         ----- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -146,7 +146,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:156:5\n    |\n LL |         ref a @ [ref b @ .., Some(Test::Foo | Test::Bar)] => Some(b),\n-   |                  ---------- immutable borrow occurs here\n+   |                  ----- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -158,7 +158,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:170:5\n    |\n LL |         [_, ref a @ Some(box ref b), ..] => Some(a),\n-   |             ----------------------- immutable borrow occurs here\n+   |             ----- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -170,7 +170,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:186:5\n    |\n LL |         [_, ref a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n-   |             ------------------------------------------- immutable borrow occurs here\n+   |             ----- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here\n@@ -182,7 +182,7 @@ error[E0502]: cannot borrow `x` as immutable because it is also borrowed as muta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:200:5\n    |\n LL |         [_, ref mut a @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n-   |             ----------------------------------------------- mutable borrow occurs here\n+   |             --------- mutable borrow occurs here\n ...\n LL |     &x;\n    |     ^^ immutable borrow occurs here\n@@ -194,7 +194,7 @@ error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immuta\n   --> $DIR/bindings-after-at-or-patterns-slice-patterns-box-patterns.rs:214:5\n    |\n LL |         ref a @ [_, ref b @ Some(box Test::Foo | box Test::Bar), ..] => Some(a),\n-   |         ------------------------------------------------------------ immutable borrow occurs here\n+   |         ----- immutable borrow occurs here\n ...\n LL |     &mut x;\n    |     ^^^^^^ mutable borrow occurs here"}, {"sha": "2c1b9c10d4660dc0cd71e3931f2224d2dd9592a5", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -200,7 +200,7 @@ LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n LL |         match v {\n LL |             &[x @ ..] => println!(\"{:?}\", x),\n-   |               ^^^^^^ use of borrowed `v`\n+   |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -212,7 +212,7 @@ LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n LL |             &[_, x @ ..] => println!(\"{:?}\", x),\n-   |                  ^^^^^^ use of borrowed `v`\n+   |                  ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -224,7 +224,7 @@ LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n LL |             &[x @ .., _] => println!(\"{:?}\", x),\n-   |               ^^^^^^ use of borrowed `v`\n+   |               ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here\n@@ -236,7 +236,7 @@ LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n ...\n LL |             &[_, x @ .., _] => println!(\"{:?}\", x),\n-   |                  ^^^^^^ use of borrowed `v`\n+   |                  ^ use of borrowed `v`\n ...\n LL |         drop(x);\n    |              - borrow later used here"}, {"sha": "346b82a2666442d47f9116393cf294deb80d20cf", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-match.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -79,7 +79,7 @@ error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-match.rs:89:11\n    |\n LL |         [_y @ .., _, _] => {}\n-   |          ------- value moved here\n+   |          -- value moved here\n ...\n LL |         [(_x, _), _, _] => {}\n    |           ^^ value used here after move\n@@ -90,7 +90,7 @@ error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array-match.rs:99:15\n    |\n LL |         [_, _, _y @ ..] => {}\n-   |                ------- value moved here\n+   |                -- value moved here\n ...\n LL |         [.., (_x, _)] => {}\n    |               ^^ value used here after move\n@@ -101,7 +101,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-match.rs:110:11\n    |\n LL |         [x @ .., _] => {}\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move"}, {"sha": "6c6a25c251e700917af065713bfebf0d4259a24d", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap-match.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -68,7 +68,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:85:11\n    |\n LL |         [_, _y @ ..] => {}\n-   |             ------- value partially moved here\n+   |             -- value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move\n@@ -79,7 +79,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:96:11\n    |\n LL |         [_y @ .., _] => {}\n-   |          ------- value partially moved here\n+   |          -- value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move\n@@ -90,7 +90,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:109:11\n    |\n LL |         [x @ .., _, _] => {}\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move"}, {"sha": "77702e145df816fb85cdb6aac915a0853efa0bba", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-match.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -79,7 +79,7 @@ error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:89:11\n    |\n LL |         [_y @ .., _, _] => {}\n-   |          ------- value moved here\n+   |          -- value moved here\n ...\n LL |         [(ref _x, _), _, _] => {}\n    |           ^^^^^^ value borrowed here after move\n@@ -90,7 +90,7 @@ error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:99:15\n    |\n LL |         [_, _, _y @ ..] => {}\n-   |                ------- value moved here\n+   |                -- value moved here\n ...\n LL |         [.., (ref _x, _)] => {}\n    |               ^^^^^^ value borrowed here after move\n@@ -101,7 +101,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:110:11\n    |\n LL |         [x @ .., _] => {}\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move\n@@ -134,7 +134,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:139:5\n    |\n LL |         [_, _, _x @ ..] => {}\n-   |                ------- value partially moved here\n+   |                -- value partially moved here\n LL |     }\n LL |     a[0] = Default::default();\n    |     ^^^^ value used here after partial move\n@@ -145,7 +145,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-match.rs:147:5\n    |\n LL |         [_, _, _x @ ..] => {}\n-   |                ------- value partially moved here\n+   |                -- value partially moved here\n LL |     }\n LL |     a[0].1 = Default::default();\n    |     ^^^^ value used here after partial move"}, {"sha": "6cc2c2f7a984c7ba34275f88e826717edf4f4b25", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap-match.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -68,7 +68,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:85:11\n    |\n LL |         [_, _y @ ..] => {}\n-   |             ------- value partially moved here\n+   |             -- value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move\n@@ -79,7 +79,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:96:11\n    |\n LL |         [_y @ .., _] => {}\n-   |          ------- value partially moved here\n+   |          -- value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move\n@@ -90,7 +90,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:109:11\n    |\n LL |         [x @ .., _, _] => {}\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     }\n LL |     match a {\n    |           ^ value used here after partial move"}, {"sha": "9add7553afa70917c9b51c8cac20f391e07e9f9f", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -34,7 +34,7 @@ error[E0382]: borrow of partially moved value: `a`\n LL |     let [_x, _, _] = a;\n    |          -- value partially moved here\n LL |     let [ref _y @ .., _, _] = a;\n-   |          ^^^^^^^^^^^ value borrowed here after partial move\n+   |          ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n \n@@ -44,7 +44,7 @@ error[E0382]: borrow of partially moved value: `a`\n LL |     let [.., _x] = a;\n    |              -- value partially moved here\n LL |     let [_, _, ref _y @ ..] = a;\n-   |                ^^^^^^^^^^^ value borrowed here after partial move\n+   |                ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n \n@@ -54,7 +54,7 @@ error[E0382]: borrow of partially moved value: `a`\n LL |     let [(_x, _), _, _] = a;\n    |           -- value partially moved here\n LL |     let [ref _y @ .., _, _] = a;\n-   |          ^^^^^^^^^^^ value borrowed here after partial move\n+   |          ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n \n@@ -64,15 +64,15 @@ error[E0382]: borrow of partially moved value: `a`\n LL |     let [.., (_x, _)] = a;\n    |               -- value partially moved here\n LL |     let [_, _, ref _y @ ..] = a;\n-   |                ^^^^^^^^^^^ value borrowed here after partial move\n+   |                ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use.rs:54:11\n    |\n LL |     let [_y @ .., _, _] = a;\n-   |          ------- value moved here\n+   |          -- value moved here\n LL |     let [(ref _x, _), _, _] = a;\n    |           ^^^^^^ value borrowed here after move\n    |\n@@ -82,7 +82,7 @@ error[E0382]: borrow of moved value: `a[..]`\n   --> $DIR/borrowck-move-out-from-array-use.rs:60:15\n    |\n LL |     let [_, _, _y @ ..] = a;\n-   |                ------- value moved here\n+   |                -- value moved here\n LL |     let [.., (ref _x, _)] = a;\n    |               ^^^^^^ value borrowed here after move\n    |\n@@ -92,9 +92,9 @@ error[E0382]: borrow of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:68:13\n    |\n LL |     let [x @ .., _] = a;\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     let [_, ref _y @ ..] = a;\n-   |             ^^^^^^^^^^^ value borrowed here after partial move\n+   |             ^^^^^^ value borrowed here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n \n@@ -122,7 +122,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:88:5\n    |\n LL |     let [_, _, _x @ ..] = a;\n-   |                ------- value partially moved here\n+   |                -- value partially moved here\n LL |     a[0] = Default::default();\n    |     ^^^^ value used here after partial move\n    |\n@@ -132,7 +132,7 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array-use.rs:94:5\n    |\n LL |     let [_, _, _x @ ..] = a;\n-   |                ------- value partially moved here\n+   |                -- value partially moved here\n LL |     a[0].1 = Default::default();\n    |     ^^^^ value used here after partial move\n    |"}, {"sha": "363effcfe5322a579be2a699d6763eb91cacc58e", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -34,7 +34,7 @@ error[E0382]: use of partially moved value: `a`\n LL |     let [_x, _, _] = a;\n    |          -- value partially moved here\n LL |     let [_y @ .., _, _] = a;\n-   |          ^^^^^^^ value used here after partial move\n+   |          ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n \n@@ -44,7 +44,7 @@ error[E0382]: use of partially moved value: `a`\n LL |     let [.., _x] = a;\n    |              -- value partially moved here\n LL |     let [_, _, _y @ ..] = a;\n-   |                ^^^^^^^ value used here after partial move\n+   |                ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n \n@@ -54,7 +54,7 @@ error[E0382]: use of partially moved value: `a`\n LL |     let [(_x, _), _, _] = a;\n    |           -- value partially moved here\n LL |     let [_y @ .., _, _] = a;\n-   |          ^^^^^^^ value used here after partial move\n+   |          ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n \n@@ -64,15 +64,15 @@ error[E0382]: use of partially moved value: `a`\n LL |     let [.., (_x, _)] = a;\n    |               -- value partially moved here\n LL |     let [_, _, _y @ ..] = a;\n-   |                ^^^^^^^ value used here after partial move\n+   |                ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..].0` has type `String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array.rs:54:11\n    |\n LL |     let [_y @ .., _, _] = a;\n-   |          ------- value moved here\n+   |          -- value moved here\n LL |     let [(_x, _), _, _] = a;\n    |           ^^ value used here after move\n    |\n@@ -82,7 +82,7 @@ error[E0382]: use of moved value: `a[..].0`\n   --> $DIR/borrowck-move-out-from-array.rs:60:15\n    |\n LL |     let [_, _, _y @ ..] = a;\n-   |                ------- value moved here\n+   |                -- value moved here\n LL |     let [.., (_x, _)] = a;\n    |               ^^ value used here after move\n    |\n@@ -92,9 +92,9 @@ error[E0382]: use of partially moved value: `a`\n   --> $DIR/borrowck-move-out-from-array.rs:68:13\n    |\n LL |     let [x @ .., _] = a;\n-   |          ------ value partially moved here\n+   |          - value partially moved here\n LL |     let [_, _y @ ..] = a;\n-   |             ^^^^^^^ value used here after partial move\n+   |             ^^ value used here after partial move\n    |\n    = note: partial move occurs because `a[..]` has type `(String, String)`, which does not implement the `Copy` trait\n "}, {"sha": "f4324110ccb8ef1eed24c416f85c8d3d34b5ebee", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -57,7 +57,7 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n LL |     let [ref first, ref second, ..] = *s;\n    |                     ---------- immutable borrow occurs here\n LL |     let [_, ref mut tail @ ..] = *s;\n-   |             ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |             ^^^^^^^^^^^^ mutable borrow occurs here\n LL |     nop(&[first, second]);\n    |                  ------ immutable borrow later used here\n \n@@ -67,17 +67,17 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n LL |     let [.., ref second, ref first] = *s;\n    |              ---------- immutable borrow occurs here\n LL |     let [ref mut tail @ .., _] = *s;\n-   |          ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |          ^^^^^^^^^^^^ mutable borrow occurs here\n LL |     nop(&[first, second]);\n    |                  ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-slice-pattern-element-loan-array.rs:46:10\n    |\n LL |     let [_,  ref s1 @ ..] = *s;\n-   |              ----------- immutable borrow occurs here\n+   |              ------ immutable borrow occurs here\n LL |     let [ref mut s2 @ .., _, _] = *s;\n-   |          ^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |          ^^^^^^^^^^ mutable borrow occurs here\n LL |     nop_subslice(s1);\n    |                  -- immutable borrow later used here\n "}, {"sha": "f9a63bd49dd57d0f18349da122a6e8d79147aba4", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -88,7 +88,7 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n LL |         if let [_, ref mut tail @ ..] = *s {\n-   |                    ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |                    ^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n@@ -98,17 +98,17 @@ error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as im\n LL |     if let [.., ref second, ref first] = *s {\n    |                 ---------- immutable borrow occurs here\n LL |         if let [ref mut tail @ .., _] = *s {\n-   |                 ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |                 ^^^^^^^^^^^^ mutable borrow occurs here\n LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n   --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:65:17\n    |\n LL |     if let [_, _, _, ref s1 @ ..] = *s {\n-   |                      ----------- immutable borrow occurs here\n+   |                      ------ immutable borrow occurs here\n LL |         if let [ref mut s2 @ .., _, _, _] = *s {\n-   |                 ^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |                 ^^^^^^^^^^ mutable borrow occurs here\n LL |             nop_subslice(s1);\n    |                          -- immutable borrow later used here\n "}, {"sha": "0ac7df944d78114ad1de4c57ea5eaac14fa2a8d7", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-move-tail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,7 +2,7 @@ error[E0506]: cannot assign to `a[_]` because it is borrowed\n   --> $DIR/borrowck-vec-pattern-move-tail.rs:8:5\n    |\n LL |         [1, 2, ref tail @ ..] => tail,\n-   |                ------------- borrow of `a[_]` occurs here\n+   |                -------- borrow of `a[_]` occurs here\n ...\n LL |     a[2] = 0;\n    |     ^^^^^^^^ assignment to borrowed `a[_]` occurs here"}, {"sha": "c3bcb7de65daa8fd07550695aaeaafae769f60a9", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -14,7 +14,7 @@ error[E0506]: cannot assign to `vec[_]` because it is borrowed\n   --> $DIR/borrowck-vec-pattern-nesting.rs:23:13\n    |\n LL |         &mut [ref _b @ ..] => {\n-   |               ----------- borrow of `vec[_]` occurs here\n+   |               ------ borrow of `vec[_]` occurs here\n LL |\n LL |             vec[0] = Box::new(4);\n    |             ^^^^^^ assignment to borrowed `vec[_]` occurs here"}, {"sha": "0caa0b83a4c7cbe00939ab4cc0ed8a43ec7de3db", "filename": "src/test/ui/moves/move-out-of-array-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-array-ref.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -13,7 +13,7 @@ error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:13:27\n    |\n LL |     let [_, s @ .. , _] = *a;\n-   |             ------        ^^\n+   |             -             ^^\n    |             |             |\n    |             |             cannot move out of here\n    |             |             help: consider borrowing here: `&*a`\n@@ -35,7 +35,7 @@ error[E0508]: cannot move out of type `[D; 4]`, a non-copy array\n   --> $DIR/move-out-of-array-ref.rs:23:27\n    |\n LL |     let [_, s @ .. , _] = *a;\n-   |             ------        ^^\n+   |             -             ^^\n    |             |             |\n    |             |             cannot move out of here\n    |             |             help: consider borrowing here: `&*a`"}, {"sha": "93b0dcfc2d18af210bd8307640d65d7414e2ff24", "filename": "src/test/ui/moves/move-out-of-slice-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmove-out-of-slice-2.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -14,7 +14,7 @@ LL |     match *a {\n    |           ^^ cannot move out of here\n LL |\n LL |         [a @ ..] => {}\n-   |          ------\n+   |          -\n    |          |\n    |          data moved here\n    |          move occurs because `a` has type `[A]`, which does not implement the `Copy` trait\n@@ -26,7 +26,7 @@ LL |     match *b {\n    |           ^^ cannot move out of here\n LL |\n LL |         [_, _, b @ .., _] => {}\n-   |                ------\n+   |                -\n    |                |\n    |                data moved here\n    |                move occurs because `b` has type `[A]`, which does not implement the `Copy` trait\n@@ -38,7 +38,7 @@ LL |     match *c {\n    |           ^^ cannot move out of here\n LL |\n LL |         [c @ ..] => {}\n-   |          ------\n+   |          -\n    |          |\n    |          data moved here\n    |          move occurs because `c` has type `[C]`, which does not implement the `Copy` trait\n@@ -50,7 +50,7 @@ LL |     match *d {\n    |           ^^ cannot move out of here\n LL |\n LL |         [_, _, d @ .., _] => {}\n-   |                ------\n+   |                -\n    |                |\n    |                data moved here\n    |                move occurs because `d` has type `[C]`, which does not implement the `Copy` trait"}, {"sha": "dcb6f9fec18b6eb94aec31ecd326569227f1674c", "filename": "src/test/ui/nll/issue-51244.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fnll%2Fissue-51244.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fnll%2Fissue-51244.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51244.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,7 +2,7 @@ error[E0594]: cannot assign to `*my_ref`, which is behind a `&` reference\n   --> $DIR/issue-51244.rs:3:5\n    |\n LL |     let ref my_ref @ _ = 0;\n-   |         -------------- help: consider changing this to be a mutable reference: `ref mut my_ref @ _`\n+   |         ---------- help: consider changing this to be a mutable reference: `ref mut my_ref`\n LL |     *my_ref = 0;\n    |     ^^^^^^^^^^^ `my_ref` is a `&` reference, so the data it refers to cannot be written\n "}, {"sha": "fad84dda0e192ea46dec8291315542d205cb6585", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-neither-can-live-while-the-other-survives-1.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-neither-can-live-while-the-other-survives-1.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -40,9 +40,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:12:14\n    |\n LL |         Some(ref _y @ _z) => {}\n-   |              ^^^^^^^^^--\n-   |              |        |\n-   |              |        value moved here\n+   |              ^^^^^^   -- value moved here\n+   |              |\n    |              value borrowed here after move\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait\n@@ -55,9 +54,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/bind-by-move-neither-can-live-while-the-other-survives-1.rs:26:14\n    |\n LL |         Some(ref mut _y @ _z) => {}\n-   |              ^^^^^^^^^^^^^--\n-   |              |            |\n-   |              |            value moved here\n+   |              ^^^^^^^^^^   -- value moved here\n+   |              |\n    |              value borrowed here after move\n    |\n    = note: move occurs because value has type `X`, which does not implement the `Copy` trait"}, {"sha": "a481ca46833827fc64cc0ee58cc6b23f4a2ca246", "filename": "src/test/ui/pattern/bindings-after-at/bind-by-move-no-subbindings-fun-param.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fbind-by-move-no-subbindings-fun-param.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,9 +2,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/bind-by-move-no-subbindings-fun-param.rs:7:6\n    |\n LL | fn f(a @ A(u): A) -> Box<u8> {\n-   |      ^^^^^^-^\n-   |      |     |\n-   |      |     value partially moved here\n+   |      ^     - value partially moved here\n+   |      |\n    |      value used here after partial move\n    |\n    = note: partial move occurs because value has type `Box<u8>`, which does not implement the `Copy` trait"}, {"sha": "83751843b1b81b09741d51eac2d4a17e802d1d94", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.stderr", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-move-and-move.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,7 +2,7 @@ error[E0382]: use of moved value\n   --> $DIR/borrowck-move-and-move.rs:11:9\n    |\n LL |     let a @ b = U;\n-   |         ^^^^-   - move occurs because value has type `U`, which does not implement the `Copy` trait\n+   |         ^   -   - move occurs because value has type `U`, which does not implement the `Copy` trait\n    |         |   |\n    |         |   value moved here\n    |         value used here after move\n@@ -11,9 +11,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:13:9\n    |\n LL |     let a @ (b, c) = (U, U);\n-   |         ^^^^^^^^-^\n-   |         |       |\n-   |         |       value partially moved here\n+   |         ^       - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -22,9 +21,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:15:9\n    |\n LL |     let a @ (b, c) = (u(), u());\n-   |         ^^^^^^^^-^\n-   |         |       |\n-   |         |       value partially moved here\n+   |         ^       - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -35,9 +33,8 @@ error[E0382]: use of moved value\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `Result<U, U>`, which does not implement the `Copy` trait\n LL |         a @ Ok(b) | a @ Err(b) => {}\n-   |         -------^-\n-   |         |      |\n-   |         |      value used here after move\n+   |         -      ^ value used here after move\n+   |         |\n    |         value moved here\n \n error[E0382]: use of moved value\n@@ -46,18 +43,16 @@ error[E0382]: use of moved value\n LL |     match Ok(U) {\n    |           ----- move occurs because value has type `Result<U, U>`, which does not implement the `Copy` trait\n LL |         a @ Ok(b) | a @ Err(b) => {}\n-   |                     --------^-\n-   |                     |       |\n-   |                     |       value used here after move\n+   |                     -       ^ value used here after move\n+   |                     |\n    |                     value moved here\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:25:9\n    |\n LL |         xs @ [a, .., b] => {}\n-   |         ^^^^^^^^^^^^^-^\n-   |         |            |\n-   |         |            value partially moved here\n+   |         ^^           - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -66,9 +61,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/borrowck-move-and-move.rs:29:9\n    |\n LL |         xs @ [_, ys @ .., _] => {}\n-   |         ^^^^^^^^^-------^^^^\n-   |         |        |\n-   |         |        value partially moved here\n+   |         ^^       -- value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -77,7 +71,7 @@ error[E0382]: use of moved value\n   --> $DIR/borrowck-move-and-move.rs:22:12\n    |\n LL |     fn fun(a @ b: U) {}\n-   |            ^^^^-\n+   |            ^----\n    |            |   |\n    |            |   value moved here\n    |            value used here after move"}, {"sha": "002c7609f61093c6c3c499a14a7a6f88c7ffc1d1", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.stderr", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-at-and-box.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -74,9 +74,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-at-and-box.rs:31:9\n    |\n LL |     let ref a @ box b = Box::new(NC);\n-   |         ^^^^^^^^^^^^-\n-   |         |           |\n-   |         |           value moved here\n+   |         ^^^^^       - value moved here\n+   |         |\n    |         value borrowed here after move\n    |\n    = note: move occurs because value has type `NC`, which does not implement the `Copy` trait\n@@ -85,9 +84,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-at-and-box.rs:38:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n-   |         ^^^^^^^^^^^^---------\n-   |         |           |\n-   |         |           mutable borrow occurs here\n+   |         ^^^^^       --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |     *b = NC;\n@@ -97,9 +95,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-at-and-box.rs:42:9\n    |\n LL |     let ref a @ box ref mut b = Box::new(NC);\n-   |         ^^^^^^^^^^^^---------\n-   |         |           |\n-   |         |           mutable borrow occurs here\n+   |         ^^^^^       --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |     *b = NC;\n@@ -109,9 +106,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-at-and-box.rs:48:9\n    |\n LL |     let ref mut a @ box ref b = Box::new(NC);\n-   |         ^^^^^^^^^^^^^^^^-----\n-   |         |               |\n-   |         |               immutable borrow occurs here\n+   |         ^^^^^^^^^       ----- immutable borrow occurs here\n+   |         |\n    |         mutable borrow occurs here\n ...\n LL |     drop(b);\n@@ -121,9 +117,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-at-and-box.rs:62:9\n    |\n LL |         ref mut a @ box ref b => {\n-   |         ^^^^^^^^^^^^^^^^-----\n-   |         |               |\n-   |         |               immutable borrow occurs here\n+   |         ^^^^^^^^^       ----- immutable borrow occurs here\n+   |         |\n    |         mutable borrow occurs here\n ...\n LL |             drop(b);\n@@ -133,9 +128,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-at-and-box.rs:54:11\n    |\n LL |     fn f5(ref mut a @ box ref b: Box<NC>) {\n-   |           ^^^^^^^^^^^^^^^^-----\n-   |           |               |\n-   |           |               immutable borrow occurs here\n+   |           ^^^^^^^^^       ----- immutable borrow occurs here\n+   |           |\n    |           mutable borrow occurs here\n ...\n LL |         drop(b);"}, {"sha": "a9e66de084242f560ae2e78d0683f85fc44ca4b1", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref-inverse.stderr", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref-inverse.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -262,9 +262,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:24:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (U, U);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^---------^\n-   |         |                       |\n-   |         |                       value partially moved here\n+   |         ^                       - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -273,9 +272,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:33:9\n    |\n LL |     let a @ (mut b @ ref mut c, d @ ref e) = (u(), u());\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^---------^\n-   |         |                       |\n-   |         |                       value partially moved here\n+   |         ^                       - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -286,20 +284,16 @@ error[E0382]: use of moved value\n LL |     match Some((U, U)) {\n    |           ------------ move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |         -----------------------------^^^^^^^^^--\n-   |         |                            |\n-   |         |                            value used here after move\n-   |         value moved here\n+   |         - value moved here           ^ value used here after move\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:55:30\n    |\n LL |     match Some([U, U]) {\n    |           ------------ move occurs because value has type `Option<[U; 2]>`, which does not implement the `Copy` trait\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n-   |         ---------------------^^^^^^^^^--\n-   |         |                    |\n-   |         |                    value borrowed here after move\n+   |         -----                ^^^^^^^^^ value borrowed here after move\n+   |         |\n    |         value moved here\n \n error[E0382]: borrow of moved value\n@@ -308,9 +302,8 @@ error[E0382]: borrow of moved value\n LL |     match Some(u()) {\n    |           --------- move occurs because value has type `Option<U>`, which does not implement the `Copy` trait\n LL |         a @ Some(ref b) => {}\n-   |         ---------^^^^^-\n-   |         |        |\n-   |         |        value borrowed here after move\n+   |         -        ^^^^^ value borrowed here after move\n+   |         |\n    |         value moved here\n \n error[E0382]: use of moved value\n@@ -319,29 +312,24 @@ error[E0382]: use of moved value\n LL |     match Some((u(), u())) {\n    |           ---------------- move occurs because value has type `Option<(U, U)>`, which does not implement the `Copy` trait\n LL |         a @ Some((mut b @ ref mut c, d @ ref e)) => {}\n-   |         -----------------------------^^^^^^^^^--\n-   |         |                            |\n-   |         |                            value used here after move\n-   |         value moved here\n+   |         - value moved here           ^ value used here after move\n \n error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:75:30\n    |\n LL |     match Some([u(), u()]) {\n    |           ---------------- move occurs because value has type `Option<[U; 2]>`, which does not implement the `Copy` trait\n LL |         mut a @ Some([ref b, ref mut c]) => {}\n-   |         ---------------------^^^^^^^^^--\n-   |         |                    |\n-   |         |                    value borrowed here after move\n+   |         -----                ^^^^^^^^^ value borrowed here after move\n+   |         |\n    |         value moved here\n \n error[E0382]: use of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref-inverse.rs:14:11\n    |\n LL |     fn f2(mut a @ (b @ ref c, mut d @ ref e): (U, U)) {}\n-   |           ^^^^^^^^^^^^^^^^^^^^-------------^\n-   |           |                   |\n-   |           |                   value partially moved here\n+   |           ^^^^^               ----- value partially moved here\n+   |           |\n    |           value used here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait"}, {"sha": "e03a9298214e4b55281bd21e0b50563fbd5c11e3", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-by-move-and-ref.stderr", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-by-move-and-ref.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -237,9 +237,8 @@ error[E0382]: borrow of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:30:9\n    |\n LL |     let ref mut a @ [b, mut c] = [U, U];\n-   |         ^^^^^^^^^^^^^^^^-----^\n-   |         |               |\n-   |         |               value partially moved here\n+   |         ^^^^^^^^^       ----- value partially moved here\n+   |         |\n    |         value borrowed here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -248,7 +247,7 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:33:9\n    |\n LL |     let ref a @ b = u();\n-   |         ^^^^^^^^-   --- move occurs because value has type `U`, which does not implement the `Copy` trait\n+   |         ^^^^^   -   --- move occurs because value has type `U`, which does not implement the `Copy` trait\n    |         |       |\n    |         |       value moved here\n    |         value borrowed here after move\n@@ -257,9 +256,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:18\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n-   |                  ^^^^^^^^-----\n-   |                  |       |\n-   |                  |       value moved here\n+   |                  ^^^^^   ----- value moved here\n+   |                  |\n    |                  value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -268,9 +266,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:36:33\n    |\n LL |     let ref a @ (ref b @ mut c, ref d @ e) = (u(), u());\n-   |                                 ^^^^^^^^-\n-   |                                 |       |\n-   |                                 |       value moved here\n+   |                                 ^^^^^   - value moved here\n+   |                                 |\n    |                                 value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -279,9 +276,8 @@ error[E0382]: borrow of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:42:9\n    |\n LL |     let ref mut a @ [b, mut c] = [u(), u()];\n-   |         ^^^^^^^^^^^^^^^^-----^\n-   |         |               |\n-   |         |               value partially moved here\n+   |         ^^^^^^^^^       ----- value partially moved here\n+   |         |\n    |         value borrowed here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -290,9 +286,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:23\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                       ^^^^^^^^-----\n-   |                       |       |\n-   |                       |       value moved here\n+   |                       ^^^^^   ----- value moved here\n+   |                       |\n    |                       value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -305,9 +300,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:69:38\n    |\n LL |         ref a @ Some((ref b @ mut c, ref d @ e)) => {}\n-   |                                      ^^^^^^^^-\n-   |                                      |       |\n-   |                                      |       value moved here\n+   |                                      ^^^^^   - value moved here\n+   |                                      |\n    |                                      value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -320,7 +314,7 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:11:11\n    |\n LL |     fn f1(ref a @ b: U) {}\n-   |           ^^^^^^^^-\n+   |           ^^^^^----\n    |           |       |\n    |           |       value moved here\n    |           value borrowed here after move\n@@ -330,9 +324,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:20\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n-   |                    ^^^^^^^^-----\n-   |                    |       |\n-   |                    |       value moved here\n+   |                    ^^^^^   ----- value moved here\n+   |                    |\n    |                    value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -341,9 +334,8 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:14:35\n    |\n LL |     fn f2(ref a @ (ref b @ mut c, ref d @ e): (U, U)) {}\n-   |                                   ^^^^^^^^-\n-   |                                   |       |\n-   |                                   |       value moved here\n+   |                                   ^^^^^   - value moved here\n+   |                                   |\n    |                                   value borrowed here after move\n    |\n    = note: move occurs because value has type `U`, which does not implement the `Copy` trait\n@@ -352,9 +344,8 @@ error[E0382]: borrow of partially moved value\n   --> $DIR/borrowck-pat-by-move-and-ref.rs:20:11\n    |\n LL |     fn f3(ref mut a @ [b, mut c]: [U; 2]) {}\n-   |           ^^^^^^^^^^^^^^^^-----^\n-   |           |               |\n-   |           |               value partially moved here\n+   |           ^^^^^^^^^       ----- value partially moved here\n+   |           |\n    |           value borrowed here after partial move\n    |\n    = note: partial move occurs because value has type `U`, which does not implement the `Copy` trait"}, {"sha": "9fd5e229afd0a2fd4d5bf0d01efcfbd93496e789", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.stderr", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-and-ref.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -298,9 +298,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:8:31\n    |\n LL |         ref mut z @ &mut Some(ref a) => {\n-   |         ----------------------^^^^^-\n-   |         |                     |\n-   |         |                     immutable borrow occurs here\n+   |         ---------             ^^^^^ immutable borrow occurs here\n+   |         |\n    |         mutable borrow occurs here\n ...\n LL |             **z = None;\n@@ -310,9 +309,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:46:9\n    |\n LL |     let ref mut a @ ref b = u();\n-   |         ^^^^^^^^^^^^-----\n-   |         |           |\n-   |         |           immutable borrow occurs here\n+   |         ^^^^^^^^^   ----- immutable borrow occurs here\n+   |         |\n    |         mutable borrow occurs here\n ...\n LL |     drop(b);\n@@ -322,9 +320,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:51:9\n    |\n LL |     let ref a @ ref mut b = u();\n-   |         ^^^^^^^^---------\n-   |         |       |\n-   |         |       mutable borrow occurs here\n+   |         ^^^^^   --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |     *b = u();\n@@ -334,9 +331,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:20\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n-   |         -----------^^^^^^^^^-\n-   |         |          |\n-   |         |          mutable borrow occurs here\n+   |         -----      ^^^^^^^^^ mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |             drop(a);\n@@ -346,9 +342,8 @@ error[E0502]: cannot borrow value as mutable because it is also borrowed as immu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:76:45\n    |\n LL |         ref a @ Ok(ref mut b) | ref a @ Err(ref mut b) => {\n-   |                                 ------------^^^^^^^^^-\n-   |                                 |           |\n-   |                                 |           mutable borrow occurs here\n+   |                                 -----       ^^^^^^^^^ mutable borrow occurs here\n+   |                                 |\n    |                                 immutable borrow occurs here\n ...\n LL |             drop(a);\n@@ -406,9 +401,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:117:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         ^^^^^^^^^---------^^^^^^^^^^^^\n-   |         |        |\n-   |         |        mutable borrow occurs here\n+   |         ^^^^^    --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |     *b = U;\n@@ -418,9 +412,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:123:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         ^^^^^^^^^---------^^^^^^^^^^^^\n-   |         |        |\n-   |         |        mutable borrow occurs here\n+   |         ^^^^^    --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n ...\n LL |     *b = U;\n@@ -430,9 +423,8 @@ error[E0502]: cannot borrow value as immutable because it is also borrowed as mu\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:129:9\n    |\n LL |     let ref a @ (ref mut b, ref mut c) = (U, U);\n-   |         ^^^^^^^^^---------^^^^^^^^^^^^\n-   |         |        |\n-   |         |        mutable borrow occurs here\n+   |         ^^^^^    --------- mutable borrow occurs here\n+   |         |\n    |         immutable borrow occurs here\n LL |\n LL |     *b = U;\n@@ -442,7 +434,7 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-and-ref.rs:28:30\n    |\n LL |     fn f4_also_moved(ref a @ ref mut b @ c: U) {}\n-   |                      --------^^^^^^^^^^^^-\n+   |                      --------^^^^^^^^^----\n    |                      |       |           |\n    |                      |       |           value moved here\n    |                      |       value borrowed here after move"}, {"sha": "e47aea9c77e6c1bcf9ed4e8d4bed246f7c69879e", "filename": "src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.stderr", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fborrowck-pat-ref-mut-twice.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -262,9 +262,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:29:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ^^^^^^^^^^^^---------\n-   |         |           |\n-   |         |           first mutable borrow occurs here\n+   |         ^^^^^^^^^   --------- first mutable borrow occurs here\n+   |         |\n    |         second mutable borrow occurs here\n ...\n LL |     drop(b);\n@@ -274,9 +273,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:39:9\n    |\n LL |     let ref mut a @ ref mut b = U;\n-   |         ^^^^^^^^^^^^---------\n-   |         |           |\n-   |         |           first mutable borrow occurs here\n+   |         ^^^^^^^^^   --------- first mutable borrow occurs here\n+   |         |\n    |         second mutable borrow occurs here\n ...\n LL |     *b = U;\n@@ -286,9 +284,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------------^^^^^^^^^-\n-   |         |              |\n-   |         |              second mutable borrow occurs here\n+   |         ---------      ^^^^^^^^^ second mutable borrow occurs here\n+   |         |\n    |         first mutable borrow occurs here\n ...\n LL |             *a = Err(U);\n@@ -298,9 +295,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:89:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ----------------^^^^^^^^^-\n-   |                                     |               |\n-   |                                     |               second mutable borrow occurs here\n+   |                                     ---------       ^^^^^^^^^ second mutable borrow occurs here\n+   |                                     |\n    |                                     first mutable borrow occurs here\n ...\n LL |             *a = Err(U);\n@@ -310,9 +306,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:24\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |         ---------------^^^^^^^^^-\n-   |         |              |\n-   |         |              second mutable borrow occurs here\n+   |         ---------      ^^^^^^^^^ second mutable borrow occurs here\n+   |         |\n    |         first mutable borrow occurs here\n ...\n LL |             drop(a);\n@@ -322,9 +317,8 @@ error[E0499]: cannot borrow value as mutable more than once at a time\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:101:53\n    |\n LL |         ref mut a @ Ok(ref mut b) | ref mut a @ Err(ref mut b) => {\n-   |                                     ----------------^^^^^^^^^-\n-   |                                     |               |\n-   |                                     |               second mutable borrow occurs here\n+   |                                     ---------       ^^^^^^^^^ second mutable borrow occurs here\n+   |                                     |\n    |                                     first mutable borrow occurs here\n ...\n LL |             drop(a);\n@@ -334,7 +328,7 @@ error[E0382]: borrow of moved value\n   --> $DIR/borrowck-pat-ref-mut-twice.rs:21:34\n    |\n LL |     fn f4_also_moved(ref mut a @ ref mut b @ c: U) {}\n-   |                      ------------^^^^^^^^^^^^-\n+   |                      ------------^^^^^^^^^----\n    |                      |           |           |\n    |                      |           |           value moved here\n    |                      |           value borrowed here after move"}, {"sha": "cd3234952fa54c13db85096ca76839836285d706", "filename": "src/test/ui/pattern/bindings-after-at/copy-and-move-mixed.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fcopy-and-move-mixed.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -2,9 +2,8 @@ error[E0382]: use of partially moved value\n   --> $DIR/copy-and-move-mixed.rs:12:9\n    |\n LL |     let a @ NC(b, c @ NC(d, e)) = NC(C, NC(C, C));\n-   |         ^^^^^^^^^^------------^\n-   |         |         |\n-   |         |         value partially moved here\n+   |         ^         - value partially moved here\n+   |         |\n    |         value used here after partial move\n    |\n    = note: partial move occurs because value has type `NC<C, C>`, which does not implement the `Copy` trait"}, {"sha": "840a513d6c67d5595e4432f5067f09f33099c2a9", "filename": "src/test/ui/pattern/bindings-after-at/default-binding-modes-both-sides-independent.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fdefault-binding-modes-both-sides-independent.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -48,7 +48,7 @@ error[E0382]: borrow of moved value\n   --> $DIR/default-binding-modes-both-sides-independent.rs:29:9\n    |\n LL |     let ref mut a @ b = NotCopy;\n-   |         ^^^^^^^^^^^^-   ------- move occurs because value has type `NotCopy`, which does not implement the `Copy` trait\n+   |         ^^^^^^^^^   -   ------- move occurs because value has type `NotCopy`, which does not implement the `Copy` trait\n    |         |           |\n    |         |           value moved here\n    |         value borrowed here after move"}, {"sha": "70beb5d423223888072bf6072c552320a1d5c96b", "filename": "src/test/ui/pattern/bindings-after-at/nested-binding-modes-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fbindings-after-at%2Fnested-binding-modes-mut.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -11,7 +11,7 @@ error[E0596]: cannot borrow `not_mut` as mutable, as it is not declared as mutab\n   --> $DIR/nested-binding-modes-mut.rs:9:5\n    |\n LL |     let not_mut @ mut is_mut = 42;\n-   |         -------------------- help: consider changing this to be mutable: `mut not_mut`\n+   |         ------- help: consider changing this to be mutable: `mut not_mut`\n LL |     &mut is_mut;\n LL |     &mut not_mut;\n    |     ^^^^^^^^^^^^ cannot borrow as mutable"}, {"sha": "bac2db6ce825c5964f1aff96cffde29a513ebe1a", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -35,7 +35,7 @@ error[E0502]: cannot borrow `arr[..]` as mutable because it is also borrowed as\n   --> $DIR/borrowck-move-ref-pattern.rs:13:16\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n-   |                             ---------------- immutable borrow occurs here\n+   |                             ----------- immutable borrow occurs here\n ...\n LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n    |                ^^^^^^^^^^^ mutable borrow occurs here\n@@ -47,7 +47,7 @@ error[E0505]: cannot move out of `arr[..]` because it is borrowed\n   --> $DIR/borrowck-move-ref-pattern.rs:13:29\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n-   |                             ---------------- borrow of `arr[..]` occurs here\n+   |                             ----------- borrow of `arr[..]` occurs here\n ...\n LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n    |                             ^^^ move out of `arr[..]` occurs here\n@@ -59,7 +59,7 @@ error[E0505]: cannot move out of `arr[..]` because it is borrowed\n   --> $DIR/borrowck-move-ref-pattern.rs:13:34\n    |\n LL |     let [ref _x0_hold, _x1, ref xs_hold @ ..] = arr;\n-   |                             ---------------- borrow of `arr[..]` occurs here\n+   |                             ----------- borrow of `arr[..]` occurs here\n ...\n LL |     let [_, _, ref mut _x2, _x3, mut _x4] = arr;\n    |                                  ^^^^^^^ move out of `arr[..]` occurs here"}, {"sha": "4e68d6810e29b0101aca9f22d8c454f5bdc65c38", "filename": "src/tools/clippy/clippy_lints/src/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for Default {\n                 if adt.is_struct();\n                 let variant = adt.non_enum_variant();\n                 if adt.did().is_local() || !variant.is_field_list_non_exhaustive();\n-                let module_did = cx.tcx.parent_module(stmt.hir_id).to_def_id();\n+                let module_did = cx.tcx.parent_module(stmt.hir_id);\n                 if variant\n                     .fields\n                     .iter()"}, {"sha": "23c86482b46cb1186f9221d7c11f49c51cfea29d", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42244c2ab462a5ac4c901e8988f9fcb78776d9c/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=b42244c2ab462a5ac4c901e8988f9fcb78776d9c", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::hir::nested_filter;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{\n     self, Binder, BoundConstness, GenericParamDefKind, ImplPolarity, ParamEnv, PredicateKind, TraitPredicate, TraitRef,\n-    Ty, TyCtxt, Visibility,\n+    Ty, TyCtxt,\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n@@ -464,7 +464,7 @@ impl<'tcx> Visitor<'tcx> for UnsafeVisitor<'_, 'tcx> {\n fn check_partial_eq_without_eq<'tcx>(cx: &LateContext<'tcx>, span: Span, trait_ref: &hir::TraitRef<'_>, ty: Ty<'tcx>) {\n     if_chain! {\n         if let ty::Adt(adt, substs) = ty.kind();\n-        if cx.tcx.visibility(adt.did()) == Visibility::Public;\n+        if cx.tcx.visibility(adt.did()).is_public();\n         if let Some(eq_trait_def_id) = cx.tcx.get_diagnostic_item(sym::Eq);\n         if let Some(def_id) = trait_ref.trait_def_id();\n         if cx.tcx.is_diagnostic_item(sym::PartialEq, def_id);"}]}