{"sha": "cda3490f8fb099a1ddd1f253a75c29110042dc01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYTM0OTBmOGZiMDk5YTFkZGQxZjI1M2E3NWMyOTExMDA0MmRjMDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T15:44:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-19T15:44:41Z"}, "message": "Auto merge of #21269 - alexcrichton:issue-6936, r=pnkfelix\n\nThis commit modifies resolve to prevent conflicts with typedef names in the same\r\nmethod that conflits are prevented with enum names. This is a breaking change\r\ndue to the differing semantics in resolve, and any errors generated on behalf of\r\nthis change require that a conflicting typedef, module, or structure to be\r\nrenamed so they do not conflict.\r\n\r\n[breaking-change]\r\nCloses #6936", "tree": {"sha": "e45f373d63f312eee13369ad064b808f6c08e6d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e45f373d63f312eee13369ad064b808f6c08e6d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cda3490f8fb099a1ddd1f253a75c29110042dc01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cda3490f8fb099a1ddd1f253a75c29110042dc01", "html_url": "https://github.com/rust-lang/rust/commit/cda3490f8fb099a1ddd1f253a75c29110042dc01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cda3490f8fb099a1ddd1f253a75c29110042dc01/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43f2c199e4e87d7ccd15658c52ad8dc5a1d54fb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/43f2c199e4e87d7ccd15658c52ad8dc5a1d54fb9", "html_url": "https://github.com/rust-lang/rust/commit/43f2c199e4e87d7ccd15658c52ad8dc5a1d54fb9"}, {"sha": "3121c040438fcc9a14d028a5aca4a6892f7bcdcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3121c040438fcc9a14d028a5aca4a6892f7bcdcc", "html_url": "https://github.com/rust-lang/rust/commit/3121c040438fcc9a14d028a5aca4a6892f7bcdcc"}], "stats": {"total": 649, "additions": 341, "deletions": 308}, "files": [{"sha": "8a27cfc510f4a25dc21085a53c23dcc8584fe865", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -575,7 +575,7 @@ pub struct RawPointerDerive {\n impl RawPointerDerive {\n     pub fn new() -> RawPointerDerive {\n         RawPointerDerive {\n-            checked_raw_pointers: NodeSet::new(),\n+            checked_raw_pointers: NodeSet(),\n         }\n     }\n }\n@@ -1323,7 +1323,7 @@ impl UnusedMut {\n         // collect all mutable pattern and group their NodeIDs by their Identifier to\n         // avoid false warnings in match arms with multiple patterns\n \n-        let mut mutables = FnvHashMap::new();\n+        let mut mutables = FnvHashMap();\n         for p in pats.iter() {\n             pat_util::pat_bindings(&cx.tcx.def_map, &**p, |mode, id, _, path1| {\n                 let ident = path1.node;"}, {"sha": "de4efe09f2725986e593f047f2c873af8dcdaecc", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -98,9 +98,9 @@ impl LintStore {\n         LintStore {\n             lints: vec!(),\n             passes: Some(vec!()),\n-            by_name: FnvHashMap::new(),\n-            levels: FnvHashMap::new(),\n-            lint_groups: FnvHashMap::new(),\n+            by_name: FnvHashMap(),\n+            levels: FnvHashMap(),\n+            lint_groups: FnvHashMap(),\n         }\n     }\n \n@@ -468,7 +468,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             exported_items: exported_items,\n             lints: lint_store,\n             level_stack: vec![],\n-            node_levels: RefCell::new(FnvHashMap::new()),\n+            node_levels: RefCell::new(FnvHashMap()),\n         }\n     }\n "}, {"sha": "a928d1c902285df26fb56984fafa4a9d0cd21973", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -84,8 +84,8 @@ pub struct CStore {\n impl CStore {\n     pub fn new(intr: Rc<IdentInterner>) -> CStore {\n         CStore {\n-            metas: RefCell::new(FnvHashMap::new()),\n-            extern_mod_crate_map: RefCell::new(FnvHashMap::new()),\n+            metas: RefCell::new(FnvHashMap()),\n+            extern_mod_crate_map: RefCell::new(FnvHashMap()),\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),"}, {"sha": "5cbe97504281da432f6e5ae33e59b1525f72b199", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -2111,7 +2111,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: RefCell::new(encode_inlined_item),\n-        type_abbrevs: RefCell::new(FnvHashMap::new()),\n+        type_abbrevs: RefCell::new(FnvHashMap()),\n         reachable: reachable,\n      };\n \n@@ -2216,7 +2216,7 @@ pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,\n-        abbrevs: &RefCell::new(FnvHashMap::new())\n+        abbrevs: &RefCell::new(FnvHashMap())\n     }, t);\n     String::from_utf8(wr.unwrap()).unwrap()\n }"}, {"sha": "a1ac25a5650ef21bcd530d3e857fb2ce775c8465", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -46,7 +46,7 @@ pub fn construct(tcx: &ty::ctxt,\n     let block_exit;\n \n     let mut cfg_builder = CFGBuilder {\n-        exit_map: NodeMap::new(),\n+        exit_map: NodeMap(),\n         graph: graph,\n         fn_exit: fn_exit,\n         tcx: tcx,"}, {"sha": "9d3180864f283cf8cb7620487c27e5fdcab46055", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -64,10 +64,10 @@ struct GlobalChecker {\n \n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut checker = GlobalChecker {\n-        static_consumptions: NodeSet::new(),\n-        const_borrows: NodeSet::new(),\n-        static_interior_borrows: NodeSet::new(),\n-        static_local_borrows: NodeSet::new(),\n+        static_consumptions: NodeSet(),\n+        const_borrows: NodeSet(),\n+        static_interior_borrows: NodeSet(),\n+        static_local_borrows: NodeSet(),\n     };\n     {\n         let param_env = ty::empty_parameter_environment(tcx);"}, {"sha": "05dd47f5a367f07e4a7252cbf47333bd76dd6b61", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstEvalVisitor<'a, 'tcx> {\n pub fn process_crate(tcx: &ty::ctxt) {\n     visit::walk_crate(&mut ConstEvalVisitor {\n         tcx: tcx,\n-        ccache: DefIdMap::new(),\n+        ccache: DefIdMap(),\n     }, tcx.map.krate());\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "2b9bd1cd09fdb33d199060c0b069b9b3b94b13d7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n \n fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n                          cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n-    let mut index = NodeMap::new();\n+    let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in"}, {"sha": "95e6edd6dfe28bd9900565630fb5da0eccc26b46", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -137,7 +137,7 @@ fn calculate_type(sess: &session::Session,\n         config::CrateTypeExecutable | config::CrateTypeDylib => {},\n     }\n \n-    let mut formats = FnvHashMap::new();\n+    let mut formats = FnvHashMap();\n \n     // Sweep all crates for found dylibs. Add all dylibs, as well as their\n     // dependencies, ensuring there are no conflicts. The only valid case for a"}, {"sha": "f8f962cd86d2914872c6069e168fa48879877a8a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n            name: String,\n            map: &'a ConstraintMap<'tcx>) -> ConstraintGraph<'a, 'tcx> {\n         let mut i = 0;\n-        let mut node_ids = FnvHashMap::new();\n+        let mut node_ids = FnvHashMap();\n         {\n             let mut add_node = |&mut : node| {\n                 if let Vacant(e) = node_ids.entry(node) {\n@@ -188,7 +188,7 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n \n impl<'a, 'tcx> dot::GraphWalk<'a, Node, Edge> for ConstraintGraph<'a, 'tcx> {\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        let mut set = FnvHashSet::new();\n+        let mut set = FnvHashSet();\n         for constraint in self.map.keys() {\n             let (n1, n2) = constraint_to_nodes(constraint);\n             set.insert(n1);"}, {"sha": "0f487fffe5cb967178cf2dfb384e78c532879145", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -236,11 +236,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n             values: RefCell::new(None),\n-            constraints: RefCell::new(FnvHashMap::new()),\n+            constraints: RefCell::new(FnvHashMap()),\n             verifys: RefCell::new(Vec::new()),\n-            givens: RefCell::new(FnvHashSet::new()),\n-            lubs: RefCell::new(FnvHashMap::new()),\n-            glbs: RefCell::new(FnvHashMap::new()),\n+            givens: RefCell::new(FnvHashSet()),\n+            lubs: RefCell::new(FnvHashMap()),\n+            glbs: RefCell::new(FnvHashMap()),\n             skolemization_count: Cell::new(0),\n             bound_count: Cell::new(0),\n             undo_log: RefCell::new(Vec::new())\n@@ -1200,7 +1200,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                       values: &Vec<VarValue>,\n                                       errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n-        let mut reg_reg_dups = FnvHashSet::new();\n+        let mut reg_reg_dups = FnvHashSet();\n         for verify in self.verifys.borrow().iter() {\n             match *verify {\n                 VerifyRegSubReg(ref origin, sub, sup) => {\n@@ -1476,7 +1476,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             dup_found: bool\n         }\n         let mut state = WalkState {\n-            set: FnvHashSet::new(),\n+            set: FnvHashSet(),\n             stack: vec!(orig_node_idx),\n             result: Vec::new(),\n             dup_found: false"}, {"sha": "db6a4768857733d2c7a468d88a1424a40913919d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -167,7 +167,7 @@ impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n \n impl<'a> LanguageItemCollector<'a> {\n     pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n-        let mut item_refs = FnvHashMap::new();\n+        let mut item_refs = FnvHashMap();\n \n         $( item_refs.insert($name, $variant as uint); )*\n "}, {"sha": "27a0324a3c4135178d5d39096198c0aff9b95f00", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -277,9 +277,9 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             tcx: tcx,\n             num_live_nodes: 0,\n             num_vars: 0,\n-            live_node_map: NodeMap::new(),\n-            variable_map: NodeMap::new(),\n-            capture_info_map: NodeMap::new(),\n+            live_node_map: NodeMap(),\n+            variable_map: NodeMap(),\n+            capture_info_map: NodeMap(),\n             var_kinds: Vec::new(),\n             lnks: Vec::new(),\n         }\n@@ -582,8 +582,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             successors: repeat(invalid_node()).take(num_live_nodes).collect(),\n             users: repeat(invalid_users()).take(num_live_nodes * num_vars).collect(),\n             loop_scope: Vec::new(),\n-            break_ln: NodeMap::new(),\n-            cont_ln: NodeMap::new(),\n+            break_ln: NodeMap(),\n+            cont_ln: NodeMap(),\n         }\n     }\n "}, {"sha": "01dc55c3eeec0433b41fe45073e8231cb55cfcb8", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -21,7 +21,7 @@ pub type PatIdMap = FnvHashMap<ast::Ident, ast::NodeId>;\n // This is used because same-named variables in alternative patterns need to\n // use the NodeId of their namesake in the first pattern.\n pub fn pat_id_map(dm: &DefMap, pat: &ast::Pat) -> PatIdMap {\n-    let mut map = FnvHashMap::new();\n+    let mut map = FnvHashMap();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n         map.insert(path1.node, p_id);\n     });"}, {"sha": "d6e652f16c654316f174faeba67e74fe474c2026", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         });\n         ReachableContext {\n             tcx: tcx,\n-            reachable_symbols: NodeSet::new(),\n+            reachable_symbols: NodeSet(),\n             worklist: Vec::new(),\n             any_library: any_library,\n         }"}, {"sha": "90ba442ee394e733a1a6a877470148ab6d370dad", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -891,11 +891,11 @@ impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n \n pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n-        scope_map: RefCell::new(FnvHashMap::new()),\n-        var_map: RefCell::new(NodeMap::new()),\n-        free_region_map: RefCell::new(FnvHashMap::new()),\n-        rvalue_scopes: RefCell::new(NodeMap::new()),\n-        terminating_scopes: RefCell::new(FnvHashSet::new()),\n+        scope_map: RefCell::new(FnvHashMap()),\n+        var_map: RefCell::new(NodeMap()),\n+        free_region_map: RefCell::new(FnvHashMap()),\n+        rvalue_scopes: RefCell::new(NodeMap()),\n+        terminating_scopes: RefCell::new(FnvHashSet()),\n     };\n     {\n         let mut visitor = RegionResolutionVisitor {"}, {"sha": "eff0018becc01c8fa822b0b03deae2ab571136b1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -74,7 +74,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegionMap {\n-    let mut named_region_map = NodeMap::new();\n+    let mut named_region_map = NodeMap();\n     visit::walk_crate(&mut LifetimeContext {\n         sess: sess,\n         named_region_map: &mut named_region_map,"}, {"sha": "1a00e175e0f6fefdfd3824d9a545747dc110f4d2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -141,8 +141,8 @@ impl Index {\n     pub fn build(krate: &Crate) -> Index {\n         let mut annotator = Annotator {\n             index: Index {\n-                local: NodeMap::new(),\n-                extern_cache: DefIdMap::new()\n+                local: NodeMap(),\n+                extern_cache: DefIdMap()\n             },\n             parent: None\n         };"}, {"sha": "42624555ae47524bf7a1552a9cf4c93fca744e6d", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             duplicate_set: HashSet::new(),\n             predicates: Vec::new(),\n             attempted_mark: 0,\n-            region_obligations: NodeMap::new(),\n+            region_obligations: NodeMap(),\n         }\n     }\n "}, {"sha": "be6c6b9d34f3784caf6f3713739855531a35fb8f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -2362,71 +2362,71 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx>\n {\n-    let mut interner = FnvHashMap::new();\n+    let mut interner = FnvHashMap();\n     let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n \n     ctxt {\n         arenas: arenas,\n         interner: RefCell::new(interner),\n-        substs_interner: RefCell::new(FnvHashMap::new()),\n-        bare_fn_interner: RefCell::new(FnvHashMap::new()),\n-        region_interner: RefCell::new(FnvHashMap::new()),\n+        substs_interner: RefCell::new(FnvHashMap()),\n+        bare_fn_interner: RefCell::new(FnvHashMap()),\n+        region_interner: RefCell::new(FnvHashMap()),\n         types: common_types,\n         named_region_map: named_region_map,\n-        item_variance_map: RefCell::new(DefIdMap::new()),\n+        item_variance_map: RefCell::new(DefIdMap()),\n         variance_computed: Cell::new(false),\n         sess: s,\n         def_map: dm,\n         region_maps: region_maps,\n-        node_types: RefCell::new(FnvHashMap::new()),\n-        item_substs: RefCell::new(NodeMap::new()),\n-        trait_refs: RefCell::new(NodeMap::new()),\n-        trait_defs: RefCell::new(DefIdMap::new()),\n-        object_cast_map: RefCell::new(NodeMap::new()),\n+        node_types: RefCell::new(FnvHashMap()),\n+        item_substs: RefCell::new(NodeMap()),\n+        trait_refs: RefCell::new(NodeMap()),\n+        trait_defs: RefCell::new(DefIdMap()),\n+        object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n-        intrinsic_defs: RefCell::new(DefIdMap::new()),\n+        intrinsic_defs: RefCell::new(DefIdMap()),\n         freevars: freevars,\n-        tcache: RefCell::new(DefIdMap::new()),\n-        rcache: RefCell::new(FnvHashMap::new()),\n-        short_names_cache: RefCell::new(FnvHashMap::new()),\n-        tc_cache: RefCell::new(FnvHashMap::new()),\n-        ast_ty_to_ty_cache: RefCell::new(NodeMap::new()),\n-        enum_var_cache: RefCell::new(DefIdMap::new()),\n-        impl_or_trait_items: RefCell::new(DefIdMap::new()),\n-        trait_item_def_ids: RefCell::new(DefIdMap::new()),\n-        trait_items_cache: RefCell::new(DefIdMap::new()),\n-        impl_trait_cache: RefCell::new(DefIdMap::new()),\n-        ty_param_defs: RefCell::new(NodeMap::new()),\n-        adjustments: RefCell::new(NodeMap::new()),\n-        normalized_cache: RefCell::new(FnvHashMap::new()),\n+        tcache: RefCell::new(DefIdMap()),\n+        rcache: RefCell::new(FnvHashMap()),\n+        short_names_cache: RefCell::new(FnvHashMap()),\n+        tc_cache: RefCell::new(FnvHashMap()),\n+        ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n+        enum_var_cache: RefCell::new(DefIdMap()),\n+        impl_or_trait_items: RefCell::new(DefIdMap()),\n+        trait_item_def_ids: RefCell::new(DefIdMap()),\n+        trait_items_cache: RefCell::new(DefIdMap()),\n+        impl_trait_cache: RefCell::new(DefIdMap()),\n+        ty_param_defs: RefCell::new(NodeMap()),\n+        adjustments: RefCell::new(NodeMap()),\n+        normalized_cache: RefCell::new(FnvHashMap()),\n         lang_items: lang_items,\n-        provided_method_sources: RefCell::new(DefIdMap::new()),\n-        struct_fields: RefCell::new(DefIdMap::new()),\n-        destructor_for_type: RefCell::new(DefIdMap::new()),\n-        destructors: RefCell::new(DefIdSet::new()),\n-        trait_impls: RefCell::new(DefIdMap::new()),\n-        inherent_impls: RefCell::new(DefIdMap::new()),\n-        impl_items: RefCell::new(DefIdMap::new()),\n-        used_unsafe: RefCell::new(NodeSet::new()),\n-        used_mut_nodes: RefCell::new(NodeSet::new()),\n-        populated_external_types: RefCell::new(DefIdSet::new()),\n-        populated_external_traits: RefCell::new(DefIdSet::new()),\n-        upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n-        extern_const_statics: RefCell::new(DefIdMap::new()),\n-        extern_const_variants: RefCell::new(DefIdMap::new()),\n-        method_map: RefCell::new(FnvHashMap::new()),\n-        dependency_formats: RefCell::new(FnvHashMap::new()),\n-        unboxed_closures: RefCell::new(DefIdMap::new()),\n-        node_lint_levels: RefCell::new(FnvHashMap::new()),\n+        provided_method_sources: RefCell::new(DefIdMap()),\n+        struct_fields: RefCell::new(DefIdMap()),\n+        destructor_for_type: RefCell::new(DefIdMap()),\n+        destructors: RefCell::new(DefIdSet()),\n+        trait_impls: RefCell::new(DefIdMap()),\n+        inherent_impls: RefCell::new(DefIdMap()),\n+        impl_items: RefCell::new(DefIdMap()),\n+        used_unsafe: RefCell::new(NodeSet()),\n+        used_mut_nodes: RefCell::new(NodeSet()),\n+        populated_external_types: RefCell::new(DefIdSet()),\n+        populated_external_traits: RefCell::new(DefIdSet()),\n+        upvar_borrow_map: RefCell::new(FnvHashMap()),\n+        extern_const_statics: RefCell::new(DefIdMap()),\n+        extern_const_variants: RefCell::new(DefIdMap()),\n+        method_map: RefCell::new(FnvHashMap()),\n+        dependency_formats: RefCell::new(FnvHashMap()),\n+        unboxed_closures: RefCell::new(DefIdMap()),\n+        node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n         capture_modes: capture_modes,\n-        associated_types: RefCell::new(DefIdMap::new()),\n+        associated_types: RefCell::new(DefIdMap()),\n         selection_cache: traits::SelectionCache::new(),\n-        repr_hint_cache: RefCell::new(DefIdMap::new()),\n+        repr_hint_cache: RefCell::new(DefIdMap()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n-        object_safety_cache: RefCell::new(DefIdMap::new()),\n+        object_safety_cache: RefCell::new(DefIdMap()),\n    }\n }\n \n@@ -3331,7 +3331,7 @@ pub fn type_interior_is_unsafe<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n     return memoized(&cx.tc_cache, ty, |ty| {\n-        tc_ty(cx, ty, &mut FnvHashMap::new())\n+        tc_ty(cx, ty, &mut FnvHashMap())\n     });\n \n     fn tc_ty<'tcx>(cx: &ctxt<'tcx>,\n@@ -6760,7 +6760,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n {\n     debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n \n-    let mut map = FnvHashMap::new();\n+    let mut map = FnvHashMap();\n \n     // Note: fold the field `0`, not the binder, so that late-bound\n     // regions bound by `binder` are considered free."}, {"sha": "5424b1c8cae508d0fa815a0449e571439c0bf8f5", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -346,7 +346,7 @@ pub fn build_session_(sopts: config::Options,\n         local_crate_source_file: local_crate_source_file,\n         working_dir: os::getcwd().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n-        lints: RefCell::new(NodeMap::new()),\n+        lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),\n         crate_metadata: RefCell::new(Vec::new()),\n         features: RefCell::new(feature_gate::Features::new()),"}, {"sha": "7aa126371c423a0dd418ac078068efb8f23cf2d9", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -15,7 +15,7 @@\n use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n-use std::hash::{Hasher, Writer};\n+use std::hash::{Hasher, Writer, Hash};\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n@@ -27,42 +27,18 @@ pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n-// Hacks to get good names\n-pub mod FnvHashMap {\n-    use std::hash::Hash;\n-    use std::default::Default;\n-    pub fn new<K: Hash<super::FnvHasher> + Eq, V>() -> super::FnvHashMap<K, V> {\n-        Default::default()\n-    }\n-}\n-pub mod FnvHashSet {\n-    use std::hash::Hash;\n-    use std::default::Default;\n-    pub fn new<V: Hash<super::FnvHasher> + Eq>() -> super::FnvHashSet<V> {\n-        Default::default()\n-    }\n+pub fn FnvHashMap<K: Hash<FnvHasher> + Eq, V>() -> FnvHashMap<K, V> {\n+    Default::default()\n }\n-pub mod NodeMap {\n-    pub fn new<T>() -> super::NodeMap<T> {\n-        super::FnvHashMap::new()\n-    }\n-}\n-pub mod DefIdMap {\n-    pub fn new<T>() -> super::DefIdMap<T> {\n-        super::FnvHashMap::new()\n-    }\n-}\n-pub mod NodeSet {\n-    pub fn new() -> super::NodeSet {\n-        super::FnvHashSet::new()\n-    }\n-}\n-pub mod DefIdSet {\n-    pub fn new() -> super::DefIdSet {\n-        super::FnvHashSet::new()\n-    }\n+pub fn FnvHashSet<V: Hash<FnvHasher> + Eq>() -> FnvHashSet<V> {\n+    Default::default()\n }\n \n+pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n+pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n+pub fn NodeSet() -> NodeSet { FnvHashSet() }\n+pub fn DefIdSet() -> DefIdSet { FnvHashSet() }\n+\n /// A speedy hash algorithm for node ids and def ids. The hashmap in\n /// libcollections by default uses SipHash which isn't quite as speedy as we\n /// want. In the compiler we're not really worried about DOS attempts, so we"}, {"sha": "9236a6bda59da1cb73399965374c76f0f34332dd", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -209,12 +209,12 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FnvHashMap::new()),\n+            path_map: RefCell::new(FnvHashMap()),\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n             variant_matches: RefCell::new(Vec::new()),\n-            assignee_ids: RefCell::new(NodeSet::new()),\n+            assignee_ids: RefCell::new(NodeSet()),\n             fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }"}, {"sha": "e12c195a3afbcc5faaf1c0173ec90f9ceab2e0fe", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -1539,7 +1539,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     // Figure out who everyone's parent is\n     let mut visitor = ParentVisitor {\n-        parents: NodeMap::new(),\n+        parents: NodeMap(),\n         curparent: ast::DUMMY_NODE_ID,\n     };\n     visit::walk_crate(&mut visitor, krate);\n@@ -1569,9 +1569,9 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx: tcx,\n-        exported_items: NodeSet::new(),\n-        public_items: NodeSet::new(),\n-        reexports: NodeSet::new(),\n+        exported_items: NodeSet(),\n+        public_items: NodeSet(),\n+        reexports: NodeSet(),\n         export_map: export_map,\n         prev_exported: true,\n         prev_public: true,"}, {"sha": "21eec383df465508d99304f6ea6f14b1f8c96421", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 113, "deletions": 104, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -321,9 +321,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules,\n+                                   sp);\n \n-                name_bindings.define_type(DefTy(local_def(item.id), false), sp, modifiers);\n+                name_bindings.define_type(DefTy(local_def(item.id), false), sp,\n+                                          modifiers);\n+\n+                let parent_link = self.get_parent_link(parent, name);\n+                name_bindings.set_module_kind(parent_link,\n+                                              Some(local_def(item.id)),\n+                                              TypeModuleKind,\n+                                              false,\n+                                              is_public,\n+                                              sp);\n                 parent.clone()\n             }\n \n@@ -412,118 +422,116 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     }\n                 };\n \n-                match mod_name {\n+                let mod_name = match mod_name {\n+                    Some(mod_name) => mod_name,\n                     None => {\n                         self.resolve_error(ty.span,\n                                            \"inherent implementations may \\\n                                             only be implemented in the same \\\n                                             module as the type they are \\\n-                                            implemented for\")\n+                                            implemented for\");\n+                        return parent.clone();\n                     }\n-                    Some(mod_name) => {\n-                        // Create the module and add all methods.\n-                        let parent_opt = parent.children.borrow().get(&mod_name).cloned();\n-                        let new_parent = match parent_opt {\n-                            // It already exists\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                (child.get_module().kind.get() == ImplModuleKind ||\n-                                 child.get_module().kind.get() == TraitModuleKind) => {\n-                                    child.get_module()\n-                                }\n-                            Some(ref child) if child.get_module_if_available()\n-                                .is_some() &&\n-                                child.get_module().kind.get() ==\n-                                EnumModuleKind => child.get_module(),\n-                            // Create the module\n-                            _ => {\n-                                let name_bindings =\n-                                    self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n-\n-                                let parent_link = self.get_parent_link(parent, name);\n-                                let def_id = local_def(item.id);\n-                                let ns = TypeNS;\n-                                let is_public =\n-                                    !name_bindings.defined_in_namespace(ns) ||\n-                                    name_bindings.defined_in_public_namespace(ns);\n-\n-                                name_bindings.define_module(parent_link,\n-                                                            Some(def_id),\n-                                                            ImplModuleKind,\n-                                                            false,\n-                                                            is_public,\n-                                                            sp);\n-\n-                                name_bindings.get_module()\n-                            }\n-                        };\n+                };\n+                // Create the module and add all methods.\n+                let child_opt = parent.children.borrow().get(&mod_name)\n+                                       .and_then(|m| m.get_module_if_available());\n+                let new_parent = match child_opt {\n+                    // It already exists\n+                    Some(ref child) if (child.kind.get() == ImplModuleKind ||\n+                                        child.kind.get() == TraitModuleKind) => {\n+                        child.clone()\n+                    }\n+                    Some(ref child) if child.kind.get() == EnumModuleKind ||\n+                                       child.kind.get() == TypeModuleKind => {\n+                        child.clone()\n+                    }\n+                    // Create the module\n+                    _ => {\n+                        let name_bindings =\n+                            self.add_child(mod_name, parent, ForbidDuplicateModules, sp);\n+\n+                        let parent_link = self.get_parent_link(parent, name);\n+                        let def_id = local_def(item.id);\n+                        let ns = TypeNS;\n+                        let is_public =\n+                            !name_bindings.defined_in_namespace(ns) ||\n+                            name_bindings.defined_in_public_namespace(ns);\n+\n+                        name_bindings.define_module(parent_link,\n+                                                    Some(def_id),\n+                                                    ImplModuleKind,\n+                                                    false,\n+                                                    is_public,\n+                                                    sp);\n \n-                        // For each implementation item...\n-                        for impl_item in impl_items.iter() {\n-                            match *impl_item {\n-                                MethodImplItem(ref method) => {\n-                                    // Add the method to the module.\n-                                    let name = method.pe_ident().name;\n-                                    let method_name_bindings =\n-                                        self.add_child(name,\n-                                                       &new_parent,\n-                                                       ForbidDuplicateValues,\n-                                                       method.span);\n-                                    let def = match method.pe_explicit_self()\n-                                        .node {\n-                                            SelfStatic => {\n-                                                // Static methods become\n-                                                // `DefStaticMethod`s.\n-                                                DefStaticMethod(local_def(method.id),\n-                                                                FromImpl(local_def(item.id)))\n-                                            }\n-                                            _ => {\n-                                                // Non-static methods become\n-                                                // `DefMethod`s.\n-                                                DefMethod(local_def(method.id),\n-                                                          None,\n-                                                          FromImpl(local_def(item.id)))\n-                                            }\n-                                        };\n+                        name_bindings.get_module()\n+                    }\n+                };\n \n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if method.pe_vis() == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    method_name_bindings.define_value(\n-                                        def,\n-                                        method.span,\n-                                        modifiers);\n-                                }\n-                                TypeImplItem(ref typedef) => {\n-                                    // Add the typedef to the module.\n-                                    let name = typedef.ident.name;\n-                                    let typedef_name_bindings =\n-                                        self.add_child(\n-                                            name,\n-                                            &new_parent,\n-                                            ForbidDuplicateTypesAndModules,\n-                                            typedef.span);\n-                                    let def = DefAssociatedTy(local_def(\n-                                        typedef.id));\n-                                    // NB: not IMPORTABLE\n-                                    let modifiers = if typedef.vis == ast::Public {\n-                                        PUBLIC\n-                                    } else {\n-                                        DefModifiers::empty()\n-                                    };\n-                                    typedef_name_bindings.define_type(\n-                                        def,\n-                                        typedef.span,\n-                                        modifiers);\n-                                }\n-                            }\n+                // For each implementation item...\n+                for impl_item in impl_items.iter() {\n+                    match *impl_item {\n+                        MethodImplItem(ref method) => {\n+                            // Add the method to the module.\n+                            let name = method.pe_ident().name;\n+                            let method_name_bindings =\n+                                self.add_child(name,\n+                                               &new_parent,\n+                                               ForbidDuplicateValues,\n+                                               method.span);\n+                            let def = match method.pe_explicit_self()\n+                                .node {\n+                                    SelfStatic => {\n+                                        // Static methods become\n+                                        // `DefStaticMethod`s.\n+                                        DefStaticMethod(local_def(method.id),\n+                                                        FromImpl(local_def(item.id)))\n+                                    }\n+                                    _ => {\n+                                        // Non-static methods become\n+                                        // `DefMethod`s.\n+                                        DefMethod(local_def(method.id),\n+                                                  None,\n+                                                  FromImpl(local_def(item.id)))\n+                                    }\n+                                };\n+\n+                            // NB: not IMPORTABLE\n+                            let modifiers = if method.pe_vis() == ast::Public {\n+                                PUBLIC\n+                            } else {\n+                                DefModifiers::empty()\n+                            };\n+                            method_name_bindings.define_value(\n+                                def,\n+                                method.span,\n+                                modifiers);\n+                        }\n+                        TypeImplItem(ref typedef) => {\n+                            // Add the typedef to the module.\n+                            let name = typedef.ident.name;\n+                            let typedef_name_bindings =\n+                                self.add_child(\n+                                    name,\n+                                    &new_parent,\n+                                    ForbidDuplicateTypesAndModules,\n+                                    typedef.span);\n+                            let def = DefAssociatedTy(local_def(\n+                                typedef.id));\n+                            // NB: not IMPORTABLE\n+                            let modifiers = if typedef.vis == ast::Public {\n+                                PUBLIC\n+                            } else {\n+                                DefModifiers::empty()\n+                            };\n+                            typedef_name_bindings.define_type(\n+                                def,\n+                                typedef.span,\n+                                modifiers);\n                         }\n                     }\n                 }\n-\n                 parent.clone()\n             }\n \n@@ -859,7 +867,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let kind = match def {\n             DefTy(_, true) => EnumModuleKind,\n-            DefStruct(..) | DefTy(..) => ImplModuleKind,\n+            DefTy(_, false) => TypeModuleKind,\n+            DefStruct(..) => ImplModuleKind,\n             _ => NormalModuleKind\n         };\n "}, {"sha": "31999faa6dfeacd4171be041948f3cbed81c5808", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -459,6 +459,7 @@ enum ModuleKind {\n     TraitModuleKind,\n     ImplModuleKind,\n     EnumModuleKind,\n+    TypeModuleKind,\n     AnonymousModuleKind,\n }\n \n@@ -522,7 +523,7 @@ impl Module {\n             children: RefCell::new(HashMap::new()),\n             imports: RefCell::new(Vec::new()),\n             external_module_children: RefCell::new(HashMap::new()),\n-            anonymous_children: RefCell::new(NodeMap::new()),\n+            anonymous_children: RefCell::new(NodeMap()),\n             import_resolutions: RefCell::new(HashMap::new()),\n             glob_count: Cell::new(0),\n             resolved_import_count: Cell::new(0),\n@@ -942,8 +943,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             graph_root: graph_root,\n \n-            trait_item_map: FnvHashMap::new(),\n-            structs: FnvHashMap::new(),\n+            trait_item_map: FnvHashMap(),\n+            structs: FnvHashMap(),\n \n             unresolved_imports: 0,\n \n@@ -960,16 +961,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n-            def_map: RefCell::new(NodeMap::new()),\n-            freevars: RefCell::new(NodeMap::new()),\n-            freevars_seen: RefCell::new(NodeMap::new()),\n-            capture_mode_map: NodeMap::new(),\n-            export_map: NodeMap::new(),\n-            trait_map: NodeMap::new(),\n+            def_map: RefCell::new(NodeMap()),\n+            freevars: RefCell::new(NodeMap()),\n+            freevars_seen: RefCell::new(NodeMap()),\n+            capture_mode_map: NodeMap(),\n+            export_map: NodeMap(),\n+            trait_map: NodeMap(),\n             used_imports: HashSet::new(),\n             used_crates: HashSet::new(),\n-            external_exports: DefIdSet::new(),\n-            last_private: NodeMap::new(),\n+            external_exports: DefIdSet(),\n+            last_private: NodeMap(),\n \n             emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n@@ -2240,6 +2241,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         TraitModuleKind |\n                         ImplModuleKind |\n                         EnumModuleKind |\n+                        TypeModuleKind |\n                         AnonymousModuleKind => {\n                             search_module = parent_module_node.upgrade().unwrap();\n                         }\n@@ -2337,6 +2339,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         TraitModuleKind |\n                         ImplModuleKind |\n                         EnumModuleKind |\n+                        TypeModuleKind |\n                         AnonymousModuleKind => module_ = new_module,\n                     }\n                 }\n@@ -2353,6 +2356,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             TraitModuleKind |\n             ImplModuleKind |\n             EnumModuleKind |\n+            TypeModuleKind |\n             AnonymousModuleKind => {\n                 match self.get_nearest_normal_module_parent(module_.clone()) {\n                     None => module_,\n@@ -2631,7 +2635,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let mut seen = self.freevars_seen.borrow_mut();\n                             let seen = match seen.entry(function_id) {\n                                 Occupied(v) => v.into_mut(),\n-                                Vacant(v) => v.insert(NodeSet::new()),\n+                                Vacant(v) => v.insert(NodeSet()),\n                             };\n                             if seen.contains(&node_id) {\n                                 continue;"}, {"sha": "9f3c55d4f687e45393c382826b4b0062c87a4915", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -1306,7 +1306,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n     let ccx = bcx.ccx();\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n-    let mut bindings_map = FnvHashMap::new();\n+    let mut bindings_map = FnvHashMap();\n     pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n         let ident = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);"}, {"sha": "eed61ae59a259557817c6a67bf6e57cb7739c01e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -1461,8 +1461,8 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n           needs_ret_allocas: nested_returns,\n           personality: Cell::new(None),\n           caller_expects_out_pointer: uses_outptr,\n-          lllocals: RefCell::new(NodeMap::new()),\n-          llupvars: RefCell::new(NodeMap::new()),\n+          lllocals: RefCell::new(NodeMap()),\n+          llupvars: RefCell::new(NodeMap()),\n           id: id,\n           param_substs: param_substs,\n           span: sp,"}, {"sha": "187b3e2cf21887a20a7a6c77e3e2553597574a20", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Build version of path with cycles removed.\n \n                 // Pass 1: scan table mapping str -> rightmost pos.\n-                let mut mm = FnvHashMap::new();\n+                let mut mm = FnvHashMap();\n                 let len = v.len();\n                 let mut i = 0u;\n                 while i < len {"}, {"sha": "312fd33ef1ff04d1ca8fab5688efd20e942bb433", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -176,7 +176,7 @@ pub fn unsized_part_of_type<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx>\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     return memoized(ccx.needs_unwind_cleanup_cache(), ty, |ty| {\n-        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet::new())\n+        type_needs_unwind_cleanup_(ccx.tcx(), ty, &mut FnvHashSet())\n     });\n \n     fn type_needs_unwind_cleanup_<'tcx>(tcx: &ty::ctxt<'tcx>,"}, {"sha": "10edb72f0e200e06c2c65248a806541409152fc5", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -253,7 +253,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             metadata_llcx: metadata_llcx,\n             export_map: export_map,\n             reachable: reachable,\n-            item_symbols: RefCell::new(NodeMap::new()),\n+            item_symbols: RefCell::new(NodeMap()),\n             link_meta: link_meta,\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n@@ -267,11 +267,11 @@ impl<'tcx> SharedCrateContext<'tcx> {\n                 n_inlines: Cell::new(0u),\n                 n_closures: Cell::new(0u),\n                 n_llvm_insns: Cell::new(0u),\n-                llvm_insns: RefCell::new(FnvHashMap::new()),\n+                llvm_insns: RefCell::new(FnvHashMap()),\n                 fn_stats: RefCell::new(Vec::new()),\n             },\n-            available_monomorphizations: RefCell::new(FnvHashSet::new()),\n-            available_drop_glues: RefCell::new(FnvHashMap::new()),\n+            available_monomorphizations: RefCell::new(FnvHashSet()),\n+            available_drop_glues: RefCell::new(FnvHashMap()),\n         };\n \n         for i in range(0, local_count) {\n@@ -387,39 +387,39 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llcx: llcx,\n                 td: td,\n                 tn: TypeNames::new(),\n-                externs: RefCell::new(FnvHashMap::new()),\n-                item_vals: RefCell::new(NodeMap::new()),\n-                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap::new()),\n-                fn_pointer_shims: RefCell::new(FnvHashMap::new()),\n-                drop_glues: RefCell::new(FnvHashMap::new()),\n-                tydescs: RefCell::new(FnvHashMap::new()),\n+                externs: RefCell::new(FnvHashMap()),\n+                item_vals: RefCell::new(NodeMap()),\n+                needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n+                fn_pointer_shims: RefCell::new(FnvHashMap()),\n+                drop_glues: RefCell::new(FnvHashMap()),\n+                tydescs: RefCell::new(FnvHashMap()),\n                 finished_tydescs: Cell::new(false),\n-                external: RefCell::new(DefIdMap::new()),\n-                external_srcs: RefCell::new(NodeMap::new()),\n-                monomorphized: RefCell::new(FnvHashMap::new()),\n-                monomorphizing: RefCell::new(DefIdMap::new()),\n-                vtables: RefCell::new(FnvHashMap::new()),\n-                const_cstr_cache: RefCell::new(FnvHashMap::new()),\n-                const_globals: RefCell::new(FnvHashMap::new()),\n-                const_values: RefCell::new(NodeMap::new()),\n-                static_values: RefCell::new(NodeMap::new()),\n-                extern_const_values: RefCell::new(DefIdMap::new()),\n-                impl_method_cache: RefCell::new(FnvHashMap::new()),\n-                closure_bare_wrapper_cache: RefCell::new(FnvHashMap::new()),\n-                lltypes: RefCell::new(FnvHashMap::new()),\n-                llsizingtypes: RefCell::new(FnvHashMap::new()),\n-                adt_reprs: RefCell::new(FnvHashMap::new()),\n-                type_hashcodes: RefCell::new(FnvHashMap::new()),\n-                all_llvm_symbols: RefCell::new(FnvHashSet::new()),\n+                external: RefCell::new(DefIdMap()),\n+                external_srcs: RefCell::new(NodeMap()),\n+                monomorphized: RefCell::new(FnvHashMap()),\n+                monomorphizing: RefCell::new(DefIdMap()),\n+                vtables: RefCell::new(FnvHashMap()),\n+                const_cstr_cache: RefCell::new(FnvHashMap()),\n+                const_globals: RefCell::new(FnvHashMap()),\n+                const_values: RefCell::new(NodeMap()),\n+                static_values: RefCell::new(NodeMap()),\n+                extern_const_values: RefCell::new(DefIdMap()),\n+                impl_method_cache: RefCell::new(FnvHashMap()),\n+                closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                lltypes: RefCell::new(FnvHashMap()),\n+                llsizingtypes: RefCell::new(FnvHashMap()),\n+                adt_reprs: RefCell::new(FnvHashMap()),\n+                type_hashcodes: RefCell::new(FnvHashMap()),\n+                all_llvm_symbols: RefCell::new(FnvHashSet()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n-                unboxed_closure_vals: RefCell::new(FnvHashMap::new()),\n+                unboxed_closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n-                intrinsics: RefCell::new(FnvHashMap::new()),\n+                intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0u),\n-                trait_cache: RefCell::new(FnvHashMap::new()),\n+                trait_cache: RefCell::new(FnvHashMap()),\n             };\n \n             local_ccx.int_type = Type::int(&local_ccx.dummy_ccx(shared));"}, {"sha": "2f01f0328e28c21fb7ee45124db52cd07f6959af", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -271,9 +271,9 @@ impl<'tcx> TypeMap<'tcx> {\n     fn new() -> TypeMap<'tcx> {\n         TypeMap {\n             unique_id_interner: Interner::new(),\n-            type_to_metadata: FnvHashMap::new(),\n-            unique_id_to_metadata: FnvHashMap::new(),\n-            type_to_unique_id: FnvHashMap::new(),\n+            type_to_metadata: FnvHashMap(),\n+            unique_id_to_metadata: FnvHashMap(),\n+            type_to_unique_id: FnvHashMap(),\n         }\n     }\n \n@@ -672,11 +672,11 @@ impl<'tcx> CrateDebugContext<'tcx> {\n             llcontext: llcontext,\n             builder: builder,\n             current_debug_location: Cell::new(UnknownLocation),\n-            created_files: RefCell::new(FnvHashMap::new()),\n-            created_enum_disr_types: RefCell::new(DefIdMap::new()),\n+            created_files: RefCell::new(FnvHashMap()),\n+            created_enum_disr_types: RefCell::new(DefIdMap()),\n             type_map: RefCell::new(TypeMap::new()),\n-            namespace_map: RefCell::new(FnvHashMap::new()),\n-            composite_types_completed: RefCell::new(FnvHashSet::new()),\n+            namespace_map: RefCell::new(FnvHashMap()),\n+            composite_types_completed: RefCell::new(FnvHashSet()),\n         };\n     }\n }\n@@ -3225,7 +3225,7 @@ fn create_scope_map(cx: &CrateContext,\n                     fn_metadata: DISubprogram,\n                     fn_ast_id: ast::NodeId)\n                  -> NodeMap<DIScope> {\n-    let mut scope_map = NodeMap::new();\n+    let mut scope_map = NodeMap();\n \n     let def_map = &cx.tcx().def_map;\n "}, {"sha": "07eb17e6300cdf9fcd424ef78ff8665b0b8ab5f9", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -352,7 +352,7 @@ pub struct TypeNames {\n impl TypeNames {\n     pub fn new() -> TypeNames {\n         TypeNames {\n-            named_types: RefCell::new(FnvHashMap::new())\n+            named_types: RefCell::new(FnvHashMap())\n         }\n     }\n "}, {"sha": "42b12c158664ae2247d1e2a60744bda4f08ad8fc", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -1719,7 +1719,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut trait_def_ids = DefIdMap::new();\n+    let mut trait_def_ids = DefIdMap();\n     for ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {"}, {"sha": "bc2f291007d83b24be4eb35724dbc72dee5cc5d4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -592,7 +592,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         .collect::<FnvHashMap<_, _>>();\n \n     // Keep track of which fields have already appeared in the pattern.\n-    let mut used_fields = FnvHashMap::new();\n+    let mut used_fields = FnvHashMap();\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields.iter() {"}, {"sha": "a4fa594621eff95426a7d5341f6451821f975320", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -373,16 +373,16 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n         Inherited {\n             infcx: infer::new_infer_ctxt(tcx),\n-            locals: RefCell::new(NodeMap::new()),\n+            locals: RefCell::new(NodeMap()),\n             param_env: param_env,\n-            node_types: RefCell::new(NodeMap::new()),\n-            item_substs: RefCell::new(NodeMap::new()),\n-            adjustments: RefCell::new(NodeMap::new()),\n-            method_map: RefCell::new(FnvHashMap::new()),\n-            object_cast_map: RefCell::new(NodeMap::new()),\n-            upvar_borrow_map: RefCell::new(FnvHashMap::new()),\n-            unboxed_closures: RefCell::new(DefIdMap::new()),\n-            fn_sig_map: RefCell::new(NodeMap::new()),\n+            node_types: RefCell::new(NodeMap()),\n+            item_substs: RefCell::new(NodeMap()),\n+            adjustments: RefCell::new(NodeMap()),\n+            method_map: RefCell::new(FnvHashMap()),\n+            object_cast_map: RefCell::new(NodeMap()),\n+            upvar_borrow_map: RefCell::new(FnvHashMap()),\n+            unboxed_closures: RefCell::new(DefIdMap()),\n+            fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         }\n     }\n@@ -3153,7 +3153,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 enum_id_opt: Option<ast::DefId>)  {\n         let tcx = fcx.ccx.tcx;\n \n-        let mut class_field_map = FnvHashMap::new();\n+        let mut class_field_map = FnvHashMap();\n         let mut fields_found = 0;\n         for field in field_types.iter() {\n             class_field_map.insert(field.name, (field.id, false));"}, {"sha": "350cee99f6a3fc80d1ba06dcc02c22ab69dfddc9", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -595,7 +595,7 @@ pub fn check_coherence(crate_context: &CrateCtxt) {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n-        inherent_impls: RefCell::new(FnvHashMap::new()),\n+        inherent_impls: RefCell::new(FnvHashMap()),\n     }.check(crate_context.tcx.map.krate());\n     impls::check(crate_context.tcx);\n     unsafety::check(crate_context.tcx);"}, {"sha": "80c0a72db838768499d7a7d5bea23b56a02de3d3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -449,7 +449,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n            rcvr_ty_generics.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n-    let mut seen_methods = FnvHashSet::new();\n+    let mut seen_methods = FnvHashSet();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n@@ -737,7 +737,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members and check for duplicate fields.\n-    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap::new();\n+    let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let field_tys = struct_def.fields.iter().map(|f| {\n         let result = convert_field(ccx, &scheme.generics, f, local_def(id));\n "}, {"sha": "86447e76a898b7110a5c2c9f59af7041867e1459", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -288,7 +288,7 @@ fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n-        inferred_map: NodeMap::new(),\n+        inferred_map: NodeMap(),\n         inferred_infos: Vec::new(),\n \n         // cache and share the variance struct used for items with"}, {"sha": "ab9700d966aa525a9772dfbd09b3c4dddc42eb64", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -313,7 +313,7 @@ pub fn run(mut krate: clean::Crate,\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n-    let public_items = public_items.unwrap_or(NodeSet::new());\n+    let public_items = public_items.unwrap_or(NodeSet());\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();"}, {"sha": "f5c879a07ee56b602d8648c7fd5974849bed3b27", "filename": "src/test/compile-fail/issue-6936.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Ftest%2Fcompile-fail%2Fissue-6936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cda3490f8fb099a1ddd1f253a75c29110042dc01/src%2Ftest%2Fcompile-fail%2Fissue-6936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6936.rs?ref=cda3490f8fb099a1ddd1f253a75c29110042dc01", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct T;\n+\n+mod t1 {\n+    type Foo = ::T;\n+    mod Foo {} //~ ERROR: duplicate definition of type or module `Foo`\n+}\n+\n+mod t2 {\n+    type Foo = ::T;\n+    struct Foo; //~ ERROR: duplicate definition of type or module `Foo`\n+}\n+\n+mod t3 {\n+    type Foo = ::T;\n+    enum Foo {} //~ ERROR: duplicate definition of type or module `Foo`\n+}\n+\n+mod t4 {\n+    type Foo = ::T;\n+    fn Foo() {} // ok\n+}\n+\n+mod t5 {\n+    type Bar<T> = T;\n+    mod Bar {} //~ ERROR: duplicate definition of type or module `Bar`\n+}\n+\n+mod t6 {\n+    type Foo = ::T;\n+    impl Foo {} // ok\n+}\n+\n+\n+fn main() {}"}]}