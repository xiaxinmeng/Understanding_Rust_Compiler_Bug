{"sha": "e6aa96246fe6125dae72d2840749f2859b49a47f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YWE5NjI0NmZlNjEyNWRhZTcyZDI4NDA3NDlmMjg1OWI0OWE0N2Y=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-28T13:03:02Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-12-02T16:00:24Z"}, "message": "Simplify lifetimes by allocating patterns on the arena\n\nWe want the lifetimes of the patterns contained in the matrix and the\ncandidate `PatStack` to be the same so that they can be mixed together.\nA lot of this would not be necessary if `SmallVec` was covariant in its\ntype argument (see https://github.com/servo/rust-smallvec/issues/146).", "tree": {"sha": "1f56af6dfb377f0a0be6608fd6f7f62e1201b0c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f56af6dfb377f0a0be6608fd6f7f62e1201b0c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6aa96246fe6125dae72d2840749f2859b49a47f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6aa96246fe6125dae72d2840749f2859b49a47f", "html_url": "https://github.com/rust-lang/rust/commit/e6aa96246fe6125dae72d2840749f2859b49a47f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6aa96246fe6125dae72d2840749f2859b49a47f/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21af89d773cc76eaf7240e4a16f30d4cd29139e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/21af89d773cc76eaf7240e4a16f30d4cd29139e1", "html_url": "https://github.com/rust-lang/rust/commit/21af89d773cc76eaf7240e4a16f30d4cd29139e1"}], "stats": {"total": 87, "additions": 38, "deletions": 49}, "files": [{"sha": "e2ed925047442c5fe7fb83f096f1bf452ee6a609", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e6aa96246fe6125dae72d2840749f2859b49a47f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6aa96246fe6125dae72d2840749f2859b49a47f/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e6aa96246fe6125dae72d2840749f2859b49a47f", "patch": "@@ -425,16 +425,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Option<PatStack<'q, 'tcx>>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Option<PatStack<'p, 'tcx>> {\n         let new_heads = specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns);\n         new_heads.map(|mut new_head| {\n             new_head.0.extend_from_slice(&self.0[1..]);\n@@ -486,16 +482,12 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     }\n \n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n-    fn specialize_constructor<'a, 'q>(\n+    fn specialize_constructor(\n         &self,\n-        cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+        cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n-        ctor_wild_subpatterns: &[&'q Pat<'tcx>],\n-    ) -> Matrix<'q, 'tcx>\n-    where\n-        'a: 'q,\n-        'p: 'q,\n-    {\n+        ctor_wild_subpatterns: &'p [Pat<'tcx>],\n+    ) -> Matrix<'p, 'tcx> {\n         self.0\n             .iter()\n             .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n@@ -1604,10 +1596,10 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n-pub fn is_useful<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+pub fn is_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n@@ -1768,21 +1760,21 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n-fn is_useful_specialized<'p, 'a, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn is_useful_specialized<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n-    v: &PatStack<'_, 'tcx>,\n+    v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n-    let ctor_wild_subpatterns_owned: Vec<_> = ctor.wildcard_subpatterns(cx, lty);\n-    let ctor_wild_subpatterns: Vec<_> = ctor_wild_subpatterns_owned.iter().collect();\n-    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    let ctor_wild_subpatterns =\n+        cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n+    let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n+    v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n@@ -2250,13 +2242,13 @@ fn constructor_covered_by_range<'tcx>(\n     if intersects { Some(()) } else { None }\n }\n \n-fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+fn patterns_for_variant<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     subpatterns: &'p [FieldPat<'tcx>],\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n     is_non_exhaustive: bool,\n ) -> PatStack<'p, 'tcx> {\n-    let mut result = SmallVec::from_slice(ctor_wild_subpatterns);\n+    let mut result: SmallVec<_> = ctor_wild_subpatterns.iter().collect();\n \n     for subpat in subpatterns {\n         if !is_non_exhaustive || !cx.is_uninhabited(subpat.pattern.ty) {\n@@ -2280,11 +2272,11 @@ fn patterns_for_variant<'p, 'a: 'p, 'tcx>(\n /// different patterns.\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n-fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'q Pat<'tcx>,\n+fn specialize_one_pattern<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n+    pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n-    ctor_wild_subpatterns: &[&'p Pat<'tcx>],\n+    ctor_wild_subpatterns: &'p [Pat<'tcx>],\n ) -> Option<PatStack<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n@@ -2294,9 +2286,7 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n-        PatKind::Binding { .. } | PatKind::Wild => {\n-            Some(PatStack::from_slice(ctor_wild_subpatterns))\n-        }\n+        PatKind::Binding { .. } | PatKind::Wild => Some(ctor_wild_subpatterns.iter().collect()),\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n@@ -2406,7 +2396,6 @@ fn specialize_one_pattern<'p, 'a: 'p, 'q: 'p, 'tcx>(\n                                 .chain(\n                                     ctor_wild_subpatterns\n                                         .iter()\n-                                        .map(|p| *p)\n                                         .skip(prefix.len())\n                                         .take(slice_count)\n                                         .chain(suffix.iter()),"}, {"sha": "62bc04b65f34f21b6424421219b4c2a9b3f43f90", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6aa96246fe6125dae72d2840749f2859b49a47f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6aa96246fe6125dae72d2840749f2859b49a47f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=e6aa96246fe6125dae72d2840749f2859b49a47f", "patch": "@@ -261,8 +261,8 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n             patcx.include_lint_checks();\n             let pattern = patcx.lower_pattern(pat);\n             let pattern_ty = pattern.ty;\n-            let pattern = expand_pattern(cx, pattern);\n-            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(&pattern)].into_iter().collect();\n+            let pattern = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+            let pats: Matrix<'_, '_> = vec![PatStack::from_pattern(pattern)].into_iter().collect();\n \n             let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n@@ -398,7 +398,7 @@ fn pat_is_catchall(pat: &Pat) -> bool {\n \n // Check for unreachable patterns\n fn check_arms<'p, 'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     arms: &[(Vec<(&'p super::Pat<'tcx>, &hir::Pat)>, Option<&hir::Expr>)],\n     source: hir::MatchSource,\n ) -> Matrix<'p, 'tcx> {\n@@ -482,14 +482,14 @@ fn check_arms<'p, 'tcx>(\n     seen\n }\n \n-fn check_not_useful(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_not_useful<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     ty: Ty<'tcx>,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n-    let wild_pattern = super::Pat::wildcard_from_ty(ty);\n-    match is_useful(cx, matrix, &PatStack::from_pattern(&wild_pattern), ConstructWitness, hir_id) {\n+    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n+    match is_useful(cx, matrix, &PatStack::from_pattern(wild_pattern), ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             bug!(\"Exhaustiveness check returned no witnesses\")\n@@ -500,11 +500,11 @@ fn check_not_useful(\n     }\n }\n \n-fn check_exhaustive<'tcx>(\n-    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+fn check_exhaustive<'p, 'tcx>(\n+    cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n-    matrix: &Matrix<'_, 'tcx>,\n+    matrix: &Matrix<'p, 'tcx>,\n     hir_id: HirId,\n ) {\n     let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {"}]}