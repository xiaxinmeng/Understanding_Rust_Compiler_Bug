{"sha": "f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0Yjg5ZjVkNzlmZDU0NDhmYzVkODI4NDRlYmQ4OTBjYzJkNzg0M2I=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T18:46:31Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-21T18:46:31Z"}, "message": "rustc: Move ty.unify to a separate namespace", "tree": {"sha": "1421f693b5e67eaed5b2bc5898c6bf539561bbec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1421f693b5e67eaed5b2bc5898c6bf539561bbec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "html_url": "https://github.com/rust-lang/rust/commit/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "186717fae09fc42410a56e51fe32af662a55b6e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/186717fae09fc42410a56e51fe32af662a55b6e2", "html_url": "https://github.com/rust-lang/rust/commit/186717fae09fc42410a56e51fe32af662a55b6e2"}], "stats": {"total": 96, "additions": 50, "deletions": 46}, "files": [{"sha": "eed0709871465a1bdc304d7505c8ddb2b6f7a10c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "patch": "@@ -77,8 +77,8 @@ tag sty {\n \n type unify_handler = obj {\n     fn resolve_local(ast.def_id id) -> option.t[@t];\n-    fn record_local(ast.def_id id, @t ty);  // TODO: -> unify_result\n-    fn record_param(uint index, @t binding) -> unify_result;\n+    fn record_local(ast.def_id id, @t ty);  // TODO: -> Unify.result\n+    fn record_param(uint index, @t binding) -> Unify.result;\n };\n \n tag type_err {\n@@ -95,11 +95,6 @@ tag type_err {\n     terr_arg_count;\n }\n \n-tag unify_result {\n-    ures_ok(@ty.t);\n-    ures_err(type_err, @ty.t, @ty.t);\n-}\n-\n \n type ty_param_count_and_ty = tup(uint, @t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n@@ -1551,12 +1546,16 @@ fn is_lval(@ast.expr expr) -> bool {\n //\n //     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n \n-type var_bindings = rec(UFind.ufind sets,\n-                        hashmap[int,uint] var_ids,\n-                        mutable vec[mutable vec[@t]] types);\n+mod Unify {\n+    tag result {\n+        ures_ok(@ty.t);\n+        ures_err(type_err, @ty.t, @ty.t);\n+    }\n+\n+    type var_bindings = rec(UFind.ufind sets,\n+                            hashmap[int,uint] var_ids,\n+                            mutable vec[mutable vec[@t]] types);\n \n-fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n-        -> unify_result {\n     // Wraps the given type in an appropriate cname.\n     //\n     // TODO: This doesn't do anything yet. We should carry the cname up from\n@@ -1565,7 +1564,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     // something we'll probably need to develop over time.\n \n     // Simple structural type comparison.\n-    fn struct_cmp(@ty.t expected, @ty.t actual) -> unify_result {\n+    fn struct_cmp(@ty.t expected, @ty.t actual) -> result {\n         if (expected.struct == actual.struct) {\n             ret ures_ok(expected);\n         }\n@@ -1589,7 +1588,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     }\n \n     tag fn_common_res {\n-        fn_common_res_err(unify_result);\n+        fn_common_res_err(result);\n         fn_common_res_ok(vec[arg], @t);\n     }\n \n@@ -1666,7 +1665,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 &unify_handler handler,\n                 vec[arg] expected_inputs, @t expected_output,\n                 vec[arg] actual_inputs, @t actual_output)\n-        -> unify_result {\n+        -> result {\n \n         if (e_proto != a_proto) {\n             ret ures_err(terr_mismatch, expected, actual);\n@@ -1693,7 +1692,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                        &unify_handler handler,\n                        vec[arg] expected_inputs, @t expected_output,\n                        vec[arg] actual_inputs, @t actual_output)\n-        -> unify_result {\n+        -> result {\n         if (e_abi != a_abi) {\n             ret ures_err(terr_mismatch, expected, actual);\n         }\n@@ -1717,7 +1716,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                  @ty.t actual,\n                  &unify_handler handler,\n                  vec[method] expected_meths,\n-                 vec[method] actual_meths) -> unify_result {\n+                 vec[method] actual_meths) -> result {\n       let vec[method] result_meths = vec();\n       let uint i = 0u;\n       let uint expected_len = _vec.len[method](expected_meths);\n@@ -1772,7 +1771,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     }\n \n     fn unify_step(&var_bindings bindings, @ty.t expected, @ty.t actual,\n-                  &unify_handler handler) -> unify_result {\n+                  &unify_handler handler) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -2261,24 +2260,27 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         ret result;\n     }\n \n-    let vec[@t] throwaway = vec();\n-    let vec[mutable vec[@t]] types = vec(mutable throwaway);\n-    _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n+    fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n+            -> result {\n+        let vec[@t] throwaway = vec();\n+        let vec[mutable vec[@t]] types = vec(mutable throwaway);\n+        _vec.pop[mutable vec[@t]](types);   // FIXME: botch\n \n-    auto bindings = rec(sets=UFind.make(),\n-                        var_ids=common.new_int_hash[uint](),\n-                        mutable types=types);\n+        auto bindings = rec(sets=UFind.make(),\n+                            var_ids=common.new_int_hash[uint](),\n+                            mutable types=types);\n \n-    auto ures = unify_step(bindings, expected, actual, handler);\n-    alt (ures) {\n-    case (ures_ok(?t)) {\n-        auto set_types = unify_sets(bindings);\n-        auto t2 = substitute(bindings, set_types, t);\n-        ret ures_ok(t2);\n-    }\n-    case (_) { ret ures; }\n+        auto ures = unify_step(bindings, expected, actual, handler);\n+        alt (ures) {\n+        case (ures_ok(?t)) {\n+            auto set_types = unify_sets(bindings);\n+            auto t2 = substitute(bindings, set_types, t);\n+            ret ures_ok(t2);\n+        }\n+        case (_) { ret ures; }\n+        }\n+        fail;   // not reached\n     }\n-    fail;   // not reached\n }\n \n fn type_err_to_str(&ty.type_err err) -> str {"}, {"sha": "b4863954f79303d2af947b365c9ee76ce33645a1", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b89f5d79fd5448fc5d82844ebd890cc2d7843b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=f4b89f5d79fd5448fc5d82844ebd890cc2d7843b", "patch": "@@ -25,6 +25,8 @@ import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n import middle.ty.ty_param_count_and_ty;\n import middle.ty.ty_nil;\n+import middle.ty.Unify.ures_ok;\n+import middle.ty.Unify.ures_err;\n \n import std._str;\n import std._uint;\n@@ -49,7 +51,7 @@ tag any_item {\n type ty_item_table = hashmap[ast.def_id,any_item];\n \n type unify_cache_entry = tup(@ty.t,@ty.t,vec[mutable @ty.t]);\n-type unify_cache = hashmap[unify_cache_entry,ty.unify_result];\n+type unify_cache = hashmap[unify_cache_entry,ty.Unify.result];\n \n type crate_ctxt = rec(session.session sess,\n                       ty.type_cache type_cache,\n@@ -805,15 +807,15 @@ mod Collect {\n // Type unification\n \n mod Unify {\n-    fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n+    fn simple(@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.Unify.result {\n         // FIXME: horrid botch\n         let vec[mutable @ty.t] param_substs = vec(mutable ty.mk_nil());\n         _vec.pop[mutable @ty.t](param_substs);\n         ret with_params(fcx, expected, actual, param_substs);\n     }\n \n     fn with_params(@fn_ctxt fcx, @ty.t expected, @ty.t actual,\n-                   vec[mutable @ty.t] param_substs) -> ty.unify_result {\n+                   vec[mutable @ty.t] param_substs) -> ty.Unify.result {\n         auto cache_key = tup(expected, actual, param_substs);\n         if (fcx.ccx.unify_cache.contains_key(cache_key)) {\n             fcx.ccx.cache_hits += 1u;\n@@ -843,7 +845,7 @@ mod Unify {\n                     case (some[@ty.t](?old_type)) {\n                         alt (with_params(fcx, old_type, new_type,\n                                          param_substs)) {\n-                            case (ty.ures_ok(?ut)) { unified_type = ut; }\n+                            case (ures_ok(?ut)) { unified_type = ut; }\n                             case (_) { fail; /* FIXME */ }\n                         }\n                     }\n@@ -859,17 +861,17 @@ mod Unify {\n                     ty.substitute_type_params(param_substs_1, unified_type);\n                 fcx.locals.insert(id, unified_type);\n             }\n-            fn record_param(uint index, @ty.t binding) -> ty.unify_result {\n+            fn record_param(uint index, @ty.t binding) -> ty.Unify.result {\n                 // Unify with the appropriate type in the parameter\n                 // substitution list.\n                 auto old_subst = param_substs.(index);\n \n                 auto result = with_params(fcx, old_subst, binding,\n                                           param_substs);\n                 alt (result) {\n-                    case (ty.ures_ok(?new_subst)) {\n+                    case (ures_ok(?new_subst)) {\n                         param_substs.(index) = new_subst;\n-                        ret ty.ures_ok(ty.mk_bound_param(index));\n+                        ret ures_ok(ty.mk_bound_param(index));\n                     }\n                     case (_) { ret result; }\n                 }\n@@ -878,7 +880,7 @@ mod Unify {\n \n \n         auto handler = unify_handler(fcx, param_substs);\n-        auto result = ty.unify(expected, actual, handler);\n+        auto result = ty.Unify.unify(expected, actual, handler);\n         fcx.ccx.unify_cache.insert(cache_key, result);\n         ret result;\n     }\n@@ -965,7 +967,7 @@ mod Demand {\n         }\n \n         alt (Unify.with_params(fcx, expected_1, actual_1, ty_param_substs)) {\n-            case (ty.ures_ok(?t)) {\n+            case (ures_ok(?t)) {\n                 // TODO: Use \"freeze\", when we have it.\n                 let vec[@ty.t] result_ty_param_substs = vec();\n                 for (mutable @ty.t ty_param_subst in ty_param_substs) {\n@@ -975,7 +977,7 @@ mod Demand {\n                 ret tup(result_ty_param_substs, add_boxes(implicit_boxes, t));\n             }\n \n-            case (ty.ures_err(?err, ?expected, ?actual)) {\n+            case (ures_err(?err, ?expected, ?actual)) {\n                 fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n                                       + ty_to_str(expected) + \" but found \"\n                                       + ty_to_str(actual) + \" (\" +\n@@ -993,8 +995,8 @@ mod Demand {\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n     alt (Unify.simple(fcx, expected, actual)) {\n-        case (ty.ures_ok(_))        { ret true;  }\n-        case (ty.ures_err(_, _, _)) { ret false; }\n+        case (ures_ok(_))        { ret true;  }\n+        case (ures_err(_, _, _)) { ret false; }\n     }\n }\n \n@@ -2723,7 +2725,7 @@ fn check_crate(session.session sess, @ast.crate crate) -> typecheck_result {\n     auto hasher = hash_unify_cache_entry;\n     auto eqer = eq_unify_cache_entry;\n     auto unify_cache =\n-        map.mk_hashmap[unify_cache_entry,ty.unify_result](hasher, eqer);\n+        map.mk_hashmap[unify_cache_entry,ty.Unify.result](hasher, eqer);\n \n     auto ccx = @rec(sess=sess,\n                     type_cache=result._1,"}]}