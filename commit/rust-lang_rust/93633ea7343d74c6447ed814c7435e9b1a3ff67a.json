{"sha": "93633ea7343d74c6447ed814c7435e9b1a3ff67a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNjMzZWE3MzQzZDc0YzY0NDdlZDgxNGM3NDM1ZTliMWEzZmY2N2E=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-05-24T01:57:56Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-05-25T23:53:34Z"}, "message": "Add an internal notion of 'implicit copyability' and use it to warn when implicitly copying mutable data and some unique data. Closes #2448.", "tree": {"sha": "d53efcb377efc5f03849e1f95659f90f4bbeb817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d53efcb377efc5f03849e1f95659f90f4bbeb817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93633ea7343d74c6447ed814c7435e9b1a3ff67a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93633ea7343d74c6447ed814c7435e9b1a3ff67a", "html_url": "https://github.com/rust-lang/rust/commit/93633ea7343d74c6447ed814c7435e9b1a3ff67a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93633ea7343d74c6447ed814c7435e9b1a3ff67a/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8668d06400710f9d99d1b39da847031dc3d78394", "url": "https://api.github.com/repos/rust-lang/rust/commits/8668d06400710f9d99d1b39da847031dc3d78394", "html_url": "https://github.com/rust-lang/rust/commit/8668d06400710f9d99d1b39da847031dc3d78394"}], "stats": {"total": 150, "additions": 104, "deletions": 46}, "files": [{"sha": "dbac02c4004e034bcf3d3e3f54f4028709e004a5", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/93633ea7343d74c6447ed814c7435e9b1a3ff67a/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93633ea7343d74c6447ed814c7435e9b1a3ff67a/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=93633ea7343d74c6447ed814c7435e9b1a3ff67a", "patch": "@@ -92,7 +92,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n         check_send(cx, var_t, sp);\n \n         // copied in data must be copyable, but moved in data can be anything\n-        if !is_move { check_copy(cx, var_t, sp); }\n+        let is_implicit = fv.is_some();\n+        if !is_move { check_copy(cx, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n         if !is_move {\n@@ -105,7 +106,8 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     fn check_for_box(cx: ctx, fv: option<@freevar_entry>, is_move: bool,\n                      var_t: ty::t, sp: span) {\n         // copied in data must be copyable, but moved in data can be anything\n-        if !is_move { check_copy(cx, var_t, sp); }\n+        let is_implicit = fv.is_some();\n+        if !is_move { check_copy(cx, var_t, sp, is_implicit); }\n \n         // check that only immutable variables are implicitly copied in\n         if !is_move {\n@@ -203,12 +205,16 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n     #debug[\"kind::check_expr(%s)\", expr_to_str(e)];\n     alt e.node {\n-      expr_assign(_, ex) | expr_assign_op(_, _, ex) |\n+      expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n       expr_ret(some(ex)) | expr_cast(ex, _) { maybe_copy(cx, ex); }\n       expr_copy(expr) { check_copy_ex(cx, expr, false); }\n-      // Vector add copies.\n-      expr_binary(add, ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n+      // Vector add copies, but not \"implicitly\"\n+      expr_assign_op(_, _, ex) { check_copy_ex(cx, ex, false) }\n+      expr_binary(add, ls, rs) {\n+        check_copy_ex(cx, ls, false);\n+        check_copy_ex(cx, rs, false);\n+      }\n       expr_rec(fields, def) {\n         for fields.each {|field| maybe_copy(cx, field.node.expr); }\n         alt def {\n@@ -365,17 +371,12 @@ fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     }\n }\n \n-fn check_copy_ex(cx: ctx, ex: @expr, _warn: bool) {\n+fn check_copy_ex(cx: ctx, ex: @expr, implicit_copy: bool) {\n     if ty::expr_is_lval(cx.method_map, ex) &&\n        !cx.last_use_map.contains_key(ex.id) &&\n        !is_nullary_variant(cx, ex) {\n         let ty = ty::expr_ty(cx.tcx, ex);\n-        check_copy(cx, ty, ex.span);\n-        // FIXME turn this on again once vector types are no longer unique.\n-        // Right now, it is too annoying to be useful.\n-        /* if warn && ty::type_is_unique(ty) {\n-            cx.tcx.sess.span_warn(ex.span, \"copying a unique value\");\n-        }*/\n+        check_copy(cx, ty, ex.span, implicit_copy);\n     }\n }\n \n@@ -408,9 +409,14 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n     }\n }\n \n-fn check_copy(cx: ctx, ty: ty::t, sp: span) {\n-    if !ty::kind_can_be_copied(ty::type_kind(cx.tcx, ty)) {\n+fn check_copy(cx: ctx, ty: ty::t, sp: span, implicit_copy: bool) {\n+    let k = ty::type_kind(cx.tcx, ty);\n+    if !ty::kind_can_be_copied(k) {\n         cx.tcx.sess.span_err(sp, \"copying a noncopyable value\");\n+    } else if implicit_copy && !ty::kind_can_be_implicitly_copied(k) {\n+        cx.tcx.sess.span_warn(\n+            sp,\n+            \"implicitly copying a non-implicitly-copyable value\");\n     }\n }\n "}, {"sha": "6da81e26372ed7259fdd9de011394fdbd0036279", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 84, "deletions": 32, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/93633ea7343d74c6447ed814c7435e9b1a3ff67a/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93633ea7343d74c6447ed814c7435e9b1a3ff67a/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=93633ea7343d74c6447ed814c7435e9b1a3ff67a", "patch": "@@ -111,7 +111,8 @@ export ty_to_def_id;\n export ty_fn_args;\n export type_constr;\n export kind, kind_sendable, kind_copyable, kind_noncopyable, kind_const;\n-export kind_can_be_copied, kind_can_be_sent, proto_kind, kind_lteq, type_kind;\n+export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n+export proto_kind, kind_lteq, type_kind;\n export operators;\n export type_err, terr_vstore_kind;\n export type_err_to_str;\n@@ -1268,9 +1269,11 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n \n enum kind { kind_(u32) }\n \n-const KIND_MASK_COPY  : u32 = 0b00000000000000000000000000000001u32;\n-const KIND_MASK_SEND  : u32 = 0b00000000000000000000000000000010u32;\n-const KIND_MASK_CONST : u32 = 0b00000000000000000000000000000100u32;\n+// *ALL* implicity copiable things must be copiable\n+const KIND_MASK_COPY     : u32 = 0b00000000000000000000000000000001u32;\n+const KIND_MASK_SEND     : u32 = 0b00000000000000000000000000000010u32;\n+const KIND_MASK_CONST    : u32 = 0b00000000000000000000000000000100u32;\n+const KIND_MASK_IMPLICIT : u32 = 0b00000000000000000000000000001000u32;\n \n fn kind_noncopyable() -> kind {\n     kind_(0u32)\n@@ -1280,6 +1283,14 @@ fn kind_copyable() -> kind {\n     kind_(KIND_MASK_COPY)\n }\n \n+fn kind_implicitly_copyable() -> kind {\n+    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY)\n+}\n+\n+fn kind_implicitly_sendable() -> kind {\n+    kind_(KIND_MASK_IMPLICIT | KIND_MASK_COPY | KIND_MASK_SEND)\n+}\n+\n fn kind_sendable() -> kind {\n     kind_(KIND_MASK_COPY | KIND_MASK_SEND)\n }\n@@ -1305,6 +1316,10 @@ fn remove_const(k: kind, tm: mt) -> kind {\n     }\n }\n \n+fn remove_implicit(k: kind) -> kind {\n+    k - kind_(KIND_MASK_IMPLICIT)\n+}\n+\n impl operators for kind {\n     fn &(other: kind) -> kind {\n         lower_kind(self, other)\n@@ -1319,9 +1334,13 @@ impl operators for kind {\n     }\n }\n \n-// Using these query functons is preferable to direct comparison or matching\n+// Using these query functions is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n // future.\n+pure fn kind_can_be_implicitly_copied(k: kind) -> bool {\n+    *k & KIND_MASK_IMPLICIT != 0u32\n+}\n+\n pure fn kind_can_be_copied(k: kind) -> bool {\n     *k & KIND_MASK_COPY != 0u32\n }\n@@ -1334,9 +1353,9 @@ fn proto_kind(p: proto) -> kind {\n     alt p {\n       ast::proto_any { kind_noncopyable() }\n       ast::proto_block { kind_noncopyable() }\n-      ast::proto_box { kind_copyable() }\n+      ast::proto_box { kind_implicitly_copyable() }\n       ast::proto_uniq { kind_sendable() }\n-      ast::proto_bare { kind_sendable() | kind_const() }\n+      ast::proto_bare { kind_implicitly_sendable() | kind_const() }\n     }\n }\n \n@@ -1354,13 +1373,34 @@ fn raise_kind(a: kind, b: kind) -> kind {\n \n #[test]\n fn test_kinds() {\n-    // The kind \"lattice\" is nocopy <= copy <= send\n+    // The kind \"lattice\" is defined by the subset operation on the\n+    // set of permitted operations.\n     assert kind_lteq(kind_sendable(), kind_sendable());\n     assert kind_lteq(kind_copyable(), kind_sendable());\n     assert kind_lteq(kind_copyable(), kind_copyable());\n     assert kind_lteq(kind_noncopyable(), kind_sendable());\n     assert kind_lteq(kind_noncopyable(), kind_copyable());\n     assert kind_lteq(kind_noncopyable(), kind_noncopyable());\n+    assert kind_lteq(kind_copyable(), kind_implicitly_copyable());\n+    assert kind_lteq(kind_copyable(), kind_implicitly_sendable());\n+    assert kind_lteq(kind_sendable(), kind_implicitly_sendable());\n+    assert !kind_lteq(kind_sendable(), kind_implicitly_copyable());\n+    assert !kind_lteq(kind_copyable(), kind_send_only());\n+}\n+\n+// Return the most permissive kind that a composite object containing a field\n+// with the given mutability can have.\n+// This is used to prevent objects containing mutable state from being\n+// implicitly copied.\n+fn mutability_kind(m: mutability) -> kind {\n+    alt (m) {\n+      m_mutbl | m_const { remove_implicit(kind_top()) }\n+      m_imm { kind_top() }\n+    }\n+}\n+\n+fn mutable_type_kind(cx: ctxt, ty: mt) -> kind {\n+    lower_kind(mutability_kind(ty.mutbl), type_kind(cx, ty.ty))\n }\n \n fn type_kind(cx: ctxt, ty: t) -> kind {\n@@ -1370,79 +1410,88 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n     }\n \n     // Insert a default in case we loop back on self recursively.\n-    cx.kind_cache.insert(ty, kind_sendable());\n+    cx.kind_cache.insert(ty, kind_top());\n \n     let result = alt get(ty).struct {\n       // Scalar and unique types are sendable\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) | ty_str { kind_sendable() | kind_const() }\n+      ty_ptr(_) { kind_implicitly_sendable() | kind_const() }\n+      // FIXME: this *shouldn't* be implicitly copyable (#2450)\n+      ty_str { kind_implicitly_sendable() | kind_const() }\n       ty_type { kind_copyable() }\n       ty_fn(f) { proto_kind(f.proto) }\n \n       // Closures have kind determined by capture mode\n       ty_opaque_closure_ptr(ck_block) { kind_noncopyable() }\n-      ty_opaque_closure_ptr(ck_box) { kind_copyable() }\n+      ty_opaque_closure_ptr(ck_box) { kind_implicitly_copyable() }\n       ty_opaque_closure_ptr(ck_uniq) { kind_sendable() }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n       ty_box(tm) {\n         if tm.mutbl == ast::m_mutbl {\n-            kind_copyable()\n+            kind_implicitly_copyable()\n         }\n         else {\n             let k = type_kind(cx, tm.ty);\n             if kind_lteq(kind_const(), k) {\n-                kind_copyable() | kind_const()\n+                kind_implicitly_copyable() | kind_const()\n             }\n-            else { kind_copyable() }\n+            else { kind_implicitly_copyable() }\n         }\n       }\n-      ty_iface(_, _) | ty_opaque_box { kind_copyable() }\n-      ty_rptr(_, _) { kind_copyable() }\n+      ty_iface(_, _) | ty_opaque_box { kind_implicitly_copyable() }\n+      ty_rptr(_, _) { kind_implicitly_copyable() }\n \n-      // Unique boxes and vecs have the kind of their contained type.\n-      ty_vec(tm) | ty_uniq(tm) { remove_const(type_kind(cx, tm.ty), tm) }\n+      // Unique boxes and vecs have the kind of their contained type,\n+      // but unique boxes can't be implicitly copyable.\n+      ty_uniq(tm) {\n+        remove_implicit(remove_const(type_kind(cx, tm.ty), tm))\n+      }\n+      // FIXME: Vectors *shouldn't* be implicitly copyable but are (#2450)\n+      ty_vec(tm) { remove_const(mutable_type_kind(cx, tm), tm) }\n \n       // Slice and refcounted evecs are copyable; uniques and interiors\n-      // depend on the their contained type.\n+      // depend on the their contained type, but aren't implicitly copyable.\n       ty_evec(tm, vstore_box) |\n       ty_evec(tm, vstore_slice(_)) {\n         if kind_lteq(kind_const(), type_kind(cx, tm.ty)) {\n-            kind_copyable() | kind_const()\n+            kind_implicitly_copyable() | kind_const()\n         }\n         else {\n-            kind_const()\n+            kind_implicitly_copyable()\n         }\n       }\n       ty_evec(tm, vstore_uniq) |\n-      ty_evec(tm, vstore_fixed(_)) { remove_const(type_kind(cx, tm.ty), tm) }\n+      ty_evec(tm, vstore_fixed(_)) {\n+        remove_implicit(remove_const(type_kind(cx, tm.ty), tm))\n+      }\n \n       // All estrs are copyable; uniques and interiors are sendable.\n       ty_estr(vstore_box) |\n-      ty_estr(vstore_slice(_)) { kind_copyable() | kind_const() }\n+      ty_estr(vstore_slice(_)) { kind_implicitly_copyable() | kind_const() }\n       ty_estr(vstore_uniq) |\n       ty_estr(vstore_fixed(_)) { kind_sendable() | kind_const() }\n \n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         let mut lowest = kind_top();\n         for flds.each {|f|\n-            lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n+            lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n             lowest = remove_const(lowest, f.mt);\n         }\n         lowest\n       }\n       // FIXME: (tjc) there are rules about when classes are copyable/\n       // sendable, but I'm just treating them like records (#1726)\n       ty_class(did, substs) {\n-          // also factor out this code, copied from the records case\n-          let mut lowest = kind_top();\n-          let flds = class_items_as_fields(cx, did, substs);\n-          for flds.each {|f|\n-            lowest = lower_kind(lowest, type_kind(cx, f.mt.ty));\n-          }\n-          lowest\n+        // also factor out this code, copied from the records case\n+        let mut lowest = kind_top();\n+        let flds = class_items_as_fields(cx, did, substs);\n+        for flds.each {|f|\n+            lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n+        }\n+        lowest\n       }\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n@@ -1470,7 +1519,10 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       }\n       ty_res(did, inner, tps) { kind_send_only() }\n       ty_param(_, did) {\n-          param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n+        // FIXME: type params shouldn't be implicitly copyable (#2449)\n+        let k = param_bounds_to_kind(cx.ty_param_bounds.get(did.node));\n+        if kind_can_be_copied(k)\n+            { raise_kind(k, kind_implicitly_copyable()) } else { k }\n       }\n       ty_constr(t, _) { type_kind(cx, t) }\n       // FIXME: is self ever const?"}]}