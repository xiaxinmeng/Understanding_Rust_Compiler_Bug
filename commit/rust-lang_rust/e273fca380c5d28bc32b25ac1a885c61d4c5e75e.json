{"sha": "e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "node_id": "C_kwDOAAsO6NoAKGUyNzNmY2EzODBjNWQyOGJjMzJiMjVhYzFhODg1YzYxZDRjNWU3NWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-11T06:26:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-11T06:26:47Z"}, "message": "Auto merge of #93865 - flip1995:clippyup, r=Manishearth,flip1995\n\nUpdate Clippy\n\nr? `@Manishearth`", "tree": {"sha": "870304e43c9a3ee291f2e277d0f56b7f574c1a54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/870304e43c9a3ee291f2e277d0f56b7f574c1a54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "html_url": "https://github.com/rust-lang/rust/commit/e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e646f3d2a9541952310778288854943678738ea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e646f3d2a9541952310778288854943678738ea9", "html_url": "https://github.com/rust-lang/rust/commit/e646f3d2a9541952310778288854943678738ea9"}, {"sha": "04c9842ebecea8959ba3da36ab948f4a43b996e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/04c9842ebecea8959ba3da36ab948f4a43b996e0", "html_url": "https://github.com/rust-lang/rust/commit/04c9842ebecea8959ba3da36ab948f4a43b996e0"}], "stats": {"total": 7624, "additions": 4465, "deletions": 3159}, "files": [{"sha": "c9adf77c0d639a0560073ea4889d32b06bb60344", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 177, "deletions": 4, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -6,14 +6,185 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[e181011...master](https://github.com/rust-lang/rust-clippy/compare/e181011...master)\n+[0eff589...master](https://github.com/rust-lang/rust-clippy/compare/0eff589...master)\n \n-## Rust 1.58 (beta)\n+## Rust 1.59 (beta)\n \n-Current beta, release 2022-01-13\n+Current beta, release 2022-02-24\n+\n+[e181011...0eff589](https://github.com/rust-lang/rust-clippy/compare/e181011...0eff589)\n+\n+### New Lints\n+\n+* [`index_refutable_slice`]\n+  [#7643](https://github.com/rust-lang/rust-clippy/pull/7643)\n+* [`needless_splitn`]\n+  [#7896](https://github.com/rust-lang/rust-clippy/pull/7896)\n+* [`unnecessary_to_owned`]\n+  [#7978](https://github.com/rust-lang/rust-clippy/pull/7978)\n+* [`needless_late_init`]\n+  [#7995](https://github.com/rust-lang/rust-clippy/pull/7995)\n+* [`octal_escapes`] [#8007](https://github.com/rust-lang/rust-clippy/pull/8007)\n+* [`return_self_not_must_use`]\n+  [#8071](https://github.com/rust-lang/rust-clippy/pull/8071)\n+* [`init_numbered_fields`]\n+  [#8170](https://github.com/rust-lang/rust-clippy/pull/8170)\n+\n+### Moves and Deprecations\n+\n+* Move `if_then_panic` to `pedantic` and rename to [`manual_assert`] (now\n+  allow-by-default) [#7810](https://github.com/rust-lang/rust-clippy/pull/7810)\n+* Rename `disallow_type` to [`disallowed_types`] and `disallowed_method` to\n+  [`disallowed_methods`]\n+  [#7984](https://github.com/rust-lang/rust-clippy/pull/7984)\n+* Move [`map_flatten`] to `complexity` (now warn-by-default)\n+  [#8054](https://github.com/rust-lang/rust-clippy/pull/8054)\n+\n+### Enhancements\n+\n+* [`match_overlapping_arm`]: Fix false negative where after included ranges,\n+  overlapping ranges weren't linted anymore\n+  [#7909](https://github.com/rust-lang/rust-clippy/pull/7909)\n+* [`deprecated_cfg_attr`]: Now takes the specified MSRV into account\n+  [#7944](https://github.com/rust-lang/rust-clippy/pull/7944)\n+* [`cast_lossless`]: Now also lints for `bool` to integer casts\n+  [#7948](https://github.com/rust-lang/rust-clippy/pull/7948)\n+* [`let_underscore_lock`]: Also emit lints for the `parking_lot` crate\n+  [#7957](https://github.com/rust-lang/rust-clippy/pull/7957)\n+* [`needless_borrow`]\n+  [#7977](https://github.com/rust-lang/rust-clippy/pull/7977)\n+    * Lint when a borrow is auto-dereffed more than once\n+    * Lint in the trailing expression of a block for a match arm\n+* [`strlen_on_c_strings`]\n+  [8001](https://github.com/rust-lang/rust-clippy/pull/8001)\n+    * Lint when used without a fully-qualified path\n+    * Suggest removing the surrounding unsafe block when possible\n+* [`non_ascii_literal`]: Now also lints on `char`s, not just `string`s\n+  [#8034](https://github.com/rust-lang/rust-clippy/pull/8034)\n+* [`single_char_pattern`]: Now also lints on `split_inclusive`, `split_once`,\n+  `rsplit_once`, `replace`, and `replacen`\n+  [#8077](https://github.com/rust-lang/rust-clippy/pull/8077)\n+* [`unwrap_or_else_default`]: Now also lints on `std` constructors like\n+  `Vec::new`, `HashSet::new`, and `HashMap::new`\n+  [#8163](https://github.com/rust-lang/rust-clippy/pull/8163)\n+* [`shadow_reuse`]: Now also lints on shadowed `if let` bindings, instead of\n+  [`shadow_unrelated`]\n+  [#8165](https://github.com/rust-lang/rust-clippy/pull/8165)\n+\n+### False Positive Fixes\n+\n+* [`or_fun_call`], [`unnecessary_lazy_evaluations`]: Improve heuristics, so that\n+  cheap functions (e.g. calling `.len()` on a `Vec`) won't get linted anymore\n+  [#7639](https://github.com/rust-lang/rust-clippy/pull/7639)\n+* [`manual_split_once`]: No longer suggests code changing the original behavior\n+  [#7896](https://github.com/rust-lang/rust-clippy/pull/7896)\n+* Don't show [`no_effect`] or [`unnecessary_operation`] warning for unit struct\n+  implementing `FnOnce`\n+  [#7898](https://github.com/rust-lang/rust-clippy/pull/7898)\n+* [`semicolon_if_nothing_returned`]: Fixed a bug, where the lint wrongly\n+  triggered on `let-else` statements\n+  [#7955](https://github.com/rust-lang/rust-clippy/pull/7955)\n+* [`if_then_some_else_none`]: No longer lints if there is an early return\n+  [#7980](https://github.com/rust-lang/rust-clippy/pull/7980)\n+* [`needless_collect`]: No longer suggests removal of `collect` when removal\n+  would create code requiring mutably borrowing a value multiple times\n+  [#7982](https://github.com/rust-lang/rust-clippy/pull/7982)\n+* [`shadow_same`]: Fix false positive for `async` function's params\n+  [#7997](https://github.com/rust-lang/rust-clippy/pull/7997)\n+* [`suboptimal_flops`]: No longer triggers in constant functions\n+  [#8009](https://github.com/rust-lang/rust-clippy/pull/8009)\n+* [`type_complexity`]: No longer lints on associated types in traits\n+  [#8030](https://github.com/rust-lang/rust-clippy/pull/8030)\n+* [`question_mark`]: No longer lints if returned object is not local\n+  [#8080](https://github.com/rust-lang/rust-clippy/pull/8080)\n+* [`option_if_let_else`]: No longer lint on complex sub-patterns\n+  [#8086](https://github.com/rust-lang/rust-clippy/pull/8086)\n+* [`blocks_in_if_conditions`]: No longer lints on empty closures\n+  [#8100](https://github.com/rust-lang/rust-clippy/pull/8100)\n+* [`enum_variant_names`]: No longer lint when first prefix is only a substring\n+  of a camel-case word\n+  [#8127](https://github.com/rust-lang/rust-clippy/pull/8127)\n+* [`identity_op`]: Only lint on integral operands\n+  [#8183](https://github.com/rust-lang/rust-clippy/pull/8183)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`search_is_some`]: Fix suggestion for `any()` not taking item by reference\n+  [#7463](https://github.com/rust-lang/rust-clippy/pull/7463)\n+* [`almost_swapped`]: Now detects if there is a `no_std` or `no_core` attribute\n+  and adapts the suggestion accordingly\n+  [#7877](https://github.com/rust-lang/rust-clippy/pull/7877)\n+* [`redundant_pattern_matching`]: Fix suggestion for deref expressions\n+  [#7949](https://github.com/rust-lang/rust-clippy/pull/7949)\n+* [`explicit_counter_loop`]: Now also produces a suggestion for non-`usize`\n+  types [#7950](https://github.com/rust-lang/rust-clippy/pull/7950)\n+* [`manual_map`]: Fix suggestion when used with unsafe functions and blocks\n+  [#7968](https://github.com/rust-lang/rust-clippy/pull/7968)\n+* [`option_map_or_none`]: Suggest `map` over `and_then` when possible\n+  [#7971](https://github.com/rust-lang/rust-clippy/pull/7971)\n+* [`option_if_let_else`]: No longer expands macros in the suggestion\n+  [#7974](https://github.com/rust-lang/rust-clippy/pull/7974)\n+* [`iter_cloned_collect`]: Suggest `copied` over `cloned` when possible\n+  [#8006](https://github.com/rust-lang/rust-clippy/pull/8006)\n+* [`doc_markdown`]: No longer uses inline hints to improve readability of\n+  suggestion [#8011](https://github.com/rust-lang/rust-clippy/pull/8011)\n+* [`needless_question_mark`]: Now better explains the suggestion\n+  [#8028](https://github.com/rust-lang/rust-clippy/pull/8028)\n+* [`single_char_pattern`]: Escape backslash `\\` in suggestion\n+  [#8067](https://github.com/rust-lang/rust-clippy/pull/8067)\n+* [`needless_bool`]: Suggest `a != b` over `!(a == b)`\n+  [#8117](https://github.com/rust-lang/rust-clippy/pull/8117)\n+* [`iter_skip_next`]: Suggest to add a `mut` if it is necessary in order to\n+  apply this lints suggestion\n+  [#8133](https://github.com/rust-lang/rust-clippy/pull/8133)\n+* [`neg_multiply`]: Now produces a suggestion\n+  [#8144](https://github.com/rust-lang/rust-clippy/pull/8144)\n+* [`needless_return`]: Now suggests the unit type `()` over an empty block `{}`\n+  in match arms [#8185](https://github.com/rust-lang/rust-clippy/pull/8185)\n+* [`suboptimal_flops`]: Now gives a syntactically correct suggestion for\n+  `to_radians` and `to_degrees`\n+  [#8187](https://github.com/rust-lang/rust-clippy/pull/8187)\n+\n+### ICE Fixes\n+\n+* [`undocumented_unsafe_blocks`]\n+  [#7945](https://github.com/rust-lang/rust-clippy/pull/7945)\n+  [#7988](https://github.com/rust-lang/rust-clippy/pull/7988)\n+* [`unnecessary_cast`]\n+  [#8167](https://github.com/rust-lang/rust-clippy/pull/8167)\n+\n+### Documentation Improvements\n+\n+* [`print_stdout`], [`print_stderr`], [`dbg_macro`]: Document how the lint level\n+  can be changed crate-wide\n+  [#8040](https://github.com/rust-lang/rust-clippy/pull/8040)\n+* Added a note to the `README` that config changes don't apply to already\n+  compiled code [#8175](https://github.com/rust-lang/rust-clippy/pull/8175)\n+\n+### Others\n+\n+* [Clippy's lint\n+  list](https://rust-lang.github.io/rust-clippy/master/index.html) now displays\n+  the version a lint was added. :tada:\n+  [#7813](https://github.com/rust-lang/rust-clippy/pull/7813)\n+* New and improved issue templates\n+  [#8032](https://github.com/rust-lang/rust-clippy/pull/8032)\n+* _Dev:_ Add `cargo dev lint` command, to run your modified Clippy version on a\n+  file [#7917](https://github.com/rust-lang/rust-clippy/pull/7917)\n+\n+## Rust 1.58\n+\n+Current stable, released 2022-01-13\n \n [00e31fa...e181011](https://github.com/rust-lang/rust-clippy/compare/00e31fa...e181011)\n \n+### Rust 1.58.1\n+\n+* Move [`non_send_fields_in_send_ty`] to `nursery` (now allow-by-default)\n+  [#8075](https://github.com/rust-lang/rust-clippy/pull/8075)\n+* [`useless_format`]: Handle implicit named arguments\n+  [#8295](https://github.com/rust-lang/rust-clippy/pull/8295)\n+\n ### New lints\n \n * [`transmute_num_to_bytes`]\n@@ -124,7 +295,7 @@ Current beta, release 2022-01-13\n \n ## Rust 1.57\n \n-Current stable, released 2021-12-02\n+Released 2021-12-02\n \n [7bfc26e...00e31fa](https://github.com/rust-lang/rust-clippy/compare/7bfc26e...00e31fa)\n \n@@ -2930,6 +3101,7 @@ Released 2018-09-13\n [`declare_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n [`default_numeric_fallback`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_numeric_fallback\n [`default_trait_access`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_trait_access\n+[`default_union_representation`]: https://rust-lang.github.io/rust-clippy/master/index.html#default_union_representation\n [`deprecated_cfg_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_cfg_attr\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n@@ -3303,6 +3475,7 @@ Released 2018-09-13\n [`transmute_num_to_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_num_to_bytes\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmute_undefined_repr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_undefined_repr\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex"}, {"sha": "b0fb39e8169968aa57624a6d988879a11021b02c", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "modified", "additions": 18, "deletions": 47, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -5,9 +5,7 @@ use std::ffi::OsStr;\n use std::fs;\n use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n-use walkdir::WalkDir;\n-\n-use crate::clippy_project_root;\n+use walkdir::{DirEntry, WalkDir};\n \n #[cfg(not(windows))]\n static CARGO_CLIPPY_EXE: &str = \"cargo-clippy\";\n@@ -24,43 +22,25 @@ static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> = SyncLazy::ne\n ///\n /// Panics if the path to a test file is broken\n pub fn bless(ignore_timestamp: bool) {\n-    let test_suite_dirs = [\n-        clippy_project_root().join(\"tests\").join(\"ui\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-internal\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-toml\"),\n-        clippy_project_root().join(\"tests\").join(\"ui-cargo\"),\n-    ];\n-    for test_suite_dir in &test_suite_dirs {\n-        WalkDir::new(test_suite_dir)\n-            .into_iter()\n-            .filter_map(Result::ok)\n-            .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n-            .for_each(|f| {\n-                let test_name = f.path().strip_prefix(test_suite_dir).unwrap();\n-                for &ext in &[\"stdout\", \"stderr\", \"fixed\"] {\n-                    let test_name_ext = format!(\"stage-id.{}\", ext);\n-                    update_reference_file(\n-                        f.path().with_extension(ext),\n-                        test_name.with_extension(test_name_ext),\n-                        ignore_timestamp,\n-                    );\n-                }\n-            });\n-    }\n+    let extensions = [\"stdout\", \"stderr\", \"fixed\"].map(OsStr::new);\n+\n+    WalkDir::new(build_dir())\n+        .into_iter()\n+        .map(Result::unwrap)\n+        .filter(|entry| entry.path().extension().map_or(false, |ext| extensions.contains(&ext)))\n+        .for_each(|entry| update_reference_file(&entry, ignore_timestamp));\n }\n \n-fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignore_timestamp: bool) {\n-    let test_output_path = build_dir().join(test_name);\n-    let relative_reference_file_path = reference_file_path.strip_prefix(clippy_project_root()).unwrap();\n+fn update_reference_file(test_output_entry: &DirEntry, ignore_timestamp: bool) {\n+    let test_output_path = test_output_entry.path();\n \n-    // If compiletest did not write any changes during the test run,\n-    // we don't have to update anything\n-    if !test_output_path.exists() {\n-        return;\n-    }\n+    let reference_file_name = test_output_entry.file_name().to_str().unwrap().replace(\".stage-id\", \"\");\n+    let reference_file_path = Path::new(\"tests\")\n+        .join(test_output_path.strip_prefix(build_dir()).unwrap())\n+        .with_file_name(reference_file_name);\n \n     // If the test output was not updated since the last clippy build, it may be outdated\n-    if !ignore_timestamp && !updated_since_clippy_build(&test_output_path).unwrap_or(true) {\n+    if !ignore_timestamp && !updated_since_clippy_build(test_output_entry).unwrap_or(true) {\n         return;\n     }\n \n@@ -69,23 +49,14 @@ fn update_reference_file(reference_file_path: PathBuf, test_name: PathBuf, ignor\n \n     if test_output_file != reference_file {\n         // If a test run caused an output file to change, update the reference file\n-        println!(\"updating {}\", &relative_reference_file_path.display());\n+        println!(\"updating {}\", reference_file_path.display());\n         fs::copy(test_output_path, &reference_file_path).expect(\"Could not update reference file\");\n-\n-        // We need to re-read the file now because it was potentially updated from copying\n-        let reference_file = fs::read(&reference_file_path).unwrap_or_default();\n-\n-        if reference_file.is_empty() {\n-            // If we copied over an empty output file, we remove the now empty reference file\n-            println!(\"removing {}\", &relative_reference_file_path.display());\n-            fs::remove_file(reference_file_path).expect(\"Could not remove reference file\");\n-        }\n     }\n }\n \n-fn updated_since_clippy_build(path: &Path) -> Option<bool> {\n+fn updated_since_clippy_build(entry: &DirEntry) -> Option<bool> {\n     let clippy_build_time = (*CLIPPY_BUILD_TIME)?;\n-    let modified = fs::metadata(path).ok()?.modified().ok()?;\n+    let modified = entry.metadata().ok()?.modified().ok()?;\n     Some(modified >= clippy_build_time)\n }\n "}, {"sha": "4c4dd85d518a62ae9db0938d05f56f8fdfed47dc", "filename": "src/tools/clippy/clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::get_parent_expr;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{differing_macro_contexts, get_parent_expr};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         if let Some(ex) = &block.expr {\n                             // don't dig into the expression here, just suggest that they remove\n                             // the block\n-                            if expr.span.from_expansion() || differing_macro_contexts(expr.span, ex.span) {\n+                            if expr.span.from_expansion() || ex.span.from_expansion() {\n                                 return;\n                             }\n                             let mut applicability = Applicability::MachineApplicable;\n@@ -122,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                         }\n                     } else {\n                         let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n-                        if span.from_expansion() || differing_macro_contexts(expr.span, span) {\n+                        if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }\n                         // move block higher"}, {"sha": "9b5da0bd8a66009405623eb817f6c91c10e31709", "filename": "src/tools/clippy/clippy_lints/src/default_union_representation.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,105 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::{self as hir, HirId, Item, ItemKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::layout::LayoutOf;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Displays a warning when a union is declared with the default representation (without a `#[repr(C)]` attribute).\n+    ///\n+    /// ### Why is this bad?\n+    /// Unions in Rust have unspecified layout by default, despite many people thinking that they\n+    /// lay out each field at the start of the union (like C does). That is, there are no guarantees\n+    /// about the offset of the fields for unions with multiple non-ZST fields without an explicitly\n+    /// specified layout. These cases may lead to undefined behavior in unsafe blocks.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// union Foo {\n+    ///     a: i32,\n+    ///     b: u32,\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let _x: u32 = unsafe {\n+    ///         Foo { a: 0_i32 }.b // Undefined behaviour: `b` is allowed to be padding\n+    ///     };\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// union Foo {\n+    ///     a: i32,\n+    ///     b: u32,\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let _x: u32 = unsafe {\n+    ///         Foo { a: 0_i32 }.b // Now defined behaviour, this is just an i32 -> u32 transmute\n+    ///     };\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub DEFAULT_UNION_REPRESENTATION,\n+    restriction,\n+    \"unions without a `#[repr(C)]` attribute\"\n+}\n+declare_lint_pass!(DefaultUnionRepresentation => [DEFAULT_UNION_REPRESENTATION]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DefaultUnionRepresentation {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if is_union_with_two_non_zst_fields(cx, item) && !has_c_repr_attr(cx, item.hir_id()) {\n+            span_lint_and_help(\n+                cx,\n+                DEFAULT_UNION_REPRESENTATION,\n+                item.span,\n+                \"this union has the default representation\",\n+                None,\n+                &format!(\n+                    \"consider annotating `{}` with `#[repr(C)]` to explicitly specify memory layout\",\n+                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Returns true if the given item is a union with at least two non-ZST fields.\n+fn is_union_with_two_non_zst_fields(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n+    if let ItemKind::Union(data, _) = &item.kind {\n+        data.fields().iter().filter(|f| !is_zst(cx, f.ty)).count() >= 2\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_zst(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) -> bool {\n+    if hir_ty.span.from_expansion() {\n+        return false;\n+    }\n+    let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+    if let Ok(layout) = cx.layout_of(ty) {\n+        layout.is_zst()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn has_c_repr_attr(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n+    cx.tcx.hir().attrs(hir_id).iter().any(|attr| {\n+        if attr.has_name(sym::repr) {\n+            if let Some(items) = attr.meta_item_list() {\n+                for item in items {\n+                    if item.is_word() && matches!(item.name_or_empty(), sym::C) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    })\n+}"}, {"sha": "4c12202c84ab39da96a0c1a54e5b7cb78a43f19c", "filename": "src/tools/clippy/clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for (index, conf) in self.conf_disallowed.iter().enumerate() {\n             let segs: Vec<_> = conf.path().split(\"::\").collect();\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n                 self.disallowed.insert(id, index);\n             }\n         }"}, {"sha": "14f89edce615db9993d811d34e6e8d42d62f8b14", "filename": "src/tools/clippy/clippy_lints/src/disallowed_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdisallowed_types.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedTypes {\n                 ),\n             };\n             let segs: Vec<_> = path.split(\"::\").collect();\n-            match clippy_utils::path_to_res(cx, &segs) {\n+            match clippy_utils::def_path_res(cx, &segs) {\n                 Res::Def(_, id) => {\n                     self.def_ids.insert(id, reason);\n                 },"}, {"sha": "3e2217c28da3a0dee72c6d62b567fe6fb3014436", "filename": "src/tools/clippy/clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexplicit_write.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,6 @@\n-use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::macros::FormatArgsExpn;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{is_expn_of, match_function_call, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -79,28 +80,22 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitWrite {\n                         \"print\".into(),\n                     )\n                 };\n-                let msg = format!(\"use of `{}.unwrap()`\", used);\n-                if let [write_output] = *format_args.format_string_parts {\n-                    let mut write_output = write_output.to_string();\n-                    if write_output.ends_with('\\n') {\n-                        write_output.pop();\n-                    }\n-\n-                    let sugg = format!(\"{}{}!(\\\"{}\\\")\", prefix, sugg_mac, write_output.escape_default());\n-                    span_lint_and_sugg(\n-                        cx,\n-                        EXPLICIT_WRITE,\n-                        expr.span,\n-                        &msg,\n-                        \"try this\",\n-                        sugg,\n-                        Applicability::MachineApplicable\n-                    );\n-                } else {\n-                    // We don't have a proper suggestion\n-                    let help = format!(\"consider using `{}{}!` instead\", prefix, sugg_mac);\n-                    span_lint_and_help(cx, EXPLICIT_WRITE, expr.span, &msg, None, &help);\n-                }\n+                let mut applicability = Applicability::MachineApplicable;\n+                let inputs_snippet = snippet_with_applicability(\n+                    cx,\n+                    format_args.inputs_span(),\n+                    \"..\",\n+                    &mut applicability,\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    EXPLICIT_WRITE,\n+                    expr.span,\n+                    &format!(\"use of `{}.unwrap()`\", used),\n+                    \"try this\",\n+                    format!(\"{}{}!({})\", prefix, sugg_mac, inputs_snippet),\n+                    applicability,\n+                )\n             }\n         }\n     }"}, {"sha": "57964b8d48ea9c4904282e191e097b044b140534", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_note};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_opt;\n use if_chain::if_chain;\n use rustc_ast::ast::{BinOpKind, Block, Expr, ExprKind, StmtKind, UnOp};\n@@ -135,7 +134,7 @@ impl EarlyLintPass for Formatting {\n /// Implementation of the `SUSPICIOUS_ASSIGNMENT_FORMATTING` lint.\n fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n     if let ExprKind::Assign(ref lhs, ref rhs, _) = expr.kind {\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion() {\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion() {\n             let eq_span = lhs.span.between(rhs.span);\n             if let ExprKind::Unary(op, ref sub_rhs) = rhs.kind {\n                 if let Some(eq_snippet) = snippet_opt(cx, eq_span) {\n@@ -165,7 +164,7 @@ fn check_assign(cx: &EarlyContext<'_>, expr: &Expr) {\n fn check_unop(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::Binary(ref binop, ref lhs, ref rhs) = expr.kind;\n-        if !differing_macro_contexts(lhs.span, rhs.span) && !lhs.span.from_expansion();\n+        if !lhs.span.from_expansion() && !rhs.span.from_expansion();\n         // span between BinOp LHS and RHS\n         let binop_span = lhs.span.between(rhs.span);\n         // if RHS is an UnOp\n@@ -206,8 +205,8 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n     if_chain! {\n         if let ExprKind::If(_, then, Some(else_)) = &expr.kind;\n         if is_block(else_) || is_if(else_);\n-        if !differing_macro_contexts(then.span, else_.span);\n-        if !then.span.from_expansion() && !in_external_macro(cx.sess(), expr.span);\n+        if !then.span.from_expansion() && !else_.span.from_expansion();\n+        if !in_external_macro(cx.sess(), expr.span);\n \n         // workaround for rust-lang/rust#43081\n         if expr.span.lo().0 != 0 && expr.span.hi().0 != 0;\n@@ -268,7 +267,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n         for element in array {\n             if_chain! {\n                 if let ExprKind::Binary(ref op, ref lhs, _) = element.kind;\n-                if has_unary_equivalent(op.node) && !differing_macro_contexts(lhs.span, op.span);\n+                if has_unary_equivalent(op.node) && lhs.span.ctxt() == op.span.ctxt();\n                 let space_span = lhs.span.between(op.span);\n                 if let Some(space_snippet) = snippet_opt(cx, space_span);\n                 let lint_span = lhs.span.with_lo(lhs.span.hi());\n@@ -291,8 +290,7 @@ fn check_array(cx: &EarlyContext<'_>, expr: &Expr) {\n \n fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n     if_chain! {\n-        if !differing_macro_contexts(first.span, second.span);\n-        if !first.span.from_expansion();\n+        if !first.span.from_expansion() && !second.span.from_expansion();\n         if let ExprKind::If(cond_expr, ..) = &first.kind;\n         if is_block(second) || is_if(second);\n "}, {"sha": "5e4cde553b52e954a0bf7e30f2eed0ef0531e21c", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -17,7 +17,6 @@ use rustc_typeck::hir_ty_to_ty;\n use if_chain::if_chain;\n \n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::{snippet, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n \n@@ -123,7 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                 vis.visit_ty(impl_.self_ty);\n \n                 for target in &vis.found {\n-                    if differing_macro_contexts(item.span, target.span()) {\n+                    if item.span.ctxt() != target.span().ctxt() {\n                         return;\n                     }\n "}, {"sha": "b6badef02f58a989e4fa23332fded3c3d3fa7a99", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, higher, is_qpath_def_path, paths};\n+use clippy_utils::{get_trait_def_id, higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -167,13 +167,9 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => {\n-            if let ExprKind::Path(ref qpath) = path.kind {\n-                is_qpath_def_path(cx, qpath, path.hir_id, &paths::ITER_REPEAT).into()\n-            } else {\n-                Finite\n-            }\n-        },\n+        ExprKind::Call(path, _) => path_def_id(cx, path)\n+            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n+            .into(),\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "d93e34e76b492bc9320fd4eb6aa6bf8ce4a3a151", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -277,6 +277,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "d013daa8e082a72eb316681fb421749cf455292c", "filename": "src/tools/clippy/clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -58,6 +58,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n     LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "a80320a578f0e7ba609c90fad800c08ab7c8b456", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -92,6 +92,7 @@ store.register_lints(&[\n     default::DEFAULT_TRAIT_ACCESS,\n     default::FIELD_REASSIGN_WITH_DEFAULT,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n+    default_union_representation::DEFAULT_UNION_REPRESENTATION,\n     dereference::EXPLICIT_DEREF_METHODS,\n     dereference::NEEDLESS_BORROW,\n     dereference::REF_BINDING_TO_REFERENCE,\n@@ -472,6 +473,7 @@ store.register_lints(&[\n     transmute::TRANSMUTE_NUM_TO_BYTES,\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n+    transmute::TRANSMUTE_UNDEFINED_REPR,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,"}, {"sha": "5a89fdb05a9904ab1442fd73bada9b12c7be9a37", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -12,6 +12,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(create_dir::CREATE_DIR),\n     LintId::of(dbg_macro::DBG_MACRO),\n     LintId::of(default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK),\n+    LintId::of(default_union_representation::DEFAULT_UNION_REPRESENTATION),\n     LintId::of(disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS),\n     LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n     LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),"}, {"sha": "5c45012ef0686c12bc2e9b5bdbb38bab033b7184", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -17,6 +17,8 @@\n #![warn(rust_2018_idioms, unused_lifetimes)]\n // warn on rustc internal lints\n #![warn(rustc::internal)]\n+// Disable this rustc lint for now, as it was also done in rustc\n+#![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n@@ -189,6 +191,7 @@ mod create_dir;\n mod dbg_macro;\n mod default;\n mod default_numeric_fallback;\n+mod default_union_representation;\n mod dereference;\n mod derivable_impls;\n mod derive;\n@@ -859,6 +862,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| Box::new(single_char_lifetime_names::SingleCharLifetimeNames));\n     store.register_late_pass(move || Box::new(borrow_as_ptr::BorrowAsPtr::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n+    store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "36ecd83f7d643734e0f0f2df0977cd63f3c5ea70", "filename": "src/tools/clippy/clippy_lints/src/loops/single_element_loop.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsingle_element_loop.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,10 +1,9 @@\n use super::SINGLE_ELEMENT_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::single_segment_path;\n-use clippy_utils::source::{indent_of, snippet};\n+use clippy_utils::source::{indent_of, snippet_with_applicability};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Pat};\n use rustc_lint::LateContext;\n \n pub(super) fn check<'tcx>(\n@@ -16,33 +15,30 @@ pub(super) fn check<'tcx>(\n ) {\n     let arg_expr = match arg.kind {\n         ExprKind::AddrOf(BorrowKind::Ref, _, ref_arg) => ref_arg,\n-        ExprKind::MethodCall(method, args, _) if args.len() == 1 && method.ident.name == rustc_span::sym::iter => {\n-            &args[0]\n-        },\n+        ExprKind::MethodCall(method, [arg], _) if method.ident.name == rustc_span::sym::iter => arg,\n         _ => return,\n     };\n     if_chain! {\n-        if let PatKind::Binding(.., target, _) = pat.kind;\n         if let ExprKind::Array([arg_expression]) = arg_expr.kind;\n-        if let ExprKind::Path(ref list_item) = arg_expression.kind;\n-        if let Some(list_item_name) = single_segment_path(list_item).map(|ps| ps.ident.name);\n         if let ExprKind::Block(block, _) = body.kind;\n         if !block.stmts.is_empty();\n-\n         then {\n-            let mut block_str = snippet(cx, block.span, \"..\").into_owned();\n+            let mut applicability = Applicability::MachineApplicable;\n+            let pat_snip = snippet_with_applicability(cx, pat.span, \"..\", &mut applicability);\n+            let arg_snip = snippet_with_applicability(cx, arg_expression.span, \"..\", &mut applicability);\n+            let mut block_str = snippet_with_applicability(cx, block.span, \"..\", &mut applicability).into_owned();\n             block_str.remove(0);\n             block_str.pop();\n-\n+            let indent = \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0));\n \n             span_lint_and_sugg(\n                 cx,\n                 SINGLE_ELEMENT_LOOP,\n                 expr.span,\n                 \"for loop over a single element\",\n                 \"try\",\n-                format!(\"{{\\n{}let {} = &{};{}}}\", \" \".repeat(indent_of(cx, block.stmts[0].span).unwrap_or(0)), target.name, list_item_name, block_str),\n-                Applicability::MachineApplicable\n+                format!(\"{{\\n{}let {} = &{};{}}}\", indent, pat_snip, arg_snip, block_str),\n+                applicability,\n             )\n         }\n     }"}, {"sha": "b6c746d3e397116fd1e6856a8a646f696076ef53", "filename": "src/tools/clippy/clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Futils.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::intravisit::{walk_expr, walk_local, walk_pat, walk_stmt, Visitor}\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, HirId, HirIdMap, Local, Mutability, Pat, PatKind, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_typeck::hir_ty_to_ty;\n@@ -332,18 +332,21 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n     } else {\n         // (&x).into_iter() ==> x.iter()\n         // (&mut x).into_iter() ==> x.iter_mut()\n-        match &arg.kind {\n-            ExprKind::AddrOf(BorrowKind::Ref, mutability, arg_inner)\n-                if has_iter_method(cx, cx.typeck_results().expr_ty(arg_inner)).is_some() =>\n-            {\n-                let meth_name = match mutability {\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n+        match &arg_ty.kind() {\n+            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, inner_ty).is_some() => {\n+                let method_name = match mutbl {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\",\n                 };\n+                let caller = match &arg.kind {\n+                    ExprKind::AddrOf(BorrowKind::Ref, _, arg_inner) => arg_inner,\n+                    _ => arg,\n+                };\n                 format!(\n                     \"{}.{}()\",\n-                    sugg::Sugg::hir_with_applicability(cx, arg_inner, \"_\", applic_ref).maybe_par(),\n-                    meth_name,\n+                    sugg::Sugg::hir_with_applicability(cx, caller, \"_\", applic_ref).maybe_par(),\n+                    method_name,\n                 )\n             },\n             _ => format!("}, {"sha": "e61cb4d227363c67529be6ecbef20cddb9122c16", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "removed", "additions": 0, "deletions": 2342, "changes": 2342, "blob_url": "https://github.com/rust-lang/rust/blob/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=e646f3d2a9541952310778288854943678738ea9", "patch": "@@ -1,2342 +0,0 @@\n-use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n-use clippy_utils::diagnostics::{\n-    multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n-};\n-use clippy_utils::macros::{is_panic, root_macro_call};\n-use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n-use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n-use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{\n-    get_parent_expr, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n-    strip_pat_refs,\n-};\n-use clippy_utils::{higher, peel_blocks_with_stmt};\n-use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n-use core::iter::{once, ExactSizeIterator};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{Attribute, LitKind};\n-use rustc_errors::Applicability;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    self as hir, Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, HirId, Local, MatchSource,\n-    Mutability, Node, Pat, PatKind, PathSegment, QPath, RangeEnd, TyKind,\n-};\n-use rustc_hir::{HirIdMap, HirIdSet};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty, VariantDef};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n-use rustc_span::{sym, symbol::kw};\n-use std::cmp::Ordering;\n-use std::collections::hash_map::Entry;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with a single arm where an `if let`\n-    /// will usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn bar(stool: &str) {}\n-    /// # let x = Some(\"abc\");\n-    /// // Bad\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH,\n-    style,\n-    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches with two arms where an `if let else` will\n-    /// usually suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `if let` nests less than a `match`.\n-    ///\n-    /// ### Known problems\n-    /// Personal style preferences may differ.\n-    ///\n-    /// ### Example\n-    /// Using `match`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// match x {\n-    ///     Some(ref foo) => bar(foo),\n-    ///     _ => bar(&other_ref),\n-    /// }\n-    /// ```\n-    ///\n-    /// Using `if let` with `else`:\n-    ///\n-    /// ```rust\n-    /// # fn bar(foo: &usize) {}\n-    /// # let other_ref: usize = 1;\n-    /// # let x: Option<&usize> = Some(&1);\n-    /// if let Some(ref foo) = x {\n-    ///     bar(foo);\n-    /// } else {\n-    ///     bar(&other_ref);\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub SINGLE_MATCH_ELSE,\n-    pedantic,\n-    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where all arms match a reference,\n-    /// suggesting to remove the reference and deref the matched expression\n-    /// instead. It also checks for `if let &foo = bar` blocks.\n-    ///\n-    /// ### Why is this bad?\n-    /// It just makes the code less readable. That reference\n-    /// destructuring adds nothing to the code.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// // Bad\n-    /// match x {\n-    ///     &A(ref y) => foo(y),\n-    ///     &B => bar(),\n-    ///     _ => frob(&x),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match *x {\n-    ///     A(ref y) => foo(y),\n-    ///     B => bar(),\n-    ///     _ => frob(x),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_REF_PATS,\n-    style,\n-    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches where match expression is a `bool`. It\n-    /// suggests to replace the expression with an `if...else` block.\n-    ///\n-    /// ### Why is this bad?\n-    /// It makes the code less readable.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// match condition {\n-    ///     true => foo(),\n-    ///     false => bar(),\n-    /// }\n-    /// ```\n-    /// Use if/else instead:\n-    /// ```rust\n-    /// # fn foo() {}\n-    /// # fn bar() {}\n-    /// let condition: bool = true;\n-    /// if condition {\n-    ///     foo();\n-    /// } else {\n-    ///     bar();\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_BOOL,\n-    pedantic,\n-    \"a `match` on a boolean expression instead of an `if..else` block\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for overlapping match arms.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is likely to be an error and if not, makes the code\n-    /// less obvious.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = 5;\n-    /// match x {\n-    ///     1..=10 => println!(\"1 ... 10\"),\n-    ///     5..=15 => println!(\"5 ... 15\"),\n-    ///     _ => (),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_OVERLAPPING_ARM,\n-    style,\n-    \"a `match` with overlapping arms\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for arm which matches all errors with `Err(_)`\n-    /// and take drastic actions like `panic!`.\n-    ///\n-    /// ### Why is this bad?\n-    /// It is generally a bad practice, similar to\n-    /// catching all exceptions in java with `catch(Exception)`\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Result<i32, &str> = Ok(3);\n-    /// match x {\n-    ///     Ok(_) => println!(\"ok\"),\n-    ///     Err(_) => panic!(\"err\"),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_WILD_ERR_ARM,\n-    pedantic,\n-    \"a `match` with `Err(_)` arm and take drastic actions\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for match which is used to add a reference to an\n-    /// `Option` value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using `as_ref()` or `as_mut()` instead is shorter.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x: Option<()> = None;\n-    ///\n-    /// // Bad\n-    /// let r: Option<&()> = match x {\n-    ///     None => None,\n-    ///     Some(ref v) => Some(v),\n-    /// };\n-    ///\n-    /// // Good\n-    /// let r: Option<&()> = x.as_ref();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_AS_REF,\n-    complexity,\n-    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches using `_`.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may be incorrect if guards exhaustively cover some\n-    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A(usize), B(usize) }\n-    /// # let x = Foo::B(1);\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A(_) => {},\n-    ///     Foo::B(_) => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.34.0\"]\n-    pub WILDCARD_ENUM_MATCH_ARM,\n-    restriction,\n-    \"a wildcard enum match arm using `_`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard enum matches for a single variant.\n-    ///\n-    /// ### Why is this bad?\n-    /// New enum variants added by library updates can be missed.\n-    ///\n-    /// ### Known problems\n-    /// Suggested replacements may not use correct path to enum\n-    /// if it's not present in the current scope.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # enum Foo { A, B, C }\n-    /// # let x = Foo::B;\n-    /// // Bad\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match x {\n-    ///     Foo::A => {},\n-    ///     Foo::B => {},\n-    ///     Foo::C => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.45.0\"]\n-    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    pedantic,\n-    \"a wildcard enum match for a single variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for wildcard pattern used with others patterns in same match arm.\n-    ///\n-    /// ### Why is this bad?\n-    /// Wildcard pattern already covers any other pattern as it will match anyway.\n-    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// // Bad\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     \"bar\" | _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match \"foo\" {\n-    ///     \"a\" => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.42.0\"]\n-    pub WILDCARD_IN_OR_PATTERNS,\n-    complexity,\n-    \"a wildcard pattern used with others patterns in same match arm\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for matches being used to destructure a single-variant enum\n-    /// or tuple struct where a `let` will suffice.\n-    ///\n-    /// ### Why is this bad?\n-    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    ///\n-    /// let data = match wrapper {\n-    ///     Wrapper::Data(i) => i,\n-    /// };\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    /// ```rust\n-    /// enum Wrapper {\n-    ///     Data(i32),\n-    /// }\n-    ///\n-    /// let wrapper = Wrapper::Data(42);\n-    /// let Wrapper::Data(data) = wrapper;\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub INFALLIBLE_DESTRUCTURING_MATCH,\n-    style,\n-    \"a `match` statement with a single infallible arm instead of a `let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for useless match that binds to only one value.\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    ///  Suggested replacements may be incorrect when `match`\n-    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # let a = 1;\n-    /// # let b = 2;\n-    ///\n-    /// // Bad\n-    /// match (a, b) {\n-    ///     (c, d) => {\n-    ///         // useless match\n-    ///     }\n-    /// }\n-    ///\n-    /// // Good\n-    /// let (c, d) = (a, b);\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub MATCH_SINGLE_BINDING,\n-    complexity,\n-    \"a match with a single binding instead of using `let` statement\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n-    ///\n-    /// ### Why is this bad?\n-    /// Correctness and readability. It's like having a wildcard pattern after\n-    /// matching all enum variants explicitly.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # struct A { a: i32 }\n-    /// let a = A { a: 5 };\n-    ///\n-    /// // Bad\n-    /// match a {\n-    ///     A { a: 5, .. } => {},\n-    ///     _ => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match a {\n-    ///     A { a: 5 } => {},\n-    ///     _ => {},\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.43.0\"]\n-    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    restriction,\n-    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lint for redundant pattern matching over `Result`, `Option`,\n-    /// `std::task::Poll` or `std::net::IpAddr`\n-    ///\n-    /// ### Why is this bad?\n-    /// It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// ### Known problems\n-    /// This will change the drop order for the matched type. Both `if let` and\n-    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n-    /// value before entering the block. For most types this change will not matter, but for a few\n-    /// types this will not be an acceptable change (e.g. locks). See the\n-    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n-    /// drop order.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// if let Poll::Pending = Poll::Pending::<()> {}\n-    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n-    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n-    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// # use std::task::Poll;\n-    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// if Poll::Pending::<()>.is_pending() {}\n-    /// if Poll::Ready(42).is_ready() {}\n-    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n-    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    #[clippy::version = \"1.31.0\"]\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match`  or `if let` expressions producing a\n-    /// `bool` that could be written using `matches!`\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability and needless complexity.\n-    ///\n-    /// ### Known problems\n-    /// This lint falsely triggers, if there are arms with\n-    /// `cfg` attributes that remove an arm evaluating to `false`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = Some(5);\n-    ///\n-    /// // Bad\n-    /// let a = match x {\n-    ///     Some(0) => true,\n-    ///     _ => false,\n-    /// };\n-    ///\n-    /// let a = if let Some(0) = x {\n-    ///     true\n-    /// } else {\n-    ///     false\n-    /// };\n-    ///\n-    /// // Good\n-    /// let a = matches!(x, Some(0));\n-    /// ```\n-    #[clippy::version = \"1.47.0\"]\n-    pub MATCH_LIKE_MATCHES_MACRO,\n-    style,\n-    \"a match that could be written with the matches! macro\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for `match` with identical arm bodies.\n-    ///\n-    /// ### Why is this bad?\n-    /// This is probably a copy & paste error. If arm bodies\n-    /// are the same on purpose, you can factor them\n-    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n-    ///\n-    /// ### Known problems\n-    /// False positive possible with order dependent `match`\n-    /// (see issue\n-    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => bar(), // <= oops\n-    /// }\n-    /// ```\n-    ///\n-    /// This should probably be\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar => bar(),\n-    ///     Quz => quz(),\n-    ///     Baz => baz(), // <= fixed\n-    /// }\n-    /// ```\n-    ///\n-    /// or if the original code was not a typo:\n-    /// ```rust,ignore\n-    /// match foo {\n-    ///     Bar | Baz => bar(), // <= shows the intent better\n-    ///     Quz => quz(),\n-    /// }\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MATCH_SAME_ARMS,\n-    pedantic,\n-    \"`match` with identical arm bodies\"\n-}\n-\n-#[derive(Default)]\n-pub struct Matches {\n-    msrv: Option<RustcVersion>,\n-    infallible_destructuring_match_linted: bool,\n-}\n-\n-impl Matches {\n-    #[must_use]\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self {\n-            msrv,\n-            ..Matches::default()\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(Matches => [\n-    SINGLE_MATCH,\n-    MATCH_REF_PATS,\n-    MATCH_BOOL,\n-    SINGLE_MATCH_ELSE,\n-    MATCH_OVERLAPPING_ARM,\n-    MATCH_WILD_ERR_ARM,\n-    MATCH_AS_REF,\n-    WILDCARD_ENUM_MATCH_ARM,\n-    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-    WILDCARD_IN_OR_PATTERNS,\n-    MATCH_SINGLE_BINDING,\n-    INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-    REDUNDANT_PATTERN_MATCHING,\n-    MATCH_LIKE_MATCHES_MACRO,\n-    MATCH_SAME_ARMS,\n-]);\n-\n-impl<'tcx> LateLintPass<'tcx> for Matches {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        redundant_pattern_match::check(cx, expr);\n-\n-        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n-            if !check_match_like_matches(cx, expr) {\n-                lint_match_arms(cx, expr);\n-            }\n-        } else {\n-            lint_match_arms(cx, expr);\n-        }\n-\n-        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n-            check_single_match(cx, ex, arms, expr);\n-            check_match_bool(cx, ex, arms, expr);\n-            check_overlapping_arms(cx, ex, arms);\n-            check_wild_err_arm(cx, ex, arms);\n-            check_wild_enum_match(cx, ex, arms);\n-            check_match_as_ref(cx, ex, arms, expr);\n-            check_wild_in_or_pats(cx, arms);\n-\n-            if self.infallible_destructuring_match_linted {\n-                self.infallible_destructuring_match_linted = false;\n-            } else {\n-                check_match_single_binding(cx, ex, arms, expr);\n-            }\n-        }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if_chain! {\n-            if !local.span.from_expansion();\n-            if let Some(expr) = local.init;\n-            if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n-            if arms.len() == 1 && arms[0].guard.is_none();\n-            if let PatKind::TupleStruct(\n-                QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n-            if args.len() == 1;\n-            if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = peel_blocks(arms[0].body);\n-            if path_to_local_id(body, arg);\n-\n-            then {\n-                let mut applicability = Applicability::MachineApplicable;\n-                self.infallible_destructuring_match_linted = true;\n-                span_lint_and_sugg(\n-                    cx,\n-                    INFALLIBLE_DESTRUCTURING_MATCH,\n-                    local.span,\n-                    \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n-                    Consider using `let`\",\n-                    \"try this\",\n-                    format!(\n-                        \"let {}({}) = {};\",\n-                        snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n-                    ),\n-                    applicability,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        if_chain! {\n-            if !pat.span.from_expansion();\n-            if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n-            if let Some(def_id) = path.res.opt_def_id();\n-            let ty = cx.tcx.type_of(def_id);\n-            if let ty::Adt(def, _) = ty.kind();\n-            if def.is_struct() || def.is_union();\n-            if fields.len() == def.non_enum_variant().fields.len();\n-\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n-                    pat.span,\n-                    \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n-                    None,\n-                    \"consider removing `..` from this binding\",\n-                );\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-#[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        if expr.span.from_expansion() {\n-            // Don't lint match expressions present in\n-            // macro_rules! block\n-            return;\n-        }\n-        if let PatKind::Or(..) = arms[0].pat.kind {\n-            // don't lint for or patterns for now, this makes\n-            // the lint noisy in unnecessary situations\n-            return;\n-        }\n-        let els = arms[1].body;\n-        let els = if is_unit_expr(peel_blocks(els)) {\n-            None\n-        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n-            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n-                // single statement/expr \"else\" block, don't lint\n-                return;\n-            }\n-            // block with 2+ statements or 1 expr and 1+ statement\n-            Some(els)\n-        } else {\n-            // not a block, don't lint\n-            return;\n-        };\n-\n-        let ty = cx.typeck_results().expr_ty(ex);\n-        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n-            check_single_match_single_pattern(cx, ex, arms, expr, els);\n-            check_single_match_opt_like(cx, ex, arms, expr, ty, els);\n-        }\n-    }\n-}\n-\n-fn check_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    if is_wild(arms[1].pat) {\n-        report_single_match_single_pattern(cx, ex, arms, expr, els);\n-    }\n-}\n-\n-fn report_single_match_single_pattern(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n-    let els_str = els.map_or(String::new(), |els| {\n-        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n-    });\n-\n-    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n-    let (msg, sugg) = if_chain! {\n-        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n-        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n-        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n-        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n-        if ty.is_integral() || ty.is_char() || ty.is_str()\n-            || (implements_trait(cx, ty, spe_trait_id, &[])\n-                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n-        then {\n-            // scrutinee derives PartialEq and the pattern is a constant.\n-            let pat_ref_count = match pat.kind {\n-                // string literals are already a reference.\n-                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n-                _ => pat_ref_count,\n-            };\n-            // References are only implicitly added to the pattern, so no overflow here.\n-            // e.g. will work: match &Some(_) { Some(_) => () }\n-            // will not: match Some(_) { &Some(_) => () }\n-            let ref_count_diff = ty_ref_count - pat_ref_count;\n-\n-            // Try to remove address of expressions first.\n-            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n-            let ref_count_diff = ref_count_diff - removed;\n-\n-            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n-            let sugg = format!(\n-                \"if {} == {}{} {}{}\",\n-                snippet(cx, ex.span, \"..\"),\n-                // PartialEq for different reference counts may not exist.\n-                \"&\".repeat(ref_count_diff),\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        } else {\n-            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n-            let sugg = format!(\n-                \"if let {} = {} {}{}\",\n-                snippet(cx, arms[0].pat.span, \"..\"),\n-                snippet(cx, ex.span, \"..\"),\n-                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n-                els_str,\n-            );\n-            (msg, sugg)\n-        }\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        lint,\n-        expr.span,\n-        msg,\n-        \"try this\",\n-        sugg,\n-        Applicability::HasPlaceholders,\n-    );\n-}\n-\n-fn check_single_match_opt_like(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    expr: &Expr<'_>,\n-    ty: Ty<'_>,\n-    els: Option<&Expr<'_>>,\n-) {\n-    // list of candidate `Enum`s we know will never get any more members\n-    let candidates = &[\n-        (&paths::COW, \"Borrowed\"),\n-        (&paths::COW, \"Cow::Borrowed\"),\n-        (&paths::COW, \"Cow::Owned\"),\n-        (&paths::COW, \"Owned\"),\n-        (&paths::OPTION, \"None\"),\n-        (&paths::RESULT, \"Err\"),\n-        (&paths::RESULT, \"Ok\"),\n-    ];\n-\n-    let path = match arms[1].pat.kind {\n-        PatKind::TupleStruct(ref path, inner, _) => {\n-            // Contains any non wildcard patterns (e.g., `Err(err)`)?\n-            if !inner.iter().all(is_wild) {\n-                return;\n-            }\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-        },\n-        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => ident.to_string(),\n-        PatKind::Path(ref path) => {\n-            rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-        },\n-        _ => return,\n-    };\n-\n-    for &(ty_path, pat_path) in candidates {\n-        if path == *pat_path && match_type(cx, ty, ty_path) {\n-            report_single_match_single_pattern(cx, ex, arms, expr, els);\n-        }\n-    }\n-}\n-\n-fn check_match_bool(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    // Type of expression is `bool`.\n-    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_BOOL,\n-            expr.span,\n-            \"you seem to be trying to match on a boolean expression\",\n-            move |diag| {\n-                if arms.len() == 2 {\n-                    // no guards\n-                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n-                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n-                            match lit.node {\n-                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    };\n-\n-                    if let Some((true_expr, false_expr)) = exprs {\n-                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                            (false, false) => Some(format!(\n-                                \"if {} {} else {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n-                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (false, true) => Some(format!(\n-                                \"if {} {}\",\n-                                snippet(cx, ex.span, \"b\"),\n-                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n-                            )),\n-                            (true, false) => {\n-                                let test = Sugg::hir(cx, ex, \"..\");\n-                                Some(format!(\n-                                    \"if {} {}\",\n-                                    !test,\n-                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n-                                ))\n-                            },\n-                            (true, true) => None,\n-                        };\n-\n-                        if let Some(sugg) = sugg {\n-                            diag.span_suggestion(\n-                                expr.span,\n-                                \"consider using an `if`/`else` expression\",\n-                                sugg,\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        }\n-                    }\n-                }\n-            },\n-        );\n-    }\n-}\n-\n-fn check_overlapping_arms<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n-    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n-        if !ranges.is_empty() {\n-            if let Some((start, end)) = overlapping(&ranges) {\n-                span_lint_and_note(\n-                    cx,\n-                    MATCH_OVERLAPPING_ARM,\n-                    start.span,\n-                    \"some ranges overlap\",\n-                    Some(end.span),\n-                    \"overlaps with this\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_wild_err_arm<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n-    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n-        for arm in arms {\n-            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n-                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n-                if path_str == \"Err\" {\n-                    let mut matching_wild = inner.iter().any(is_wild);\n-                    let mut ident_bind_name = kw::Underscore;\n-                    if !matching_wild {\n-                        // Looking for unused bindings (i.e.: `_e`)\n-                        for pat in inner.iter() {\n-                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n-                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n-                                    ident_bind_name = ident.name;\n-                                    matching_wild = true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if_chain! {\n-                        if matching_wild;\n-                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n-                        if is_panic(cx, macro_call.def_id);\n-                        then {\n-                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n-                            span_lint_and_note(cx,\n-                                MATCH_WILD_ERR_ARM,\n-                                arm.pat.span,\n-                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n-                                None,\n-                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-enum CommonPrefixSearcher<'a> {\n-    None,\n-    Path(&'a [PathSegment<'a>]),\n-    Mixed,\n-}\n-impl<'a> CommonPrefixSearcher<'a> {\n-    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n-        match path {\n-            [path @ .., _] => self.with_prefix(path),\n-            [] => (),\n-        }\n-    }\n-\n-    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n-        match self {\n-            Self::None => *self = Self::Path(path),\n-            Self::Path(self_path)\n-                if path\n-                    .iter()\n-                    .map(|p| p.ident.name)\n-                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n-            Self::Path(_) => *self = Self::Mixed,\n-            Self::Mixed => (),\n-        }\n-    }\n-}\n-\n-fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n-    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n-    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n-    let adt_def = match ty.kind() {\n-        ty::Adt(adt_def, _)\n-            if adt_def.is_enum()\n-                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n-        {\n-            adt_def\n-        },\n-        _ => return,\n-    };\n-\n-    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n-    // the uncommon case, and the book-keeping is slightly expensive.\n-    let mut wildcard_span = None;\n-    let mut wildcard_ident = None;\n-    let mut has_non_wild = false;\n-    for arm in arms {\n-        match peel_hir_pat_refs(arm.pat).0.kind {\n-            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n-            PatKind::Binding(_, _, ident, None) => {\n-                wildcard_span = Some(arm.pat.span);\n-                wildcard_ident = Some(ident);\n-            },\n-            _ => has_non_wild = true,\n-        }\n-    }\n-    let wildcard_span = match wildcard_span {\n-        Some(x) if has_non_wild => x,\n-        _ => return,\n-    };\n-\n-    // Accumulate the variants which should be put in place of the wildcard because they're not\n-    // already covered.\n-    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n-    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n-\n-    let mut path_prefix = CommonPrefixSearcher::None;\n-    for arm in arms {\n-        // Guards mean that this case probably isn't exhaustively covered. Technically\n-        // this is incorrect, as we should really check whether each variant is exhaustively\n-        // covered by the set of guards that cover it, but that's really hard to do.\n-        recurse_or_patterns(arm.pat, |pat| {\n-            let path = match &peel_hir_pat_refs(pat).0.kind {\n-                PatKind::Path(path) => {\n-                    #[allow(clippy::match_same_arms)]\n-                    let id = match cx.qpath_res(path, pat.hir_id) {\n-                        Res::Def(\n-                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n-                            _,\n-                        ) => return,\n-                        Res::Def(_, id) => id,\n-                        _ => return,\n-                    };\n-                    if arm.guard.is_none() {\n-                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                    }\n-                    path\n-                },\n-                PatKind::TupleStruct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n-                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n-                        }\n-                    }\n-                    path\n-                },\n-                PatKind::Struct(path, patterns, ..) => {\n-                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n-                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n-                            missing_variants.retain(|e| e.def_id != id);\n-                        }\n-                    }\n-                    path\n-                },\n-                _ => return,\n-            };\n-            match path {\n-                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n-                QPath::TypeRelative(\n-                    hir::Ty {\n-                        kind: TyKind::Path(QPath::Resolved(_, path)),\n-                        ..\n-                    },\n-                    _,\n-                ) => path_prefix.with_prefix(path.segments),\n-                _ => (),\n-            }\n-        });\n-    }\n-\n-    let format_suggestion = |variant: &VariantDef| {\n-        format!(\n-            \"{}{}{}{}\",\n-            if let Some(ident) = wildcard_ident {\n-                format!(\"{} @ \", ident.name)\n-            } else {\n-                String::new()\n-            },\n-            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n-                let mut s = String::new();\n-                for seg in path_prefix {\n-                    s.push_str(seg.ident.as_str());\n-                    s.push_str(\"::\");\n-                }\n-                s\n-            } else {\n-                let mut s = cx.tcx.def_path_str(adt_def.did);\n-                s.push_str(\"::\");\n-                s\n-            },\n-            variant.name,\n-            match variant.ctor_kind {\n-                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n-                CtorKind::Fn => \"(..)\",\n-                CtorKind::Const => \"\",\n-                CtorKind::Fictive => \"{ .. }\",\n-            }\n-        )\n-    };\n-\n-    match missing_variants.as_slice() {\n-        [] => (),\n-        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n-            cx,\n-            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n-            wildcard_span,\n-            \"wildcard matches only a single variant and will also match any future added variants\",\n-            \"try this\",\n-            format_suggestion(x),\n-            Applicability::MaybeIncorrect,\n-        ),\n-        variants => {\n-            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n-            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n-                suggestions.push(\"_\".into());\n-                \"wildcard matches known variants and will also match future added variants\"\n-            } else {\n-                \"wildcard match will also match any future added variants\"\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                WILDCARD_ENUM_MATCH_ARM,\n-                wildcard_span,\n-                message,\n-                \"try this\",\n-                suggestions.join(\" | \"),\n-                Applicability::MaybeIncorrect,\n-            );\n-        },\n-    };\n-}\n-\n-fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n-where\n-    'b: 'a,\n-    I: Clone + Iterator<Item = &'a Pat<'b>>,\n-{\n-    if !has_multiple_ref_pats(pats.clone()) {\n-        return;\n-    }\n-\n-    let (first_sugg, msg, title);\n-    let span = ex.span.source_callsite();\n-    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-        msg = \"try\";\n-        title = \"you don't need to add `&` to both the expression and the patterns\";\n-    } else {\n-        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n-        title = \"you don't need to add `&` to all patterns\";\n-    }\n-\n-    let remaining_suggs = pats.filter_map(|pat| {\n-        if let PatKind::Ref(refp, _) = pat.kind {\n-            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-        } else {\n-            None\n-        }\n-    });\n-\n-    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-        if !expr.span.from_expansion() {\n-            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n-        }\n-    });\n-}\n-\n-fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n-        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n-            is_ref_some_arm(cx, &arms[1])\n-        } else if is_none_arm(cx, &arms[1]) {\n-            is_ref_some_arm(cx, &arms[0])\n-        } else {\n-            None\n-        };\n-        if let Some(rb) = arm_ref {\n-            let suggestion = if rb == BindingAnnotation::Ref {\n-                \"as_ref\"\n-            } else {\n-                \"as_mut\"\n-            };\n-\n-            let output_ty = cx.typeck_results().expr_ty(expr);\n-            let input_ty = cx.typeck_results().expr_ty(ex);\n-\n-            let cast = if_chain! {\n-                if let ty::Adt(_, substs) = input_ty.kind();\n-                let input_ty = substs.type_at(0);\n-                if let ty::Adt(_, substs) = output_ty.kind();\n-                let output_ty = substs.type_at(0);\n-                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n-                if input_ty != output_ty;\n-                then {\n-                    \".map(|x| x as _)\"\n-                } else {\n-                    \"\"\n-                }\n-            };\n-\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_AS_REF,\n-                expr.span,\n-                &format!(\"use `{}()` instead\", suggestion),\n-                \"try this\",\n-                format!(\n-                    \"{}.{}(){}\",\n-                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n-                    suggestion,\n-                    cast,\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n-    for arm in arms {\n-        if let PatKind::Or(fields) = arm.pat.kind {\n-            // look for multiple fields in this arm that contains at least one Wild pattern\n-            if fields.len() > 1 && fields.iter().any(is_wild) {\n-                span_lint_and_help(\n-                    cx,\n-                    WILDCARD_IN_OR_PATTERNS,\n-                    arm.pat.span,\n-                    \"wildcard pattern covers any other pattern as it will match anyway\",\n-                    None,\n-                    \"consider handling `_` separately\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n-fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let Some(higher::IfLet {\n-        let_pat,\n-        let_expr,\n-        if_then,\n-        if_else: Some(if_else),\n-    }) = higher::IfLet::hir(cx, expr)\n-    {\n-        return find_matches_sugg(\n-            cx,\n-            let_expr,\n-            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n-            expr,\n-            true,\n-        );\n-    }\n-\n-    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n-        return find_matches_sugg(\n-            cx,\n-            scrut,\n-            arms.iter().map(|arm| {\n-                (\n-                    cx.tcx.hir().attrs(arm.hir_id),\n-                    Some(arm.pat),\n-                    arm.body,\n-                    arm.guard.as_ref(),\n-                )\n-            }),\n-            expr,\n-            false,\n-        );\n-    }\n-\n-    false\n-}\n-\n-/// Lint a `match` or `if let` for replacement by `matches!`\n-fn find_matches_sugg<'a, 'b, I>(\n-    cx: &LateContext<'_>,\n-    ex: &Expr<'_>,\n-    mut iter: I,\n-    expr: &Expr<'_>,\n-    is_if_let: bool,\n-) -> bool\n-where\n-    'b: 'a,\n-    I: Clone\n-        + DoubleEndedIterator\n-        + ExactSizeIterator\n-        + Iterator<\n-            Item = (\n-                &'a [Attribute],\n-                Option<&'a Pat<'b>>,\n-                &'a Expr<'b>,\n-                Option<&'a Guard<'b>>,\n-            ),\n-        >,\n-{\n-    if_chain! {\n-        if iter.len() >= 2;\n-        if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n-        let iter_without_last = iter.clone();\n-        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n-        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n-        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n-        if b0 != b1;\n-        if first_guard.is_none() || iter.len() == 0;\n-        if first_attrs.is_empty();\n-        if iter\n-            .all(|arm| {\n-                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n-            });\n-        then {\n-            if let Some(last_pat) = last_pat_opt {\n-                if !is_wild(last_pat) {\n-                    return false;\n-                }\n-            }\n-\n-            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n-            // evaluated into `false` and so such arms will be stripped before.\n-            let mut applicability = Applicability::MaybeIncorrect;\n-            let pat = {\n-                use itertools::Itertools as _;\n-                iter_without_last\n-                    .filter_map(|arm| {\n-                        let pat_span = arm.1?.span;\n-                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n-                    })\n-                    .join(\" | \")\n-            };\n-            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n-                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n-            } else {\n-                pat\n-            };\n-\n-            // strip potential borrows (#6503), but only if the type is a reference\n-            let mut ex_new = ex;\n-            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n-                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n-                    ex_new = ex_inner;\n-                }\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_LIKE_MATCHES_MACRO,\n-                expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n-                \"try this\",\n-                format!(\n-                    \"{}matches!({}, {})\",\n-                    if b0 { \"\" } else { \"!\" },\n-                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n-                    pat_and_guard,\n-                ),\n-                applicability,\n-            );\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n-    match ex {\n-        ExprKind::Lit(Spanned {\n-            node: LitKind::Bool(b), ..\n-        }) => Some(*b),\n-        ExprKind::Block(\n-            rustc_hir::Block {\n-                stmts: &[],\n-                expr: Some(exp),\n-                ..\n-            },\n-            _,\n-        ) if is_if_let => {\n-            if let ExprKind::Lit(Spanned {\n-                node: LitKind::Bool(b), ..\n-            }) = exp.kind\n-            {\n-                Some(b)\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None,\n-    }\n-}\n-\n-#[allow(clippy::too_many_lines)]\n-fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n-        return;\n-    }\n-\n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n-    let matched_vars = ex.span;\n-    let bind_names = arms[0].pat.span;\n-    let match_body = peel_blocks(arms[0].body);\n-    let mut snippet_body = if match_body.span.from_expansion() {\n-        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n-    } else {\n-        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n-    };\n-\n-    // Do we need to add ';' to suggestion ?\n-    match match_body.kind {\n-        ExprKind::Block(block, _) => {\n-            // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-        _ => {\n-            // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-    }\n-\n-    let mut applicability = Applicability::MaybeIncorrect;\n-    match arms[0].pat.kind {\n-        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n-            // If this match is in a local (`let`) stmt\n-            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n-                (\n-                    parent_let_node.span,\n-                    format!(\n-                        \"let {} = {};\\n{}let {} = {};\",\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n-                        snippet_body\n-                    ),\n-                )\n-            } else {\n-                // If we are in closure, we need curly braces around suggestion\n-                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n-                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    if let ExprKind::Closure(..) = parent_expr.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the closure\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                // If the parent is already an arm, and the body is another match statement,\n-                // we need curly braces around suggestion\n-                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n-                    if let ExprKind::Match(..) = arm.body.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the match\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                (\n-                    expr.span,\n-                    format!(\n-                        \"{}let {} = {};\\n{}{}{}\",\n-                        cbrace_start,\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        indent,\n-                        snippet_body,\n-                        cbrace_end\n-                    ),\n-                )\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_SINGLE_BINDING,\n-                target_span,\n-                \"this match could be written as a `let` statement\",\n-                \"consider using `let` statement\",\n-                sugg,\n-                applicability,\n-            );\n-        },\n-        PatKind::Wild => {\n-            if ex.can_have_side_effects() {\n-                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n-                let sugg = format!(\n-                    \"{};\\n{}{}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n-                    indent,\n-                    snippet_body\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its scrutinee and body\",\n-                    \"consider using the scrutinee and body instead\",\n-                    sugg,\n-                    applicability,\n-                );\n-            } else {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its body itself\",\n-                    \"consider using the match body instead\",\n-                    snippet_body,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => (),\n-    }\n-}\n-\n-/// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n-    let map = &cx.tcx.hir();\n-    if_chain! {\n-        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n-        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n-        then {\n-            return Some(parent_let_expr);\n-        }\n-    }\n-    None\n-}\n-\n-/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n-fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n-    arms.iter()\n-        .filter_map(|arm| {\n-            if let Arm { pat, guard: None, .. } = *arm {\n-                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n-                    let lhs_const = match lhs {\n-                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n-                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n-                    };\n-                    let rhs_const = match rhs {\n-                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n-                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n-                    };\n-\n-                    let lhs_val = lhs_const.int_value(cx, ty)?;\n-                    let rhs_val = rhs_const.int_value(cx, ty)?;\n-\n-                    let rhs_bound = match range_end {\n-                        RangeEnd::Included => EndBound::Included(rhs_val),\n-                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n-                    };\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (lhs_val, rhs_bound),\n-                    });\n-                }\n-\n-                if let PatKind::Lit(value) = pat.kind {\n-                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n-                    return Some(SpannedRange {\n-                        span: pat.span,\n-                        node: (value, EndBound::Included(value)),\n-                    });\n-                }\n-            }\n-            None\n-        })\n-        .collect()\n-}\n-\n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum EndBound<T> {\n-    Included(T),\n-    Excluded(T),\n-}\n-\n-#[derive(Debug, Eq, PartialEq)]\n-struct SpannedRange<T> {\n-    pub span: Span,\n-    pub node: (T, EndBound<T>),\n-}\n-\n-// Checks if arm has the form `None => None`\n-fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n-}\n-\n-// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n-    if_chain! {\n-        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n-        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n-        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n-        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n-        then {\n-            return Some(rb)\n-        }\n-    }\n-    None\n-}\n-\n-fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n-where\n-    'b: 'a,\n-    I: Iterator<Item = &'a Pat<'b>>,\n-{\n-    let mut ref_count = 0;\n-    for opt in pats.map(|pat| match pat.kind {\n-        PatKind::Ref(..) => Some(true), // &-patterns\n-        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-        _ => None,                      // any other pattern is not fine\n-    }) {\n-        if let Some(inner) = opt {\n-            if inner {\n-                ref_count += 1;\n-            }\n-        } else {\n-            return false;\n-        }\n-    }\n-    ref_count > 1\n-}\n-\n-fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n-where\n-    T: Copy + Ord,\n-{\n-    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n-    enum BoundKind {\n-        EndExcluded,\n-        Start,\n-        EndIncluded,\n-    }\n-\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n-\n-    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n-        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n-            Some(self.cmp(other))\n-        }\n-    }\n-\n-    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n-        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n-            let RangeBound(self_value, self_kind, _) = *self;\n-            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n-        }\n-    }\n-\n-    let mut values = Vec::with_capacity(2 * ranges.len());\n-\n-    for r @ SpannedRange { node: (start, end), .. } in ranges {\n-        values.push(RangeBound(*start, BoundKind::Start, r));\n-        values.push(match end {\n-            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n-            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n-        });\n-    }\n-\n-    values.sort();\n-\n-    let mut started = vec![];\n-\n-    for RangeBound(_, kind, range) in values {\n-        match kind {\n-            BoundKind::Start => started.push(range),\n-            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n-                let mut overlap = None;\n-\n-                while let Some(last_started) = started.pop() {\n-                    if last_started == range {\n-                        break;\n-                    }\n-                    overlap = Some(last_started);\n-                }\n-\n-                if let Some(first_overlapping) = overlap {\n-                    return Some((range, first_overlapping));\n-                }\n-            },\n-        }\n-    }\n-\n-    None\n-}\n-\n-mod redundant_pattern_match {\n-    use super::REDUNDANT_PATTERN_MATCHING;\n-    use clippy_utils::diagnostics::span_lint_and_then;\n-    use clippy_utils::higher;\n-    use clippy_utils::source::snippet;\n-    use clippy_utils::sugg::Sugg;\n-    use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n-    use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n-    use if_chain::if_chain;\n-    use rustc_ast::ast::LitKind;\n-    use rustc_data_structures::fx::FxHashSet;\n-    use rustc_errors::Applicability;\n-    use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n-    use rustc_hir::{\n-        intravisit::{walk_expr, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n-    };\n-    use rustc_lint::LateContext;\n-    use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n-    use rustc_span::sym;\n-\n-    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some(higher::IfLet {\n-            if_else,\n-            let_pat,\n-            let_expr,\n-            ..\n-        }) = higher::IfLet::hir(cx, expr)\n-        {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n-        }\n-        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n-            find_sugg_for_match(cx, expr, op, arms);\n-        }\n-        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n-            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n-        }\n-    }\n-\n-    /// Checks if the drop order for a type matters. Some std types implement drop solely to\n-    /// deallocate memory. For these types, and composites containing them, changing the drop order\n-    /// won't result in any observable side effects.\n-    fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-        type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-    }\n-\n-    fn type_needs_ordered_drop_inner<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        ty: Ty<'tcx>,\n-        seen: &mut FxHashSet<Ty<'tcx>>,\n-    ) -> bool {\n-        if !seen.insert(ty) {\n-            return false;\n-        }\n-        if !ty.needs_drop(cx.tcx, cx.param_env) {\n-            false\n-        } else if !cx\n-            .tcx\n-            .lang_items()\n-            .drop_trait()\n-            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-        {\n-            // This type doesn't implement drop, so no side effects here.\n-            // Check if any component type has any.\n-            match ty.kind() {\n-                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n-                ty::Adt(adt, subs) => adt\n-                    .all_fields()\n-                    .map(|f| f.ty(cx.tcx, subs))\n-                    .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-                _ => true,\n-            }\n-        }\n-        // Check for std types which implement drop, but only for memory allocation.\n-        else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-            || is_type_diagnostic_item(cx, ty, sym::Rc)\n-            || is_type_diagnostic_item(cx, ty, sym::Arc)\n-            || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-            || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-            || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-            || match_type(cx, ty, &paths::WEAK_RC)\n-            || match_type(cx, ty, &paths::WEAK_ARC)\n-        {\n-            // Check all of the generic arguments.\n-            if let ty::Adt(_, subs) = ty.kind() {\n-                subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-            } else {\n-                true\n-            }\n-        } else {\n-            true\n-        }\n-    }\n-\n-    // Extract the generic arguments out of a type\n-    fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n-        if_chain! {\n-            if let ty::Adt(_, subs) = ty.kind();\n-            if let Some(sub) = subs.get(index);\n-            if let GenericArgKind::Type(sub_ty) = sub.unpack();\n-            then {\n-                Some(sub_ty)\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-\n-    // Checks if there are any temporaries created in the given expression for which drop order\n-    // matters.\n-    fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n-        struct V<'a, 'tcx> {\n-            cx: &'a LateContext<'tcx>,\n-            res: bool,\n-        }\n-        impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n-            fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-                match expr.kind {\n-                    // Taking the reference of a value leaves a temporary\n-                    // e.g. In `&String::new()` the string is a temporary value.\n-                    // Remaining fields are temporary values\n-                    // e.g. In `(String::new(), 0).1` the string is a temporary value.\n-                    ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n-                        if !matches!(expr.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(expr);\n-                            }\n-                        }\n-                    },\n-                    // the base type is alway taken by reference.\n-                    // e.g. In `(vec![0])[0]` the vector is a temporary value.\n-                    ExprKind::Index(base, index) => {\n-                        if !matches!(base.kind, ExprKind::Path(_)) {\n-                            if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(base);\n-                            }\n-                        }\n-                        self.visit_expr(index);\n-                    },\n-                    // Method calls can take self by reference.\n-                    // e.g. In `String::new().len()` the string is a temporary value.\n-                    ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n-                        if !matches!(self_arg.kind, ExprKind::Path(_)) {\n-                            let self_by_ref = self\n-                                .cx\n-                                .typeck_results()\n-                                .type_dependent_def_id(expr.hir_id)\n-                                .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                            if self_by_ref\n-                                && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg))\n-                            {\n-                                self.res = true;\n-                            } else {\n-                                self.visit_expr(self_arg);\n-                            }\n-                        }\n-                        args.iter().for_each(|arg| self.visit_expr(arg));\n-                    },\n-                    // Either explicitly drops values, or changes control flow.\n-                    ExprKind::DropTemps(_)\n-                    | ExprKind::Ret(_)\n-                    | ExprKind::Break(..)\n-                    | ExprKind::Yield(..)\n-                    | ExprKind::Block(Block { expr: None, .. }, _)\n-                    | ExprKind::Loop(..) => (),\n-\n-                    // Only consider the final expression.\n-                    ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n-\n-                    _ => walk_expr(self, expr),\n-                }\n-            }\n-        }\n-\n-        let mut v = V { cx, res: false };\n-        v.visit_expr(expr);\n-        v.res\n-    }\n-\n-    fn find_sugg_for_if_let<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        expr: &'tcx Expr<'_>,\n-        let_pat: &Pat<'_>,\n-        let_expr: &'tcx Expr<'_>,\n-        keyword: &'static str,\n-        has_else: bool,\n-    ) {\n-        // also look inside refs\n-        let mut kind = &let_pat.kind;\n-        // if we have &None for example, peel it so we can detect \"if let None = x\"\n-        if let PatKind::Ref(inner, _mutability) = kind {\n-            kind = &inner.kind;\n-        }\n-        let op_ty = cx.typeck_results().expr_ty(let_expr);\n-        // Determine which function should be used, and the type contained by the corresponding\n-        // variant.\n-        let (good_method, inner_ty) = match kind {\n-            PatKind::TupleStruct(ref path, [sub_pat], _) => {\n-                if let PatKind::Wild = sub_pat.kind {\n-                    if is_lang_ctor(cx, path, ResultOk) {\n-                        (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, ResultErr) {\n-                        (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n-                    } else if is_lang_ctor(cx, path, OptionSome) {\n-                        (\"is_some()\", op_ty)\n-                    } else if is_lang_ctor(cx, path, PollReady) {\n-                        (\"is_ready()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V4) {\n-                        (\"is_ipv4()\", op_ty)\n-                    } else if is_qpath_def_path(cx, path, sub_pat.hir_id, &paths::IPADDR_V6) {\n-                        (\"is_ipv6()\", op_ty)\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            },\n-            PatKind::Path(ref path) => {\n-                let method = if is_lang_ctor(cx, path, OptionNone) {\n-                    \"is_none()\"\n-                } else if is_lang_ctor(cx, path, PollPending) {\n-                    \"is_pending()\"\n-                } else {\n-                    return;\n-                };\n-                // `None` and `Pending` don't have an inner type.\n-                (method, cx.tcx.types.unit)\n-            },\n-            _ => return,\n-        };\n-\n-        // If this is the last expression in a block or there is an else clause then the whole\n-        // type needs to be considered, not just the inner type of the branch being matched on.\n-        // Note the last expression in a block is dropped after all local bindings.\n-        let check_ty = if has_else\n-            || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n-        {\n-            op_ty\n-        } else {\n-            inner_ty\n-        };\n-\n-        // All temporaries created in the scrutinee expression are dropped at the same time as the\n-        // scrutinee would be, so they have to be considered as well.\n-        // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n-        // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n-\n-        // check that `while_let_on_iterator` lint does not trigger\n-        if_chain! {\n-            if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n-            if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, let_expr, sym::Iterator);\n-            then {\n-                return;\n-            }\n-        }\n-\n-        let result_expr = match &let_expr.kind {\n-            ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            ExprKind::Unary(UnOp::Deref, deref) => deref,\n-            _ => let_expr,\n-        };\n-\n-        span_lint_and_then(\n-            cx,\n-            REDUNDANT_PATTERN_MATCHING,\n-            let_pat.span,\n-            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-            |diag| {\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                let expr_span = expr.span;\n-\n-                // if/while let ... = ... { ... }\n-                //                 ^^^\n-                let op_span = result_expr.span.source_callsite();\n-\n-                // if/while let ... = ... { ... }\n-                // ^^^^^^^^^^^^^^^^^^^\n-                let span = expr_span.until(op_span.shrink_to_hi());\n-\n-                let app = if needs_drop {\n-                    Applicability::MaybeIncorrect\n-                } else {\n-                    Applicability::MachineApplicable\n-                };\n-\n-                let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n-                    .maybe_par()\n-                    .to_string();\n-\n-                diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n-\n-                if needs_drop {\n-                    diag.note(\"this will change drop order of the result, as well as all temporaries\");\n-                    diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n-                }\n-            },\n-        );\n-    }\n-\n-    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-        if arms.len() == 2 {\n-            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-            let found_good_method = match node_pair {\n-                (\n-                    PatKind::TupleStruct(ref path_left, patterns_left, _),\n-                    PatKind::TupleStruct(ref path_right, patterns_right, _),\n-                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::RESULT_OK,\n-                            &paths::RESULT_ERR,\n-                            \"is_ok()\",\n-                            \"is_err()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::IPADDR_V4,\n-                                &paths::IPADDR_V6,\n-                                \"is_ipv4()\",\n-                                \"is_ipv6()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n-                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n-                    if patterns.len() == 1 =>\n-                {\n-                    if let PatKind::Wild = patterns[0].kind {\n-                        find_good_method_for_match(\n-                            cx,\n-                            arms,\n-                            path_left,\n-                            path_right,\n-                            &paths::OPTION_SOME,\n-                            &paths::OPTION_NONE,\n-                            \"is_some()\",\n-                            \"is_none()\",\n-                        )\n-                        .or_else(|| {\n-                            find_good_method_for_match(\n-                                cx,\n-                                arms,\n-                                path_left,\n-                                path_right,\n-                                &paths::POLL_READY,\n-                                &paths::POLL_PENDING,\n-                                \"is_ready()\",\n-                                \"is_pending()\",\n-                            )\n-                        })\n-                    } else {\n-                        None\n-                    }\n-                },\n-                _ => None,\n-            };\n-\n-            if let Some(good_method) = found_good_method {\n-                let span = expr.span.to(op.span);\n-                let result_expr = match &op.kind {\n-                    ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-                    _ => op,\n-                };\n-                span_lint_and_then(\n-                    cx,\n-                    REDUNDANT_PATTERN_MATCHING,\n-                    expr.span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            span,\n-                            \"try this\",\n-                            format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n-                            Applicability::MaybeIncorrect, // snippet\n-                        );\n-                    },\n-                );\n-            }\n-        }\n-    }\n-\n-    #[allow(clippy::too_many_arguments)]\n-    fn find_good_method_for_match<'a>(\n-        cx: &LateContext<'_>,\n-        arms: &[Arm<'_>],\n-        path_left: &QPath<'_>,\n-        path_right: &QPath<'_>,\n-        expected_left: &[&str],\n-        expected_right: &[&str],\n-        should_be_left: &'a str,\n-        should_be_right: &'a str,\n-    ) -> Option<&'a str> {\n-        let body_node_pair = if is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-        } else if is_qpath_def_path(cx, path_right, arms[1].pat.hir_id, expected_left)\n-            && is_qpath_def_path(cx, path_left, arms[0].pat.hir_id, expected_right)\n-        {\n-            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-        } else {\n-            return None;\n-        };\n-\n-        match body_node_pair {\n-            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n-                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_overlapping() {\n-    use rustc_span::source_map::DUMMY_SP;\n-\n-    let sp = |s, e| SpannedRange {\n-        span: DUMMY_SP,\n-        node: (s, e),\n-    };\n-\n-    assert_eq!(None, overlapping::<u8>(&[]));\n-    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n-    assert_eq!(\n-        None,\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        None,\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(10, EndBound::Included(11))\n-        ],)\n-    );\n-    assert_eq!(\n-        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n-        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n-    );\n-    assert_eq!(\n-        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n-        overlapping(&[\n-            sp(1, EndBound::Included(4)),\n-            sp(5, EndBound::Included(6)),\n-            sp(6, EndBound::Included(11))\n-        ],)\n-    );\n-}\n-\n-/// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n-    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n-            let mut h = SpanlessHash::new(cx);\n-            h.hash_expr(arm.body);\n-            h.finish()\n-        };\n-\n-        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n-            let min_index = usize::min(lindex, rindex);\n-            let max_index = usize::max(lindex, rindex);\n-\n-            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n-            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n-                if_chain! {\n-                    if let Some(a_id) = path_to_local(a);\n-                    if let Some(b_id) = path_to_local(b);\n-                    let entry = match local_map.entry(a_id) {\n-                        Entry::Vacant(entry) => entry,\n-                        // check if using the same bindings as before\n-                        Entry::Occupied(entry) => return *entry.get() == b_id,\n-                    };\n-                    // the names technically don't have to match; this makes the lint more conservative\n-                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n-                    if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n-                    if pat_contains_local(lhs.pat, a_id);\n-                    if pat_contains_local(rhs.pat, b_id);\n-                    then {\n-                        entry.insert(b_id);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            };\n-            // Arms with a guard are ignored, those can\u2019t always be merged together\n-            // This is also the case for arms in-between each there is an arm with a guard\n-            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-                && SpanlessEq::new(cx)\n-                    .expr_fallback(eq_fallback)\n-                    .eq_expr(lhs.body, rhs.body)\n-                // these checks could be removed to allow unused bindings\n-                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n-        };\n-\n-        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_SAME_ARMS,\n-                j.body.span,\n-                \"this `match` has identical arm bodies\",\n-                |diag| {\n-                    diag.span_note(i.body.span, \"same as this\");\n-\n-                    // Note: this does not use `span_suggestion` on purpose:\n-                    // there is no clean way\n-                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                    // makes an even more confusing error message. Also in order not to make up a\n-                    // span for the whole pattern, the suggestion is only shown when there is only\n-                    // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                    if let PatKind::Wild = j.pat.kind {\n-                        // if the last arm is _, then i could be integrated into _\n-                        // note that i.pat cannot be _, because that would mean that we're\n-                        // hiding all the subsequent arms, and rust won't compile\n-                        diag.span_note(\n-                            i.body.span,\n-                            &format!(\n-                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                                lhs\n-                            ),\n-                        );\n-                    } else {\n-                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                            .help(\"...or consider changing the match arm bodies\");\n-                    }\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n-    let mut result = false;\n-    pat.walk_short(|p| {\n-        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n-        !result\n-    });\n-    result\n-}\n-\n-/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n-fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n-    let mut result = true;\n-    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n-    result && ids.is_empty()\n-}"}, {"sha": "2472acb6f6e8b6f974fcf898010e45140bc021ff", "filename": "src/tools/clippy/clippy_lints/src/matches/infalliable_detructuring_match.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Finfalliable_detructuring_match.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{path_to_local_id, peel_blocks, strip_pat_refs};\n+use rustc_errors::Applicability;\n+use rustc_hir::{ExprKind, Local, MatchSource, PatKind, QPath};\n+use rustc_lint::LateContext;\n+\n+use super::INFALLIBLE_DESTRUCTURING_MATCH;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, local: &Local<'_>) -> bool {\n+    if_chain! {\n+        if !local.span.from_expansion();\n+        if let Some(expr) = local.init;\n+        if let ExprKind::Match(target, arms, MatchSource::Normal) = expr.kind;\n+        if arms.len() == 1 && arms[0].guard.is_none();\n+        if let PatKind::TupleStruct(\n+            QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n+        if args.len() == 1;\n+        if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n+        let body = peel_blocks(arms[0].body);\n+        if path_to_local_id(body, arg);\n+\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                INFALLIBLE_DESTRUCTURING_MATCH,\n+                local.span,\n+                \"you seem to be trying to use `match` to destructure a single infallible pattern. \\\n+                Consider using `let`\",\n+                \"try this\",\n+                format!(\n+                    \"let {}({}) = {};\",\n+                    snippet_with_applicability(cx, variant_name.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, local.pat.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability),\n+                ),\n+                applicability,\n+            );\n+            return true;\n+        }\n+    }\n+    false\n+}"}, {"sha": "d914eba01716b69e6fb182bcede18001c2e6f94b", "filename": "src/tools/clippy/clippy_lints/src/matches/match_as_ref.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,85 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{is_lang_ctor, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Expr, ExprKind, LangItem, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_AS_REF;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        let arm_ref: Option<BindingAnnotation> = if is_none_arm(cx, &arms[0]) {\n+            is_ref_some_arm(cx, &arms[1])\n+        } else if is_none_arm(cx, &arms[1]) {\n+            is_ref_some_arm(cx, &arms[0])\n+        } else {\n+            None\n+        };\n+        if let Some(rb) = arm_ref {\n+            let suggestion = if rb == BindingAnnotation::Ref {\n+                \"as_ref\"\n+            } else {\n+                \"as_mut\"\n+            };\n+\n+            let output_ty = cx.typeck_results().expr_ty(expr);\n+            let input_ty = cx.typeck_results().expr_ty(ex);\n+\n+            let cast = if_chain! {\n+                if let ty::Adt(_, substs) = input_ty.kind();\n+                let input_ty = substs.type_at(0);\n+                if let ty::Adt(_, substs) = output_ty.kind();\n+                let output_ty = substs.type_at(0);\n+                if let ty::Ref(_, output_ty, _) = *output_ty.kind();\n+                if input_ty != output_ty;\n+                then {\n+                    \".map(|x| x as _)\"\n+                } else {\n+                    \"\"\n+                }\n+            };\n+\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_AS_REF,\n+                expr.span,\n+                &format!(\"use `{}()` instead\", suggestion),\n+                \"try this\",\n+                format!(\n+                    \"{}.{}(){}\",\n+                    snippet_with_applicability(cx, ex.span, \"_\", &mut applicability),\n+                    suggestion,\n+                    cast,\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}\n+\n+// Checks if arm has the form `None => None`\n+fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n+    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+}\n+\n+// Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n+fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n+    if_chain! {\n+        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n+        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n+        if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n+        if let ExprKind::Path(ref some_path) = e.kind;\n+        if is_lang_ctor(cx, some_path, LangItem::OptionSome) && args.len() == 1;\n+        if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;\n+        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n+        then {\n+            return Some(rb)\n+        }\n+    }\n+    None\n+}"}, {"sha": "90c50b994d2bfe11245881843feef728b1829ad5", "filename": "src/tools/clippy/clippy_lints/src/matches/match_bool.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_bool.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,75 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::is_unit_expr;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::sugg::Sugg;\n+use rustc_ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::MATCH_BOOL;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    // Type of expression is `bool`.\n+    if *cx.typeck_results().expr_ty(ex).kind() == ty::Bool {\n+        span_lint_and_then(\n+            cx,\n+            MATCH_BOOL,\n+            expr.span,\n+            \"you seem to be trying to match on a boolean expression\",\n+            move |diag| {\n+                if arms.len() == 2 {\n+                    // no guards\n+                    let exprs = if let PatKind::Lit(arm_bool) = arms[0].pat.kind {\n+                        if let ExprKind::Lit(ref lit) = arm_bool.kind {\n+                            match lit.node {\n+                                LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                                LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                                _ => None,\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    };\n+\n+                    if let Some((true_expr, false_expr)) = exprs {\n+                        let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                            (false, false) => Some(format!(\n+                                \"if {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span)),\n+                                expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (false, true) => Some(format!(\n+                                \"if {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\", Some(expr.span))\n+                            )),\n+                            (true, false) => {\n+                                let test = Sugg::hir(cx, ex, \"..\");\n+                                Some(format!(\n+                                    \"if {} {}\",\n+                                    !test,\n+                                    expr_block(cx, false_expr, None, \"..\", Some(expr.span))\n+                                ))\n+                            },\n+                            (true, true) => None,\n+                        };\n+\n+                        if let Some(sugg) = sugg {\n+                            diag.span_suggestion(\n+                                expr.span,\n+                                \"consider using an `if`/`else` expression\",\n+                                sugg,\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                }\n+            },\n+        );\n+    }\n+}"}, {"sha": "d605b6d73c09d8b9684e4d2b83a76a91a19b82f2", "filename": "src/tools/clippy/clippy_lints/src/matches/match_like_matches.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_like_matches.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{higher, is_wild};\n+use rustc_ast::{Attribute, LitKind};\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Guard, MatchSource, Pat};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Spanned;\n+\n+use super::MATCH_LIKE_MATCHES_MACRO;\n+\n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            IntoIterator::into_iter([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n+    }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n+}\n+\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n+    if_chain! {\n+        if iter.len() >= 2;\n+        if cx.typeck_results().expr_ty(expr).is_bool();\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n+        if b0 != b1;\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n+            .all(|arm| {\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n+            });\n+        then {\n+            if let Some(last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n+            // The suggestion may be incorrect, because some arms can have `cfg` attributes\n+            // evaluated into `false` and so such arms will be stripped before.\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let pat = {\n+                use itertools::Itertools as _;\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n+                    .join(\" | \")\n+            };\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n+                format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                pat\n+            };\n+\n+            // strip potential borrows (#6503), but only if the type is a reference\n+            let mut ex_new = ex;\n+            if let ExprKind::AddrOf(BorrowKind::Ref, .., ex_inner) = ex.kind {\n+                if let ty::Ref(..) = cx.typeck_results().expr_ty(ex_inner).kind() {\n+                    ex_new = ex_inner;\n+                }\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if b0 { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex_new.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if is_if_let => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "80f964ba1b72c4a246f24ee264d3ce5a508276d4", "filename": "src/tools/clippy/clippy_lints/src/matches/match_ref_pats.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_ref_pats.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,66 @@\n+use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use core::iter::once;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability, Pat, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_REF_PATS;\n+\n+pub(crate) fn check<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_multiple_ref_pats(pats.clone()) {\n+        return;\n+    }\n+\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n+    }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n+}\n+\n+fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut ref_count = 0;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                ref_count += 1;\n+            }\n+        } else {\n+            return false;\n+        }\n+    }\n+    ref_count > 1\n+}"}, {"sha": "271a386859555040a8c43990020700447e7b9c9e", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,111 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, MatchSource, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use std::collections::hash_map::Entry;\n+\n+use super::MATCH_SAME_ARMS;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+    if let ExprKind::Match(_, arms, MatchSource::Normal) = expr.kind {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n+            let mut h = SpanlessHash::new(cx);\n+            h.hash_expr(arm.body);\n+            h.finish()\n+        };\n+\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n+            let min_index = usize::min(lindex, rindex);\n+            let max_index = usize::max(lindex, rindex);\n+\n+            let mut local_map: HirIdMap<HirId> = HirIdMap::default();\n+            let eq_fallback = |a: &Expr<'_>, b: &Expr<'_>| {\n+                if_chain! {\n+                    if let Some(a_id) = path_to_local(a);\n+                    if let Some(b_id) = path_to_local(b);\n+                    let entry = match local_map.entry(a_id) {\n+                        Entry::Vacant(entry) => entry,\n+                        // check if using the same bindings as before\n+                        Entry::Occupied(entry) => return *entry.get() == b_id,\n+                    };\n+                    // the names technically don't have to match; this makes the lint more conservative\n+                    if cx.tcx.hir().name(a_id) == cx.tcx.hir().name(b_id);\n+                    if cx.typeck_results().expr_ty(a) == cx.typeck_results().expr_ty(b);\n+                    if pat_contains_local(lhs.pat, a_id);\n+                    if pat_contains_local(rhs.pat, b_id);\n+                    then {\n+                        entry.insert(b_id);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n+            // Arms with a guard are ignored, those can\u2019t always be merged together\n+            // This is also the case for arms in-between each there is an arm with a guard\n+            (min_index..=max_index).all(|index| arms[index].guard.is_none())\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        };\n+\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n+        for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                j.body.span,\n+                \"this `match` has identical arm bodies\",\n+                |diag| {\n+                    diag.span_note(i.body.span, \"same as this\");\n+\n+                    // Note: this does not use `span_suggestion` on purpose:\n+                    // there is no clean way\n+                    // to remove the other arm. Building a span and suggest to replace it to \"\"\n+                    // makes an even more confusing error message. Also in order not to make up a\n+                    // span for the whole pattern, the suggestion is only shown when there is only\n+                    // one pattern. The user should know about `|` if they are already using it\u2026\n+\n+                    let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n+                    let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n+\n+                    if let PatKind::Wild = j.pat.kind {\n+                        // if the last arm is _, then i could be integrated into _\n+                        // note that i.pat cannot be _, because that would mean that we're\n+                        // hiding all the subsequent arms, and rust won't compile\n+                        diag.span_note(\n+                            i.body.span,\n+                            &format!(\n+                                \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n+                                lhs\n+                            ),\n+                        );\n+                    } else {\n+                        diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n+                            .help(\"...or consider changing the match arm bodies\");\n+                    }\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+fn pat_contains_local(pat: &Pat<'_>, id: HirId) -> bool {\n+    let mut result = false;\n+    pat.walk_short(|p| {\n+        result |= matches!(p.kind, PatKind::Binding(_, binding_id, ..) if binding_id == id);\n+        !result\n+    });\n+    result\n+}\n+\n+/// Returns true if all the bindings in the `Pat` are in `ids` and vice versa\n+fn bindings_eq(pat: &Pat<'_>, mut ids: HirIdSet) -> bool {\n+    let mut result = true;\n+    pat.each_binding_or_first(&mut |_, id, _, _| result &= ids.remove(&id));\n+    result && ids.is_empty()\n+}"}, {"sha": "8ae19e03f1a6a5afbfb1016ebd066c4da9d76d0c", "filename": "src/tools/clippy/clippy_lints/src/matches/match_single_binding.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, Local, Node, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_SINGLE_BINDING;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+        return;\n+    }\n+\n+    // HACK:\n+    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n+    // to prevent false positives as there is currently no better way to detect if code was excluded by\n+    // a macro. See PR #6435\n+    if_chain! {\n+        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n+        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n+        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n+        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n+        if rest_snippet.contains(\"=>\");\n+        then {\n+            // The code it self contains another thick arrow \"=>\"\n+            // -> Either another arm or a comment\n+            return;\n+        }\n+    }\n+\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = peel_blocks(arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    match match_body.kind {\n+        ExprKind::Block(block, _) => {\n+            // macro + expr_ty(body) == ()\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+        _ => {\n+            // expr_ty(body) == ()\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+    }\n+\n+    let mut applicability = Applicability::MaybeIncorrect;\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            // If this match is in a local (`let`) stmt\n+            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n+                (\n+                    parent_let_node.span,\n+                    format!(\n+                        \"let {} = {};\\n{}let {} = {};\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n+                        snippet_body\n+                    ),\n+                )\n+            } else {\n+                // If we are in closure, we need curly braces around suggestion\n+                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n+                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n+                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+                    if let ExprKind::Closure(..) = parent_expr.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the closure\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                // If the parent is already an arm, and the body is another match statement,\n+                // we need curly braces around suggestion\n+                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n+                    if let ExprKind::Match(..) = arm.body.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the match\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                (\n+                    expr.span,\n+                    format!(\n+                        \"{}let {} = {};\\n{}{}{}\",\n+                        cbrace_start,\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        indent,\n+                        snippet_body,\n+                        cbrace_end\n+                    ),\n+                )\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                target_span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using `let` statement\",\n+                sugg,\n+                applicability,\n+            );\n+        },\n+        PatKind::Wild => {\n+            if ex.can_have_side_effects() {\n+                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n+                let sugg = format!(\n+                    \"{};\\n{}{}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    indent,\n+                    snippet_body\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its scrutinee and body\",\n+                    \"consider using the scrutinee and body instead\",\n+                    sugg,\n+                    applicability,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its body itself\",\n+                    \"consider using the match body instead\",\n+                    snippet_body,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Returns true if the `ex` match expression is in a local (`let`) statement\n+fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    let map = &cx.tcx.hir();\n+    if_chain! {\n+        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n+        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n+        then {\n+            return Some(parent_let_expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "3515286d5b4af8e45596abfc7dd98ce51a1b2521", "filename": "src/tools/clippy/clippy_lints/src/matches/match_wild_enum.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_enum.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,198 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_refutable, peel_hir_pat_refs, recurse_or_patterns};\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::{Arm, Expr, PatKind, PathSegment, QPath, Ty, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, VariantDef};\n+use rustc_span::sym;\n+\n+use super::{MATCH_WILDCARD_FOR_SINGLE_VARIANTS, WILDCARD_ENUM_MATCH_ARM};\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n+    let ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    let adt_def = match ty.kind() {\n+        ty::Adt(adt_def, _)\n+            if adt_def.is_enum()\n+                && !(is_type_diagnostic_item(cx, ty, sym::Option) || is_type_diagnostic_item(cx, ty, sym::Result)) =>\n+        {\n+            adt_def\n+        },\n+        _ => return,\n+    };\n+\n+    // First pass - check for violation, but don't do much book-keeping because this is hopefully\n+    // the uncommon case, and the book-keeping is slightly expensive.\n+    let mut wildcard_span = None;\n+    let mut wildcard_ident = None;\n+    let mut has_non_wild = false;\n+    for arm in arms {\n+        match peel_hir_pat_refs(arm.pat).0.kind {\n+            PatKind::Wild => wildcard_span = Some(arm.pat.span),\n+            PatKind::Binding(_, _, ident, None) => {\n+                wildcard_span = Some(arm.pat.span);\n+                wildcard_ident = Some(ident);\n+            },\n+            _ => has_non_wild = true,\n+        }\n+    }\n+    let wildcard_span = match wildcard_span {\n+        Some(x) if has_non_wild => x,\n+        _ => return,\n+    };\n+\n+    // Accumulate the variants which should be put in place of the wildcard because they're not\n+    // already covered.\n+    let has_hidden = adt_def.variants.iter().any(|x| is_hidden(cx, x));\n+    let mut missing_variants: Vec<_> = adt_def.variants.iter().filter(|x| !is_hidden(cx, x)).collect();\n+\n+    let mut path_prefix = CommonPrefixSearcher::None;\n+    for arm in arms {\n+        // Guards mean that this case probably isn't exhaustively covered. Technically\n+        // this is incorrect, as we should really check whether each variant is exhaustively\n+        // covered by the set of guards that cover it, but that's really hard to do.\n+        recurse_or_patterns(arm.pat, |pat| {\n+            let path = match &peel_hir_pat_refs(pat).0.kind {\n+                PatKind::Path(path) => {\n+                    #[allow(clippy::match_same_arms)]\n+                    let id = match cx.qpath_res(path, pat.hir_id) {\n+                        Res::Def(\n+                            DefKind::Const | DefKind::ConstParam | DefKind::AnonConst | DefKind::InlineConst,\n+                            _,\n+                        ) => return,\n+                        Res::Def(_, id) => id,\n+                        _ => return,\n+                    };\n+                    if arm.guard.is_none() {\n+                        missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                    }\n+                    path\n+                },\n+                PatKind::TupleStruct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p)) {\n+                            missing_variants.retain(|e| e.ctor_def_id != Some(id));\n+                        }\n+                    }\n+                    path\n+                },\n+                PatKind::Struct(path, patterns, ..) => {\n+                    if let Some(id) = cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        if arm.guard.is_none() && patterns.iter().all(|p| !is_refutable(cx, p.pat)) {\n+                            missing_variants.retain(|e| e.def_id != id);\n+                        }\n+                    }\n+                    path\n+                },\n+                _ => return,\n+            };\n+            match path {\n+                QPath::Resolved(_, path) => path_prefix.with_path(path.segments),\n+                QPath::TypeRelative(\n+                    Ty {\n+                        kind: TyKind::Path(QPath::Resolved(_, path)),\n+                        ..\n+                    },\n+                    _,\n+                ) => path_prefix.with_prefix(path.segments),\n+                _ => (),\n+            }\n+        });\n+    }\n+\n+    let format_suggestion = |variant: &VariantDef| {\n+        format!(\n+            \"{}{}{}{}\",\n+            if let Some(ident) = wildcard_ident {\n+                format!(\"{} @ \", ident.name)\n+            } else {\n+                String::new()\n+            },\n+            if let CommonPrefixSearcher::Path(path_prefix) = path_prefix {\n+                let mut s = String::new();\n+                for seg in path_prefix {\n+                    s.push_str(seg.ident.as_str());\n+                    s.push_str(\"::\");\n+                }\n+                s\n+            } else {\n+                let mut s = cx.tcx.def_path_str(adt_def.did);\n+                s.push_str(\"::\");\n+                s\n+            },\n+            variant.name,\n+            match variant.ctor_kind {\n+                CtorKind::Fn if variant.fields.len() == 1 => \"(_)\",\n+                CtorKind::Fn => \"(..)\",\n+                CtorKind::Const => \"\",\n+                CtorKind::Fictive => \"{ .. }\",\n+            }\n+        )\n+    };\n+\n+    match missing_variants.as_slice() {\n+        [] => (),\n+        [x] if !adt_def.is_variant_list_non_exhaustive() && !has_hidden => span_lint_and_sugg(\n+            cx,\n+            MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+            wildcard_span,\n+            \"wildcard matches only a single variant and will also match any future added variants\",\n+            \"try this\",\n+            format_suggestion(x),\n+            Applicability::MaybeIncorrect,\n+        ),\n+        variants => {\n+            let mut suggestions: Vec<_> = variants.iter().copied().map(format_suggestion).collect();\n+            let message = if adt_def.is_variant_list_non_exhaustive() || has_hidden {\n+                suggestions.push(\"_\".into());\n+                \"wildcard matches known variants and will also match future added variants\"\n+            } else {\n+                \"wildcard match will also match any future added variants\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                WILDCARD_ENUM_MATCH_ARM,\n+                wildcard_span,\n+                message,\n+                \"try this\",\n+                suggestions.join(\" | \"),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    };\n+}\n+\n+enum CommonPrefixSearcher<'a> {\n+    None,\n+    Path(&'a [PathSegment<'a>]),\n+    Mixed,\n+}\n+impl<'a> CommonPrefixSearcher<'a> {\n+    fn with_path(&mut self, path: &'a [PathSegment<'a>]) {\n+        match path {\n+            [path @ .., _] => self.with_prefix(path),\n+            [] => (),\n+        }\n+    }\n+\n+    fn with_prefix(&mut self, path: &'a [PathSegment<'a>]) {\n+        match self {\n+            Self::None => *self = Self::Path(path),\n+            Self::Path(self_path)\n+                if path\n+                    .iter()\n+                    .map(|p| p.ident.name)\n+                    .eq(self_path.iter().map(|p| p.ident.name)) => {},\n+            Self::Path(_) => *self = Self::Mixed,\n+            Self::Mixed => (),\n+        }\n+    }\n+}\n+\n+fn is_hidden(cx: &LateContext<'_>, variant_def: &VariantDef) -> bool {\n+    let attrs = cx.tcx.get_attrs(variant_def.def_id);\n+    clippy_utils::attrs::is_doc_hidden(attrs) || clippy_utils::attrs::is_unstable(attrs)\n+}"}, {"sha": "bc16f17b6196e420184860ce3dd731f9eeeebdbe", "filename": "src/tools/clippy/clippy_lints/src/matches/match_wild_err_arm.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_wild_err_arm.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,51 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::macros::{is_panic, root_macro_call};\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::is_local_used;\n+use clippy_utils::{is_wild, peel_blocks_with_stmt};\n+use rustc_hir::{Arm, Expr, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::{kw, sym};\n+\n+use super::MATCH_WILD_ERR_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &Expr<'tcx>, arms: &[Arm<'tcx>]) {\n+    let ex_ty = cx.typeck_results().expr_ty(ex).peel_refs();\n+    if is_type_diagnostic_item(cx, ex_ty, sym::Result) {\n+        for arm in arms {\n+            if let PatKind::TupleStruct(ref path, inner, _) = arm.pat.kind {\n+                let path_str = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false));\n+                if path_str == \"Err\" {\n+                    let mut matching_wild = inner.iter().any(is_wild);\n+                    let mut ident_bind_name = kw::Underscore;\n+                    if !matching_wild {\n+                        // Looking for unused bindings (i.e.: `_e`)\n+                        for pat in inner.iter() {\n+                            if let PatKind::Binding(_, id, ident, None) = pat.kind {\n+                                if ident.as_str().starts_with('_') && !is_local_used(cx, arm.body, id) {\n+                                    ident_bind_name = ident.name;\n+                                    matching_wild = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if_chain! {\n+                        if matching_wild;\n+                        if let Some(macro_call) = root_macro_call(peel_blocks_with_stmt(arm.body).span);\n+                        if is_panic(cx, macro_call.def_id);\n+                        then {\n+                            // `Err(_)` or `Err(_e)` arm with `panic!` found\n+                            span_lint_and_note(cx,\n+                                MATCH_WILD_ERR_ARM,\n+                                arm.pat.span,\n+                                &format!(\"`Err({})` matches all errors\", ident_bind_name),\n+                                None,\n+                                \"match each error separately or use the error output, or use `.except(msg)` if the error case is unreachable\",\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "b5ee4561f06eceeb346ea5f648adf7357ddb9ea6", "filename": "src/tools/clippy/clippy_lints/src/matches/mod.rs", "status": "added", "additions": 646, "deletions": 0, "changes": 646, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,646 @@\n+use clippy_utils::{meets_msrv, msrvs};\n+use rustc_hir::{Expr, ExprKind, Local, MatchSource, Pat};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+mod infalliable_detructuring_match;\n+mod match_as_ref;\n+mod match_bool;\n+mod match_like_matches;\n+mod match_ref_pats;\n+mod match_same_arms;\n+mod match_single_binding;\n+mod match_wild_enum;\n+mod match_wild_err_arm;\n+mod overlapping_arms;\n+mod redundant_pattern_match;\n+mod rest_pat_in_fully_bound_struct;\n+mod single_match;\n+mod wild_in_or_pats;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with a single arm where an `if let`\n+    /// will usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn bar(stool: &str) {}\n+    /// # let x = Some(\"abc\");\n+    /// // Bad\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH,\n+    style,\n+    \"a `match` statement with a single nontrivial arm (i.e., where the other arm is `_ => {}`) instead of `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches with two arms where an `if let else` will\n+    /// usually suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `if let` nests less than a `match`.\n+    ///\n+    /// ### Known problems\n+    /// Personal style preferences may differ.\n+    ///\n+    /// ### Example\n+    /// Using `match`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// match x {\n+    ///     Some(ref foo) => bar(foo),\n+    ///     _ => bar(&other_ref),\n+    /// }\n+    /// ```\n+    ///\n+    /// Using `if let` with `else`:\n+    ///\n+    /// ```rust\n+    /// # fn bar(foo: &usize) {}\n+    /// # let other_ref: usize = 1;\n+    /// # let x: Option<&usize> = Some(&1);\n+    /// if let Some(ref foo) = x {\n+    ///     bar(foo);\n+    /// } else {\n+    ///     bar(&other_ref);\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub SINGLE_MATCH_ELSE,\n+    pedantic,\n+    \"a `match` statement with two arms where the second arm's pattern is a placeholder instead of a specific match pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where all arms match a reference,\n+    /// suggesting to remove the reference and deref the matched expression\n+    /// instead. It also checks for `if let &foo = bar` blocks.\n+    ///\n+    /// ### Why is this bad?\n+    /// It just makes the code less readable. That reference\n+    /// destructuring adds nothing to the code.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// match x {\n+    ///     &A(ref y) => foo(y),\n+    ///     &B => bar(),\n+    ///     _ => frob(&x),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match *x {\n+    ///     A(ref y) => foo(y),\n+    ///     B => bar(),\n+    ///     _ => frob(x),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_REF_PATS,\n+    style,\n+    \"a `match` or `if let` with all arms prefixed with `&` instead of deref-ing the match expression\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches where match expression is a `bool`. It\n+    /// suggests to replace the expression with an `if...else` block.\n+    ///\n+    /// ### Why is this bad?\n+    /// It makes the code less readable.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// match condition {\n+    ///     true => foo(),\n+    ///     false => bar(),\n+    /// }\n+    /// ```\n+    /// Use if/else instead:\n+    /// ```rust\n+    /// # fn foo() {}\n+    /// # fn bar() {}\n+    /// let condition: bool = true;\n+    /// if condition {\n+    ///     foo();\n+    /// } else {\n+    ///     bar();\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_BOOL,\n+    pedantic,\n+    \"a `match` on a boolean expression instead of an `if..else` block\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for overlapping match arms.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is likely to be an error and if not, makes the code\n+    /// less obvious.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     1..=10 => println!(\"1 ... 10\"),\n+    ///     5..=15 => println!(\"5 ... 15\"),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_OVERLAPPING_ARM,\n+    style,\n+    \"a `match` with overlapping arms\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for arm which matches all errors with `Err(_)`\n+    /// and take drastic actions like `panic!`.\n+    ///\n+    /// ### Why is this bad?\n+    /// It is generally a bad practice, similar to\n+    /// catching all exceptions in java with `catch(Exception)`\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Result<i32, &str> = Ok(3);\n+    /// match x {\n+    ///     Ok(_) => println!(\"ok\"),\n+    ///     Err(_) => panic!(\"err\"),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_WILD_ERR_ARM,\n+    pedantic,\n+    \"a `match` with `Err(_)` arm and take drastic actions\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for match which is used to add a reference to an\n+    /// `Option` value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using `as_ref()` or `as_mut()` instead is shorter.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x: Option<()> = None;\n+    ///\n+    /// // Bad\n+    /// let r: Option<&()> = match x {\n+    ///     None => None,\n+    ///     Some(ref v) => Some(v),\n+    /// };\n+    ///\n+    /// // Good\n+    /// let r: Option<&()> = x.as_ref();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_AS_REF,\n+    complexity,\n+    \"a `match` on an Option value instead of using `as_ref()` or `as_mut`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches using `_`.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may be incorrect if guards exhaustively cover some\n+    /// variants, and also may not use correct path to enum if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A(usize), B(usize) }\n+    /// # let x = Foo::B(1);\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A(_) => {},\n+    ///     Foo::B(_) => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.34.0\"]\n+    pub WILDCARD_ENUM_MATCH_ARM,\n+    restriction,\n+    \"a wildcard enum match arm using `_`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard enum matches for a single variant.\n+    ///\n+    /// ### Why is this bad?\n+    /// New enum variants added by library updates can be missed.\n+    ///\n+    /// ### Known problems\n+    /// Suggested replacements may not use correct path to enum\n+    /// if it's not present in the current scope.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # enum Foo { A, B, C }\n+    /// # let x = Foo::B;\n+    /// // Bad\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match x {\n+    ///     Foo::A => {},\n+    ///     Foo::B => {},\n+    ///     Foo::C => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.45.0\"]\n+    pub MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    pedantic,\n+    \"a wildcard enum match for a single variant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for wildcard pattern used with others patterns in same match arm.\n+    ///\n+    /// ### Why is this bad?\n+    /// Wildcard pattern already covers any other pattern as it will match anyway.\n+    /// It makes the code less readable, especially to spot wildcard pattern use in match arm.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// // Bad\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     \"bar\" | _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match \"foo\" {\n+    ///     \"a\" => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.42.0\"]\n+    pub WILDCARD_IN_OR_PATTERNS,\n+    complexity,\n+    \"a wildcard pattern used with others patterns in same match arm\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for matches being used to destructure a single-variant enum\n+    /// or tuple struct where a `let` will suffice.\n+    ///\n+    /// ### Why is this bad?\n+    /// Just readability \u2013 `let` doesn't nest, whereas a `match` does.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    ///\n+    /// let data = match wrapper {\n+    ///     Wrapper::Data(i) => i,\n+    /// };\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    /// ```rust\n+    /// enum Wrapper {\n+    ///     Data(i32),\n+    /// }\n+    ///\n+    /// let wrapper = Wrapper::Data(42);\n+    /// let Wrapper::Data(data) = wrapper;\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub INFALLIBLE_DESTRUCTURING_MATCH,\n+    style,\n+    \"a `match` statement with a single infallible arm instead of a `let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for useless match that binds to only one value.\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    ///  Suggested replacements may be incorrect when `match`\n+    /// is actually binding temporary value, bringing a 'dropped while borrowed' error.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let a = 1;\n+    /// # let b = 2;\n+    ///\n+    /// // Bad\n+    /// match (a, b) {\n+    ///     (c, d) => {\n+    ///         // useless match\n+    ///     }\n+    /// }\n+    ///\n+    /// // Good\n+    /// let (c, d) = (a, b);\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub MATCH_SINGLE_BINDING,\n+    complexity,\n+    \"a match with a single binding instead of using `let` statement\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary '..' pattern binding on struct when all fields are explicitly matched.\n+    ///\n+    /// ### Why is this bad?\n+    /// Correctness and readability. It's like having a wildcard pattern after\n+    /// matching all enum variants explicitly.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # struct A { a: i32 }\n+    /// let a = A { a: 5 };\n+    ///\n+    /// // Bad\n+    /// match a {\n+    ///     A { a: 5, .. } => {},\n+    ///     _ => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match a {\n+    ///     A { a: 5 } => {},\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.43.0\"]\n+    pub REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    restriction,\n+    \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lint for redundant pattern matching over `Result`, `Option`,\n+    /// `std::task::Poll` or `std::net::IpAddr`\n+    ///\n+    /// ### Why is this bad?\n+    /// It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// ### Known problems\n+    /// This will change the drop order for the matched type. Both `if let` and\n+    /// `while let` will drop the value at the end of the block, both `if` and `while` will drop the\n+    /// value before entering the block. For most types this change will not matter, but for a few\n+    /// types this will not be an acceptable change (e.g. locks). See the\n+    /// [reference](https://doc.rust-lang.org/reference/destructors.html#drop-scopes) for more about\n+    /// drop order.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// if let Poll::Pending = Poll::Pending::<()> {}\n+    /// if let Poll::Ready(_) = Poll::Ready(42) {}\n+    /// if let IpAddr::V4(_) = IpAddr::V4(Ipv4Addr::LOCALHOST) {}\n+    /// if let IpAddr::V6(_) = IpAddr::V6(Ipv6Addr::LOCALHOST) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// # use std::task::Poll;\n+    /// # use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// if Poll::Pending::<()>.is_pending() {}\n+    /// if Poll::Ready(42).is_ready() {}\n+    /// if IpAddr::V4(Ipv4Addr::LOCALHOST).is_ipv4() {}\n+    /// if IpAddr::V6(Ipv6Addr::LOCALHOST).is_ipv6() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    #[clippy::version = \"1.31.0\"]\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability and needless complexity.\n+    ///\n+    /// ### Known problems\n+    /// This lint falsely triggers, if there are arms with\n+    /// `cfg` attributes that remove an arm evaluating to `false`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    #[clippy::version = \"1.47.0\"]\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `match` with identical arm bodies.\n+    ///\n+    /// ### Why is this bad?\n+    /// This is probably a copy & paste error. If arm bodies\n+    /// are the same on purpose, you can factor them\n+    /// [using `|`](https://doc.rust-lang.org/book/patterns.html#multiple-patterns).\n+    ///\n+    /// ### Known problems\n+    /// False positive possible with order dependent `match`\n+    /// (see issue\n+    /// [#860](https://github.com/rust-lang/rust-clippy/issues/860)).\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => bar(), // <= oops\n+    /// }\n+    /// ```\n+    ///\n+    /// This should probably be\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar => bar(),\n+    ///     Quz => quz(),\n+    ///     Baz => baz(), // <= fixed\n+    /// }\n+    /// ```\n+    ///\n+    /// or if the original code was not a typo:\n+    /// ```rust,ignore\n+    /// match foo {\n+    ///     Bar | Baz => bar(), // <= shows the intent better\n+    ///     Quz => quz(),\n+    /// }\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MATCH_SAME_ARMS,\n+    pedantic,\n+    \"`match` with identical arm bodies\"\n+}\n+\n+#[derive(Default)]\n+pub struct Matches {\n+    msrv: Option<RustcVersion>,\n+    infallible_destructuring_match_linted: bool,\n+}\n+\n+impl Matches {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            ..Matches::default()\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(Matches => [\n+    SINGLE_MATCH,\n+    MATCH_REF_PATS,\n+    MATCH_BOOL,\n+    SINGLE_MATCH_ELSE,\n+    MATCH_OVERLAPPING_ARM,\n+    MATCH_WILD_ERR_ARM,\n+    MATCH_AS_REF,\n+    WILDCARD_ENUM_MATCH_ARM,\n+    MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n+    WILDCARD_IN_OR_PATTERNS,\n+    MATCH_SINGLE_BINDING,\n+    INFALLIBLE_DESTRUCTURING_MATCH,\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO,\n+    MATCH_SAME_ARMS,\n+]);\n+\n+impl<'tcx> LateLintPass<'tcx> for Matches {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        redundant_pattern_match::check(cx, expr);\n+\n+        if meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO) {\n+            if !match_like_matches::check(cx, expr) {\n+                match_same_arms::check(cx, expr);\n+            }\n+        } else {\n+            match_same_arms::check(cx, expr);\n+        }\n+\n+        if let ExprKind::Match(ex, arms, MatchSource::Normal) = expr.kind {\n+            single_match::check(cx, ex, arms, expr);\n+            match_bool::check(cx, ex, arms, expr);\n+            overlapping_arms::check(cx, ex, arms);\n+            match_wild_err_arm::check(cx, ex, arms);\n+            match_wild_enum::check(cx, ex, arms);\n+            match_as_ref::check(cx, ex, arms, expr);\n+            wild_in_or_pats::check(cx, arms);\n+\n+            if self.infallible_destructuring_match_linted {\n+                self.infallible_destructuring_match_linted = false;\n+            } else {\n+                match_single_binding::check(cx, ex, arms, expr);\n+            }\n+        }\n+        if let ExprKind::Match(ex, arms, _) = expr.kind {\n+            match_ref_pats::check(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        }\n+    }\n+\n+    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n+        self.infallible_destructuring_match_linted |= infalliable_detructuring_match::check(cx, local);\n+    }\n+\n+    fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n+        rest_pat_in_fully_bound_struct::check(cx, pat);\n+    }\n+\n+    extract_msrv_attr!(LateContext);\n+}"}, {"sha": "7e658126690299787f1410a713533a78d8c60a06", "filename": "src/tools/clippy/clippy_lints/src/matches/overlapping_arms.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Foverlapping_arms.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,181 @@\n+use clippy_utils::consts::{constant, constant_full_int, miri_to_const, FullInt};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use core::cmp::Ordering;\n+use rustc_hir::{Arm, Expr, PatKind, RangeEnd};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+use rustc_span::Span;\n+\n+use super::MATCH_OVERLAPPING_ARM;\n+\n+pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n+    if arms.len() >= 2 && cx.typeck_results().expr_ty(ex).is_integral() {\n+        let ranges = all_ranges(cx, arms, cx.typeck_results().expr_ty(ex));\n+        if !ranges.is_empty() {\n+            if let Some((start, end)) = overlapping(&ranges) {\n+                span_lint_and_note(\n+                    cx,\n+                    MATCH_OVERLAPPING_ARM,\n+                    start.span,\n+                    \"some ranges overlap\",\n+                    Some(end.span),\n+                    \"overlaps with this\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+/// Gets the ranges for each range pattern arm. Applies `ty` bounds for open ranges.\n+fn all_ranges<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>], ty: Ty<'tcx>) -> Vec<SpannedRange<FullInt>> {\n+    arms.iter()\n+        .filter_map(|arm| {\n+            if let Arm { pat, guard: None, .. } = *arm {\n+                if let PatKind::Range(ref lhs, ref rhs, range_end) = pat.kind {\n+                    let lhs_const = match lhs {\n+                        Some(lhs) => constant(cx, cx.typeck_results(), lhs)?.0,\n+                        None => miri_to_const(ty.numeric_min_val(cx.tcx)?)?,\n+                    };\n+                    let rhs_const = match rhs {\n+                        Some(rhs) => constant(cx, cx.typeck_results(), rhs)?.0,\n+                        None => miri_to_const(ty.numeric_max_val(cx.tcx)?)?,\n+                    };\n+\n+                    let lhs_val = lhs_const.int_value(cx, ty)?;\n+                    let rhs_val = rhs_const.int_value(cx, ty)?;\n+\n+                    let rhs_bound = match range_end {\n+                        RangeEnd::Included => EndBound::Included(rhs_val),\n+                        RangeEnd::Excluded => EndBound::Excluded(rhs_val),\n+                    };\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (lhs_val, rhs_bound),\n+                    });\n+                }\n+\n+                if let PatKind::Lit(value) = pat.kind {\n+                    let value = constant_full_int(cx, cx.typeck_results(), value)?;\n+                    return Some(SpannedRange {\n+                        span: pat.span,\n+                        node: (value, EndBound::Included(value)),\n+                    });\n+                }\n+            }\n+            None\n+        })\n+        .collect()\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum EndBound<T> {\n+    Included(T),\n+    Excluded(T),\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+struct SpannedRange<T> {\n+    pub span: Span,\n+    pub node: (T, EndBound<T>),\n+}\n+\n+fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n+where\n+    T: Copy + Ord,\n+{\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n+\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n+        }\n+    }\n+\n+    let mut values = Vec::with_capacity(2 * ranges.len());\n+\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n+    }\n+\n+    values.sort();\n+\n+    let mut started = vec![];\n+\n+    for RangeBound(_, kind, range) in values {\n+        match kind {\n+            BoundKind::Start => started.push(range),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n+                let mut overlap = None;\n+\n+                while let Some(last_started) = started.pop() {\n+                    if last_started == range {\n+                        break;\n+                    }\n+                    overlap = Some(last_started);\n+                }\n+\n+                if let Some(first_overlapping) = overlap {\n+                    return Some((range, first_overlapping));\n+                }\n+            },\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[test]\n+fn test_overlapping() {\n+    use rustc_span::source_map::DUMMY_SP;\n+\n+    let sp = |s, e| SpannedRange {\n+        span: DUMMY_SP,\n+        node: (s, e),\n+    };\n+\n+    assert_eq!(None, overlapping::<u8>(&[]));\n+    assert_eq!(None, overlapping(&[sp(1, EndBound::Included(4))]));\n+    assert_eq!(\n+        None,\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(5, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        None,\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(10, EndBound::Included(11))\n+        ],)\n+    );\n+    assert_eq!(\n+        Some((&sp(1, EndBound::Included(4)), &sp(3, EndBound::Included(6)))),\n+        overlapping(&[sp(1, EndBound::Included(4)), sp(3, EndBound::Included(6))])\n+    );\n+    assert_eq!(\n+        Some((&sp(5, EndBound::Included(6)), &sp(6, EndBound::Included(11)))),\n+        overlapping(&[\n+            sp(1, EndBound::Included(4)),\n+            sp(5, EndBound::Included(6)),\n+            sp(6, EndBound::Included(11))\n+        ],)\n+    );\n+}"}, {"sha": "61c5fa0872f6a4527e3a5ef3db62986fb5d2b191", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,436 @@\n+use super::REDUNDANT_PATTERN_MATCHING;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::source::snippet;\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::{higher, match_def_path};\n+use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, PollPending};\n+use rustc_hir::{\n+    intravisit::{walk_expr, Visitor},\n+    Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath, UnOp,\n+};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n+use rustc_span::sym;\n+\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let Some(higher::IfLet {\n+        if_else,\n+        let_pat,\n+        let_expr,\n+        ..\n+    }) = higher::IfLet::hir(cx, expr)\n+    {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some());\n+    }\n+    if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+        find_sugg_for_match(cx, expr, op, arms);\n+    }\n+    if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+        find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false);\n+    }\n+}\n+\n+/// Checks if the drop order for a type matters. Some std types implement drop solely to\n+/// deallocate memory. For these types, and composites containing them, changing the drop order\n+/// won't result in any observable side effects.\n+fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+}\n+\n+fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+    if !seen.insert(ty) {\n+        return false;\n+    }\n+    if !ty.needs_drop(cx.tcx, cx.param_env) {\n+        false\n+    } else if !cx\n+        .tcx\n+        .lang_items()\n+        .drop_trait()\n+        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    {\n+        // This type doesn't implement drop, so no side effects here.\n+        // Check if any component type has any.\n+        match ty.kind() {\n+            ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Adt(adt, subs) => adt\n+                .all_fields()\n+                .map(|f| f.ty(cx.tcx, subs))\n+                .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            _ => true,\n+        }\n+    }\n+    // Check for std types which implement drop, but only for memory allocation.\n+    else if is_type_diagnostic_item(cx, ty, sym::Vec)\n+        || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+        || is_type_diagnostic_item(cx, ty, sym::Rc)\n+        || is_type_diagnostic_item(cx, ty, sym::Arc)\n+        || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n+        || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n+        || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n+        || match_type(cx, ty, &paths::WEAK_RC)\n+        || match_type(cx, ty, &paths::WEAK_ARC)\n+    {\n+        // Check all of the generic arguments.\n+        if let ty::Adt(_, subs) = ty.kind() {\n+            subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n+        } else {\n+            true\n+        }\n+    } else {\n+        true\n+    }\n+}\n+\n+// Extract the generic arguments out of a type\n+fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n+    if_chain! {\n+        if let ty::Adt(_, subs) = ty.kind();\n+        if let Some(sub) = subs.get(index);\n+        if let GenericArgKind::Type(sub_ty) = sub.unpack();\n+        then {\n+            Some(sub_ty)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Checks if there are any temporaries created in the given expression for which drop order\n+// matters.\n+fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        res: bool,\n+    }\n+    impl<'a, 'tcx> Visitor<'tcx> for V<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+            match expr.kind {\n+                // Taking the reference of a value leaves a temporary\n+                // e.g. In `&String::new()` the string is a temporary value.\n+                // Remaining fields are temporary values\n+                // e.g. In `(String::new(), 0).1` the string is a temporary value.\n+                ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n+                    if !matches!(expr.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(expr);\n+                        }\n+                    }\n+                },\n+                // the base type is alway taken by reference.\n+                // e.g. In `(vec![0])[0]` the vector is a temporary value.\n+                ExprKind::Index(base, index) => {\n+                    if !matches!(base.kind, ExprKind::Path(_)) {\n+                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(base);\n+                        }\n+                    }\n+                    self.visit_expr(index);\n+                },\n+                // Method calls can take self by reference.\n+                // e.g. In `String::new().len()` the string is a temporary value.\n+                ExprKind::MethodCall(_, [self_arg, args @ ..], _) => {\n+                    if !matches!(self_arg.kind, ExprKind::Path(_)) {\n+                        let self_by_ref = self\n+                            .cx\n+                            .typeck_results()\n+                            .type_dependent_def_id(expr.hir_id)\n+                            .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n+                        if self_by_ref && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                            self.res = true;\n+                        } else {\n+                            self.visit_expr(self_arg);\n+                        }\n+                    }\n+                    args.iter().for_each(|arg| self.visit_expr(arg));\n+                },\n+                // Either explicitly drops values, or changes control flow.\n+                ExprKind::DropTemps(_)\n+                | ExprKind::Ret(_)\n+                | ExprKind::Break(..)\n+                | ExprKind::Yield(..)\n+                | ExprKind::Block(Block { expr: None, .. }, _)\n+                | ExprKind::Loop(..) => (),\n+\n+                // Only consider the final expression.\n+                ExprKind::Block(Block { expr: Some(expr), .. }, _) => self.visit_expr(expr),\n+\n+                _ => walk_expr(self, expr),\n+            }\n+        }\n+    }\n+\n+    let mut v = V { cx, res: false };\n+    v.visit_expr(expr);\n+    v.res\n+}\n+\n+fn find_sugg_for_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    keyword: &'static str,\n+    has_else: bool,\n+) {\n+    // also look inside refs\n+    // if we have &None for example, peel it so we can detect \"if let None = x\"\n+    let check_pat = match let_pat.kind {\n+        PatKind::Ref(inner, _mutability) => inner,\n+        _ => let_pat,\n+    };\n+    let op_ty = cx.typeck_results().expr_ty(let_expr);\n+    // Determine which function should be used, and the type contained by the corresponding\n+    // variant.\n+    let (good_method, inner_ty) = match check_pat.kind {\n+        PatKind::TupleStruct(ref qpath, [sub_pat], _) => {\n+            if let PatKind::Wild = sub_pat.kind {\n+                let res = cx.typeck_results().qpath_res(qpath, check_pat.hir_id);\n+                let Some(id) = res.opt_def_id().and_then(|ctor_id| cx.tcx.parent(ctor_id)) else { return };\n+                let lang_items = cx.tcx.lang_items();\n+                if Some(id) == lang_items.result_ok_variant() {\n+                    (\"is_ok()\", try_get_generic_ty(op_ty, 0).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.result_err_variant() {\n+                    (\"is_err()\", try_get_generic_ty(op_ty, 1).unwrap_or(op_ty))\n+                } else if Some(id) == lang_items.option_some_variant() {\n+                    (\"is_some()\", op_ty)\n+                } else if Some(id) == lang_items.poll_ready_variant() {\n+                    (\"is_ready()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V4) {\n+                    (\"is_ipv4()\", op_ty)\n+                } else if match_def_path(cx, id, &paths::IPADDR_V6) {\n+                    (\"is_ipv6()\", op_ty)\n+                } else {\n+                    return;\n+                }\n+            } else {\n+                return;\n+            }\n+        },\n+        PatKind::Path(ref path) => {\n+            let method = if is_lang_ctor(cx, path, OptionNone) {\n+                \"is_none()\"\n+            } else if is_lang_ctor(cx, path, PollPending) {\n+                \"is_pending()\"\n+            } else {\n+                return;\n+            };\n+            // `None` and `Pending` don't have an inner type.\n+            (method, cx.tcx.types.unit)\n+        },\n+        _ => return,\n+    };\n+\n+    // If this is the last expression in a block or there is an else clause then the whole\n+    // type needs to be considered, not just the inner type of the branch being matched on.\n+    // Note the last expression in a block is dropped after all local bindings.\n+    let check_ty = if has_else\n+        || (keyword == \"if\" && matches!(cx.tcx.hir().parent_iter(expr.hir_id).next(), Some((_, Node::Block(..)))))\n+    {\n+        op_ty\n+    } else {\n+        inner_ty\n+    };\n+\n+    // All temporaries created in the scrutinee expression are dropped at the same time as the\n+    // scrutinee would be, so they have to be considered as well.\n+    // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n+    // for the duration if body.\n+    let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+\n+    // check that `while_let_on_iterator` lint does not trigger\n+    if_chain! {\n+        if keyword == \"while\";\n+        if let ExprKind::MethodCall(method_path, _, _) = let_expr.kind;\n+        if method_path.ident.name == sym::next;\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        then {\n+            return;\n+        }\n+    }\n+\n+    let result_expr = match &let_expr.kind {\n+        ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+        ExprKind::Unary(UnOp::Deref, deref) => deref,\n+        _ => let_expr,\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        REDUNDANT_PATTERN_MATCHING,\n+        let_pat.span,\n+        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+        |diag| {\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+            let expr_span = expr.span;\n+\n+            // if/while let ... = ... { ... }\n+            //                 ^^^\n+            let op_span = result_expr.span.source_callsite();\n+\n+            // if/while let ... = ... { ... }\n+            // ^^^^^^^^^^^^^^^^^^^\n+            let span = expr_span.until(op_span.shrink_to_hi());\n+\n+            let app = if needs_drop {\n+                Applicability::MaybeIncorrect\n+            } else {\n+                Applicability::MachineApplicable\n+            };\n+\n+            let sugg = Sugg::hir_with_macro_callsite(cx, result_expr, \"_\")\n+                .maybe_par()\n+                .to_string();\n+\n+            diag.span_suggestion(span, \"try this\", format!(\"{} {}.{}\", keyword, sugg, good_method), app);\n+\n+            if needs_drop {\n+                diag.note(\"this will change drop order of the result, as well as all temporaries\");\n+                diag.note(\"add `#[allow(clippy::redundant_pattern_matching)]` if this is important\");\n+            }\n+        },\n+    );\n+}\n+\n+fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, patterns_left, _),\n+                PatKind::TupleStruct(ref path_right, patterns_right, _),\n+            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::IPADDR_V4,\n+                            &paths::IPADDR_V6,\n+                            \"is_ipv4()\",\n+                            \"is_ipv6()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            (PatKind::TupleStruct(ref path_left, patterns, _), PatKind::Path(ref path_right))\n+            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, patterns, _))\n+                if patterns.len() == 1 =>\n+            {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_good_method_for_match(\n+                        cx,\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\",\n+                    )\n+                    .or_else(|| {\n+                        find_good_method_for_match(\n+                            cx,\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::POLL_READY,\n+                            &paths::POLL_PENDING,\n+                            \"is_ready()\",\n+                            \"is_pending()\",\n+                        )\n+                    })\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            let span = expr.span.to(op.span);\n+            let result_expr = match &op.kind {\n+                ExprKind::AddrOf(_, _, borrowed) => borrowed,\n+                _ => op,\n+            };\n+            span_lint_and_then(\n+                cx,\n+                REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |diag| {\n+                    diag.span_suggestion(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, result_expr.span, \"_\"), good_method),\n+                        Applicability::MaybeIncorrect, // snippet\n+                    );\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+fn find_good_method_for_match<'a>(\n+    cx: &LateContext<'_>,\n+    arms: &[Arm<'_>],\n+    path_left: &QPath<'_>,\n+    path_right: &QPath<'_>,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str,\n+) -> Option<&'a str> {\n+    let left_id = cx\n+        .typeck_results()\n+        .qpath_res(path_left, arms[0].pat.hir_id)\n+        .opt_def_id()?;\n+    let right_id = cx\n+        .typeck_results()\n+        .qpath_res(path_right, arms[1].pat.hir_id)\n+        .opt_def_id()?;\n+    let body_node_pair = if match_def_path(cx, left_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+    } else if match_def_path(cx, right_id, expected_left) && match_def_path(cx, right_id, expected_right) {\n+        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+            (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+            (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+            _ => None,\n+        },\n+        _ => None,\n+    }\n+}"}, {"sha": "5076239a57c4d79f707b8aa0655d698ba126faf7", "filename": "src/tools/clippy/clippy_lints/src/matches/rest_pat_in_fully_bound_struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_hir::{Pat, PatKind, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+\n+use super::REST_PAT_IN_FULLY_BOUND_STRUCTS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, pat: &Pat<'_>) {\n+    if_chain! {\n+        if !pat.span.from_expansion();\n+        if let PatKind::Struct(QPath::Resolved(_, path), fields, true) = pat.kind;\n+        if let Some(def_id) = path.res.opt_def_id();\n+        let ty = cx.tcx.type_of(def_id);\n+        if let ty::Adt(def, _) = ty.kind();\n+        if def.is_struct() || def.is_union();\n+        if fields.len() == def.non_enum_variant().fields.len();\n+\n+        then {\n+            span_lint_and_help(\n+                cx,\n+                REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+                pat.span,\n+                \"unnecessary use of `..` pattern in struct binding. All fields were already bound\",\n+                None,\n+                \"consider removing `..` from this binding\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "6ba279eaf122433885b17e8dcf592dd88876bf09", "filename": "src/tools/clippy/clippy_lints/src/matches/single_match.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,269 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{expr_block, snippet};\n+use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n+use clippy_utils::{\n+    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n+};\n+use core::cmp::max;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty, TyS};\n+\n+use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n+\n+#[rustfmt::skip]\n+pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n+        if expr.span.from_expansion() {\n+            // Don't lint match expressions present in\n+            // macro_rules! block\n+            return;\n+        }\n+        if let PatKind::Or(..) = arms[0].pat.kind {\n+            // don't lint for or patterns for now, this makes\n+            // the lint noisy in unnecessary situations\n+            return;\n+        }\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(peel_blocks(els)) {\n+            None\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            }\n+            // block with 2+ statements or 1 expr and 1+ statement\n+            Some(els)\n+        } else {\n+            // not a block, don't lint\n+            return;\n+        };\n+\n+        let ty = cx.typeck_results().expr_ty(ex);\n+        if *ty.kind() != ty::Bool || is_lint_allowed(cx, MATCH_BOOL, ex.hir_id) {\n+            check_single_pattern(cx, ex, arms, expr, els);\n+            check_opt_like(cx, ex, arms, expr, ty, els);\n+        }\n+    }\n+}\n+\n+fn check_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    if is_wild(arms[1].pat) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+fn report_single_pattern(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n+    let els_str = els.map_or(String::new(), |els| {\n+        format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n+    });\n+\n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n+    let (msg, sugg) = if_chain! {\n+        if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n+        let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n+        if let Some(spe_trait_id) = cx.tcx.lang_items().structural_peq_trait();\n+        if let Some(pe_trait_id) = cx.tcx.lang_items().eq_trait();\n+        if ty.is_integral() || ty.is_char() || ty.is_str()\n+            || (implements_trait(cx, ty, spe_trait_id, &[])\n+                && implements_trait(cx, ty, pe_trait_id, &[ty.into()]));\n+        then {\n+            // scrutinee derives PartialEq and the pattern is a constant.\n+            let pat_ref_count = match pat.kind {\n+                // string literals are already a reference.\n+                PatKind::Lit(Expr { kind: ExprKind::Lit(lit), .. }) if lit.node.is_str() => pat_ref_count + 1,\n+                _ => pat_ref_count,\n+            };\n+            // References are only implicitly added to the pattern, so no overflow here.\n+            // e.g. will work: match &Some(_) { Some(_) => () }\n+            // will not: match Some(_) { &Some(_) => () }\n+            let ref_count_diff = ty_ref_count - pat_ref_count;\n+\n+            // Try to remove address of expressions first.\n+            let (ex, removed) = peel_n_hir_expr_refs(ex, ref_count_diff);\n+            let ref_count_diff = ref_count_diff - removed;\n+\n+            let msg = \"you seem to be trying to use `match` for an equality check. Consider using `if`\";\n+            let sugg = format!(\n+                \"if {} == {}{} {}{}\",\n+                snippet(cx, ex.span, \"..\"),\n+                // PartialEq for different reference counts may not exist.\n+                \"&\".repeat(ref_count_diff),\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        } else {\n+            let msg = \"you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\";\n+            let sugg = format!(\n+                \"if let {} = {} {}{}\",\n+                snippet(cx, arms[0].pat.span, \"..\"),\n+                snippet(cx, ex.span, \"..\"),\n+                expr_block(cx, arms[0].body, None, \"..\", Some(expr.span)),\n+                els_str,\n+            );\n+            (msg, sugg)\n+        }\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        lint,\n+        expr.span,\n+        msg,\n+        \"try this\",\n+        sugg,\n+        Applicability::HasPlaceholders,\n+    );\n+}\n+\n+fn check_opt_like<'a>(\n+    cx: &LateContext<'a>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    ty: Ty<'a>,\n+    els: Option<&Expr<'_>>,\n+) {\n+    // list of candidate `Enum`s we know will never get any more members\n+    let candidates = &[\n+        (&paths::COW, \"Borrowed\"),\n+        (&paths::COW, \"Cow::Borrowed\"),\n+        (&paths::COW, \"Cow::Owned\"),\n+        (&paths::COW, \"Owned\"),\n+        (&paths::OPTION, \"None\"),\n+        (&paths::RESULT, \"Err\"),\n+        (&paths::RESULT, \"Ok\"),\n+    ];\n+\n+    // We want to suggest to exclude an arm that contains only wildcards or forms the exhaustive\n+    // match with the second branch, without enum variants in matches.\n+    if !contains_only_wilds(arms[1].pat) && !form_exhaustive_matches(arms[0].pat, arms[1].pat) {\n+        return;\n+    }\n+\n+    let mut paths_and_types = Vec::new();\n+    if !collect_pat_paths(&mut paths_and_types, cx, arms[1].pat, ty) {\n+        return;\n+    }\n+\n+    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+        let (path, ty) = path_info;\n+        for &(ty_path, pat_path) in candidates {\n+            if path == pat_path && match_type(cx, ty, ty_path) {\n+                return true;\n+            }\n+        }\n+        false\n+    };\n+    if paths_and_types.iter().all(in_candidate_enum) {\n+        report_single_pattern(cx, ex, arms, expr, els);\n+    }\n+}\n+\n+/// Collects paths and their types from the given patterns. Returns true if the given pattern could\n+/// be simplified, false otherwise.\n+fn collect_pat_paths<'a>(acc: &mut Vec<(String, Ty<'a>)>, cx: &LateContext<'a>, pat: &Pat<'_>, ty: Ty<'a>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) => inner.iter().all(|p| {\n+            let p_ty = cx.typeck_results().pat_ty(p);\n+            collect_pat_paths(acc, cx, p, p_ty)\n+        }),\n+        PatKind::TupleStruct(ref path, ..) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        PatKind::Binding(BindingAnnotation::Unannotated, .., ident, None) => {\n+            acc.push((ident.to_string(), ty));\n+            true\n+        },\n+        PatKind::Path(ref path) => {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(path, false);\n+            });\n+            acc.push((path, ty));\n+            true\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given arm of pattern matching contains wildcard patterns.\n+fn contains_only_wilds(pat: &Pat<'_>) -> bool {\n+    match pat.kind {\n+        PatKind::Wild => true,\n+        PatKind::Tuple(inner, _) | PatKind::TupleStruct(_, inner, ..) => inner.iter().all(contains_only_wilds),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true if the given patterns forms only exhaustive matches that don't contain enum\n+/// patterns without a wildcard.\n+fn form_exhaustive_matches(left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    match (&left.kind, &right.kind) {\n+        (PatKind::Wild, _) | (_, PatKind::Wild) => true,\n+        (PatKind::Tuple(left_in, left_pos), PatKind::Tuple(right_in, right_pos)) => {\n+            // We don't actually know the position and the presence of the `..` (dotdot) operator\n+            // in the arms, so we need to evaluate the correct offsets here in order to iterate in\n+            // both arms at the same time.\n+            let len = max(\n+                left_in.len() + {\n+                    if left_pos.is_some() { 1 } else { 0 }\n+                },\n+                right_in.len() + {\n+                    if right_pos.is_some() { 1 } else { 0 }\n+                },\n+            );\n+            let mut left_pos = left_pos.unwrap_or(usize::MAX);\n+            let mut right_pos = right_pos.unwrap_or(usize::MAX);\n+            let mut left_dot_space = 0;\n+            let mut right_dot_space = 0;\n+            for i in 0..len {\n+                let mut found_dotdot = false;\n+                if i == left_pos {\n+                    left_dot_space += 1;\n+                    if left_dot_space < len - left_in.len() {\n+                        left_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if i == right_pos {\n+                    right_dot_space += 1;\n+                    if right_dot_space < len - right_in.len() {\n+                        right_pos += 1;\n+                    }\n+                    found_dotdot = true;\n+                }\n+                if found_dotdot {\n+                    continue;\n+                }\n+                if !contains_only_wilds(&left_in[i - left_dot_space])\n+                    && !contains_only_wilds(&right_in[i - right_dot_space])\n+                {\n+                    return false;\n+                }\n+            }\n+            true\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "459513e65bfad1b1aeb7e503a06e9c6949c6f0c3", "filename": "src/tools/clippy/clippy_lints/src/matches/wild_in_or_pats.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fwild_in_or_pats.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,24 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_wild;\n+use rustc_hir::{Arm, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::WILDCARD_IN_OR_PATTERNS;\n+\n+pub(crate) fn check(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n+    for arm in arms {\n+        if let PatKind::Or(fields) = arm.pat.kind {\n+            // look for multiple fields in this arm that contains at least one Wild pattern\n+            if fields.len() > 1 && fields.iter().any(is_wild) {\n+                span_lint_and_help(\n+                    cx,\n+                    WILDCARD_IN_OR_PATTERNS,\n+                    arm.pat.span,\n+                    \"wildcard pattern covers any other pattern as it will match anyway\",\n+                    None,\n+                    \"consider handling `_` separately\",\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "2cf2c5641bf10654e37c51cfb31171ce62bce223", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{method_chain_args, single_segment_path};\n+use clippy_utils::{method_chain_args, path_def_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_lint::Lint;\n-use rustc_middle::ty;\n-use rustc_span::sym;\n+use rustc_middle::ty::{self, DefIdTree};\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n pub(super) fn check(\n@@ -19,11 +18,9 @@ pub(super) fn check(\n ) -> bool {\n     if_chain! {\n         if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(fun, arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n+        if let hir::ExprKind::Call(fun, [arg_char]) = info.other.kind;\n+        if let Some(id) = path_def_id(cx, fun).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+        if Some(id) == cx.tcx.lang_items().option_some_variant();\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n@@ -42,7 +39,7 @@ pub(super) fn check(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                        snippet_with_applicability(cx, arg_char.span, \"..\", &mut applicability)),\n                 applicability,\n             );\n "}, {"sha": "a7c0e43923e139b3cc378b6f54aa19161d396f6e", "filename": "src/tools/clippy/clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                         if info.eq { \"\" } else { \"!\" },\n                         snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n                         suggest,\n-                        c),\n+                        c.escape_default()),\n                 applicability,\n             );\n "}, {"sha": "0fe510beaa07ee8640d48599b3025775744c8e84", "filename": "src/tools/clippy/clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_qpath_def_path;\n use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{match_def_path, path_def_id};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -93,12 +93,12 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) -> Option<M\n     let ty_str = ty.to_string();\n \n     // `std::T::MAX` `std::T::MIN` constants\n-    if let hir::ExprKind::Path(path) = &expr.kind {\n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MAX\"][..]) {\n+    if let Some(id) = path_def_id(cx, expr) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MAX\"]) {\n             return Some(MinMax::Max);\n         }\n \n-        if is_qpath_def_path(cx, path, expr.hir_id, &[\"core\", &ty_str, \"MIN\"][..]) {\n+        if match_def_path(cx, id, &[\"core\", &ty_str, \"MIN\"]) {\n             return Some(MinMax::Min);\n         }\n     }"}, {"sha": "c2202cb1e57709517787801ef261964e9ebd2de9", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -566,17 +566,20 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// Readability, this can be written more concisely as\n-    /// `_.flat_map(_)`\n+    /// `_.flat_map(_)` for `Iterator` or `_.and_then(_)` for `Option`\n     ///\n     /// ### Example\n     /// ```rust\n     /// let vec = vec![vec![1]];\n+    /// let opt = Some(5);\n     ///\n     /// // Bad\n     /// vec.iter().map(|x| x.iter()).flatten();\n+    /// opt.map(|x| Some(x * 2)).flatten();\n     ///\n     /// // Good\n     /// vec.iter().flat_map(|x| x.iter());\n+    /// opt.and_then(|x| Some(x * 2));\n     /// ```\n     #[clippy::version = \"1.31.0\"]\n     pub MAP_FLATTEN,\n@@ -2399,10 +2402,17 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n                 implicit_clone::check(cx, name, expr, recv);\n             },\n-            (\"unwrap\", []) => match method_call(recv) {\n-                Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),\n-                Some((\"get_mut\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, true),\n-                _ => unwrap_used::check(cx, expr, recv),\n+            (\"unwrap\", []) => {\n+                match method_call(recv) {\n+                    Some((\"get\", [recv, get_arg], _)) => {\n+                        get_unwrap::check(cx, expr, recv, get_arg, false);\n+                    },\n+                    Some((\"get_mut\", [recv, get_arg], _)) => {\n+                        get_unwrap::check(cx, expr, recv, get_arg, true);\n+                    },\n+                    _ => {},\n+                }\n+                unwrap_used::check(cx, expr, recv);\n             },\n             (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n                 Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {"}, {"sha": "bdf8cea120739f63b1092dc88cafc352cfb0f741", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, single_segment_path};\n+use clippy_utils::{is_lang_ctor, path_def_id};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n use super::OPTION_MAP_OR_NONE;\n@@ -76,13 +77,11 @@ pub(super) fn check<'tcx>(\n         if let hir::ExprKind::Closure(_, _, id, span, _) = map_arg.kind;\n             let arg_snippet = snippet(cx, span, \"..\");\n             let body = cx.tcx.hir().body(id);\n-                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n-                if arg_char.len() == 1;\n-                if let hir::ExprKind::Path(ref qpath) = func.kind;\n-                if let Some(segment) = single_segment_path(qpath);\n-                if segment.ident.name == sym::Some;\n+                if let Some((func, [arg_char])) = reduce_unit_expression(cx, &body.value);\n+                if let Some(id) = path_def_id(cx, func).and_then(|ctor_id| cx.tcx.parent(ctor_id));\n+                if Some(id) == cx.tcx.lang_items().option_some_variant();\n                 then {\n-                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let func_snippet = snippet(cx, arg_char.span, \"..\");\n                     let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `map(..)` instead\";\n                     return span_lint_and_sugg("}, {"sha": "6c641af59f92b9c6a3f1b6941c01305f8b8bd464", "filename": "src/tools/clippy/clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,4 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::differing_macro_contexts;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_copy;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -48,7 +47,7 @@ pub(super) fn check<'tcx>(\n             }\n         }\n \n-        if differing_macro_contexts(unwrap_arg.span, map_span) {\n+        if unwrap_arg.span.ctxt() != map_span.ctxt() {\n             return;\n         }\n "}, {"sha": "926c25b4b40a5c7aa2bd7c5003384ed5951fa857", "filename": "src/tools/clippy/clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -45,16 +45,16 @@ pub(super) fn check_manual_split_once(\n         IterUsageKind::Next | IterUsageKind::Second => {\n             let self_deref = {\n                 let adjust = cx.typeck_results().expr_adjustments(self_arg);\n-                if adjust.is_empty() {\n+                if adjust.len() < 2 {\n                     String::new()\n                 } else if cx.typeck_results().expr_ty(self_arg).is_box()\n                     || adjust\n                         .iter()\n                         .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n                 {\n-                    format!(\"&{}\", \"*\".repeat(adjust.len() - 1))\n+                    format!(\"&{}\", \"*\".repeat(adjust.len().saturating_sub(1)))\n                 } else {\n-                    \"*\".repeat(adjust.len() - 2)\n+                    \"*\".repeat(adjust.len().saturating_sub(2))\n                 }\n             };\n             if matches!(usage.kind, IterUsageKind::Next) {"}, {"sha": "12ad3d8d69038d3016ebf021f0fa7895603fa749", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -33,9 +33,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         } else if !found_mapping && !mutates_arg {\n             let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n             match cx.typeck_results().expr_ty(&body.value).kind() {\n-                ty::Adt(adt, subst)\n-                    if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && in_ty == subst.type_at(0) =>\n-                {\n+                ty::Adt(adt, subst) if cx.tcx.is_diagnostic_item(sym::Option, adt.did) && in_ty == subst.type_at(0) => {\n                     \"filter\"\n                 },\n                 _ => return,"}, {"sha": "ac82dd306a52879d1d96976dac46938d06abd974", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -20,8 +20,8 @@ use rustc_span::symbol::sym;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    expr_path_res, get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n-    last_path_segment, match_any_def_paths, paths, unsext, SpanlessEq,\n+    get_item_name, get_parent_expr, in_constant, is_diag_trait_item, is_integer_const, iter_input_pats,\n+    last_path_segment, match_any_def_paths, path_def_id, paths, unsext, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -583,8 +583,7 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left:\n             )\n         },\n         ExprKind::Call(path, [arg]) => {\n-            if expr_path_res(cx, path)\n-                .opt_def_id()\n+            if path_def_id(cx, path)\n                 .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n                 .is_some()\n             {"}, {"sha": "3d0a23822838e871c3c6ef5f891aa4303505b7d3", "filename": "src/tools/clippy/clippy_lints/src/missing_enforced_import_rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_enforced_import_rename.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -58,7 +58,7 @@ impl_lint_pass!(ImportRename => [MISSING_ENFORCED_IMPORT_RENAMES]);\n impl LateLintPass<'_> for ImportRename {\n     fn check_crate(&mut self, cx: &LateContext<'_>) {\n         for Rename { path, rename } in &self.conf_renames {\n-            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &path.split(\"::\").collect::<Vec<_>>()) {\n                 self.renames.insert(id, Symbol::intern(rename));\n             }\n         }"}, {"sha": "e0ce1b7db003afb96091e912a701d1e0ab2f7a84", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -3,9 +3,7 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n-use clippy_utils::{\n-    expr_path_res, get_expr_use_or_unification_node, is_lint_allowed, match_any_diagnostic_items, path_to_local, paths,\n-};\n+use clippy_utils::{get_expr_use_or_unification_node, is_lint_allowed, path_def_id, path_to_local, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n@@ -153,7 +151,9 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                 cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n                 sig.decl.inputs,\n                 &[],\n-            ) {\n+            )\n+            .filter(|arg| arg.mutability() == Mutability::Not)\n+            {\n                 span_lint_and_sugg(\n                     cx,\n                     PTR_ARG,\n@@ -170,10 +170,10 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n         let hir = cx.tcx.hir();\n         let mut parents = hir.parent_iter(body.value.hir_id);\n-        let (item_id, decl) = match parents.next() {\n+        let (item_id, decl, is_trait_item) = match parents.next() {\n             Some((_, Node::Item(i))) => {\n                 if let ItemKind::Fn(sig, ..) = &i.kind {\n-                    (i.def_id, sig.decl)\n+                    (i.def_id, sig.decl, false)\n                 } else {\n                     return;\n                 }\n@@ -185,14 +185,14 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return;\n                 }\n                 if let ImplItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl)\n+                    (i.def_id, sig.decl, false)\n                 } else {\n                     return;\n                 }\n             },\n             Some((_, Node::TraitItem(i))) => {\n                 if let TraitItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl)\n+                    (i.def_id, sig.decl, true)\n                 } else {\n                     return;\n                 }\n@@ -202,7 +202,9 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n \n         check_mut_from_ref(cx, decl);\n         let sig = cx.tcx.fn_sig(item_id).skip_binder();\n-        let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params).collect();\n+        let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params)\n+            .filter(|arg| !is_trait_item || arg.mutability() == Mutability::Not)\n+            .collect();\n         let results = check_ptr_arg_usage(cx, body, &lint_args);\n \n         for (result, args) in results.iter().zip(lint_args.iter()).filter(|(r, _)| !r.skip) {\n@@ -318,6 +320,10 @@ impl PtrArg<'_> {\n             self.deref_ty.argless_str(),\n         )\n     }\n+\n+    fn mutability(&self) -> Mutability {\n+        self.ref_prefix.mutability\n+    }\n }\n \n struct RefPrefix {\n@@ -641,7 +647,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                     },\n                     _ => {\n                         skip_count += 1;\n-                        results[arg.idx].skip = true;\n+                        results[i].skip = true;\n                         None\n                     },\n                 }\n@@ -665,8 +671,8 @@ fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutabil\n \n fn is_null_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(pathexp, []) = expr.kind {\n-        expr_path_res(cx, pathexp).opt_def_id().map_or(false, |id| {\n-            match_any_diagnostic_items(cx, id, &[sym::ptr_null, sym::ptr_null_mut]).is_some()\n+        path_def_id(cx, pathexp).map_or(false, |id| {\n+            matches!(cx.tcx.get_diagnostic_name(id), Some(sym::ptr_null | sym::ptr_null_mut))\n         })\n     } else {\n         false"}, {"sha": "be7610f365c5be716dc68aaf25de986b0a99f651", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -2,19 +2,18 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, single_segment_path};\n+use clippy_utils::{get_parent_expr, in_constant, is_integer_const, meets_msrv, msrvs, path_to_local};\n use clippy_utils::{higher, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, HirId, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::sym;\n-use rustc_span::symbol::Ident;\n use std::cmp::Ordering;\n \n declare_clippy_lint! {\n@@ -220,12 +219,12 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n         _ => return,\n     };\n     // value, name, order (higher/lower), inclusiveness\n-    if let (Some((lval, lname, name_span, lval_span, lord, linc)), Some((rval, rname, _, rval_span, rord, rinc))) =\n+    if let (Some((lval, lid, name_span, lval_span, lord, linc)), Some((rval, rid, _, rval_span, rord, rinc))) =\n         (check_range_bounds(cx, l), check_range_bounds(cx, r))\n     {\n         // we only lint comparisons on the same name and with different\n         // direction\n-        if lname != rname || lord == rord {\n+        if lid != rid || lord == rord {\n             return;\n         }\n         let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l), &lval, &rval);\n@@ -293,7 +292,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n     }\n }\n \n-fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, Ident, Span, Span, Ordering, bool)> {\n+fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant, HirId, Span, Span, Ordering, bool)> {\n     if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n@@ -302,11 +301,11 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n             BinOpKind::Le => (true, Ordering::Less),\n             _ => return None,\n         };\n-        if let Some(id) = match_ident(l) {\n+        if let Some(id) = path_to_local(l) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n                 return Some((c, id, l.span, r.span, ordering, inclusive));\n             }\n-        } else if let Some(id) = match_ident(r) {\n+        } else if let Some(id) = path_to_local(r) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n                 return Some((c, id, r.span, l.span, ordering.reverse(), inclusive));\n             }\n@@ -315,17 +314,6 @@ fn check_range_bounds(cx: &LateContext<'_>, ex: &Expr<'_>) -> Option<(Constant,\n     None\n }\n \n-fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n-    if let ExprKind::Path(ref qpath) = e.kind {\n-        if let Some(seg) = single_segment_path(qpath) {\n-            if seg.args.is_none() {\n-                return Some(seg.ident);\n-            }\n-        }\n-    }\n-    None\n-}\n-\n fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n     if_chain! {\n         if path.ident.as_str() == \"zip\";"}, {"sha": "1885f3ca414dfe9dbef2a600fc961cf4f6b9ebb5", "filename": "src/tools/clippy/clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fswap.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{can_mut_borrow_both, differing_macro_contexts, eq_expr_value, std_or_core};\n+use clippy_utils::{can_mut_borrow_both, eq_expr_value, std_or_core};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n@@ -172,7 +172,7 @@ fn check_suspicious_swap(cx: &LateContext<'_>, block: &Block<'_>) {\n         if_chain! {\n             if let StmtKind::Semi(first) = w[0].kind;\n             if let StmtKind::Semi(second) = w[1].kind;\n-            if !differing_macro_contexts(first.span, second.span);\n+            if first.span.ctxt() == second.span.ctxt();\n             if let ExprKind::Assign(lhs0, rhs0, _) = first.kind;\n             if let ExprKind::Assign(lhs1, rhs1, _) = second.kind;\n             if eq_expr_value(cx, lhs0, rhs1);"}, {"sha": "4c320deecc28b02b79a19f119be4e49cddb7a5f4", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -7,6 +7,7 @@ mod transmute_num_to_bytes;\n mod transmute_ptr_to_ptr;\n mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n+mod transmute_undefined_repr;\n mod transmutes_expressible_as_ptr_casts;\n mod unsound_collection_transmute;\n mod useless_transmute;\n@@ -355,6 +356,30 @@ declare_clippy_lint! {\n     \"transmute between collections of layout-incompatible types\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmutes either to or from a type which does not have a defined representation.\n+    ///\n+    /// ### Why is this bad?\n+    /// The results of such a transmute are not defined.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub TRANSMUTE_UNDEFINED_REPR,\n+    correctness,\n+    \"transmute to or from a type with an undefined representation\"\n+}\n+\n declare_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n@@ -369,13 +394,13 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_NUM_TO_BYTES,\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    TRANSMUTE_UNDEFINED_REPR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Transmute {\n-    #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Call(path_expr, args) = e.kind;\n+            if let ExprKind::Call(path_expr, [arg]) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(qpath, path_expr.hir_id).opt_def_id();\n             if cx.tcx.is_diagnostic_item(sym::transmute, def_id);\n@@ -385,28 +410,31 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n                 let const_context = in_constant(cx, e.hir_id);\n \n-                let from_ty = cx.typeck_results().expr_ty(&args[0]);\n+                let from_ty = cx.typeck_results().expr_ty(arg);\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n                 // If useless_transmute is triggered, the other lints can be skipped.\n-                if useless_transmute::check(cx, e, from_ty, to_ty, args) {\n+                if useless_transmute::check(cx, e, from_ty, to_ty, arg) {\n                     return;\n                 }\n \n-                let mut linted = wrong_transmute::check(cx, e, from_ty, to_ty);\n-                linted |= crosspointer_transmute::check(cx, e, from_ty, to_ty);\n-                linted |= transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, args, qpath);\n-                linted |= transmute_int_to_char::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_ref_to_ref::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_int_to_bool::check(cx, e, from_ty, to_ty, args);\n-                linted |= transmute_int_to_float::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_float_to_int::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= transmute_num_to_bytes::check(cx, e, from_ty, to_ty, args, const_context);\n-                linted |= unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n+                let linted = wrong_transmute::check(cx, e, from_ty, to_ty)\n+                    | crosspointer_transmute::check(cx, e, from_ty, to_ty)\n+                    | transmute_ptr_to_ref::check(cx, e, from_ty, to_ty, arg, qpath)\n+                    | transmute_int_to_char::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_ref_to_ref::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_ptr_to_ptr::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_int_to_bool::check(cx, e, from_ty, to_ty, arg)\n+                    | transmute_int_to_float::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_float_to_int::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | transmute_num_to_bytes::check(cx, e, from_ty, to_ty, arg, const_context)\n+                    | (\n+                        unsound_collection_transmute::check(cx, e, from_ty, to_ty)\n+                        || transmute_undefined_repr::check(cx, e, from_ty, to_ty)\n+                    );\n \n                 if !linted {\n-                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, args);\n+                    transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, arg);\n                 }\n             }\n         }"}, {"sha": "d5ef86dc4e572703af49941486832c5c9bea462e", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    mut arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -26,37 +26,36 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let mut expr = &args[0];\n-                    let mut arg = sugg::Sugg::hir(cx, expr, \"..\");\n+                    let mut sugg = sugg::Sugg::hir(cx, arg, \"..\");\n \n-                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &expr.kind {\n-                        expr = inner_expr;\n+                    if let ExprKind::Unary(UnOp::Neg, inner_expr) = &arg.kind {\n+                        arg = inner_expr;\n                     }\n \n                     if_chain! {\n                         // if the expression is a float literal and it is unsuffixed then\n                         // add a suffix so the suggestion is valid and unambiguous\n-                        if let ExprKind::Lit(lit) = &expr.kind;\n+                        if let ExprKind::Lit(lit) = &arg.kind;\n                         if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n                         then {\n-                            let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n-                            match arg {\n-                                sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n-                                _ => arg = sugg::Sugg::NonParen(op)\n+                            let op = format!(\"{}{}\", sugg, float_ty.name_str()).into();\n+                            match sugg {\n+                                sugg::Sugg::MaybeParen(_) => sugg = sugg::Sugg::MaybeParen(op),\n+                                _ => sugg = sugg::Sugg::NonParen(op)\n                             }\n                         }\n                     }\n \n-                    arg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", arg.maybe_par()).into());\n+                    sugg = sugg::Sugg::NonParen(format!(\"{}.to_bits()\", sugg.maybe_par()).into());\n \n                     // cast the result of `to_bits` if `to_ty` is signed\n-                    arg = if let ty::Int(int_ty) = to_ty.kind() {\n-                        arg.as_ty(int_ty.name_str().to_string())\n+                    sugg = if let ty::Int(int_ty) = to_ty.kind() {\n+                        sugg.as_ty(int_ty.name_str().to_string())\n                     } else {\n-                        arg\n+                        sugg\n                     };\n \n-                    diag.span_suggestion(e.span, \"consider using\", arg.to_string(), Applicability::Unspecified);\n+                    diag.span_suggestion(e.span, \"consider using\", sugg.to_string(), Applicability::Unspecified);\n                 },\n             );\n             true"}, {"sha": "8c50b58ca4b862af20360774f2a4654df4fa1085", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_bool.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Int(ty::IntTy::I8) | ty::Uint(ty::UintTy::U8), ty::Bool) => {\n@@ -25,7 +25,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `bool`\", from_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let zero = sugg::Sugg::NonParen(Cow::from(\"0\"));\n                     diag.span_suggestion(\n                         e.span,"}, {"sha": "3eb07b68992a89b96ff10c4a40277023c8878536", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_char.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Int(ty::IntTy::I32) | ty::Uint(ty::UintTy::U32), &ty::Char) => {\n@@ -24,7 +24,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `char`\", from_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(_) = from_ty.kind() {\n                         arg.as_ty(ast::UintTy::U32.name_str())\n                     } else {"}, {"sha": "b8703052e6c869750a09751579885123c0e1143a", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_int_to_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_int_to_float.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -24,7 +24,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let arg = if let ty::Int(int_ty) = from_ty.kind() {\n                         arg.as_ty(format!(\n                             \"u{}\","}, {"sha": "52d193d11e1a08dab87adca2de3548d904b3d16f", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_num_to_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_num_to_bytes.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -33,7 +33,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 &format!(\"transmute from a `{}` to a `{}`\", from_ty, to_ty),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     diag.span_suggestion(\n                         e.span,\n                         \"consider using `to_ne_bytes()`\","}, {"sha": "d712b33de9e1a49ead17804603354e5d09055bcd", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ptr.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::RawPtr(_), ty::RawPtr(to_ty)) => {\n@@ -23,7 +23,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from a pointer to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let sugg = arg.as_ty(cx.tcx.mk_ptr(*to_ty));\n                         diag.span_suggestion(e.span, \"try\", sugg.to_string(), Applicability::Unspecified);\n                     }"}, {"sha": "5699f8e92cfca82428614d957a7075a249f6e071", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     qpath: &'tcx QPath<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n@@ -28,7 +28,7 @@ pub(super) fn check<'tcx>(\n                     from_ty, to_ty\n                 ),\n                 |diag| {\n-                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                    let arg = sugg::Sugg::hir(cx, arg, \"..\");\n                     let (deref, cast) = if *mutbl == Mutability::Mut {\n                         (\"&mut *\", \"*mut\")\n                     } else {"}, {"sha": "fdef8bac7f9b093faf73679e13d3c319596b69c9", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -15,7 +15,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n     const_context: bool,\n ) -> bool {\n     let mut triggered = false;\n@@ -41,7 +41,7 @@ pub(super) fn check<'tcx>(\n                     format!(\n                         \"std::str::from_utf8{}({}).unwrap()\",\n                         postfix,\n-                        snippet(cx, args[0].span, \"..\"),\n+                        snippet(cx, arg.span, \"..\"),\n                     ),\n                     Applicability::Unspecified,\n                 );\n@@ -54,7 +54,7 @@ pub(super) fn check<'tcx>(\n                         TRANSMUTE_PTR_TO_PTR,\n                         e.span,\n                         \"transmute from a reference to a reference\",\n-                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                        |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                             let ty_from_and_mut = ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: *from_mutbl"}, {"sha": "030d2c23784886c7c7ebd11513970af7a2d226b9", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,293 @@\n+use super::TRANSMUTE_UNDEFINED_REPR;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n+use rustc_middle::ty::{self, Ty, TypeAndMut};\n+use rustc_span::Span;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty_orig: Ty<'tcx>,\n+    to_ty_orig: Ty<'tcx>,\n+) -> bool {\n+    let mut from_ty = cx.tcx.erase_regions(from_ty_orig);\n+    let mut to_ty = cx.tcx.erase_regions(to_ty_orig);\n+\n+    while from_ty != to_ty {\n+        match reduce_refs(cx, e.span, from_ty, to_ty) {\n+            ReducedTys::FromFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if from_ty_orig.peel_refs() != unsized_ty {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if to_ty_orig.peel_refs() != unsized_ty {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, from_sub_ty) {\n+                ReducedTy::UnorderedFields(from_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if from_ty_orig.peel_refs() != from_ty {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(from_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::FromPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, to_sub_ty) {\n+                ReducedTy::UnorderedFields(to_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if to_ty_orig.peel_refs() != to_ty {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(to_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::Other {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n+                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n+                            from_ty_orig, to_ty_orig\n+                        ),\n+                        |diag| {\n+                            if_chain! {\n+                                if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def());\n+                                if from_def == to_def;\n+                                then {\n+                                    diag.note(&format!(\n+                                        \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                        cx.tcx.item_name(from_def.did)\n+                                    ));\n+                                } else {\n+                                    if from_ty_orig.peel_refs() != from_ty {\n+                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                    }\n+                                    if to_ty_orig.peel_refs() != to_ty {\n+                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                                    }\n+                                }\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::UnorderedFields(from_ty),\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if from_ty_orig.peel_refs() != from_ty {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                    ReducedTy::UnorderedFields(to_ty),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if to_ty_orig.peel_refs() != to_ty {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (ReducedTy::Ref(from_sub_ty), ReducedTy::Ref(to_sub_ty)) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                (\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                )\n+                | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => break,\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+enum ReducedTys<'tcx> {\n+    FromFatPtr { unsized_ty: Ty<'tcx> },\n+    ToFatPtr { unsized_ty: Ty<'tcx> },\n+    ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+}\n+\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n+    loop {\n+        return match (from_ty.kind(), to_ty.kind()) {\n+            (\n+                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n+                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+            ) => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n+            },\n+            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::FromFatPtr { unsized_ty }\n+            },\n+            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::ToFatPtr { unsized_ty }\n+            },\n+            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+                ReducedTys::FromPtr { from_ty, to_ty }\n+            },\n+            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+                ReducedTys::ToPtr { from_ty, to_ty }\n+            },\n+            _ => ReducedTys::Other { from_ty, to_ty },\n+        };\n+    }\n+}\n+\n+enum ReducedTy<'tcx> {\n+    OrderedFields(Ty<'tcx>),\n+    UnorderedFields(Ty<'tcx>),\n+    Ref(Ty<'tcx>),\n+    Other(Ty<'tcx>),\n+    IntArray,\n+}\n+\n+fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx> {\n+    loop {\n+        ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n+        return match *ty.kind() {\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::IntArray,\n+            ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n+                ty = sub_ty;\n+                continue;\n+            },\n+            ty::Tuple(args) => {\n+                let mut iter = args.iter().map(GenericArg::expect_ty);\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Adt(def, substs) if def.is_struct() => {\n+                if def.repr.inhibit_struct_field_reordering_opt() {\n+                    return ReducedTy::OrderedFields(ty);\n+                }\n+                let mut iter = def\n+                    .non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Ref(..) | ty::RawPtr(_) => ReducedTy::Ref(ty),\n+            _ => ReducedTy::Other(ty),\n+        };\n+    }\n+}\n+\n+fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    if_chain! {\n+        if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty);\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        then {\n+            layout.layout.size.bytes() == 0\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "626d7cd46fc43c1383717d3b670780df06bc6201", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmutes_expressible_as_ptr_casts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmutes_expressible_as_ptr_casts.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) {\n         span_lint_and_then(\n@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n                 from_ty, to_ty\n             ),\n             |diag| {\n-                if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                     let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n                     diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n                 }"}, {"sha": "2d67401a15f2d65b96cacdbaa0f92e69c6ae7fce", "filename": "src/tools/clippy/clippy_lints/src/transmute/unsound_collection_transmute.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Funsound_collection_transmute.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,29 +1,31 @@\n use super::utils::is_layout_incompatible;\n use super::UNSOUND_COLLECTION_TRANSMUTE;\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::match_any_diagnostic_items;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::symbol::{sym, Symbol};\n-\n-// used to check for UNSOUND_COLLECTION_TRANSMUTE\n-static COLLECTIONS: &[Symbol] = &[\n-    sym::Vec,\n-    sym::VecDeque,\n-    sym::BinaryHeap,\n-    sym::BTreeSet,\n-    sym::BTreeMap,\n-    sym::HashSet,\n-    sym::HashMap,\n-];\n+use rustc_span::symbol::sym;\n \n /// Checks for `unsound_collection_transmute` lint.\n /// Returns `true` if it's triggered, otherwise returns `false`.\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         (ty::Adt(from_adt, from_substs), ty::Adt(to_adt, to_substs)) => {\n-            if from_adt.did != to_adt.did || match_any_diagnostic_items(cx, to_adt.did, COLLECTIONS).is_none() {\n+            if from_adt.did != to_adt.did {\n+                return false;\n+            }\n+            if !matches!(\n+                cx.tcx.get_diagnostic_name(to_adt.did),\n+                Some(\n+                    sym::BTreeMap\n+                        | sym::BTreeSet\n+                        | sym::BinaryHeap\n+                        | sym::HashMap\n+                        | sym::HashSet\n+                        | sym::Vec\n+                        | sym::VecDeque\n+                )\n+            ) {\n                 return false;\n             }\n             if from_substs"}, {"sha": "998f97eb5d8c65990e2f7348a256a16c6b8072ec", "filename": "src/tools/clippy/clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check<'tcx>(\n     e: &'tcx Expr<'_>,\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n-    args: &'tcx [Expr<'_>],\n+    arg: &'tcx Expr<'_>,\n ) -> bool {\n     match (&from_ty.kind(), &to_ty.kind()) {\n         _ if from_ty == to_ty => {\n@@ -32,7 +32,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from a reference to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let rty_and_mut = ty::TypeAndMut {\n                             ty: rty,\n                             mutbl: *rty_mutbl,\n@@ -57,7 +57,7 @@ pub(super) fn check<'tcx>(\n                 e.span,\n                 \"transmute from an integer to a pointer\",\n                 |diag| {\n-                    if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                    if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         diag.span_suggestion(\n                             e.span,\n                             \"try\","}, {"sha": "21a9558ec076a54e938fadc06f56fb6f9fa5ee34", "filename": "src/tools/clippy/clippy_lints/src/types/box_collection.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fbox_collection.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use super::BOX_COLLECTION;\n \n@@ -11,10 +11,9 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         if Some(def_id) == cx.tcx.lang_items().owned_box();\n         if let Some(item_type) = get_std_collection(cx, qpath);\n         then {\n-            let generic = if item_type == \"String\" {\n-                \"\"\n-            } else {\n-                \"<..>\"\n+            let generic = match item_type {\n+                sym::String => \"\",\n+                _ => \"<..>\",\n             };\n             span_lint_and_help(\n                 cx,\n@@ -37,14 +36,10 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n     }\n }\n \n-fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::Vec).is_some() {\n-        Some(\"Vec\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::String).is_some() {\n-        Some(\"String\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::HashMap).is_some() {\n-        Some(\"HashMap\")\n-    } else {\n-        None\n-    }\n+fn get_std_collection(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Symbol> {\n+    let param = qpath_generic_tys(qpath).next()?;\n+    let id = path_def_id(cx, param)?;\n+    cx.tcx\n+        .get_diagnostic_name(id)\n+        .filter(|&name| matches!(name, sym::HashMap | sym::String | sym::Vec))\n }"}, {"sha": "8767e3c30a68ac4564ba72814b48f53719090be3", "filename": "src/tools/clippy/clippy_lints/src/types/option_option.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Foption_option.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,22 +1,28 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n+use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n use super::OPTION_OPTION;\n \n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n-    if cx.tcx.is_diagnostic_item(sym::Option, def_id) && is_ty_param_diagnostic_item(cx, qpath, sym::Option).is_some() {\n-        span_lint(\n-            cx,\n-            OPTION_OPTION,\n-            hir_ty.span,\n-            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                                 enum if you need to distinguish all 3 cases\",\n-        );\n-        true\n-    } else {\n-        false\n+    if_chain! {\n+        if cx.tcx.is_diagnostic_item(sym::Option, def_id);\n+        if let Some(arg) = qpath_generic_tys(qpath).next();\n+        if path_def_id(cx, arg) == Some(def_id);\n+        then {\n+            span_lint(\n+                cx,\n+                OPTION_OPTION,\n+                hir_ty.span,\n+                \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                                     enum if you need to distinguish all 3 cases\",\n+            );\n+            true\n+        } else {\n+            false\n+        }\n     }\n }"}, {"sha": "4d72a29e8c74722711aeb3b6a754e3d0c2bd4765", "filename": "src/tools/clippy/clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_qpath_generic_tys, is_ty_param_diagnostic_item};\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_errors::Applicability;\n use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n use rustc_lint::LateContext;\n@@ -20,12 +20,17 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 format!(\"Rc<{}>\", alternate),\n                 Applicability::MachineApplicable,\n             );\n-        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Vec) {\n+        } else {\n+            let Some(ty) = qpath_generic_tys(qpath).next() else { return false };\n+            let Some(id) = path_def_id(cx, ty) else { return false };\n+            if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n+                return false;\n+            }\n             let qpath = match &ty.kind {\n                 TyKind::Path(qpath) => qpath,\n                 _ => return false,\n             };\n-            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+            let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n@@ -55,12 +60,16 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 format!(\"Arc<{}>\", alternate),\n                 Applicability::MachineApplicable,\n             );\n-        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Vec) {\n+        } else if let Some(ty) = qpath_generic_tys(qpath).next() {\n+            let Some(id) = path_def_id(cx, ty) else { return false };\n+            if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n+                return false;\n+            }\n             let qpath = match &ty.kind {\n                 TyKind::Path(qpath) => qpath,\n                 _ => return false,\n             };\n-            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+            let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n@@ -85,13 +94,13 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n }\n \n fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::String).is_some() {\n-        Some(\"str\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n-        Some(\"std::ffi::OsStr\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n-        Some(\"std::path::Path\")\n-    } else {\n-        None\n-    }\n+    let ty = qpath_generic_tys(qpath).next()?;\n+    let id = path_def_id(cx, ty)?;\n+    let path = match cx.tcx.get_diagnostic_name(id)? {\n+        sym::String => \"str\",\n+        sym::OsString => \"std::ffi::OsStr\",\n+        sym::PathBuf => \"std::path::Path\",\n+        _ => return None,\n+    };\n+    Some(path)\n }"}, {"sha": "a75972cf3ddbe1e2d91acbf11fc541577c7ed7e5", "filename": "src/tools/clippy/clippy_lints/src/types/rc_mutex.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Frc_mutex.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_ty_param_diagnostic_item;\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use if_chain::if_chain;\n use rustc_hir::{self as hir, def_id::DefId, QPath};\n use rustc_lint::LateContext;\n@@ -10,7 +10,9 @@ use super::RC_MUTEX;\n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n     if_chain! {\n         if cx.tcx.is_diagnostic_item(sym::Rc, def_id) ;\n-        if let Some(_) = is_ty_param_diagnostic_item(cx, qpath, sym::Mutex) ;\n+        if let Some(arg) = qpath_generic_tys(qpath).next();\n+        if let Some(id) = path_def_id(cx, arg);\n+        if cx.tcx.is_diagnostic_item(sym::Mutex, id);\n         then {\n             span_lint_and_help(\n                 cx,"}, {"sha": "10d2ae2eb1dbb8808eb0fa601d0fc1ffad349dfb", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::{get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item};\n+use clippy_utils::{path_def_id, qpath_generic_tys};\n use rustc_errors::Applicability;\n-use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n+use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -39,21 +39,20 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         return true;\n     }\n \n-    let (inner_sym, ty) = if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n-        (\"Box\", ty)\n-    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n-        (\"Rc\", ty)\n-    } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Arc) {\n-        (\"Arc\", ty)\n-    } else {\n-        return false;\n+    let Some(ty) = qpath_generic_tys(qpath).next() else { return false };\n+    let Some(id) = path_def_id(cx, ty) else { return false };\n+    let (inner_sym, ty) = match cx.tcx.get_diagnostic_name(id) {\n+        Some(sym::Arc) => (\"Arc\", ty),\n+        Some(sym::Rc) => (\"Rc\", ty),\n+        _ if Some(id) == cx.tcx.lang_items().owned_box() => (\"Box\", ty),\n+        _ => return false,\n     };\n \n     let inner_qpath = match &ty.kind {\n         TyKind::Path(inner_qpath) => inner_qpath,\n         _ => return false,\n     };\n-    let inner_span = match get_qpath_generic_tys(inner_qpath).next() {\n+    let inner_span = match qpath_generic_tys(inner_qpath).next() {\n         Some(ty) => {\n             // Box<Box<dyn T>> is smaller than Box<dyn T> because of wide pointers\n             if matches!(ty.kind, TyKind::TraitObject(..)) {"}, {"sha": "9b9e25326f9663b11e84984b0acb71e59ffc1cfa", "filename": "src/tools/clippy/clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, path_to_local, usage::is_potentially_mutated};\n+use clippy_utils::{path_to_local, usage::is_potentially_mutated};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, Visitor};\n@@ -238,8 +238,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.local_id == id);\n                 // Span contexts should not differ with the conditional branch\n-                if !differing_macro_contexts(unwrappable.branch.span, expr.span);\n-                if !differing_macro_contexts(unwrappable.branch.span, unwrappable.check.span);\n+                let span_ctxt = expr.span.ctxt();\n+                if unwrappable.branch.span.ctxt() == span_ctxt;\n+                if unwrappable.check.span.ctxt() == span_ctxt;\n                 then {\n                     if call_to_unwrap == unwrappable.safe_to_unwrap {\n                         let is_entire_condition = unwrappable.is_entire_condition;"}, {"sha": "680b2eb1da723d7696878d7d9f1ed2d27f69ebc7", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -322,18 +322,36 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n     let mut current = env::var_os(\"CLIPPY_CONF_DIR\")\n         .or_else(|| env::var_os(\"CARGO_MANIFEST_DIR\"))\n         .map_or_else(|| PathBuf::from(\".\"), PathBuf::from);\n+\n+    let mut found_config: Option<PathBuf> = None;\n+\n     loop {\n         for config_file_name in &CONFIG_FILE_NAMES {\n             if let Ok(config_file) = current.join(config_file_name).canonicalize() {\n                 match fs::metadata(&config_file) {\n                     Err(e) if e.kind() == io::ErrorKind::NotFound => {},\n                     Err(e) => return Err(e),\n                     Ok(md) if md.is_dir() => {},\n-                    Ok(_) => return Ok(Some(config_file)),\n+                    Ok(_) => {\n+                        // warn if we happen to find two config files #8323\n+                        if let Some(ref found_config_) = found_config {\n+                            eprintln!(\n+                                \"Using config file `{}`\\nWarning: `{}` will be ignored.\",\n+                                found_config_.display(),\n+                                config_file.display(),\n+                            );\n+                        } else {\n+                            found_config = Some(config_file);\n+                        }\n+                    },\n                 }\n             }\n         }\n \n+        if found_config.is_some() {\n+            return Ok(found_config);\n+        }\n+\n         // If the current directory has no parent, we're done searching.\n         if !current.pop() {\n             return Ok(None);"}, {"sha": "dc0f515bfe5cb1d97e075396e242722eeab43502", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -4,8 +4,8 @@ use clippy_utils::macros::root_macro_call_first_node;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls,\n-    path_to_res, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n+    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -844,7 +844,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n             // Extract the path to the matched type\n             if let Some(segments) = path_to_matched_type(cx, ty_path);\n             let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = path_to_res(cx, &segments[..]).opt_def_id();\n+            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n             // Check if the matched type is a diagnostic item\n             if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n             then {\n@@ -917,7 +917,7 @@ fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Ve\n // This is not a complete resolver for paths. It works on all the paths currently used in the paths\n // module.  That's all it does and all it needs to do.\n pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if path_to_res(cx, path) != Res::Err {\n+    if def_path_res(cx, path) != Res::Err {\n         return true;\n     }\n \n@@ -999,7 +999,7 @@ impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n         }\n \n         for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = path_to_res(cx, module).opt_def_id() {\n+            if let Some(def_id) = def_path_res(cx, module).opt_def_id() {\n                 for item in cx.tcx.module_children(def_id).iter() {\n                     if_chain! {\n                         if let Res::Def(DefKind::Const, item_def_id) = item.res;"}, {"sha": "56633490eaa1a7d51d1c4744eaba273226ccaa09", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -612,8 +612,8 @@ fn get_lint_group_and_level_or_lint(\n }\n \n fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n-    for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n-        if IGNORED_LINT_GROUPS.contains(group_name) {\n+    for (group_name, lints, _) in cx.lint_store.get_lint_groups() {\n+        if IGNORED_LINT_GROUPS.contains(&group_name) {\n             continue;\n         }\n "}, {"sha": "3f604d5166bf7d7dcf8f41ba0b9b39aeb996ebd8", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -331,17 +331,16 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     let def_path: Vec<&str> = def_path.iter().take(4).map(Symbol::as_str).collect();\n                     if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n                     then {\n-                       let value = match int_impl {\n-                           \"<impl i8>\" => i8::MAX as u128,\n-                           \"<impl i16>\" => i16::MAX as u128,\n-                           \"<impl i32>\" => i32::MAX as u128,\n-                           \"<impl i64>\" => i64::MAX as u128,\n-                           \"<impl i128>\" => i128::MAX as u128,\n-                           _ => return None,\n-                       };\n-                       Some(Constant::Int(value))\n-                    }\n-                    else {\n+                        let value = match int_impl {\n+                            \"<impl i8>\" => i8::MAX as u128,\n+                            \"<impl i16>\" => i16::MAX as u128,\n+                            \"<impl i32>\" => i32::MAX as u128,\n+                            \"<impl i64>\" => i64::MAX as u128,\n+                            \"<impl i128>\" => i128::MAX as u128,\n+                            _ => return None,\n+                        };\n+                        Some(Constant::Int(value))\n+                    } else {\n                         None\n                     }\n                 }"}, {"sha": "2095fc966c5dc7535f3be122d08bef255130de57", "filename": "src/tools/clippy/clippy_utils/src/higher.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhigher.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -284,8 +284,7 @@ impl<'a> VecArgs<'a> {\n                 return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n                     // `vec![elem; size]` case\n                     Some(VecArgs::Repeat(&args[0], &args[1]))\n-                }\n-                else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+                } else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n                     // `vec![a, b, c]` case\n                     if_chain! {\n                         if let hir::ExprKind::Box(boxed) = args[0].kind;\n@@ -296,11 +295,9 @@ impl<'a> VecArgs<'a> {\n                     }\n \n                     None\n-                }\n-                else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n+                } else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n                     Some(VecArgs::Vec(&[]))\n-                }\n-                else {\n+                } else {\n                     None\n                 };\n             }\n@@ -456,7 +453,7 @@ pub fn get_vec_init_kind<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -\n                         if let ExprKind::Lit(lit) = &arg.kind;\n                         if let LitKind::Int(num, _) = lit.node;\n                         then {\n-                            return Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?))\n+                            return Some(VecInitKind::WithLiteralCapacity(num.try_into().ok()?));\n                         }\n                     }\n                     return Some(VecInitKind::WithExprCapacity(arg.hir_id));"}, {"sha": "9654895060f85bde17984d509fb4fc2f0906adf4", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,4 @@\n use crate::consts::{constant_context, constant_simple};\n-use crate::differing_macro_contexts;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n@@ -186,7 +185,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n \n     #[allow(clippy::similar_names)]\n     pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n+        if !self.inner.allow_side_effects && left.span.ctxt() != right.span.ctxt() {\n             return false;\n         }\n "}, {"sha": "42955080c966e10d37ca00c6feb89009b2797c19", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 63, "deletions": 121, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -77,9 +77,9 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n     def, lang_items, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n-    ExprKind, FnDecl, ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem,\n-    Local, MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n-    Target, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n+    ExprKind, FnDecl, ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, Target,\n+    TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n@@ -134,13 +134,6 @@ macro_rules! extract_msrv_attr {\n     };\n }\n \n-/// Returns `true` if the two spans come from differing expansions (i.e., one is\n-/// from a macro and one isn't).\n-#[must_use]\n-pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n-    rhs.ctxt() != lhs.ctxt()\n-}\n-\n /// If the given expression is a local binding, find the initializer expression.\n /// If that initializer expression is another local binding, find its initializer again.\n /// This process repeats as long as possible (but usually no more than once). Initializer\n@@ -262,44 +255,6 @@ pub fn is_wild(pat: &Pat<'_>) -> bool {\n     matches!(pat.kind, PatKind::Wild)\n }\n \n-/// Checks if the first type parameter is a lang item.\n-pub fn is_ty_param_lang_item<'tcx>(\n-    cx: &LateContext<'_>,\n-    qpath: &QPath<'tcx>,\n-    item: LangItem,\n-) -> Option<&'tcx hir::Ty<'tcx>> {\n-    let ty = get_qpath_generic_tys(qpath).next()?;\n-\n-    if let TyKind::Path(qpath) = &ty.kind {\n-        cx.qpath_res(qpath, ty.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |id| {\n-                cx.tcx.lang_items().require(item).map_or(false, |lang_id| id == lang_id)\n-            })\n-            .then(|| ty)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Checks if the first type parameter is a diagnostic item.\n-pub fn is_ty_param_diagnostic_item<'tcx>(\n-    cx: &LateContext<'_>,\n-    qpath: &QPath<'tcx>,\n-    item: Symbol,\n-) -> Option<&'tcx hir::Ty<'tcx>> {\n-    let ty = get_qpath_generic_tys(qpath).next()?;\n-\n-    if let TyKind::Path(qpath) = &ty.kind {\n-        cx.qpath_res(qpath, ty.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |id| cx.tcx.is_diagnostic_item(item, id))\n-            .then(|| ty)\n-    } else {\n-        None\n-    }\n-}\n-\n /// Checks if the method call given in `expr` belongs to the given trait.\n /// This is a deprecated function, consider using [`is_trait_method`].\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n@@ -360,35 +315,17 @@ pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     }\n }\n \n-pub fn get_qpath_generics<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx GenericArgs<'tcx>> {\n-    match path {\n-        QPath::Resolved(_, p) => p.segments.last().and_then(|s| s.args),\n-        QPath::TypeRelative(_, s) => s.args,\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n-pub fn get_qpath_generic_tys<'tcx>(path: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n-    get_qpath_generics(path)\n-        .map_or([].as_ref(), |a| a.args)\n+pub fn qpath_generic_tys<'tcx>(qpath: &QPath<'tcx>) -> impl Iterator<Item = &'tcx hir::Ty<'tcx>> {\n+    last_path_segment(qpath)\n+        .args\n+        .map_or(&[][..], |a| a.args)\n         .iter()\n-        .filter_map(|a| {\n-            if let hir::GenericArg::Type(ty) = a {\n-                Some(ty)\n-            } else {\n-                None\n-            }\n+        .filter_map(|a| match a {\n+            hir::GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n         })\n }\n \n-pub fn single_segment_path<'tcx>(path: &QPath<'tcx>) -> Option<&'tcx PathSegment<'tcx>> {\n-    match *path {\n-        QPath::Resolved(_, path) => path.segments.get(0),\n-        QPath::TypeRelative(_, seg) => Some(seg),\n-        QPath::LangItem(..) => None,\n-    }\n-}\n-\n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n /// entire path or resolved `DefId`. Prefer using `match_def_path`. Consider getting a `DefId` from\n /// `QPath::Resolved.1.res.opt_def_id()`.\n@@ -420,37 +357,17 @@ pub fn match_qpath(path: &QPath<'_>, segments: &[&str]) -> bool {\n     }\n }\n \n-/// If the expression is a path, resolve it. Otherwise, return `Res::Err`.\n-pub fn expr_path_res(cx: &LateContext<'_>, expr: &Expr<'_>) -> Res {\n-    if let ExprKind::Path(p) = &expr.kind {\n-        cx.qpath_res(p, expr.hir_id)\n-    } else {\n-        Res::Err\n-    }\n-}\n-\n-/// Resolves the path to a `DefId` and checks if it matches the given path.\n-pub fn is_qpath_def_path(cx: &LateContext<'_>, path: &QPath<'_>, hir_id: HirId, segments: &[&str]) -> bool {\n-    cx.qpath_res(path, hir_id)\n-        .opt_def_id()\n-        .map_or(false, |id| match_def_path(cx, id, segments))\n-}\n-\n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given path.\n ///\n /// Please use `is_expr_diagnostic_item` if the target is a diagnostic item.\n pub fn is_expr_path_def_path(cx: &LateContext<'_>, expr: &Expr<'_>, segments: &[&str]) -> bool {\n-    expr_path_res(cx, expr)\n-        .opt_def_id()\n-        .map_or(false, |id| match_def_path(cx, id, segments))\n+    path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, segments))\n }\n \n /// If the expression is a path, resolves it to a `DefId` and checks if it matches the given\n /// diagnostic item.\n pub fn is_expr_diagnostic_item(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol) -> bool {\n-    expr_path_res(cx, expr)\n-        .opt_def_id()\n-        .map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n+    path_def_id(cx, expr).map_or(false, |id| cx.tcx.is_diagnostic_item(diag_item, id))\n }\n \n /// THIS METHOD IS DEPRECATED and will eventually be removed since it does not match against the\n@@ -497,8 +414,46 @@ pub fn path_to_local_id(expr: &Expr<'_>, id: HirId) -> bool {\n     path_to_local(expr) == Some(id)\n }\n \n-/// Gets the definition associated to a path.\n-pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n+pub trait MaybePath<'hir> {\n+    fn hir_id(&self) -> HirId;\n+    fn qpath_opt(&self) -> Option<&QPath<'hir>>;\n+}\n+\n+macro_rules! maybe_path {\n+    ($ty:ident, $kind:ident) => {\n+        impl<'hir> MaybePath<'hir> for hir::$ty<'hir> {\n+            fn hir_id(&self) -> HirId {\n+                self.hir_id\n+            }\n+            fn qpath_opt(&self) -> Option<&QPath<'hir>> {\n+                match &self.kind {\n+                    hir::$kind::Path(qpath) => Some(qpath),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    };\n+}\n+maybe_path!(Expr, ExprKind);\n+maybe_path!(Pat, PatKind);\n+maybe_path!(Ty, TyKind);\n+\n+/// If `maybe_path` is a path node, resolves it, otherwise returns `Res::Err`\n+pub fn path_res<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>) -> Res {\n+    match maybe_path.qpath_opt() {\n+        None => Res::Err,\n+        Some(qpath) => cx.qpath_res(qpath, maybe_path.hir_id()),\n+    }\n+}\n+\n+/// If `maybe_path` is a path node which resolves to an item, retrieves the item ID\n+pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>) -> Option<DefId> {\n+    path_res(cx, maybe_path).opt_def_id()\n+}\n+\n+/// Resolves a def path like `std::vec::Vec`.\n+/// This function is expensive and should be used sparingly.\n+pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n     macro_rules! try_res {\n         ($e:expr) => {\n             match $e {\n@@ -574,7 +529,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n /// Convenience function to get the `DefId` of a trait by path.\n /// It could be a trait or trait alias.\n pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n-    match path_to_res(cx, path) {\n+    match def_path_res(cx, path) {\n         Res::Def(DefKind::Trait | DefKind::TraitAlias, trait_id) => Some(trait_id),\n         _ => None,\n     }\n@@ -603,7 +558,9 @@ pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, def_id: LocalDefId) ->\n         if parent_impl != CRATE_DEF_ID;\n         if let hir::Node::Item(item) = cx.tcx.hir().get_by_def_id(parent_impl);\n         if let hir::ItemKind::Impl(impl_) = &item.kind;\n-        then { return impl_.of_trait.as_ref(); }\n+        then {\n+            return impl_.of_trait.as_ref();\n+        }\n     }\n     None\n }\n@@ -713,12 +670,7 @@ pub fn is_default_equivalent_call(cx: &LateContext<'_>, repl_func: &Expr<'_>) ->\n         if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n         if is_diag_trait_item(cx, repl_def_id, sym::Default)\n             || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n-        then {\n-            true\n-        }\n-        else {\n-            false\n-        }\n+        then { true } else { false }\n     }\n }\n \n@@ -1553,8 +1505,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n             if arms.len() == 2;\n             if arms[0].guard.is_none();\n             if arms[1].guard.is_none();\n-            if (is_ok(cx, &arms[0]) && is_err(cx, &arms[1])) ||\n-                (is_ok(cx, &arms[1]) && is_err(cx, &arms[0]));\n+            if (is_ok(cx, &arms[0]) && is_err(cx, &arms[1])) || (is_ok(cx, &arms[1]) && is_err(cx, &arms[0]));\n             then {\n                 return Some(expr);\n             }\n@@ -1644,7 +1595,7 @@ pub fn match_function_call<'tcx>(\n         if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n         if match_def_path(cx, fun_def_id, path);\n         then {\n-            return Some(args)\n+            return Some(args);\n         }\n     };\n     None\n@@ -1653,22 +1604,14 @@ pub fn match_function_call<'tcx>(\n /// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n /// any.\n ///\n-/// Please use `match_any_diagnostic_items` if the targets are all diagnostic items.\n+/// Please use `tcx.get_diagnostic_name` if the targets are all diagnostic items.\n pub fn match_any_def_paths(cx: &LateContext<'_>, did: DefId, paths: &[&[&str]]) -> Option<usize> {\n     let search_path = cx.get_def_path(did);\n     paths\n         .iter()\n         .position(|p| p.iter().map(|x| Symbol::intern(x)).eq(search_path.iter().copied()))\n }\n \n-/// Checks if the given `DefId` matches any of provided diagnostic items. Returns the index of\n-/// matching path, if any.\n-pub fn match_any_diagnostic_items(cx: &LateContext<'_>, def_id: DefId, diag_items: &[Symbol]) -> Option<usize> {\n-    diag_items\n-        .iter()\n-        .position(|item| cx.tcx.is_diagnostic_item(*item, def_id))\n-}\n-\n /// Checks if the given `DefId` matches the path.\n pub fn match_def_path<'tcx>(cx: &LateContext<'tcx>, did: DefId, syms: &[&str]) -> bool {\n     // We should probably move to Symbols in Clippy as well rather than interning every time.\n@@ -1821,8 +1764,7 @@ pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool\n \n     match expr.kind {\n         ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n-        _ => false,\n+        _ => path_def_id(cx, expr).map_or(false, |id| match_def_path(cx, id, &paths::CONVERT_IDENTITY)),\n     }\n }\n \n@@ -2174,7 +2116,7 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n \n /// Checks if the function containing the given `HirId` is a `#[test]` function\n ///\n-/// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n+/// Note: Add `// compile-flags: --test` to UI tests with a `#[test]` function\n pub fn is_in_test_function(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     with_test_item_names(tcx, tcx.parent_module(id), |names| {\n         tcx.hir()\n@@ -2197,7 +2139,7 @@ pub fn is_in_test_function(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n /// Checks whether item either has `test` attribute applied, or\n /// is a module with `test` in its name.\n ///\n-/// Note: If you use this function, please add a `#[test]` case in `tests/ui_test`.\n+/// Note: Add `// compile-flags: --test` to UI tests with a `#[test]` function\n pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n     is_in_test_function(tcx, item.hir_id())\n         || matches!(item.kind, ItemKind::Mod(..))"}, {"sha": "5a76ac23332d31d5fd08c8826cd8f9c78ec876ff", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{self as hir, Expr, ExprKind, HirId, Node, QPath};\n use rustc_lint::LateContext;\n use rustc_span::def_id::DefId;\n-use rustc_span::hygiene::{MacroKind, SyntaxContext};\n+use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::ops::ControlFlow;\n \n@@ -306,6 +306,7 @@ fn is_assert_arg(cx: &LateContext<'_>, expr: &Expr<'_>, assert_expn: ExpnId) ->\n }\n \n /// A parsed `format_args!` expansion\n+#[derive(Debug)]\n pub struct FormatArgsExpn<'tcx> {\n     /// Span of the first argument, the format string\n     pub format_string_span: Span,\n@@ -462,7 +463,11 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n                     if let Ok(i) = usize::try_from(position);\n                     if let Some(&(j, format_trait)) = self.formatters.get(i);\n                     then {\n-                        Some(FormatArgsArg { value: self.value_args[j], format_trait, spec: Some(spec) })\n+                        Some(FormatArgsArg {\n+                            value: self.value_args[j],\n+                            format_trait,\n+                            spec: Some(spec),\n+                        })\n                     } else {\n                         None\n                     }\n@@ -471,11 +476,13 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n             .collect()\n     }\n \n-    /// Span of all inputs\n+    /// Source callsite span of all inputs\n     pub fn inputs_span(&self) -> Span {\n         match *self.value_args {\n             [] => self.format_string_span,\n-            [.., last] => self.format_string_span.to(last.span),\n+            [.., last] => self\n+                .format_string_span\n+                .to(hygiene::walk_chain(last.span, self.format_string_span.ctxt())),\n         }\n     }\n }"}, {"sha": "958e6d1ec4615b2eeeaa8acfcf61ea17ac58ceb1", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -20,7 +20,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{expr_path_res, match_def_path, must_use_attr};\n+use crate::{match_def_path, must_use_attr, path_res};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -443,7 +443,7 @@ impl<'tcx> ExprFnSig<'tcx> {\n \n /// If the expression is function like, get the signature for it.\n pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnSig<'tcx>> {\n-    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = expr_path_res(cx, expr) {\n+    if let Res::Def(DefKind::Fn | DefKind::Ctor(_, CtorKind::Fn) | DefKind::AssocFn, id) = path_res(cx, expr) {\n         Some(ExprFnSig::Sig(cx.tcx.fn_sig(id)))\n     } else {\n         let ty = cx.typeck_results().expr_ty_adjusted(expr).peel_refs();"}, {"sha": "36c454745ba06a5cc91cccb178fc987950c830f4", "filename": "src/tools/clippy/doc/common_tools_writing_lints.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fdoc%2Fcommon_tools_writing_lints.md?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -235,7 +235,11 @@ Use the following functions to deal with macros:\n    assert_eq!(in_external_macro(cx.sess(), match_span), true);\n    ```\n \n-- `differing_macro_contexts()`: returns true if the two given spans are not from the same context\n+- `span.ctxt()`: the span's context represents whether it is from expansion, and if so, what expanded it\n+\n+One thing `SpanContext` is useful for is to check if two spans are in the same context. For example,\n+in `a == b`, `a` and `b` have the same context. In a `macro_rules!` with `a == $b`, `$b` is expanded to some\n+expression with a different context from `a`.\n \n    ```rust\n    macro_rules! m {\n@@ -252,7 +256,7 @@ Use the following functions to deal with macros:\n    // These spans are not from the same context\n    // x.is_some() is from inside the macro\n    // x.unwrap() is from outside the macro\n-   assert_eq!(differing_macro_contexts(x_is_some_span, x_unwrap_span), true);\n+   assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n    ```\n \n [TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html"}, {"sha": "f065f0bffc7bf70fc934bec08ab33408bad2874c", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-01-27\"\n+channel = \"nightly-2022-02-10\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "a82ff182839314d625cd0078cbe2d17fda1fe670", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 32, "deletions": 46, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -11,6 +11,7 @@ use std::env::{self, remove_var, set_var, var_os};\n use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::io;\n+use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n use test_utils::IS_RUSTC_TEST_SUITE;\n \n@@ -64,11 +65,11 @@ extern crate tokio;\n /// dependencies must be added to Cargo.toml at the project root. Test\n /// dependencies that are not *directly* used by this test module require an\n /// `extern crate` declaration.\n-fn extern_flags() -> String {\n+static EXTERN_FLAGS: SyncLazy<String> = SyncLazy::new(|| {\n     let current_exe_depinfo = {\n         let mut path = env::current_exe().unwrap();\n         path.set_extension(\"d\");\n-        std::fs::read_to_string(path).unwrap()\n+        fs::read_to_string(path).unwrap()\n     };\n     let mut crates: HashMap<&str, &str> = HashMap::with_capacity(TEST_DEPENDENCIES.len());\n     for line in current_exe_depinfo.lines() {\n@@ -112,24 +113,25 @@ fn extern_flags() -> String {\n         .into_iter()\n         .map(|(name, path)| format!(\" --extern {}={}\", name, path))\n         .collect()\n-}\n+});\n \n-fn default_config() -> compiletest::Config {\n+fn base_config(test_dir: &str) -> compiletest::Config {\n     let mut config = compiletest::Config {\n         edition: Some(\"2021\".into()),\n+        mode: TestMode::Ui,\n         ..compiletest::Config::default()\n     };\n \n     if let Ok(filters) = env::var(\"TESTNAME\") {\n-        config.filters = filters.split(',').map(std::string::ToString::to_string).collect();\n+        config.filters = filters.split(',').map(ToString::to_string).collect();\n     }\n \n     if let Some(path) = option_env!(\"RUSTC_LIB_PATH\") {\n         let path = PathBuf::from(path);\n         config.run_lib_path = path.clone();\n         config.compile_lib_path = path;\n     }\n-    let current_exe_path = std::env::current_exe().unwrap();\n+    let current_exe_path = env::current_exe().unwrap();\n     let deps_path = current_exe_path.parent().unwrap();\n     let profile_path = deps_path.parent().unwrap();\n \n@@ -143,10 +145,11 @@ fn default_config() -> compiletest::Config {\n         \"--emit=metadata -Dwarnings -Zui-testing -L dependency={}{}{}\",\n         deps_path.display(),\n         host_libs,\n-        extern_flags(),\n+        &*EXTERN_FLAGS,\n     ));\n \n-    config.build_base = profile_path.join(\"test\");\n+    config.src_base = Path::new(\"tests\").join(test_dir);\n+    config.build_base = profile_path.join(\"test\").join(test_dir);\n     config.rustc_path = profile_path.join(if cfg!(windows) {\n         \"clippy-driver.exe\"\n     } else {\n@@ -155,38 +158,23 @@ fn default_config() -> compiletest::Config {\n     config\n }\n \n-fn run_ui(cfg: &mut compiletest::Config) {\n-    cfg.mode = TestMode::Ui;\n-    cfg.src_base = Path::new(\"tests\").join(\"ui\");\n+fn run_ui() {\n+    let config = base_config(\"ui\");\n     // use tests/clippy.toml\n-    let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", std::fs::canonicalize(\"tests\").unwrap());\n-    compiletest::run_tests(cfg);\n-}\n-\n-fn run_ui_test(cfg: &mut compiletest::Config) {\n-    cfg.mode = TestMode::Ui;\n-    cfg.src_base = Path::new(\"tests\").join(\"ui_test\");\n-    let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", std::fs::canonicalize(\"tests\").unwrap());\n-    let rustcflags = cfg.target_rustcflags.get_or_insert_with(Default::default);\n-    let len = rustcflags.len();\n-    rustcflags.push_str(\" --test\");\n-    compiletest::run_tests(cfg);\n-    if let Some(ref mut flags) = &mut cfg.target_rustcflags {\n-        flags.truncate(len);\n-    }\n+    let _g = VarGuard::set(\"CARGO_MANIFEST_DIR\", fs::canonicalize(\"tests\").unwrap());\n+    compiletest::run_tests(&config);\n }\n \n-fn run_internal_tests(cfg: &mut compiletest::Config) {\n+fn run_internal_tests() {\n     // only run internal tests with the internal-tests feature\n     if !RUN_INTERNAL_TESTS {\n         return;\n     }\n-    cfg.mode = TestMode::Ui;\n-    cfg.src_base = Path::new(\"tests\").join(\"ui-internal\");\n-    compiletest::run_tests(cfg);\n+    let config = base_config(\"ui-internal\");\n+    compiletest::run_tests(&config);\n }\n \n-fn run_ui_toml(config: &mut compiletest::Config) {\n+fn run_ui_toml() {\n     fn run_tests(config: &compiletest::Config, mut tests: Vec<tester::TestDescAndFn>) -> Result<bool, io::Error> {\n         let mut result = true;\n         let opts = compiletest::test_opts(config);\n@@ -222,12 +210,12 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n         Ok(result)\n     }\n \n-    config.mode = TestMode::Ui;\n-    config.src_base = Path::new(\"tests\").join(\"ui-toml\").canonicalize().unwrap();\n+    let mut config = base_config(\"ui-toml\");\n+    config.src_base = config.src_base.canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(config);\n+    let tests = compiletest::make_tests(&config);\n \n-    let res = run_tests(config, tests);\n+    let res = run_tests(&config, tests);\n     match res {\n         Ok(true) => {},\n         Ok(false) => panic!(\"Some tests failed\"),\n@@ -237,7 +225,7 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n     }\n }\n \n-fn run_ui_cargo(config: &mut compiletest::Config) {\n+fn run_ui_cargo() {\n     fn run_tests(\n         config: &compiletest::Config,\n         filters: &[String],\n@@ -310,13 +298,13 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n         return;\n     }\n \n-    config.mode = TestMode::Ui;\n-    config.src_base = Path::new(\"tests\").join(\"ui-cargo\").canonicalize().unwrap();\n+    let mut config = base_config(\"ui-cargo\");\n+    config.src_base = config.src_base.canonicalize().unwrap();\n \n-    let tests = compiletest::make_tests(config);\n+    let tests = compiletest::make_tests(&config);\n \n     let current_dir = env::current_dir().unwrap();\n-    let res = run_tests(config, &config.filters, tests);\n+    let res = run_tests(&config, &config.filters, tests);\n     env::set_current_dir(current_dir).unwrap();\n \n     match res {\n@@ -331,12 +319,10 @@ fn run_ui_cargo(config: &mut compiletest::Config) {\n #[test]\n fn compile_test() {\n     set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n-    let mut config = default_config();\n-    run_ui(&mut config);\n-    run_ui_test(&mut config);\n-    run_ui_toml(&mut config);\n-    run_ui_cargo(&mut config);\n-    run_internal_tests(&mut config);\n+    run_ui();\n+    run_ui_toml();\n+    run_ui_cargo();\n+    run_internal_tests();\n }\n \n /// Restores an env var on drop"}, {"sha": "79c973cbfd2d57a4cb9a6732a6cda7fa4cf405dc", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/no_warn/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2FCargo.toml?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"no_warn\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "cda8d17eed44c7cdb9e9fc1609d90e71a146fdfa", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/no_warn/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fclippy.toml?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = false"}, {"sha": "e7a11a969c037e00a796aafeff6258501ec15e9a", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/no_warn/src/main.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fno_warn%2Fsrc%2Fmain.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "cda8d17eed44c7cdb9e9fc1609d90e71a146fdfa", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/.clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2F.clippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2F.clippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2F.clippy.toml?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = false"}, {"sha": "3d5c707579bcae8b63c54519c6c522e59dbb3c13", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2FCargo.toml?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"warn\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]"}, {"sha": "cda8d17eed44c7cdb9e9fc1609d90e71a146fdfa", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fclippy.toml?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1 @@\n+avoid-breaking-exported-api = false"}, {"sha": "2d0b4a7948c4a3b7c6c6d31c2b371e31c4602857", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/src/main.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,5 @@\n+// ignore-windows\n+\n+fn main() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "2abb4e3e06e64327dc81f3cdabaf44f646f1f571", "filename": "src/tools/clippy/tests/ui-cargo/multiple_config_files/warn/src/main.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_config_files%2Fwarn%2Fsrc%2Fmain.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,2 @@\n+Using config file `$SRC_DIR/tests/ui-cargo/multiple_config_files/warn/.clippy.toml`\n+Warning: `$SRC_DIR/tests/ui-cargo/multiple_config_files/warn/clippy.toml` will be ignored."}, {"sha": "e0510d942c200843abd0432b756f60ab9002d265", "filename": "src/tools/clippy/tests/ui/crashes/ice-4968.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-4968.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -3,6 +3,7 @@\n // Test for https://github.com/rust-lang/rust-clippy/issues/4968\n \n #![warn(clippy::unsound_collection_transmute)]\n+#![allow(clippy::transmute_undefined_repr)]\n \n trait Trait {\n     type Assoc;"}, {"sha": "d9a5ee1162a49cb0a9daa52157037caa0e3f9b1f", "filename": "src/tools/clippy/tests/ui/crashes/ice-8250.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,6 @@\n+fn _f(s: &str) -> Option<()> {\n+    let _ = s[1..].splitn(2, '.').next()?;\n+    Some(())\n+}\n+\n+fn main() {}"}, {"sha": "04ea4456656525c570cd1a39eb4348119ab291f4", "filename": "src/tools/clippy/tests/ui/crashes/ice-8250.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8250.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,18 @@\n+error: manual implementation of `split_once`\n+  --> $DIR/ice-8250.rs:2:13\n+   |\n+LL |     let _ = s[1..].splitn(2, '.').next()?;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s[1..].split_once('.').map_or(s[1..], |x| x.0)`\n+   |\n+   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/ice-8250.rs:2:13\n+   |\n+LL |     let _ = s[1..].splitn(2, '.').next()?;\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: try this: `s[1..].split('.')`\n+   |\n+   = note: `-D clippy::needless-splitn` implied by `-D warnings`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3e38b1408d8ca1f509ce6ab05f4b6b580febd8c9", "filename": "src/tools/clippy/tests/ui/crashes/ice-8386.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8386.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8386.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-8386.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,3 @@\n+fn f(x: u32, mut arg: &String) {}\n+\n+fn main() {}"}, {"sha": "93b2d33da2cd2163f34cbc6cee5a64149d60ef48", "filename": "src/tools/clippy/tests/ui/default_union_representation.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,78 @@\n+#![feature(transparent_unions)]\n+#![warn(clippy::default_union_representation)]\n+\n+union NoAttribute {\n+    a: i32,\n+    b: u32,\n+}\n+\n+#[repr(C)]\n+union ReprC {\n+    a: i32,\n+    b: u32,\n+}\n+\n+#[repr(packed)]\n+union ReprPacked {\n+    a: i32,\n+    b: u32,\n+}\n+\n+#[repr(C, packed)]\n+union ReprCPacked {\n+    a: i32,\n+    b: u32,\n+}\n+\n+#[repr(C, align(32))]\n+union ReprCAlign {\n+    a: i32,\n+    b: u32,\n+}\n+\n+#[repr(align(32))]\n+union ReprAlign {\n+    a: i32,\n+    b: u32,\n+}\n+\n+union SingleZST {\n+    f0: (),\n+}\n+union ZSTsAndField1 {\n+    f0: u32,\n+    f1: (),\n+    f2: (),\n+    f3: (),\n+}\n+union ZSTsAndField2 {\n+    f0: (),\n+    f1: (),\n+    f2: u32,\n+    f3: (),\n+}\n+union ZSTAndTwoFields {\n+    f0: u32,\n+    f1: u64,\n+    f2: (),\n+}\n+\n+#[repr(C)]\n+union CZSTAndTwoFields {\n+    f0: u32,\n+    f1: u64,\n+    f2: (),\n+}\n+\n+#[repr(transparent)]\n+union ReprTransparent {\n+    a: i32,\n+}\n+\n+#[repr(transparent)]\n+union ReprTransparentZST {\n+    a: i32,\n+    b: (),\n+}\n+\n+fn main() {}"}, {"sha": "138884af868c70c52673092638caacc9e31e6fee", "filename": "src/tools/clippy/tests/ui/default_union_representation.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdefault_union_representation.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,48 @@\n+error: this union has the default representation\n+  --> $DIR/default_union_representation.rs:4:1\n+   |\n+LL | / union NoAttribute {\n+LL | |     a: i32,\n+LL | |     b: u32,\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::default-union-representation` implied by `-D warnings`\n+   = help: consider annotating `NoAttribute` with `#[repr(C)]` to explicitly specify memory layout\n+\n+error: this union has the default representation\n+  --> $DIR/default_union_representation.rs:16:1\n+   |\n+LL | / union ReprPacked {\n+LL | |     a: i32,\n+LL | |     b: u32,\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ReprPacked` with `#[repr(C)]` to explicitly specify memory layout\n+\n+error: this union has the default representation\n+  --> $DIR/default_union_representation.rs:34:1\n+   |\n+LL | / union ReprAlign {\n+LL | |     a: i32,\n+LL | |     b: u32,\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ReprAlign` with `#[repr(C)]` to explicitly specify memory layout\n+\n+error: this union has the default representation\n+  --> $DIR/default_union_representation.rs:54:1\n+   |\n+LL | / union ZSTAndTwoFields {\n+LL | |     f0: u32,\n+LL | |     f1: u64,\n+LL | |     f2: (),\n+LL | | }\n+   | |_^\n+   |\n+   = help: consider annotating `ZSTAndTwoFields` with `#[repr(C)]` to explicitly specify memory layout\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "422f9486503d2396a484653531936afe7aa18814", "filename": "src/tools/clippy/tests/ui/eq_op.rs", "status": "modified", "additions": 52, "deletions": 41, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,58 +1,56 @@\n-// does not test any rustfixable lints\n-\n-#[rustfmt::skip]\n-#[warn(clippy::eq_op)]\n-#[allow(clippy::identity_op, clippy::double_parens)]\n-#[allow(clippy::no_effect, unused_variables, clippy::unnecessary_operation, clippy::short_circuit_statement)]\n-#[allow(clippy::nonminimal_bool)]\n-#[allow(unused)]\n-#[allow(clippy::unnecessary_cast)]\n+// compile-flags: --test\n+\n+#![warn(clippy::eq_op)]\n+#![allow(clippy::double_parens, clippy::identity_op, clippy::nonminimal_bool)]\n+\n fn main() {\n     // simple values and comparisons\n-    1 == 1;\n-    \"no\" == \"no\";\n+    let _ = 1 == 1;\n+    let _ = \"no\" == \"no\";\n     // even though I agree that no means no ;-)\n-    false != false;\n-    1.5 < 1.5;\n-    1u64 >= 1u64;\n+    let _ = false != false;\n+    let _ = 1.5 < 1.5;\n+    let _ = 1u64 >= 1u64;\n \n     // casts, methods, parentheses\n-    (1 as u64) & (1 as u64);\n-    1 ^ ((((((1))))));\n+    let _ = (1u32 as u64) & (1u32 as u64);\n+    #[rustfmt::skip]\n+    {\n+        let _ = 1 ^ ((((((1))))));\n+    };\n \n     // unary and binary operators\n-    (-(2) < -(2));\n-    ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n-    (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n+    let _ = (-(2) < -(2));\n+    let _ = ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n+    let _ = (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n \n     // various other things\n-    ([1] != [1]);\n-    ((1, 2) != (1, 2));\n-    vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros\n+    let _ = ([1] != [1]);\n+    let _ = ((1, 2) != (1, 2));\n+    let _ = vec![1, 2, 3] == vec![1, 2, 3]; //no error yet, as we don't match macros\n \n     // const folding\n-    1 + 1 == 2;\n-    1 - 1 == 0;\n+    let _ = 1 + 1 == 2;\n+    let _ = 1 - 1 == 0;\n \n-    1 - 1;\n-    1 / 1;\n-    true && true;\n-\n-    true || true;\n+    let _ = 1 - 1;\n+    let _ = 1 / 1;\n+    let _ = true && true;\n \n+    let _ = true || true;\n \n     let a: u32 = 0;\n     let b: u32 = 0;\n \n-    a == b && b == a;\n-    a != b && b != a;\n-    a < b && b > a;\n-    a <= b && b >= a;\n+    let _ = a == b && b == a;\n+    let _ = a != b && b != a;\n+    let _ = a < b && b > a;\n+    let _ = a <= b && b >= a;\n \n     let mut a = vec![1];\n-    a == a;\n-    2*a.len() == 2*a.len(); // ok, functions\n-    a.pop() == a.pop(); // ok, functions\n+    let _ = a == a;\n+    let _ = 2 * a.len() == 2 * a.len(); // ok, functions\n+    let _ = a.pop() == a.pop(); // ok, functions\n \n     check_ignore_macro();\n \n@@ -63,15 +61,14 @@ fn main() {\n     const D: u32 = A / A;\n }\n \n-#[rustfmt::skip]\n macro_rules! check_if_named_foo {\n-    ($expression:expr) => (\n+    ($expression:expr) => {\n         if stringify!($expression) == \"foo\" {\n             println!(\"foo!\");\n         } else {\n             println!(\"not foo.\");\n         }\n-    )\n+    };\n }\n \n macro_rules! bool_macro {\n@@ -80,11 +77,10 @@ macro_rules! bool_macro {\n     };\n }\n \n-#[allow(clippy::short_circuit_statement)]\n fn check_ignore_macro() {\n     check_if_named_foo!(foo);\n     // checks if the lint ignores macros with `!` operator\n-    !bool_macro!(1) && !bool_macro!(\"\");\n+    let _ = !bool_macro!(1) && !bool_macro!(\"\");\n }\n \n struct Nested {\n@@ -95,3 +91,18 @@ fn check_nested(n1: &Nested, n2: &Nested) -> bool {\n     // `n2.inner.0.0` mistyped as `n1.inner.0.0`\n     (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n }\n+\n+#[test]\n+fn eq_op_shouldnt_trigger_in_tests() {\n+    let a = 1;\n+    let result = a + 1 == 1 + a;\n+    assert!(result);\n+}\n+\n+#[test]\n+fn eq_op_macros_shouldnt_trigger_in_tests() {\n+    let a = 1;\n+    let b = 2;\n+    assert_eq!(a, a);\n+    assert_eq!(a + b, b + a);\n+}"}, {"sha": "313ceed2b41facad2b115d1b36d0d77bbb4693a2", "filename": "src/tools/clippy/tests/ui/eq_op.stderr", "status": "modified", "additions": 80, "deletions": 82, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Feq_op.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,174 +1,172 @@\n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:12:5\n+  --> $DIR/eq_op.rs:8:13\n    |\n-LL |     1 == 1;\n-   |     ^^^^^^\n+LL |     let _ = 1 == 1;\n+   |             ^^^^^^\n    |\n    = note: `-D clippy::eq-op` implied by `-D warnings`\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:13:5\n+  --> $DIR/eq_op.rs:9:13\n    |\n-LL |     \"no\" == \"no\";\n-   |     ^^^^^^^^^^^^\n+LL |     let _ = \"no\" == \"no\";\n+   |             ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:15:5\n+  --> $DIR/eq_op.rs:11:13\n    |\n-LL |     false != false;\n-   |     ^^^^^^^^^^^^^^\n+LL |     let _ = false != false;\n+   |             ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:16:5\n+  --> $DIR/eq_op.rs:12:13\n    |\n-LL |     1.5 < 1.5;\n-   |     ^^^^^^^^^\n+LL |     let _ = 1.5 < 1.5;\n+   |             ^^^^^^^^^\n \n error: equal expressions as operands to `>=`\n-  --> $DIR/eq_op.rs:17:5\n+  --> $DIR/eq_op.rs:13:13\n    |\n-LL |     1u64 >= 1u64;\n-   |     ^^^^^^^^^^^^\n+LL |     let _ = 1u64 >= 1u64;\n+   |             ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:20:5\n+  --> $DIR/eq_op.rs:16:13\n    |\n-LL |     (1 as u64) & (1 as u64);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = (1u32 as u64) & (1u32 as u64);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `^`\n-  --> $DIR/eq_op.rs:21:5\n+  --> $DIR/eq_op.rs:19:17\n    |\n-LL |     1 ^ ((((((1))))));\n-   |     ^^^^^^^^^^^^^^^^^\n+LL |         let _ = 1 ^ ((((((1))))));\n+   |                 ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `<`\n-  --> $DIR/eq_op.rs:24:5\n+  --> $DIR/eq_op.rs:23:13\n    |\n-LL |     (-(2) < -(2));\n-   |     ^^^^^^^^^^^^^\n+LL |     let _ = (-(2) < -(2));\n+   |             ^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:25:5\n+  --> $DIR/eq_op.rs:24:13\n    |\n-LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:25:6\n+  --> $DIR/eq_op.rs:24:14\n    |\n-LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n-   |      ^^^^^^^^^^^^^^^^^\n+LL |     let _ = ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n+   |              ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&`\n-  --> $DIR/eq_op.rs:25:27\n+  --> $DIR/eq_op.rs:24:35\n    |\n-LL |     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n-   |                           ^^^^^^^^^^^^^^^^^\n+LL |     let _ = ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n+   |                                   ^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:26:5\n+  --> $DIR/eq_op.rs:25:13\n    |\n-LL |     (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _ = (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:29:5\n+  --> $DIR/eq_op.rs:28:13\n    |\n-LL |     ([1] != [1]);\n-   |     ^^^^^^^^^^^^\n+LL |     let _ = ([1] != [1]);\n+   |             ^^^^^^^^^^^^\n \n error: equal expressions as operands to `!=`\n-  --> $DIR/eq_op.rs:30:5\n+  --> $DIR/eq_op.rs:29:13\n    |\n-LL |     ((1, 2) != (1, 2));\n-   |     ^^^^^^^^^^^^^^^^^^\n+LL |     let _ = ((1, 2) != (1, 2));\n+   |             ^^^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:34:5\n+  --> $DIR/eq_op.rs:33:13\n    |\n-LL |     1 + 1 == 2;\n-   |     ^^^^^^^^^^\n+LL |     let _ = 1 + 1 == 2;\n+   |             ^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:35:5\n+  --> $DIR/eq_op.rs:34:13\n    |\n-LL |     1 - 1 == 0;\n-   |     ^^^^^^^^^^\n+LL |     let _ = 1 - 1 == 0;\n+   |             ^^^^^^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:35:5\n+  --> $DIR/eq_op.rs:34:13\n    |\n-LL |     1 - 1 == 0;\n-   |     ^^^^^\n+LL |     let _ = 1 - 1 == 0;\n+   |             ^^^^^\n \n error: equal expressions as operands to `-`\n-  --> $DIR/eq_op.rs:37:5\n+  --> $DIR/eq_op.rs:36:13\n    |\n-LL |     1 - 1;\n-   |     ^^^^^\n+LL |     let _ = 1 - 1;\n+   |             ^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:38:5\n+  --> $DIR/eq_op.rs:37:13\n    |\n-LL |     1 / 1;\n-   |     ^^^^^\n+LL |     let _ = 1 / 1;\n+   |             ^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:39:5\n+  --> $DIR/eq_op.rs:38:13\n    |\n-LL |     true && true;\n-   |     ^^^^^^^^^^^^\n+LL |     let _ = true && true;\n+   |             ^^^^^^^^^^^^\n \n error: equal expressions as operands to `||`\n-  --> $DIR/eq_op.rs:41:5\n+  --> $DIR/eq_op.rs:40:13\n    |\n-LL |     true || true;\n-   |     ^^^^^^^^^^^^\n+LL |     let _ = true || true;\n+   |             ^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:47:5\n+  --> $DIR/eq_op.rs:45:13\n    |\n-LL |     a == b && b == a;\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     let _ = a == b && b == a;\n+   |             ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:48:5\n+  --> $DIR/eq_op.rs:46:13\n    |\n-LL |     a != b && b != a;\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     let _ = a != b && b != a;\n+   |             ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:49:5\n+  --> $DIR/eq_op.rs:47:13\n    |\n-LL |     a < b && b > a;\n-   |     ^^^^^^^^^^^^^^\n+LL |     let _ = a < b && b > a;\n+   |             ^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `&&`\n-  --> $DIR/eq_op.rs:50:5\n+  --> $DIR/eq_op.rs:48:13\n    |\n-LL |     a <= b && b >= a;\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     let _ = a <= b && b >= a;\n+   |             ^^^^^^^^^^^^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:53:5\n+  --> $DIR/eq_op.rs:51:13\n    |\n-LL |     a == a;\n-   |     ^^^^^^\n+LL |     let _ = a == a;\n+   |             ^^^^^^\n \n error: equal expressions as operands to `/`\n-  --> $DIR/eq_op.rs:63:20\n+  --> $DIR/eq_op.rs:61:20\n    |\n LL |     const D: u32 = A / A;\n    |                    ^^^^^\n \n error: equal expressions as operands to `==`\n-  --> $DIR/eq_op.rs:96:5\n+  --> $DIR/eq_op.rs:92:5\n    |\n LL |     (n1.inner.0).0 == (n1.inner.0).0 && (n1.inner.1).0 == (n2.inner.1).0 && (n1.inner.2).0 == (n2.inner.2).0\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[deny(clippy::eq_op)]` on by default\n \n error: aborting due to 28 previous errors\n "}, {"sha": "53e45d28bded91a7ab772f5aa2afd15c3f8a379e", "filename": "src/tools/clippy/tests/ui/expect_fun_call.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -5,6 +5,12 @@\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     struct Foo;\n \n@@ -31,6 +37,9 @@ fn main() {\n     let with_none_and_as_str: Option<i32> = None;\n     with_none_and_as_str.unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code));\n \n+    let with_none_and_format_with_macro: Option<i32> = None;\n+    with_none_and_format_with_macro.unwrap_or_else(|| panic!(\"Error {}: fake error\", one!()));\n+\n     let with_ok: Result<(), ()> = Ok(());\n     with_ok.expect(\"error\");\n "}, {"sha": "22e530b80349d81e27ef8fdeb015acbe54a027a5", "filename": "src/tools/clippy/tests/ui/expect_fun_call.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -5,6 +5,12 @@\n \n /// Checks implementation of the `EXPECT_FUN_CALL` lint\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     struct Foo;\n \n@@ -31,6 +37,9 @@ fn main() {\n     let with_none_and_as_str: Option<i32> = None;\n     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n \n+    let with_none_and_format_with_macro: Option<i32> = None;\n+    with_none_and_format_with_macro.expect(format!(\"Error {}: fake error\", one!()).as_str());\n+\n     let with_ok: Result<(), ()> = Ok(());\n     with_ok.expect(\"error\");\n "}, {"sha": "aca15935fca06596dca5f84edebe35b693baaa15", "filename": "src/tools/clippy/tests/ui/expect_fun_call.stderr", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexpect_fun_call.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,76 +1,82 @@\n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:29:26\n+  --> $DIR/expect_fun_call.rs:35:26\n    |\n LL |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n    |\n    = note: `-D clippy::expect-fun-call` implied by `-D warnings`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:32:26\n+  --> $DIR/expect_fun_call.rs:38:26\n    |\n LL |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:42:25\n+  --> $DIR/expect_fun_call.rs:41:37\n+   |\n+LL |     with_none_and_format_with_macro.expect(format!(\"Error {}: fake error\", one!()).as_str());\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"Error {}: fake error\", one!()))`\n+\n+error: use of `expect` followed by a function call\n+  --> $DIR/expect_fun_call.rs:51:25\n    |\n LL |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:45:25\n+  --> $DIR/expect_fun_call.rs:54:25\n    |\n LL |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(\"Error {}: fake error\", error_code))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:57:17\n+  --> $DIR/expect_fun_call.rs:66:17\n    |\n LL |     Some(\"foo\").expect(format!(\"{} {}\", 1, 2).as_ref());\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{} {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:78:21\n+  --> $DIR/expect_fun_call.rs:87:21\n    |\n LL |         Some(\"foo\").expect(&get_string());\n    |                     ^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:79:21\n+  --> $DIR/expect_fun_call.rs:88:21\n    |\n LL |         Some(\"foo\").expect(get_string().as_ref());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:80:21\n+  --> $DIR/expect_fun_call.rs:89:21\n    |\n LL |         Some(\"foo\").expect(get_string().as_str());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:82:21\n+  --> $DIR/expect_fun_call.rs:91:21\n    |\n LL |         Some(\"foo\").expect(get_static_str());\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_static_str()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:83:21\n+  --> $DIR/expect_fun_call.rs:92:21\n    |\n LL |         Some(\"foo\").expect(get_non_static_str(&0));\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| { panic!(\"{}\", get_non_static_str(&0).to_string()) })`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:87:16\n+  --> $DIR/expect_fun_call.rs:96:16\n    |\n LL |     Some(true).expect(&format!(\"key {}, {}\", 1, 2));\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"key {}, {}\", 1, 2))`\n \n error: use of `expect` followed by a function call\n-  --> $DIR/expect_fun_call.rs:93:17\n+  --> $DIR/expect_fun_call.rs:102:17\n    |\n LL |         opt_ref.expect(&format!(\"{:?}\", opt_ref));\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| panic!(\"{:?}\", opt_ref))`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "f9f8407d57755481de85bad8ad47efe42eba1563", "filename": "src/tools/clippy/tests/ui/explicit_counter_loop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_counter_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_counter_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_counter_loop.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -46,13 +46,13 @@ error: the variable `idx_usize` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:170:9\n    |\n LL |         for _item in slice {\n-   |         ^^^^^^^^^^^^^^^^^^ help: consider using: `for (idx_usize, _item) in slice.into_iter().enumerate()`\n+   |         ^^^^^^^^^^^^^^^^^^ help: consider using: `for (idx_usize, _item) in slice.iter().enumerate()`\n \n error: the variable `idx_u32` is used as a loop counter\n   --> $DIR/explicit_counter_loop.rs:182:9\n    |\n LL |         for _item in slice {\n-   |         ^^^^^^^^^^^^^^^^^^ help: consider using: `for (idx_u32, _item) in (0_u32..).zip(slice.into_iter())`\n+   |         ^^^^^^^^^^^^^^^^^^ help: consider using: `for (idx_u32, _item) in (0_u32..).zip(slice.iter())`\n    |\n    = note: `idx_u32` is of type `u32`, making it ineligible for `Iterator::enumerate`\n "}, {"sha": "74d0e5290282aff21105c871e8ba6223477e862b", "filename": "src/tools/clippy/tests/ui/explicit_write.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -10,6 +10,12 @@ fn stderr() -> String {\n     String::new()\n }\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     // these should warn\n     {\n@@ -24,6 +30,12 @@ fn main() {\n         // including newlines\n         println!(\"test\\ntest\");\n         eprintln!(\"test\\ntest\");\n+\n+        let value = 1;\n+        eprintln!(\"with {}\", value);\n+        eprintln!(\"with {} {}\", 2, value);\n+        eprintln!(\"with {value}\");\n+        eprintln!(\"macro arg {}\", one!());\n     }\n     // these should not warn, different destination\n     {"}, {"sha": "e7a698d3e012d35049febcde9222b519904e06e8", "filename": "src/tools/clippy/tests/ui/explicit_write.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -10,6 +10,12 @@ fn stderr() -> String {\n     String::new()\n }\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     // these should warn\n     {\n@@ -24,6 +30,12 @@ fn main() {\n         // including newlines\n         writeln!(std::io::stdout(), \"test\\ntest\").unwrap();\n         writeln!(std::io::stderr(), \"test\\ntest\").unwrap();\n+\n+        let value = 1;\n+        writeln!(std::io::stderr(), \"with {}\", value).unwrap();\n+        writeln!(std::io::stderr(), \"with {} {}\", 2, value).unwrap();\n+        writeln!(std::io::stderr(), \"with {value}\").unwrap();\n+        writeln!(std::io::stderr(), \"macro arg {}\", one!()).unwrap();\n     }\n     // these should not warn, different destination\n     {"}, {"sha": "29ae0cdece2499e6466a957b8409f1faf007397b", "filename": "src/tools/clippy/tests/ui/explicit_write.stderr", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,52 +1,76 @@\n error: use of `write!(stdout(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:17:9\n+  --> $DIR/explicit_write.rs:23:9\n    |\n LL |         write!(std::io::stdout(), \"test\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `print!(\"test\")`\n    |\n    = note: `-D clippy::explicit-write` implied by `-D warnings`\n \n error: use of `write!(stderr(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:18:9\n+  --> $DIR/explicit_write.rs:24:9\n    |\n LL |         write!(std::io::stderr(), \"test\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprint!(\"test\")`\n \n error: use of `writeln!(stdout(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:19:9\n+  --> $DIR/explicit_write.rs:25:9\n    |\n LL |         writeln!(std::io::stdout(), \"test\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `println!(\"test\")`\n \n error: use of `writeln!(stderr(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:20:9\n+  --> $DIR/explicit_write.rs:26:9\n    |\n LL |         writeln!(std::io::stderr(), \"test\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"test\")`\n \n error: use of `stdout().write_fmt(...).unwrap()`\n-  --> $DIR/explicit_write.rs:21:9\n+  --> $DIR/explicit_write.rs:27:9\n    |\n LL |         std::io::stdout().write_fmt(format_args!(\"test\")).unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `print!(\"test\")`\n \n error: use of `stderr().write_fmt(...).unwrap()`\n-  --> $DIR/explicit_write.rs:22:9\n+  --> $DIR/explicit_write.rs:28:9\n    |\n LL |         std::io::stderr().write_fmt(format_args!(\"test\")).unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprint!(\"test\")`\n \n error: use of `writeln!(stdout(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:25:9\n+  --> $DIR/explicit_write.rs:31:9\n    |\n LL |         writeln!(std::io::stdout(), \"test/ntest\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `println!(\"test/ntest\")`\n \n error: use of `writeln!(stderr(), ...).unwrap()`\n-  --> $DIR/explicit_write.rs:26:9\n+  --> $DIR/explicit_write.rs:32:9\n    |\n LL |         writeln!(std::io::stderr(), \"test/ntest\").unwrap();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"test/ntest\")`\n \n-error: aborting due to 8 previous errors\n+error: use of `writeln!(stderr(), ...).unwrap()`\n+  --> $DIR/explicit_write.rs:35:9\n+   |\n+LL |         writeln!(std::io::stderr(), \"with {}\", value).unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"with {}\", value)`\n+\n+error: use of `writeln!(stderr(), ...).unwrap()`\n+  --> $DIR/explicit_write.rs:36:9\n+   |\n+LL |         writeln!(std::io::stderr(), \"with {} {}\", 2, value).unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"with {} {}\", 2, value)`\n+\n+error: use of `writeln!(stderr(), ...).unwrap()`\n+  --> $DIR/explicit_write.rs:37:9\n+   |\n+LL |         writeln!(std::io::stderr(), \"with {value}\").unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"with {value}\")`\n+\n+error: use of `writeln!(stderr(), ...).unwrap()`\n+  --> $DIR/explicit_write.rs:38:9\n+   |\n+LL |         writeln!(std::io::stderr(), \"macro arg {}\", one!()).unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `eprintln!(\"macro arg {}\", one!())`\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "f21e8ef935bd02f71fb0cab1c48983afcbe06589", "filename": "src/tools/clippy/tests/ui/explicit_write_non_rustfix.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.rs?ref=e646f3d2a9541952310778288854943678738ea9", "patch": "@@ -1,8 +0,0 @@\n-#![allow(unused_imports, clippy::blacklisted_name)]\n-#![warn(clippy::explicit_write)]\n-\n-fn main() {\n-    use std::io::Write;\n-    let bar = \"bar\";\n-    writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n-}"}, {"sha": "b94ec6403ddcea3c63bfd188bbd6914679581c70", "filename": "src/tools/clippy/tests/ui/explicit_write_non_rustfix.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fexplicit_write_non_rustfix.stderr?ref=e646f3d2a9541952310778288854943678738ea9", "patch": "@@ -1,11 +0,0 @@\n-error: use of `writeln!(stderr(), ...).unwrap()`\n-  --> $DIR/explicit_write_non_rustfix.rs:7:5\n-   |\n-LL |     writeln!(std::io::stderr(), \"foo {}\", bar).unwrap();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::explicit-write` implied by `-D warnings`\n-   = help: consider using `eprintln!` instead\n-\n-error: aborting due to previous error\n-"}, {"sha": "c3a36dcabd1a9392278988dd9150ddd69a847649", "filename": "src/tools/clippy/tests/ui/get_unwrap.fixed", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,7 @@\n // run-rustfix\n+\n #![allow(unused_mut, clippy::from_iter_instead_of_collect)]\n+#![warn(clippy::unwrap_used)]\n #![deny(clippy::get_unwrap)]\n \n use std::collections::BTreeMap;\n@@ -37,6 +39,7 @@ fn main() {\n         let _ = &some_vecdeque[0];\n         let _ = &some_hashmap[&1];\n         let _ = &some_btreemap[&1];\n+        #[allow(clippy::unwrap_used)]\n         let _ = false_positive.get(0).unwrap();\n         // Test with deref\n         let _: u8 = boxed_slice[1];\n@@ -49,9 +52,12 @@ fn main() {\n         some_vec[0] = 1;\n         some_vecdeque[0] = 1;\n         // Check false positives\n-        *some_hashmap.get_mut(&1).unwrap() = 'b';\n-        *some_btreemap.get_mut(&1).unwrap() = 'b';\n-        *false_positive.get_mut(0).unwrap() = 1;\n+        #[allow(clippy::unwrap_used)]\n+        {\n+            *some_hashmap.get_mut(&1).unwrap() = 'b';\n+            *some_btreemap.get_mut(&1).unwrap() = 'b';\n+            *false_positive.get_mut(0).unwrap() = 1;\n+        }\n     }\n \n     {"}, {"sha": "d77a202aa39c3455026a095bd64e71b56c13fa40", "filename": "src/tools/clippy/tests/ui/get_unwrap.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,7 @@\n // run-rustfix\n+\n #![allow(unused_mut, clippy::from_iter_instead_of_collect)]\n+#![warn(clippy::unwrap_used)]\n #![deny(clippy::get_unwrap)]\n \n use std::collections::BTreeMap;\n@@ -37,6 +39,7 @@ fn main() {\n         let _ = some_vecdeque.get(0).unwrap();\n         let _ = some_hashmap.get(&1).unwrap();\n         let _ = some_btreemap.get(&1).unwrap();\n+        #[allow(clippy::unwrap_used)]\n         let _ = false_positive.get(0).unwrap();\n         // Test with deref\n         let _: u8 = *boxed_slice.get(1).unwrap();\n@@ -49,9 +52,12 @@ fn main() {\n         *some_vec.get_mut(0).unwrap() = 1;\n         *some_vecdeque.get_mut(0).unwrap() = 1;\n         // Check false positives\n-        *some_hashmap.get_mut(&1).unwrap() = 'b';\n-        *some_btreemap.get_mut(&1).unwrap() = 'b';\n-        *false_positive.get_mut(0).unwrap() = 1;\n+        #[allow(clippy::unwrap_used)]\n+        {\n+            *some_hashmap.get_mut(&1).unwrap() = 'b';\n+            *some_btreemap.get_mut(&1).unwrap() = 'b';\n+            *false_positive.get_mut(0).unwrap() = 1;\n+        }\n     }\n \n     {"}, {"sha": "cb5f44fbd59ee6114a6f339a533c93cf24dbd5a9", "filename": "src/tools/clippy/tests/ui/get_unwrap.stderr", "status": "modified", "additions": 120, "deletions": 15, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fget_unwrap.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,86 +1,191 @@\n error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:34:17\n+  --> $DIR/get_unwrap.rs:36:17\n    |\n LL |         let _ = boxed_slice.get(1).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&boxed_slice[1]`\n    |\n note: the lint level is defined here\n-  --> $DIR/get_unwrap.rs:3:9\n+  --> $DIR/get_unwrap.rs:5:9\n    |\n LL | #![deny(clippy::get_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:36:17\n+   |\n+LL |         let _ = boxed_slice.get(1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unwrap-used` implied by `-D warnings`\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:35:17\n+  --> $DIR/get_unwrap.rs:37:17\n    |\n LL |         let _ = some_slice.get(0).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_slice[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:37:17\n+   |\n+LL |         let _ = some_slice.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a Vec. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:36:17\n+  --> $DIR/get_unwrap.rs:38:17\n    |\n LL |         let _ = some_vec.get(0).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_vec[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:38:17\n+   |\n+LL |         let _ = some_vec.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a VecDeque. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:37:17\n+  --> $DIR/get_unwrap.rs:39:17\n    |\n LL |         let _ = some_vecdeque.get(0).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_vecdeque[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:39:17\n+   |\n+LL |         let _ = some_vecdeque.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a HashMap. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:38:17\n+  --> $DIR/get_unwrap.rs:40:17\n    |\n LL |         let _ = some_hashmap.get(&1).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_hashmap[&1]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:40:17\n+   |\n+LL |         let _ = some_hashmap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a BTreeMap. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:39:17\n+  --> $DIR/get_unwrap.rs:41:17\n    |\n LL |         let _ = some_btreemap.get(&1).unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_btreemap[&1]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:41:17\n+   |\n+LL |         let _ = some_btreemap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:42:21\n+  --> $DIR/get_unwrap.rs:45:21\n    |\n LL |         let _: u8 = *boxed_slice.get(1).unwrap();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `boxed_slice[1]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:45:22\n+   |\n+LL |         let _: u8 = *boxed_slice.get(1).unwrap();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get_mut().unwrap()` on a slice. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:47:9\n+  --> $DIR/get_unwrap.rs:50:9\n    |\n LL |         *boxed_slice.get_mut(0).unwrap() = 1;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `boxed_slice[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:50:10\n+   |\n+LL |         *boxed_slice.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get_mut().unwrap()` on a slice. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:48:9\n+  --> $DIR/get_unwrap.rs:51:9\n    |\n LL |         *some_slice.get_mut(0).unwrap() = 1;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_slice[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:51:10\n+   |\n+LL |         *some_slice.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get_mut().unwrap()` on a Vec. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:49:9\n+  --> $DIR/get_unwrap.rs:52:9\n    |\n LL |         *some_vec.get_mut(0).unwrap() = 1;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:52:10\n+   |\n+LL |         *some_vec.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get_mut().unwrap()` on a VecDeque. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:50:9\n+  --> $DIR/get_unwrap.rs:53:9\n    |\n LL |         *some_vecdeque.get_mut(0).unwrap() = 1;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vecdeque[0]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:53:10\n+   |\n+LL |         *some_vecdeque.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get().unwrap()` on a Vec. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:59:17\n+  --> $DIR/get_unwrap.rs:65:17\n    |\n LL |         let _ = some_vec.get(0..1).unwrap().to_vec();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0..1]`\n \n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:65:17\n+   |\n+LL |         let _ = some_vec.get(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n error: called `.get_mut().unwrap()` on a Vec. Using `[]` is more clear and more concise\n-  --> $DIR/get_unwrap.rs:60:17\n+  --> $DIR/get_unwrap.rs:66:17\n    |\n LL |         let _ = some_vec.get_mut(0..1).unwrap().to_vec();\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0..1]`\n \n-error: aborting due to 13 previous errors\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/get_unwrap.rs:66:17\n+   |\n+LL |         let _ = some_vec.get_mut(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: aborting due to 26 previous errors\n "}, {"sha": "d0bc640db88994c7c59312de4dfcb001aa984a78", "filename": "src/tools/clippy/tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -6,6 +6,12 @@\n #![warn(clippy::manual_assert)]\n #![allow(clippy::nonminimal_bool)]\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     let a = vec![1, 2, 3];\n     let c = Some(2);\n@@ -42,4 +48,5 @@ fn main() {\n     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n+    assert!(!a.is_empty(), \"with expansion {}\", one!());\n }"}, {"sha": "a0f31afd6ebfe5986ff06e2f716b539e713b1535", "filename": "src/tools/clippy/tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2018.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,5 @@\n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:24:5\n+  --> $DIR/manual_assert.rs:30:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n@@ -9,52 +9,60 @@ LL | |     }\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:27:5\n+  --> $DIR/manual_assert.rs:33:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qwqwq\");\n LL | |     }\n    | |_____^ help: try: `assert!(a.is_empty(), \"qwqwq\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:44:5\n+  --> $DIR/manual_assert.rs:50:5\n    |\n LL | /     if b.is_empty() {\n LL | |         panic!(\"panic1\");\n LL | |     }\n    | |_____^ help: try: `assert!(!b.is_empty(), \"panic1\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:47:5\n+  --> $DIR/manual_assert.rs:53:5\n    |\n LL | /     if b.is_empty() && a.is_empty() {\n LL | |         panic!(\"panic2\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:50:5\n+  --> $DIR/manual_assert.rs:56:5\n    |\n LL | /     if a.is_empty() && !b.is_empty() {\n LL | |         panic!(\"panic3\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:53:5\n+  --> $DIR/manual_assert.rs:59:5\n    |\n LL | /     if b.is_empty() || a.is_empty() {\n LL | |         panic!(\"panic4\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:56:5\n+  --> $DIR/manual_assert.rs:62:5\n    |\n LL | /     if a.is_empty() || !b.is_empty() {\n LL | |         panic!(\"panic5\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n \n-error: aborting due to 7 previous errors\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:65:5\n+   |\n+LL | /     if a.is_empty() {\n+LL | |         panic!(\"with expansion {}\", one!())\n+LL | |     }\n+   | |_____^ help: try: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "d0bc640db88994c7c59312de4dfcb001aa984a78", "filename": "src/tools/clippy/tests/ui/manual_assert.edition2021.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -6,6 +6,12 @@\n #![warn(clippy::manual_assert)]\n #![allow(clippy::nonminimal_bool)]\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     let a = vec![1, 2, 3];\n     let c = Some(2);\n@@ -42,4 +48,5 @@ fn main() {\n     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n+    assert!(!a.is_empty(), \"with expansion {}\", one!());\n }"}, {"sha": "a0f31afd6ebfe5986ff06e2f716b539e713b1535", "filename": "src/tools/clippy/tests/ui/manual_assert.edition2021.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.edition2021.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -1,5 +1,5 @@\n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:24:5\n+  --> $DIR/manual_assert.rs:30:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qaqaq{:?}\", a);\n@@ -9,52 +9,60 @@ LL | |     }\n    = note: `-D clippy::manual-assert` implied by `-D warnings`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:27:5\n+  --> $DIR/manual_assert.rs:33:5\n    |\n LL | /     if !a.is_empty() {\n LL | |         panic!(\"qwqwq\");\n LL | |     }\n    | |_____^ help: try: `assert!(a.is_empty(), \"qwqwq\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:44:5\n+  --> $DIR/manual_assert.rs:50:5\n    |\n LL | /     if b.is_empty() {\n LL | |         panic!(\"panic1\");\n LL | |     }\n    | |_____^ help: try: `assert!(!b.is_empty(), \"panic1\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:47:5\n+  --> $DIR/manual_assert.rs:53:5\n    |\n LL | /     if b.is_empty() && a.is_empty() {\n LL | |         panic!(\"panic2\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(b.is_empty() && a.is_empty()), \"panic2\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:50:5\n+  --> $DIR/manual_assert.rs:56:5\n    |\n LL | /     if a.is_empty() && !b.is_empty() {\n LL | |         panic!(\"panic3\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:53:5\n+  --> $DIR/manual_assert.rs:59:5\n    |\n LL | /     if b.is_empty() || a.is_empty() {\n LL | |         panic!(\"panic4\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(b.is_empty() || a.is_empty()), \"panic4\");`\n \n error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:56:5\n+  --> $DIR/manual_assert.rs:62:5\n    |\n LL | /     if a.is_empty() || !b.is_empty() {\n LL | |         panic!(\"panic5\");\n LL | |     }\n    | |_____^ help: try: `assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");`\n \n-error: aborting due to 7 previous errors\n+error: only a `panic!` in `if`-then statement\n+  --> $DIR/manual_assert.rs:65:5\n+   |\n+LL | /     if a.is_empty() {\n+LL | |         panic!(\"with expansion {}\", one!())\n+LL | |     }\n+   | |_____^ help: try: `assert!(!a.is_empty(), \"with expansion {}\", one!());`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "027747d8386319431e82d9a836cf095063d2f2b9", "filename": "src/tools/clippy/tests/ui/manual_assert.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_assert.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -6,6 +6,12 @@\n #![warn(clippy::manual_assert)]\n #![allow(clippy::nonminimal_bool)]\n \n+macro_rules! one {\n+    () => {\n+        1\n+    };\n+}\n+\n fn main() {\n     let a = vec![1, 2, 3];\n     let c = Some(2);\n@@ -56,4 +62,7 @@ fn main() {\n     if a.is_empty() || !b.is_empty() {\n         panic!(\"panic5\");\n     }\n+    if a.is_empty() {\n+        panic!(\"with expansion {}\", one!())\n+    }\n }"}, {"sha": "6c5232ec5f55b7d0e59dec9373f55b4f91cd0f16", "filename": "src/tools/clippy/tests/ui/manual_flatten.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -26,8 +26,6 @@ fn main() {\n     }\n \n     // Test for loop over an implicit reference\n-    // Note: if `clippy::manual_flatten` is made autofixable, this case will\n-    // lead to a follow-up lint `clippy::into_iter_on_ref`\n     let z = &y;\n     for n in z {\n         if let Ok(n) = n {"}, {"sha": "392e1a39393754214ce44a4c04bdc222b85cb6b3", "filename": "src/tools/clippy/tests/ui/manual_flatten.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmanual_flatten.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -63,10 +63,10 @@ LL | |         }\n    | |_________^\n \n error: unnecessary `if let` since only the `Ok` variant of the iterator element is used\n-  --> $DIR/manual_flatten.rs:32:5\n+  --> $DIR/manual_flatten.rs:30:5\n    |\n LL |       for n in z {\n-   |       ^        - help: try: `z.into_iter().flatten()`\n+   |       ^        - help: try: `z.iter().flatten()`\n    |  _____|\n    | |\n LL | |         if let Ok(n) = n {\n@@ -76,15 +76,15 @@ LL | |     }\n    | |_____^\n    |\n help: ...and remove the `if let` statement in the for loop\n-  --> $DIR/manual_flatten.rs:33:9\n+  --> $DIR/manual_flatten.rs:31:9\n    |\n LL | /         if let Ok(n) = n {\n LL | |             println!(\"{}\", n);\n LL | |         }\n    | |_________^\n \n error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n-  --> $DIR/manual_flatten.rs:41:5\n+  --> $DIR/manual_flatten.rs:39:5\n    |\n LL |       for n in z {\n    |       ^        - help: try: `z.flatten()`\n@@ -97,15 +97,15 @@ LL | |     }\n    | |_____^\n    |\n help: ...and remove the `if let` statement in the for loop\n-  --> $DIR/manual_flatten.rs:42:9\n+  --> $DIR/manual_flatten.rs:40:9\n    |\n LL | /         if let Some(m) = n {\n LL | |             println!(\"{}\", m);\n LL | |         }\n    | |_________^\n \n error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n-  --> $DIR/manual_flatten.rs:74:5\n+  --> $DIR/manual_flatten.rs:72:5\n    |\n LL |       for n in &vec_of_ref {\n    |       ^        ----------- help: try: `vec_of_ref.iter().copied().flatten()`\n@@ -118,18 +118,18 @@ LL | |     }\n    | |_____^\n    |\n help: ...and remove the `if let` statement in the for loop\n-  --> $DIR/manual_flatten.rs:75:9\n+  --> $DIR/manual_flatten.rs:73:9\n    |\n LL | /         if let Some(n) = n {\n LL | |             println!(\"{:?}\", n);\n LL | |         }\n    | |_________^\n \n error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n-  --> $DIR/manual_flatten.rs:81:5\n+  --> $DIR/manual_flatten.rs:79:5\n    |\n LL |       for n in vec_of_ref {\n-   |       ^        ---------- help: try: `vec_of_ref.into_iter().copied().flatten()`\n+   |       ^        ---------- help: try: `vec_of_ref.iter().copied().flatten()`\n    |  _____|\n    | |\n LL | |         if let Some(n) = n {\n@@ -139,18 +139,18 @@ LL | |     }\n    | |_____^\n    |\n help: ...and remove the `if let` statement in the for loop\n-  --> $DIR/manual_flatten.rs:82:9\n+  --> $DIR/manual_flatten.rs:80:9\n    |\n LL | /         if let Some(n) = n {\n LL | |             println!(\"{:?}\", n);\n LL | |         }\n    | |_________^\n \n error: unnecessary `if let` since only the `Some` variant of the iterator element is used\n-  --> $DIR/manual_flatten.rs:88:5\n+  --> $DIR/manual_flatten.rs:86:5\n    |\n LL |       for n in slice_of_ref {\n-   |       ^        ------------ help: try: `slice_of_ref.into_iter().copied().flatten()`\n+   |       ^        ------------ help: try: `slice_of_ref.iter().copied().flatten()`\n    |  _____|\n    | |\n LL | |         if let Some(n) = n {\n@@ -160,7 +160,7 @@ LL | |     }\n    | |_____^\n    |\n help: ...and remove the `if let` statement in the for loop\n-  --> $DIR/manual_flatten.rs:89:9\n+  --> $DIR/manual_flatten.rs:87:9\n    |\n LL | /         if let Some(n) = n {\n LL | |             println!(\"{:?}\", n);"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/tools/clippy/tests/ui/non_expressive_names.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_expressive_names.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_expressive_names.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_expressive_names.stdout?ref=e646f3d2a9541952310778288854943678738ea9"}, {"sha": "00b99da2631c630aa1ef6e227e50c4c7f678f027", "filename": "src/tools/clippy/tests/ui/ptr_arg.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -180,3 +180,9 @@ fn dyn_fn_requires_vec(v: &Vec<u32>, f: &dyn Fn(&Vec<u32>)) {\n // No error for types behind an alias (#7699)\n type A = Vec<u8>;\n fn aliased(a: &A) {}\n+\n+// Issue #8366\n+pub trait Trait {\n+    fn f(v: &mut Vec<i32>);\n+    fn f2(v: &mut Vec<i32>) {}\n+}"}, {"sha": "bd371888046361ceea6c5ce3b9c866301df7e5a4", "filename": "src/tools/clippy/tests/ui/single_match.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -145,6 +145,84 @@ fn if_suggestion() {\n     };\n }\n \n+// See: issue #8282\n+fn ranges() {\n+    enum E {\n+        V,\n+    }\n+    let x = (Some(E::V), Some(42));\n+\n+    // Don't lint, because the `E` enum can be extended with additional fields later. Thus, the\n+    // proposed replacement to `if let Some(E::V)` may hide non-exhaustive warnings that appeared\n+    // because of `match` construction.\n+    match x {\n+        (Some(E::V), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(_), _) => {},\n+        (None, _) => {},\n+    }\n+\n+    // lint\n+    match x {\n+        (Some(E::V), _) => todo!(),\n+        (_, _) => {},\n+    }\n+\n+    // lint\n+    match (Some(42), Some(E::V), Some(42)) {\n+        (.., Some(E::V), _) => {},\n+        (..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (.., Some(E::V), _) => {},\n+        (.., None, _) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (Some(E::V), ..) => {},\n+        (None, ..) => {},\n+    }\n+\n+    // Don't lint, see above.\n+    match (Some(E::V), Some(E::V), Some(E::V)) {\n+        (_, Some(E::V), ..) => {},\n+        (_, None, ..) => {},\n+    }\n+}\n+\n+fn skip_type_aliases() {\n+    enum OptionEx {\n+        Some(i32),\n+        None,\n+    }\n+    enum ResultEx {\n+        Err(i32),\n+        Ok(i32),\n+    }\n+\n+    use OptionEx::{None, Some};\n+    use ResultEx::{Err, Ok};\n+\n+    // don't lint\n+    match Err(42) {\n+        Ok(_) => dummy(),\n+        Err(_) => (),\n+    };\n+\n+    // don't lint\n+    match Some(1i32) {\n+        Some(_) => dummy(),\n+        None => (),\n+    };\n+}\n+\n macro_rules! single_match {\n     ($num:literal) => {\n         match $num {"}, {"sha": "318faf2571758a1c5c7b7069207c014f645c8f90", "filename": "src/tools/clippy/tests/ui/single_match.stderr", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -38,15 +38,6 @@ LL | |         _ => {},\n LL | |     };\n    | |_____^ help: try this: `if let (2..=3, 7..=9) = z { dummy() }`\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match.rs:54:5\n-   |\n-LL | /     match x {\n-LL | |         Some(y) => dummy(),\n-LL | |         None => (),\n-LL | |     };\n-   | |_____^ help: try this: `if let Some(y) = x { dummy() }`\n-\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n   --> $DIR/single_match.rs:59:5\n    |\n@@ -128,5 +119,32 @@ LL | |         _ => (),\n LL | |     };\n    | |_____^ help: try this: `if let None = x { println!() }`\n \n-error: aborting due to 13 previous errors\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:164:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(_), _) => {},\n+LL | |         (None, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(_), _) = x {}`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:170:5\n+   |\n+LL | /     match x {\n+LL | |         (Some(E::V), _) => todo!(),\n+LL | |         (_, _) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (Some(E::V), _) = x { todo!() }`\n+\n+error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match.rs:176:5\n+   |\n+LL | /     match (Some(42), Some(E::V), Some(42)) {\n+LL | |         (.., Some(E::V), _) => {},\n+LL | |         (..) => {},\n+LL | |     }\n+   | |_____^ help: try this: `if let (.., Some(E::V), _) = (Some(42), Some(E::V), Some(42)) {}`\n+\n+error: aborting due to 15 previous errors\n "}, {"sha": "21ea704b62ab5c9134fcccdcda1d853a27af1c42", "filename": "src/tools/clippy/tests/ui/single_match_else.stderr", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -19,45 +19,5 @@ LL +         None\n LL +     }\n    |\n \n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:70:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return\n-LL +     }\n-   |\n-\n-error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:79:5\n-   |\n-LL | /     match Some(1) {\n-LL | |         Some(a) => println!(\"${:?}\", a),\n-LL | |         None => {\n-LL | |             println!(\"else block\");\n-LL | |             return;\n-LL | |         },\n-LL | |     }\n-   | |_____^\n-   |\n-help: try this\n-   |\n-LL ~     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n-LL +         println!(\"else block\");\n-LL +         return;\n-LL +     }\n-   |\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n "}, {"sha": "983fac7afe69a58c42ea43c4a1cfc7881a9b3bd7", "filename": "src/tools/clippy/tests/ui/starts_ends_with.fixed", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.fixed?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -7,6 +7,10 @@ fn main() {}\n fn starts_with() {\n     \"\".starts_with(' ');\n     !\"\".starts_with(' ');\n+\n+    // Ensure that suggestion is escaped correctly\n+    \"\".starts_with('\\n');\n+    !\"\".starts_with('\\n');\n }\n \n fn chars_cmp_with_unwrap() {\n@@ -31,7 +35,7 @@ fn chars_cmp_with_unwrap() {\n         // !s.ends_with('o')\n         // Nothing here\n     }\n-    if !s.ends_with('o') {\n+    if !s.ends_with('\\n') {\n         // !s.ends_with('o')\n         // Nothing here\n     }\n@@ -43,4 +47,8 @@ fn ends_with() {\n     !\"\".ends_with(' ');\n     \"\".ends_with(' ');\n     !\"\".ends_with(' ');\n+\n+    // Ensure that suggestion is escaped correctly\n+    \"\".ends_with('\\n');\n+    !\"\".ends_with('\\n');\n }"}, {"sha": "e3335dd2e2ef7727f6e92500fbeebb4450a47164", "filename": "src/tools/clippy/tests/ui/starts_ends_with.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -7,6 +7,10 @@ fn main() {}\n fn starts_with() {\n     \"\".chars().next() == Some(' ');\n     Some(' ') != \"\".chars().next();\n+\n+    // Ensure that suggestion is escaped correctly\n+    \"\".chars().next() == Some('\\n');\n+    Some('\\n') != \"\".chars().next();\n }\n \n fn chars_cmp_with_unwrap() {\n@@ -31,7 +35,7 @@ fn chars_cmp_with_unwrap() {\n         // !s.ends_with('o')\n         // Nothing here\n     }\n-    if s.chars().last().unwrap() != 'o' {\n+    if s.chars().last().unwrap() != '\\n' {\n         // !s.ends_with('o')\n         // Nothing here\n     }\n@@ -43,4 +47,8 @@ fn ends_with() {\n     Some(' ') != \"\".chars().last();\n     \"\".chars().next_back() == Some(' ');\n     Some(' ') != \"\".chars().next_back();\n+\n+    // Ensure that suggestion is escaped correctly\n+    \"\".chars().last() == Some('\\n');\n+    Some('\\n') != \"\".chars().last();\n }"}, {"sha": "2dd9f53b8026afd215c7fdd3b436fab8e61bad21", "filename": "src/tools/clippy/tests/ui/starts_ends_with.stderr", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fstarts_ends_with.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -13,66 +13,90 @@ LL |     Some(' ') != \"\".chars().next();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".starts_with(' ')`\n \n error: you should use the `starts_with` method\n-  --> $DIR/starts_ends_with.rs:14:8\n+  --> $DIR/starts_ends_with.rs:12:5\n+   |\n+LL |     \"\".chars().next() == Some('/n');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".starts_with('/n')`\n+\n+error: you should use the `starts_with` method\n+  --> $DIR/starts_ends_with.rs:13:5\n+   |\n+LL |     Some('/n') != \"\".chars().next();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".starts_with('/n')`\n+\n+error: you should use the `starts_with` method\n+  --> $DIR/starts_ends_with.rs:18:8\n    |\n LL |     if s.chars().next().unwrap() == 'f' {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.starts_with('f')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:18:8\n+  --> $DIR/starts_ends_with.rs:22:8\n    |\n LL |     if s.chars().next_back().unwrap() == 'o' {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.ends_with('o')`\n    |\n    = note: `-D clippy::chars-last-cmp` implied by `-D warnings`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:22:8\n+  --> $DIR/starts_ends_with.rs:26:8\n    |\n LL |     if s.chars().last().unwrap() == 'o' {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.ends_with('o')`\n \n error: you should use the `starts_with` method\n-  --> $DIR/starts_ends_with.rs:26:8\n+  --> $DIR/starts_ends_with.rs:30:8\n    |\n LL |     if s.chars().next().unwrap() != 'f' {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.starts_with('f')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:30:8\n+  --> $DIR/starts_ends_with.rs:34:8\n    |\n LL |     if s.chars().next_back().unwrap() != 'o' {\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.ends_with('o')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:34:8\n+  --> $DIR/starts_ends_with.rs:38:8\n    |\n-LL |     if s.chars().last().unwrap() != 'o' {\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.ends_with('o')`\n+LL |     if s.chars().last().unwrap() != '/n' {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.ends_with('/n')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:42:5\n+  --> $DIR/starts_ends_with.rs:46:5\n    |\n LL |     \"\".chars().last() == Some(' ');\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".ends_with(' ')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:43:5\n+  --> $DIR/starts_ends_with.rs:47:5\n    |\n LL |     Some(' ') != \"\".chars().last();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".ends_with(' ')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:44:5\n+  --> $DIR/starts_ends_with.rs:48:5\n    |\n LL |     \"\".chars().next_back() == Some(' ');\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".ends_with(' ')`\n \n error: you should use the `ends_with` method\n-  --> $DIR/starts_ends_with.rs:45:5\n+  --> $DIR/starts_ends_with.rs:49:5\n    |\n LL |     Some(' ') != \"\".chars().next_back();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".ends_with(' ')`\n \n-error: aborting due to 12 previous errors\n+error: you should use the `ends_with` method\n+  --> $DIR/starts_ends_with.rs:52:5\n+   |\n+LL |     \"\".chars().last() == Some('/n');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".ends_with('/n')`\n+\n+error: you should use the `ends_with` method\n+  --> $DIR/starts_ends_with.rs:53:5\n+   |\n+LL |     Some('/n') != \"\".chars().last();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".ends_with('/n')`\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "71539940fbf270e23d043b52d792f2e505c67906", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::transmute_undefined_repr)]\n+#![allow(clippy::unit_arg)]\n+\n+fn value<T>() -> T {\n+    unimplemented!()\n+}\n+\n+struct Empty;\n+struct Ty<T>(T);\n+struct Ty2<T, U>(T, U);\n+\n+#[repr(C)]\n+struct Ty2C<T, U>(T, U);\n+\n+fn main() {\n+    unsafe {\n+        let _: () = core::mem::transmute(value::<Empty>());\n+        let _: Empty = core::mem::transmute(value::<()>());\n+\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+\n+        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+\n+        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n+        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+\n+        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+\n+        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+    }\n+}"}, {"sha": "040c63c7afa625202d558097aec418e11a13a1b2", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e273fca380c5d28bc32b25ac1a885c61d4c5e75e/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr?ref=e273fca380c5d28bc32b25ac1a885c61d4c5e75e", "patch": "@@ -0,0 +1,44 @@\n+error: transmute from `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:23:33\n+   |\n+LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n+\n+error: transmute into `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:24:32\n+   |\n+LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:29:32\n+   |\n+LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:30:36\n+   |\n+LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute to `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:35:33\n+   |\n+LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:36:37\n+   |\n+LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "f2f5f1e588ed408e8a252148e7c9f48b48001bda", "filename": "src/tools/clippy/tests/ui_test/eq_op.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e646f3d2a9541952310778288854943678738ea9/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui_test%2Feq_op.rs?ref=e646f3d2a9541952310778288854943678738ea9", "patch": "@@ -1,15 +0,0 @@\n-#[warn(clippy::eq_op)]\n-#[test]\n-fn eq_op_shouldnt_trigger_in_tests() {\n-    let a = 1;\n-    let result = a + 1 == 1 + a;\n-    assert!(result);\n-}\n-\n-#[test]\n-fn eq_op_macros_shouldnt_trigger_in_tests() {\n-    let a = 1;\n-    let b = 2;\n-    assert_eq!(a, a);\n-    assert_eq!(a + b, b + a);\n-}"}]}