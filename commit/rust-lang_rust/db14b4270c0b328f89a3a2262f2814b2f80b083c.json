{"sha": "db14b4270c0b328f89a3a2262f2814b2f80b083c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMTRiNDI3MGMwYjMyOGY4OWEzYTIyNjJmMjgxNGIyZjgwYjA4M2M=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-10T18:53:33Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "Add simplisitc global modification caching", "tree": {"sha": "828807a713f8acb5543e2a12768b4e6accba2491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/828807a713f8acb5543e2a12768b4e6accba2491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db14b4270c0b328f89a3a2262f2814b2f80b083c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db14b4270c0b328f89a3a2262f2814b2f80b083c", "html_url": "https://github.com/rust-lang/rust/commit/db14b4270c0b328f89a3a2262f2814b2f80b083c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db14b4270c0b328f89a3a2262f2814b2f80b083c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ae3b3eb0682a4550578b4c35dc6e099d8a04e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae3b3eb0682a4550578b4c35dc6e099d8a04e66", "html_url": "https://github.com/rust-lang/rust/commit/3ae3b3eb0682a4550578b4c35dc6e099d8a04e66"}], "stats": {"total": 142, "additions": 111, "deletions": 31}, "files": [{"sha": "31c73c40287bdcdc0f21b970dc152f705916039d", "filename": "crates/libanalysis/src/db.rs", "status": "modified", "additions": 94, "deletions": 22, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb.rs?ref=db14b4270c0b328f89a3a2262f2814b2f80b083c", "patch": "@@ -2,50 +2,95 @@ use std::{\n     hash::Hash,\n     sync::Arc,\n     cell::RefCell,\n+    fmt::Debug,\n };\n+use parking_lot::Mutex;\n use libsyntax2::{File};\n use im;\n use {\n     FileId,\n     imp::{FileResolverImp},\n+    module_map_db::ModuleDescr,\n };\n \n-#[derive(Clone)]\n-pub(crate) struct Db {\n-    file_resolver: FileResolverImp,\n-    files: im::HashMap<FileId, Arc<String>>,\n+#[derive(Debug)]\n+pub(crate) struct DbHost {\n+    db: Arc<Db>,\n }\n \n-impl Db {\n-    pub(crate) fn new() -> Db {\n-        Db {\n+impl DbHost {\n+    pub(crate) fn new() -> DbHost {\n+        let db = Db {\n             file_resolver: FileResolverImp::default(),\n             files: im::HashMap::new(),\n-        }\n+            cache: Mutex::new(Cache::new())\n+        };\n+        DbHost { db: Arc::new(db) }\n     }\n     pub(crate) fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n+        let db = self.db_mut();\n         match text {\n             None => {\n-                self.files.remove(&file_id);\n+                db.files.remove(&file_id);\n             }\n             Some(text) => {\n-                self.files.insert(file_id, Arc::new(text));\n+                db.files.insert(file_id, Arc::new(text));\n             }\n         }\n     }\n     pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n-        self.file_resolver = file_resolver\n+        let db = self.db_mut();\n+        db.file_resolver = file_resolver\n     }\n     pub(crate) fn query_ctx(&self) -> QueryCtx {\n         QueryCtx {\n-            db: self.clone(),\n+            db: Arc::clone(&self.db),\n             trace: RefCell::new(Vec::new()),\n         }\n     }\n+    fn db_mut(&mut self) -> &mut Db {\n+        // NB: this \"forks\" the database & clears the cache\n+        let db = Arc::make_mut(&mut self.db);\n+        *db.cache.get_mut() = Default::default();\n+        db\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Db {\n+    file_resolver: FileResolverImp,\n+    files: im::HashMap<FileId, Arc<String>>,\n+    cache: Mutex<Cache>,\n+}\n+\n+impl Clone for Db {\n+    fn clone(&self) -> Db {\n+        Db {\n+            file_resolver: self.file_resolver.clone(),\n+            files: self.files.clone(),\n+            cache: Mutex::new(Cache::new()),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Default, Debug)]\n+pub(crate) struct Cache {\n+    pub(crate) module_descr: QueryCache<ModuleDescr>\n+}\n+#[allow(type_alias_bounds)]\n+pub(crate) type QueryCache<Q: Query> = im::HashMap<\n+    <Q as Query>::Params,\n+    <Q as Query>::Output\n+>;\n+\n+impl Cache {\n+    fn new() -> Cache {\n+        Default::default()\n+    }\n }\n \n pub(crate) struct QueryCtx {\n-    db: Db,\n+    db: Arc<Db>,\n     pub(crate) trace: RefCell<Vec<TraceEvent>>,\n }\n \n@@ -62,9 +107,7 @@ pub(crate) enum TraceEventKind {\n \n impl QueryCtx {\n     pub(crate) fn get<Q: Get>(&self, params: &Q::Params) -> Q::Output {\n-        self.trace(TraceEvent { query_id: Q::ID, kind: TraceEventKind::Start });\n         let res = Q::get(self, params);\n-        self.trace(TraceEvent { query_id: Q::ID, kind: TraceEventKind::Finish });\n         res\n     }\n     fn trace(&self, event: TraceEvent) {\n@@ -74,26 +117,55 @@ impl QueryCtx {\n \n pub(crate) trait Query {\n     const ID: u32;\n-    type Params: Hash;\n-    type Output;\n+    type Params: Hash + Eq + Debug;\n+    type Output: Debug;\n }\n \n pub(crate) trait Get: Query {\n     fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n }\n \n-impl<T: Eval> Get for T {\n+impl<T: Eval> Get for T\n+where\n+    T::Params: Clone,\n+    T::Output: Clone,\n+{\n     fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output {\n-        Self::eval(ctx, params)\n+        {\n+            let mut cache = ctx.db.cache.lock();\n+            if let Some(cache) = Self::cache(&mut cache) {\n+                if let Some(res) = cache.get(params) {\n+                    return res.clone();\n+                }\n+            }\n+        }\n+        ctx.trace(TraceEvent { query_id: Self::ID, kind: TraceEventKind::Start });\n+        let res = Self::eval(ctx, params);\n+        ctx.trace(TraceEvent { query_id: Self::ID, kind: TraceEventKind::Finish });\n+\n+        let mut cache = ctx.db.cache.lock();\n+        if let Some(cache) = Self::cache(&mut cache) {\n+            cache.insert(params.clone(), res.clone());\n+        }\n+\n+        res\n     }\n }\n \n-pub(crate) trait Eval: Query {\n+pub(crate) trait Eval: Query\n+where\n+    Self::Params: Clone,\n+    Self::Output: Clone,\n+ {\n+    fn cache(_cache: &mut Cache) -> Option<&mut QueryCache<Self>> {\n+        None\n+    }\n     fn eval(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n }\n \n+#[derive(Debug)]\n pub(crate) struct DbFiles {\n-    db: Db,\n+    db: Arc<Db>,\n }\n \n impl DbFiles {\n@@ -113,7 +185,7 @@ impl Query for Files {\n }\n impl Get for Files {\n     fn get(ctx: &QueryCtx, _params: &()) -> DbFiles {\n-        DbFiles { db: ctx.db.clone() }\n+        DbFiles { db: Arc::clone(&ctx.db) }\n     }\n }\n "}, {"sha": "3e77006c5ace2e160e0b41807e667814340b0251", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=db14b4270c0b328f89a3a2262f2814b2f80b083c", "patch": "@@ -13,7 +13,7 @@ extern crate im;\n \n mod symbol_index;\n mod module_map;\n-mod module_map_db;\n+pub(crate) mod module_map_db;\n mod imp;\n mod job;\n mod roots;"}, {"sha": "14b156b43631ba275dff761065841adb7969be87", "filename": "crates/libanalysis/src/module_map_db.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db14b4270c0b328f89a3a2262f2814b2f80b083c/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs?ref=db14b4270c0b328f89a3a2262f2814b2f80b083c", "patch": "@@ -1,11 +1,14 @@\n use std::sync::Arc;\n use {\n     FileId,\n-    db::{Query, Eval, QueryCtx, FileSyntax, Files},\n+    db::{\n+        Query, Eval, QueryCtx, FileSyntax, Files,\n+        Cache, QueryCache,\n+    },\n     module_map::resolve_submodule,\n };\n \n-enum ModuleDescr {}\n+pub(crate) enum ModuleDescr {}\n impl Query for ModuleDescr {\n     const ID: u32 = 30;\n     type Params = FileId;\n@@ -27,6 +30,9 @@ impl Query for ParentModule {\n }\n \n impl Eval for ModuleDescr {\n+    fn cache(cache: &mut Cache) -> Option<&mut QueryCache<Self>> {\n+        Some(&mut cache.module_descr)\n+    }\n     fn eval(ctx: &QueryCtx, file_id: &FileId) -> Arc<descr::ModuleDescr> {\n         let file = ctx.get::<FileSyntax>(file_id);\n         Arc::new(descr::ModuleDescr::new(file.ast()))\n@@ -66,6 +72,7 @@ mod descr {\n         ast::{self, NameOwner},\n     };\n \n+    #[derive(Debug)]\n     pub struct ModuleDescr {\n         pub submodules: Vec<Submodule>\n     }\n@@ -85,7 +92,7 @@ mod descr {\n             ModuleDescr { submodules } }\n     }\n \n-    #[derive(Clone, Hash)]\n+    #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n     pub struct Submodule {\n         pub name: SmolStr,\n     }\n@@ -98,7 +105,7 @@ mod tests {\n     use im;\n     use relative_path::{RelativePath, RelativePathBuf};\n     use {\n-        db::{Query, Db, TraceEventKind},\n+        db::{Query, DbHost, TraceEventKind},\n         imp::FileResolverImp,\n         FileId, FileResolver,\n     };\n@@ -122,15 +129,15 @@ mod tests {\n     struct Fixture {\n         next_file_id: u32,\n         fm: im::HashMap<FileId, RelativePathBuf>,\n-        db: Db,\n+        db: DbHost,\n     }\n \n     impl Fixture {\n         fn new() -> Fixture {\n             Fixture {\n                 next_file_id: 1,\n                 fm: im::HashMap::new(),\n-                db: Db::new(),\n+                db: DbHost::new(),\n             }\n         }\n         fn add_file(&mut self, path: &str, text: &str) -> FileId {\n@@ -185,10 +192,11 @@ mod tests {\n     fn test_parent_module() {\n         let mut f = Fixture::new();\n         let foo = f.add_file(\"/foo.rs\", \"\");\n-        f.check_parent_modules(foo, &[], &[(FileSyntax::ID, 1)]);\n+        f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 1)]);\n \n         let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n-        f.check_parent_modules(foo, &[lib], &[(FileSyntax::ID, 2)]);\n+        f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 2)]);\n+        f.check_parent_modules(foo, &[lib], &[(ModuleDescr::ID, 0)]);\n \n         f.change_file(lib, \"\");\n         f.check_parent_modules(foo, &[], &[(ModuleDescr::ID, 2)]);"}]}