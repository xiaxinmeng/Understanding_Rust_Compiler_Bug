{"sha": "a023e6121f4310f259378588bc60a4cf8b339fb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMjNlNjEyMWY0MzEwZjI1OTM3ODU4OGJjNjBhNGNmOGIzMzlmYjA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-27T21:39:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-27T21:39:42Z"}, "message": "Rollup merge of #70480 - lcnr:appayupyup, r=eddyb\n\nclarify hir_id <-> node_id method names\n\nresolves 2 FIXME.\n\nr? @eddyb", "tree": {"sha": "7cac7497870e0cc87fe9cf51c8b91f56767e5411", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cac7497870e0cc87fe9cf51c8b91f56767e5411"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a023e6121f4310f259378588bc60a4cf8b339fb0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJefnKfCRBK7hj4Ov3rIwAAdHIIADhm/cpg2DKVQm9g6+5o4hb0\nN8EENSxBqKlKy4Uplw2H2V5B7MxeWFeoR4FpHQ20gCkj9PDc+OrUvTOrjaxqY5PM\nXKGY8xl/+UOPx/51CI7Dv2sZKs1IS+ipcS3lAMgKdR+CmSWPgRaBHhZ8woGgBh/C\nyZ0z4IV8O/SE2bfd1z+agK8LHM/cxw34sKm0F3DMG88Kxi/IbHuuAhi+B3MzRJW6\naaTNLfvKH29WAOMmFh0wXOuAoWgVq6ywYhiV4e+U5JBXf5+cQxrCAP5xmHeC7m3k\n97BmbVNWjcEP7g78QgnZlHGSn2J6d7fol1fnDaARiBGbmN4IVcUizjohnGm65uU=\n=Yg69\n-----END PGP SIGNATURE-----\n", "payload": "tree 7cac7497870e0cc87fe9cf51c8b91f56767e5411\nparent 5b68f9c46a550dec9f8ef8bafb9a815cf564af1d\nparent 37603f499aceab28771a45fa76d120a8fa4b1735\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585345182 +0100\ncommitter GitHub <noreply@github.com> 1585345182 +0100\n\nRollup merge of #70480 - lcnr:appayupyup, r=eddyb\n\nclarify hir_id <-> node_id method names\n\nresolves 2 FIXME.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a023e6121f4310f259378588bc60a4cf8b339fb0", "html_url": "https://github.com/rust-lang/rust/commit/a023e6121f4310f259378588bc60a4cf8b339fb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a023e6121f4310f259378588bc60a4cf8b339fb0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "html_url": "https://github.com/rust-lang/rust/commit/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d"}, {"sha": "37603f499aceab28771a45fa76d120a8fa4b1735", "url": "https://api.github.com/repos/rust-lang/rust/commits/37603f499aceab28771a45fa76d120a8fa4b1735", "html_url": "https://github.com/rust-lang/rust/commit/37603f499aceab28771a45fa76d120a8fa4b1735"}], "stats": {"total": 96, "additions": 50, "deletions": 46}, "files": [{"sha": "70ea856498de4def00c12ea80b1e381f7e1df649", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -241,8 +241,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-            let node_id = self.definitions.hir_to_node_id(hir_id);\n-            assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n+            let node_id = self.definitions.hir_id_to_node_id(hir_id);\n+            assert_eq!(self.definitions.node_id_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_local_def_id(node_id) {\n@@ -342,7 +342,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(\n             i.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(i.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n             this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n@@ -374,7 +376,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(\n             ti.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(ti.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n             this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n@@ -388,7 +392,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(\n             ii.hir_id.owner,\n-            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n+            self.definitions\n+                .opt_local_def_id(self.definitions.hir_id_to_node_id(ii.hir_id))\n+                .unwrap()\n         );\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n             this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);"}, {"sha": "e8ce13e06e9f55b62a36e666d14a7ac56d4d2fd3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -161,7 +161,7 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn local_def_id_from_node_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n-            let hir_id = self.node_to_hir_id(node);\n+            let hir_id = self.node_id_to_hir_id(node);\n             bug!(\n                 \"local_def_id_from_node_id: no entry for `{}`, which has a map of `{:?}`\",\n                 node,\n@@ -184,7 +184,7 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<DefId> {\n-        let node_id = self.hir_to_node_id(hir_id);\n+        let node_id = self.hir_id_to_node_id(hir_id);\n         self.opt_local_def_id_from_node_id(node_id)\n     }\n \n@@ -204,13 +204,13 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n-        self.tcx.definitions.hir_to_node_id(hir_id)\n+    pub fn hir_id_to_node_id(&self, hir_id: HirId) -> NodeId {\n+        self.tcx.definitions.hir_id_to_node_id(hir_id)\n     }\n \n     #[inline]\n-    pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n-        self.tcx.definitions.node_to_hir_id(node_id)\n+    pub fn node_id_to_hir_id(&self, node_id: NodeId) -> HirId {\n+        self.tcx.definitions.node_id_to_hir_id(node_id)\n     }\n \n     #[inline]"}, {"sha": "971472a64222282b3223fe36ada8d0ac3caf4c49", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -137,7 +137,7 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.definitions.node_to_hir_id(node_id)\n+        self.definitions.node_id_to_hir_id(node_id)\n     }\n \n     #[inline]"}, {"sha": "ce3b76278016e8da2e07bcb4429e1e3d9856a559", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -1126,11 +1126,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in resolutions.trait_map {\n-            let hir_id = definitions.node_to_hir_id(k);\n+            let hir_id = definitions.node_id_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner).or_default();\n             let v = v\n                 .into_iter()\n-                .map(|tc| tc.map_import_ids(|id| definitions.node_to_hir_id(id)))\n+                .map(|tc| tc.map_import_ids(|id| definitions.node_id_to_hir_id(id)))\n                 .collect();\n             map.insert(hir_id.local_id, StableVec::new(v));\n         }\n@@ -1154,7 +1154,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .map(|(k, v)| {\n                     let exports: Vec<_> = v\n                         .into_iter()\n-                        .map(|e| e.map_id(|id| definitions.node_to_hir_id(id)))\n+                        .map(|e| e.map_id(|id| definitions.node_id_to_hir_id(id)))\n                         .collect();\n                     (k, exports)\n                 })"}, {"sha": "314af77f2ca1681779b3426dd43ba95404337622", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -353,15 +353,13 @@ impl Definitions {\n         }\n     }\n \n-    // FIXME(eddyb) rename to `hir_id_to_node_id`.\n     #[inline]\n-    pub fn hir_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n+    pub fn hir_id_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n         self.hir_id_to_node_id[&hir_id]\n     }\n \n-    // FIXME(eddyb) rename to `node_id_to_hir_id`.\n     #[inline]\n-    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+    pub fn node_id_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_id_to_hir_id[node_id]\n     }\n "}, {"sha": "d241cc5d8a33368cdd54f81e2944671680c9d51c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -644,7 +644,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n     }\n \n     let mut unsafe_blocks: Vec<_> = unsafe_blocks.iter().collect();\n-    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_to_node_id(*hir_id));\n+    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_id_to_node_id(*hir_id));\n     let used_unsafe: FxHashSet<_> =\n         unsafe_blocks.iter().flat_map(|&&(id, used)| used.then_some(id)).collect();\n     for &(block_id, is_used) in unsafe_blocks {"}, {"sha": "c0ac9e7f6b61ff1b62540960a16705a84aad9733", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -225,7 +225,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             collector.visit_pat(&arg.pat);\n \n             for (id, ident, ..) in collector.collected_idents {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n@@ -268,7 +268,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         self.nest_tables(id, |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n                 v.process_formals(&sig.decl.inputs, &method_data.qualname);\n@@ -308,7 +308,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            let hir_id = self.tcx.hir().node_to_hir_id(field.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(field.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, field, hir_id), field_data);\n         }\n     }\n@@ -360,7 +360,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: Option<&'l ast::Block>,\n     ) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n@@ -402,7 +402,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         typ: &'l ast::Ty,\n         expr: Option<&'l ast::Expr>,\n     ) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n@@ -429,7 +429,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n@@ -503,7 +503,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -546,7 +546,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n@@ -699,7 +699,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             let id = id_from_node_id(item.id, &self.save_ctxt);\n             let span = self.span_from_span(item.ident.span);\n             let children = methods.iter().map(|i| id_from_node_id(i.id, &self.save_ctxt)).collect();\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -759,7 +759,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), mod_data);\n         }\n     }\n@@ -864,7 +864,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         match p.kind {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let hir_id = self.tcx.hir().node_to_hir_id(p.id);\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(p.id);\n                 let adt = match self.save_ctxt.tables.node_type_opt(hir_id) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n                     _ => {\n@@ -903,7 +903,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         for (id, ident, _) in collector.collected_idents {\n             match self.save_ctxt.get_path_res(id) {\n                 Res::Local(hir_id) => {\n-                    let id = self.tcx.hir().hir_to_node_id(hir_id);\n+                    let id = self.tcx.hir().hir_id_to_node_id(hir_id);\n                     let typ = self\n                         .save_ctxt\n                         .tables\n@@ -1126,7 +1126,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         // The access is calculated using the current tree ID, but with the root tree's visibility\n         // (since nested trees don't have their own visibility).\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         let access = access_from!(self.save_ctxt, root_item, hir_id);\n \n         // The parent `DefId` of a given use tree is always the enclosing item.\n@@ -1321,7 +1321,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_node_id(item.id, &self.save_ctxt);\n-                    let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+                    let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n \n                     self.dumper.dump_def(\n                         &access_from!(self.save_ctxt, item, hir_id),\n@@ -1420,7 +1420,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         self.process_macro_use(ex.span);\n         match ex.kind {\n             ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-                let expr_hir_id = self.save_ctxt.tcx.hir().node_to_hir_id(ex.id);\n+                let expr_hir_id = self.save_ctxt.tcx.hir().node_id_to_hir_id(ex.id);\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(expr_hir_id);\n                 let adt = match self.save_ctxt.tables.expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n@@ -1429,7 +1429,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                         return;\n                     }\n                 };\n-                let node_id = self.save_ctxt.tcx.hir().hir_to_node_id(hir_expr.hir_id);\n+                let node_id = self.save_ctxt.tcx.hir().hir_id_to_node_id(hir_expr.hir_id);\n                 let res = self.save_ctxt.get_path_res(node_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), base)\n             }\n@@ -1514,7 +1514,7 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         match item.kind {"}, {"sha": "c737c6257a2ec49b90e27358d361940337d4b49b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -412,7 +412,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n-                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_to_hir_id(id)) {\n+                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_id_to_hir_id(id)) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }\n@@ -452,7 +452,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(def_id) => {\n                     let mut docs = String::new();\n                     let mut attrs = vec![];\n-                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n+                    let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n                     if let Some(Node::TraitItem(item)) = self.tcx.hir().find(hir_id) {\n                         docs = self.docs_for_attrs(&item.attrs);\n@@ -511,15 +511,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n-        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr.id);\n+        let expr_hir_id = self.tcx.hir().node_id_to_hir_id(expr.id);\n         let hir_node = self.tcx.hir().expect_expr(expr_hir_id);\n         let ty = self.tables.expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().kind == ty::Error {\n             return None;\n         }\n         match expr.kind {\n             ast::ExprKind::Field(ref sub_ex, ident) => {\n-                let sub_ex_hir_id = self.tcx.hir().node_to_hir_id(sub_ex.id);\n+                let sub_ex_hir_id = self.tcx.hir().node_id_to_hir_id(sub_ex.id);\n                 let hir_node = match self.tcx.hir().find(sub_ex_hir_id) {\n                     Some(Node::Expr(expr)) => expr,\n                     _ => {\n@@ -573,7 +573,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(ref seg, ..) => {\n-                let expr_hir_id = self.tcx.hir().definitions().node_to_hir_id(expr.id);\n+                let expr_hir_id = self.tcx.hir().definitions().node_id_to_hir_id(expr.id);\n                 let method_id = match self.tables.type_dependent_def_id(expr_hir_id) {\n                     Some(id) => id,\n                     None => {\n@@ -605,7 +605,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_res(&self, id: NodeId) -> Res {\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n         match self.tcx.hir().get(hir_id) {\n             Node::TraitRef(tr) => tr.path.res,\n \n@@ -619,7 +619,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 Some(res) if res != Res::Err => res,\n                 _ => {\n                     let parent_node = self.tcx.hir().get_parent_node(hir_id);\n-                    self.get_path_res(self.tcx.hir().hir_to_node_id(parent_node))\n+                    self.get_path_res(self.tcx.hir().hir_id_to_node_id(parent_node))\n                 }\n             },\n \n@@ -681,7 +681,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Local(id) => Some(Ref {\n                 kind: RefKind::Variable,\n                 span,\n-                ref_id: id_from_node_id(self.tcx.hir().hir_to_node_id(id), self),\n+                ref_id: id_from_node_id(self.tcx.hir().hir_id_to_node_id(id), self),\n             }),\n             Res::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })"}, {"sha": "2525773f0ed711933ef95446cb1cce355d07aa90", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a023e6121f4310f259378588bc60a4cf8b339fb0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a023e6121f4310f259378588bc60a4cf8b339fb0", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         // In case we're in a module, try to resolve the relative path.\n         if let Some(module_id) = parent_id.or(self.mod_ids.last().cloned()) {\n-            let module_id = cx.tcx.hir().hir_to_node_id(module_id);\n+            let module_id = cx.tcx.hir().hir_id_to_node_id(module_id);\n             let result = cx.enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns, module_id)\n             });"}]}