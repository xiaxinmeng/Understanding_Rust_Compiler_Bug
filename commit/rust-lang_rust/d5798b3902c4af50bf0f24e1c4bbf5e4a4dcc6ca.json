{"sha": "d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Nzk4YjM5MDJjNGFmNTBiZjBmMjRlMWM0YmJmNWU0YTRkY2M2Y2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T15:41:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-17T15:41:40Z"}, "message": "auto merge of #10972 : metajack/rust/pkgid-with-name, r=alexcrichton\n\nThis change extends the pkgid attribute to allow of explicit crate names, instead of always inferring them based on the path. This means that if your GitHub repo is called `rust-foo`, you can have your pkgid set your library name to `foo`. You'd do this with a pkgid attribute like `github.com/somewhere/rust-foo#foo:1.0`.\r\n\r\nThis is half of the fix for #10922.", "tree": {"sha": "91c5eff1ccbe19cda325df92a91ad78c75b1e351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/91c5eff1ccbe19cda325df92a91ad78c75b1e351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "html_url": "https://github.com/rust-lang/rust/commit/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a26bd166a3c029a17f4a5fdb6021d7de7c7eb48", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a26bd166a3c029a17f4a5fdb6021d7de7c7eb48", "html_url": "https://github.com/rust-lang/rust/commit/1a26bd166a3c029a17f4a5fdb6021d7de7c7eb48"}, {"sha": "262cc4a2bcc0e1465ed0c88722d5adfa80a184d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/262cc4a2bcc0e1465ed0c88722d5adfa80a184d9", "html_url": "https://github.com/rust-lang/rust/commit/262cc4a2bcc0e1465ed0c88722d5adfa80a184d9"}], "stats": {"total": 130, "additions": 78, "deletions": 52}, "files": [{"sha": "48a1ea6f6539d261bc5e105e05142c54573ffe82", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "patch": "@@ -790,7 +790,7 @@ extern mod extra; // equivalent to: extern mod extra = \"extra\";\n \n extern mod rustextra = \"extra\"; // linking to 'extra' under another name\n \n-extern mod foo = \"some/where/foo#1.0\"; // a full package ID for rustpkg\n+extern mod foo = \"some/where/rust-foo#foo:1.0\"; // a full package ID for rustpkg\n ~~~~\n \n ##### Use declarations"}, {"sha": "3c10e5199c926a6af837ae0afd48d11735a7ff7d", "filename": "src/libsyntax/pkgid.rs", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca/src%2Flibsyntax%2Fpkgid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca/src%2Flibsyntax%2Fpkgid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fpkgid.rs?ref=d5798b3902c4af50bf0f24e1c4bbf5e4a4dcc6ca", "patch": "@@ -8,10 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// PkgIds identify crates and include the crate name and optionall a path and\n+/// version. In the full form, they look like relative URLs. Example:\n+/// `github.com/mozilla/rust#std:1.0` would be a package ID with a path of\n+/// `gitub.com/mozilla/rust` and a crate name of `std` with a version of\n+/// `1.0`. If no crate name is given after the hash, the name is inferred to\n+/// be the last component of the path. If no version is given, it is inferred\n+/// to be `0.0`.\n #[deriving(Clone, Eq)]\n pub struct PkgId {\n+    /// A path which represents the codes origin. By convention this is the\n+    /// URL, without `http://` or `https://` prefix, to the crate's repository\n     path: ~str,\n+    /// The name of the crate.\n     name: ~str,\n+    /// The version of the crate.\n     version: Option<~str>,\n }\n \n@@ -21,62 +32,55 @@ impl ToStr for PkgId {\n             None => \"0.0\",\n             Some(ref version) => version.as_slice(),\n         };\n-        if self.path.is_empty() {\n-            format!(\"{}\\\\#{}\", self.name, version)\n+        if self.path == self.name || self.path.ends_with(format!(\"/{}\", self.name)) {\n+            format!(\"{}\\\\#{}\", self.path, version)\n         } else {\n-            format!(\"{}/{}\\\\#{}\", self.path, self.name, version)\n+            format!(\"{}\\\\#{}:{}\", self.path, self.name, version)\n         }\n     }\n }\n \n impl FromStr for PkgId {\n     fn from_str(s: &str) -> Option<PkgId> {\n-        let hash_idx = match s.find('#') {\n-            None => s.len(),\n-            Some(idx) => idx,\n-        };\n-        let prefix = s.slice_to(hash_idx);\n-        let name_idx = match prefix.rfind('/') {\n-            None => 0,\n-            Some(idx) => idx + 1,\n-        };\n-        if name_idx >= prefix.len() {\n-            return None;\n-        }\n-        let name = prefix.slice_from(name_idx);\n-        if name.len() <= 0 {\n-            return None;\n-        }\n+        let pieces: ~[&str] = s.splitn('#', 1).collect();\n+        let path = pieces[0].to_owned();\n \n-        let path = if name_idx == 0 {\n-            \"\"\n-        } else {\n-            prefix.slice_to(name_idx - 1)\n-        };\n-        let check_path = Path::new(path);\n-        if !check_path.is_relative() {\n+        if path.starts_with(\"/\") || path.ends_with(\"/\") ||\n+            path.starts_with(\".\") || path.is_empty() {\n             return None;\n         }\n \n-        let version = match s.find('#') {\n-            None => None,\n-            Some(idx) => {\n-                if idx >= s.len() {\n-                    None\n-                } else {\n-                    let v = s.slice_from(idx + 1);\n-                    if v.is_empty() {\n-                        None\n-                    } else {\n-                        Some(v.to_owned())\n-                    }\n-                }\n-            }\n+        let path_pieces: ~[&str] = path.rsplitn('/', 1).collect();\n+        let inferred_name = path_pieces[0];\n+\n+        let (name, version) = if pieces.len() == 1 {\n+            (inferred_name.to_owned(), None)\n+        } else {\n+            let hash_pieces: ~[&str] = pieces[1].splitn(':', 1).collect();\n+            let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n+                (\"\", hash_pieces[0])\n+            } else {\n+                (hash_pieces[0], hash_pieces[1])\n+            };\n+\n+            let name = if !hash_name.is_empty() {\n+                hash_name.to_owned()\n+            } else {\n+                inferred_name.to_owned()\n+            };\n+\n+            let version = if !hash_version.is_empty() {\n+                Some(hash_version.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            (name, version)\n         };\n \n-        Some(PkgId{\n-            path: path.to_owned(),\n-            name: name.to_owned(),\n+        Some(PkgId {\n+            path: path,\n+            name: name,\n             version: version,\n         })\n     }\n@@ -96,15 +100,15 @@ fn bare_name() {\n     let pkgid: PkgId = from_str(\"foo\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"foo\");\n }\n \n #[test]\n fn bare_name_single_char() {\n     let pkgid: PkgId = from_str(\"f\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"f\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"f\");\n }\n \n #[test]\n@@ -118,15 +122,15 @@ fn simple_path() {\n     let pkgid: PkgId = from_str(\"example.com/foo/bar\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"bar\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn simple_version() {\n     let pkgid: PkgId = from_str(\"foo#1.0\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"foo\");\n }\n \n #[test]\n@@ -135,26 +139,48 @@ fn absolute_path() {\n     assert!(pkgid.is_none());\n }\n \n+#[test]\n+fn path_ends_with_slash() {\n+    let pkgid: Option<PkgId> = from_str(\"foo/bar/\");\n+    assert!(pkgid.is_none());\n+}\n+\n #[test]\n fn path_and_version() {\n     let pkgid: PkgId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"bar\");\n     assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn single_chars() {\n     let pkgid: PkgId = from_str(\"a/b#1\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"b\");\n     assert_eq!(pkgid.version, Some(~\"1\"));\n-    assert_eq!(pkgid.path, ~\"a\");\n+    assert_eq!(pkgid.path, ~\"a/b\");\n }\n \n #[test]\n fn missing_version() {\n     let pkgid: PkgId = from_str(\"foo#\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n-}\n\\ No newline at end of file\n+    assert_eq!(pkgid.path, ~\"foo\");\n+}\n+\n+#[test]\n+fn path_and_name() {\n+    let pkgid: PkgId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"foo/rust-bar\");\n+}\n+\n+#[test]\n+fn empty_name() {\n+    let pkgid: PkgId = from_str(\"foo/bar#:1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"foo/bar\");\n+}"}]}