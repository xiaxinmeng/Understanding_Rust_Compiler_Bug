{"sha": "b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxODRiZmFkN2EyZGM2YTliZjY2NTRhN2VlYzZjNjhhMjdjNDlmNzA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-20T17:19:23Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-12-20T17:19:23Z"}, "message": "Add completions for patterns", "tree": {"sha": "a9d35d8053e13d22561156c760e0996323040169", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9d35d8053e13d22561156c760e0996323040169"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "html_url": "https://github.com/rust-lang/rust/commit/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3125555a8de6fad4529408436800a6b1243a442", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3125555a8de6fad4529408436800a6b1243a442", "html_url": "https://github.com/rust-lang/rust/commit/f3125555a8de6fad4529408436800a6b1243a442"}], "stats": {"total": 341, "additions": 315, "deletions": 26}, "files": [{"sha": "d9fe1348552eff448dd8ae75b84f9bd6a715fa6a", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -19,9 +19,14 @@ use hir::{ModPath, ScopeDef, Type};\n use crate::{\n     item::Builder,\n     render::{\n-        const_::render_const, enum_variant::render_variant, function::render_fn,\n-        macro_::render_macro, render_field, render_resolution, render_tuple_field,\n-        type_alias::render_type_alias, RenderContext,\n+        const_::render_const,\n+        enum_variant::render_variant,\n+        function::render_fn,\n+        macro_::render_macro,\n+        pattern::{render_struct_pat, render_variant_pat},\n+        render_field, render_resolution, render_tuple_field,\n+        type_alias::render_type_alias,\n+        RenderContext,\n     },\n     CompletionContext, CompletionItem,\n };\n@@ -105,6 +110,28 @@ impl Completions {\n         self.add(item)\n     }\n \n+    pub(crate) fn add_variant_pat(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::Variant,\n+        local_name: Option<hir::Name>,\n+    ) {\n+        if let Some(item) = render_variant_pat(RenderContext::new(ctx), variant, local_name) {\n+            self.add(item);\n+        }\n+    }\n+\n+    pub(crate) fn add_struct_pat(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        strukt: hir::Struct,\n+        local_name: Option<hir::Name>,\n+    ) {\n+        if let Some(item) = render_struct_pat(RenderContext::new(ctx), strukt, local_name) {\n+            self.add(item);\n+        }\n+    }\n+\n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n         if let Some(item) = render_const(RenderContext::new(ctx), constant) {\n             self.add(item);"}, {"sha": "496f0b04000db88b91c9f58ace619b5860ce1ee5", "filename": "crates/completion/src/completions/pattern.rs", "status": "modified", "additions": 139, "deletions": 15, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -1,10 +1,12 @@\n //! Completes constats and paths in patterns.\n \n+use hir::StructKind;\n+\n use crate::{CompletionContext, Completions};\n \n-/// Completes constats and paths in patterns.\n+/// Completes constants and paths in patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_pat_binding_or_const || ctx.is_irrefutable_let_pat_binding) {\n+    if !(ctx.is_pat_binding_or_const || ctx.is_irrefutable_pat_binding) {\n         return;\n     }\n     if ctx.record_pat_syntax.is_some() {\n@@ -15,20 +17,25 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     // suggest variants + auto-imports\n     ctx.scope.process_all_names(&mut |name, res| {\n         let add_resolution = match &res {\n-            hir::ScopeDef::ModuleDef(def) => {\n-                if ctx.is_irrefutable_let_pat_binding {\n-                    matches!(def, hir::ModuleDef::Adt(hir::Adt::Struct(_)))\n-                } else {\n-                    matches!(\n-                        def,\n-                        hir::ModuleDef::Adt(hir::Adt::Enum(..))\n-                            | hir::ModuleDef::Adt(hir::Adt::Struct(..))\n-                            | hir::ModuleDef::Variant(..)\n-                            | hir::ModuleDef::Const(..)\n-                            | hir::ModuleDef::Module(..)\n-                    )\n+            hir::ScopeDef::ModuleDef(def) => match def {\n+                hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n+                    acc.add_struct_pat(ctx, strukt.clone(), Some(name.clone()));\n+                    true\n+                }\n+                hir::ModuleDef::Variant(variant)\n+                    if !ctx.is_irrefutable_pat_binding\n+                        // render_resolution already does some pattern completion tricks for tuple variants\n+                        && variant.kind(ctx.db) == StructKind::Record =>\n+                {\n+                    acc.add_variant_pat(ctx, variant.clone(), Some(name.clone()));\n+                    true\n                 }\n-            }\n+                hir::ModuleDef::Adt(hir::Adt::Enum(..))\n+                | hir::ModuleDef::Variant(..)\n+                | hir::ModuleDef::Const(..)\n+                | hir::ModuleDef::Module(..) => !ctx.is_irrefutable_pat_binding,\n+                _ => false,\n+            },\n             hir::ScopeDef::MacroDef(_) => true,\n             _ => false,\n         };\n@@ -49,6 +56,11 @@ mod tests {\n         expect.assert_eq(&actual)\n     }\n \n+    fn check_snippet(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Snippet);\n+        expect.assert_eq(&actual)\n+    }\n+\n     #[test]\n     fn completes_enum_variants_and_modules() {\n         check(\n@@ -114,4 +126,116 @@ fn foo() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn completes_in_param() {\n+        check(\n+            r#\"\n+enum E { X }\n+\n+static FOO: E = E::X;\n+struct Bar { f: u32 }\n+\n+fn foo(<|>) {\n+}\n+\"#,\n+            expect![[r#\"\n+                st Bar\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_pat_in_let() {\n+        check_snippet(\n+            r#\"\n+struct Bar { f: u32 }\n+\n+fn foo() {\n+   let <|>\n+}\n+\"#,\n+            expect![[r#\"\n+                bn Bar Bar { f }$0\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_param_pattern() {\n+        check_snippet(\n+            r#\"\n+struct Foo { bar: String, baz: String }\n+struct Bar(String, String);\n+struct Baz;\n+fn outer(<|>) {}\n+\"#,\n+            expect![[r#\"\n+                bn Foo Foo { bar, baz }: Foo$0\n+                bn Bar Bar($1, $2): Bar$0\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn completes_let_pattern() {\n+        check_snippet(\n+            r#\"\n+struct Foo { bar: String, baz: String }\n+struct Bar(String, String);\n+struct Baz;\n+fn outer() {\n+    let <|>\n+}\n+\"#,\n+            expect![[r#\"\n+                bn Foo Foo { bar, baz }$0\n+                bn Bar Bar($1, $2)$0\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn completes_refutable_pattern() {\n+        check_snippet(\n+            r#\"\n+struct Foo { bar: i32, baz: i32 }\n+struct Bar(String, String);\n+struct Baz;\n+fn outer() {\n+    match () {\n+        <|>\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                bn Foo Foo { bar, baz }$0\n+                bn Bar Bar($1, $2)$0\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn omits_private_fields_pat() {\n+        check_snippet(\n+            r#\"\n+mod foo {\n+    pub struct Foo { pub bar: i32, baz: i32 }\n+    pub struct Bar(pub String, String);\n+    pub struct Invisible(String, String);\n+}\n+use foo::*;\n+\n+fn outer() {\n+    match () {\n+        <|>\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                bn Foo Foo { bar, .. }$0\n+                bn Bar Bar($1, ..)$0\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "41de324d8d9348ca4a334be2c502b9369ba69abd", "filename": "crates/completion/src/context.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcontext.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -51,7 +51,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n     pub(super) is_pat_binding_or_const: bool,\n-    pub(super) is_irrefutable_let_pat_binding: bool,\n+    pub(super) is_irrefutable_pat_binding: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n@@ -147,7 +147,7 @@ impl<'a> CompletionContext<'a> {\n             active_parameter: ActiveParameter::at(db, position),\n             is_param: false,\n             is_pat_binding_or_const: false,\n-            is_irrefutable_let_pat_binding: false,\n+            is_irrefutable_pat_binding: false,\n             is_trivial_path: false,\n             path_qual: None,\n             after_if: false,\n@@ -327,14 +327,19 @@ impl<'a> CompletionContext<'a> {\n                 if bind_pat.syntax().parent().and_then(ast::RecordPatFieldList::cast).is_some() {\n                     self.is_pat_binding_or_const = false;\n                 }\n-                if let Some(let_stmt) = bind_pat.syntax().ancestors().find_map(ast::LetStmt::cast) {\n-                    if let Some(pat) = let_stmt.pat() {\n-                        if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range())\n-                        {\n-                            self.is_pat_binding_or_const = false;\n-                            self.is_irrefutable_let_pat_binding = true;\n+                if let Some(Some(pat)) = bind_pat.syntax().ancestors().find_map(|node| {\n+                    match_ast! {\n+                        match node {\n+                            ast::LetStmt(it) => Some(it.pat()),\n+                            ast::Param(it) => Some(it.pat()),\n+                            _ => None,\n                         }\n                     }\n+                }) {\n+                    if pat.syntax().text_range().contains_range(bind_pat.syntax().text_range()) {\n+                        self.is_pat_binding_or_const = false;\n+                        self.is_irrefutable_pat_binding = true;\n+                    }\n                 }\n             }\n             if is_node::<ast::Param>(name.syntax()) {"}, {"sha": "945158d10119265f3fd4317b8d43c45e3d7770fd", "filename": "crates/completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -5,6 +5,7 @@ pub(crate) mod macro_;\n pub(crate) mod function;\n pub(crate) mod enum_variant;\n pub(crate) mod const_;\n+pub(crate) mod pattern;\n pub(crate) mod type_alias;\n \n mod builder_ext;"}, {"sha": "e20b0027bd994cdc886266c3c54af91f187ff0a4", "filename": "crates/completion/src/render/pattern.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fpattern.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -0,0 +1,128 @@\n+//! Renderer for patterns.\n+\n+use hir::{db::HirDatabase, HasVisibility, Name, StructKind};\n+use itertools::Itertools;\n+\n+use crate::{item::CompletionKind, render::RenderContext, CompletionItem, CompletionItemKind};\n+\n+pub(crate) fn render_struct_pat<'a>(\n+    ctx: RenderContext<'a>,\n+    strukt: hir::Struct,\n+    local_name: Option<Name>,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_struct_pat\");\n+\n+    let module = ctx.completion.scope.module()?;\n+    let fields = strukt.fields(ctx.db());\n+    let n_fields = fields.len();\n+    let fields = fields\n+        .into_iter()\n+        .filter(|field| field.is_visible_from(ctx.db(), module))\n+        .collect::<Vec<_>>();\n+\n+    if fields.is_empty() {\n+        // Matching a struct without matching its fields is pointless, unlike matching a Variant without its fields\n+        return None;\n+    }\n+    let fields_omitted = n_fields - fields.len() > 0;\n+\n+    let name = local_name.unwrap_or_else(|| strukt.name(ctx.db())).to_string();\n+    let mut pat = match strukt.kind(ctx.db()) {\n+        StructKind::Tuple if ctx.snippet_cap().is_some() => {\n+            render_tuple_as_pat(&fields, &name, fields_omitted)\n+        }\n+        StructKind::Record => render_record_as_pat(ctx.db(), &fields, &name, fields_omitted),\n+        _ => return None,\n+    };\n+\n+    if ctx.completion.is_param {\n+        pat.push(':');\n+        pat.push(' ');\n+        pat.push_str(&name);\n+    }\n+    if ctx.snippet_cap().is_some() {\n+        pat.push_str(\"$0\");\n+    }\n+\n+    let mut completion = CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), name)\n+        .kind(CompletionItemKind::Binding)\n+        .set_documentation(ctx.docs(strukt))\n+        .set_deprecated(ctx.is_deprecated(strukt))\n+        .detail(&pat);\n+    if let Some(snippet_cap) = ctx.snippet_cap() {\n+        completion = completion.insert_snippet(snippet_cap, pat);\n+    } else {\n+        completion = completion.insert_text(pat);\n+    }\n+    Some(completion.build())\n+}\n+\n+pub(crate) fn render_variant_pat<'a>(\n+    ctx: RenderContext<'a>,\n+    variant: hir::Variant,\n+    local_name: Option<Name>,\n+) -> Option<CompletionItem> {\n+    let _p = profile::span(\"render_variant_pat\");\n+\n+    let module = ctx.completion.scope.module()?;\n+    let fields = variant.fields(ctx.db());\n+    let n_fields = fields.len();\n+    let fields = fields\n+        .into_iter()\n+        .filter(|field| field.is_visible_from(ctx.db(), module))\n+        .collect::<Vec<_>>();\n+\n+    let fields_omitted = n_fields - fields.len() > 0;\n+\n+    let name = local_name.unwrap_or_else(|| variant.name(ctx.db())).to_string();\n+    let mut pat = match variant.kind(ctx.db()) {\n+        StructKind::Tuple if ctx.snippet_cap().is_some() => {\n+            render_tuple_as_pat(&fields, &name, fields_omitted)\n+        }\n+        StructKind::Record => render_record_as_pat(ctx.db(), &fields, &name, fields_omitted),\n+        _ => return None,\n+    };\n+\n+    if ctx.completion.is_param {\n+        pat.push(':');\n+        pat.push(' ');\n+        pat.push_str(&name);\n+    }\n+    if ctx.snippet_cap().is_some() {\n+        pat.push_str(\"$0\");\n+    }\n+    let mut completion = CompletionItem::new(CompletionKind::Snippet, ctx.source_range(), name)\n+        .kind(CompletionItemKind::Binding)\n+        .set_documentation(ctx.docs(variant))\n+        .set_deprecated(ctx.is_deprecated(variant))\n+        .detail(&pat);\n+    if let Some(snippet_cap) = ctx.snippet_cap() {\n+        completion = completion.insert_snippet(snippet_cap, pat);\n+    } else {\n+        completion = completion.insert_text(pat);\n+    }\n+    Some(completion.build())\n+}\n+\n+fn render_record_as_pat(\n+    db: &dyn HirDatabase,\n+    fields: &[hir::Field],\n+    name: &str,\n+    fields_omitted: bool,\n+) -> String {\n+    format!(\n+        \"{name} {{ {}{} }}\",\n+        fields.into_iter().map(|field| field.name(db)).format(\", \"),\n+        if fields_omitted { \", ..\" } else { \"\" },\n+        name = name\n+    )\n+}\n+\n+fn render_tuple_as_pat(fields: &[hir::Field], name: &str, fields_omitted: bool) -> String {\n+    format!(\n+        \"{name}({}{})\",\n+        fields.into_iter().enumerate().map(|(idx, _)| format!(\"${}\", idx + 1)).format(\", \"),\n+        if fields_omitted { \", ..\" } else { \"\" },\n+        name = name\n+    )\n+}"}, {"sha": "dbc937e4f6a2b332496c46bddb9dfefa16cbb5b7", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=b184bfad7a2dc6a9bf6654a7eec6c68a27c49f70", "patch": "@@ -511,6 +511,10 @@ impl Struct {\n         db.struct_data(self.id).repr.clone()\n     }\n \n+    pub fn kind(self, db: &dyn HirDatabase) -> StructKind {\n+        self.variant_data(db).kind()\n+    }\n+\n     fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.struct_data(self.id).variant_data.clone()\n     }"}]}