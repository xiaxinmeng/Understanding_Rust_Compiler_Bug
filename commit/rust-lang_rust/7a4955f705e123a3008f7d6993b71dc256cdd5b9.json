{"sha": "7a4955f705e123a3008f7d6993b71dc256cdd5b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNDk1NWY3MDVlMTIzYTMwMDhmN2Q2OTkzYjcxZGMyNTZjZGQ1Yjk=", "commit": {"author": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2017-05-16T11:08:24Z"}, "committer": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2017-05-16T11:08:24Z"}, "message": "Add methods to serialize Config to TOML.\n\nTwo different modes:\n\n - Serialize the full Config object. This is useful as\n   `Config::default().to_toml()` to output a rustfmt.toml with defaults\n   (#317).\n - Serialize only the options that have been accessed. This could be\n   useful to output a minimal rustfmt.toml for a project. (If the\n   default value of any unused config item changes, you'll then get the\n   new default when you come to use it).\n\nThis commit doesn't expose this anywhere - deciding a sensible CLI is a\nbit trickier.\n\nThis commit also has very simple error reporting (Result<String,\nString>) - once the CLI is decided, a more sensible method of reporting\nerrors might become obvious.", "tree": {"sha": "9857147952f7cc34f792d9c823ee23ddc632620e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9857147952f7cc34f792d9c823ee23ddc632620e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a4955f705e123a3008f7d6993b71dc256cdd5b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4955f705e123a3008f7d6993b71dc256cdd5b9", "html_url": "https://github.com/rust-lang/rust/commit/7a4955f705e123a3008f7d6993b71dc256cdd5b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a4955f705e123a3008f7d6993b71dc256cdd5b9/comments", "author": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d879662a9ef1184fa9f35d43bedd4b451e659c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d879662a9ef1184fa9f35d43bedd4b451e659c7", "html_url": "https://github.com/rust-lang/rust/commit/4d879662a9ef1184fa9f35d43bedd4b451e659c7"}], "stats": {"total": 81, "additions": 71, "deletions": 10}, "files": [{"sha": "e33c35f1054eab3e5414899b162c2e49816a663f", "filename": "src/config.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=7a4955f705e123a3008f7d6993b71dc256cdd5b9", "patch": "@@ -25,7 +25,7 @@ macro_rules! configuration_option_enum{\n             $( $x ),+\n         }\n \n-        impl_enum_decodable!($e, $( $x ),+);\n+        impl_enum_serialize_and_deserialize!($e, $( $x ),+);\n     }\n }\n \n@@ -247,10 +247,10 @@ macro_rules! create_config {\n         // Just like the Config struct but with each property wrapped\n         // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n         // specity all properties of `Config`.\n-        // We first parse into `ParsedConfig`, then create a default `Config`\n-        // and overwrite the properties with corresponding values from `ParsedConfig`\n-        #[derive(Deserialize, Clone)]\n-        pub struct ParsedConfig {\n+        // We first parse into `PartialConfig`, then create a default `Config`\n+        // and overwrite the properties with corresponding values from `PartialConfig`.\n+        #[derive(Deserialize, Serialize, Clone)]\n+        struct PartialConfig {\n             $(pub $i: Option<$ty>),+\n         }\n \n@@ -263,7 +263,7 @@ macro_rules! create_config {\n             }\n             )+\n \n-            fn fill_from_parsed_config(mut self, parsed: ParsedConfig) -> Config {\n+            fn fill_from_parsed_config(mut self, parsed: PartialConfig) -> Config {\n             $(\n                 if let Some(val) = parsed.$i {\n                     self.$i = val;\n@@ -306,6 +306,38 @@ macro_rules! create_config {\n                 }\n             }\n \n+            pub fn used_to_toml(&self) -> Result<String, String> {\n+                let mut partial = PartialConfig {\n+                    $(\n+                        $i: if self.tracker.was_accessed(stringify!($i)) {\n+                                Some(self.$i.clone())\n+                            } else {\n+                                None\n+                            },\n+                    )+\n+                };\n+\n+                // file_lines is special and can't be specified in toml.\n+                partial.file_lines = None;\n+\n+                toml::to_string(&partial)\n+                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n+            }\n+\n+            pub fn to_toml(&self) -> Result<String, String> {\n+                let mut partial = PartialConfig {\n+                    $(\n+                        $i: Some(self.$i.clone()),\n+                    )+\n+                };\n+\n+                // file_lines is special and can't be specified in toml.\n+                partial.file_lines = None;\n+\n+                toml::to_string(&partial)\n+                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n+            }\n+\n             pub fn override_value(&mut self, key: &str, val: &str)\n                 -> result::Result<(), Box<error::Error + Send + Sync>>\n             {"}, {"sha": "c6c4cc3e597e92f85dfe70707b13a37dcf5b678c", "filename": "src/file_lines.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=7a4955f705e123a3008f7d6993b71dc256cdd5b9", "patch": "@@ -216,6 +216,16 @@ impl<'de> ::serde::de::Deserialize<'de> for FileLines {\n     }\n }\n \n+// We also want to avoid attempting to serialize a FileLines to toml. The\n+// `Config` struct should ensure this impl is never reached.\n+impl ::serde::ser::Serialize for FileLines {\n+    fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n+        where S: ::serde::ser::Serializer\n+    {\n+        panic!(\"FileLines cannot be serialized. This is a rustfmt bug.\");\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Range;"}, {"sha": "613f31412e0d63747fd654c83a7e5cac84c89cae", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=7a4955f705e123a3008f7d6993b71dc256cdd5b9", "patch": "@@ -35,7 +35,7 @@ pub enum ListTactic {\n     Mixed,\n }\n \n-impl_enum_decodable!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n+impl_enum_serialize_and_deserialize!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum SeparatorTactic {\n@@ -44,7 +44,7 @@ pub enum SeparatorTactic {\n     Vertical,\n }\n \n-impl_enum_decodable!(SeparatorTactic, Always, Never, Vertical);\n+impl_enum_serialize_and_deserialize!(SeparatorTactic, Always, Never, Vertical);\n \n impl SeparatorTactic {\n     pub fn from_bool(b: bool) -> SeparatorTactic {"}, {"sha": "bb9d178b83fcb2d998fd5fedbe02c4acabdd9e32", "filename": "src/utils.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4955f705e123a3008f7d6993b71dc256cdd5b9/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=7a4955f705e123a3008f7d6993b71dc256cdd5b9", "patch": "@@ -189,10 +189,29 @@ pub fn trim_newlines(input: &str) -> &str {\n     }\n }\n \n-// Macro for deriving implementations of Decodable for enums\n+// Macro for deriving implementations of Serialize/Deserialize for enums\n #[macro_export]\n-macro_rules! impl_enum_decodable {\n+macro_rules! impl_enum_serialize_and_deserialize {\n     ( $e:ident, $( $x:ident ),* ) => {\n+        impl ::serde::ser::Serialize for $e {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+                where S: ::serde::ser::Serializer\n+            {\n+                use serde::ser::Error;\n+\n+                // We don't know whether the user of the macro has given us all options.\n+                #[allow(unreachable_patterns)]\n+                match *self {\n+                    $(\n+                        $e::$x => serializer.serialize_str(stringify!($x)),\n+                    )*\n+                    _ => {\n+                        Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self)))\n+                    }\n+                }\n+            }\n+        }\n+\n         impl<'de> ::serde::de::Deserialize<'de> for $e {\n             fn deserialize<D>(d: D) -> Result<Self, D::Error>\n                     where D: ::serde::Deserializer<'de> {"}]}