{"sha": "d3984e16bf04f8ff886247cbf684041ba623d6ab", "node_id": "C_kwDOAAsO6NoAKGQzOTg0ZTE2YmYwNGY4ZmY4ODYyNDdjYmY2ODQwNDFiYTYyM2Q2YWI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-11T21:45:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-11T21:45:48Z"}, "message": "Rollup merge of #89651 - ibraheemdev:poll-ready, r=dtolnay\n\nAdd `Poll::ready` and revert stabilization of `task::ready!`\n\nThis PR adds an inherent `ready` method to `Poll` that can be used with the `?` operator as an alternative to the `task::ready!` macro:\n```rust\nlet val = ready!(fut.poll(cx));\nlet val = fut.poll(cx).ready()?;\n```\n\nI think this form is a nice, non-breaking middle ground between changing the `impl Try for Poll`, and adding a separate macro. It looks better than `ready!` in my opinion, and it composes well:\n\n```rust\nlet elem = ready!(fut.poll(cx)).pop().unwrap();\nlet elem = fut.poll(cx).ready()?.pop().unwrap();\n```\n\nThe planned stabilization of `ready!` in 1.56 has been reverted because I think this alternate approach is worth considering.\n\nr? rust-lang/libs", "tree": {"sha": "eb817a52bc1a0e32928a75aea5d02e170ed5b303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb817a52bc1a0e32928a75aea5d02e170ed5b303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3984e16bf04f8ff886247cbf684041ba623d6ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZLCMCRBK7hj4Ov3rIwAAPCEIAFyXSMGuu/Ockspyup/5P74V\n7ubzXqaeS19s0ogPLSlnn2IsbVwkQbJNYPVnuJgD5mo1rN9qJ1zET9ByQ5UfDkxJ\nJTHU3XfBDlWWpXJMtKEl4KLgqUvnBVM1A/MEIQWhjLxQBmJAh6Zlmo0mQ3GNXEsC\nXkt082/3tq5+FTsV9Az2TDSMCm+MBJbAU5xYwyudYr1cM2gDcazcOZFHymkE7bMR\nbFZcQ07EHNt9Q5xoJ99lDk8fifEltsXF4b/TuEhvawwomVxSK+uo8WOzpiq1qLHl\niL2ysTAG46MprvyxQyB247t4bAVP3SfGljO6OQFnhySxZ7Zq7MzHpIfRteYvCTs=\n=Fbkh\n-----END PGP SIGNATURE-----\n", "payload": "tree eb817a52bc1a0e32928a75aea5d02e170ed5b303\nparent b80dd9e445e19fd82d305cd61cd266b0ee61bfee\nparent a1e03fc563eaaab04b747cf8d3f1a0d8931e39fd\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1633988748 +0200\ncommitter GitHub <noreply@github.com> 1633988748 +0200\n\nRollup merge of #89651 - ibraheemdev:poll-ready, r=dtolnay\n\nAdd `Poll::ready` and revert stabilization of `task::ready!`\n\nThis PR adds an inherent `ready` method to `Poll` that can be used with the `?` operator as an alternative to the `task::ready!` macro:\n```rust\nlet val = ready!(fut.poll(cx));\nlet val = fut.poll(cx).ready()?;\n```\n\nI think this form is a nice, non-breaking middle ground between changing the `impl Try for Poll`, and adding a separate macro. It looks better than `ready!` in my opinion, and it composes well:\n\n```rust\nlet elem = ready!(fut.poll(cx)).pop().unwrap();\nlet elem = fut.poll(cx).ready()?.pop().unwrap();\n```\n\nThe planned stabilization of `ready!` in 1.56 has been reverted because I think this alternate approach is worth considering.\n\nr? rust-lang/libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3984e16bf04f8ff886247cbf684041ba623d6ab", "html_url": "https://github.com/rust-lang/rust/commit/d3984e16bf04f8ff886247cbf684041ba623d6ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3984e16bf04f8ff886247cbf684041ba623d6ab/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "url": "https://api.github.com/repos/rust-lang/rust/commits/b80dd9e445e19fd82d305cd61cd266b0ee61bfee", "html_url": "https://github.com/rust-lang/rust/commit/b80dd9e445e19fd82d305cd61cd266b0ee61bfee"}, {"sha": "a1e03fc563eaaab04b747cf8d3f1a0d8931e39fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e03fc563eaaab04b747cf8d3f1a0d8931e39fd", "html_url": "https://github.com/rust-lang/rust/commit/a1e03fc563eaaab04b747cf8d3f1a0d8931e39fd"}], "stats": {"total": 101, "additions": 97, "deletions": 4}, "files": [{"sha": "269740c171cfb29e3519fe9510eff74bf7750457", "filename": "RELEASES.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3984e16bf04f8ff886247cbf684041ba623d6ab/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/d3984e16bf04f8ff886247cbf684041ba623d6ab/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=d3984e16bf04f8ff886247cbf684041ba623d6ab", "patch": "@@ -64,7 +64,6 @@ Stabilised APIs\n - [`VecDeque::shrink_to`]\n - [`HashMap::shrink_to`]\n - [`HashSet::shrink_to`]\n-- [`task::ready!`]\n \n These APIs are now usable in const contexts:\n \n@@ -128,7 +127,6 @@ and related tools.\n [`VecDeque::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.shrink_to\n [`HashMap::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html#method.shrink_to\n [`HashSet::shrink_to`]: https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.shrink_to\n-[`task::ready!`]: https://doc.rust-lang.org/stable/std/task/macro.ready.html\n [`std::mem::transmute`]: https://doc.rust-lang.org/stable/std/mem/fn.transmute.html\n [`slice::first`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first\n [`slice::split_first`]: https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_first"}, {"sha": "71a67a2793a46bfa83331c7a93d6f80d089ec2ef", "filename": "library/core/src/task/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fmod.rs?ref=d3984e16bf04f8ff886247cbf684041ba623d6ab", "patch": "@@ -11,5 +11,7 @@ mod wake;\n pub use self::wake::{Context, RawWaker, RawWakerVTable, Waker};\n \n mod ready;\n-#[stable(feature = \"ready_macro\", since = \"1.56.0\")]\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n pub use ready::ready;\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+pub use ready::Ready;"}, {"sha": "3e0b3e89758a64ac2e3824955320730fffd1f67a", "filename": "library/core/src/task/poll.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fpoll.rs?ref=d3984e16bf04f8ff886247cbf684041ba623d6ab", "patch": "@@ -3,6 +3,7 @@\n use crate::convert;\n use crate::ops::{self, ControlFlow};\n use crate::result::Result;\n+use crate::task::Ready;\n \n /// Indicates whether a value is available or if the current task has been\n /// scheduled to receive a wakeup instead.\n@@ -92,6 +93,38 @@ impl<T> Poll<T> {\n     pub const fn is_pending(&self) -> bool {\n         !self.is_ready()\n     }\n+\n+    /// Extracts the successful type of a [`Poll<T>`].\n+    ///\n+    /// When combined with the `?` operator, this function will\n+    /// propogate any [`Poll::Pending`] values to the caller, and\n+    /// extract the `T` from [`Poll::Ready`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(poll_ready)]\n+    ///\n+    /// use std::task::{Context, Poll};\n+    /// use std::future::{self, Future};\n+    /// use std::pin::Pin;\n+    ///\n+    /// pub fn do_poll(cx: &mut Context<'_>) -> Poll<()> {\n+    ///     let mut fut = future::ready(42);\n+    ///     let fut = Pin::new(&mut fut);\n+    ///\n+    ///     let num = fut.poll(cx).ready()?;\n+    ///     # drop(num);\n+    ///     // ... use num\n+    ///\n+    ///     Poll::Ready(())\n+    /// }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+    pub fn ready(self) -> Ready<T> {\n+        Ready(self)\n+    }\n }\n \n impl<T, E> Poll<Result<T, E>> {"}, {"sha": "174ca67546033d2aa4942b3a03971f8d1c8069b0", "filename": "library/core/src/task/ready.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3984e16bf04f8ff886247cbf684041ba623d6ab/library%2Fcore%2Fsrc%2Ftask%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fready.rs?ref=d3984e16bf04f8ff886247cbf684041ba623d6ab", "patch": "@@ -1,3 +1,8 @@\n+use core::convert;\n+use core::fmt;\n+use core::ops::{ControlFlow, FromResidual, Try};\n+use core::task::Poll;\n+\n /// Extracts the successful type of a [`Poll<T>`].\n ///\n /// This macro bakes in propagation of [`Pending`] signals by returning early.\n@@ -8,6 +13,8 @@\n /// # Examples\n ///\n /// ```\n+/// #![feature(ready_macro)]\n+///\n /// use std::task::{ready, Context, Poll};\n /// use std::future::{self, Future};\n /// use std::pin::Pin;\n@@ -27,6 +34,7 @@\n /// The `ready!` call expands to:\n ///\n /// ```\n+/// # #![feature(ready_macro)]\n /// # use std::task::{Context, Poll};\n /// # use std::future::{self, Future};\n /// # use std::pin::Pin;\n@@ -45,7 +53,7 @@\n ///     # Poll::Ready(())\n /// # }\n /// ```\n-#[stable(feature = \"ready_macro\", since = \"1.56.0\")]\n+#[unstable(feature = \"ready_macro\", issue = \"70922\")]\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro ready($e:expr) {\n     match $e {\n@@ -55,3 +63,55 @@ pub macro ready($e:expr) {\n         }\n     }\n }\n+\n+/// Extracts the successful type of a [`Poll<T>`].\n+///\n+/// See [`Poll::ready`] for details.\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+pub struct Ready<T>(pub(crate) Poll<T>);\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> Try for Ready<T> {\n+    type Output = T;\n+    type Residual = Ready<convert::Infallible>;\n+\n+    #[inline]\n+    fn from_output(output: Self::Output) -> Self {\n+        Ready(Poll::Ready(output))\n+    }\n+\n+    #[inline]\n+    fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n+        match self.0 {\n+            Poll::Ready(v) => ControlFlow::Continue(v),\n+            Poll::Pending => ControlFlow::Break(Ready(Poll::Pending)),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> FromResidual for Ready<T> {\n+    #[inline]\n+    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n+        match residual.0 {\n+            Poll::Pending => Ready(Poll::Pending),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> FromResidual<Ready<convert::Infallible>> for Poll<T> {\n+    #[inline]\n+    fn from_residual(residual: Ready<convert::Infallible>) -> Self {\n+        match residual.0 {\n+            Poll::Pending => Poll::Pending,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"poll_ready\", issue = \"89780\")]\n+impl<T> fmt::Debug for Ready<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Ready\").finish()\n+    }\n+}"}]}