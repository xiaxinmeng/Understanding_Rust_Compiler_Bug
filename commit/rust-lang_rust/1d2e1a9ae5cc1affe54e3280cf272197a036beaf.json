{"sha": "1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMmUxYTlhZTVjYzFhZmZlNTRlMzI4MGNmMjcyMTk3YTAzNmJlYWY=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-13T02:10:41Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-13T11:33:48Z"}, "message": "Avoid empty \"else\" blocks\n\nIf an \"if\" expression has no \"else\", we don't have to create an LLVM\nbasic block either.", "tree": {"sha": "1956623d749b90a3612bdcb0b706c52db92bb2d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1956623d749b90a3612bdcb0b706c52db92bb2d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "html_url": "https://github.com/rust-lang/rust/commit/1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d2e1a9ae5cc1affe54e3280cf272197a036beaf/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df2bb1bccd8394dbd73ffa52dea1151dcd0b0ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df2bb1bccd8394dbd73ffa52dea1151dcd0b0ad", "html_url": "https://github.com/rust-lang/rust/commit/5df2bb1bccd8394dbd73ffa52dea1151dcd0b0ad"}], "stats": {"total": 31, "additions": 19, "deletions": 12}, "files": [{"sha": "81260428f241bc06e814971ef0342c8fd918f7e0", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1d2e1a9ae5cc1affe54e3280cf272197a036beaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d2e1a9ae5cc1affe54e3280cf272197a036beaf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=1d2e1a9ae5cc1affe54e3280cf272197a036beaf", "patch": "@@ -67,13 +67,8 @@ pub fn trans_if(bcx: block,\n         expr::trans_to_datum(bcx, cond).to_result();\n \n     let then_bcx_in = scope_block(bcx, thn.info(), \"then\");\n-    let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n \n     let cond_val = bool_to_i1(bcx, cond_val);\n-    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n-\n-    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n-           then_bcx_in.to_str(), else_bcx_in.to_str());\n \n     let then_bcx_out = trans_block(then_bcx_in, thn, dest);\n     let then_bcx_out = trans_block_cleanups(then_bcx_out,\n@@ -83,9 +78,10 @@ pub fn trans_if(bcx: block,\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n     // 'else' context\n-    let else_bcx_out = match els {\n+    let (else_bcx_in, next_bcx) = match els {\n       Some(elexpr) => {\n-        match elexpr.node {\n+        let else_bcx_in = scope_block(bcx, els.info(), \"else\");\n+        let else_bcx_out = match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n             trans_block(else_bcx_in, &elseif_blk, dest)\n@@ -95,14 +91,25 @@ pub fn trans_if(bcx: block,\n           }\n           // would be nice to have a constraint on ifs\n           _ => bcx.tcx().sess.bug(\"strange alternative in if\")\n-        }\n+        };\n+        let else_bcx_out = trans_block_cleanups(else_bcx_out,\n+                                                block_cleanups(else_bcx_in));\n+\n+        (else_bcx_in, join_blocks(bcx, [then_bcx_out, else_bcx_out]))\n+      }\n+      _ => {\n+          let next_bcx = sub_block(bcx, \"next\");\n+          Br(then_bcx_out, next_bcx.llbb);\n+\n+          (next_bcx, next_bcx)\n       }\n-      _ => else_bcx_in\n     };\n-    let else_bcx_out = trans_block_cleanups(else_bcx_out,\n-                                            block_cleanups(else_bcx_in));\n-    return join_blocks(bcx, [then_bcx_out, else_bcx_out]);\n \n+    debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n+           then_bcx_in.to_str(), else_bcx_in.to_str());\n+\n+    CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+    next_bcx\n }\n \n pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {"}]}