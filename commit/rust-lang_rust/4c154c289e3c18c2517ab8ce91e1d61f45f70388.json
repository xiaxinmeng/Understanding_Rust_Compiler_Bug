{"sha": "4c154c289e3c18c2517ab8ce91e1d61f45f70388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMTU0YzI4OWUzYzE4YzI1MTdhYjhjZTkxZTFkNjFmNDVmNzAzODg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T11:13:13Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-18T11:13:13Z"}, "message": "remove arena from Roots\n\nwe want to move ra_vfs to a new repo, so having fewer deps is useful.\nArena is a thin layer of sugar on top of Vec anyway.", "tree": {"sha": "9bb92aca50f1df3404466d1fb6f54d5d97494290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bb92aca50f1df3404466d1fb6f54d5d97494290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c154c289e3c18c2517ab8ce91e1d61f45f70388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c154c289e3c18c2517ab8ce91e1d61f45f70388", "html_url": "https://github.com/rust-lang/rust/commit/4c154c289e3c18c2517ab8ce91e1d61f45f70388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c154c289e3c18c2517ab8ce91e1d61f45f70388/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d151b2a655057b9da45243d0f4e160b10a98ac37", "url": "https://api.github.com/repos/rust-lang/rust/commits/d151b2a655057b9da45243d0f4e160b10a98ac37", "html_url": "https://github.com/rust-lang/rust/commit/d151b2a655057b9da45243d0f4e160b10a98ac37"}], "stats": {"total": 34, "additions": 18, "deletions": 16}, "files": [{"sha": "1c5402aed94ed8742066e8610ebbfea0483dd9be", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4c154c289e3c18c2517ab8ce91e1d61f45f70388/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c154c289e3c18c2517ab8ce91e1d61f45f70388/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=4c154c289e3c18c2517ab8ce91e1d61f45f70388", "patch": "@@ -25,7 +25,7 @@ use std::{\n };\n \n use crossbeam_channel::Receiver;\n-use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n+use ra_arena::{impl_arena_id, Arena, RawId};\n use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n@@ -53,7 +53,7 @@ struct VfsFileData {\n pub struct Vfs {\n     roots: Arc<Roots>,\n     files: Arena<VfsFile, VfsFileData>,\n-    root2files: ArenaMap<VfsRoot, FxHashSet<VfsFile>>,\n+    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n     worker: Worker,\n }\n@@ -72,7 +72,7 @@ impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let roots = Arc::new(Roots::new(roots));\n         let worker = io::start(Arc::clone(&roots));\n-        let mut root2files = ArenaMap::default();\n+        let mut root2files = FxHashMap::default();\n \n         for root in roots.iter() {\n             root2files.insert(root, Default::default());\n@@ -164,7 +164,7 @@ impl Vfs {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the background, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let existing = self.root2files[root]\n+                let existing = self.root2files[&root]\n                     .iter()\n                     .map(|&file| (self.files[file].path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n@@ -241,7 +241,7 @@ impl Vfs {\n     ) -> VfsFile {\n         let data = VfsFileData { root, path, text, is_overlayed };\n         let file = self.files.alloc(data);\n-        self.root2files.get_mut(root).unwrap().insert(file);\n+        self.root2files.get_mut(&root).unwrap().insert(file);\n         file\n     }\n \n@@ -256,7 +256,7 @@ impl Vfs {\n         self.files[file].text = Default::default();\n         self.files[file].path = Default::default();\n         let root = self.files[file].root;\n-        let removed = self.root2files.get_mut(root).unwrap().remove(&file);\n+        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n         assert!(removed);\n     }\n \n@@ -267,7 +267,7 @@ impl Vfs {\n     }\n \n     fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[root].iter().map(|&it| it).find(|&file| self.files[file].path == path)\n+        self.root2files[&root].iter().map(|&it| it).find(|&file| self.files[file].path == path)\n     }\n }\n "}, {"sha": "4503458eed173e62513a180a3e96edf607046ee6", "filename": "crates/ra_vfs/src/roots.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c154c289e3c18c2517ab8ce91e1d61f45f70388/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c154c289e3c18c2517ab8ce91e1d61f45f70388/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=4c154c289e3c18c2517ab8ce91e1d61f45f70388", "patch": "@@ -4,12 +4,10 @@ use std::{\n };\n \n use relative_path::{ RelativePath, RelativePathBuf};\n-use ra_arena::{impl_arena_id, Arena, RawId};\n \n /// VfsRoot identifies a watched directory on the file system.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n+pub struct VfsRoot(pub u32);\n \n /// Describes the contents of a single source root.\n ///\n@@ -24,20 +22,20 @@ struct RootData {\n }\n \n pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, RootData>,\n+    roots: Vec<RootData>,\n }\n \n impl Roots {\n     pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Arena::default();\n+        let mut roots = Vec::new();\n         // A hack to make nesting work.\n         paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n         paths.dedup();\n         for (i, path) in paths.iter().enumerate() {\n             let nested_roots =\n                 paths[..i].iter().filter_map(|it| rel_path(path, it)).collect::<Vec<_>>();\n \n-            roots.alloc(RootData::new(path.clone(), nested_roots));\n+            roots.push(RootData::new(path.clone(), nested_roots));\n         }\n         Roots { roots }\n     }\n@@ -51,20 +49,24 @@ impl Roots {\n         self.roots.len()\n     }\n     pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = VfsRoot> + 'a {\n-        self.roots.iter().map(|(id, _)| id)\n+        (0..self.roots.len()).into_iter().map(|idx| VfsRoot(idx as u32))\n     }\n     pub(crate) fn path(&self, root: VfsRoot) -> &Path {\n-        self.roots[root].path.as_path()\n+        self.root(root).path.as_path()\n     }\n     /// Checks if root contains a path and returns a root-relative path.\n     pub(crate) fn contains(&self, root: VfsRoot, path: &Path) -> Option<RelativePathBuf> {\n-        let data = &self.roots[root];\n+        let data = self.root(root);\n         iter::once(&data.path)\n             .chain(data.canonical_path.as_ref().into_iter())\n             .find_map(|base| rel_path(base, path))\n             .filter(|path| !data.excluded_dirs.contains(path))\n             .filter(|path| !data.is_excluded(path))\n     }\n+\n+    fn root(&self, root: VfsRoot) -> &RootData {\n+        &self.roots[root.0 as usize]\n+    }\n }\n \n impl RootData {"}]}