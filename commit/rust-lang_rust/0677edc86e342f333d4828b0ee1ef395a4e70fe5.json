{"sha": "0677edc86e342f333d4828b0ee1ef395a4e70fe5", "node_id": "C_kwDOAAsO6NoAKDA2NzdlZGM4NmUzNDJmMzMzZDQ4MjhiMGVlMWVmMzk1YTRlNzBmZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-31T17:45:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-31T17:45:26Z"}, "message": "Auto merge of #95526 - Dylan-DPC:rollup-0ikl5l5, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #91416 (Specialize infinite-type \"insert some indirection\" suggestion for Option)\n - #95384 (Update target_has_atomic documentation for stabilization)\n - #95517 (small rustc_borrowck cleanup)\n - #95520 (Fix typos in core::ptr docs)\n - #95523 (remove unused field from `infcx`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "56ff127af90384d75ba662e6f8cd7633bf1e20a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ff127af90384d75ba662e6f8cd7633bf1e20a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "html_url": "https://github.com/rust-lang/rust/commit/0677edc86e342f333d4828b0ee1ef395a4e70fe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0677edc86e342f333d4828b0ee1ef395a4e70fe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1a8692f6260fd59dba1e0fa187092a1c354b2e", "html_url": "https://github.com/rust-lang/rust/commit/bd1a8692f6260fd59dba1e0fa187092a1c354b2e"}, {"sha": "1074c814af33dfef7007ae261aecfff368bb80a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1074c814af33dfef7007ae261aecfff368bb80a1", "html_url": "https://github.com/rust-lang/rust/commit/1074c814af33dfef7007ae261aecfff368bb80a1"}], "stats": {"total": 396, "additions": 282, "deletions": 114}, "files": [{"sha": "f8439d2e163559f5c51faa2364f18c15b2dc1aed", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -253,8 +253,10 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         let constraint_sets: Vec<_> = unnormalized_input_output_tys\n             .flat_map(|ty| {\n                 debug!(\"build: input_or_output={:?}\", ty);\n-                // We add implied bounds from both the unnormalized and normalized ty\n-                // See issue #87748\n+                // We only add implied bounds for the normalized type as the unnormalized\n+                // type may not actually get checked by the caller.\n+                //\n+                // Can otherwise be unsound, see #91068.\n                 let TypeOpOutput { output: norm_ty, constraints: constraints1, .. } = self\n                     .param_env\n                     .and(type_op::normalize::Normalize::new(ty))"}, {"sha": "e9fa33f656f31006b12a39d0536091830056e4f6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -1899,7 +1899,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                     ObligationCause::new(\n                                         span,\n                                         self.tcx().hir().local_def_id_to_hir_id(def_id),\n-                                        traits::ObligationCauseCode::RepeatVec(is_const_fn),\n+                                        traits::ObligationCauseCode::RepeatElementCopy {\n+                                            is_const_fn,\n+                                        },\n                                     ),\n                                     self.param_env,\n                                     ty::Binder::dummy(ty::TraitRef::new("}, {"sha": "09b02ba74a8de0d079cdaebe2533497025d95745", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -65,7 +65,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         Self {\n             tcx: self.tcx.clone(),\n             defining_use_anchor: self.defining_use_anchor.clone(),\n-            reveal_defining_opaque_types: self.reveal_defining_opaque_types.clone(),\n             in_progress_typeck_results: self.in_progress_typeck_results.clone(),\n             inner: self.inner.clone(),\n             skip_leak_check: self.skip_leak_check.clone(),"}, {"sha": "bd59bf4dea8837c552f9225b433a59dfc94b2e6c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -290,10 +290,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n     pub defining_use_anchor: Option<LocalDefId>,\n \n-    /// Used by WF-checking to not have to figure out hidden types itself, but\n-    /// to just invoke type_of to get the already computed hidden type from typeck.\n-    pub reveal_defining_opaque_types: bool,\n-\n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n     /// used for reading closure kinds/signatures as they are inferred,\n@@ -569,7 +565,6 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n     defining_use_anchor: Option<LocalDefId>,\n-    reveal_defining_opaque_types: bool,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -578,12 +573,7 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder {\n-            tcx: self,\n-            defining_use_anchor: None,\n-            fresh_typeck_results: None,\n-            reveal_defining_opaque_types: false,\n-        }\n+        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n     }\n }\n \n@@ -607,13 +597,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n-    /// WF-checking doesn't need to recompute opaque types and can instead use\n-    /// the type_of query to get them from typeck.\n-    pub fn reveal_defining_opaque_types(mut self) -> Self {\n-        self.reveal_defining_opaque_types = true;\n-        self\n-    }\n-\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -638,17 +621,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder {\n-            tcx,\n-            defining_use_anchor,\n-            reveal_defining_opaque_types,\n-            ref fresh_typeck_results,\n-        } = *self;\n+        let InferCtxtBuilder { tcx, defining_use_anchor, ref fresh_typeck_results } = *self;\n         let in_progress_typeck_results = fresh_typeck_results.as_ref();\n         f(InferCtxt {\n             tcx,\n             defining_use_anchor,\n-            reveal_defining_opaque_types,\n             in_progress_typeck_results,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),"}, {"sha": "1f18260d9154f52929ea480d70e87dcbfeca8af3", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -236,11 +236,12 @@ pub enum ObligationCauseCode<'tcx> {\n     SizedBoxType,\n     /// Inline asm operand type must be `Sized`.\n     InlineAsmSized,\n-    /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If the function in the array repeat expression is a `const fn`,\n-    /// display a help message suggesting to move the function call to a\n-    /// new `const` item while saying that `T` doesn't implement `Copy`.\n-    RepeatVec(bool),\n+    /// `[expr; N]` requires `type_of(expr): Copy`.\n+    RepeatElementCopy {\n+        /// If element is a `const fn` we display a help message suggesting to move the\n+        /// function call to a new `const` item while saying that `T` doesn't implement `Copy`.\n+        is_const_fn: bool,\n+    },\n \n     /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n     FieldSized {"}, {"sha": "72b597bb13d29caa22e322184925da867738a2d0", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         let kind = match pat.kind {\n             hir::PatKind::Wild => PatKind::Wild,\n \n-            hir::PatKind::Lit(ref value) => self.lower_lit(value),\n+            hir::PatKind::Lit(value) => self.lower_lit(value),\n \n             hir::PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n                 let (lo_expr, hi_expr) = (lo_expr.as_deref(), hi_expr.as_deref());"}, {"sha": "d83781170e8c3f56d94a254ecadb97e657147522", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 48, "deletions": 11, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -2285,10 +2285,10 @@ impl<'v> Visitor<'v> for FindTypeParam {\n     }\n }\n \n-pub fn recursive_type_with_infinite_size_error(\n-    tcx: TyCtxt<'_>,\n+pub fn recursive_type_with_infinite_size_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     type_def_id: DefId,\n-    spans: Vec<Span>,\n+    spans: Vec<(Span, Option<hir::HirId>)>,\n ) {\n     assert!(type_def_id.is_local());\n     let span = tcx.hir().span_if_local(type_def_id).unwrap();\n@@ -2297,24 +2297,33 @@ pub fn recursive_type_with_infinite_size_error(\n     let mut err =\n         struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\", path);\n     err.span_label(span, \"recursive type has infinite size\");\n-    for &span in &spans {\n+    for &(span, _) in &spans {\n         err.span_label(span, \"recursive without indirection\");\n     }\n     let msg = format!(\n         \"insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `{}` representable\",\n         path,\n     );\n     if spans.len() <= 4 {\n+        // FIXME(compiler-errors): This suggestion might be erroneous if Box is shadowed\n         err.multipart_suggestion(\n             &msg,\n             spans\n-                .iter()\n-                .flat_map(|&span| {\n-                    [\n-                        (span.shrink_to_lo(), \"Box<\".to_string()),\n-                        (span.shrink_to_hi(), \">\".to_string()),\n-                    ]\n-                    .into_iter()\n+                .into_iter()\n+                .flat_map(|(span, field_id)| {\n+                    if let Some(generic_span) = get_option_generic_from_field_id(tcx, field_id) {\n+                        // If we match an `Option` and can grab the span of the Option's generic, then\n+                        // suggest boxing the generic arg for a non-null niche optimization.\n+                        vec![\n+                            (generic_span.shrink_to_lo(), \"Box<\".to_string()),\n+                            (generic_span.shrink_to_hi(), \">\".to_string()),\n+                        ]\n+                    } else {\n+                        vec![\n+                            (span.shrink_to_lo(), \"Box<\".to_string()),\n+                            (span.shrink_to_hi(), \">\".to_string()),\n+                        ]\n+                    }\n                 })\n                 .collect(),\n             Applicability::HasPlaceholders,\n@@ -2325,6 +2334,34 @@ pub fn recursive_type_with_infinite_size_error(\n     err.emit();\n }\n \n+/// Extract the span for the generic type `T` of `Option<T>` in a field definition\n+fn get_option_generic_from_field_id(tcx: TyCtxt<'_>, field_id: Option<hir::HirId>) -> Option<Span> {\n+    let node = tcx.hir().find(field_id?);\n+\n+    // Expect a field from our field_id\n+    let Some(hir::Node::Field(field_def)) = node\n+        else { bug!(\"Expected HirId corresponding to FieldDef, found: {:?}\", node) };\n+\n+    // Match a type that is a simple QPath with no Self\n+    let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = &field_def.ty.kind\n+        else { return None };\n+\n+    // Check if the path we're checking resolves to Option\n+    let hir::def::Res::Def(_, did) = path.res\n+        else { return None };\n+\n+    // Bail if this path doesn't describe `::core::option::Option`\n+    if !tcx.is_diagnostic_item(sym::Option, did) {\n+        return None;\n+    }\n+\n+    // Match a single generic arg in the 0th path segment\n+    let generic_arg = path.segments.last()?.args?.args.get(0)?;\n+\n+    // Take the span out of the type, if it's a type\n+    if let hir::GenericArg::Type(generic_ty) = generic_arg { Some(generic_ty.span) } else { None }\n+}\n+\n /// Summarizes information\n #[derive(Clone)]\n pub enum ArgKind {"}, {"sha": "58e002b3360818382bdc4363bf0d410fbbb8bc6b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -1988,7 +1988,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::Coercion { source: _, target } => {\n                 err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n             }\n-            ObligationCauseCode::RepeatVec(is_const_fn) => {\n+            ObligationCauseCode::RepeatElementCopy { is_const_fn } => {\n                 err.note(\n                     \"the `Copy` trait is required because the repeated element will be copied\",\n                 );"}, {"sha": "7efc82efd15c30c60034df6da010b48acccdfdd2", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -17,12 +17,20 @@ use std::cmp;\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n-    SelfRecursive(Vec<Span>),\n+    /// Return a list of types that are included in themselves:\n+    /// the spans where they are self-included, and (if found)\n+    /// the HirId of the FieldDef that defines the self-inclusion.\n+    SelfRecursive(Vec<(Span, Option<hir::HirId>)>),\n }\n \n /// Check whether a type is representable. This means it cannot contain unboxed\n /// structural recursion. This check is needed for structs and enums.\n-pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> Representability {\n+pub fn ty_is_representable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n+) -> Representability {\n     debug!(\"is_type_representable: {:?}\", ty);\n     // To avoid a stack overflow when checking an enum variant or struct that\n     // contains a different, structurally recursive type, maintain a stack of\n@@ -38,11 +46,12 @@ pub fn ty_is_representable<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, sp: Span) -> R\n     let mut force_result = false;\n     let r = is_type_structurally_recursive(\n         tcx,\n-        sp,\n         &mut seen,\n         &mut shadow_seen,\n         &mut representable_cache,\n         ty,\n+        sp,\n+        field_id,\n         &mut force_result,\n     );\n     debug!(\"is_type_representable: {:?} is {:?}\", ty, r);\n@@ -61,11 +70,12 @@ fn fold_repr<It: Iterator<Item = Representability>>(iter: It) -> Representabilit\n \n fn are_inner_types_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n     debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n@@ -75,11 +85,12 @@ fn are_inner_types_recursive<'tcx>(\n             fold_repr(fields.iter().map(|ty| {\n                 is_type_structurally_recursive(\n                     tcx,\n-                    sp,\n                     seen,\n                     shadow_seen,\n                     representable_cache,\n                     ty,\n+                    sp,\n+                    field_id,\n                     force_result,\n                 )\n             }))\n@@ -88,20 +99,26 @@ fn are_inner_types_recursive<'tcx>(\n         // FIXME(#11924) Behavior undecided for zero-length vectors.\n         ty::Array(ty, _) => is_type_structurally_recursive(\n             tcx,\n-            sp,\n             seen,\n             shadow_seen,\n             representable_cache,\n             *ty,\n+            sp,\n+            field_id,\n             force_result,\n         ),\n         ty::Adt(def, substs) => {\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n                 let ty = field.ty(tcx, substs);\n-                let span = match field.did.as_local().and_then(|id| tcx.hir().find_by_def_id(id)) {\n-                    Some(hir::Node::Field(field)) => field.ty.span,\n-                    _ => sp,\n+                let (sp, field_id) = match field\n+                    .did\n+                    .as_local()\n+                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                    .and_then(|id| tcx.hir().find(id))\n+                {\n+                    Some(hir::Node::Field(field)) => (field.ty.span, Some(field.hir_id)),\n+                    _ => (sp, field_id),\n                 };\n \n                 let mut result = None;\n@@ -130,7 +147,7 @@ fn are_inner_types_recursive<'tcx>(\n                 // result without adjusting).\n                 if shadow_seen.len() > seen.len() && shadow_seen.first() == Some(def) {\n                     *force_result = true;\n-                    result = Some(Representability::SelfRecursive(vec![span]));\n+                    result = Some(Representability::SelfRecursive(vec![(sp, field_id)]));\n                 }\n \n                 if result == None {\n@@ -161,16 +178,17 @@ fn are_inner_types_recursive<'tcx>(\n                         result = Some(\n                             match is_type_structurally_recursive(\n                                 tcx,\n-                                span,\n                                 &mut nested_seen,\n                                 shadow_seen,\n                                 representable_cache,\n                                 raw_adt_ty,\n+                                sp,\n+                                field_id,\n                                 force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n                                     if *force_result {\n-                                        Representability::SelfRecursive(vec![span])\n+                                        Representability::SelfRecursive(vec![(sp, field_id)])\n                                     } else {\n                                         Representability::ContainsRecursive\n                                     }\n@@ -208,15 +226,16 @@ fn are_inner_types_recursive<'tcx>(\n                         result = Some(\n                             match is_type_structurally_recursive(\n                                 tcx,\n-                                span,\n                                 seen,\n                                 shadow_seen,\n                                 representable_cache,\n                                 ty,\n+                                sp,\n+                                field_id,\n                                 force_result,\n                             ) {\n                                 Representability::SelfRecursive(_) => {\n-                                    Representability::SelfRecursive(vec![span])\n+                                    Representability::SelfRecursive(vec![(sp, field_id)])\n                                 }\n                                 x => x,\n                             },\n@@ -247,29 +266,31 @@ fn same_adt<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n // contain any types on stack `seen`?\n fn is_type_structurally_recursive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n-    debug!(\"is_type_structurally_recursive: {:?} {:?}\", ty, sp);\n+    debug!(\"is_type_structurally_recursive: {:?} {:?} {:?}\", ty, sp, field_id);\n     if let Some(representability) = representable_cache.get(&ty) {\n         debug!(\n-            \"is_type_structurally_recursive: {:?} {:?} - (cached) {:?}\",\n-            ty, sp, representability\n+            \"is_type_structurally_recursive: {:?} {:?} {:?} - (cached) {:?}\",\n+            ty, sp, field_id, representability\n         );\n         return representability.clone();\n     }\n \n     let representability = is_type_structurally_recursive_inner(\n         tcx,\n-        sp,\n         seen,\n         shadow_seen,\n         representable_cache,\n         ty,\n+        sp,\n+        field_id,\n         force_result,\n     );\n \n@@ -279,11 +300,12 @@ fn is_type_structurally_recursive<'tcx>(\n \n fn is_type_structurally_recursive_inner<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    sp: Span,\n     seen: &mut Vec<Ty<'tcx>>,\n     shadow_seen: &mut Vec<ty::AdtDef<'tcx>>,\n     representable_cache: &mut FxHashMap<Ty<'tcx>, Representability>,\n     ty: Ty<'tcx>,\n+    sp: Span,\n+    field_id: Option<hir::HirId>,\n     force_result: &mut bool,\n ) -> Representability {\n     match ty.kind() {\n@@ -305,7 +327,7 @@ fn is_type_structurally_recursive_inner<'tcx>(\n                 if let Some(&seen_adt) = iter.next() {\n                     if same_adt(seen_adt, *def) {\n                         debug!(\"SelfRecursive: {:?} contains {:?}\", seen_adt, ty);\n-                        return Representability::SelfRecursive(vec![sp]);\n+                        return Representability::SelfRecursive(vec![(sp, field_id)]);\n                     }\n                 }\n \n@@ -335,11 +357,12 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             shadow_seen.push(*def);\n             let out = are_inner_types_recursive(\n                 tcx,\n-                sp,\n                 seen,\n                 shadow_seen,\n                 representable_cache,\n                 ty,\n+                sp,\n+                field_id,\n                 force_result,\n             );\n             shadow_seen.pop();\n@@ -350,11 +373,12 @@ fn is_type_structurally_recursive_inner<'tcx>(\n             // No need to push in other cases.\n             are_inner_types_recursive(\n                 tcx,\n-                sp,\n                 seen,\n                 shadow_seen,\n                 representable_cache,\n                 ty,\n+                sp,\n+                field_id,\n                 force_result,\n             )\n         }"}, {"sha": "7cb478d78880acbea2f8d1dab399287d91aacb42", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -1045,7 +1045,7 @@ pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalD\n     // recursive type. It is only necessary to throw an error on those that\n     // contain themselves. For case 2, there must be an inner type that will be\n     // caught by case 1.\n-    match representability::ty_is_representable(tcx, rty, sp) {\n+    match representability::ty_is_representable(tcx, rty, sp, None) {\n         Representability::SelfRecursive(spans) => {\n             recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n             return false;"}, {"sha": "e7cfa3a7c14939fde344f4f93b00856280f65730", "filename": "compiler/rustc_typeck/src/check/inherited.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Finherited.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -95,13 +95,6 @@ impl<'tcx> InheritedBuilder<'tcx> {\n         let def_id = self.def_id;\n         self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n-\n-    /// WF-checking doesn't need to recompute opaque types and can instead use\n-    /// the type_of query to get them from typeck.\n-    pub fn reveal_defining_opaque_types(mut self) -> Self {\n-        self.infcx = self.infcx.reveal_defining_opaque_types();\n-        self\n-    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx> {"}, {"sha": "bd08da9529a5f89635ffa47d5a3b1cf74eedef7a", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -968,7 +968,7 @@ fn for_item<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>) -> CheckWfFcxBuilder<\n \n fn for_id(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) -> CheckWfFcxBuilder<'_> {\n     CheckWfFcxBuilder {\n-        inherited: Inherited::build(tcx, def_id).reveal_defining_opaque_types(),\n+        inherited: Inherited::build(tcx, def_id),\n         id: hir::HirId::make_owner(def_id),\n         span,\n         param_env: tcx.param_env(def_id),"}, {"sha": "68d80022b4c80d9992110b8911a794cdd7f88c5f", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -84,7 +84,7 @@\n //! have to change, and is it worse or better now? Would any patterns become truly inexpressible?\n //! Could we carve out special exceptions for those patterns? Should we?\n //!\n-//! A secondary goal of this project is to see if we can disamiguate the many functions of\n+//! A secondary goal of this project is to see if we can disambiguate the many functions of\n //! pointer<->integer casts enough for the definition of `usize` to be loosened so that it\n //! isn't *pointer*-sized but address-space/offset/allocation-sized (we'll probably continue\n //! to conflate these notions). This would potentially make it possible to more efficiently\n@@ -163,7 +163,7 @@\n //! of pointers and `usize` (and `isize`), and defining a pointer to semantically contain the\n //! following information:\n //!\n-//! * The **address-space** it is part of (i.e. \"data\" vs \"code\" in WASM).\n+//! * The **address-space** it is part of (e.g. \"data\" vs \"code\" in WASM).\n //! * The **address** it points to, which can be represented by a `usize`.\n //! * The **provenance** it has, defining the memory it has permission to access.\n //!\n@@ -246,7 +246,7 @@\n //! be using AtomicPtr instead. If that messes up the way you atomically manipulate pointers,\n //! we would like to know why, and what needs to be done to fix it.)\n //!\n-//! Something more complicated and just generally *evil* like a XOR-List requires more significant\n+//! Something more complicated and just generally *evil* like an XOR-List requires more significant\n //! changes like allocating all nodes in a pre-allocated Vec or Arena and using a pointer\n //! to the whole allocation to reconstitute the XORed addresses.\n //!\n@@ -257,7 +257,7 @@\n //! special attention at all, because they're generally accessing memory outside the scope of\n //! \"the abstract machine\", or already using \"I know what I'm doing\" annotations like \"volatile\".\n //!\n-//! Under [Strict Provenance] is is Undefined Behaviour to:\n+//! Under [Strict Provenance] it is Undefined Behaviour to:\n //!\n //! * Access memory through a pointer that does not have provenance over that memory.\n //!"}, {"sha": "c11a35ab947a808160bd1051916664ee3c71b239", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -65,9 +65,10 @@\n //! For reference, the `std` library requires `AtomicBool`s and pointer-sized atomics, although\n //! `core` does not.\n //!\n-//! Currently you'll need to use `#[cfg(target_arch)]` primarily to\n-//! conditionally compile in code with atomics. There is an unstable\n-//! `#[cfg(target_has_atomic)]` as well which may be stabilized in the future.\n+//! The `#[cfg(target_has_atomic)]` attribute can be used to conditionally\n+//! compile based on the target's supported bit widths. It is a key-value\n+//! option set for each supported size, with values \"8\", \"16\", \"32\", \"64\",\n+//! \"128\", and \"ptr\" for pointer-sized atomics.\n //!\n //! [lock-free]: https://en.wikipedia.org/wiki/Non-blocking_algorithm\n //!"}, {"sha": "db32eb952ba79796caa6b7fdac16eb13d004536b", "filename": "src/test/ui/issues/issue-17431-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-1.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -8,8 +8,8 @@ LL | struct Foo { foo: Option<Option<Foo>> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { foo: Box<Option<Option<Foo>>> }\n-   |                   ++++                   +\n+LL | struct Foo { foo: Option<Box<Option<Foo>>> }\n+   |                          ++++           +\n \n error: aborting due to previous error\n "}, {"sha": "d23fd1474ac12fe497ea1dd217fadefd9a092811", "filename": "src/test/ui/issues/issue-17431-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-2.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -8,8 +8,8 @@ LL | struct Baz { q: Option<Foo> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n    |\n-LL | struct Baz { q: Box<Option<Foo>> }\n-   |                 ++++           +\n+LL | struct Baz { q: Option<Box<Foo>> }\n+   |                        ++++   +\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/issue-17431-2.rs:4:1\n@@ -21,8 +21,8 @@ LL | struct Foo { q: Option<Baz> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { q: Box<Option<Baz>> }\n-   |                 ++++           +\n+LL | struct Foo { q: Option<Box<Baz>> }\n+   |                        ++++   +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ddf669b8fd1cb6733773b069185e7a1b0ec73dcc", "filename": "src/test/ui/issues/issue-17431-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-4.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -8,8 +8,8 @@ LL | struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T>\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo<T> { foo: Box<Option<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n-   |                      ++++                      +\n+LL | struct Foo<T> { foo: Option<Box<Option<Foo<T>>>>, marker: marker::PhantomData<T> }\n+   |                             ++++              +\n \n error: aborting due to previous error\n "}, {"sha": "6f8a7e3867b099eb6987f52bc1137f8881f475b3", "filename": "src/test/ui/issues/issue-17431-7.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17431-7.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -8,8 +8,8 @@ LL | enum Foo { Voo(Option<Option<Foo>>) }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | enum Foo { Voo(Box<Option<Option<Foo>>>) }\n-   |                ++++                   +\n+LL | enum Foo { Voo(Option<Box<Option<Foo>>>) }\n+   |                       ++++           +\n \n error: aborting due to previous error\n "}, {"sha": "e853d0f8c8932d98ff5bd743ca95385264edffd4", "filename": "src/test/ui/issues/issue-3779.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3779.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -9,8 +9,8 @@ LL |     element: Option<S>\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `S` representable\n    |\n-LL |     element: Box<Option<S>>\n-   |              ++++         +\n+LL |     element: Option<Box<S>>\n+   |                     ++++ +\n \n error: aborting due to previous error\n "}, {"sha": "536510814c57ca7f8ea2705653cff351d92ace7c", "filename": "src/test/ui/sized-cycle-note.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fsized-cycle-note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsized-cycle-note.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -8,8 +8,8 @@ LL | struct Baz { q: Option<Foo> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Baz` representable\n    |\n-LL | struct Baz { q: Box<Option<Foo>> }\n-   |                 ++++           +\n+LL | struct Baz { q: Option<Box<Foo>> }\n+   |                        ++++   +\n \n error[E0072]: recursive type `Foo` has infinite size\n   --> $DIR/sized-cycle-note.rs:11:1\n@@ -21,8 +21,8 @@ LL | struct Foo { q: Option<Baz> }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n    |\n-LL | struct Foo { q: Box<Option<Baz>> }\n-   |                 ++++           +\n+LL | struct Foo { q: Option<Box<Baz>> }\n+   |                        ++++   +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "882ed577cf36626d00bf63a6fb55d23c2f3c2f6b", "filename": "src/test/ui/span/E0072.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fspan%2FE0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0072.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -9,8 +9,8 @@ LL |     tail: Option<ListNode>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n    |\n-LL |     tail: Box<Option<ListNode>>,\n-   |           ++++                +\n+LL |     tail: Option<Box<ListNode>>,\n+   |                  ++++        +\n \n error: aborting due to previous error\n "}, {"sha": "acfc60b51f330892710429c476ccfbc1ba26f27e", "filename": "src/test/ui/span/multiline-span-E0072.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-E0072.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -12,8 +12,8 @@ LL | | }\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `ListNode` representable\n    |\n-LL |     tail: Box<Option<ListNode>>,\n-   |           ++++                +\n+LL |     tail: Option<Box<ListNode>>,\n+   |                  ++++        +\n \n error: aborting due to previous error\n "}, {"sha": "80a494f3f65eb20d83ecf57aa34b381a456f5ed3", "filename": "src/test/ui/structs-enums/struct-rec/mutual-struct-recursion.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fstruct-rec%2Fmutual-struct-recursion.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -37,8 +37,8 @@ LL |     y: Option<Option<D<T>>>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `C` representable\n    |\n-LL |     y: Box<Option<Option<D<T>>>>,\n-   |        ++++                    +\n+LL |     y: Option<Box<Option<D<T>>>>,\n+   |               ++++            +\n \n error[E0072]: recursive type `D` has infinite size\n   --> $DIR/mutual-struct-recursion.rs:18:1\n@@ -51,8 +51,8 @@ LL |     z: Option<Option<C<T>>>,\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `D` representable\n    |\n-LL |     z: Box<Option<Option<C<T>>>>,\n-   |        ++++                    +\n+LL |     z: Option<Box<Option<C<T>>>>,\n+   |               ++++            +\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e141c2149ffea54fec419abc699dea58196554ff", "filename": "src/test/ui/type/type-recursive-box-shadowed.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -0,0 +1,12 @@\n+//FIXME(compiler-errors): This fixup should suggest the full box path, not just `Box`\n+\n+struct Box<T> {\n+    t: T,\n+}\n+\n+struct Foo {\n+    //~^ ERROR recursive type `Foo` has infinite size\n+    inner: Foo,\n+}\n+\n+fn main() {}"}, {"sha": "c22d848f3797e645b017201532a419167d16d9cd", "filename": "src/test/ui/type/type-recursive-box-shadowed.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive-box-shadowed.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -0,0 +1,17 @@\n+error[E0072]: recursive type `Foo` has infinite size\n+  --> $DIR/type-recursive-box-shadowed.rs:7:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^ recursive type has infinite size\n+LL |\n+LL |     inner: Foo,\n+   |            --- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `Foo` representable\n+   |\n+LL |     inner: Box<Foo>,\n+   |            ++++   +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0072`."}, {"sha": "e8084f0d0826af0b18b2d0ebaf513c31a59c3175", "filename": "src/test/ui/type/type-recursive.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.rs?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -1,6 +1,30 @@\n struct T1 { //~ ERROR E0072\n     foo: isize,\n-    foolish: T1\n+    foolish: T1,\n+}\n+\n+struct T2 { //~ ERROR E0072\n+    inner: Option<T2>,\n+}\n+\n+type OptionT3 = Option<T3>;\n+\n+struct T3 { //~ ERROR E0072\n+    inner: OptionT3,\n+}\n+\n+struct T4(Option<T4>); //~ ERROR E0072\n+\n+enum T5 { //~ ERROR E0072\n+    Variant(Option<T5>),\n+}\n+\n+enum T6 { //~ ERROR E0072\n+    Variant{ field: Option<T6> },\n+}\n+\n+struct T7 { //~ ERROR E0072\n+    foo: std::cell::Cell<Option<T7>>,\n }\n \n fn main() { }"}, {"sha": "04392f7390dfc3fd52cbc764c46909f62116111b", "filename": "src/test/ui/type/type-recursive.stderr", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0677edc86e342f333d4828b0ee1ef395a4e70fe5/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-recursive.stderr?ref=0677edc86e342f333d4828b0ee1ef395a4e70fe5", "patch": "@@ -4,14 +4,93 @@ error[E0072]: recursive type `T1` has infinite size\n LL | struct T1 {\n    | ^^^^^^^^^ recursive type has infinite size\n LL |     foo: isize,\n-LL |     foolish: T1\n+LL |     foolish: T1,\n    |              -- recursive without indirection\n    |\n help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T1` representable\n    |\n-LL |     foolish: Box<T1>\n+LL |     foolish: Box<T1>,\n    |              ++++  +\n \n-error: aborting due to previous error\n+error[E0072]: recursive type `T2` has infinite size\n+  --> $DIR/type-recursive.rs:6:1\n+   |\n+LL | struct T2 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     inner: Option<T2>,\n+   |            ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T2` representable\n+   |\n+LL |     inner: Option<Box<T2>>,\n+   |                   ++++  +\n+\n+error[E0072]: recursive type `T3` has infinite size\n+  --> $DIR/type-recursive.rs:12:1\n+   |\n+LL | struct T3 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     inner: OptionT3,\n+   |            -------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T3` representable\n+   |\n+LL |     inner: Box<OptionT3>,\n+   |            ++++        +\n+\n+error[E0072]: recursive type `T4` has infinite size\n+  --> $DIR/type-recursive.rs:16:1\n+   |\n+LL | struct T4(Option<T4>);\n+   | ^^^^^^^^^^----------^^\n+   | |         |\n+   | |         recursive without indirection\n+   | recursive type has infinite size\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T4` representable\n+   |\n+LL | struct T4(Option<Box<T4>>);\n+   |                  ++++  +\n+\n+error[E0072]: recursive type `T5` has infinite size\n+  --> $DIR/type-recursive.rs:18:1\n+   |\n+LL | enum T5 {\n+   | ^^^^^^^ recursive type has infinite size\n+LL |     Variant(Option<T5>),\n+   |             ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T5` representable\n+   |\n+LL |     Variant(Option<Box<T5>>),\n+   |                    ++++  +\n+\n+error[E0072]: recursive type `T6` has infinite size\n+  --> $DIR/type-recursive.rs:22:1\n+   |\n+LL | enum T6 {\n+   | ^^^^^^^ recursive type has infinite size\n+LL |     Variant{ field: Option<T6> },\n+   |                     ---------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T6` representable\n+   |\n+LL |     Variant{ field: Option<Box<T6>> },\n+   |                            ++++  +\n+\n+error[E0072]: recursive type `T7` has infinite size\n+  --> $DIR/type-recursive.rs:26:1\n+   |\n+LL | struct T7 {\n+   | ^^^^^^^^^ recursive type has infinite size\n+LL |     foo: std::cell::Cell<Option<T7>>,\n+   |          --------------------------- recursive without indirection\n+   |\n+help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to make `T7` representable\n+   |\n+LL |     foo: Box<std::cell::Cell<Option<T7>>>,\n+   |          ++++                           +\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0072`."}]}