{"sha": "ed30152b52f650be4e8e2eee8616f7fa41f89569", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMzAxNTJiNTJmNjUwYmU0ZThlMmVlZTg2MTZmN2ZhNDFmODk1Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-04T08:55:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-04T08:55:18Z"}, "message": "Auto merge of #876 - RalfJung:atomic, r=RalfJung\n\ncheck that atomics are sufficiently aligned\n\nFixes https://github.com/rust-lang/miri/issues/475", "tree": {"sha": "b06cdc63d1ae489e771216bc86c4c90fbe036ff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b06cdc63d1ae489e771216bc86c4c90fbe036ff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed30152b52f650be4e8e2eee8616f7fa41f89569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed30152b52f650be4e8e2eee8616f7fa41f89569", "html_url": "https://github.com/rust-lang/rust/commit/ed30152b52f650be4e8e2eee8616f7fa41f89569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed30152b52f650be4e8e2eee8616f7fa41f89569/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843691d6122e49dc7bd17a45d74a1d8a2fbb815b", "url": "https://api.github.com/repos/rust-lang/rust/commits/843691d6122e49dc7bd17a45d74a1d8a2fbb815b", "html_url": "https://github.com/rust-lang/rust/commit/843691d6122e49dc7bd17a45d74a1d8a2fbb815b"}, {"sha": "a4cc58efc6db1c8c478954ea5116e15a7add479c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cc58efc6db1c8c478954ea5116e15a7add479c", "html_url": "https://github.com/rust-lang/rust/commit/a4cc58efc6db1c8c478954ea5116e15a7add479c"}], "stats": {"total": 157, "additions": 109, "deletions": 48}, "files": [{"sha": "920dc564e1546e440ede8ac6555926fc8c9ba622", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 61, "deletions": 26, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ed30152b52f650be4e8e2eee8616f7fa41f89569/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed30152b52f650be4e8e2eee8616f7fa41f89569/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=ed30152b52f650be4e8e2eee8616f7fa41f89569", "patch": "@@ -1,7 +1,7 @@\n use rustc_apfloat::Float;\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic};\n-use rustc::ty::layout::{self, LayoutOf, Size};\n+use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n \n use crate::{\n@@ -48,56 +48,84 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n+            \"volatile_load\" => {\n+                let place = this.deref_operand(args[0])?;\n+                this.copy_op(place.into(), dest)?;\n+            }\n+\n+            \"volatile_store\" => {\n+                let place = this.deref_operand(args[0])?;\n+                this.copy_op(args[1], place.into())?;\n+            }\n+\n             \"atomic_load\" |\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                let val = this.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-                this.write_scalar(val, dest)?;\n-            }\n+                let place = this.deref_operand(args[0])?;\n+                let val = this.read_scalar(place.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n-            \"volatile_load\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(ptr.into(), dest)?;\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+\n+                this.write_scalar(val, dest)?;\n             }\n \n             \"atomic_store\" |\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-                this.write_scalar(val, ptr.into())?;\n-            }\n \n-            \"volatile_store\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], ptr.into())?;\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+\n+                this.write_scalar(val, place.into())?;\n             }\n \n             \"atomic_fence_acq\" => {\n                 // we are inherently singlethreaded and singlecored, this is a nop\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let new = this.read_scalar(args[1])?;\n-                let old = this.read_scalar(ptr.into())?;\n+                let old = this.read_scalar(place.into())?;\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+\n                 this.write_scalar(old, dest)?; // old value is returned\n-                this.write_scalar(new, ptr.into())?;\n+                this.write_scalar(new, place.into())?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let expect_old = this.read_immediate(args[1])?; // read as immediate for the sake of `binary_op()`\n                 let new = this.read_scalar(args[2])?;\n-                let old = this.read_immediate(ptr.into())?; // read as immediate for the sake of `binary_op()`\n+                let old = this.read_immediate(place.into())?; // read as immediate for the sake of `binary_op()`\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+\n                 // binary_op will bail if either of them is not a scalar\n                 let (eq, _) = this.binary_op(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n                 this.write_immediate(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n                 if eq.to_bool()? {\n-                    this.write_scalar(new, ptr.into())?;\n+                    this.write_scalar(new, place.into())?;\n                 }\n             }\n \n@@ -131,12 +159,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"atomic_xsub_rel\" |\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                if !ptr.layout.ty.is_integral() {\n+                let place = this.deref_operand(args[0])?;\n+                if !place.layout.ty.is_integral() {\n                     bug!(\"Atomic arithmetic operations only work on integer types\");\n                 }\n                 let rhs = this.read_immediate(args[1])?;\n-                let old = this.read_immediate(ptr.into())?;\n+                let old = this.read_immediate(place.into())?;\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n+\n                 this.write_immediate(*old, dest)?; // old value is returned\n                 let (op, neg) = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => (mir::BinOp::BitOr, false),\n@@ -154,7 +189,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 } else {\n                     val\n                 };\n-                this.write_scalar(val, ptr.into())?;\n+                this.write_scalar(val, place.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -335,8 +370,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"move_val_init\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], ptr.into())?;\n+                let place = this.deref_operand(args[0])?;\n+                this.copy_op(args[1], place.into())?;\n             }\n \n             \"offset\" => {"}, {"sha": "5d2347c03ffee72c19710d104a7750f59b4d84d9", "filename": "tests/compile-fail/atomic_unaligned.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed30152b52f650be4e8e2eee8616f7fa41f89569/tests%2Fcompile-fail%2Fatomic_unaligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed30152b52f650be4e8e2eee8616f7fa41f89569/tests%2Fcompile-fail%2Fatomic_unaligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fatomic_unaligned.rs?ref=ed30152b52f650be4e8e2eee8616f7fa41f89569", "patch": "@@ -0,0 +1,12 @@\n+#![feature(core_intrinsics)]\n+\n+fn main() {\n+    // Do a 4-aligned u64 atomic access. That should be UB on all platforms,\n+    // even if u64 only has alignment 4.\n+    let z = [0u32; 2];\n+    let zptr = &z as *const _ as *const u64;\n+    unsafe {\n+        ::std::intrinsics::atomic_load(zptr);\n+        //~^ ERROR tried to access memory with alignment 4, but alignment 8 is required\n+    }\n+}"}, {"sha": "68a5d7295f1761e1c114f6f042af1165cb8eb1d4", "filename": "tests/run-pass/atomic-access-bool.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/843691d6122e49dc7bd17a45d74a1d8a2fbb815b/tests%2Frun-pass%2Fatomic-access-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/843691d6122e49dc7bd17a45d74a1d8a2fbb815b/tests%2Frun-pass%2Fatomic-access-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic-access-bool.rs?ref=843691d6122e49dc7bd17a45d74a1d8a2fbb815b", "patch": "@@ -1,19 +0,0 @@\n-use std::sync::atomic::{AtomicBool, Ordering::*};\n-\n-static mut ATOMIC: AtomicBool = AtomicBool::new(false);\n-\n-fn main() {\n-    unsafe {\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.store(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_or(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_and(false, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-        ATOMIC.fetch_nand(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), true);\n-        ATOMIC.fetch_xor(true, SeqCst);\n-        assert_eq!(*ATOMIC.get_mut(), false);\n-    }\n-}"}, {"sha": "f0b8ec06b905c65b0952af28d15cad9393e28327", "filename": "tests/run-pass/atomic.rs", "status": "renamed", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed30152b52f650be4e8e2eee8616f7fa41f89569/tests%2Frun-pass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed30152b52f650be4e8e2eee8616f7fa41f89569/tests%2Frun-pass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fatomic.rs?ref=ed30152b52f650be4e8e2eee8616f7fa41f89569", "patch": "@@ -1,8 +1,32 @@\n-use std::sync::atomic::{AtomicIsize, Ordering::*};\n-\n-static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n+use std::sync::atomic::{AtomicBool, AtomicIsize, AtomicU64, Ordering::*};\n \n fn main() {\n+    atomic_bool();\n+    atomic_isize();\n+    atomic_u64();\n+}\n+\n+fn atomic_bool() {\n+    static mut ATOMIC: AtomicBool = AtomicBool::new(false);\n+\n+    unsafe {\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.store(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_or(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_and(false, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+        ATOMIC.fetch_nand(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), true);\n+        ATOMIC.fetch_xor(true, SeqCst);\n+        assert_eq!(*ATOMIC.get_mut(), false);\n+    }\n+}\n+\n+fn atomic_isize() {\n+    static ATOMIC: AtomicIsize = AtomicIsize::new(0);\n+\n     // Make sure trans can emit all the intrinsics correctly\n     assert_eq!(ATOMIC.compare_exchange(0, 1, Relaxed, Relaxed), Ok(0));\n     assert_eq!(ATOMIC.compare_exchange(0, 2, Acquire, Relaxed), Err(1));\n@@ -27,3 +51,12 @@ fn main() {\n     ATOMIC.compare_exchange_weak(0, 1, SeqCst, Acquire).ok();\n     ATOMIC.compare_exchange_weak(0, 1, SeqCst, SeqCst).ok();\n }\n+\n+fn atomic_u64() {\n+    static ATOMIC: AtomicU64 = AtomicU64::new(0);\n+\n+    ATOMIC.store(1, SeqCst);\n+    assert_eq!(ATOMIC.compare_exchange(0, 0x100, AcqRel, Acquire), Err(1));\n+    assert_eq!(ATOMIC.compare_exchange_weak(1, 0x100, AcqRel, Acquire), Ok(1));\n+    assert_eq!(ATOMIC.load(Relaxed), 0x100);\n+}", "previous_filename": "tests/run-pass/atomic-compare_exchange.rs"}]}