{"sha": "13e284033e34609f5f911d3df989eddec4af3f1b", "node_id": "C_kwDOAAsO6NoAKDEzZTI4NDAzM2UzNDYwOWY1ZjkxMWQzZGY5ODllZGRlYzRhZjNmMWI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-03T13:44:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-03T13:44:21Z"}, "message": "Rollup merge of #92444 - dtolnay:coremethods, r=joshtriplett\n\nConsolidate Result's and Option's methods into fewer impl blocks\n\n`Result`'s and `Option`'s methods have historically been separated up into `impl` blocks based on their trait bounds, with the bounds specified on type parameters of the impl block. I find this unhelpful because closely related methods, like `unwrap_or` and `unwrap_or_default`, end up disproportionately far apart in source code and rustdocs:\n\n<pre>\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or(self, default: T) -&gt; T {\n        ...\n    }\n\n    <img alt=\"one eternity later\" src=\"https://user-images.githubusercontent.com/1940490/147780325-ad4e01a4-c971-436e-bdf4-e755f2d35f15.jpg\" width=\"750\">\n}\n\nimpl&lt;T: Default&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_default(self) -&gt; T {\n        ...\n    }\n}\n</pre>\n\nI'd prefer for method to be in as few impl blocks as possible, with the most logical grouping within each impl block. Any bounds needed can be written as `where` clauses on the method instead:\n\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap_or(self, default: T) -> T {\n        ...\n    }\n\n    pub fn unwrap_or_default(self) -> T\n    where\n        T: Default,\n    {\n        ...\n    }\n}\n```\n\n*Warning: the end-to-end diff of this PR is computed confusingly by git / rendered confusingly by GitHub; it's practically impossible to review that way. I've broken the PR into commits that move small groups of methods for which git behaves better &mdash; these each should be easily individually reviewable.*", "tree": {"sha": "846a319db7993f26e2ee2647b93f86d181bb94d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/846a319db7993f26e2ee2647b93f86d181bb94d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13e284033e34609f5f911d3df989eddec4af3f1b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh0v22CRBK7hj4Ov3rIwAADUUIAAhwQXdFteloKiyAYOam2Uim\nNR1FId1+Qkh09zZQwAguRM70q2po3Pk+LlC1TqIbvTLnE0HlVysdJWebmzMPK0PN\nB8UFgJ7fXy1zPpn7JonehONPCi3AG4CqW2iXQKtgjRe6nrUGfzCwhcsltqLts8FC\nndRGN245c6r+mznI2d9WU5gboKeCFgvvuPCps1KXqXWBWS/CNwbvFXzV+pYLuHrL\n3hBjgum3KSdAZ7CKhDQnxiX1CKKdG8x9zdNcxJbC/LEA2lmkhoEwKTPZ8fMd5OcO\ncwQiyXvjUVQgKZQZATZkMCSK2vwCRyAducpIRbJQCA0fEcVkRPGRaI15gK8siw0=\n=hvmd\n-----END PGP SIGNATURE-----\n", "payload": "tree 846a319db7993f26e2ee2647b93f86d181bb94d5\nparent df921190f3e8236892094a0f45aa5cc77e10f3d2\nparent 5960f7a617647f5204e924304b40592ab4f9f51d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641217461 +0100\ncommitter GitHub <noreply@github.com> 1641217461 +0100\n\nRollup merge of #92444 - dtolnay:coremethods, r=joshtriplett\n\nConsolidate Result's and Option's methods into fewer impl blocks\n\n`Result`'s and `Option`'s methods have historically been separated up into `impl` blocks based on their trait bounds, with the bounds specified on type parameters of the impl block. I find this unhelpful because closely related methods, like `unwrap_or` and `unwrap_or_default`, end up disproportionately far apart in source code and rustdocs:\n\n<pre>\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or(self, default: T) -&gt; T {\n        ...\n    }\n\n    <img alt=\"one eternity later\" src=\"https://user-images.githubusercontent.com/1940490/147780325-ad4e01a4-c971-436e-bdf4-e755f2d35f15.jpg\" width=\"750\">\n}\n\nimpl&lt;T: Default&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_default(self) -&gt; T {\n        ...\n    }\n}\n</pre>\n\nI'd prefer for method to be in as few impl blocks as possible, with the most logical grouping within each impl block. Any bounds needed can be written as `where` clauses on the method instead:\n\n```rust\nimpl<T> Option<T> {\n    pub fn unwrap_or(self, default: T) -> T {\n        ...\n    }\n\n    pub fn unwrap_or_default(self) -> T\n    where\n        T: Default,\n    {\n        ...\n    }\n}\n```\n\n*Warning: the end-to-end diff of this PR is computed confusingly by git / rendered confusingly by GitHub; it's practically impossible to review that way. I've broken the PR into commits that move small groups of methods for which git behaves better &mdash; these each should be easily individually reviewable.*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13e284033e34609f5f911d3df989eddec4af3f1b", "html_url": "https://github.com/rust-lang/rust/commit/13e284033e34609f5f911d3df989eddec4af3f1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13e284033e34609f5f911d3df989eddec4af3f1b/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df921190f3e8236892094a0f45aa5cc77e10f3d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/df921190f3e8236892094a0f45aa5cc77e10f3d2", "html_url": "https://github.com/rust-lang/rust/commit/df921190f3e8236892094a0f45aa5cc77e10f3d2"}, {"sha": "5960f7a617647f5204e924304b40592ab4f9f51d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5960f7a617647f5204e924304b40592ab4f9f51d", "html_url": "https://github.com/rust-lang/rust/commit/5960f7a617647f5204e924304b40592ab4f9f51d"}], "stats": {"total": 1041, "additions": 529, "deletions": 512}, "files": [{"sha": "0022df4f65ff7cffd1a430d7afbe7b129ba2864d", "filename": "library/core/src/option.rs", "status": "modified", "additions": 118, "deletions": 122, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -810,6 +810,45 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Returns the contained [`Some`] value or a default.\n+    ///\n+    /// Consumes the `self` argument then, if [`Some`], returns the contained\n+    /// value, otherwise if [`None`], returns the [default value] for that\n+    /// type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Converts a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning\n+    /// [`None`] on error.\n+    ///\n+    /// ```\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    /// ```\n+    ///\n+    /// [default value]: Default::default\n+    /// [`parse`]: str::parse\n+    /// [`FromStr`]: crate::str::FromStr\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn unwrap_or_default(self) -> T\n+    where\n+        T: ~const Default,\n+    {\n+        match self {\n+            Some(x) => x,\n+            None => Default::default(),\n+        }\n+    }\n+\n     /// Returns the contained [`Some`] value, consuming the `self` value,\n     /// without checking that the value is not [`None`].\n     ///\n@@ -1033,6 +1072,58 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n+    ///\n+    /// Leaves the original Option in-place, creating a new one with a reference\n+    /// to the original one, additionally coercing the contents via [`Deref`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n+    ///\n+    /// let x: Option<String> = None;\n+    /// assert_eq!(x.as_deref(), None);\n+    /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref(&self) -> Option<&T::Target>\n+    where\n+        T: ~const Deref,\n+    {\n+        match self.as_ref() {\n+            Some(t) => Some(t.deref()),\n+            None => None,\n+        }\n+    }\n+\n+    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n+    ///\n+    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n+    /// the inner type's [`Deref::Target`] type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref_mut().map(|x| {\n+    ///     x.make_ascii_uppercase();\n+    ///     x\n+    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// ```\n+    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    where\n+        T: ~const DerefMut,\n+    {\n+        match self.as_mut() {\n+            Some(t) => Some(t.deref_mut()),\n+            None => None,\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -1581,7 +1672,7 @@ impl<T, U> Option<(T, U)> {\n     }\n }\n \n-impl<T: Copy> Option<&T> {\n+impl<T> Option<&T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by copying the contents of the\n     /// option.\n     ///\n@@ -1597,41 +1688,18 @@ impl<T: Copy> Option<&T> {\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"copied\", since = \"1.35.0\")]\n     #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n-    pub const fn copied(self) -> Option<T> {\n+    pub const fn copied(self) -> Option<T>\n+    where\n+        T: Copy,\n+    {\n         // FIXME: this implementation, which sidesteps using `Option::map` since it's not const\n         // ready yet, should be reverted when possible to avoid code repetition\n         match self {\n             Some(&v) => Some(v),\n             None => None,\n         }\n     }\n-}\n \n-impl<T: Copy> Option<&mut T> {\n-    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n-    /// option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut x = 12;\n-    /// let opt_x = Some(&mut x);\n-    /// assert_eq!(opt_x, Some(&mut 12));\n-    /// let copied = opt_x.copied();\n-    /// assert_eq!(copied, Some(12));\n-    /// ```\n-    #[must_use = \"`self` will be dropped if the result is not used\"]\n-    #[stable(feature = \"copied\", since = \"1.35.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn copied(self) -> Option<T> {\n-        match self {\n-            Some(&mut t) => Some(t),\n-            None => None,\n-        }\n-    }\n-}\n-\n-impl<T: Clone> Option<&T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n     /// option.\n     ///\n@@ -1658,8 +1726,8 @@ impl<T: Clone> Option<&T> {\n     }\n }\n \n-impl<T: Clone> Option<&mut T> {\n-    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n+impl<T> Option<&mut T> {\n+    /// Maps an `Option<&mut T>` to an `Option<T>` by copying the contents of the\n     /// option.\n     ///\n     /// # Examples\n@@ -1668,115 +1736,43 @@ impl<T: Clone> Option<&mut T> {\n     /// let mut x = 12;\n     /// let opt_x = Some(&mut x);\n     /// assert_eq!(opt_x, Some(&mut 12));\n-    /// let cloned = opt_x.cloned();\n-    /// assert_eq!(cloned, Some(12));\n+    /// let copied = opt_x.copied();\n+    /// assert_eq!(copied, Some(12));\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n-    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n-    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n-    pub const fn cloned(self) -> Option<T>\n-    where\n-        T: ~const Clone,\n-    {\n-        match self {\n-            Some(t) => Some(t.clone()),\n-            None => None,\n-        }\n-    }\n-}\n-\n-impl<T: Default> Option<T> {\n-    /// Returns the contained [`Some`] value or a default.\n-    ///\n-    /// Consumes the `self` argument then, if [`Some`], returns the contained\n-    /// value, otherwise if [`None`], returns the [default value] for that\n-    /// type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Converts a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). [`parse`] converts\n-    /// a string to any other type that implements [`FromStr`], returning\n-    /// [`None`] on error.\n-    ///\n-    /// ```\n-    /// let good_year_from_input = \"1909\";\n-    /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().ok().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();\n-    ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n-    /// ```\n-    ///\n-    /// [default value]: Default::default\n-    /// [`parse`]: str::parse\n-    /// [`FromStr`]: crate::str::FromStr\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[stable(feature = \"copied\", since = \"1.35.0\")]\n     #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn unwrap_or_default(self) -> T\n+    pub const fn copied(self) -> Option<T>\n     where\n-        T: ~const Default,\n+        T: Copy,\n     {\n         match self {\n-            Some(x) => x,\n-            None => Default::default(),\n-        }\n-    }\n-}\n-\n-impl<T: Deref> Option<T> {\n-    /// Converts from `Option<T>` (or `&Option<T>`) to `Option<&T::Target>`.\n-    ///\n-    /// Leaves the original Option in-place, creating a new one with a reference\n-    /// to the original one, additionally coercing the contents via [`Deref`].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let x: Option<String> = Some(\"hey\".to_owned());\n-    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n-    ///\n-    /// let x: Option<String> = None;\n-    /// assert_eq!(x.as_deref(), None);\n-    /// ```\n-    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref(&self) -> Option<&T::Target>\n-    where\n-        T: ~const Deref,\n-    {\n-        match self.as_ref() {\n-            Some(t) => Some(t.deref()),\n+            Some(&mut t) => Some(t),\n             None => None,\n         }\n     }\n-}\n \n-impl<T: DerefMut> Option<T> {\n-    /// Converts from `Option<T>` (or `&mut Option<T>`) to `Option<&mut T::Target>`.\n-    ///\n-    /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n-    /// the inner type's [`Deref::Target`] type.\n+    /// Maps an `Option<&mut T>` to an `Option<T>` by cloning the contents of the\n+    /// option.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n-    /// assert_eq!(x.as_deref_mut().map(|x| {\n-    ///     x.make_ascii_uppercase();\n-    ///     x\n-    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// let mut x = 12;\n+    /// let opt_x = Some(&mut x);\n+    /// assert_eq!(opt_x, Some(&mut 12));\n+    /// let cloned = opt_x.cloned();\n+    /// assert_eq!(cloned, Some(12));\n     /// ```\n-    #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    #[must_use = \"`self` will be dropped if the result is not used\"]\n+    #[stable(since = \"1.26.0\", feature = \"option_ref_mut_cloned\")]\n+    #[rustc_const_unstable(feature = \"const_option_cloned\", issue = \"91582\")]\n+    pub const fn cloned(self) -> Option<T>\n     where\n-        T: ~const DerefMut,\n+        T: ~const Clone,\n     {\n-        match self.as_mut() {\n-            Some(t) => Some(t.deref_mut()),\n+        match self {\n+            Some(t) => Some(t.clone()),\n             None => None,\n         }\n     }"}, {"sha": "f46632e7a8d2030b78f5a9b5986737d98a4a46c4", "filename": "library/core/src/result.rs", "status": "modified", "additions": 401, "deletions": 376, "changes": 777, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -901,6 +901,56 @@ impl<T, E> Result<T, E> {\n         self\n     }\n \n+    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n+    ///\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&str, &u32> = Ok(\"hello\");\n+    /// assert_eq!(x.as_deref(), y);\n+    ///\n+    /// let x: Result<String, u32> = Err(42);\n+    /// let y: Result<&str, &u32> = Err(&42);\n+    /// assert_eq!(x.as_deref(), y);\n+    /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n+    pub fn as_deref(&self) -> Result<&T::Target, &E>\n+    where\n+        T: Deref,\n+    {\n+        self.as_ref().map(|t| t.deref())\n+    }\n+\n+    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n+    ///\n+    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n+    /// and returns the new [`Result`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut s = \"HELLO\".to_string();\n+    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n+    /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    ///\n+    /// let mut i = 42;\n+    /// let mut x: Result<String, u32> = Err(42);\n+    /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n+    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// ```\n+    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E>\n+    where\n+        T: DerefMut,\n+    {\n+        self.as_mut().map(|t| t.deref_mut())\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -951,608 +1001,583 @@ impl<T, E> Result<T, E> {\n         IterMut { inner: self.as_mut().ok() }\n     }\n \n-    ////////////////////////////////////////////////////////////////////////\n-    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+    // Extract a value\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n-    ///\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n     ///\n-    /// # Examples\n+    /// # Panics\n     ///\n-    /// Basic usage:\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n     ///\n-    /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<&str, &str> = Err(\"late error\");\n-    /// assert_eq!(x.and(y), Err(\"late error\"));\n     ///\n-    /// let x: Result<u32, &str> = Err(\"early error\");\n-    /// let y: Result<&str, &str> = Ok(\"foo\");\n-    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    /// # Examples\n     ///\n-    /// let x: Result<u32, &str> = Err(\"not a 2\");\n-    /// let y: Result<&str, &str> = Err(\"late error\");\n-    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    /// Basic usage:\n     ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<&str, &str> = Ok(\"different result type\");\n-    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n+    #[track_caller]\n+    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n+    pub fn expect(self, msg: &str) -> T\n+    where\n+        E: fmt::Debug,\n+    {\n         match self {\n-            Ok(_) => res,\n-            Err(e) => Err(e),\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(msg, &e),\n         }\n     }\n \n-    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n     ///\n+    /// [`unwrap_or`]: Result::unwrap_or\n+    /// [`unwrap_or_else`]: Result::unwrap_or_else\n+    /// [`unwrap_or_default`]: Result::unwrap_or_default\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Err`], with a panic message provided by the\n+    /// [`Err`]'s value.\n     ///\n-    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.unwrap(), 2);\n+    /// ```\n     ///\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n-    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n-    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n+    pub fn unwrap(self) -> T\n+    where\n+        E: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => op(t),\n-            Err(e) => Err(e),\n+            Ok(t) => t,\n+            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n         }\n     }\n \n-    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n-    ///\n-    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n-    /// result of a function call, it is recommended to use [`or_else`], which is\n-    /// lazily evaluated.\n+    /// Returns the contained [`Ok`] value or a default\n     ///\n-    /// [`or_else`]: Result::or_else\n+    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n+    /// value, otherwise if [`Err`], returns the default value for that\n+    /// type.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// Converts a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning an\n+    /// [`Err`] on error.\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<u32, &str> = Err(\"late error\");\n-    /// assert_eq!(x.or(y), Ok(2));\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"early error\");\n-    /// let y: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.or(y), Ok(2));\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"not a 2\");\n-    /// let y: Result<u32, &str> = Err(\"late error\");\n-    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n     ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// let y: Result<u32, &str> = Ok(100);\n-    /// assert_eq!(x.or(y), Ok(2));\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n     /// ```\n+    ///\n+    /// [`parse`]: str::parse\n+    /// [`FromStr`]: crate::str::FromStr\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n+    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n+    pub fn unwrap_or_default(self) -> T\n+    where\n+        T: Default,\n+    {\n         match self {\n-            Ok(v) => Ok(v),\n-            Err(_) => res,\n+            Ok(x) => x,\n+            Err(_) => Default::default(),\n         }\n     }\n \n-    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n-    /// This function can be used for control flow based on result values.\n+    /// # Panics\n+    ///\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n-    ///\n-    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n-    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n-    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n-    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(10);\n+    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n+    #[track_caller]\n+    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n+    pub fn expect_err(self, msg: &str) -> E\n+    where\n+        T: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => Ok(t),\n-            Err(e) => op(e),\n+            Ok(t) => unwrap_failed(msg, &t),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value or a provided default.\n+    /// Returns the contained [`Err`] value, consuming the `self` value.\n     ///\n-    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n-    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n-    /// which is lazily evaluated.\n+    /// # Panics\n     ///\n-    /// [`unwrap_or_else`]: Result::unwrap_or_else\n+    /// Panics if the value is an [`Ok`], with a custom panic message provided\n+    /// by the [`Ok`]'s value.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n+    /// ```should_panic\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// x.unwrap_err(); // panics with `2`\n     /// ```\n-    /// let default = 2;\n-    /// let x: Result<u32, &str> = Ok(9);\n-    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n-    /// let x: Result<u32, &str> = Err(\"error\");\n-    /// assert_eq!(x.unwrap_or(default), default);\n+    /// ```\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, default: T) -> T {\n+    pub fn unwrap_err(self) -> E\n+    where\n+        T: fmt::Debug,\n+    {\n         match self {\n-            Ok(t) => t,\n-            Err(_) => default,\n+            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", &t),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value or computes it from a closure.\n+    /// Returns the contained [`Ok`] value, but never panics.\n+    ///\n+    /// Unlike [`unwrap`], this method is known to never panic on the\n+    /// result types it is implemented for. Therefore, it can be used\n+    /// instead of `unwrap` as a maintainability safeguard that will fail\n+    /// to compile if the error type of the `Result` is later changed\n+    /// to an error that can actually occur.\n     ///\n+    /// [`unwrap`]: Result::unwrap\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// fn count(x: &str) -> usize { x.len() }\n+    /// # #![feature(never_type)]\n+    /// # #![feature(unwrap_infallible)]\n     ///\n-    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n-    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n+    /// fn only_good_news() -> Result<String, !> {\n+    ///     Ok(\"this is fine\".into())\n+    /// }\n+    ///\n+    /// let s: String = only_good_news().into_ok();\n+    /// println!(\"{}\", s);\n     /// ```\n+    #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n     #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n+    pub fn into_ok(self) -> T\n+    where\n+        E: Into<!>,\n+    {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => op(e),\n+            Ok(x) => x,\n+            Err(e) => e.into(),\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value, consuming the `self` value,\n-    /// without checking that the value is not an [`Err`].\n-    ///\n-    /// # Safety\n+    /// Returns the contained [`Err`] value, but never panics.\n     ///\n-    /// Calling this method on an [`Err`] is *[undefined behavior]*.\n+    /// Unlike [`unwrap_err`], this method is known to never panic on the\n+    /// result types it is implemented for. Therefore, it can be used\n+    /// instead of `unwrap_err` as a maintainability safeguard that will fail\n+    /// to compile if the ok type of the `Result` is later changed\n+    /// to a type that can actually occur.\n     ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    /// [`unwrap_err`]: Result::unwrap_err\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(unsafe { x.unwrap_unchecked() }, 2);\n-    /// ```\n+    /// # #![feature(never_type)]\n+    /// # #![feature(unwrap_infallible)]\n     ///\n-    /// ```no_run\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// unsafe { x.unwrap_unchecked(); } // Undefined behavior!\n+    /// fn only_bad_news() -> Result<!, String> {\n+    ///     Err(\"Oops, it failed\".into())\n+    /// }\n+    ///\n+    /// let error: String = only_bad_news().into_err();\n+    /// println!(\"{}\", error);\n     /// ```\n+    #[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n-    pub unsafe fn unwrap_unchecked(self) -> T {\n-        debug_assert!(self.is_ok());\n+    pub fn into_err(self) -> E\n+    where\n+        T: Into<!>,\n+    {\n         match self {\n-            Ok(t) => t,\n-            // SAFETY: the safety contract must be upheld by the caller.\n-            Err(_) => unsafe { hint::unreachable_unchecked() },\n+            Ok(x) => x.into(),\n+            Err(e) => e,\n         }\n     }\n \n-    /// Returns the contained [`Err`] value, consuming the `self` value,\n-    /// without checking that the value is not an [`Ok`].\n-    ///\n-    /// # Safety\n-    ///\n-    /// Calling this method on an [`Ok`] is *[undefined behavior]*.\n+    ////////////////////////////////////////////////////////////////////////\n+    // Boolean operations on the values, eager and lazy\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n     ///\n-    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n-    /// ```no_run\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// unsafe { x.unwrap_err_unchecked() }; // Undefined behavior!\n-    /// ```\n+    /// Basic usage:\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// assert_eq!(unsafe { x.unwrap_err_unchecked() }, \"emergency failure\");\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<&str, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Ok(\"different result type\");\n+    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n-    pub unsafe fn unwrap_err_unchecked(self) -> E {\n-        debug_assert!(self.is_err());\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n         match self {\n-            // SAFETY: the safety contract must be upheld by the caller.\n-            Ok(_) => unsafe { hint::unreachable_unchecked() },\n-            Err(e) => e,\n+            Ok(_) => res,\n+            Err(e) => Err(e),\n         }\n     }\n-}\n \n-impl<T: Copy, E> Result<&T, E> {\n-    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n-    /// `Ok` part.\n+    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n     ///\n-    /// # Examples\n     ///\n-    /// ```\n-    /// #![feature(result_copied)]\n-    /// let val = 12;\n-    /// let x: Result<&i32, i32> = Ok(&val);\n-    /// assert_eq!(x, Ok(&12));\n-    /// let copied = x.copied();\n-    /// assert_eq!(copied, Ok(12));\n-    /// ```\n-    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn copied(self) -> Result<T, E> {\n-        self.map(|&t| t)\n-    }\n-}\n-\n-impl<T: Copy, E> Result<&mut T, E> {\n-    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n-    /// `Ok` part.\n+    /// This function can be used for control flow based on `Result` values.\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// #![feature(result_copied)]\n-    /// let mut val = 12;\n-    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n-    /// assert_eq!(x, Ok(&mut 12));\n-    /// let copied = x.copied();\n-    /// assert_eq!(copied, Ok(12));\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n+    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n+    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n     /// ```\n-    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn copied(self) -> Result<T, E> {\n-        self.map(|&mut t| t)\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn and_then<U, F: FnOnce(T) -> Result<U, E>>(self, op: F) -> Result<U, E> {\n+        match self {\n+            Ok(t) => op(t),\n+            Err(e) => Err(e),\n+        }\n     }\n-}\n \n-impl<T: Clone, E> Result<&T, E> {\n-    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n-    /// `Ok` part.\n+    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n-    /// # Examples\n+    /// Arguments passed to `or` are eagerly evaluated; if you are passing the\n+    /// result of a function call, it is recommended to use [`or_else`], which is\n+    /// lazily evaluated.\n     ///\n-    /// ```\n-    /// #![feature(result_cloned)]\n-    /// let val = 12;\n-    /// let x: Result<&i32, i32> = Ok(&val);\n-    /// assert_eq!(x, Ok(&12));\n-    /// let cloned = x.cloned();\n-    /// assert_eq!(cloned, Ok(12));\n-    /// ```\n-    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn cloned(self) -> Result<T, E> {\n-        self.map(|t| t.clone())\n-    }\n-}\n-\n-impl<T: Clone, E> Result<&mut T, E> {\n-    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n-    /// `Ok` part.\n+    /// [`or_else`]: Result::or_else\n     ///\n     /// # Examples\n     ///\n+    /// Basic usage:\n+    ///\n     /// ```\n-    /// #![feature(result_cloned)]\n-    /// let mut val = 12;\n-    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n-    /// assert_eq!(x, Ok(&mut 12));\n-    /// let cloned = x.cloned();\n-    /// assert_eq!(cloned, Ok(12));\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"early error\");\n+    /// let y: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"not a 2\");\n+    /// let y: Result<u32, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// let y: Result<u32, &str> = Ok(100);\n+    /// assert_eq!(x.or(y), Ok(2));\n     /// ```\n-    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n-    pub fn cloned(self) -> Result<T, E> {\n-        self.map(|t| t.clone())\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or<F>(self, res: Result<T, F>) -> Result<T, F> {\n+        match self {\n+            Ok(v) => Ok(v),\n+            Err(_) => res,\n+        }\n     }\n-}\n \n-impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Returns the contained [`Ok`] value, consuming the `self` value.\n-    ///\n-    /// # Panics\n+    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n-    /// Panics if the value is an [`Err`], with a panic message including the\n-    /// passed message, and the content of the [`Err`].\n+    /// This function can be used for control flow based on result values.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n+    /// ```\n+    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n+    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n+    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n+    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n+    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n-    pub fn expect(self, msg: &str) -> T {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_else<F, O: FnOnce(E) -> Result<T, F>>(self, op: O) -> Result<T, F> {\n         match self {\n-            Ok(t) => t,\n-            Err(e) => unwrap_failed(msg, &e),\n+            Ok(t) => Ok(t),\n+            Err(e) => op(e),\n         }\n     }\n \n-    /// Returns the contained [`Ok`] value, consuming the `self` value.\n+    /// Returns the contained [`Ok`] value or a provided default.\n     ///\n-    /// Because this function may panic, its use is generally discouraged.\n-    /// Instead, prefer to use pattern matching and handle the [`Err`]\n-    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n-    /// [`unwrap_or_default`].\n+    /// Arguments passed to `unwrap_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`unwrap_or_else`],\n+    /// which is lazily evaluated.\n     ///\n-    /// [`unwrap_or`]: Result::unwrap_or\n     /// [`unwrap_or_else`]: Result::unwrap_or_else\n-    /// [`unwrap_or_default`]: Result::unwrap_or_default\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Err`], with a panic message provided by the\n-    /// [`Err`]'s value.\n-    ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.unwrap(), 2);\n-    /// ```\n+    /// let default = 2;\n+    /// let x: Result<u32, &str> = Ok(9);\n+    /// assert_eq!(x.unwrap_or(default), 9);\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// x.unwrap(); // panics with `emergency failure`\n+    /// let x: Result<u32, &str> = Err(\"error\");\n+    /// assert_eq!(x.unwrap_or(default), default);\n     /// ```\n     #[inline]\n-    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap(self) -> T {\n+    pub fn unwrap_or(self, default: T) -> T {\n         match self {\n             Ok(t) => t,\n-            Err(e) => unwrap_failed(\"called `Result::unwrap()` on an `Err` value\", &e),\n+            Err(_) => default,\n         }\n     }\n-}\n \n-impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Returns the contained [`Err`] value, consuming the `self` value.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the value is an [`Ok`], with a panic message including the\n-    /// passed message, and the content of the [`Ok`].\n+    /// Returns the contained [`Ok`] value or computes it from a closure.\n     ///\n     ///\n     /// # Examples\n     ///\n     /// Basic usage:\n     ///\n-    /// ```should_panic\n-    /// let x: Result<u32, &str> = Ok(10);\n-    /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n+    /// ```\n+    /// fn count(x: &str) -> usize { x.len() }\n+    ///\n+    /// assert_eq!(Ok(2).unwrap_or_else(count), 2);\n+    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3);\n     /// ```\n     #[inline]\n-    #[track_caller]\n-    #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n-    pub fn expect_err(self, msg: &str) -> E {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn unwrap_or_else<F: FnOnce(E) -> T>(self, op: F) -> T {\n         match self {\n-            Ok(t) => unwrap_failed(msg, &t),\n-            Err(e) => e,\n+            Ok(t) => t,\n+            Err(e) => op(e),\n         }\n     }\n \n-    /// Returns the contained [`Err`] value, consuming the `self` value.\n+    /// Returns the contained [`Ok`] value, consuming the `self` value,\n+    /// without checking that the value is not an [`Err`].\n     ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the value is an [`Ok`], with a custom panic message provided\n-    /// by the [`Ok`]'s value.\n+    /// Calling this method on an [`Err`] is *[undefined behavior]*.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n     ///\n-    /// ```should_panic\n+    /// ```\n     /// let x: Result<u32, &str> = Ok(2);\n-    /// x.unwrap_err(); // panics with `2`\n+    /// assert_eq!(unsafe { x.unwrap_unchecked() }, 2);\n     /// ```\n     ///\n-    /// ```\n+    /// ```no_run\n     /// let x: Result<u32, &str> = Err(\"emergency failure\");\n-    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n+    /// unsafe { x.unwrap_unchecked(); } // Undefined behavior!\n     /// ```\n     #[inline]\n     #[track_caller]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_err(self) -> E {\n+    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n+    pub unsafe fn unwrap_unchecked(self) -> T {\n+        debug_assert!(self.is_ok());\n         match self {\n-            Ok(t) => unwrap_failed(\"called `Result::unwrap_err()` on an `Ok` value\", &t),\n-            Err(e) => e,\n+            Ok(t) => t,\n+            // SAFETY: the safety contract must be upheld by the caller.\n+            Err(_) => unsafe { hint::unreachable_unchecked() },\n         }\n     }\n-}\n \n-impl<T: Default, E> Result<T, E> {\n-    /// Returns the contained [`Ok`] value or a default\n+    /// Returns the contained [`Err`] value, consuming the `self` value,\n+    /// without checking that the value is not an [`Ok`].\n     ///\n-    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n-    /// value, otherwise if [`Err`], returns the default value for that\n-    /// type.\n+    /// # Safety\n     ///\n-    /// # Examples\n+    /// Calling this method on an [`Ok`] is *[undefined behavior]*.\n     ///\n-    /// Converts a string to an integer, turning poorly-formed strings\n-    /// into 0 (the default value for integers). [`parse`] converts\n-    /// a string to any other type that implements [`FromStr`], returning an\n-    /// [`Err`] on error.\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n-    /// ```\n-    /// let good_year_from_input = \"1909\";\n-    /// let bad_year_from_input = \"190blarg\";\n-    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n-    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    /// # Examples\n     ///\n-    /// assert_eq!(1909, good_year);\n-    /// assert_eq!(0, bad_year);\n+    /// ```no_run\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// unsafe { x.unwrap_err_unchecked() }; // Undefined behavior!\n     /// ```\n     ///\n-    /// [`parse`]: str::parse\n-    /// [`FromStr`]: crate::str::FromStr\n+    /// ```\n+    /// let x: Result<u32, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(unsafe { x.unwrap_err_unchecked() }, \"emergency failure\");\n+    /// ```\n     #[inline]\n-    #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n-    pub fn unwrap_or_default(self) -> T {\n+    #[track_caller]\n+    #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n+    pub unsafe fn unwrap_err_unchecked(self) -> E {\n+        debug_assert!(self.is_err());\n         match self {\n-            Ok(x) => x,\n-            Err(_) => Default::default(),\n+            // SAFETY: the safety contract must be upheld by the caller.\n+            Ok(_) => unsafe { hint::unreachable_unchecked() },\n+            Err(e) => e,\n         }\n     }\n }\n \n-#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n-impl<T, E: Into<!>> Result<T, E> {\n-    /// Returns the contained [`Ok`] value, but never panics.\n-    ///\n-    /// Unlike [`unwrap`], this method is known to never panic on the\n-    /// result types it is implemented for. Therefore, it can be used\n-    /// instead of `unwrap` as a maintainability safeguard that will fail\n-    /// to compile if the error type of the `Result` is later changed\n-    /// to an error that can actually occur.\n-    ///\n-    /// [`unwrap`]: Result::unwrap\n+impl<T, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n-    /// # #![feature(never_type)]\n-    /// # #![feature(unwrap_infallible)]\n-    ///\n-    /// fn only_good_news() -> Result<String, !> {\n-    ///     Ok(\"this is fine\".into())\n-    /// }\n-    ///\n-    /// let s: String = only_good_news().into_ok();\n-    /// println!(\"{}\", s);\n+    /// #![feature(result_copied)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n     /// ```\n-    #[inline]\n-    pub fn into_ok(self) -> T {\n-        match self {\n-            Ok(x) => x,\n-            Err(e) => e.into(),\n-        }\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E>\n+    where\n+        T: Copy,\n+    {\n+        self.map(|&t| t)\n     }\n-}\n \n-#[unstable(feature = \"unwrap_infallible\", reason = \"newly added\", issue = \"61695\")]\n-impl<T: Into<!>, E> Result<T, E> {\n-    /// Returns the contained [`Err`] value, but never panics.\n-    ///\n-    /// Unlike [`unwrap_err`], this method is known to never panic on the\n-    /// result types it is implemented for. Therefore, it can be used\n-    /// instead of `unwrap_err` as a maintainability safeguard that will fail\n-    /// to compile if the ok type of the `Result` is later changed\n-    /// to a type that can actually occur.\n-    ///\n-    /// [`unwrap_err`]: Result::unwrap_err\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n-    ///\n     /// ```\n-    /// # #![feature(never_type)]\n-    /// # #![feature(unwrap_infallible)]\n-    ///\n-    /// fn only_bad_news() -> Result<!, String> {\n-    ///     Err(\"Oops, it failed\".into())\n-    /// }\n-    ///\n-    /// let error: String = only_bad_news().into_err();\n-    /// println!(\"{}\", error);\n+    /// #![feature(result_cloned)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n     /// ```\n-    #[inline]\n-    pub fn into_err(self) -> E {\n-        match self {\n-            Ok(x) => x.into(),\n-            Err(e) => e,\n-        }\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E>\n+    where\n+        T: Clone,\n+    {\n+        self.map(|t| t.clone())\n     }\n }\n \n-impl<T: Deref, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&<T as Deref>::Target, &E>`.\n-    ///\n-    /// Coerces the [`Ok`] variant of the original [`Result`] via [`Deref`](crate::ops::Deref)\n-    /// and returns the new [`Result`].\n+impl<T, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<String, u32> = Ok(\"hello\".to_string());\n-    /// let y: Result<&str, &u32> = Ok(\"hello\");\n-    /// assert_eq!(x.as_deref(), y);\n-    ///\n-    /// let x: Result<String, u32> = Err(42);\n-    /// let y: Result<&str, &u32> = Err(&42);\n-    /// assert_eq!(x.as_deref(), y);\n+    /// #![feature(result_copied)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n     /// ```\n-    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n-    pub fn as_deref(&self) -> Result<&T::Target, &E> {\n-        self.as_ref().map(|t| t.deref())\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E>\n+    where\n+        T: Copy,\n+    {\n+        self.map(|&mut t| t)\n     }\n-}\n \n-impl<T: DerefMut, E> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut <T as DerefMut>::Target, &mut E>`.\n-    ///\n-    /// Coerces the [`Ok`] variant of the original [`Result`] via [`DerefMut`](crate::ops::DerefMut)\n-    /// and returns the new [`Result`].\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let mut s = \"HELLO\".to_string();\n-    /// let mut x: Result<String, u32> = Ok(\"hello\".to_string());\n-    /// let y: Result<&mut str, &mut u32> = Ok(&mut s);\n-    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n-    ///\n-    /// let mut i = 42;\n-    /// let mut x: Result<String, u32> = Err(42);\n-    /// let y: Result<&mut str, &mut u32> = Err(&mut i);\n-    /// assert_eq!(x.as_deref_mut().map(|x| { x.make_ascii_uppercase(); x }), y);\n+    /// #![feature(result_cloned)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n     /// ```\n-    #[stable(feature = \"inner_deref\", since = \"1.47.0\")]\n-    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n-        self.as_mut().map(|t| t.deref_mut())\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E>\n+    where\n+        T: Clone,\n+    {\n+        self.map(|t| t.clone())\n     }\n }\n "}, {"sha": "52ee1db5b157113d3a3a1ea2c83582d3ad80b3e8", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/option-as_deref_mut.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Foption-as_deref_mut.stderr?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -5,7 +5,6 @@ LL |     let _result = &mut Some(42).as_deref_mut();\n    |                                 ^^^^^^^^^^^^ method cannot be called on `Option<{integer}>` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n-           `{integer}: DerefMut`\n            `{integer}: Deref`\n \n error: aborting due to previous error"}, {"sha": "018557881ef77edb45ee41dce7eba85273a2c6aa", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut.stderr?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -5,7 +5,6 @@ LL |     let _result = &mut Ok(42).as_deref_mut();\n    |                               ^^^^^^^^^^^^ method cannot be called on `Result<{integer}, _>` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n-           `{integer}: DerefMut`\n            `{integer}: Deref`\n \n error: aborting due to previous error"}, {"sha": "6303c6e6a5db11404e1850fbf09dc214c61cfcc4", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -3,5 +3,5 @@ struct Foo;\n fn main() {\n     let a: Result<(), Foo> = Ok(());\n     a.unwrap();\n-    //~^ ERROR the method\n+    //~^ ERROR `Foo` doesn't implement `Debug`\n }"}, {"sha": "dc73bcd6e4d050aa27835b524445d3bdbd85e3dd", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/13e284033e34609f5f911d3df989eddec4af3f1b/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=13e284033e34609f5f911d3df989eddec4af3f1b", "patch": "@@ -1,19 +1,17 @@\n-error[E0599]: the method `unwrap` exists for enum `Result<(), Foo>`, but its trait bounds were not satisfied\n+error[E0277]: `Foo` doesn't implement `Debug`\n   --> $DIR/method-help-unsatisfied-bound.rs:5:7\n    |\n-LL | struct Foo;\n-   | ----------- doesn't satisfy `Foo: Debug`\n-...\n LL |     a.unwrap();\n-   |       ^^^^^^ method cannot be called on `Result<(), Foo>` due to unsatisfied trait bounds\n+   |       ^^^^^^ `Foo` cannot be formatted using `{:?}`\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `Foo: Debug`\n-help: consider annotating `Foo` with `#[derive(Debug)]`\n-   |\n-LL | #[derive(Debug)]\n+   = help: the trait `Debug` is not implemented for `Foo`\n+   = note: add `#[derive(Debug)]` to `Foo` or manually `impl Debug for Foo`\n+note: required by a bound in `Result::<T, E>::unwrap`\n+  --> $SRC_DIR/core/src/result.rs:LL:COL\n    |\n+LL |         E: fmt::Debug,\n+   |            ^^^^^^^^^^ required by this bound in `Result::<T, E>::unwrap`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0599`.\n+For more information about this error, try `rustc --explain E0277`."}]}