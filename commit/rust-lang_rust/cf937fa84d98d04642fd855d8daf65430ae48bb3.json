{"sha": "cf937fa84d98d04642fd855d8daf65430ae48bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOTM3ZmE4NGQ5OGQwNDY0MmZkODU1ZDhkYWY2NTQzMGFlNDhiYjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-03T10:07:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-03T10:07:05Z"}, "message": "Rollup merge of #66935 - petrochenkov:attrtok2, r=Centril\n\nsyntax: Unify macro and attribute arguments in AST\n\nThe unified form (`ast::MacArgs`) represents parsed arguments instead of an unstructured token stream that was previously used for attributes.\nIt also tracks some spans and delimiter kinds better for fn-like macros and macro definitions.\n\nI've been talking about implementing this with @nnethercote in https://github.com/rust-lang/rust/pull/65750#issuecomment-546517322.\nThe parsed representation is closer to `MetaItem` and requires less token juggling during conversions, so it potentially may be faster.\n\nr? @Centril", "tree": {"sha": "d078e53e048e0c7a216faaf4227787d08b22e675", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d078e53e048e0c7a216faaf4227787d08b22e675"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf937fa84d98d04642fd855d8daf65430ae48bb3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd5jPKCRBK7hj4Ov3rIwAAdHIIABVMUYB+yB0R/mv/GKNuoQZg\n3Kzg8HgvojRzlRkDxCIaPfnyHfoOzNG54RGZA0C06ZA6cfhQRD1oqKkVKrqSaUoj\nc5I6F9Edvoe19soGAyDZgcHohYZ9oFkP+iU9869teQvC7zLKGxnysnixSHjg+LFN\nu4xS58IecTXkVdciKaxTeVJI/AmChdFE7AuCoU8+22ZCpzV4uHz0v3stuHJiapLm\nStAeGO2bThOahiYKAWO8p2Qm3PQkiT8ymVWOhuAA1WPVBtuGnpefl/IMrHvDqm88\nLtVp49LhNCoTolmlTISSnSLBfHuqkMdmlZfZNQ5qlCnm8KN7ACohdn7BIoPRf1s=\n=/rLM\n-----END PGP SIGNATURE-----\n", "payload": "tree d078e53e048e0c7a216faaf4227787d08b22e675\nparent 01345d65c119f48aa5e62acd9a88c7079186024e\nparent 498737c8e9cf52be1bde3bef7ffa24a3d0540257\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575367625 +0100\ncommitter GitHub <noreply@github.com> 1575367625 +0100\n\nRollup merge of #66935 - petrochenkov:attrtok2, r=Centril\n\nsyntax: Unify macro and attribute arguments in AST\n\nThe unified form (`ast::MacArgs`) represents parsed arguments instead of an unstructured token stream that was previously used for attributes.\nIt also tracks some spans and delimiter kinds better for fn-like macros and macro definitions.\n\nI've been talking about implementing this with @nnethercote in https://github.com/rust-lang/rust/pull/65750#issuecomment-546517322.\nThe parsed representation is closer to `MetaItem` and requires less token juggling during conversions, so it potentially may be faster.\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf937fa84d98d04642fd855d8daf65430ae48bb3", "html_url": "https://github.com/rust-lang/rust/commit/cf937fa84d98d04642fd855d8daf65430ae48bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf937fa84d98d04642fd855d8daf65430ae48bb3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01345d65c119f48aa5e62acd9a88c7079186024e", "url": "https://api.github.com/repos/rust-lang/rust/commits/01345d65c119f48aa5e62acd9a88c7079186024e", "html_url": "https://github.com/rust-lang/rust/commit/01345d65c119f48aa5e62acd9a88c7079186024e"}, {"sha": "498737c8e9cf52be1bde3bef7ffa24a3d0540257", "url": "https://api.github.com/repos/rust-lang/rust/commits/498737c8e9cf52be1bde3bef7ffa24a3d0540257", "html_url": "https://github.com/rust-lang/rust/commit/498737c8e9cf52be1bde3bef7ffa24a3d0540257"}], "stats": {"total": 722, "additions": 395, "deletions": 327}, "files": [{"sha": "e13f6cabb5296296b8d3106e73ae17b20094fb55", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1003,7 +1003,7 @@ impl<'a> LoweringContext<'a> {\n             AttrKind::Normal(ref item) => {\n                 AttrKind::Normal(AttrItem {\n                     path: item.path.clone(),\n-                    tokens: self.lower_token_stream(item.tokens.clone()),\n+                    args: self.lower_mac_args(&item.args),\n                 })\n             }\n             AttrKind::DocComment(comment) => AttrKind::DocComment(comment)\n@@ -1017,6 +1017,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n+        match *args {\n+            MacArgs::Empty => MacArgs::Empty,\n+            MacArgs::Delimited(dspan, delim, ref tokens) =>\n+                MacArgs::Delimited(dspan, delim, self.lower_token_stream(tokens.clone())),\n+            MacArgs::Eq(eq_span, ref tokens) =>\n+                MacArgs::Eq(eq_span, self.lower_token_stream(tokens.clone())),\n+        }\n+    }\n+\n     fn lower_token_stream(&mut self, tokens: TokenStream) -> TokenStream {\n         tokens\n             .into_trees()"}, {"sha": "ff9d8c85df8b9dd3661df2d3092faf3bb354d3ab", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -233,7 +233,7 @@ impl LoweringContext<'_> {\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n-                let body = self.lower_token_stream(def.stream());\n+                let body = self.lower_token_stream(def.body.inner_tokens());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {\n                     name: ident.name,"}, {"sha": "0fd7145f425d3027cf58e59594035682aec631dc", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1450,10 +1450,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n-        self.check_tokens(cx, mac_def.stream());\n+        self.check_tokens(cx, mac_def.body.inner_tokens());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n-        self.check_tokens(cx, mac.tts.clone().into());\n+        self.check_tokens(cx, mac.args.inner_tokens());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "13db9a6fef9ca83b1cf5a6c808726f61c4a4517a", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -32,6 +32,8 @@ use syntax::source_map;\n use syntax::source_map::Spanned;\n use syntax::symbol::Symbol;\n use syntax::expand::allocator::AllocatorKind;\n+use syntax::ptr::P;\n+use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, FileName};\n \n macro_rules! provide {\n@@ -427,6 +429,7 @@ impl CStore {\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n         let local_span = Span::with_root_ctxt(source_file.start_pos, source_file.end_pos);\n+        let dspan = DelimSpan::from_single(local_span);\n         let (body, mut errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n         emit_unclosed_delims(&mut errors, &sess.parse_sess);\n \n@@ -448,7 +451,7 @@ impl CStore {\n             span: local_span,\n             attrs: attrs.iter().cloned().collect(),\n             kind: ast::ItemKind::MacroDef(ast::MacroDef {\n-                tokens: body.into(),\n+                body: P(ast::MacArgs::Delimited(dspan, ast::MacDelimiter::Brace, body)),\n                 legacy: def.legacy,\n             }),\n             vis: source_map::respan(local_span.shrink_to_lo(), ast::VisibilityKind::Inherited),"}, {"sha": "1bf6e9ecbc060ec8868bd2bff9134b71c8ef8817", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -101,7 +101,7 @@ impl<'a> StripUnconfigured<'a> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n-        if attr.get_normal_item().tokens.is_empty() {\n+        if let ast::MacArgs::Empty = attr.get_normal_item().args {\n             self.sess.span_diagnostic\n                 .struct_span_err(\n                     attr.span,"}, {"sha": "a22b383e5f39166dc0b558f843bfed5571c23832", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -277,7 +277,9 @@ pub fn parse_in_attr<'a, T>(\n ) -> PResult<'a, T> {\n     let mut parser = Parser::new(\n         sess,\n-        attr.get_normal_item().tokens.clone(),\n+        // FIXME(#66940, Centril | petrochenkov): refactor this function so it doesn't\n+        // require reconstructing and immediately re-parsing delimiters.\n+        attr.get_normal_item().args.outer_tokens(),\n         None,\n         false,\n         false,\n@@ -409,7 +411,7 @@ fn prepend_attrs(\n             brackets.push(stream);\n         }\n \n-        brackets.push(item.tokens.clone());\n+        brackets.push(item.args.outer_tokens());\n \n         // The span we list here for `#` and for `[ ... ]` are both wrong in\n         // that it encompasses more than each token, but it hopefully is \"good"}, {"sha": "c7261404f54efda0dede24beb4e011e53703b1df", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -2,8 +2,7 @@ use super::{SeqSep, Parser, TokenType, PathStyle};\n use syntax::attr;\n use syntax::ast;\n use syntax::util::comments;\n-use syntax::token::{self, Nonterminal, DelimToken};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::token::{self, Nonterminal};\n use syntax_pos::{Span, Symbol};\n use errors::PResult;\n \n@@ -181,31 +180,8 @@ impl<'a> Parser<'a> {\n             item\n         } else {\n             let path = self.parse_path(PathStyle::Mod)?;\n-            let tokens = if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n-               self.check(&token::OpenDelim(DelimToken::Bracket)) ||\n-               self.check(&token::OpenDelim(DelimToken::Brace)) {\n-                   self.parse_token_tree().into()\n-            } else if self.eat(&token::Eq) {\n-                let eq = TokenTree::token(token::Eq, self.prev_span);\n-                let mut is_interpolated_expr = false;\n-                if let token::Interpolated(nt) = &self.token.kind {\n-                    if let token::NtExpr(..) = **nt {\n-                        is_interpolated_expr = true;\n-                    }\n-                }\n-                let token_tree = if is_interpolated_expr {\n-                    // We need to accept arbitrary interpolated expressions to continue\n-                    // supporting things like `doc = $expr` that work on stable.\n-                    // Non-literal interpolated expressions are rejected after expansion.\n-                    self.parse_token_tree()\n-                } else {\n-                    self.parse_unsuffixed_lit()?.token_tree()\n-                };\n-                TokenStream::new(vec![eq.into(), token_tree.into()])\n-            } else {\n-                TokenStream::default()\n-            };\n-            ast::AttrItem { path, tokens }\n+            let args = self.parse_attr_args()?;\n+            ast::AttrItem { path, args }\n         })\n     }\n \n@@ -244,7 +220,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    pub(super) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n "}, {"sha": "1112274dc46a511524ba2ce1cf181fa285c01d59", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -922,13 +922,11 @@ impl<'a> Parser<'a> {\n                     // `!`, as an operator, is prefix, so we know this isn't that.\n                     if self.eat(&token::Not) {\n                         // MACRO INVOCATION expression\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n+                        let args = self.parse_mac_args()?;\n                         hi = self.prev_span;\n                         ex = ExprKind::Mac(Mac {\n                             path,\n-                            tts,\n-                            delim,\n-                            span: lo.to(hi),\n+                            args,\n                             prior_type_ascription: self.last_type_ascription,\n                         });\n                     } else if self.check(&token::OpenDelim(token::Brace)) {"}, {"sha": "46addba57c628eb5c5c1724fdb9d59b713377036", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -8,12 +8,12 @@ use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, Us\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, Variant, VariantData, StructField};\n-use syntax::ast::{Mac, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n+use syntax::ast::{Mac, MacArgs, MacDelimiter, Block, BindingMode, FnDecl, FnSig, SelfKind, Param};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::ThinVec;\n use syntax::token;\n-use syntax::tokenstream::{TokenTree, TokenStream};\n+use syntax::tokenstream::{DelimSpan, TokenTree, TokenStream};\n use syntax::source_map::{self, respan, Span};\n use syntax::struct_span_err;\n use syntax_pos::BytePos;\n@@ -432,22 +432,18 @@ impl<'a> Parser<'a> {\n             let prev_span = self.prev_span;\n             self.complain_if_pub_macro(&visibility.node, prev_span);\n \n-            let mac_lo = self.token.span;\n-\n             // Item macro\n             let path = self.parse_path(PathStyle::Mod)?;\n             self.expect(&token::Not)?;\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+            let args = self.parse_mac_args()?;\n+            if args.need_semicolon() && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n             let hi = self.prev_span;\n             let mac = Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: mac_lo.to(hi),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n             let item =\n@@ -500,7 +496,6 @@ impl<'a> Parser<'a> {\n         if self.token.is_path_start() &&\n                 !(self.is_async_fn() && self.token.span.rust_2015()) {\n             let prev_span = self.prev_span;\n-            let lo = self.token.span;\n             let path = self.parse_path(PathStyle::Mod)?;\n \n             if path.segments.len() == 1 {\n@@ -518,16 +513,14 @@ impl<'a> Parser<'a> {\n             *at_end = true;\n \n             // eat a matched-delimiter token tree:\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace {\n+            let args = self.parse_mac_args()?;\n+            if args.need_semicolon() {\n                 self.expect_semi()?;\n             }\n \n             Ok(Some(Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: lo.to(self.prev_span),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             }))\n         } else {\n@@ -1624,33 +1617,31 @@ impl<'a> Parser<'a> {\n         vis: &Visibility,\n         lo: Span\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let token_lo = self.token.span;\n         let (ident, def) = if self.eat_keyword(kw::Macro) {\n             let ident = self.parse_ident()?;\n-            let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n-                match self.parse_token_tree() {\n-                    TokenTree::Delimited(_, _, tts) => tts,\n-                    _ => unreachable!(),\n-                }\n+            let body = if self.check(&token::OpenDelim(token::Brace)) {\n+                self.parse_mac_args()?\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n-                let args = self.parse_token_tree();\n+                let params = self.parse_token_tree();\n+                let pspan = params.span();\n                 let body = if self.check(&token::OpenDelim(token::Brace)) {\n                     self.parse_token_tree()\n                 } else {\n-                    self.unexpected()?;\n-                    unreachable!()\n+                    return self.unexpected();\n                 };\n-                TokenStream::new(vec![\n-                    args.into(),\n-                    TokenTree::token(token::FatArrow, token_lo.to(self.prev_span)).into(),\n+                let bspan = body.span();\n+                let tokens = TokenStream::new(vec![\n+                    params.into(),\n+                    TokenTree::token(token::FatArrow, pspan.between(bspan)).into(),\n                     body.into(),\n-                ])\n+                ]);\n+                let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n+                P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n             } else {\n-                self.unexpected()?;\n-                unreachable!()\n+                return self.unexpected();\n             };\n \n-            (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n+            (ident, ast::MacroDef { body, legacy: false })\n         } else if self.check_keyword(sym::macro_rules) &&\n                   self.look_ahead(1, |t| *t == token::Not) &&\n                   self.look_ahead(2, |t| t.is_ident()) {\n@@ -1660,12 +1651,12 @@ impl<'a> Parser<'a> {\n             self.bump();\n \n             let ident = self.parse_ident()?;\n-            let (delim, tokens) = self.expect_delimited_token_tree()?;\n-            if delim != MacDelimiter::Brace && !self.eat(&token::Semi) {\n+            let body = self.parse_mac_args()?;\n+            if body.need_semicolon() && !self.eat(&token::Semi) {\n                 self.report_invalid_macro_expansion_item();\n             }\n \n-            (ident, ast::MacroDef { tokens, legacy: true })\n+            (ident, ast::MacroDef { body, legacy: true })\n         } else {\n             return Ok(None);\n         };"}, {"sha": "28689720044e8e702f6d80fd08e912f71a2212ae", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -16,7 +16,7 @@ use crate::lexer::UnmatchedBrace;\n \n use syntax::ast::{\n     self, DUMMY_NODE_ID, AttrStyle, Attribute, CrateSugar, Extern, Ident, StrLit,\n-    IsAsync, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n+    IsAsync, MacArgs, MacDelimiter, Mutability, Visibility, VisibilityKind, Unsafety,\n };\n \n use syntax::print::pprust;\n@@ -1010,27 +1010,49 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn expect_delimited_token_tree(&mut self) -> PResult<'a, (MacDelimiter, TokenStream)> {\n-        let delim = match self.token.kind {\n-            token::OpenDelim(delim) => delim,\n-            _ => {\n-                let msg = \"expected open delimiter\";\n-                let mut err = self.fatal(msg);\n-                err.span_label(self.token.span, msg);\n-                return Err(err)\n+    fn parse_mac_args(&mut self) -> PResult<'a, P<MacArgs>> {\n+        self.parse_mac_args_common(true).map(P)\n+    }\n+\n+    fn parse_attr_args(&mut self) -> PResult<'a, MacArgs> {\n+        self.parse_mac_args_common(false)\n+    }\n+\n+    fn parse_mac_args_common(&mut self, delimited_only: bool) -> PResult<'a, MacArgs> {\n+        Ok(if self.check(&token::OpenDelim(DelimToken::Paren)) ||\n+                       self.check(&token::OpenDelim(DelimToken::Bracket)) ||\n+                       self.check(&token::OpenDelim(DelimToken::Brace)) {\n+            match self.parse_token_tree() {\n+                TokenTree::Delimited(dspan, delim, tokens) =>\n+                    // We've confirmed above that there is a delimiter so unwrapping is OK.\n+                    MacArgs::Delimited(dspan, MacDelimiter::from_token(delim).unwrap(), tokens),\n+                _ => unreachable!(),\n             }\n-        };\n-        let tts = match self.parse_token_tree() {\n-            TokenTree::Delimited(_, _, tts) => tts,\n-            _ => unreachable!(),\n-        };\n-        let delim = match delim {\n-            token::Paren => MacDelimiter::Parenthesis,\n-            token::Bracket => MacDelimiter::Bracket,\n-            token::Brace => MacDelimiter::Brace,\n-            token::NoDelim => self.bug(\"unexpected no delimiter\"),\n-        };\n-        Ok((delim, tts.into()))\n+        } else if !delimited_only {\n+            if self.eat(&token::Eq) {\n+                let eq_span = self.prev_span;\n+                let mut is_interpolated_expr = false;\n+                if let token::Interpolated(nt) = &self.token.kind {\n+                    if let token::NtExpr(..) = **nt {\n+                        is_interpolated_expr = true;\n+                    }\n+                }\n+                let token_tree = if is_interpolated_expr {\n+                    // We need to accept arbitrary interpolated expressions to continue\n+                    // supporting things like `doc = $expr` that work on stable.\n+                    // Non-literal interpolated expressions are rejected after expansion.\n+                    self.parse_token_tree()\n+                } else {\n+                    self.parse_unsuffixed_lit()?.token_tree()\n+                };\n+\n+                MacArgs::Eq(eq_span, token_tree.into())\n+            } else {\n+                MacArgs::Empty\n+            }\n+        } else {\n+            return self.unexpected();\n+        })\n     }\n \n     fn parse_or_use_outer_attributes("}, {"sha": "1127c4b2d5f88c0bb65725f789db5ff1164d7ea7", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -338,7 +338,7 @@ impl<'a> Parser<'a> {\n                     (None, self.parse_path(PathStyle::Expr)?)\n                 };\n                 match self.token.kind {\n-                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(lo, path)?,\n+                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(path)?,\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n                         self.parse_pat_range_starting_with_path(lo, qself, path)?\n                     }\n@@ -593,14 +593,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse macro invocation\n-    fn parse_pat_mac_invoc(&mut self, lo: Span, path: Path) -> PResult<'a, PatKind> {\n+    fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n-        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        let args = self.parse_mac_args()?;\n         let mac = Mac {\n             path,\n-            tts,\n-            delim,\n-            span: lo.to(self.prev_span),\n+            args,\n             prior_type_ascription: self.last_type_ascription,\n         };\n         Ok(PatKind::Mac(mac))"}, {"sha": "75bb67d47bc48cfc96044828e932866802387416", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -2,6 +2,7 @@ use super::{Parser, TokenType};\n use crate::maybe_whole;\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n+use syntax::ast::MacArgs;\n use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax::source_map::{Span, BytePos};\n@@ -114,9 +115,9 @@ impl<'a> Parser<'a> {\n     fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         let meta_ident = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref item) => match item.tokens.is_empty() {\n-                    true => Some(item.path.clone()),\n-                    false => None,\n+                token::NtMeta(ref item) => match item.args {\n+                    MacArgs::Empty => Some(item.path.clone()),\n+                    _ => None,\n                 },\n                 _ => None,\n             },"}, {"sha": "b952e8814a361adec72a9e3fec9ad9b7dccd3d48", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -10,7 +10,7 @@ use syntax::ThinVec;\n use syntax::ptr::P;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n-use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac, MacDelimiter};\n+use syntax::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac};\n use syntax::util::classify;\n use syntax::token;\n use syntax::source_map::{respan, Span};\n@@ -93,23 +93,22 @@ impl<'a> Parser<'a> {\n                 }));\n             }\n \n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            let args = self.parse_mac_args()?;\n+            let delim = args.delim();\n             let hi = self.prev_span;\n \n-            let style = if delim == MacDelimiter::Brace {\n+            let style = if delim == token::Brace {\n                 MacStmtStyle::Braces\n             } else {\n                 MacStmtStyle::NoBraces\n             };\n \n             let mac = Mac {\n                 path,\n-                tts,\n-                delim,\n-                span: lo.to(hi),\n+                args,\n                 prior_type_ascription: self.last_type_ascription,\n             };\n-            let kind = if delim == MacDelimiter::Brace ||\n+            let kind = if delim == token::Brace ||\n                           self.token == token::Semi || self.token == token::Eof {\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             }\n@@ -130,7 +129,7 @@ impl<'a> Parser<'a> {\n                 self.warn_missing_semicolon();\n                 StmtKind::Mac(P((mac, style, attrs.into())))\n             } else {\n-                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                let e = self.mk_expr(lo.to(hi), ExprKind::Mac(mac), ThinVec::new());\n                 let e = self.maybe_recover_from_bad_qpath(e, true)?;\n                 let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n                 let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;"}, {"sha": "321427969051c54c24f464334a4d8235cd0a4039", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -177,12 +177,10 @@ impl<'a> Parser<'a> {\n             let path = self.parse_path(PathStyle::Type)?;\n             if self.eat(&token::Not) {\n                 // Macro invocation in type position\n-                let (delim, tts) = self.expect_delimited_token_tree()?;\n+                let args = self.parse_mac_args()?;\n                 let mac = Mac {\n                     path,\n-                    tts,\n-                    delim,\n-                    span: lo.to(self.prev_span),\n+                    args,\n                     prior_type_ascription: self.last_type_ascription,\n                 };\n                 TyKind::Mac(mac)"}, {"sha": "0fb348efece58e2f477e44b1e19457fa7035b264", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -2,11 +2,9 @@\n \n use errors::{PResult, Applicability};\n use rustc_feature::{AttributeTemplate, BUILTIN_ATTRIBUTE_MAP};\n-use syntax::ast::{self, Attribute, AttrKind, Ident, MetaItem, MetaItemKind};\n+use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MetaItem, MetaItemKind};\n use syntax::attr::mk_name_value_item_str;\n use syntax::early_buffered_lints::BufferedEarlyLintId;\n-use syntax::token;\n-use syntax::tokenstream::TokenTree;\n use syntax::sess::ParseSess;\n use syntax_pos::{Symbol, sym};\n \n@@ -19,11 +17,9 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n         Some((name, _, template, _)) if name != sym::rustc_dummy =>\n             check_builtin_attribute(sess, attr, name, template),\n-        _ => if let Some(TokenTree::Token(token)) = attr.get_normal_item().tokens.trees().next() {\n-            if token == token::Eq {\n-                // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n-            }\n+        _ => if let MacArgs::Eq(..) = attr.get_normal_item().args {\n+            // All key-value attributes are restricted to meta-item syntax.\n+            parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n         }\n     }\n }"}, {"sha": "29cfee8408f30d209f21333bd24010b116e61090", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -737,14 +737,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n     }\n \n-    fn visit_mac(&mut self, mac: &Mac) {\n-        // when a new macro kind is added but the author forgets to set it up for expansion\n-        // because that's the only part that won't cause a compiler error\n-        self.session.diagnostic()\n-            .span_bug(mac.span, \"macro invocation missed in expansion; did you forget to override \\\n-                                 the relevant `fold_*()` method in `PlaceholderExpander`?\");\n-    }\n-\n     fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = ii.kind {\n             self.check_fn_decl(&sig.decl);"}, {"sha": "396d948433961ddbb013b8f8fca4660e60bd0a27", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1515,14 +1515,6 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_mac(&mut self, mac: &'l ast::Mac) {\n-        // These shouldn't exist in the AST at this point, log a span bug.\n-        span_bug!(\n-            mac.span,\n-            \"macro invocation should have been expanded out of AST\"\n-        );\n-    }\n-\n     fn visit_pat(&mut self, p: &'l ast::Pat) {\n         self.process_macro_use(p.span);\n         self.process_pat(p);"}, {"sha": "7ee1054dc4846886fd6c177fdb98bc91a776145d", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -482,7 +482,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {\n             let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n-                let tts: Vec<_> = def.stream().into_trees().collect();\n+                let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()\n             } else {\n                 unreachable!()"}, {"sha": "8018e005b12d72ee6c1e4da30dc2c4d49a8ef6a4", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 84, "deletions": 25, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -27,7 +27,7 @@ pub use syntax_pos::symbol::{Ident, Symbol as Name};\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::token::{self, DelimToken};\n-use crate::tokenstream::TokenStream;\n+use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n \n use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP, ExpnId};\n@@ -40,6 +40,7 @@ use rustc_index::vec::Idx;\n use rustc_serialize::{self, Decoder, Encoder};\n use rustc_macros::HashStable_Generic;\n \n+use std::iter;\n use std::fmt;\n \n #[cfg(test)]\n@@ -1372,34 +1373,89 @@ pub enum Movability {\n     Movable,\n }\n \n-/// Represents a macro invocation. The `Path` indicates which macro\n-/// is being invoked, and the vector of token-trees contains the source\n-/// of the macro invocation.\n-///\n-/// N.B., the additional ident for a `macro_rules`-style macro is actually\n-/// stored in the enclosing item.\n+/// Represents a macro invocation. The `path` indicates which macro\n+/// is being invoked, and the `args` are arguments passed to it.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mac {\n     pub path: Path,\n-    pub delim: MacDelimiter,\n-    pub tts: TokenStream,\n-    pub span: Span,\n+    pub args: P<MacArgs>,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+impl Mac {\n+    pub fn span(&self) -> Span {\n+        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+    }\n+}\n+\n+/// Arguments passed to an attribute or a function-like macro.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum MacArgs {\n+    /// No arguments - `#[attr]`.\n+    Empty,\n+    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+    Delimited(DelimSpan, MacDelimiter, TokenStream),\n+    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    Eq(\n+        /// Span of the `=` token.\n+        Span,\n+        /// Token stream of the \"value\".\n+        TokenStream,\n+    ),\n+}\n+\n+impl MacArgs {\n+    pub fn delim(&self) -> DelimToken {\n+        match self {\n+            MacArgs::Delimited(_, delim, _) => delim.to_token(),\n+            MacArgs::Empty | MacArgs::Eq(..) => token::NoDelim,\n+        }\n+    }\n+\n+    pub fn span(&self) -> Option<Span> {\n+        match *self {\n+            MacArgs::Empty => None,\n+            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n+            MacArgs::Eq(eq_span, ref tokens) => Some(eq_span.to(tokens.span().unwrap_or(eq_span))),\n+        }\n+    }\n+\n+    /// Tokens inside the delimiters or after `=`.\n+    /// Proc macros see these tokens, for example.\n+    pub fn inner_tokens(&self) -> TokenStream {\n+        match self {\n+            MacArgs::Empty => TokenStream::default(),\n+            MacArgs::Delimited(.., tokens) |\n+            MacArgs::Eq(.., tokens) => tokens.clone(),\n+        }\n+    }\n+\n+    /// Tokens together with the delimiters or `=`.\n+    /// Use of this method generally means that something suboptimal or hacky is happening.\n+    pub fn outer_tokens(&self) -> TokenStream {\n+        match *self {\n+            MacArgs::Empty => TokenStream::default(),\n+            MacArgs::Delimited(dspan, delim, ref tokens) =>\n+                TokenTree::Delimited(dspan, delim.to_token(), tokens.clone()).into(),\n+            MacArgs::Eq(eq_span, ref tokens) => iter::once(TokenTree::token(token::Eq, eq_span))\n+                                                .chain(tokens.trees()).collect(),\n+        }\n+    }\n+\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace ,_))\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n     Bracket,\n     Brace,\n }\n \n-impl Mac {\n-    pub fn stream(&self) -> TokenStream {\n-        self.tts.clone()\n-    }\n-}\n-\n impl MacDelimiter {\n     crate fn to_token(self) -> DelimToken {\n         match self {\n@@ -1408,22 +1464,25 @@ impl MacDelimiter {\n             MacDelimiter::Brace => DelimToken::Brace,\n         }\n     }\n+\n+    pub fn from_token(delim: DelimToken) -> Option<MacDelimiter> {\n+        match delim {\n+            token::Paren => Some(MacDelimiter::Parenthesis),\n+            token::Bracket => Some(MacDelimiter::Bracket),\n+            token::Brace => Some(MacDelimiter::Brace),\n+            token::NoDelim => None,\n+        }\n+    }\n }\n \n /// Represents a macro definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MacroDef {\n-    pub tokens: TokenStream,\n+    pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub legacy: bool,\n }\n \n-impl MacroDef {\n-    pub fn stream(&self) -> TokenStream {\n-        self.tokens.clone().into()\n-    }\n-}\n-\n // Clippy uses Hash and PartialEq\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq, HashStable_Generic)]\n pub enum StrStyle {\n@@ -2323,7 +2382,7 @@ impl rustc_serialize::Decodable for AttrId {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n-    pub tokens: TokenStream,\n+    pub args: MacArgs,\n }\n \n /// Metadata associated with an item."}, {"sha": "079a0f6fafa2cba57e357162d9e0216cd0f026df", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 70, "deletions": 43, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -10,7 +10,7 @@ pub use crate::ast::Attribute;\n \n use crate::ast;\n use crate::ast::{AttrItem, AttrId, AttrKind, AttrStyle, Name, Ident, Path, PathSegment};\n-use crate::ast::{MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Lit, LitKind, Expr, Item, Local, Stmt, StmtKind, GenericParam};\n use crate::mut_visit::visit_clobber;\n use crate::source_map::{BytePos, Spanned};\n@@ -198,7 +198,7 @@ impl Attribute {\n \n     pub fn is_word(&self) -> bool {\n         if let AttrKind::Normal(item) = &self.kind {\n-            item.tokens.is_empty()\n+            matches!(item.args, MacArgs::Empty)\n         } else {\n             false\n         }\n@@ -278,17 +278,9 @@ impl MetaItem {\n \n impl AttrItem {\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n-        let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n             path: self.path.clone(),\n-            kind: if let Some(kind) = MetaItemKind::from_tokens(&mut tokens) {\n-                if tokens.peek().is_some() {\n-                    return None;\n-                }\n-                kind\n-            } else {\n-                return None;\n-            },\n+            kind: MetaItemKind::from_mac_args(&self.args)?,\n             span,\n         })\n     }\n@@ -362,8 +354,8 @@ crate fn mk_attr_id() -> AttrId {\n     AttrId(id)\n }\n \n-pub fn mk_attr(style: AttrStyle, path: Path, tokens: TokenStream, span: Span) -> Attribute {\n-    mk_attr_from_item(style, AttrItem { path, tokens }, span)\n+pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attribute {\n+    mk_attr_from_item(style, AttrItem { path, args }, span)\n }\n \n pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n@@ -377,12 +369,12 @@ pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attrib\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Inner, item.path, item.kind.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n-    mk_attr(AttrStyle::Outer, item.path, item.kind.tokens(item.span), item.span)\n+    mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(style: AttrStyle, comment: Symbol, span: Span) -> Attribute {\n@@ -520,7 +512,26 @@ impl MetaItem {\n }\n \n impl MetaItemKind {\n-    pub fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n+    pub fn mac_args(&self, span: Span) -> MacArgs {\n+        match self {\n+            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::NameValue(lit) => MacArgs::Eq(span, lit.token_tree().into()),\n+            MetaItemKind::List(list) => {\n+                let mut tts = Vec::new();\n+                for (i, item) in list.iter().enumerate() {\n+                    if i > 0 {\n+                        tts.push(TokenTree::token(token::Comma, span).into());\n+                    }\n+                    tts.extend(item.token_trees_and_joints())\n+                }\n+                MacArgs::Delimited(\n+                    DelimSpan::from_single(span), MacDelimiter::Parenthesis, TokenStream::new(tts)\n+                )\n+            }\n+        }\n+    }\n+\n+    fn token_trees_and_joints(&self, span: Span) -> Vec<TreeAndJoint> {\n         match *self {\n             MetaItemKind::Word => vec![],\n             MetaItemKind::NameValue(ref lit) => {\n@@ -548,33 +559,8 @@ impl MetaItemKind {\n         }\n     }\n \n-    // Premature conversions of `TokenTree`s to `TokenStream`s can hurt\n-    // performance. Do not use this function if `token_trees_and_joints()` can\n-    // be used instead.\n-    pub fn tokens(&self, span: Span) -> TokenStream {\n-        TokenStream::new(self.token_trees_and_joints(span))\n-    }\n-\n-    fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItemKind>\n-        where I: Iterator<Item = TokenTree>,\n-    {\n-        let delimited = match tokens.peek().cloned() {\n-            Some(TokenTree::Token(token)) if token == token::Eq => {\n-                tokens.next();\n-                return if let Some(TokenTree::Token(token)) = tokens.next() {\n-                    Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n-                } else {\n-                    None\n-                };\n-            }\n-            Some(TokenTree::Delimited(_, delim, ref tts)) if delim == token::Paren => {\n-                tokens.next();\n-                tts.clone()\n-            }\n-            _ => return Some(MetaItemKind::Word),\n-        };\n-\n-        let mut tokens = delimited.into_trees().peekable();\n+    fn list_from_tokens(tokens: TokenStream) -> Option<MetaItemKind> {\n+        let mut tokens = tokens.into_trees().peekable();\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n             let item = NestedMetaItem::from_tokens(&mut tokens)?;\n@@ -586,6 +572,47 @@ impl MetaItemKind {\n         }\n         Some(MetaItemKind::List(result))\n     }\n+\n+    fn name_value_from_tokens(\n+        tokens: &mut impl Iterator<Item = TokenTree>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.next() {\n+            Some(TokenTree::Token(token)) =>\n+                Lit::from_token(&token).ok().map(MetaItemKind::NameValue),\n+            _ => None,\n+        }\n+    }\n+\n+    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+        match args {\n+            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) =>\n+                MetaItemKind::list_from_tokens(tokens.clone()),\n+            MacArgs::Delimited(..) => None,\n+            MacArgs::Eq(_, tokens) => {\n+                assert!(tokens.len() == 1);\n+                MetaItemKind::name_value_from_tokens(&mut tokens.trees())\n+            }\n+            MacArgs::Empty => Some(MetaItemKind::Word),\n+        }\n+    }\n+\n+    fn from_tokens(\n+        tokens: &mut iter::Peekable<impl Iterator<Item = TokenTree>>,\n+    ) -> Option<MetaItemKind> {\n+        match tokens.peek() {\n+            Some(TokenTree::Delimited(_, token::Paren, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n+                tokens.next();\n+                MetaItemKind::list_from_tokens(inner_tokens)\n+            }\n+            Some(TokenTree::Delimited(..)) => None,\n+            Some(TokenTree::Token(Token { kind: token::Eq, .. })) => {\n+                tokens.next();\n+                MetaItemKind::name_value_from_tokens(tokens)\n+            }\n+            _ => Some(MetaItemKind::Word),\n+        }\n+    }\n }\n \n impl NestedMetaItem {"}, {"sha": "3dcdd4db6377a2b8173f5d7a2e5c5e68026c80f5", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -12,6 +12,7 @@\n #![feature(const_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n+#![feature(matches_macro)]\n #![feature(nll)]\n #![feature(try_trait)]\n #![feature(slice_patterns)]"}, {"sha": "8889e5df26c528b22dc46a90b4ff9add78e0d068", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -359,6 +359,26 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl }: &mut FnSig, vis: &mut\n     vis.visit_fn_decl(decl);\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+    match args {\n+        MacArgs::Empty => {}\n+        MacArgs::Delimited(dspan, _delim, tokens) => {\n+            visit_delim_span(dspan, vis);\n+            vis.visit_tts(tokens);\n+        }\n+        MacArgs::Eq(eq_span, tokens) => {\n+            vis.visit_span(eq_span);\n+            vis.visit_tts(tokens);\n+        }\n+    }\n+}\n+\n+pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n+    vis.visit_span(&mut dspan.open);\n+    vis.visit_span(&mut dspan.close);\n+}\n+\n pub fn noop_flat_map_field_pattern<T: MutVisitor>(\n     mut fp: FieldPat,\n     vis: &mut T,\n@@ -550,25 +570,24 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n     let Attribute { kind, id: _, style: _, span } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, tokens }) => {\n+        AttrKind::Normal(AttrItem { path, args }) => {\n             vis.visit_path(path);\n-            vis.visit_tts(tokens);\n+            visit_mac_args(args, vis);\n         }\n         AttrKind::DocComment(_) => {}\n     }\n     vis.visit_span(span);\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut Mac, vis: &mut T) {\n-    let Mac { path, delim: _, tts, span, prior_type_ascription: _ } = mac;\n+    let Mac { path, args, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n-    vis.visit_tts(tts);\n-    vis.visit_span(span);\n+    visit_mac_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n-    let MacroDef { tokens, legacy: _ } = macro_def;\n-    vis.visit_tts(tokens);\n+    let MacroDef { body, legacy: _ } = macro_def;\n+    visit_mac_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n@@ -682,9 +701,9 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         token::NtIdent(ident, _is_raw) => vis.visit_ident(ident),\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n-        token::NtMeta(AttrItem { path, tokens }) => {\n+        token::NtMeta(AttrItem { path, args }) => {\n             vis.visit_path(path);\n-            vis.visit_tts(tokens);\n+            visit_mac_args(args, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => vis.visit_tt(tt),"}, {"sha": "4821bbd9ec6e2a63eb548f4936d05a1db3fee2c4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n use crate::ast::{SelfKind, GenericBound, TraitBoundModifier};\n-use crate::ast::{Attribute, MacDelimiter, GenericArg};\n+use crate::ast::{Attribute, GenericArg, MacArgs};\n use crate::util::parser::{self, AssocOp, Fixity};\n use crate::util::comments;\n use crate::attr;\n@@ -639,17 +639,22 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n \n     fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n         self.ibox(0);\n-        match item.tokens.trees().next() {\n-            Some(TokenTree::Delimited(_, delim, tts)) => {\n-                self.print_mac_common(\n-                    Some(MacHeader::Path(&item.path)), false, None, delim, tts, true, span\n-                );\n-            }\n-            tree => {\n+        match &item.args {\n+            MacArgs::Delimited(_, delim, tokens) => self.print_mac_common(\n+                Some(MacHeader::Path(&item.path)),\n+                false,\n+                None,\n+                delim.to_token(),\n+                tokens.clone(),\n+                true,\n+                span,\n+            ),\n+            MacArgs::Empty | MacArgs::Eq(..) => {\n                 self.print_path(&item.path, false, 0);\n-                if tree.is_some() {\n+                if let MacArgs::Eq(_, tokens) = &item.args {\n                     self.space();\n-                    self.print_tts(item.tokens.clone(), true);\n+                    self.word_space(\"=\");\n+                    self.print_tts(tokens.clone(), true);\n                 }\n             }\n         }\n@@ -1097,9 +1102,8 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemKind::Macro(ref m) => {\n                 self.print_mac(m);\n-                match m.delim {\n-                    MacDelimiter::Brace => {},\n-                    _ => self.s.word(\";\")\n+                if m.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1361,9 +1365,8 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Mac(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n@@ -1377,8 +1380,8 @@ impl<'a> State<'a> {\n                     Some(MacHeader::Keyword(kw)),\n                     has_bang,\n                     Some(item.ident),\n-                    DelimToken::Brace,\n-                    macro_def.stream(),\n+                    macro_def.body.delim(),\n+                    macro_def.body.inner_tokens(),\n                     true,\n                     item.span,\n                 );\n@@ -1578,9 +1581,8 @@ impl<'a> State<'a> {\n             }\n             ast::TraitItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1608,9 +1610,8 @@ impl<'a> State<'a> {\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n                 self.print_mac(mac);\n-                match mac.delim {\n-                    MacDelimiter::Brace => {}\n-                    _ => self.s.word(\";\"),\n+                if mac.args.need_semicolon() {\n+                    self.s.word(\";\");\n                 }\n             }\n         }\n@@ -1775,10 +1776,10 @@ impl<'a> State<'a> {\n             Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.delim.to_token(),\n-            m.stream(),\n+            m.args.delim(),\n+            m.args.inner_tokens(),\n             true,\n-            m.span,\n+            m.span(),\n         );\n     }\n "}, {"sha": "491b9a9ade47ac933e6187fd66a66ad00ee624fc", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -225,6 +225,14 @@ impl TokenStream {\n         self.0.len()\n     }\n \n+    pub fn span(&self) -> Option<Span> {\n+        match &**self.0 {\n+            [] => None,\n+            [(tt, _)] => Some(tt.span()),\n+            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n+        }\n+    }\n+\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),"}, {"sha": "4ee09b4b87afac146575b0d9ee10bb7f4fda96a5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -841,11 +841,19 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match attr.kind {\n-        AttrKind::Normal(ref item) => visitor.visit_tts(item.tokens.clone()),\n+        AttrKind::Normal(ref item) => walk_mac_args(visitor, &item.args),\n         AttrKind::DocComment(_) => {}\n     }\n }\n \n+pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+    match args {\n+        MacArgs::Empty => {}\n+        MacArgs::Delimited(_dspan, _delim, tokens) => visitor.visit_tts(tokens.clone()),\n+        MacArgs::Eq(_eq_span, tokens) => visitor.visit_tts(tokens.clone()),\n+    }\n+}\n+\n pub fn walk_tt<'a, V: Visitor<'a>>(visitor: &mut V, tt: TokenTree) {\n     match tt {\n         TokenTree::Token(token) => visitor.visit_token(token),"}, {"sha": "9bfedb3b6174edf5eca8b32bb38dfa50a5e75af1", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -11,7 +11,7 @@ use rustc_parse::DirectoryOwnership;\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n use syntax::ast::{self, AttrItem, Block, Ident, LitKind, NodeId, PatKind, Path};\n-use syntax::ast::{MacStmtStyle, StmtKind, ItemKind};\n+use syntax::ast::{MacArgs, MacStmtStyle, StmtKind, ItemKind};\n use syntax::attr::{self, HasAttrs, is_builtin_attr};\n use syntax::source_map::respan;\n use syntax::feature_gate::{self, feature_err};\n@@ -597,13 +597,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n                     self.gate_proc_macro_expansion_kind(span, fragment_kind);\n-                    let tok_result = expander.expand(self.cx, span, mac.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n                     self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.stream());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n@@ -642,8 +642,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                             => panic!(\"unexpected annotatable\"),\n                     })), DUMMY_SP).into();\n                     let item = attr.unwrap_normal_item();\n-                    let input = self.extract_proc_macro_attr_input(item.tokens, span);\n-                    let tok_result = expander.expand(self.cx, span, input, item_tok);\n+                    if let MacArgs::Eq(..) = item.args {\n+                        self.cx.span_err(span, \"key-value macro attributes are not supported\");\n+                    }\n+                    let tok_result =\n+                        expander.expand(self.cx, span, item.args.inner_tokens(), item_tok);\n                     self.parse_ast_fragment(tok_result, fragment_kind, &item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n@@ -687,23 +690,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn extract_proc_macro_attr_input(&self, tokens: TokenStream, span: Span) -> TokenStream {\n-        let mut trees = tokens.trees();\n-        match trees.next() {\n-            Some(TokenTree::Delimited(_, _, tts)) => {\n-                if trees.next().is_none() {\n-                    return tts.into()\n-                }\n-            }\n-            Some(TokenTree::Token(..)) => {}\n-            None => return TokenStream::default(),\n-        }\n-        self.cx.span_err(span, \"custom attribute invocations must be \\\n-            of the form `#[foo]` or `#[foo(..)]`, the macro name must only be \\\n-            followed by a delimiter token\");\n-        TokenStream::default()\n-    }\n-\n     fn gate_proc_macro_attr_item(&self, span: Span, item: &Annotatable) {\n         let kind = match item {\n             Annotatable::Item(item) => match &item.kind {\n@@ -1560,7 +1546,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             let meta = attr::mk_list_item(Ident::with_dummy_span(sym::doc), items);\n             *at = attr::Attribute {\n                 kind: ast::AttrKind::Normal(\n-                    AttrItem { path: meta.path, tokens: meta.kind.tokens(meta.span) },\n+                    AttrItem { path: meta.path, args: meta.kind.mac_args(meta.span) },\n                 ),\n                 span: at.span,\n                 id: at.id,"}, {"sha": "e3c3655bcf882c634d7d136dfef275db18339955", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -318,8 +318,8 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let body = match def.kind {\n-        ast::ItemKind::MacroDef(ref body) => body,\n+    let (is_legacy, body) = match &def.kind {\n+        ast::ItemKind::MacroDef(macro_def) => (macro_def.legacy, macro_def.body.inner_tokens()),\n         _ => unreachable!(),\n     };\n \n@@ -338,7 +338,7 @@ pub fn compile_declarative_macro(\n                     mbe::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n                 ],\n                 separator: Some(Token::new(\n-                    if body.legacy { token::Semi } else { token::Comma },\n+                    if is_legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n                 kleene: mbe::KleeneToken::new(mbe::KleeneOp::OneOrMore, def.span),\n@@ -350,7 +350,7 @@ pub fn compile_declarative_macro(\n             DelimSpan::dummy(),\n             Lrc::new(mbe::SequenceRepetition {\n                 tts: vec![mbe::TokenTree::token(\n-                    if body.legacy { token::Semi } else { token::Comma },\n+                    if is_legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )],\n                 separator: None,\n@@ -360,7 +360,7 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let argument_map = match parse(sess, body.stream(), &argument_gram, None, true) {\n+    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -435,7 +435,7 @@ pub fn compile_declarative_macro(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, body.legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, is_legacy);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) =>\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value)),"}, {"sha": "a1157667df1b438fd192bc47a0efaf58023ee570", "filename": "src/libsyntax_expand/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -30,13 +30,6 @@ impl MutVisitor for Marker {\n     }\n }\n \n-impl Marker {\n-    fn visit_delim_span(&mut self, dspan: &mut DelimSpan) {\n-        self.visit_span(&mut dspan.open);\n-        self.visit_span(&mut dspan.close);\n-    }\n-}\n-\n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n     Delimited { forest: Lrc<mbe::Delimited>, idx: usize, span: DelimSpan },\n@@ -271,7 +264,7 @@ pub(super) fn transcribe(\n             // jump back out of the Delimited, pop the result_stack and add the new results back to\n             // the previous results (from outside the Delimited).\n             mbe::TokenTree::Delimited(mut span, delimited) => {\n-                marker.visit_delim_span(&mut span);\n+                mut_visit::visit_delim_span(&mut span, &mut marker);\n                 stack.push(Frame::Delimited { forest: delimited, idx: 0, span });\n                 result_stack.push(mem::take(&mut result));\n             }"}, {"sha": "30e83c151e255f347503b5e9edafb6ab3e0b5b44", "filename": "src/libsyntax_expand/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fparse%2Ftests.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -272,7 +272,7 @@ fn ttdelim_span() {\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::Mac(ref mac) => mac.stream().trees().collect(),\n+            ast::ExprKind::Mac(ref mac) => mac.args.inner_tokens().trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "74ade1de20e2a355cab5236db0b5d2982a0a828b", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -3,7 +3,6 @@ use crate::expand::{AstFragment, AstFragmentKind};\n \n use syntax::ast;\n use syntax::source_map::{DUMMY_SP, dummy_spanned};\n-use syntax::tokenstream::TokenStream;\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n use syntax::ThinVec;\n@@ -17,9 +16,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n     fn mac_placeholder() -> ast::Mac {\n         ast::Mac {\n             path: ast::Path { span: DUMMY_SP, segments: Vec::new() },\n-            tts: TokenStream::default().into(),\n-            delim: ast::MacDelimiter::Brace,\n-            span: DUMMY_SP,\n+            args: P(ast::MacArgs::Empty),\n             prior_type_ascription: None,\n         }\n     }"}, {"sha": "8e56e2bb00b4b19b0b4be46370a197e5bdc23b6f", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1,7 +1,7 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n-use syntax::ast::{self, ItemKind};\n+use syntax::ast::{self, ItemKind, MacArgs};\n use syntax::errors::{Applicability, FatalError};\n use syntax::symbol::sym;\n use syntax::token;\n@@ -183,7 +183,7 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n         }\n \n         let parse_derive_paths = |attr: &ast::Attribute| {\n-            if attr.get_normal_item().tokens.is_empty() {\n+            if let MacArgs::Empty = attr.get_normal_item().args {\n                 return Ok(Vec::new());\n             }\n             rustc_parse::parse_in_attr(cx.parse_sess, attr, |p| p.parse_derive_paths())"}, {"sha": "c788d062994050d04edc15e51305494601c1524a", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -6,7 +6,7 @@ use syntax::token::{self, TokenKind};\n use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n-use syntax::tokenstream::{TokenStream, TokenTree};\n+use syntax::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use syntax_expand::base::*;\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -26,19 +26,19 @@ pub fn expand_assert<'cx>(\n     // `core::panic` and `std::panic` are different macros, so we use call-site\n     // context to pick up whichever is currently in scope.\n     let sp = cx.with_call_site_ctxt(sp);\n+    let tokens = custom_message.unwrap_or_else(|| {\n+        TokenStream::from(TokenTree::token(\n+            TokenKind::lit(token::Str, Symbol::intern(&format!(\n+                \"assertion failed: {}\",\n+                pprust::expr_to_string(&cond_expr).escape_debug()\n+            )), None),\n+            DUMMY_SP,\n+        ))\n+    });\n+    let args = P(MacArgs::Delimited(DelimSpan::from_single(sp), MacDelimiter::Parenthesis, tokens));\n     let panic_call = Mac {\n         path: Path::from_ident(Ident::new(sym::panic, sp)),\n-        tts: custom_message.unwrap_or_else(|| {\n-            TokenStream::from(TokenTree::token(\n-                TokenKind::lit(token::Str, Symbol::intern(&format!(\n-                    \"assertion failed: {}\",\n-                    pprust::expr_to_string(&cond_expr).escape_debug()\n-                )), None),\n-                DUMMY_SP,\n-            ))\n-        }).into(),\n-        delim: MacDelimiter::Parenthesis,\n-        span: sp,\n+        args,\n         prior_type_ascription: None,\n     };\n     let if_expr = cx.expr_if("}, {"sha": "98cf8a34742e57c140f2f330587b8a9c6fabf198", "filename": "src/libsyntax_ext/cmdline_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcmdline_attrs.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -16,15 +16,15 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, tokens } = panictry!(parser.parse_attr_item());\n+        let AttrItem { path, args } = panictry!(parser.parse_attr_item());\n         let end_span = parser.token.span;\n         if parser.token != token::Eof {\n             parse_sess.span_diagnostic\n                 .span_err(start_span.to(end_span), \"invalid crate attribute\");\n             continue;\n         }\n \n-        krate.attrs.push(mk_attr(AttrStyle::Inner, path, tokens, start_span.to(end_span)));\n+        krate.attrs.push(mk_attr(AttrStyle::Inner, path, args, start_span.to(end_span)));\n     }\n \n     krate"}, {"sha": "5bd84b43a7801bd14d99dc5bd13739cb7fc14a96", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -340,14 +340,12 @@ pub fn combine_substructure(f: CombineSubstructureFunc<'_>)\n fn find_type_parameters(\n     ty: &ast::Ty,\n     ty_param_names: &[ast::Name],\n-    span: Span,\n     cx: &ExtCtxt<'_>,\n ) -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n     struct Visitor<'a, 'b> {\n         cx: &'a ExtCtxt<'b>,\n-        span: Span,\n         ty_param_names: &'a [ast::Name],\n         types: Vec<P<ast::Ty>>,\n     }\n@@ -366,18 +364,11 @@ fn find_type_parameters(\n         }\n \n         fn visit_mac(&mut self, mac: &ast::Mac) {\n-            let span = mac.span.with_ctxt(self.span.ctxt());\n-            self.cx.span_err(span, \"`derive` cannot be used on items with type macros\");\n+            self.cx.span_err(mac.span(), \"`derive` cannot be used on items with type macros\");\n         }\n     }\n \n-    let mut visitor = Visitor {\n-        ty_param_names,\n-        types: Vec::new(),\n-        span,\n-        cx,\n-    };\n-\n+    let mut visitor = Visitor { cx, ty_param_names, types: Vec::new() };\n     visit::Visitor::visit_ty(&mut visitor, ty);\n \n     visitor.types\n@@ -605,7 +596,7 @@ impl<'a> TraitDef<'a> {\n                     .collect();\n \n                 for field_ty in field_tys {\n-                    let tys = find_type_parameters(&field_ty, &ty_param_names, self.span, cx);\n+                    let tys = find_type_parameters(&field_ty, &ty_param_names, cx);\n \n                     for ty in tys {\n                         // if we have already handled this type, skip it"}, {"sha": "f536d8f940a93871936a4b9172cb0ea5d38b6710", "filename": "src/test/ui/issues/issue-10536.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -11,9 +11,9 @@ macro_rules! foo{\n pub fn main() {\n     foo!();\n \n-    assert!({one! two()}); //~ ERROR expected open delimiter\n+    assert!({one! two()}); //~ ERROR expected one of `(`, `[`, or `{`, found `two`\n \n     // regardless of whether nested macro_rules works, the following should at\n     // least throw a conventional error.\n-    assert!({one! two}); //~ ERROR expected open delimiter\n+    assert!({one! two}); //~ ERROR expected one of `(`, `[`, or `{`, found `two`\n }"}, {"sha": "cc048445871a4bb0a8624250ed5cdaddf8e7755b", "filename": "src/test/ui/issues/issue-10536.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10536.stderr?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1,14 +1,14 @@\n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `two`\n   --> $DIR/issue-10536.rs:14:19\n    |\n LL |     assert!({one! two()});\n-   |                   ^^^ expected open delimiter\n+   |                   ^^^ expected one of `(`, `[`, or `{`\n \n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `two`\n   --> $DIR/issue-10536.rs:18:19\n    |\n LL |     assert!({one! two});\n-   |                   ^^^ expected open delimiter\n+   |                   ^^^ expected one of `(`, `[`, or `{`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f461f06b4dca6d9ff15cf5039f6207cb99ecaf63", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    foo! bar < //~ ERROR expected open delimiter\n+    foo! bar < //~ ERROR expected one of `(`, `[`, or `{`, found `bar`\n }"}, {"sha": "f2365fed273b19dbaab6e7e9e91422350302c65d", "filename": "src/test/ui/parser/macro-bad-delimiter-ident.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-bad-delimiter-ident.stderr?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -1,8 +1,8 @@\n-error: expected open delimiter\n+error: expected one of `(`, `[`, or `{`, found `bar`\n   --> $DIR/macro-bad-delimiter-ident.rs:2:10\n    |\n LL |     foo! bar <\n-   |          ^^^ expected open delimiter\n+   |          ^^^ expected one of `(`, `[`, or `{`\n \n error: aborting due to previous error\n "}, {"sha": "591c1e039bd7579b8406ed0bf2f5bba7aafb1eea", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -18,7 +18,7 @@ mod _test2_inner {\n           //~| ERROR: non-builtin inner attributes are unstable\n }\n \n-#[empty_attr = \"y\"] //~ ERROR: must only be followed by a delimiter token\n+#[empty_attr = \"y\"] //~ ERROR: key-value macro attributes are not supported\n fn _test3() {}\n \n fn attrs() {"}, {"sha": "e939434243b6a1d6c31c1feec1e440cbe614ff49", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf937fa84d98d04642fd855d8daf65430ae48bb3/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=cf937fa84d98d04642fd855d8daf65430ae48bb3", "patch": "@@ -34,7 +34,7 @@ LL |     #![empty_attr]\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add `#![feature(proc_macro_hygiene)]` to the crate attributes to enable\n \n-error: custom attribute invocations must be of the form `#[foo]` or `#[foo(..)]`, the macro name must only be followed by a delimiter token\n+error: key-value macro attributes are not supported\n   --> $DIR/proc-macro-gates.rs:21:1\n    |\n LL | #[empty_attr = \"y\"]"}]}