{"sha": "3db501268010caf4bc072453ef832c5cec25570e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYjUwMTI2ODAxMGNhZjRiYzA3MjQ1M2VmODMyYzVjZWMyNTU3MGU=", "commit": {"author": {"name": "Jose Narvaez", "email": "jnarvaez@zendesk.com", "date": "2015-10-12T10:28:54Z"}, "committer": {"name": "Jose Narvaez", "email": "jnarvaez@zendesk.com", "date": "2015-10-13T09:36:53Z"}, "message": "rustfmt suggested changes.", "tree": {"sha": "3c041076a9aee54e8e753367a5f63f3100fd1080", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c041076a9aee54e8e753367a5f63f3100fd1080"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3db501268010caf4bc072453ef832c5cec25570e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3db501268010caf4bc072453ef832c5cec25570e", "html_url": "https://github.com/rust-lang/rust/commit/3db501268010caf4bc072453ef832c5cec25570e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3db501268010caf4bc072453ef832c5cec25570e/comments", "author": null, "committer": null, "parents": [{"sha": "ec4362da562a4b591a7d120c6677e14ea713481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4362da562a4b591a7d120c6677e14ea713481a", "html_url": "https://github.com/rust-lang/rust/commit/ec4362da562a4b591a7d120c6677e14ea713481a"}], "stats": {"total": 198, "additions": 112, "deletions": 86}, "files": [{"sha": "82e93fa9e3a1ae658deab8cc2f0af4d01a372a09", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3db501268010caf4bc072453ef832c5cec25570e/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db501268010caf4bc072453ef832c5cec25570e/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=3db501268010caf4bc072453ef832c5cec25570e", "patch": "@@ -17,15 +17,17 @@ pub struct LogDirective {\n     pub level: u32,\n }\n \n-pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\",\n-                                               \"DEBUG\"];\n+pub const LOG_LEVEL_NAMES: [&'static str; 4] = [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"];\n \n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n-    level.parse::<u32>().ok().or_else(|| {\n-        let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n-        pos.map(|p| p as u32 + 1)\n-    }).map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n+    level.parse::<u32>()\n+         .ok()\n+         .or_else(|| {\n+             let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n+             pos.map(|p| p as u32 + 1)\n+         })\n+         .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n@@ -40,44 +42,48 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n     let mods = parts.next();\n     let filter = parts.next();\n     if parts.next().is_some() {\n-        println!(\"warning: invalid logging spec '{}', \\\n-                 ignoring it (too many '/'s)\", spec);\n+        println!(\"warning: invalid logging spec '{}', ignoring it (too many '/'s)\",\n+                 spec);\n         return (dirs, None);\n     }\n-    mods.map(|m| { for s in m.split(',') {\n-        if s.is_empty() { continue }\n-        let mut parts = s.split('=');\n-        let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n-            (Some(part0), None, None) => {\n+    mods.map(|m| {\n+        for s in m.split(',') {\n+            if s.is_empty() {\n+                continue\n+            }\n+            let mut parts = s.split('=');\n+            let (log_level, name) = match (parts.next(),\n+                                           parts.next().map(|s| s.trim()),\n+                                           parts.next()) {\n+                (Some(part0), None, None) => {\n                 // if the single argument is a log-level string or number,\n                 // treat that as a global fallback\n-                match parse_log_level(part0) {\n-                    Some(num) => (num, None),\n-                    None => (::MAX_LOG_LEVEL, Some(part0)),\n+                    match parse_log_level(part0) {\n+                        Some(num) => (num, None),\n+                        None => (::MAX_LOG_LEVEL, Some(part0)),\n+                    }\n                 }\n-            }\n-            (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n-            (Some(part0), Some(part1), None) => {\n-                match parse_log_level(part1) {\n-                    Some(num) => (num, Some(part0)),\n-                    _ => {\n-                        println!(\"warning: invalid logging spec '{}', \\\n-                                 ignoring it\", part1);\n-                        continue\n+                (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n+                (Some(part0), Some(part1), None) => {\n+                    match parse_log_level(part1) {\n+                        Some(num) => (num, Some(part0)),\n+                        _ => {\n+                            println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n+                            continue\n+                        }\n                     }\n                 }\n-            },\n-            _ => {\n-                println!(\"warning: invalid logging spec '{}', \\\n-                         ignoring it\", s);\n-                continue\n-            }\n-        };\n-        dirs.push(LogDirective {\n-            name: name.map(str::to_owned),\n-            level: log_level,\n-        });\n-    }});\n+                _ => {\n+                    println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n+                    continue\n+                }\n+            };\n+            dirs.push(LogDirective {\n+                name: name.map(str::to_owned),\n+                level: log_level,\n+            });\n+        }\n+    });\n \n     (dirs, filter.map(str::to_owned))\n }"}, {"sha": "7b846e0bf570798feea51540486b8353dd814fb0", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 69, "deletions": 49, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3db501268010caf4bc072453ef832c5cec25570e/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db501268010caf4bc072453ef832c5cec25570e/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=3db501268010caf4bc072453ef832c5cec25570e", "patch": "@@ -235,7 +235,9 @@ pub trait Logger {\n     fn log(&mut self, record: &LogRecord);\n }\n \n-struct DefaultLogger { handle: Stderr }\n+struct DefaultLogger {\n+    handle: Stderr,\n+}\n \n /// Wraps the log level with fmt implementations.\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n@@ -246,7 +248,7 @@ impl fmt::Display for LogLevel {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as usize - 1) {\n             Some(ref name) => fmt::Display::fmt(name, fmt),\n-            None => fmt::Display::fmt(&level, fmt)\n+            None => fmt::Display::fmt(&level, fmt),\n         }\n     }\n }\n@@ -301,11 +303,10 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| {\n-        s.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() }\n-    });\n+    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| s.borrow_mut().take())\n+                                                     .unwrap_or_else(|| {\n+                                                         box DefaultLogger { handle: io::stderr() }\n+                                                     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n         args: args,\n@@ -320,22 +321,21 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n /// safely\n #[doc(hidden)]\n #[inline(always)]\n-pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n+pub fn log_level() -> u32 {\n+    unsafe { LOG_LEVEL }\n+}\n \n /// Replaces the thread-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n     let mut l = Some(logger);\n-    LOCAL_LOGGER.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), l.take())\n-    })\n+    LOCAL_LOGGER.with(|slot| mem::replace(&mut *slot.borrow_mut(), l.take()))\n }\n \n /// A LogRecord is created by the logging macros, and passed as the only\n /// argument to Loggers.\n #[derive(Debug)]\n pub struct LogRecord<'a> {\n-\n     /// The module path of where the LogRecord originated.\n     pub module_path: &'a str,\n \n@@ -373,7 +373,9 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     // again to whether they should really be here or not. Hence, despite this\n     // check being expanded manually in the logging macro, this function checks\n     // the log level again.\n-    if level > unsafe { LOG_LEVEL } { return false }\n+    if level > unsafe { LOG_LEVEL } {\n+        return false\n+    }\n \n     // This assertion should never get tripped unless we're in an at_exit\n     // handler after logging has been torn down and a logging attempt was made.\n@@ -385,14 +387,11 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n     }\n }\n \n-fn enabled(level: u32,\n-           module: &str,\n-           iter: slice::Iter<directive::LogDirective>)\n-           -> bool {\n+fn enabled(level: u32, module: &str, iter: slice::Iter<directive::LogDirective>) -> bool {\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(&name[..]) => {},\n+            Some(ref name) if !module.starts_with(&name[..]) => {}\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -445,16 +444,14 @@ mod tests {\n \n     #[test]\n     fn match_full_path() {\n-        let dirs = [\n-            LogDirective {\n-                name: Some(\"crate2\".to_string()),\n-                level: 3\n-            },\n-            LogDirective {\n-                name: Some(\"crate1::mod1\".to_string()),\n-                level: 2\n-            }\n-        ];\n+        let dirs = [LogDirective {\n+            name: Some(\"crate2\".to_string()),\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 2,\n+        }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(!enabled(3, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2\", dirs.iter()));\n@@ -463,49 +460,72 @@ mod tests {\n \n     #[test]\n     fn no_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+            name: Some(\"crate2\".to_string()),\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 2,\n+        }];\n         assert!(!enabled(2, \"crate3\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+            name: Some(\"crate2\".to_string()),\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 2,\n+        }];\n         assert!(enabled(3, \"crate2::mod1\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_beginning_longest_match() {\n-        let dirs = [\n-            LogDirective { name: Some(\"crate2\".to_string()), level: 3 },\n-            LogDirective { name: Some(\"crate2::mod\".to_string()), level: 4 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+            name: Some(\"crate2\".to_string()),\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate2::mod\".to_string()),\n+            level: 4,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 2,\n+        }];\n         assert!(enabled(4, \"crate2::mod1\", dirs.iter()));\n         assert!(!enabled(4, \"crate2\", dirs.iter()));\n     }\n \n     #[test]\n     fn match_default() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 2 }\n-        ];\n+        let dirs = [LogDirective {\n+            name: None,\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 2,\n+        }];\n         assert!(enabled(2, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }\n \n     #[test]\n     fn zero_level() {\n-        let dirs = [\n-            LogDirective { name: None, level: 3 },\n-            LogDirective { name: Some(\"crate1::mod1\".to_string()), level: 0 }\n-        ];\n+        let dirs = [LogDirective {\n+            name: None,\n+            level: 3,\n+        },\n+                    LogDirective {\n+            name: Some(\"crate1::mod1\".to_string()),\n+            level: 0,\n+        }];\n         assert!(!enabled(1, \"crate1::mod1\", dirs.iter()));\n         assert!(enabled(3, \"crate2::mod2\", dirs.iter()));\n     }"}]}