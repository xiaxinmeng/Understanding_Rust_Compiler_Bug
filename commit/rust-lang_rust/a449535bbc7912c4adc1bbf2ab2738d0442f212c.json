{"sha": "a449535bbc7912c4adc1bbf2ab2738d0442f212c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0NDk1MzViYmM3OTEyYzRhZGMxYmJmMmFiMjczOGQwNDQyZjIxMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-22T22:03:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-22T22:03:11Z"}, "message": "Auto merge of #66640 - Centril:rollup-862009l, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #66183 (*Syntactically* permit visibilities on trait items & enum variants)\n - #66566 (Document pitfall with `impl PartialEq<B> for A`)\n - #66575 (Remove pretty printing of specific nodes in AST)\n - #66587 (Handle statics in MIR as const pointers)\n - #66619 (follow the convention in this file to use third-person singular verbs)\n - #66633 (Error code's long explanation cleanup)\n - #66637 (fix reoccuring typo: dereferencable -> dereferenceable)\n - #66639 (resolve: more declarative `fresh_binding`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "40cae34afe14332b5c35ee5d819261fbaffcaee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40cae34afe14332b5c35ee5d819261fbaffcaee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a449535bbc7912c4adc1bbf2ab2738d0442f212c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a449535bbc7912c4adc1bbf2ab2738d0442f212c", "html_url": "https://github.com/rust-lang/rust/commit/a449535bbc7912c4adc1bbf2ab2738d0442f212c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a449535bbc7912c4adc1bbf2ab2738d0442f212c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fa0af2327944bd806b2fa382d4e983149ae7e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa0af2327944bd806b2fa382d4e983149ae7e4a", "html_url": "https://github.com/rust-lang/rust/commit/5fa0af2327944bd806b2fa382d4e983149ae7e4a"}, {"sha": "56512b9d427012321384b91dcde5dc8daa83cf89", "url": "https://api.github.com/repos/rust-lang/rust/commits/56512b9d427012321384b91dcde5dc8daa83cf89", "html_url": "https://github.com/rust-lang/rust/commit/56512b9d427012321384b91dcde5dc8daa83cf89"}], "stats": {"total": 1557, "additions": 779, "deletions": 778}, "files": [{"sha": "eb5121dd0e0812cd7e5b77129a189b2e98c00129", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -135,17 +135,23 @@ use self::Ordering::*;\n /// By changing `impl PartialEq for Book` to `impl PartialEq<BookFormat> for Book`,\n /// we allow `BookFormat`s to be compared with `Book`s.\n ///\n-/// You can also combine these implementations to let the `==` operator work with\n-/// two different types:\n-///\n-/// ```\n+/// A comparison like the one above, which ignores some fields of the struct,\n+/// can be dangerous. It can easily lead to an unintended violation of the\n+/// requirements for a partial equivalence relation. For example, if we kept\n+/// the above implementation of `PartialEq<Book>` for `BookFormat` and added an\n+/// implementation of `PartialEq<Book>` for `Book` (either via a `#[derive]` or\n+/// via the manual implementation from the first example) then the result would\n+/// violate transitivity:\n+///\n+/// ```should_panic\n /// #[derive(PartialEq)]\n /// enum BookFormat {\n ///     Paperback,\n ///     Hardback,\n ///     Ebook,\n /// }\n ///\n+/// #[derive(PartialEq)]\n /// struct Book {\n ///     isbn: i32,\n ///     format: BookFormat,\n@@ -163,18 +169,16 @@ use self::Ordering::*;\n ///     }\n /// }\n ///\n-/// impl PartialEq for Book {\n-///     fn eq(&self, other: &Book) -> bool {\n-///         self.isbn == other.isbn\n-///     }\n-/// }\n+/// fn main() {\n+///     let b1 = Book { isbn: 1, format: BookFormat::Paperback };\n+///     let b2 = Book { isbn: 2, format: BookFormat::Paperback };\n ///\n-/// let b1 = Book { isbn: 3, format: BookFormat::Paperback };\n-/// let b2 = Book { isbn: 3, format: BookFormat::Ebook };\n+///     assert!(b1 == BookFormat::Paperback);\n+///     assert!(BookFormat::Paperback == b2);\n ///\n-/// assert!(b1 == BookFormat::Paperback);\n-/// assert!(BookFormat::Ebook != b1);\n-/// assert!(b1 == b2);\n+///     // The following should hold by transitivity but doesn't.\n+///     assert!(b1 == b2); // <-- PANICS\n+/// }\n /// ```\n ///\n /// # Examples"}, {"sha": "61e8b07511a6741f0f86993ea0907db9f1a55d3d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1255,7 +1255,7 @@ pub trait Iterator {\n         Fuse::new(self)\n     }\n \n-    /// Do something with each element of an iterator, passing the value on.\n+    /// Does something with each element of an iterator, passing the value on.\n     ///\n     /// When using iterators, you'll often chain several of them together.\n     /// While working on such code, you might want to check out what's\n@@ -1548,7 +1548,7 @@ pub trait Iterator {\n         (left, right)\n     }\n \n-    /// Reorder the elements of this iterator *in-place* according to the given predicate,\n+    /// Reorders the elements of this iterator *in-place* according to the given predicate,\n     /// such that all those that return `true` precede all those that return `false`.\n     /// Returns the number of `true` elements found.\n     ///"}, {"sha": "bd793fd07bf22e00ad04a9ccf8016778f281bd09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 82, "deletions": 23, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -7,7 +7,7 @@\n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n use crate::hir;\n-use crate::mir::interpret::{PanicInfo, Scalar};\n+use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -292,7 +292,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 None\n             } else {\n                 Some(local)\n@@ -305,7 +305,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable.is_some() {\n+            if self.local_decls[local].is_user_variable() {\n                 Some(local)\n             } else {\n                 None\n@@ -319,7 +319,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if decl.is_user_variable.is_some() && decl.mutability == Mutability::Mut {\n+            if decl.is_user_variable() && decl.mutability == Mutability::Mut {\n                 Some(local)\n             } else {\n                 None\n@@ -333,7 +333,7 @@ impl<'tcx> Body<'tcx> {\n         (1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if (decl.is_user_variable.is_some() || index < self.arg_count + 1)\n+            if (decl.is_user_variable() || index < self.arg_count + 1)\n                 && decl.mutability == Mutability::Mut\n             {\n                 Some(local)\n@@ -689,14 +689,8 @@ pub struct LocalDecl<'tcx> {\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// `Some(binding_mode)` if this corresponds to a user-declared local variable.\n-    ///\n-    /// This is solely used for local diagnostics when generating\n-    /// warnings/errors when compiling the current crate, and\n-    /// therefore it need not be visible across crates. pnkfelix\n-    /// currently hypothesized we *need* to wrap this in a\n-    /// `ClearCrossCrate` as long as it carries as `HirId`.\n-    pub is_user_variable: Option<ClearCrossCrate<BindingForm<'tcx>>>,\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n+    pub local_info: LocalInfo<'tcx>,\n \n     /// `true` if this is an internal local.\n     ///\n@@ -721,6 +715,7 @@ pub struct LocalDecl<'tcx> {\n     /// then it is a temporary created for evaluation of some\n     /// subexpression of some block's tail expression (with no\n     /// intervening statement context).\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub is_block_tail: Option<BlockTailInfo>,\n \n     /// The type of this local.\n@@ -730,6 +725,7 @@ pub struct LocalDecl<'tcx> {\n     /// e.g., via `let x: T`, then we carry that type here. The MIR\n     /// borrow checker needs this information since it can affect\n     /// region inference.\n+    // FIXME(matthewjasper) Don't store in this in `Body`\n     pub user_ty: UserTypeProjections,\n \n     /// The name of the local, used in debuginfo and pretty-printing.\n@@ -824,6 +820,21 @@ pub struct LocalDecl<'tcx> {\n     pub visibility_scope: SourceScope,\n }\n \n+/// Extra information about a local that's used for diagnostics.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum LocalInfo<'tcx> {\n+    /// A user-defined local variable or function parameter\n+    ///\n+    /// The `BindingForm` is solely used for local diagnostics when generating\n+    /// warnings/errors when compiling the current crate, and therefore it need\n+    /// not be visible across crates.\n+    User(ClearCrossCrate<BindingForm<'tcx>>),\n+    /// A temporary created that references the static with the given `DefId`.\n+    StaticRef { def_id: DefId, is_thread_local: bool },\n+    /// Any other temporary, the return place, or an anonymous function parameter.\n+    Other,\n+}\n+\n impl<'tcx> LocalDecl<'tcx> {\n     /// Returns `true` only if local is a binding that can itself be\n     /// made mutable via the addition of the `mut` keyword, namely\n@@ -832,15 +843,17 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// - `let x = ...`,\n     /// - or `match ... { C(x) => ... }`\n     pub fn can_be_made_mutable(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm))) => true,\n+            LocalInfo::User(\n+                ClearCrossCrate::Set(BindingForm::ImplicitSelf(ImplicitSelfKind::Imm)),\n+            ) => true,\n \n             _ => false,\n         }\n@@ -850,26 +863,54 @@ impl<'tcx> LocalDecl<'tcx> {\n     /// `ref mut ident` binding. (Such bindings cannot be made into\n     /// mutable bindings, but the inverse does not necessarily hold).\n     pub fn is_nonref_binding(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                 binding_mode: ty::BindingMode::BindByValue(_),\n                 opt_ty_info: _,\n                 opt_match_place: _,\n                 pat_span: _,\n             }))) => true,\n \n-            Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(_))) => true,\n \n             _ => false,\n         }\n     }\n \n+    /// Returns `true` if this variable is a named variable or function\n+    /// parameter declared by the user.\n+    #[inline]\n+    pub fn is_user_variable(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::User(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Returns `true` if this is a reference to a variable bound in a `match`\n     /// expression that is used to access said variable for the guard of the\n     /// match arm.\n     pub fn is_ref_for_guard(&self) -> bool {\n-        match self.is_user_variable {\n-            Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+        match self.local_info {\n+            LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_static(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `Some` if this is a reference to a static item that is used to\n+    /// access that static\n+    pub fn is_ref_to_thread_local(&self) -> bool {\n+        match self.local_info {\n+            LocalInfo::StaticRef { is_thread_local, .. } => is_thread_local,\n             _ => false,\n         }\n     }\n@@ -918,7 +959,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n             visibility_scope: OUTERMOST_SOURCE_SCOPE,\n             internal,\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n             is_block_tail: None,\n         }\n     }\n@@ -937,7 +978,7 @@ impl<'tcx> LocalDecl<'tcx> {\n             internal: false,\n             is_block_tail: None,\n             name: None, // FIXME maybe we do want some name here?\n-            is_user_variable: None,\n+            local_info: LocalInfo::Other,\n         }\n     }\n }\n@@ -2341,6 +2382,24 @@ pub struct Constant<'tcx> {\n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n+impl Constant<'tcx> {\n+    pub fn check_static_ptr(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n+        match self.literal.val.try_to_scalar() {\n+            Some(Scalar::Ptr(ptr)) => match tcx.alloc_map.lock().get(ptr.alloc_id) {\n+                Some(GlobalAlloc::Static(def_id)) => Some(def_id),\n+                Some(_) => None,\n+                None => {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP, \"MIR cannot contain dangling const pointers\",\n+                    );\n+                    None\n+                },\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// A collection of projections into user types.\n ///\n /// They are projections because a binding can occur a part of a"}, {"sha": "a66a49f103f68f0d6a4b66747a7b733c1e01f535", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 let ty = self.ty\n                              .builtin_deref(true)\n                              .unwrap_or_else(|| {\n-                                 bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n+                                 bug!(\"deref projection of non-dereferenceable ty {:?}\", self)\n                              })\n                              .ty;\n                 PlaceTy::from_ty(ty)"}, {"sha": "fc0e77aab43a4d9a38cebb573df5d6ba3475679c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -691,7 +691,7 @@ macro_rules! make_mir_visitor {\n                     source_info,\n                     visibility_scope,\n                     internal: _,\n-                    is_user_variable: _,\n+                    local_info: _,\n                     is_block_tail: _,\n                 } = local_decl;\n "}, {"sha": "2b1dfcaf68cec9f190878d4c57d9f457451c6353", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 7, "deletions": 110, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,13 +1,10 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n-// ignore-tidy-filelength\n-\n use crate::lint;\n use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n-use crate::hir::map as hir_map;\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -444,7 +441,7 @@ top_level_options!(\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n \n-        pretty: Option<(PpMode, Option<UserIdentifiedItem>)> [UNTRACKED],\n+        pretty: Option<PpMode> [UNTRACKED],\n     }\n );\n \n@@ -2562,7 +2559,7 @@ fn parse_pretty(\n     matches: &getopts::Matches,\n     debugging_opts: &DebuggingOptions,\n     efmt: ErrorOutputType,\n-) -> Option<(PpMode, Option<UserIdentifiedItem>)> {\n+) -> Option<PpMode> {\n     let pretty = if debugging_opts.unstable_options {\n         matches.opt_default(\"pretty\", \"normal\").map(|a| {\n             // stable pretty-print variants only\n@@ -2585,13 +2582,10 @@ fn parse_pretty(\n         efmt: ErrorOutputType,\n         name: &str,\n         extended: bool,\n-    ) -> (PpMode, Option<UserIdentifiedItem>) {\n+    ) -> PpMode {\n         use PpMode::*;\n         use PpSourceMode::*;\n-        let mut split = name.splitn(2, '=');\n-        let first = split.next().unwrap();\n-        let opt_second = split.next();\n-        let first = match (first, extended) {\n+        let first = match (name, extended) {\n             (\"normal\", _) => PpmSource(PpmNormal),\n             (\"identified\", _) => PpmSource(PpmIdentified),\n             (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n@@ -2619,8 +2613,7 @@ fn parse_pretty(\n                 }\n             }\n         };\n-        let opt_second = opt_second.and_then(|s| s.parse::<UserIdentifiedItem>().ok());\n-        (first, opt_second)\n+        first\n     }\n }\n \n@@ -2752,13 +2745,13 @@ pub enum PpMode {\n }\n \n impl PpMode {\n-    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+    pub fn needs_ast_map(&self) -> bool {\n         use PpMode::*;\n         use PpSourceMode::*;\n         match *self {\n             PpmSource(PpmNormal) |\n             PpmSource(PpmEveryBodyLoops) |\n-            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+            PpmSource(PpmIdentified) => false,\n \n             PpmSource(PpmExpanded) |\n             PpmSource(PpmExpandedIdentified) |\n@@ -2780,102 +2773,6 @@ impl PpMode {\n     }\n }\n \n-#[derive(Clone, Debug)]\n-pub enum UserIdentifiedItem {\n-    ItemViaNode(ast::NodeId),\n-    ItemViaPath(Vec<String>),\n-}\n-\n-impl FromStr for UserIdentifiedItem {\n-    type Err = ();\n-    fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n-        use UserIdentifiedItem::*;\n-        Ok(s.parse()\n-            .map(ast::NodeId::from_u32)\n-            .map(ItemViaNode)\n-            .unwrap_or_else(|_| ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())))\n-    }\n-}\n-\n-pub enum NodesMatchingUII<'a> {\n-    NodesMatchingDirect(std::option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n-}\n-\n-impl<'a> Iterator for NodesMatchingUII<'a> {\n-    type Item = ast::NodeId;\n-\n-    fn next(&mut self) -> Option<ast::NodeId> {\n-        use NodesMatchingUII::*;\n-        match self {\n-            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        use NodesMatchingUII::*;\n-        match self {\n-            &NodesMatchingDirect(ref iter) => iter.size_hint(),\n-            &NodesMatchingSuffix(ref iter) => iter.size_hint(),\n-        }\n-    }\n-}\n-\n-impl UserIdentifiedItem {\n-    pub fn reconstructed_input(&self) -> String {\n-        use UserIdentifiedItem::*;\n-        match *self {\n-            ItemViaNode(node_id) => node_id.to_string(),\n-            ItemViaPath(ref parts) => parts.join(\"::\"),\n-        }\n-    }\n-\n-    pub fn all_matching_node_ids<'a, 'hir>(&'a self,\n-                                       map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a> {\n-        use UserIdentifiedItem::*;\n-        use NodesMatchingUII::*;\n-        match *self {\n-            ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => {\n-                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n-            }\n-        }\n-    }\n-\n-    pub fn to_one_node_id(self,\n-                      user_option: &str,\n-                      sess: &Session,\n-                      map: &hir_map::Map<'_>)\n-                      -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n-            let message = format!(\"{} needs NodeId (int) or unique path suffix (b::c::d); got \\\n-                                   {}, which {}\",\n-                                  user_option,\n-                                  self.reconstructed_input(),\n-                                  is_wrong_because);\n-            sess.fatal(&message)\n-        };\n-\n-        let mut saw_node = ast::DUMMY_NODE_ID;\n-        let mut seen = 0;\n-        for node in self.all_matching_node_ids(map) {\n-            saw_node = node;\n-            seen += 1;\n-            if seen > 1 {\n-                fail_because(\"does not resolve uniquely\");\n-            }\n-        }\n-        if seen == 0 {\n-            fail_because(\"does not resolve to any item\");\n-        }\n-\n-        assert!(seen == 1);\n-        return saw_node;\n-    }\n-}\n-\n /// Command-line arguments passed to the compiler have to be incorporated with\n /// the dependency tracking system for incremental compilation. This module\n /// provides some utilities to make this more convenient."}, {"sha": "27891be6b82c5e45093cc7c9c6cac7c52c040cb8", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -5,17 +5,40 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasTyCtxt};\n use syntax::source_map::Span;\n use crate::traits::*;\n+use crate::mir::operand::OperandRef;\n \n use super::FunctionCx;\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn eval_mir_constant_to_operand(\n+        &mut self,\n+        bx: &mut Bx,\n+        constant: &mir::Constant<'tcx>,\n+    ) -> Result<OperandRef<'tcx, Bx::Value>, ErrorHandled> {\n+        match constant.literal.val {\n+            ty::ConstKind::Unevaluated(def_id, substs)\n+                if self.cx.tcx().is_static(def_id) => {\n+                    assert!(substs.is_empty(), \"we don't support generic statics yet\");\n+                    let static_ = bx.get_static(def_id);\n+                    // we treat operands referring to statics as if they were `&STATIC` instead\n+                    let ptr_ty = self.cx.tcx().mk_mut_ptr(self.monomorphize(&constant.literal.ty));\n+                    let layout = bx.layout_of(ptr_ty);\n+                    Ok(OperandRef::from_immediate_or_packed_pair(bx, static_, layout))\n+                }\n+            _ => {\n+                let val = self.eval_mir_constant(constant)?;\n+                Ok(OperandRef::from_const(bx, val))\n+            }\n+        }\n+    }\n+\n     pub fn eval_mir_constant(\n         &mut self,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n         match constant.literal.val {\n-            ty::ConstKind::Unevaluated(def_id, ref substs) => {\n-                let substs = self.monomorphize(substs);\n+            ty::ConstKind::Unevaluated(def_id, substs) => {\n+                let substs = self.monomorphize(&substs);\n                 let instance = ty::Instance::resolve(\n                     self.cx.tcx(), ty::ParamEnv::reveal_all(), def_id, substs,\n                 ).unwrap();"}, {"sha": "310b8aeb4db09d3de5830959c55dae1f72f9fcd5", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -465,8 +465,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::Operand::Constant(ref constant) => {\n-                self.eval_mir_constant(constant)\n-                    .map(|c| OperandRef::from_const(bx, c))\n+                self.eval_mir_constant_to_operand(bx, constant)\n                     .unwrap_or_else(|err| {\n                         match err {\n                             // errored or at least linted"}, {"sha": "ffca2bbc869b2e9f5cc83cc86913ba1ed2d62453", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -285,16 +285,15 @@ pub fn run_compiler(\n \n         compiler.parse()?;\n \n-        if let Some((ppm, opt_uii)) = &sess.opts.pretty {\n-            if ppm.needs_ast_map(&opt_uii) {\n+        if let Some(ppm) = &sess.opts.pretty {\n+            if ppm.needs_ast_map() {\n                 compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n                     let expanded_crate = compiler.expansion()?.take().0;\n                     pretty::print_after_hir_lowering(\n                         tcx,\n                         compiler.input(),\n                         &expanded_crate,\n                         *ppm,\n-                        opt_uii.clone(),\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n                     Ok(())"}, {"sha": "11603f6d9c121c10cfe739747fe2d92cde08e64f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 58, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::map as hir_map;\n use rustc::hir::print as pprust_hir;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::{PpMode, PpSourceMode, UserIdentifiedItem, Input};\n+use rustc::session::config::{PpMode, PpSourceMode, Input};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n@@ -19,7 +19,6 @@ use std::fs::File;\n use std::io::Write;\n use std::path::Path;\n \n-pub use self::UserIdentifiedItem::*;\n pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use crate::abort_on_err;\n@@ -444,14 +443,12 @@ pub fn print_after_hir_lowering<'tcx>(\n     input: &Input,\n     krate: &ast::Crate,\n     ppm: PpMode,\n-    opt_uii: Option<UserIdentifiedItem>,\n     ofile: Option<&Path>,\n ) {\n     if ppm.needs_analysis() {\n         abort_on_err(print_with_analysis(\n             tcx,\n             ppm,\n-            opt_uii,\n             ofile\n         ), tcx.sess);\n         return;\n@@ -461,8 +458,8 @@ pub fn print_after_hir_lowering<'tcx>(\n \n     let mut out = String::new();\n \n-    match (ppm, opt_uii) {\n-            (PpmSource(s), _) => {\n+    match ppm {\n+            PpmSource(s) => {\n                 // Silently ignores an identified node.\n                 let out = &mut out;\n                 let src = src.clone();\n@@ -479,7 +476,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                 })\n             }\n \n-            (PpmHir(s), None) => {\n+            PpmHir(s) => {\n                 let out = &mut out;\n                 let src = src.clone();\n                 call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n@@ -494,52 +491,14 @@ pub fn print_after_hir_lowering<'tcx>(\n                 })\n             }\n \n-            (PpmHirTree(s), None) => {\n+            PpmHirTree(s) => {\n                 let out = &mut out;\n                 call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     *out = format!(\"{:#?}\", krate);\n                 });\n             }\n \n-            (PpmHir(s), Some(uii)) => {\n-                let out = &mut out;\n-                let src = src.clone();\n-                call_with_pp_support_hir(&s, tcx, move |annotation, _| {\n-                    debug!(\"pretty printing source code {:?}\", s);\n-                    let sess = annotation.sess();\n-                    let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n-                    let mut pp_state = pprust_hir::State::new_from_input(sess.source_map(),\n-                                                                         &sess.parse_sess,\n-                                                                         src_name,\n-                                                                         src,\n-                                                                         annotation.pp_ann());\n-                    for node_id in uii.all_matching_node_ids(hir_map) {\n-                        let hir_id = tcx.hir().node_to_hir_id(node_id);\n-                        let node = hir_map.get(hir_id);\n-                        pp_state.print_node(node);\n-                        pp_state.s.space();\n-                        let path = annotation.node_path(hir_id)\n-                            .expect(\"-Z unpretty missing node paths\");\n-                        pp_state.synth_comment(path);\n-                        pp_state.s.hardbreak();\n-                    }\n-                    *out = pp_state.s.eof();\n-                })\n-            }\n-\n-            (PpmHirTree(s), Some(uii)) => {\n-                let out = &mut out;\n-                call_with_pp_support_hir(&s, tcx, move |_annotation, _krate| {\n-                    debug!(\"pretty printing source code {:?}\", s);\n-                    for node_id in uii.all_matching_node_ids(tcx.hir()) {\n-                        let hir_id = tcx.hir().node_to_hir_id(node_id);\n-                        let node = tcx.hir().get(hir_id);\n-                        out.push_str(&format!(\"{:#?}\", node));\n-                    }\n-                })\n-            }\n-\n             _ => unreachable!(),\n         }\n \n@@ -553,27 +512,17 @@ pub fn print_after_hir_lowering<'tcx>(\n fn print_with_analysis(\n     tcx: TyCtxt<'_>,\n     ppm: PpMode,\n-    uii: Option<UserIdentifiedItem>,\n     ofile: Option<&Path>,\n ) -> Result<(), ErrorReported> {\n-    let nodeid = if let Some(uii) = uii {\n-        debug!(\"pretty printing for {:?}\", uii);\n-        Some(uii.to_one_node_id(\"-Z unpretty\", tcx.sess, tcx.hir()))\n-    } else {\n-        debug!(\"pretty printing for whole crate\");\n-        None\n-    };\n-\n     let mut out = Vec::new();\n \n     tcx.analysis(LOCAL_CRATE)?;\n \n     match ppm {\n         PpmMir | PpmMirCFG => {\n-            let def_id = nodeid.map(|nid| tcx.hir().local_def_id_from_node_id(nid));\n             match ppm {\n-                PpmMir => write_mir_pretty(tcx, def_id, &mut out),\n-                PpmMirCFG => write_mir_graphviz(tcx, def_id, &mut out),\n+                PpmMir => write_mir_pretty(tcx, None, &mut out),\n+                PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n                 _ => unreachable!(),\n             }\n         }"}, {"sha": "361cb425809d7a1f06d8b1ca00cd8cbe2b8c61c0", "filename": "src/librustc_error_codes/error_codes/E0015.md", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,14 +1,32 @@\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n+A constant item was initialized with something that is not a constant expression.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0015\n+fn create_some() -> Option<u8> {\n+    Some(1)\n+}\n \n+const FOO: Option<u8> = create_some(); // error!\n ```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n+\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors.\n+\n+To fix this error, you can declare `create_some` as a constant function:\n+\n ```\n+const fn create_some() -> Option<u8> { // declared as a const function\n+    Some(1)\n+}\n \n-See [RFC 911] for more details on the design of `const fn`s.\n+const FOO: Option<u8> = create_some(); // ok!\n \n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n+// These are also working:\n+struct Bar {\n+    x: u8,\n+}\n+\n+const OTHER_FOO: Option<u8> = Some(1);\n+const BAR: Bar = Bar {x: 1};\n+```"}, {"sha": "c1d85705da3a94b02c60b61bc124480f0ac921f1", "filename": "src/librustc_error_codes/error_codes/E0023.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -2,11 +2,18 @@ A pattern attempted to extract an incorrect number of fields from a variant.\n \n Erroneous code example:\n \n-```\n+```compile_fail,E0023\n enum Fruit {\n     Apple(String, String),\n     Pear(u32),\n }\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n+match x {\n+    Fruit::Apple(a) => {}, // error!\n+    _ => {}\n+}\n ```\n \n A pattern used to match against an enum variant must provide a sub-pattern for"}, {"sha": "735a2d1f3fe85cbe9216790c44587fc7fd365412", "filename": "src/librustc_error_codes/error_codes/E0033.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -24,4 +24,4 @@ dereferencing the pointer.\n You can read more about trait objects in the [Trait Objects] section of the\n Reference.\n \n-[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects\n\\ No newline at end of file\n+[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects"}, {"sha": "25e380b02e647f0a1d7b45e43cd87ec142cb796c", "filename": "src/librustc_error_codes/error_codes/E0038.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -62,7 +62,7 @@ cause this problem.)\n In such a case, the compiler cannot predict the return type of `foo()` in a\n situation like the following:\n \n-```compile_fail\n+```compile_fail,E0038\n trait Trait {\n     fn foo(&self) -> Self;\n }\n@@ -183,7 +183,7 @@ fn call_foo(thing: Box<Trait>) {\n \n We don't just need to create a table of all implementations of all methods of\n `Trait`, we need to create such a table, for each different type fed to\n-`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)\\*(3\n types being fed to `foo()`) = 30 implementations!\n \n With real world traits these numbers can grow drastically."}, {"sha": "bb5e4b48d2debee167ef664ff0381a1f5a52270d", "filename": "src/librustc_error_codes/error_codes/E0057.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,6 @@\n-When invoking closures or other implementations of the function traits `Fn`,\n-`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\n-function must match its definition.\n+An invalid number of arguments was given when calling a closure.\n \n-An example using a closure:\n+Erroneous code example:\n \n ```compile_fail,E0057\n let f = |x| x * 3;\n@@ -11,6 +9,10 @@ let b = f(4);       // this works!\n let c = f(2, 3);    // invalid, too many parameters\n ```\n \n+When invoking closures or other implementations of the function traits `Fn`,\n+`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\n+function must match its definition.\n+\n A generic function must be treated similarly:\n \n ```"}, {"sha": "143251c13b069dd7bec12b8a5eb2fa6828b0eeea", "filename": "src/librustc_error_codes/error_codes/E0061.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,3 +1,13 @@\n+An invalid number of arguments was passed when calling a function.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0061\n+fn f(u: i32) {}\n+\n+f(); // error!\n+```\n+\n The number of arguments passed to a function must match the number of arguments\n specified in the function signature.\n "}, {"sha": "36bd8345e4359a9666ff30d451d99a043e734a03", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -388,7 +388,7 @@ fn configure_and_expand_inner<'a>(\n     // If we're actually rustdoc then there's no need to actually compile\n     // anything, so switch everything to just looping\n     let mut should_loop = sess.opts.actually_rustdoc;\n-    if let Some((PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops), _)) = sess.opts.pretty {\n+    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n         should_loop |= true;\n     }\n     if should_loop {"}, {"sha": "943234319906a28ea54cf6391604ef7e0567eb5f", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -189,8 +189,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         location: mir::Location,\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n-            if borrowed_place.ignore_borrow(\n-                self.tcx, self.body, &self.locals_state_at_exit) {\n+            if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n+                debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n             }\n "}, {"sha": "3595312f3f41b41bfa13e92a5d8838a032c2a60f", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -3,8 +3,8 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n-    FakeReadCause, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceBase,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -744,6 +744,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 projection: root_place_projection,\n             }, borrow_span));\n \n+        if let PlaceBase::Local(local) = borrow.borrowed_place.base {\n+            if self.body.local_decls[local].is_ref_to_thread_local() {\n+                let err = self.report_thread_local_value_does_not_live_long_enough(\n+                    drop_span,\n+                    borrow_span,\n+                );\n+                err.buffer(&mut self.errors_buffer);\n+                return;\n+            }\n+        };\n+\n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n             self.classify_drop_access_kind(borrow.borrowed_place.as_ref())\n         {\n@@ -770,9 +781,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             explanation\n         );\n         let err = match (place_desc, explanation) {\n-            (Some(_), _) if self.is_place_thread_local(root_place) => {\n-                self.report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span)\n-            }\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n             //\n@@ -1509,19 +1517,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // place being assigned later.\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n-                is_user_variable: Some(ClearCrossCrate::Clear),\n+                local_info: LocalInfo::User(ClearCrossCrate::Clear),\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable:\n-                    Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: None,\n-                        ..\n-                    }))),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: None,\n+                    ..\n+                }))),\n+                ..\n+            })\n+            | Some(LocalDecl {\n+                local_info: LocalInfo::StaticRef { .. },\n                 ..\n             })\n             | Some(LocalDecl {\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 ..\n             })\n             | None => (self.describe_place(place.as_ref()), assigned_span),"}, {"sha": "3835503b0ef35fdf8597ad6e40e2ca75ed22cbc9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 52, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::def::Namespace;\n use rustc::hir::def_id::DefId;\n use rustc::hir::GeneratorKind;\n use rustc::mir::{\n-    AggregateKind, Constant, Field, Local, LocalKind, Location, Operand,\n+    AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind,\n     Static, StaticKind, Terminator, TerminatorKind,\n };\n@@ -12,7 +12,6 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::print::Print;\n use rustc_errors::DiagnosticBuilder;\n use syntax_pos::Span;\n-use syntax::symbol::sym;\n \n use super::borrow_set::BorrowData;\n use super::MirBorrowckCtxt;\n@@ -178,6 +177,31 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                self.append_place_to_string(\n+                    PlaceRef {\n+                        base: &PlaceBase::Local(local),\n+                        projection: &[],\n+                    },\n+                    buf,\n+                    autoderef,\n+                    &including_downcast,\n+                )?;\n+            },\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref]\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                let local_info = &self.body.local_decls[local].local_info;\n+                if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                    buf.push_str(&self.infcx.tcx.item_name(def_id).as_str());\n+                } else {\n+                    unreachable!();\n+                }\n+            },\n             PlaceRef {\n                 base,\n                 projection: [proj_base @ .., elem],\n@@ -208,32 +232,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 )?;\n                             } else {\n                                 match (proj_base, base) {\n-                                    ([], PlaceBase::Local(local)) => {\n-                                        if self.body.local_decls[*local].is_ref_for_guard() {\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        } else {\n-                                            // FIXME deduplicate this and the _ => body below\n-                                            buf.push_str(&\"*\");\n-                                            self.append_place_to_string(\n-                                                PlaceRef {\n-                                                    base,\n-                                                    projection: proj_base,\n-                                                },\n-                                                buf,\n-                                                autoderef,\n-                                                &including_downcast,\n-                                            )?;\n-                                        }\n-                                    }\n-\n                                     _ => {\n                                         buf.push_str(&\"*\");\n                                         self.append_place_to_string(\n@@ -440,30 +438,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Checks if a place is a thread-local static.\n-    pub fn is_place_thread_local(&self, place_ref: PlaceRef<'cx, 'tcx>) -> bool {\n-        if let PlaceRef {\n-            base: PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                def_id,\n-                ..\n-            }),\n-            projection: [],\n-        } = place_ref {\n-            let attrs = self.infcx.tcx.get_attrs(*def_id);\n-            let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n-\n-            debug!(\n-                \"is_place_thread_local: attrs={:?} is_thread_local={:?}\",\n-                attrs, is_thread_local\n-            );\n-            is_thread_local\n-        } else {\n-            debug!(\"is_place_thread_local: no\");\n-            false\n-        }\n-    }\n-\n     /// Add a note that a type does not implement `Copy`\n     pub(super) fn note_type_does_not_implement_copy(\n         &self,"}, {"sha": "90e39286ec84d02d41479625d11b490abdfc0468", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -308,7 +308,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| mbcx.body.local_decls[*local].is_user_variable.is_none())\n+        .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n@@ -1287,7 +1287,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n                 match place.as_local() {\n-                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                    Some(local) if !self.body.local_decls[local].is_user_variable() => {\n                         if self.body.local_decls[local].ty.is_mutable_ptr() {\n                             // The variable will be marked as mutable by the borrow.\n                             return;\n@@ -1399,34 +1399,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = &borrow.borrowed_place;\n-        let root_place = self.prefixes(place.as_ref(), PrefixSet::All).last().unwrap();\n+        let deref = [ProjectionElem::Deref];\n+        let mut root_place = PlaceRef { base: &place.base, projection: &[] };\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Promoted(..),\n-                ..\n-            }) => {\n+            PlaceBase::Static(_) => {\n                 (true, false)\n             }\n-            PlaceBase::Static(box Static {\n-                kind: StaticKind::Static,\n-                ..\n-            }) => {\n-                // Thread-locals might be dropped after the function exits, but\n-                // \"true\" statics will never be.\n-                (true, self.is_place_thread_local(root_place))\n-            }\n-            PlaceBase::Local(_) => {\n-                // Locals are always dropped at function exit, and if they\n-                // have a destructor it would've been called already.\n-                (false, self.locals_are_invalidated_at_exit)\n+            PlaceBase::Local(local) => {\n+                if self.body.local_decls[*local].is_ref_to_thread_local() {\n+                    // Thread-locals might be dropped after the function exits\n+                    // We have to dereference the outer reference because\n+                    // borrows don't conflict behind shared references.\n+                    root_place.projection = &deref;\n+                    (true, true)\n+                } else {\n+                    (false, self.locals_are_invalidated_at_exit)\n+                }\n             }\n         };\n "}, {"sha": "b1f63d729ba9b027ce5fb0fe79d51e9f4c0b7a5e", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -104,13 +104,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                            opt_match_place: Some((ref opt_match_place, match_span)),\n-                            binding_mode: _,\n-                            opt_ty_info: _,\n-                            pat_span: _,\n-                        }))) = local_decl.is_user_variable\n-                        {\n+                        if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm {\n+                                opt_match_place: Some((ref opt_match_place, match_span)),\n+                                binding_mode: _,\n+                                opt_ty_info: _,\n+                                pat_span: _,\n+                            },\n+                        ))) = local_decl.local_info {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n                                 grouped_errors,\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             (\n                 match kind {\n                     IllegalMoveOriginKind::Static => {\n-                        self.report_cannot_move_from_static(original_path, span)\n+                        unreachable!();\n                     }\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => {\n                         self.report_cannot_move_from_borrowed_content(\n@@ -272,12 +273,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_empty() {\n+        let description = if place.projection.len() == 1 {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: &place.projection[..1],\n+                projection: &[ProjectionElem::Deref],\n             };\n \n             format!(\n@@ -327,6 +328,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     \"variables bound in patterns cannot be moved from \\\n                      until after the end of the pattern guard\");\n                 return err;\n+            } else if decl.is_ref_to_static() {\n+                return self.report_cannot_move_from_static(move_place, span);\n             }\n         }\n \n@@ -508,12 +511,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let Some(\n+            if let LocalInfo::User(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n                     ..\n                 }))\n-            ) = bind_to.is_user_variable {\n+            ) = bind_to.local_info {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {\n                     if pat_snippet.starts_with('&') {"}, {"sha": "404684c07a09c6a45805e10ab3534fcdda8b8c14", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 53, "deletions": 71, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,9 +1,7 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n-use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n-};\n+use rustc::mir::{self, Body, ClearCrossCrate, Local, LocalInfo, Location};\n+use rustc::mir::{Mutability, Place, PlaceRef, PlaceBase, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_index::vec::Idx;\n use syntax_pos::Span;\n@@ -76,6 +74,31 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_for_guard() => {\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                reason = \", as it is immutable for the pattern guard\".to_string();\n+            }\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: [ProjectionElem::Deref],\n+            } if self.body.local_decls[local].is_ref_to_static() => {\n+                if access_place.projection.len() == 1 {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = String::new();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let local_info = &self.body.local_decls[local].local_info;\n+                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n+                        let static_name = &self.infcx.tcx.item_name(def_id);\n+                        reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                    } else {\n+                        bug!(\"is_ref_to_static return true, but not ref to static?\");\n+                    }\n+                }\n+            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., ProjectionElem::Deref],\n@@ -101,15 +124,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         } else {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n-                } else if {\n-                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, proj_base) {\n-                        self.body.local_decls[*local].is_ref_for_guard()\n-                    } else {\n-                        false\n-                    }\n-                } {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n@@ -133,37 +147,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Promoted(..),\n-                        ..\n-                    }),\n-                projection: [],\n-            } => unreachable!(),\n-\n-            PlaceRef {\n-                base:\n-                    PlaceBase::Static(box Static {\n-                        kind: StaticKind::Static,\n-                        def_id,\n-                        ..\n-                    }),\n-                projection: [],\n-            } => {\n-                if let PlaceRef {\n-                    base: &PlaceBase::Static(_),\n-                    projection: &[],\n-                } = access_place.as_ref() {\n-                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n-                    reason = String::new();\n-                } else {\n-                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    let static_name = &self.infcx.tcx.item_name(*def_id);\n-                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n-                }\n+                base: PlaceBase::Static(_),\n+                ..\n             }\n-\n-            PlaceRef {\n+            | PlaceRef {\n                 base: _,\n                 projection: [.., ProjectionElem::Index(_)],\n             }\n@@ -257,15 +244,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n-                    if let ClearCrossCrate::Set(\n+                    if let LocalInfo::User(ClearCrossCrate::Set(\n                         mir::BindingForm::ImplicitSelf(kind)\n-                    ) = local_decl.is_user_variable.as_ref().unwrap() {\n+                    )) = local_decl.local_info {\n                         // Check if the user variable is a `&mut self` and we can therefore\n                         // suggest removing the `&mut`.\n                         //\n                         // Deliberately fall into this case for all implicit self types,\n                         // so that we don't fall in to the next case with them.\n-                        *kind == mir::ImplicitSelfKind::MutRef\n+                        kind == mir::ImplicitSelfKind::MutRef\n                     } else if Some(kw::SelfLower) == local_decl.name {\n                         // Otherwise, check if the name is the self kewyord - in which case\n                         // we have an explicit self. Do the same thing in this case and check\n@@ -360,16 +347,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if {\n-                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n-                    self.body.local_decls[*local].is_user_variable\n-                {\n-                    true\n-                } else {\n-                    false\n-                }\n-            } =>\n-            {\n+            } if self.body.local_decls[*local].is_ref_for_guard() => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.note(\n                     \"variables bound in patterns are immutable until the end of the pattern guard\",\n@@ -384,38 +362,42 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n                 projection: [ProjectionElem::Deref],\n-            } if self.body.local_decls[*local].is_user_variable.is_some() =>\n+            } if self.body.local_decls[*local].is_user_variable() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n-                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_)) => {\n+                let suggestion = match local_decl.local_info {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_))) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByValue(_),\n-                        opt_ty_info,\n-                        ..\n-                    })) => Some(suggest_ampmut(\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByValue(_),\n+                            opt_ty_info,\n+                            ..\n+                        },\n+                    ))) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n                         self.body,\n                         *local,\n                         local_decl,\n-                        *opt_ty_info,\n+                        opt_ty_info,\n                     )),\n \n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByReference(_),\n-                        ..\n-                    })) => {\n+                    LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n+                        mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByReference(_),\n+                            ..\n+                        },\n+                    ))) => {\n                         let pattern_span = local_decl.source_info.span;\n                         suggest_ref_mut(self.infcx.tcx, pattern_span)\n                             .map(|replacement| (pattern_span, replacement))\n                     }\n \n-                    ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n+                    LocalInfo::User(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n \n-                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n+                    _ => unreachable!(),\n                 };\n \n                 let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {"}, {"sha": "99bcfa9bc25995a3babf96a08d11565e51b14463", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1387,7 +1387,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1693,7 +1693,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,"}, {"sha": "c62de2af55f449c5218f7df0cfdf04b0861bbebf", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Body, Place, PlaceBase, Mutability, Static, StaticKind};\n+use rustc::mir::{Body, Place, PlaceBase, Mutability};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -25,7 +25,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        let ignore = match self.base {\n+        let local = match self.base {\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -34,45 +34,56 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             //\n             // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n             // so we don't have to worry about mutation while borrowed.\n-            PlaceBase::Local(index) => {\n+            PlaceBase::Local(local) => {\n                 match locals_state_at_exit {\n-                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::AllAreInvalidated => local,\n                     LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n-                            body.local_decls[index].mutability == Mutability::Not;\n-                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                        ignore\n+                        let ignore = !has_storage_dead_or_moved.contains(local) &&\n+                            body.local_decls[local].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", local, ignore);\n+                        if ignore {\n+                            return true;\n+                        } else {\n+                            local\n+                        }\n                     }\n                 }\n             }\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                false,\n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                tcx.is_mutable_static(def_id)\n-            }\n+            PlaceBase::Static(_) => return true,\n         };\n \n         for (i, elem) in self.projection.iter().enumerate() {\n             let proj_base = &self.projection[..i];\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) = ty.kind {\n-                    // For both derefs of raw pointers and `&T`\n-                    // references, the original path is `Copy` and\n-                    // therefore not significant.  In particular,\n-                    // there is nothing the user can do to the\n-                    // original path that would invalidate the\n-                    // newly created reference -- and if there\n-                    // were, then the user could have copied the\n-                    // original path into a new variable and\n-                    // borrowed *that* one, leaving the original\n-                    // path unborrowed.\n-                    return true;\n+                match ty.kind {\n+                    ty::Ref(_, _, hir::Mutability::Immutable) if i == 0 => {\n+                        // For references to thread-local statics, we do need\n+                        // to track the borrow.\n+                        if body.local_decls[local].is_ref_to_thread_local() {\n+                            continue;\n+                        }\n+                        return true;\n+                    }\n+                    ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) => {\n+                        // For both derefs of raw pointers and `&T`\n+                        // references, the original path is `Copy` and\n+                        // therefore not significant.  In particular,\n+                        // there is nothing the user can do to the\n+                        // original path that would invalidate the\n+                        // newly created reference -- and if there\n+                        // were, then the user could have copied the\n+                        // original path into a new variable and\n+                        // borrowed *that* one, leaving the original\n+                        // path unborrowed.\n+                        return true;\n+                    }\n+                    _ => {}\n                 }\n             }\n         }\n \n-        ignore\n+        false\n     }\n }"}, {"sha": "6db7ec65096ec1fc3777cad4ef50306a2ae2f117", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -45,6 +45,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     literal,\n                 }\n             },\n+            ExprKind::StaticRef { literal, .. } => {\n+                Constant {\n+                    span,\n+                    user_ty: None,\n+                    literal,\n+                }\n+            }\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "f66f1cb73666afdb428db5791c0e37cdb6da55d4", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -197,13 +197,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(place_builder)\n             }\n-            ExprKind::StaticRef { id } => block.and(PlaceBuilder::from(\n-                PlaceBase::Static(Box::new(Static {\n-                    ty: expr.ty,\n-                    kind: StaticKind::Static,\n-                    def_id: id,\n-                }))\n-            )),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let source = this.hir.mirror(source);\n@@ -292,6 +285,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::Yield { .. }\n             | ExprKind::Call { .. } => {"}, {"sha": "37eb0cc9d961e78a637d3d8d3a91e3f52fc2acdd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -270,6 +270,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 resume.and(this.unit_rvalue())\n             }\n             ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n@@ -288,7 +289,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::InlineAsm { .. }\n-            | ExprKind::StaticRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => {\n                 // these do not have corresponding `Rvalue` variants,"}, {"sha": "4dad9ab498f63c06a5959b5a3f94255074f1f61b", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -6,6 +6,7 @@ use crate::hair::*;\n use rustc::hir;\n use rustc::middle::region;\n use rustc::mir::*;\n+use syntax_pos::symbol::sym;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n@@ -63,6 +64,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if let Some(tail_info) = this.block_context.currently_in_block_tail() {\n                 local_decl = local_decl.block_tail(tail_info);\n             }\n+            if let ExprKind::StaticRef { def_id, .. } = expr.kind {\n+                let is_thread_local = this.hir.tcx().has_attr(def_id, sym::thread_local);\n+                local_decl.local_info = LocalInfo::StaticRef {def_id, is_thread_local };\n+            }\n             this.local_decls.push(local_decl)\n         };\n         let temp_place = &Place::from(temp);"}, {"sha": "270a1a6447435361555bcf3deed948b2ae45e62a", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -40,7 +40,6 @@ impl Category {\n             | ExprKind::Index { .. }\n             | ExprKind::SelfRef\n             | ExprKind::VarRef { .. }\n-            | ExprKind::StaticRef { .. }\n             | ExprKind::PlaceTypeAscription { .. }\n             | ExprKind::ValueTypeAscription { .. } => Some(Category::Place),\n \n@@ -66,7 +65,8 @@ impl Category {\n             | ExprKind::Yield { .. }\n             | ExprKind::InlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n-            ExprKind::Literal { .. } => Some(Category::Constant),\n+            ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. } => Some(Category::Constant),\n \n             ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "e991181189f412bc8c7fc2974f5013a2ffeae748", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -231,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         source_info,\n                         visibility_scope: source_info.scope,\n                         internal: true,\n-                        is_user_variable: None,\n+                        local_info: LocalInfo::Other,\n                         is_block_tail: None,\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n@@ -384,7 +384,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // Avoid creating a temporary\n             ExprKind::VarRef { .. } |\n             ExprKind::SelfRef |\n-            ExprKind::StaticRef { .. } |\n             ExprKind::PlaceTypeAscription { .. } |\n             ExprKind::ValueTypeAscription { .. } => {\n                 debug_assert!(Category::of(&expr.kind) == Some(Category::Place));\n@@ -426,6 +425,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Tuple { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::StaticRef { .. }\n             | ExprKind::Yield { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     // should be handled above"}, {"sha": "ada547aa39c9e70f5920072b162220bbfbc9fa08", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     opt_match_place: Some((ref mut match_place, _)),\n                     ..\n-                }))) = self.local_decls[local].is_user_variable\n+                }))) = self.local_decls[local].local_info\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -1734,16 +1734,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             visibility_scope,\n             internal: false,\n             is_block_tail: None,\n-            is_user_variable: Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode,\n-                // hypothetically, `visit_bindings` could try to unzip\n-                // an outermost hir::Ty as we descend, matching up\n-                // idents in pat; but complex w/ unclear UI payoff.\n-                // Instead, just abandon providing diagnostic info.\n-                opt_ty_info: None,\n-                opt_match_place,\n-                pat_span,\n-            }))),\n+            local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                VarBindingForm {\n+                    binding_mode,\n+                    // hypothetically, `visit_bindings` could try to unzip\n+                    // an outermost hir::Ty as we descend, matching up\n+                    // idents in pat; but complex w/ unclear UI payoff.\n+                    // Instead, just abandon providing diagnostic info.\n+                    opt_ty_info: None,\n+                    opt_match_place,\n+                    pat_span,\n+                },\n+            ))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         let locals = if has_guard.0 {\n@@ -1758,7 +1760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope,\n                 internal: false,\n                 is_block_tail: None,\n-                is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n+                local_info: LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::ForGuard {\n                 ref_for_guard,"}, {"sha": "6b458cc244c9e3195564c8cdd060c1206baf8964", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -820,7 +820,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 visibility_scope: source_info.scope,\n                 name,\n                 internal: false,\n-                is_user_variable: None,\n+                local_info: LocalInfo::Other,\n                 is_block_tail: None,\n             });\n         }\n@@ -855,17 +855,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     } => {\n                         self.local_decls[local].mutability = mutability;\n                         self.local_decls[local].source_info.scope = self.source_scope;\n-                        self.local_decls[local].is_user_variable =\n+                        self.local_decls[local].local_info =\n                             if let Some(kind) = self_binding {\n-                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf(*kind)))\n+                                LocalInfo::User(ClearCrossCrate::Set(\n+                                    BindingForm::ImplicitSelf(*kind),\n+                                ))\n                             } else {\n                                 let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n-                                Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                                    binding_mode,\n-                                    opt_ty_info,\n-                                    opt_match_place: Some((Some(place.clone()), span)),\n-                                    pat_span: span,\n-                                })))\n+                                LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                                    VarBindingForm {\n+                                        binding_mode,\n+                                        opt_ty_info,\n+                                        opt_match_place: Some((Some(place.clone()), span)),\n+                                        pat_span: span,\n+                                    },\n+                                )))\n                             };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }"}, {"sha": "402e5aeacbf245acb264ef3b5f12522b37a19e70", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -209,7 +209,9 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n             if place.projection.is_empty() {\n-                trans.kill_all(other_borrows_of_local);\n+                if !self.body.local_decls[local].is_ref_to_static() {\n+                    trans.kill_all(other_borrows_of_local);\n+                }\n                 return;\n             }\n "}, {"sha": "de50755616bb0b7d0b592219017a10b5767433bb", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -5,7 +5,7 @@ use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_index::vec::Idx;\n use rustc::hir::def::{CtorOf, Res, DefKind, CtorKind};\n-use rustc::mir::interpret::{GlobalId, ErrorHandled};\n+use rustc::mir::interpret::{GlobalId, ErrorHandled, Scalar};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, PointerCast};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -961,7 +961,29 @@ fn convert_path_expr<'a, 'tcx>(\n             }\n         }\n \n-        Res::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n+        // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n+        // a constant reference (or constant raw pointer for `static mut`) in MIR\n+        Res::Def(DefKind::Static, id) => {\n+            let ty = cx.tcx.type_of(id);\n+            let ty = if cx.tcx.is_mutable_static(id) {\n+                cx.tcx.mk_mut_ptr(ty)\n+            } else if cx.tcx.is_foreign_item(id) {\n+                cx.tcx.mk_imm_ptr(ty)\n+            } else {\n+                cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_static, ty)\n+            };\n+            let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n+            let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+            ExprKind::Deref { arg: Expr {\n+                ty,\n+                temp_lifetime,\n+                span: expr.span,\n+                kind: ExprKind::StaticRef {\n+                    literal: ty::Const::from_scalar(cx.tcx, Scalar::Ptr(ptr.into()), ty),\n+                    def_id: id,\n+                }\n+            }.to_ref() }\n+        },\n \n         Res::Local(var_hir_id) => convert_var(cx, expr, var_hir_id),\n "}, {"sha": "47644d9ba83725c511a800c5a07b2a5521ce48fb", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -208,9 +208,6 @@ pub enum ExprKind<'tcx> {\n     },\n     /// first argument, used for self in a closure\n     SelfRef,\n-    StaticRef {\n-        id: DefId,\n-    },\n     Borrow {\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n@@ -267,6 +264,14 @@ pub enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A literal containing the address of a `static`.\n+    ///\n+    /// This is only distinguished from `Literal` so that we can register some\n+    /// info for diagnostics.\n+    StaticRef {\n+        literal: &'tcx Const<'tcx>,\n+        def_id: DefId,\n+    },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsmInner,\n         outputs: Vec<ExprRef<'tcx>>,"}, {"sha": "842ef915ad2267025cfa1a5a6ba945eeadd58f75", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -47,7 +47,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n #[derive(Debug, Copy, Clone)]\n pub enum AllocCheck {\n     /// Allocation must be live and not a function pointer.\n-    Dereferencable,\n+    Dereferenceable,\n     /// Allocations needs to be live, but may be a function pointer.\n     Live,\n     /// Allocation may be dead.\n@@ -365,7 +365,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n             Err(ptr) => {\n                 let (allocation_size, alloc_align) =\n-                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferencable)?;\n+                    self.get_size_and_align(ptr.alloc_id, AllocCheck::Dereferenceable)?;\n                 // Test bounds. This also ensures non-NULL.\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n@@ -569,7 +569,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // # Function pointers\n         // (both global from `alloc_map` and local from `extra_fn_ptr_map`)\n         if let Ok(_) = self.get_fn_alloc(id) {\n-            return if let AllocCheck::Dereferencable = liveness {\n+            return if let AllocCheck::Dereferenceable = liveness {\n                 // The caller requested no function pointers.\n                 throw_unsup!(DerefFunctionPointer)\n             } else {"}, {"sha": "e358df2f213ba3047a52bc7c5082baf4bd0e623d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -286,7 +286,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     \"non-integer slice length in wide pointer\", self.path);\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n-                // \"dereferencable\" check performed by Stacked Borrows.\n+                // \"dereferenceable\" check performed by Stacked Borrows.\n             }\n             ty::Foreign(..) => {\n                 // Unsized, but not wide.\n@@ -404,7 +404,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n-                // Make sure this is dereferencable and all.\n+                // Make sure this is dereferenceable and all.\n                 let (size, align) = self.ecx.size_and_align_of(place.meta, place.layout)?\n                     // for the purpose of validity, consider foreign types to have\n                     // alignment and size determined by the layout (size will be 0,"}, {"sha": "17f5e3d4e47a982a990117e2cb680e505da784da", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -152,7 +152,7 @@ fn temp_decl(mutability: Mutability, ty: Ty<'_>, span: Span) -> LocalDecl<'_> {\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other,\n         is_block_tail: None,\n     }\n }"}, {"sha": "9ed1ca740b8e727e94853f61dc622743d94156a9", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n+use rustc::hir::def_id::DefId;\n use syntax_pos::DUMMY_SP;\n \n use super::{ConstKind, Item as ConstCx};\n@@ -32,7 +33,7 @@ pub trait Qualif {\n     /// of the type.\n     fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n \n-    fn in_static(_cx: &ConstCx<'_, 'tcx>, _static: &Static<'tcx>) -> bool {\n+    fn in_static(_cx: &ConstCx<'_, 'tcx>, _def_id: DefId) -> bool {\n         // FIXME(eddyb) should we do anything here for value properties?\n         false\n     }\n@@ -86,18 +87,9 @@ pub trait Qualif {\n                 projection: [],\n             } => per_local(*local),\n             PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted(..),\n-                    ..\n-                }),\n+                base: PlaceBase::Static(_),\n                 projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(static_),\n-                projection: [],\n-            } => {\n-                Self::in_static(cx, static_)\n-            },\n             PlaceRef {\n                 base: _,\n                 projection: [.., _],\n@@ -115,7 +107,9 @@ pub trait Qualif {\n             Operand::Move(ref place) => Self::in_place(cx, per_local, place.as_ref()),\n \n             Operand::Constant(ref constant) => {\n-                if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n+                if let Some(static_) = constant.check_static_ptr(cx.tcx) {\n+                    Self::in_static(cx, static_)\n+                } else if let ty::ConstKind::Unevaluated(def_id, _) = constant.literal.val {\n                     // Don't peek inside trait associated constants.\n                     if cx.tcx.trait_of_item(def_id).is_some() {\n                         Self::in_any_value_of_ty(cx, constant.literal.ty)"}, {"sha": "bee37f69a5ec5640a6c8ab09637e310da058ac3e", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,6 +1,6 @@\n //! The `Visitor` responsible for actually checking a `mir::Body` for invalid operations.\n \n-use rustc::hir::HirId;\n+use rustc::hir::{HirId, def_id::DefId};\n use rustc::middle::lang_items;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n@@ -288,6 +288,15 @@ impl Validator<'a, 'mir, 'tcx> {\n         let span = self.span;\n         self.check_op_spanned(op, span)\n     }\n+\n+    fn check_static(&mut self, def_id: DefId, span: Span) -> CheckOpResult {\n+        let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+        if is_thread_local {\n+            self.check_op_spanned(ops::ThreadLocalAccess, span)\n+        } else {\n+            self.check_op_spanned(ops::StaticAccess, span)\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n@@ -408,17 +417,21 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match place_base {\n             PlaceBase::Local(_) => {}\n-            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n+            PlaceBase::Static(_) => {\n                 bug!(\"Promotion must be run after const validation\");\n             }\n+        }\n+    }\n \n-            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n-                if is_thread_local {\n-                    self.check_op(ops::ThreadLocalAccess);\n-                } else if self.const_kind() != ConstKind::Static || !context.is_mutating_use() {\n-                    self.check_op(ops::StaticAccess);\n-                }\n+    fn visit_operand(\n+        &mut self,\n+        op: &Operand<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_operand(op, location);\n+        if let Operand::Constant(c) = op {\n+            if let Some(def_id) = c.check_static_ptr(self.tcx) {\n+                self.check_static(def_id, self.span);\n             }\n         }\n     }\n@@ -497,14 +510,24 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match elem {\n             ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    self.check_op(ops::MutDeref);\n-                }\n-\n                 let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n                 if let ty::RawPtr(_) = base_ty.kind {\n+                    if proj_base.is_empty() {\n+                        if let (PlaceBase::Local(local), []) = (place_base, proj_base) {\n+                            let decl = &self.body.local_decls[*local];\n+                            if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                                let span = decl.source_info.span;\n+                                self.check_static(def_id, span);\n+                                return;\n+                            }\n+                        }\n+                    }\n                     self.check_op(ops::RawPtrDeref);\n                 }\n+\n+                if context.is_mutating_use() {\n+                    self.check_op(ops::MutDeref);\n+                }\n             }\n \n             ProjectionElem::ConstantIndex {..} |"}, {"sha": "b7cc4e9fcf66cb772cfe199f12c833343c358014", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -206,25 +206,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 // Locals are safe.\n             }\n             PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                bug!(\"unsafety checking should happen before promotion\")\n+                bug!(\"unsafety checking should happen before promotion\");\n             }\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                if self.tcx.is_mutable_static(def_id) {\n-                    self.require_unsafe(\n-                        \"use of mutable static\",\n-                        \"mutable statics can be mutated by multiple threads: aliasing \\\n-                        violations or data races will cause undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                } else if self.tcx.is_foreign_item(def_id) {\n-                    self.require_unsafe(\n-                        \"use of extern static\",\n-                        \"extern statics are not controlled by the Rust type system: \\\n-                        invalid data, aliasing violations or data races will cause \\\n-                        undefined behavior\",\n-                        UnsafetyViolationKind::General,\n-                    );\n-                }\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n+                bug!(\"StaticKind::Static should not exist\");\n             }\n         }\n \n@@ -264,11 +249,31 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n             let old_source_info = self.source_info;\n             if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n-                if self.body.local_decls[*local].internal {\n+                let decl = &self.body.local_decls[*local];\n+                if decl.internal {\n                     // Internal locals are used in the `move_val_init` desugaring.\n                     // We want to check unsafety against the source info of the\n                     // desugaring, rather than the source info of the RHS.\n                     self.source_info = self.body.local_decls[*local].source_info;\n+                } else if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n+                    if self.tcx.is_mutable_static(def_id) {\n+                        self.require_unsafe(\n+                            \"use of mutable static\",\n+                            \"mutable statics can be mutated by multiple threads: aliasing \\\n+                        violations or data races will cause undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    } else if self.tcx.is_foreign_item(def_id) {\n+                        self.require_unsafe(\n+                            \"use of extern static\",\n+                            \"extern statics are not controlled by the Rust type system: \\\n+                        invalid data, aliasing violations or data races will cause \\\n+                        undefined behavior\",\n+                            UnsafetyViolationKind::General,\n+                        );\n+                        return;\n+                    }\n                 }\n             }\n             let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;"}, {"sha": "524b6b087908ce4b7ac57ac5e5e0ba79cac3a6f8", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -432,7 +432,7 @@ fn replace_result_variable<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     let new_ret_local = Local::new(body.local_decls.len());\n     body.local_decls.push(new_ret);\n@@ -967,7 +967,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n \n     make_generator_state_argument_indirect(tcx, def_id, &mut body);\n@@ -985,7 +985,7 @@ fn create_generator_drop_shim<'tcx>(\n         visibility_scope: source_info.scope,\n         internal: false,\n         is_block_tail: None,\n-        is_user_variable: None,\n+        local_info: LocalInfo::Other\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type"}, {"sha": "86ecfbb4fbea59af92f71b2bb0bf1ca70ba89b5d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -512,34 +512,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 projection: [],\n             } => self.validate_local(*local),\n             PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Promoted { .. },\n-                    ..\n-                }),\n+                base: PlaceBase::Static(_),\n                 projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n-            PlaceRef {\n-                base: PlaceBase::Static(box Static {\n-                    kind: StaticKind::Static,\n-                    def_id,\n-                    ..\n-                }),\n-                projection: [],\n-            } => {\n-                // Only allow statics (not consts) to refer to other statics.\n-                // FIXME(eddyb) does this matter at all for promotion?\n-                let is_static = self.const_kind.map_or(false, |k| k.is_static());\n-                if !is_static {\n-                    return Err(Unpromotable);\n-                }\n-\n-                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n-                if is_thread_local {\n-                    return Err(Unpromotable);\n-                }\n-\n-                Ok(())\n-            }\n             PlaceRef {\n                 base: _,\n                 projection: [proj_base @ .., elem],\n@@ -584,7 +559,23 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n             // The qualifs for a constant (e.g. `HasMutInterior`) are checked in\n             // `validate_rvalue` upon access.\n-            Operand::Constant(_) => Ok(()),\n+            Operand::Constant(c) => {\n+                if let Some(def_id) = c.check_static_ptr(self.tcx) {\n+                    // Only allow statics (not consts) to refer to other statics.\n+                    // FIXME(eddyb) does this matter at all for promotion?\n+                    let is_static = self.const_kind.map_or(false, |k| k.is_static());\n+                    if !is_static {\n+                        return Err(Unpromotable);\n+                    }\n+\n+                    let is_thread_local = self.tcx.has_attr(def_id, sym::thread_local);\n+                    if is_thread_local {\n+                        return Err(Unpromotable);\n+                    }\n+                }\n+\n+                Ok(())\n+            },\n         }\n     }\n "}, {"sha": "65fc7cd20439d55c703337707a3cba8dc233405b", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -249,7 +249,10 @@ fn check_operand(\n         Operand::Move(place) | Operand::Copy(place) => {\n             check_place(tcx, place, span, def_id, body)\n         }\n-        Operand::Constant(_) => Ok(()),\n+        Operand::Constant(c) => match c.check_static_ptr(tcx) {\n+            Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+            None => Ok(()),\n+        },\n     }\n }\n \n@@ -285,13 +288,7 @@ fn check_place(\n         }\n     }\n \n-    match place.base {\n-        PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-            Err((span, \"cannot access `static` items in const fn\".into()))\n-        }\n-        PlaceBase::Local(_)\n-        | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n-    }\n+    Ok(())\n }\n \n /// Returns whether `allow_internal_unstable(..., <feature_gate>, ...)` is present."}, {"sha": "eab35a86c69e45b8dd4ed13ce463e17f071bdd68", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1189,26 +1189,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Recovers from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n-    pub(super) fn eat_bad_pub(&mut self) {\n-        // When `unclosed_delims` is populated, it means that the code being parsed is already\n-        // quite malformed, which might mean that, for example, a pub struct definition could be\n-        // parsed as being a trait item, which is invalid and this error would trigger\n-        // unconditionally, resulting in misleading diagnostics. Because of this, we only attempt\n-        // this nice to have recovery for code that is otherwise well formed.\n-        if self.token.is_keyword(kw::Pub) && self.unclosed_delims.is_empty() {\n-            match self.parse_visibility(false) {\n-                Ok(vis) => {\n-                    self.diagnostic()\n-                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\")\n-                        .span_label(vis.span, \"`pub` not permitted here\")\n-                        .emit();\n-                }\n-                Err(mut err) => err.emit(),\n-            }\n-        }\n-    }\n-\n     /// Eats tokens until we can be relatively sure we reached the end of the\n     /// statement. This is something of a best-effort heuristic.\n     ///"}, {"sha": "13645e7144a9bfc72ad8f9c2858d0b9cdc7376c3", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,4 +1,4 @@\n-use super::{Parser, PathStyle};\n+use super::{Parser, PathStyle, FollowedByType};\n use super::diagnostics::{Error, dummy_arg, ConsumeClosingDelim};\n \n use crate::maybe_whole;\n@@ -87,7 +87,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.token.span;\n \n-        let vis = self.parse_visibility(false)?;\n+        let vis = self.parse_visibility(FollowedByType::No)?;\n \n         if self.eat_keyword(kw::Use) {\n             // USE ITEM\n@@ -696,7 +696,7 @@ impl<'a> Parser<'a> {\n         mut attrs: Vec<Attribute>,\n     ) -> PResult<'a, ImplItem> {\n         let lo = self.token.span;\n-        let vis = self.parse_visibility(false)?;\n+        let vis = self.parse_visibility(FollowedByType::No)?;\n         let defaultness = self.parse_defaultness();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             let (name, ty, generics) = self.parse_type_alias()?;\n@@ -883,7 +883,7 @@ impl<'a> Parser<'a> {\n         mut attrs: Vec<Attribute>,\n     ) -> PResult<'a, TraitItem> {\n         let lo = self.token.span;\n-        self.eat_bad_pub();\n+        let vis = self.parse_visibility(FollowedByType::No)?;\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n@@ -899,6 +899,7 @@ impl<'a> Parser<'a> {\n             id: DUMMY_NODE_ID,\n             ident: name,\n             attrs,\n+            vis,\n             generics,\n             kind,\n             span: lo.to(self.prev_span),\n@@ -1129,7 +1130,7 @@ impl<'a> Parser<'a> {\n \n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        let visibility = self.parse_visibility(false)?;\n+        let visibility = self.parse_visibility(FollowedByType::No)?;\n \n         // FOREIGN STATIC ITEM\n         // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n@@ -1339,7 +1340,7 @@ impl<'a> Parser<'a> {\n             let variant_attrs = self.parse_outer_attributes()?;\n             let vlo = self.token.span;\n \n-            self.eat_bad_pub();\n+            let vis = self.parse_visibility(FollowedByType::No)?;\n             let ident = self.parse_ident()?;\n \n             let struct_def = if self.check(&token::OpenDelim(token::Brace)) {\n@@ -1366,6 +1367,7 @@ impl<'a> Parser<'a> {\n \n             let vr = ast::Variant {\n                 ident,\n+                vis,\n                 id: DUMMY_NODE_ID,\n                 attrs: variant_attrs,\n                 data: struct_def,\n@@ -1519,7 +1521,7 @@ impl<'a> Parser<'a> {\n         self.parse_paren_comma_seq(|p| {\n             let attrs = p.parse_outer_attributes()?;\n             let lo = p.token.span;\n-            let vis = p.parse_visibility(true)?;\n+            let vis = p.parse_visibility(FollowedByType::Yes)?;\n             let ty = p.parse_ty()?;\n             Ok(StructField {\n                 span: lo.to(ty.span),\n@@ -1537,7 +1539,7 @@ impl<'a> Parser<'a> {\n     fn parse_struct_decl_field(&mut self) -> PResult<'a, StructField> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        let vis = self.parse_visibility(false)?;\n+        let vis = self.parse_visibility(FollowedByType::No)?;\n         self.parse_single_struct_field(lo, vis, attrs)\n     }\n "}, {"sha": "d810117662c655c0c60287f479957efd69e67181", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -348,6 +348,8 @@ impl SeqSep {\n     }\n }\n \n+pub enum FollowedByType { Yes, No }\n+\n impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n@@ -1120,7 +1122,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+    pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n@@ -1175,7 +1177,9 @@ impl<'a> Parser<'a> {\n                     id: ast::DUMMY_NODE_ID,\n                 };\n                 return Ok(respan(lo.to(self.prev_span), vis));\n-            } else if !can_take_tuple { // Provide this diagnostic if this is not a tuple struct.\n+            } else if let FollowedByType::No = fbt {\n+                // Provide this diagnostic if a type cannot follow;\n+                // in particular, if this is not a tuple struct.\n                 self.recover_incorrect_vis_restriction()?;\n                 // Emit diagnostic, but continue with public visibility.\n             }"}, {"sha": "e189b7175f91dc3eca52de8dfb84c7b9fe2f970d", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -529,6 +529,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n+                    self.invalid_visibility(&variant.vis, None);\n                     for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n@@ -751,6 +752,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n         visit::walk_impl_item(self, ii);\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+        self.invalid_visibility(&ti.vis, None);\n+        visit::walk_trait_item(self, ti);\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffer) -> bool {"}, {"sha": "666c482c680462bb6ff213a0b0658004c8919656", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -69,6 +69,7 @@ impl PatternSource {\n /// Denotes whether the context for the set of already bound bindings is a `Product`\n /// or `Or` context. This is used in e.g., `fresh_binding` and `resolve_pattern_inner`.\n /// See those functions for more information.\n+#[derive(PartialEq)]\n enum PatBoundCtx {\n     /// A product pattern context, e.g., `Variant(a, b)`.\n     Product,\n@@ -1417,21 +1418,12 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         // later passes make about or-patterns.)\n         let ident = ident.modern_and_legacy();\n \n-        // Walk outwards the stack of products / or-patterns and\n-        // find out if the identifier has been bound in any of these.\n-        let mut already_bound_and = false;\n-        let mut already_bound_or = false;\n-        for (is_sum, set) in bindings.iter_mut().rev() {\n-            match (is_sum, set.get(&ident).cloned()) {\n-                // Already bound in a product pattern, e.g. `(a, a)` which is not allowed.\n-                (PatBoundCtx::Product, Some(..)) => already_bound_and = true,\n-                // Already bound in an or-pattern, e.g. `V1(a) | V2(a)`.\n-                // This is *required* for consistency which is checked later.\n-                (PatBoundCtx::Or, Some(..)) => already_bound_or = true,\n-                // Not already bound here.\n-                _ => {}\n-            }\n-        }\n+        let mut bound_iter = bindings.iter().filter(|(_, set)| set.contains(&ident));\n+        // Already bound in a product pattern? e.g. `(a, a)` which is not allowed.\n+        let already_bound_and = bound_iter.clone().any(|(ctx, _)| *ctx == PatBoundCtx::Product);\n+        // Already bound in an or-pattern? e.g. `V1(a) | V2(a)`.\n+        // This is *required* for consistency which is checked later.\n+        let already_bound_or = bound_iter.any(|(ctx, _)| *ctx == PatBoundCtx::Or);\n \n         if already_bound_and {\n             // Overlap in a product pattern somewhere; report an error."}, {"sha": "9dd3bc624a51afc14cb320ab95144f4cc1fc26d4", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -538,7 +538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+    pub fn check_dereferenceable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n         if let PatKind::Binding(..) = inner.kind {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::Dynamic(..) = mt.ty.kind {\n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         discrim_span: Option<Span>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferencable(span, expected, &inner) {\n+        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n             // Here, `demand::subtype` is good enough, but I don't\n             // think any errors can be introduced by using `demand::eqtype`.\n             let inner_ty = self.next_ty_var(TypeVariableOrigin {\n@@ -1103,7 +1103,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (rptr_ty, inner_ty) = if self.check_dereferencable(pat.span, expected, &inner) {\n+        let (rptr_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, &inner) {\n             // `demand::subtype` would be good enough, but using `eqtype` turns\n             // out to be equally general. See (note_1) for details.\n "}, {"sha": "142430769411fd82d6c73407464e4cc2efe1a731", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -982,12 +982,12 @@ pub struct Arm {\n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n+    pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n     pub ident: Ident,\n     pub expr: P<Expr>,\n-    pub span: Span,\n     pub is_shorthand: bool,\n-    pub attrs: ThinVec<Attribute>,\n-    pub id: NodeId,\n     pub is_placeholder: bool,\n }\n \n@@ -1567,12 +1567,14 @@ pub struct FnSig {\n /// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TraitItem {\n+    pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n+    pub span: Span,\n+    pub vis: Visibility,\n     pub ident: Ident,\n-    pub attrs: Vec<Attribute>,\n+\n     pub generics: Generics,\n     pub kind: TraitItemKind,\n-    pub span: Span,\n     /// See `Item::tokens` for what this is.\n     pub tokens: Option<TokenStream>,\n }\n@@ -1588,14 +1590,15 @@ pub enum TraitItemKind {\n /// Represents anything within an `impl` block.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImplItem {\n+    pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub ident: Ident,\n+    pub span: Span,\n     pub vis: Visibility,\n+    pub ident: Ident,\n+\n     pub defaultness: Defaultness,\n-    pub attrs: Vec<Attribute>,\n     pub generics: Generics,\n     pub kind: ImplItemKind,\n-    pub span: Span,\n     /// See `Item::tokens` for what this is.\n     pub tokens: Option<TokenStream>,\n }\n@@ -2174,22 +2177,24 @@ pub struct GlobalAsm {\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n-\n /// Enum variant.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Variant {\n-    /// Name of the variant.\n-    pub ident: Ident,\n     /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n     /// Id of the variant (not the constructor, see `VariantData::ctor_id()`).\n     pub id: NodeId,\n+    /// Span\n+    pub span: Span,\n+    /// The visibility of the variant. Syntactically accepted but not semantically.\n+    pub vis: Visibility,\n+    /// Name of the variant.\n+    pub ident: Ident,\n+\n     /// Fields and constructor id of the variant.\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n-    /// Span\n-    pub span: Span,\n     /// Is a macro placeholder\n     pub is_placeholder: bool,\n }\n@@ -2368,12 +2373,13 @@ impl VisibilityKind {\n /// E.g., `bar: usize` as in `struct Foo { bar: usize }`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct StructField {\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n     pub span: Span,\n-    pub ident: Option<Ident>,\n     pub vis: Visibility,\n-    pub id: NodeId,\n+    pub ident: Option<Ident>,\n+\n     pub ty: P<Ty>,\n-    pub attrs: Vec<Attribute>,\n     pub is_placeholder: bool,\n }\n \n@@ -2417,12 +2423,13 @@ impl VariantData {\n /// The name might be a dummy name in case of anonymous items.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n-    pub kind: ItemKind,\n-    pub vis: Visibility,\n     pub span: Span,\n+    pub vis: Visibility,\n+    pub ident: Ident,\n+\n+    pub kind: ItemKind,\n \n     /// Original tokens this item was parsed from. This isn't necessarily\n     /// available for all items, although over time more and more items should\n@@ -2579,12 +2586,13 @@ impl ItemKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ForeignItem {\n-    pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n-    pub kind: ForeignItemKind,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n+    pub ident: Ident,\n+\n+    pub kind: ForeignItemKind,\n }\n \n /// An item within an `extern` block."}, {"sha": "a7bd587ac9bfb108ed9cf885f6b69be280340c78", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -472,16 +472,17 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n     items.flat_map_in_place(|item| vis.flat_map_foreign_item(item));\n }\n \n-pub fn noop_flat_map_variant<T: MutVisitor>(mut variant: Variant, vis: &mut T)\n+pub fn noop_flat_map_variant<T: MutVisitor>(mut variant: Variant, visitor: &mut T)\n     -> SmallVec<[Variant; 1]>\n {\n-    let Variant { ident, attrs, id, data, disr_expr, span, is_placeholder: _ } = &mut variant;\n-    vis.visit_ident(ident);\n-    visit_attrs(attrs, vis);\n-    vis.visit_id(id);\n-    vis.visit_variant_data(data);\n-    visit_opt(disr_expr, |disr_expr| vis.visit_anon_const(disr_expr));\n-    vis.visit_span(span);\n+    let Variant { ident, vis, attrs, id, data, disr_expr, span, is_placeholder: _ } = &mut variant;\n+    visitor.visit_ident(ident);\n+    visitor.visit_vis(vis);\n+    visit_attrs(attrs, visitor);\n+    visitor.visit_id(id);\n+    visitor.visit_variant_data(data);\n+    visit_opt(disr_expr, |disr_expr| visitor.visit_anon_const(disr_expr));\n+    visitor.visit_span(span);\n     smallvec![variant]\n }\n \n@@ -916,32 +917,33 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     }\n }\n \n-pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, vis: &mut T)\n+pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, visitor: &mut T)\n     -> SmallVec<[TraitItem; 1]>\n {\n-    let TraitItem { id, ident, attrs, generics, kind, span, tokens: _ } = &mut item;\n-    vis.visit_id(id);\n-    vis.visit_ident(ident);\n-    visit_attrs(attrs, vis);\n-    vis.visit_generics(generics);\n+    let TraitItem { id, ident, vis, attrs, generics, kind, span, tokens: _ } = &mut item;\n+    visitor.visit_id(id);\n+    visitor.visit_ident(ident);\n+    visitor.visit_vis(vis);\n+    visit_attrs(attrs, visitor);\n+    visitor.visit_generics(generics);\n     match kind {\n         TraitItemKind::Const(ty, default) => {\n-            vis.visit_ty(ty);\n-            visit_opt(default, |default| vis.visit_expr(default));\n+            visitor.visit_ty(ty);\n+            visit_opt(default, |default| visitor.visit_expr(default));\n         }\n         TraitItemKind::Method(sig, body) => {\n-            visit_fn_sig(sig, vis);\n-            visit_opt(body, |body| vis.visit_block(body));\n+            visit_fn_sig(sig, visitor);\n+            visit_opt(body, |body| visitor.visit_block(body));\n         }\n         TraitItemKind::Type(bounds, default) => {\n-            visit_bounds(bounds, vis);\n-            visit_opt(default, |default| vis.visit_ty(default));\n+            visit_bounds(bounds, visitor);\n+            visit_opt(default, |default| visitor.visit_ty(default));\n         }\n         TraitItemKind::Macro(mac) => {\n-            vis.visit_mac(mac);\n+            visitor.visit_mac(mac);\n         }\n     }\n-    vis.visit_span(span);\n+    visitor.visit_span(span);\n \n     smallvec![item]\n }"}, {"sha": "d7725acb5d45077deb8dd47be58eb9260c2e9388", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -50,6 +50,7 @@ fn test_variant_to_string() {\n \n         let var = ast::Variant {\n             ident,\n+            vis: source_map::respan(syntax_pos::DUMMY_SP, ast::VisibilityKind::Inherited),\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),"}, {"sha": "f7b06c55a3a2eb9ee7851a11f91466075196ba0c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -310,6 +310,7 @@ pub fn walk_variant<'a, V: Visitor<'a>>(visitor: &mut V, variant: &'a Variant)\n     where V: Visitor<'a>,\n {\n     visitor.visit_ident(variant.ident);\n+    visitor.visit_vis(&variant.vis);\n     visitor.visit_variant_data(&variant.data);\n     walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n     walk_list!(visitor, visit_attribute, &variant.attrs);\n@@ -581,6 +582,7 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n }\n \n pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) {\n+    visitor.visit_vis(&trait_item.vis);\n     visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);"}, {"sha": "7fe37f377a8d01493855d40fbfde084523fa7ab0", "filename": "src/libsyntax_expand/build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbuild.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -582,12 +582,13 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn variant(&self, span: Span, ident: Ident, tys: Vec<P<ast::Ty>> ) -> ast::Variant {\n+        let vis_span = span.shrink_to_lo();\n         let fields: Vec<_> = tys.into_iter().map(|ty| {\n             ast::StructField {\n                 span: ty.span,\n                 ty,\n                 ident: None,\n-                vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                vis: respan(vis_span, ast::VisibilityKind::Inherited),\n                 attrs: Vec::new(),\n                 id: ast::DUMMY_NODE_ID,\n                 is_placeholder: false,\n@@ -606,6 +607,7 @@ impl<'a> ExtCtxt<'a> {\n             disr_expr: None,\n             id: ast::DUMMY_NODE_ID,\n             ident,\n+            vis: respan(vis_span, ast::VisibilityKind::Inherited),\n             span,\n             is_placeholder: false,\n         }"}, {"sha": "bf7960f90660a86aa4b12f5c15d2eeca4bb8b49c", "filename": "src/libsyntax_expand/mbe/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -77,7 +77,7 @@ use TokenTreeOrTokenTreeSlice::*;\n use crate::mbe::{self, TokenTree};\n \n use rustc_parse::Directory;\n-use rustc_parse::parser::{Parser, PathStyle};\n+use rustc_parse::parser::{Parser, PathStyle, FollowedByType};\n use syntax::ast::{Ident, Name};\n use syntax::print::pprust;\n use syntax::sess::ParseSess;\n@@ -933,7 +933,7 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         }\n         sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n         sym::meta => token::NtMeta(p.parse_attr_item()?),\n-        sym::vis => token::NtVis(p.parse_visibility(true)?),\n+        sym::vis => token::NtVis(p.parse_visibility(FollowedByType::Yes)?),\n         sym::lifetime => if p.check_lifetime() {\n             token::NtLifetime(p.expect_lifetime().ident)\n         } else {"}, {"sha": "36a097000767bb8d6ccb840723504ed2d63c6865", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -53,7 +53,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n             tokens: None,\n         })]),\n         AstFragmentKind::TraitItems => AstFragment::TraitItems(smallvec![ast::TraitItem {\n-            id, span, ident, attrs, generics,\n+            id, span, ident, vis, attrs, generics,\n             kind: ast::TraitItemKind::Macro(mac_placeholder()),\n             tokens: None,\n         }]),\n@@ -150,6 +150,7 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId) -> AstFragment {\n                 id,\n                 ident,\n                 span,\n+                vis,\n                 is_placeholder: true,\n             }\n         ])"}, {"sha": "d14ec0397166f05cf2f9df071e8cc4e1ce227d26", "filename": "src/test/mir-opt/const_prop/read_immutable_static.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fread_immutable_static.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -10,10 +10,12 @@ fn main() {\n // START rustc.main.ConstProp.before.mir\n //  bb0: {\n //      ...\n-//      _2 = (FOO: u8);\n+//      _3 = const Scalar(AllocId(0).0x0) : &u8;\n+//      _2 = (*_3);\n //      ...\n-//      _3 = (FOO: u8);\n-//      _1 = Add(move _2, move _3);\n+//      _5 = const Scalar(AllocId(0).0x0) : &u8;\n+//      _4 = (*_5);\n+//      _1 = Add(move _2, move _4);\n //      ...\n //  }\n // END rustc.main.ConstProp.before.mir\n@@ -22,8 +24,8 @@ fn main() {\n //      ...\n //      _2 = const 2u8;\n //      ...\n-//      _3 = const 2u8;\n-//      _1 = Add(move _2, move _3);\n+//      _4 = const 2u8;\n+//      _1 = Add(move _2, move _4);\n //      ...\n //  }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "899457fc7486e5cb9d1689a7d2ba20467782c0a8", "filename": "src/test/run-make-fulldeps/pretty-print-path-suffix/Makefile", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2FMakefile?ref=5fa0af2327944bd806b2fa382d4e983149ae7e4a", "patch": "@@ -1,9 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) -o $(TMPDIR)/foo.out -Z unpretty=hir=foo input.rs\n-\t$(RUSTC) -o $(TMPDIR)/nest_foo.out -Z unpretty=hir=nest::foo input.rs\n-\t$(RUSTC) -o $(TMPDIR)/foo_method.out -Z unpretty=hir=foo_method input.rs\n-\tdiff -u $(TMPDIR)/foo.out foo.pp\n-\tdiff -u $(TMPDIR)/nest_foo.out nest_foo.pp\n-\tdiff -u $(TMPDIR)/foo_method.out foo_method.pp"}, {"sha": "fa754af95600559c4e87e1aed494413b78af9ee3", "filename": "src/test/run-make-fulldeps/pretty-print-path-suffix/foo.pp", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo.pp", "raw_url": "https://github.com/rust-lang/rust/raw/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo.pp?ref=5fa0af2327944bd806b2fa382d4e983149ae7e4a", "patch": "@@ -1,5 +0,0 @@\n-\n-pub fn foo() -> i32 { 45 } /* foo */\n-\n-\n-pub fn foo() -> &'static str { \"i am a foo.\" } /* nest::foo */"}, {"sha": "2408c3a208fdda732b0456394e399e019ed92bfe", "filename": "src/test/run-make-fulldeps/pretty-print-path-suffix/foo_method.pp", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo_method.pp", "raw_url": "https://github.com/rust-lang/rust/raw/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo_method.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Ffoo_method.pp?ref=5fa0af2327944bd806b2fa382d4e983149ae7e4a", "patch": "@@ -1,7 +0,0 @@\n-\n-\n-\n-\n-fn foo_method(self: &Self)\n- -> &'static str { return \"i am very similar to foo.\"; } /*\n-nest::{{impl}}::foo_method */"}, {"sha": "d075c46d8b0034d767519ec16585c2df6b1bd0d2", "filename": "src/test/run-make-fulldeps/pretty-print-path-suffix/input.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Finput.rs?ref=5fa0af2327944bd806b2fa382d4e983149ae7e4a", "patch": "@@ -1,18 +0,0 @@\n-#![crate_type=\"lib\"]\n-\n-pub fn\n-foo() -> i32\n-{ 45 }\n-\n-pub fn bar() -> &'static str { \"i am not a foo.\" }\n-\n-pub mod nest {\n-    pub fn foo() -> &'static str { \"i am a foo.\" }\n-\n-    struct S;\n-    impl S {\n-        fn foo_method(&self) -> &'static str {\n-            return \"i am very similar to foo.\";\n-        }\n-    }\n-}"}, {"sha": "0be392976da1753c4952a6ddd8548bcdad3f5d07", "filename": "src/test/run-make-fulldeps/pretty-print-path-suffix/nest_foo.pp", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Fnest_foo.pp", "raw_url": "https://github.com/rust-lang/rust/raw/5fa0af2327944bd806b2fa382d4e983149ae7e4a/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Fnest_foo.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fpretty-print-path-suffix%2Fnest_foo.pp?ref=5fa0af2327944bd806b2fa382d4e983149ae7e4a", "patch": "@@ -1,4 +0,0 @@\n-\n-\n-\n-pub fn foo() -> &'static str { \"i am a foo.\" } /* nest::foo */"}, {"sha": "b299fc558410de26a99969b83d90e9f82f0aeac4", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1 +1 @@\n-{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"attrs\":[],\"id\":0,\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"span\":{\"lo\":0,\"hi\":0},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"module\":{\"inner\":{\"lo\":0,\"hi\":0},\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"node\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0}},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":{\"_field0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"extern\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"core\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Semi\",\"span\":{\"lo\":0,\"hi\":0}}]},\"NonJoint\"]]}}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":0,\"hi\":0}}"}, {"sha": "2d4175ea8eb7da4c4af5bbd19768664e08e89683", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -11,10 +11,10 @@ LL |     Y\n    |     ^\n \n error[E0013]: constant functions cannot refer to statics, use a constant instead\n-  --> $DIR/const-fn-not-safe-for-const.rs:25:5\n+  --> $DIR/const-fn-not-safe-for-const.rs:25:6\n    |\n LL |     &Y\n-   |     ^^\n+   |      ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cb1663ed22f9593fca18305b0100b9d0308e8f96", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -116,10 +116,10 @@ LL | const fn foo25() -> u32 { BAR }\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: cannot access `static` items in const fn\n-  --> $DIR/min_const_fn.rs:91:36\n+  --> $DIR/min_const_fn.rs:91:37\n    |\n LL | const fn foo26() -> &'static u32 { &BAR }\n-   |                                    ^^^^\n+   |                                     ^^^\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable"}, {"sha": "0efb6bfd10a1707034db4289b0e41bef5e1eeef8", "filename": "src/test/ui/consts/projection_qualif.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -4,20 +4,20 @@ error[E0017]: references in constants may only refer to immutable values\n LL |         let b: *mut u32 = &mut a;\n    |                           ^^^^^^ constants require immutable values\n \n-error[E0019]: constant contains unimplemented expression type\n+error[E0658]: dereferencing raw pointers in constants is unstable\n   --> $DIR/projection_qualif.rs:7:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/51911\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n-error[E0658]: dereferencing raw pointers in constants is unstable\n+error[E0019]: constant contains unimplemented expression type\n   --> $DIR/projection_qualif.rs:7:18\n    |\n LL |         unsafe { *b = 5; }\n    |                  ^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/51911\n-   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "8d875d37d85f9ceeb143ba1fe1c7a8620372c9ec", "filename": "src/test/ui/issues/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-bad-values.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -4,17 +4,17 @@ error[E0017]: references in constants may only refer to immutable values\n LL | const C1: &'static mut [usize] = &mut [];\n    |                                  ^^^^^^^ constants require immutable values\n \n-error[E0017]: references in constants may only refer to immutable values\n-  --> $DIR/issue-17718-const-bad-values.rs:5:41\n+error[E0013]: constants cannot refer to statics, use a constant instead\n+  --> $DIR/issue-17718-const-bad-values.rs:5:46\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^ constants require immutable values\n+   |                                              ^\n \n-error[E0013]: constants cannot refer to statics, use a constant instead\n+error[E0017]: references in constants may only refer to immutable values\n   --> $DIR/issue-17718-const-bad-values.rs:5:41\n    |\n LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^\n+   |                                         ^^^^^^ constants require immutable values\n \n error: aborting due to 3 previous errors\n "}, {"sha": "27aad9c03cebea8c02834171349fbe9fb42d2e4b", "filename": "src/test/ui/issues/issue-17718-references.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-references.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,8 @@\n error[E0013]: constants cannot refer to statics, use a constant instead\n-  --> $DIR/issue-17718-references.rs:9:28\n+  --> $DIR/issue-17718-references.rs:9:29\n    |\n LL | const T2: &'static usize = &S;\n-   |                            ^^\n+   |                             ^\n \n error[E0013]: constants cannot refer to statics, use a constant instead\n   --> $DIR/issue-17718-references.rs:14:19"}, {"sha": "d58822f16eb35b419d092ea65b9c0cc37d6041cd", "filename": "src/test/ui/issues/issue-18118-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18118-2.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,8 @@\n error[E0013]: constants cannot refer to statics, use a constant instead\n-  --> $DIR/issue-18118-2.rs:4:9\n+  --> $DIR/issue-18118-2.rs:4:10\n    |\n LL |         &p\n-   |         ^^\n+   |          ^\n \n error: aborting due to previous error\n "}, {"sha": "9f5f6333602f5889f6a3765edd10cb1a8914f0ed", "filename": "src/test/ui/issues/issue-28433.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-28433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-28433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28433.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,14 +1,15 @@\n-error: unnecessary visibility qualifier\n+error[E0449]: unnecessary visibility qualifier\n   --> $DIR/issue-28433.rs:2:5\n    |\n LL |     pub Duck,\n-   |     ^^^ `pub` not permitted here\n+   |     ^^^ `pub` not permitted here because it's implied\n \n-error: unnecessary visibility qualifier\n+error[E0449]: unnecessary visibility qualifier\n   --> $DIR/issue-28433.rs:5:5\n    |\n LL |     pub(crate) Dove\n-   |     ^^^^^^^^^^ `pub` not permitted here\n+   |     ^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "7d3fc83786e9d40619f520459f4842f50917fddd", "filename": "src/test/ui/issues/issue-60075.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -4,7 +4,7 @@ trait T {\n     fn qux() -> Option<usize> {\n         let _ = if true {\n         });\n-//~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n+//~^ ERROR expected one of `async`\n //~| ERROR expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n //~| ERROR expected identifier, found `;`\n         Some(4)"}, {"sha": "e0b15130c337d5401a23fcc95847b2b0207d3472", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `;`\n+error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "70256a59231fb799b0fa6bd87146a9029875caad", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found `...`\n+error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 7 possible tokens\n+   |           ^^^ expected one of 9 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "ef89e31d8429da4d0ac2cdcf5f6f24507be47f16", "filename": "src/test/ui/parser/issue-65041-empty-vis-matcher-in-enum.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-enum.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+// Here we check that a `:vis` macro matcher subsititued for the empty visibility\n+// (`VisibilityKind::Inherited`) is accepted when used before an enum variant.\n+\n+fn main() {}\n+\n+macro_rules! mac_variant {\n+    ($vis:vis MARKER) => {\n+        enum Enum {\n+            $vis Unit,\n+\n+            $vis Tuple(u8, u16),\n+\n+            $vis Struct { f: u8 },\n+        }\n+    }\n+}\n+\n+mac_variant!(MARKER);\n+\n+// We also accept visibilities on variants syntactically but not semantically.\n+#[cfg(FALSE)]\n+enum E {\n+    pub U,\n+    pub(crate) T(u8),\n+    pub(super) T { f: String }\n+}"}, {"sha": "b08767b210b0609c981dfbc8dffb0aaadad99c26", "filename": "src/test/ui/parser/issue-65041-empty-vis-matcher-in-trait.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-65041-empty-vis-matcher-in-trait.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+// Here we check that a `:vis` macro matcher subsititued for the empty visibility\n+// (`VisibilityKind::Inherited`) is accepted when used before an item in a trait.\n+\n+fn main() {}\n+\n+macro_rules! mac_in_trait {\n+    ($vis:vis MARKER) => {\n+        $vis fn beta() {}\n+\n+        $vis const GAMMA: u8;\n+\n+        $vis type Delta;\n+    }\n+}\n+\n+trait Alpha {\n+    mac_in_trait!(MARKER);\n+}\n+\n+// We also accept visibilities on items in traits syntactically but not semantically.\n+#[cfg(FALSE)]\n+trait Foo {\n+    pub fn bar();\n+    pub(crate) type baz;\n+    pub(super) const QUUX: u8;\n+}"}, {"sha": "5021886bf9881bef35bac787c2d09bc3e491cd0a", "filename": "src/test/ui/parser/macro/trait-non-item-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,6 +1,6 @@\n macro_rules! bah {\n     ($a:expr) => ($a)\n-    //~^ ERROR expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n+    //~^ ERROR expected one of `async`\n }\n \n trait bar {"}, {"sha": "0a433ab278e43b327de3daff1732efdabc31a856", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found `2`\n+error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`\n+   |                   ^^ expected one of 8 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "9f3d78d584d44d535216247499299fe5db934901", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,7 +1,9 @@\n trait T {\n+//~^ ERROR `main` function not found in crate `missing_close_brace_in_trait`\n     fn foo(&self);\n \n-pub(crate) struct Bar<T>(); //~ ERROR expected one of\n+pub(crate) struct Bar<T>();\n+//~^ ERROR expected one of\n \n impl T for Bar<usize> {\n fn foo(&self) {}"}, {"sha": "cbaf9315e8540847a06d98b33fe2a4384938314e", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,25 +1,30 @@\n error: this file contains an un-closed delimiter\n-  --> $DIR/missing-close-brace-in-trait.rs:10:66\n+  --> $DIR/missing-close-brace-in-trait.rs:12:66\n    |\n LL | trait T {\n    |         - un-closed delimiter\n ...\n LL | fn main() {}\n    |                                                                  ^\n \n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, `unsafe`, or `}`, found keyword `pub`\n-  --> $DIR/missing-close-brace-in-trait.rs:4:1\n+error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found keyword `struct`\n+  --> $DIR/missing-close-brace-in-trait.rs:5:12\n    |\n-LL | trait T {\n-   |         - unclosed delimiter\n-LL |     fn foo(&self);\n-   |                   -\n-   |                   |\n-   |                   expected one of 7 possible tokens\n-   |                   help: `}` may belong here\n-LL | \n LL | pub(crate) struct Bar<T>();\n-   | ^^^ unexpected token\n+   |            ^^^^^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`\n+\n+error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n+  --> $DIR/missing-close-brace-in-trait.rs:1:1\n+   |\n+LL | / trait T {\n+LL | |\n+LL | |     fn foo(&self);\n+LL | |\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |_________________________________________________________________^ consider adding a `main` function to `$DIR/missing-close-brace-in-trait.rs`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0601`."}, {"sha": "efd09a0364ee025c2c391d49371cbbfd633453dd", "filename": "src/test/ui/parser/trait-pub-assoc-const.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-const.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,9 @@\n-error: unnecessary visibility qualifier\n+error[E0449]: unnecessary visibility qualifier\n   --> $DIR/trait-pub-assoc-const.rs:2:5\n    |\n LL |     pub const Foo: u32;\n-   |     ^^^ `pub` not permitted here\n+   |     ^^^ `pub` not permitted here because it's implied\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "e76373f5c5f8f78b7f3094a2acac841c651a2a5e", "filename": "src/test/ui/parser/trait-pub-assoc-ty.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-assoc-ty.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,9 @@\n-error: unnecessary visibility qualifier\n+error[E0449]: unnecessary visibility qualifier\n   --> $DIR/trait-pub-assoc-ty.rs:2:5\n    |\n LL |     pub type Foo;\n-   |     ^^^ `pub` not permitted here\n+   |     ^^^ `pub` not permitted here because it's implied\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "0e3fe027cb5f822745605b5d01a804391edf040b", "filename": "src/test/ui/parser/trait-pub-method.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-pub-method.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -1,8 +1,9 @@\n-error: unnecessary visibility qualifier\n+error[E0449]: unnecessary visibility qualifier\n   --> $DIR/trait-pub-method.rs:2:5\n    |\n LL |     pub fn foo();\n-   |     ^^^ `pub` not permitted here\n+   |     ^^^ `pub` not permitted here because it's implied\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0449`."}, {"sha": "313d39de36b6a98d6f156642c9049a109c4f1d0d", "filename": "src/test/ui/thread-local-in-ctfe.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local-in-ctfe.rs?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -8,14 +8,12 @@ static B: u32 = A;\n \n static C: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR thread-local variable borrowed past end of function\n \n const D: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const E: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR thread-local variable borrowed past end of function\n \n const fn f() -> u32 {\n     A"}, {"sha": "9890597b7bd5bc23e95ab4908324c337f243f3f4", "filename": "src/test/ui/thread-local-in-ctfe.stderr", "status": "modified", "additions": 7, "deletions": 24, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a449535bbc7912c4adc1bbf2ab2738d0442f212c/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fthread-local-in-ctfe.stderr?ref=a449535bbc7912c4adc1bbf2ab2738d0442f212c", "patch": "@@ -5,45 +5,28 @@ LL | static B: u32 = A;\n    |                 ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:9:18\n+  --> $DIR/thread-local-in-ctfe.rs:9:19\n    |\n LL | static C: &u32 = &A;\n-   |                  ^^\n-\n-error[E0712]: thread-local variable borrowed past end of function\n-  --> $DIR/thread-local-in-ctfe.rs:9:18\n-   |\n-LL | static C: &u32 = &A;\n-   |                  ^^- end of enclosing function is here\n-   |                  |\n-   |                  thread-local variables cannot be borrowed beyond the end of the function\n+   |                   ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:13:16\n+  --> $DIR/thread-local-in-ctfe.rs:12:16\n    |\n LL | const D: u32 = A;\n    |                ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:16:17\n-   |\n-LL | const E: &u32 = &A;\n-   |                 ^^\n-\n-error[E0712]: thread-local variable borrowed past end of function\n-  --> $DIR/thread-local-in-ctfe.rs:16:17\n+  --> $DIR/thread-local-in-ctfe.rs:15:18\n    |\n LL | const E: &u32 = &A;\n-   |                 ^^- end of enclosing function is here\n-   |                 |\n-   |                 thread-local variables cannot be borrowed beyond the end of the function\n+   |                  ^\n \n error[E0625]: thread-local statics cannot be accessed at compile-time\n-  --> $DIR/thread-local-in-ctfe.rs:21:5\n+  --> $DIR/thread-local-in-ctfe.rs:19:5\n    |\n LL |     A\n    |     ^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0712`."}]}