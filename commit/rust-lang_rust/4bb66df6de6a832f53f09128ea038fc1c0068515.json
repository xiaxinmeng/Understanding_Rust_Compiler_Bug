{"sha": "4bb66df6de6a832f53f09128ea038fc1c0068515", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYjY2ZGY2ZGU2YTgzMmY1M2YwOTEyOGVhMDM4ZmMxYzAwNjg1MTU=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-12T18:59:21Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-25T22:04:39Z"}, "message": "Support basic implicit type coerce", "tree": {"sha": "dc0509537b1f1cb0c61e0719d4d6f3317e09cc9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc0509537b1f1cb0c61e0719d4d6f3317e09cc9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb66df6de6a832f53f09128ea038fc1c0068515", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2L5HsACgkQztOS3gxI\nPQAyGA//Z5uuHm43Xip956637bIhWOydZ30ANZztkK+d3DQiYKKmZIfIYJNibfoY\n3NYniEZIR+IXLmsUp25RCl2lbfig39HlXmgNBuJTdumM11nqIs/hvwITw1f3Zl6k\nqCYAKqAb+jAreO/2+vbLaugkcrsx+IvFn3oYvDOZ+3kYVEpzSjb7wyVDXEbfRvVG\n+V2mW7J6NC2YKsOdywK6wI8OegzC+q98m6IGaCuiSZCxmAF+pP0hcOFk/Xoxji3E\n29vomDZbt2YllBgLYZJM323zxxAuRi/m+0LUxYuycVX52g3HAWsUP0ROL2hRVn/i\nEX8eITG9nQlHmddEV45KxtGtgoOp1mKeZypkz3JcS5DkL7EfueZGplsGAvfnSnC2\nvNpwmoQY/bQHxMpzm12CX1NIE88lZFiNxHvp+DDSTLemswfnlbtIk5RMROfeMXji\n3SUYajB0SZvrxKtXELSW309sKdRF+9GBxetTWiKCIr0vM24lSfzXsysK5uLXPedd\n6MA7lx7E5rPFBxJnhknUMIR4UuXJmBC8rmAhDIASPo+18/objHUmYFKbIEKIHUyR\nxnn8Q1qWVXjE5WaistWDyao/U0n26tps00/d99PLmfK7xwFe1bmZKYPSeVxaecDT\nk25kXXER/zhSQcBRGPAbzKc8IJbUb5HuU/wjhXWc5foJca0bU5k=\n=XA6m\n-----END PGP SIGNATURE-----", "payload": "tree dc0509537b1f1cb0c61e0719d4d6f3317e09cc9f\nparent 5205c84ec7d6284b258e66a06c3e330c3f9fdd88\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1568314761 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569449079 +0800\n\nSupport basic implicit type coerce\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb66df6de6a832f53f09128ea038fc1c0068515", "html_url": "https://github.com/rust-lang/rust/commit/4bb66df6de6a832f53f09128ea038fc1c0068515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb66df6de6a832f53f09128ea038fc1c0068515/comments", "author": null, "committer": null, "parents": [{"sha": "5205c84ec7d6284b258e66a06c3e330c3f9fdd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/5205c84ec7d6284b258e66a06c3e330c3f9fdd88", "html_url": "https://github.com/rust-lang/rust/commit/5205c84ec7d6284b258e66a06c3e330c3f9fdd88"}], "stats": {"total": 525, "additions": 383, "deletions": 142}, "files": [{"sha": "def787fb1e6a2491058b803acb24b81032f11faf", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 168, "deletions": 86, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/4bb66df6de6a832f53f09128ea038fc1c0068515/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb66df6de6a832f53f09128ea038fc1c0068515/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=4bb66df6de6a832f53f09128ea038fc1c0068515", "patch": "@@ -190,6 +190,15 @@ struct InferenceContext<'a, D: HirDatabase> {\n     return_ty: Ty,\n }\n \n+macro_rules! ty_app {\n+    ($ctor:pat, $param:pat) => {\n+        Ty::Apply(ApplicationTy { ctor: $ctor, parameters: $param })\n+    };\n+    ($ctor:pat) => {\n+        ty_app!($ctor, _)\n+    };\n+}\n+\n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n         InferenceContext {\n@@ -278,10 +287,16 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         match (&*ty1, &*ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n             (Ty::Apply(a_ty1), Ty::Apply(a_ty2)) if a_ty1.ctor == a_ty2.ctor => {\n                 self.unify_substs(&a_ty1.parameters, &a_ty2.parameters, depth + 1)\n             }\n+            _ => self.unify_inner_trivial(&ty1, &ty2),\n+        }\n+    }\n+\n+    fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        match (ty1, ty2) {\n+            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n             (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n             | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n             | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n@@ -795,50 +810,146 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ret_ty\n     }\n \n-    /// This is similar to unify, but it makes the first type coerce to the\n-    /// second one.\n+    /// Infer type of expression with possibly implicit coerce to the expected type.\n+    fn infer_expr_coerce(&mut self, expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(expr, &expected);\n+        self.coerce(&ty, &expected.ty);\n+        ty\n+    }\n+\n+    /// Unify two types, but may coerce the first one to the second one\n+    /// using \"implicit coercion rules\" if needed.\n+    ///\n+    /// See: https://doc.rust-lang.org/nomicon/coercions.html\n     fn coerce(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        if is_never(from_ty) {\n-            // ! coerces to any type\n-            true\n-        } else {\n-            self.unify(from_ty, to_ty)\n+        let from_ty = self.resolve_ty_shallow(from_ty).into_owned();\n+        let to_ty = self.resolve_ty_shallow(to_ty);\n+        self.coerce_inner(from_ty, &to_ty)\n+    }\n+\n+    fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n+        match (&mut from_ty, &*to_ty) {\n+            // Top and bottom type\n+            (ty_app!(TypeCtor::Never), _) => return true,\n+\n+            // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n+\n+            // `*mut T`, `&mut T, `&T`` -> `*const T`\n+            // `&mut T` -> `&T`\n+            // `&mut T` -> `*mut T`\n+            (ty_app!(c1@TypeCtor::RawPtr(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::RawPtr(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(_)), ty_app!(c2@TypeCtor::Ref(Mutability::Shared)))\n+            | (ty_app!(c1@TypeCtor::Ref(Mutability::Mut)), ty_app!(c2@TypeCtor::RawPtr(_))) => {\n+                *c1 = *c2;\n+            }\n+\n+            // Illegal mutablity conversion\n+            (\n+                ty_app!(TypeCtor::RawPtr(Mutability::Shared)),\n+                ty_app!(TypeCtor::RawPtr(Mutability::Mut)),\n+            )\n+            | (\n+                ty_app!(TypeCtor::Ref(Mutability::Shared)),\n+                ty_app!(TypeCtor::Ref(Mutability::Mut)),\n+            ) => return false,\n+\n+            // `{function_type}` -> `fn()`\n+            (ty_app!(TypeCtor::FnDef(_)), ty_app!(TypeCtor::FnPtr { .. })) => {\n+                match from_ty.callable_sig(self.db) {\n+                    None => return false,\n+                    Some(sig) => {\n+                        let num_args = sig.params_and_return.len() as u16 - 1;\n+                        from_ty =\n+                            Ty::apply(TypeCtor::FnPtr { num_args }, Substs(sig.params_and_return));\n+                    }\n+                }\n+            }\n+\n+            // Trivial cases, this should go after `never` check to\n+            // avoid infer result type to be never\n+            _ => {\n+                if self.unify_inner_trivial(&from_ty, &to_ty) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        // Try coerce or unify\n+        match (&from_ty, &to_ty) {\n+            // FIXME: Solve `FromTy: CoerceUnsized<ToTy>` instead of listing common impls here.\n+            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2))\n+            | (ty_app!(TypeCtor::RawPtr(_), st1), ty_app!(TypeCtor::RawPtr(_), st2)) => {\n+                match self.try_coerce_unsized(&st1[0], &st2[0], 0) {\n+                    Some(ret) => return ret,\n+                    None => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        // Auto Deref if cannot coerce\n+        match (&from_ty, &to_ty) {\n+            (ty_app!(TypeCtor::Ref(_), st1), ty_app!(TypeCtor::Ref(_), st2)) => {\n+                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n+            }\n+\n+            // Normal unify\n+            _ => self.unify(&from_ty, &to_ty),\n         }\n     }\n \n-    fn unify_with_autoderef(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n-        macro_rules! ty_app {\n-            ($ctor:pat, $param:pat) => {\n-                Ty::Apply(ApplicationTy { ctor: $ctor, parameters: $param })\n-            };\n+    /// Coerce a type to a DST if `FromTy: Unsize<ToTy>`\n+    ///\n+    /// See: `https://doc.rust-lang.org/nightly/std/marker/trait.Unsize.html`\n+    fn try_coerce_unsized(&mut self, from_ty: &Ty, to_ty: &Ty, depth: usize) -> Option<bool> {\n+        if depth > 1000 {\n+            panic!(\"Infinite recursion in coercion\");\n         }\n \n-        // If given type and expected type are compatible reference,\n-        // trigger auto-deref.\n-        let (_to_mut, from_ty, to_ty) =\n-            match (&*self.resolve_ty_shallow(&from_ty), &*self.resolve_ty_shallow(&to_ty)) {\n-                (\n-                    ty_app!(TypeCtor::Ref(from_mut), from_param),\n-                    ty_app!(TypeCtor::Ref(to_mut), to_param),\n-                ) if *from_mut == Mutability::Mut || from_mut == to_mut => {\n-                    (to_mut, from_param[0].clone(), to_param[0].clone())\n-                }\n-                _ => {\n-                    // Otherwise, just unify\n-                    return self.unify(&from_ty, &to_ty);\n+        // FIXME: Correctly handle\n+        match (&from_ty, &to_ty) {\n+            // `[T; N]` -> `[T]`\n+            (ty_app!(TypeCtor::Array, st1), ty_app!(TypeCtor::Slice, st2)) => {\n+                Some(self.unify(&st1[0], &st2[0]))\n+            }\n+\n+            // `T` -> `dyn Trait` when `T: Trait`\n+            (_, Ty::Dyn(_)) => {\n+                // FIXME: Check predicates\n+                Some(true)\n+            }\n+\n+            (ty_app!(ctor1, st1), ty_app!(ctor2, st2)) if ctor1 == ctor2 => {\n+                for (ty1, ty2) in st1.iter().zip(st2.iter()) {\n+                    match self.try_coerce_unsized(ty1, ty2, depth + 1) {\n+                        Some(true) => {}\n+                        ret => return ret,\n+                    }\n                 }\n-            };\n+                Some(true)\n+            }\n+\n+            _ => None,\n+        }\n+    }\n \n-        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty);\n+    /// Unify `from_ty` to `to_ty` with optional auto Deref\n+    ///\n+    /// Note that the parameters are already stripped the outer reference.\n+    fn unify_autoderef_behind_ref(&mut self, from_ty: &Ty, to_ty: &Ty) -> bool {\n+        let canonicalized = self.canonicalizer().canonicalize_ty(from_ty.clone());\n+        let to_ty = self.resolve_ty_shallow(&to_ty);\n         // FIXME: Auto DerefMut\n         for derefed_ty in\n             autoderef::autoderef(self.db, &self.resolver.clone(), canonicalized.value.clone())\n         {\n             let derefed_ty = canonicalized.decanonicalize_ty(derefed_ty.value);\n-            match (&*self.resolve_ty_shallow(&derefed_ty), &*self.resolve_ty_shallow(&to_ty)) {\n-                // Unify when constructor matches.\n-                (ty_app!(from_ctor, _), ty_app!(to_ctor, _)) if from_ctor == to_ctor => {\n-                    return self.unify(&derefed_ty, &to_ty);\n+            match (&*self.resolve_ty_shallow(&derefed_ty), &*to_ty) {\n+                // Stop when constructor matches.\n+                (ty_app!(from_ctor, st1), ty_app!(to_ctor, st2)) if from_ctor == to_ctor => {\n+                    // It will not recurse to `coerce`.\n+                    return self.unify_substs(st1, st2, 0);\n                 }\n                 _ => {}\n             }\n@@ -875,9 +986,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     Some(else_branch) => self.infer_expr_inner(*else_branch, &expected),\n                     None => Ty::unit(),\n                 };\n-                self.coerce(&else_ty, &expected.ty);\n-\n-                expected.ty.clone()\n+                if !self.coerce(&else_ty, &expected.ty) {\n+                    self.coerce(&expected.ty, &else_ty);\n+                    else_ty.clone()\n+                } else {\n+                    expected.ty.clone()\n+                }\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -973,13 +1087,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .infer_method_call(tgt_expr, *receiver, &args, &method_name, generic_args.as_ref()),\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n-                let expected = if expected.ty == Ty::Unknown {\n-                    Expectation::has_type(self.new_type_var())\n-                } else {\n-                    expected.clone()\n+                let mut expected = match expected.ty {\n+                    Ty::Unknown => Expectation::has_type(Ty::simple(TypeCtor::Never)),\n+                    _ => expected.clone(),\n                 };\n-\n-                let mut arm_tys = Vec::with_capacity(arms.len());\n+                let mut all_never = true;\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n@@ -991,16 +1103,22 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    arm_tys.push(self.infer_expr_inner(arm.expr, &expected));\n+                    let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    match &arm_ty {\n+                        ty_app!(TypeCtor::Never) => (),\n+                        _ => all_never = false,\n+                    }\n+                    if !self.coerce(&arm_ty, &expected.ty) {\n+                        self.coerce(&expected.ty, &arm_ty);\n+                        expected = Expectation::has_type(arm_ty);\n+                    }\n                 }\n \n-                let lub_ty = calculate_least_upper_bound(expected.ty, &arm_tys);\n-\n-                for arm_ty in &arm_tys {\n-                    self.coerce(arm_ty, &lub_ty);\n+                if all_never {\n+                    Ty::simple(TypeCtor::Never)\n+                } else {\n+                    expected.ty\n                 }\n-\n-                lub_ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1289,8 +1407,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n                     let decl_ty = self.insert_type_vars(decl_ty);\n                     let ty = if let Some(expr) = initializer {\n-                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n-                        expr_ty\n+                        self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty))\n                     } else {\n                         decl_ty\n                     };\n@@ -1326,8 +1443,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n \n                 let param_ty = self.normalize_associated_types_in(param_ty);\n-                let arg_ty = self.infer_expr_inner(arg, &Expectation::has_type(param_ty.clone()));\n-                self.unify_with_autoderef(&arg_ty, &param_ty);\n+                self.infer_expr_coerce(arg, &Expectation::has_type(param_ty.clone()));\n             }\n         }\n     }\n@@ -1517,37 +1633,3 @@ mod diagnostics {\n         }\n     }\n }\n-\n-fn is_never(ty: &Ty) -> bool {\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Never, .. }) = ty {\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: &[Ty]) -> Ty {\n-    let mut all_never = true;\n-    let mut last_never_ty = None;\n-    let mut least_upper_bound = expected_ty;\n-\n-    for actual_ty in actual_tys {\n-        if is_never(actual_ty) {\n-            last_never_ty = Some(actual_ty.clone());\n-        } else {\n-            all_never = false;\n-            least_upper_bound = match (actual_ty, &least_upper_bound) {\n-                (_, Ty::Unknown)\n-                | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n-                | (Ty::Apply(_), _) => actual_ty.clone(),\n-                _ => least_upper_bound,\n-            }\n-        }\n-    }\n-\n-    if all_never && last_never_ty.is_some() {\n-        last_never_ty.unwrap()\n-    } else {\n-        least_upper_bound\n-    }\n-}"}, {"sha": "2ce0039b10567368f35c077afcee9d4be0ededa4", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 215, "deletions": 56, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/4bb66df6de6a832f53f09128ea038fc1c0068515/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb66df6de6a832f53f09128ea038fc1c0068515/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=4bb66df6de6a832f53f09128ea038fc1c0068515", "patch": "@@ -806,14 +806,14 @@ fn infer_argument_autoderef() {\n         infer(r#\"\n #[lang = \"deref\"]\n pub trait Deref {\n-    type Target: ?Sized;\n+    type Target;\n     fn deref(&self) -> &Self::Target;\n }\n \n struct A<T>(T);\n \n-impl<T: Copy> A<T> {\n-    fn foo(&self) -> T {\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n         self.0\n     }\n }\n@@ -828,32 +828,33 @@ impl<T> Deref for B<T> {\n }\n \n fn test() {\n-    A::foo(&&B(B(A(42))));\n+    let t = A::foo(&&B(B(A(42))));\n }\n \"#),\n         @r###\"\n-    [76; 80) 'self': &Self\n-    [153; 157) 'self': &A<T>\n-    [164; 186) '{     ...     }': T\n-    [174; 178) 'self': &A<T>\n-    [174; 180) 'self.0': T\n-    [267; 271) 'self': &B<T>\n-    [290; 313) '{     ...     }': &T\n-    [300; 307) '&self.0': &T\n-    [301; 305) 'self': &B<T>\n-    [301; 307) 'self.0': T\n-    [327; 357) '{     ...))); }': ()\n-    [333; 339) 'A::foo': fn foo<i32>(&A<T>) -> T\n-    [333; 354) 'A::foo...42))))': i32\n-    [340; 353) '&&B(B(A(42)))': &&B<B<A<i32>>>\n-    [341; 353) '&B(B(A(42)))': &B<B<A<i32>>>\n-    [342; 343) 'B': B<B<A<i32>>>(T) -> B<T>\n-    [342; 353) 'B(B(A(42)))': B<B<A<i32>>>\n-    [344; 345) 'B': B<A<i32>>(T) -> B<T>\n-    [344; 352) 'B(A(42))': B<A<i32>>\n-    [346; 347) 'A': A<i32>(T) -> A<T>\n-    [346; 351) 'A(42)': A<i32>\n-    [348; 350) '42': i32\n+    [68; 72) 'self': &Self\n+    [139; 143) 'self': &A<T>\n+    [151; 173) '{     ...     }': T\n+    [161; 165) 'self': &A<T>\n+    [161; 167) 'self.0': T\n+    [254; 258) 'self': &B<T>\n+    [277; 300) '{     ...     }': &T\n+    [287; 294) '&self.0': &T\n+    [288; 292) 'self': &B<T>\n+    [288; 294) 'self.0': T\n+    [314; 352) '{     ...))); }': ()\n+    [324; 325) 't': &i32\n+    [328; 334) 'A::foo': fn foo<i32>(&A<T>) -> &T\n+    [328; 349) 'A::foo...42))))': &i32\n+    [335; 348) '&&B(B(A(42)))': &&B<B<A<i32>>>\n+    [336; 348) '&B(B(A(42)))': &B<B<A<i32>>>\n+    [337; 338) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [337; 348) 'B(B(A(42)))': B<B<A<i32>>>\n+    [339; 340) 'B': B<A<i32>>(T) -> B<T>\n+    [339; 347) 'B(A(42))': B<A<i32>>\n+    [341; 342) 'A': A<i32>(T) -> A<T>\n+    [341; 346) 'A(42)': A<i32>\n+    [343; 345) '42': i32\n \"###\n     );\n }\n@@ -864,15 +865,15 @@ fn infer_method_argument_autoderef() {\n         infer(r#\"\n #[lang = \"deref\"]\n pub trait Deref {\n-    type Target: ?Sized;\n+    type Target;\n     fn deref(&self) -> &Self::Target;\n }\n \n struct A<T>(*mut T);\n \n-impl<T: Copy> A<T> {\n-    fn foo(&self, x: &A<T>) -> T {\n-        x\n+impl<T> A<T> {\n+    fn foo(&self, x: &A<T>) -> &T {\n+        &*x.0\n     }\n }\n \n@@ -886,38 +887,196 @@ impl<T> Deref for B<T> {\n }\n \n fn test(a: A<i32>) {\n-    A(0 as *mut _).foo(&&B(B(a)));\n+    let t = A(0 as *mut _).foo(&&B(B(a)));\n+}\n+\"#),\n+        @r###\"\n+    [68; 72) 'self': &Self\n+    [144; 148) 'self': &A<T>\n+    [150; 151) 'x': &A<T>\n+    [166; 187) '{     ...     }': &T\n+    [176; 181) '&*x.0': &T\n+    [177; 181) '*x.0': T\n+    [178; 179) 'x': &A<T>\n+    [178; 181) 'x.0': *mut T\n+    [268; 272) 'self': &B<T>\n+    [291; 314) '{     ...     }': &T\n+    [301; 308) '&self.0': &T\n+    [302; 306) 'self': &B<T>\n+    [302; 308) 'self.0': T\n+    [326; 327) 'a': A<i32>\n+    [337; 383) '{     ...))); }': ()\n+    [347; 348) 't': &i32\n+    [351; 352) 'A': A<i32>(*mut T) -> A<T>\n+    [351; 365) 'A(0 as *mut _)': A<i32>\n+    [351; 380) 'A(0 as...B(a)))': &i32\n+    [353; 354) '0': i32\n+    [353; 364) '0 as *mut _': *mut i32\n+    [370; 379) '&&B(B(a))': &&B<B<A<i32>>>\n+    [371; 379) '&B(B(a))': &B<B<A<i32>>>\n+    [372; 373) 'B': B<B<A<i32>>>(T) -> B<T>\n+    [372; 379) 'B(B(a))': B<B<A<i32>>>\n+    [374; 375) 'B': B<A<i32>>(T) -> B<T>\n+    [374; 378) 'B(a)': B<A<i32>>\n+    [376; 377) 'a': A<i32>\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_if_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        foo(&[1])\n+    } else {\n+        &[1]\n+    };\n }\n \"#),\n         @r###\"\n-    [76; 80) 'self': &Self\n-    [158; 162) 'self': &A<T>\n-    [164; 165) 'x': &A<T>\n-    [179; 196) '{     ...     }': &A<T>\n-    [189; 190) 'x': &A<T>\n-    [277; 281) 'self': &B<T>\n-    [300; 323) '{     ...     }': &T\n-    [310; 317) '&self.0': &T\n-    [311; 315) 'self': &B<T>\n-    [311; 317) 'self.0': T\n-    [335; 336) 'a': A<i32>\n-    [346; 384) '{     ...))); }': ()\n-    [352; 353) 'A': A<i32>(*mut T) -> A<T>\n-    [352; 366) 'A(0 as *mut _)': A<i32>\n-    [352; 381) 'A(0 as...B(a)))': i32\n-    [354; 355) '0': i32\n-    [354; 365) '0 as *mut _': *mut i32\n-    [371; 380) '&&B(B(a))': &&B<B<A<i32>>>\n-    [372; 380) '&B(B(a))': &B<B<A<i32>>>\n-    [373; 374) 'B': B<B<A<i32>>>(T) -> B<T>\n-    [373; 380) 'B(B(a))': B<B<A<i32>>>\n-    [375; 376) 'B': B<A<i32>>(T) -> B<T>\n-    [375; 379) 'B(a)': B<A<i32>>\n-    [377; 378) 'a': A<i32>\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 97) '{     ...     }': &[i32]\n+    [82; 85) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [82; 91) 'foo(&[1])': &[i32]\n+    [86; 90) '&[1]': &[i32;_]\n+    [87; 90) '[1]': [i32;_]\n+    [88; 89) '1': i32\n+    [103; 123) '{     ...     }': &[i32;_]\n+    [113; 117) '&[1]': &[i32;_]\n+    [114; 117) '[1]': [i32;_]\n+    [115; 116) '1': i32\n \"###\n     );\n }\n \n+#[test]\n+fn infer_if_else_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test() {\n+    let x = if true {\n+        &[1]\n+    } else {\n+        foo(&[1])\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [50; 126) '{     ...  }; }': ()\n+    [60; 61) 'x': &[i32]\n+    [64; 123) 'if tru...     }': &[i32]\n+    [67; 71) 'true': bool\n+    [72; 92) '{     ...     }': &[i32;_]\n+    [82; 86) '&[1]': &[i32;_]\n+    [83; 86) '[1]': [i32;_]\n+    [84; 85) '1': i32\n+    [98; 123) '{     ...     }': &[i32]\n+    [108; 111) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [108; 117) 'foo(&[1])': &[i32]\n+    [112; 116) '&[1]': &[i32;_]\n+    [113; 116) '[1]': [i32;_]\n+    [114; 115) '1': i32\n+\"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_first_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        2 => foo(&[2]),\n+        1 => &[1],\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '2': i32\n+    [93; 96) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [93; 102) 'foo(&[2])': &[i32]\n+    [97; 101) '&[2]': &[i32;_]\n+    [98; 101) '[2]': [i32;_]\n+    [99; 100) '2': i32\n+    [112; 113) '1': i32\n+    [117; 121) '&[1]': &[i32;_]\n+    [118; 121) '[1]': [i32;_]\n+    [119; 120) '1': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_match_second_coerce() {\n+    assert_snapshot!(\n+        infer(r#\"\n+fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn test(i: i32) {\n+    let x = match i {\n+        1 => &[1],\n+        2 => foo(&[2]),\n+        _ => &[3],\n+    };\n+}\n+\"#),\n+        @r###\"\n+    [11; 12) 'x': &[T]\n+    [28; 39) '{ loop {} }': !\n+    [30; 37) 'loop {}': !\n+    [35; 37) '{}': ()\n+    [48; 49) 'i': i32\n+    [56; 150) '{     ...  }; }': ()\n+    [66; 67) 'x': &[i32]\n+    [70; 147) 'match ...     }': &[i32]\n+    [76; 77) 'i': i32\n+    [88; 89) '1': i32\n+    [93; 97) '&[1]': &[i32;_]\n+    [94; 97) '[1]': [i32;_]\n+    [95; 96) '1': i32\n+    [107; 108) '2': i32\n+    [112; 115) 'foo': fn foo<i32>(&[T]) -> &[T]\n+    [112; 121) 'foo(&[2])': &[i32]\n+    [116; 120) '&[2]': &[i32;_]\n+    [117; 120) '[2]': [i32;_]\n+    [118; 119) '2': i32\n+    [131; 132) '_': i32\n+    [136; 140) '&[3]': &[i32;_]\n+    [137; 140) '[3]': [i32;_]\n+    [138; 139) '3': i32\n+    \"###\n+    );\n+}\n+\n #[test]\n fn bug_484() {\n     assert_snapshot!(\n@@ -3474,7 +3633,7 @@ trait Deref {\n }\n \n struct Arc<T>;\n-impl<T: ?Sized> Deref for Arc<T> {\n+impl<T> Deref for Arc<T> {\n     type Target = T;\n }\n "}]}