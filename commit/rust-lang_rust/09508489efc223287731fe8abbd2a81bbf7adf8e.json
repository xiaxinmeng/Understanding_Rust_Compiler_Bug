{"sha": "09508489efc223287731fe8abbd2a81bbf7adf8e", "node_id": "C_kwDOAAsO6NoAKDA5NTA4NDg5ZWZjMjIzMjg3NzMxZmU4YWJiZDJhODFiYmY3YWRmOGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T19:43:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-04T19:43:36Z"}, "message": "Auto merge of #103978 - matthiaskrgr:rollup-iym9kmg, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #103367 (Remove std's transitive dependency on cfg-if 0.1)\n - #103397 (Port `dead_code` lints to be translatable.)\n - #103681 (libtest: run all tests in their own thread, if supported by the host)\n - #103792 (Migrate `codegen_ssa` to diagnostics structs - [Part 2])\n - #103897 (asm: Work around LLVM bug on AArch64)\n - #103937 (minor changes to make method lookup diagnostic code easier to read)\n - #103958 (Test tidy should not count untracked paths towards entries limit)\n - #103964 (Give a specific lint for unsafety not being inherited)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6ab0b4cf00da631b7510ff05449647bf2b43a5fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ab0b4cf00da631b7510ff05449647bf2b43a5fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09508489efc223287731fe8abbd2a81bbf7adf8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09508489efc223287731fe8abbd2a81bbf7adf8e", "html_url": "https://github.com/rust-lang/rust/commit/09508489efc223287731fe8abbd2a81bbf7adf8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09508489efc223287731fe8abbd2a81bbf7adf8e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01", "html_url": "https://github.com/rust-lang/rust/commit/c2a5c3a50fc3fb6d16cd140f55f7db61cbf08a01"}, {"sha": "347c478d886acc7e1b94af83f7fa882f73e809b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/347c478d886acc7e1b94af83f7fa882f73e809b7", "html_url": "https://github.com/rust-lang/rust/commit/347c478d886acc7e1b94af83f7fa882f73e809b7"}], "stats": {"total": 1218, "additions": 811, "deletions": 407}, "files": [{"sha": "b73a4d6f2da50c81ba6d90cde0b596ce3c8ea3a6", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1526,11 +1526,11 @@ dependencies = [\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.14\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7abc8dd8451921606d809ba32e95b6111925cd2906060d2dcc29c070220503eb\"\n+checksum = \"8fc3cb4d91f53b50155bdcfd23f6a4c39ae1969c2ae85982b135750cccaf5fce\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"libc\",\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n@@ -2478,7 +2478,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2489,7 +2489,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -2817,7 +2817,7 @@ version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n  \"libc\",\n  \"rand_chacha 0.2.2\",\n  \"rand_core 0.5.1\",\n@@ -2861,7 +2861,7 @@ version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"90bde5296fc891b0cef12a6d03ddccc162ce7b2aff54160af9338f8d40df6d19\"\n dependencies = [\n- \"getrandom 0.1.14\",\n+ \"getrandom 0.1.16\",\n ]\n \n [[package]]\n@@ -4937,6 +4937,7 @@ name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n+ \"ignore\",\n  \"lazy_static\",\n  \"miropt-test-tools\",\n  \"regex\",\n@@ -5357,7 +5358,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "2ef6fd4942bdae9a73e11abc513ab11d425c5649", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -505,6 +505,44 @@ fn xmm_reg_index(reg: InlineAsmReg) -> Option<u32> {\n     }\n }\n \n+/// If the register is an AArch64 integer register then return its index.\n+fn a64_reg_index(reg: InlineAsmReg) -> Option<u32> {\n+    match reg {\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x0) => Some(0),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x1) => Some(1),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x2) => Some(2),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x3) => Some(3),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x4) => Some(4),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x5) => Some(5),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x6) => Some(6),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x7) => Some(7),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x8) => Some(8),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x9) => Some(9),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x10) => Some(10),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x11) => Some(11),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x12) => Some(12),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x13) => Some(13),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x14) => Some(14),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x15) => Some(15),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x16) => Some(16),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x17) => Some(17),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x18) => Some(18),\n+        // x19 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x20) => Some(20),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x21) => Some(21),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x22) => Some(22),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x23) => Some(23),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x24) => Some(24),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x25) => Some(25),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x26) => Some(26),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x27) => Some(27),\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x28) => Some(28),\n+        // x29 is reserved\n+        InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) => Some(30),\n+        _ => None,\n+    }\n+}\n+\n /// If the register is an AArch64 vector register then return its index.\n fn a64_vreg_index(reg: InlineAsmReg) -> Option<u32> {\n     match reg {\n@@ -535,6 +573,22 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'x'\n                 };\n                 format!(\"{{{}mm{}}}\", class, idx)\n+            } else if let Some(idx) = a64_reg_index(reg) {\n+                let class = if let Some(layout) = layout {\n+                    match layout.size.bytes() {\n+                        8 => 'x',\n+                        _ => 'w',\n+                    }\n+                } else {\n+                    // We use i32 as the type for discarded outputs\n+                    'w'\n+                };\n+                if class == 'x' && reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n+                    // LLVM doesn't recognize x30. use lr instead.\n+                    \"{lr}\".to_string()\n+                } else {\n+                    format!(\"{{{}{}}}\", class, idx)\n+                }\n             } else if let Some(idx) = a64_vreg_index(reg) {\n                 let class = if let Some(layout) = layout {\n                     match layout.size.bytes() {\n@@ -550,9 +604,6 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                     'q'\n                 };\n                 format!(\"{{{}{}}}\", class, idx)\n-            } else if reg == InlineAsmReg::AArch64(AArch64InlineAsmReg::x30) {\n-                // LLVM doesn't recognize x30\n-                \"{lr}\".to_string()\n             } else if reg == InlineAsmReg::Arm(ArmInlineAsmReg::r14) {\n                 // LLVM doesn't recognize r14\n                 \"{lr}\".to_string()"}, {"sha": "18789d00fd3a43592ead105593149437f5d204bc", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -6,11 +6,12 @@ use rustc_span::symbol::Symbol;\n \n use object::read::archive::ArchiveFile;\n \n-use std::fmt::Display;\n use std::fs::File;\n use std::io;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::ExtractBundledLibsError;\n+\n pub trait ArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a>;\n \n@@ -28,32 +29,35 @@ pub trait ArchiveBuilderBuilder {\n         is_direct_dependency: bool,\n     ) -> PathBuf;\n \n-    fn extract_bundled_libs(\n-        &self,\n-        rlib: &Path,\n+    fn extract_bundled_libs<'a>(\n+        &'a self,\n+        rlib: &'a Path,\n         outdir: &Path,\n         bundled_lib_file_names: &FxHashSet<Symbol>,\n-    ) -> Result<(), String> {\n-        let message = |msg: &str, e: &dyn Display| format!(\"{} '{}': {}\", msg, &rlib.display(), e);\n+    ) -> Result<(), ExtractBundledLibsError<'_>> {\n         let archive_map = unsafe {\n-            Mmap::map(File::open(rlib).map_err(|e| message(\"failed to open file\", &e))?)\n-                .map_err(|e| message(\"failed to mmap file\", &e))?\n+            Mmap::map(\n+                File::open(rlib)\n+                    .map_err(|e| ExtractBundledLibsError::OpenFile { rlib, error: Box::new(e) })?,\n+            )\n+            .map_err(|e| ExtractBundledLibsError::MmapFile { rlib, error: Box::new(e) })?\n         };\n         let archive = ArchiveFile::parse(&*archive_map)\n-            .map_err(|e| message(\"failed to parse archive\", &e))?;\n+            .map_err(|e| ExtractBundledLibsError::ParseArchive { rlib, error: Box::new(e) })?;\n \n         for entry in archive.members() {\n-            let entry = entry.map_err(|e| message(\"failed to read entry\", &e))?;\n+            let entry = entry\n+                .map_err(|e| ExtractBundledLibsError::ReadEntry { rlib, error: Box::new(e) })?;\n             let data = entry\n                 .data(&*archive_map)\n-                .map_err(|e| message(\"failed to get data from archive member\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ArchiveMember { rlib, error: Box::new(e) })?;\n             let name = std::str::from_utf8(entry.name())\n-                .map_err(|e| message(\"failed to convert name\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::ConvertName { rlib, error: Box::new(e) })?;\n             if !bundled_lib_file_names.contains(&Symbol::intern(name)) {\n                 continue; // We need to extract only native libraries.\n             }\n             std::fs::write(&outdir.join(&name), data)\n-                .map_err(|e| message(\"failed to write file\", &e))?;\n+                .map_err(|e| ExtractBundledLibsError::WriteFile { rlib, error: Box::new(e) })?;\n         }\n         Ok(())\n     }"}, {"sha": "6f0a8d0a54cbac03b5158e35a8647a819bdd0912", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 47, "deletions": 85, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -919,29 +919,17 @@ fn link_natively<'a>(\n                         )\n                         .is_some();\n \n-                        sess.note_without_error(\"`link.exe` returned an unexpected error\");\n+                        sess.emit_note(errors::LinkExeUnexpectedError);\n                         if is_vs_installed && has_linker {\n                             // the linker is broken\n-                            sess.note_without_error(\n-                                \"the Visual Studio build tools may need to be repaired \\\n-                                using the Visual Studio installer\",\n-                            );\n-                            sess.note_without_error(\n-                                \"or a necessary component may be missing from the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::RepairVSBuildTools);\n+                            sess.emit_note(errors::MissingCppBuildToolComponent);\n                         } else if is_vs_installed {\n                             // the linker is not installed\n-                            sess.note_without_error(\n-                                \"in the Visual Studio installer, ensure the \\\n-                                \\\"C++ build tools\\\" workload is selected\",\n-                            );\n+                            sess.emit_note(errors::SelectCppBuildToolWorkload);\n                         } else {\n                             // visual studio is not installed\n-                            sess.note_without_error(\n-                                \"you may need to install Visual Studio build tools with the \\\n-                                \\\"C++ build tools\\\" workload\",\n-                            );\n+                            sess.emit_note(errors::VisualStudioNotInstalled);\n                         }\n                     }\n                 }\n@@ -954,35 +942,20 @@ fn link_natively<'a>(\n         Err(e) => {\n             let linker_not_found = e.kind() == io::ErrorKind::NotFound;\n \n-            let mut linker_error = {\n-                if linker_not_found {\n-                    sess.struct_err(&format!(\"linker `{}` not found\", linker_path.display()))\n-                } else {\n-                    sess.struct_err(&format!(\n-                        \"could not exec the linker `{}`\",\n-                        linker_path.display()\n-                    ))\n-                }\n-            };\n-\n-            linker_error.note(&e.to_string());\n-\n-            if !linker_not_found {\n-                linker_error.note(&format!(\"{:?}\", &cmd));\n+            if linker_not_found {\n+                sess.emit_err(errors::LinkerNotFound { linker_path, error: e });\n+            } else {\n+                sess.emit_err(errors::UnableToExeLinker {\n+                    linker_path,\n+                    error: e,\n+                    command_formatted: format!(\"{:?}\", &cmd),\n+                });\n             }\n \n-            linker_error.emit();\n-\n             if sess.target.is_like_msvc && linker_not_found {\n-                sess.note_without_error(\n-                    \"the msvc targets depend on the msvc linker \\\n-                     but `link.exe` was not found\",\n-                );\n-                sess.note_without_error(\n-                    \"please ensure that Visual Studio 2017 or later, or Build Tools \\\n-                     for Visual Studio were installed with the Visual C++ option.\",\n-                );\n-                sess.note_without_error(\"VS Code is a different product, and is not sufficient.\");\n+                sess.emit_note(errors::MsvcMissingLinker);\n+                sess.emit_note(errors::CheckInstalledVisualStudio);\n+                sess.emit_note(errors::UnsufficientVSCodeProduct);\n             }\n             sess.abort_if_errors();\n         }\n@@ -1007,15 +980,13 @@ fn link_natively<'a>(\n                     if !prog.status.success() {\n                         let mut output = prog.stderr.clone();\n                         output.extend_from_slice(&prog.stdout);\n-                        sess.struct_warn(&format!(\n-                            \"processing debug info with `dsymutil` failed: {}\",\n-                            prog.status\n-                        ))\n-                        .note(&escape_string(&output))\n-                        .emit();\n+                        sess.emit_warning(errors::ProcessingDymutilFailed {\n+                            status: prog.status,\n+                            output: escape_string(&output),\n+                        });\n                     }\n                 }\n-                Err(e) => sess.fatal(&format!(\"unable to run `dsymutil`: {}\", e)),\n+                Err(error) => sess.emit_fatal(errors::UnableToRunDsymutil { error }),\n             }\n         }\n \n@@ -1092,15 +1063,14 @@ fn strip_symbols_with_external_utility<'a>(\n             if !prog.status.success() {\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n-                sess.struct_warn(&format!(\n-                    \"stripping debug info with `{}` failed: {}\",\n-                    util, prog.status\n-                ))\n-                .note(&escape_string(&output))\n-                .emit();\n+                sess.emit_warning(errors::StrippingDebugInfoFailed {\n+                    util,\n+                    status: prog.status,\n+                    output: escape_string(&output),\n+                });\n             }\n         }\n-        Err(e) => sess.fatal(&format!(\"unable to run `{}`: {}\", util, e)),\n+        Err(error) => sess.emit_fatal(errors::UnableToRun { util, error }),\n     }\n }\n \n@@ -1251,7 +1221,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n             )),\n             (Some(linker), None) => {\n                 let stem = linker.file_stem().and_then(|stem| stem.to_str()).unwrap_or_else(|| {\n-                    sess.fatal(\"couldn't extract file stem from specified linker\")\n+                    sess.emit_fatal(errors::LinkerFileStem);\n                 });\n \n                 let flavor = if stem == \"emcc\" {\n@@ -1378,13 +1348,9 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         })\n         .collect();\n     if !lib_args.is_empty() {\n-        sess.note_without_error(\n-            \"Link against the following native artifacts when linking \\\n-                                 against this static library. The order and any duplication \\\n-                                 can be significant on some platforms.\",\n-        );\n+        sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability\n-        sess.note_without_error(&format!(\"native-static-libs: {}\", &lib_args.join(\" \")));\n+        sess.emit_note(errors::NativeStaticLibs { arguments: lib_args.join(\" \") });\n     }\n }\n \n@@ -1688,14 +1654,14 @@ fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_ty\n     match (crate_type, &sess.target.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n             if !sess.target.linker_flavor.is_gnu() {\n-                sess.fatal(\"can only use link script when linking with GNU-like linker\");\n+                sess.emit_fatal(errors::LinkScriptUnavailable);\n             }\n \n             let file_name = [\"rustc\", &sess.target.llvm_target, \"linkfile.ld\"].join(\"-\");\n \n             let path = tmpdir.join(file_name);\n-            if let Err(e) = fs::write(&path, script.as_ref()) {\n-                sess.fatal(&format!(\"failed to write link script to {}: {}\", path.display(), e));\n+            if let Err(error) = fs::write(&path, script.as_ref()) {\n+                sess.emit_fatal(errors::LinkScriptWriteFailure { path, error });\n             }\n \n             cmd.arg(\"--script\");\n@@ -1841,8 +1807,8 @@ fn add_linked_symbol_object(\n \n     let path = tmpdir.join(\"symbols.o\");\n     let result = std::fs::write(&path, file.write().unwrap());\n-    if let Err(e) = result {\n-        sess.fatal(&format!(\"failed to write {}: {}\", path.display(), e));\n+    if let Err(error) = result {\n+        sess.emit_fatal(errors::FailedToWrite { path, error });\n     }\n     cmd.add_object(&path);\n }\n@@ -2299,14 +2265,10 @@ fn collect_natvis_visualizers(\n                 visualizer_paths.push(visualizer_out_file);\n             }\n             Err(error) => {\n-                sess.warn(\n-                    format!(\n-                        \"Unable to write debugger visualizer file `{}`: {} \",\n-                        visualizer_out_file.display(),\n-                        error\n-                    )\n-                    .as_str(),\n-                );\n+                sess.emit_warning(errors::UnableToWriteDebuggerVisualizer {\n+                    path: visualizer_out_file,\n+                    error,\n+                });\n             }\n         };\n     }\n@@ -2484,7 +2446,7 @@ fn add_upstream_rust_crates<'a>(\n                         let rlib = &src.rlib.as_ref().unwrap().0;\n                         archive_builder_builder\n                             .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.fatal(e));\n+                            .unwrap_or_else(|e| sess.emit_fatal(e));\n                     }\n \n                     let mut last = (None, NativeLibKind::Unspecified, None);\n@@ -2641,7 +2603,7 @@ fn add_upstream_rust_crates<'a>(\n                 || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n \n             let mut archive = archive_builder_builder.new_archive_builder(sess);\n-            if let Err(e) = archive.add_archive(\n+            if let Err(error) = archive.add_archive(\n                 cratepath,\n                 Box::new(move |f| {\n                     if f == METADATA_FILENAME {\n@@ -2681,7 +2643,7 @@ fn add_upstream_rust_crates<'a>(\n                     false\n                 }),\n             ) {\n-                sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+                sess.emit_fatal(errors::RlibArchiveBuildFailure { error });\n             }\n             if archive.build(&dst) {\n                 link_upstream(&dst);\n@@ -2813,14 +2775,14 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n         (\"arm\", \"watchos\") => \"watchos\",\n         (_, \"macos\") => \"macosx\",\n         _ => {\n-            sess.err(&format!(\"unsupported arch `{}` for os `{}`\", arch, os));\n+            sess.emit_err(errors::UnsupportedArch { arch, os });\n             return;\n         }\n     };\n     let sdk_root = match get_apple_sdk_root(sdk_name) {\n         Ok(s) => s,\n         Err(e) => {\n-            sess.err(&e);\n+            sess.emit_err(e);\n             return;\n         }\n     };\n@@ -2836,7 +2798,7 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     }\n }\n \n-fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n+fn get_apple_sdk_root(sdk_name: &str) -> Result<String, errors::AppleSdkRootError<'_>> {\n     // Following what clang does\n     // (https://github.com/llvm/llvm-project/blob/\n     // 296a80102a9b72c3eda80558fb78a3ed8849b341/clang/lib/Driver/ToolChains/Darwin.cpp#L1661-L1678)\n@@ -2886,7 +2848,7 @@ fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n \n     match res {\n         Ok(output) => Ok(output.trim().to_string()),\n-        Err(e) => Err(format!(\"failed to get {} SDK path: {}\", sdk_name, e)),\n+        Err(error) => Err(errors::AppleSdkRootError::SdkPath { sdk_name, error }),\n     }\n }\n \n@@ -2919,7 +2881,7 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n                 }\n             }\n         } else {\n-            sess.fatal(\"option `-Z gcc-ld` is used even though linker flavor is not gcc\");\n+            sess.emit_fatal(errors::OptionGccOnly);\n         }\n     }\n }"}, {"sha": "36c94462b0b3e50cd338e8ef3a2420231b289297", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -354,3 +354,170 @@ impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_exe_unexpected_error)]\n+pub struct LinkExeUnexpectedError;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_repair_vs_build_tools)]\n+pub struct RepairVSBuildTools;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_missing_cpp_build_tool_component)]\n+pub struct MissingCppBuildToolComponent;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_select_cpp_build_tool_workload)]\n+pub struct SelectCppBuildToolWorkload;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_visual_studio_not_installed)]\n+pub struct VisualStudioNotInstalled;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_not_found)]\n+#[note]\n+pub struct LinkerNotFound {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_exe_linker)]\n+#[note]\n+#[note(command_note)]\n+pub struct UnableToExeLinker {\n+    pub linker_path: PathBuf,\n+    pub error: Error,\n+    pub command_formatted: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_msvc_missing_linker)]\n+pub struct MsvcMissingLinker;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_check_installed_visual_studio)]\n+pub struct CheckInstalledVisualStudio;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsufficient_vs_code_product)]\n+pub struct UnsufficientVSCodeProduct;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_processing_dymutil_failed)]\n+#[note]\n+pub struct ProcessingDymutilFailed {\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run_dsymutil)]\n+#[note]\n+pub struct UnableToRunDsymutil {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_stripping_debu_info_failed)]\n+#[note]\n+pub struct StrippingDebugInfoFailed<'a> {\n+    pub util: &'a str,\n+    pub status: ExitStatus,\n+    pub output: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_run)]\n+pub struct UnableToRun<'a> {\n+    pub util: &'a str,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_linker_file_stem)]\n+pub struct LinkerFileStem;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_static_library_native_artifacts)]\n+pub struct StaticLibraryNativeArtifacts;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_native_static_libs)]\n+pub struct NativeStaticLibs {\n+    pub arguments: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_unavailable)]\n+pub struct LinkScriptUnavailable;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_link_script_write_failure)]\n+pub struct LinkScriptWriteFailure {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_failed_to_write)]\n+pub struct FailedToWrite {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unable_to_write_debugger_visualizer)]\n+pub struct UnableToWriteDebuggerVisualizer {\n+    pub path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_rlib_archive_build_failure)]\n+pub struct RlibArchiveBuildFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_option_gcc_only)]\n+pub struct OptionGccOnly;\n+\n+#[derive(Diagnostic)]\n+pub enum ExtractBundledLibsError<'a> {\n+    #[diag(codegen_ssa_extract_bundled_libs_open_file)]\n+    OpenFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_mmap_file)]\n+    MmapFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_parse_archive)]\n+    ParseArchive { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_read_entry)]\n+    ReadEntry { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_archive_member)]\n+    ArchiveMember { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_convert_name)]\n+    ConvertName { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+\n+    #[diag(codegen_ssa_extract_bundled_libs_write_file)]\n+    WriteFile { rlib: &'a Path, error: Box<dyn std::error::Error> },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_unsupported_arch)]\n+pub struct UnsupportedArch<'a> {\n+    pub arch: &'a str,\n+    pub os: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum AppleSdkRootError<'a> {\n+    #[diag(codegen_ssa_apple_sdk_error_sdk_path)]\n+    SdkPath { sdk_name: &'a str, error: Error },\n+}"}, {"sha": "ad0d758210175fb096eefe07f0929da10767fae6", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -119,3 +119,66 @@ codegen_ssa_thorin_object_read = {$error}\n codegen_ssa_thorin_object_write = {$error}\n codegen_ssa_thorin_gimli_read = {$error}\n codegen_ssa_thorin_gimli_write = {$error}\n+\n+codegen_ssa_link_exe_unexpected_error = `link.exe` returned an unexpected error\n+\n+codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n+\n+codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n+\n+codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n+\n+codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload\n+\n+codegen_ssa_linker_not_found = linker `{$linker_path}` not found\n+    .note = {$error}\n+\n+codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n+    .note = {$error}\n+    .command_note = {$command_formatted}\n+\n+codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n+\n+codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n+\n+codegen_ssa_unsufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+\n+codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n+\n+codegen_ssa_stripping_debu_info_failed = stripping debug info with `{$util}` failed: {$status}\n+    .note = {$output}\n+\n+codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n+\n+codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n+\n+codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n+\n+codegen_ssa_native_static_libs = native-static-libs: {$arguments}\n+\n+codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n+\n+codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n+\n+codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+\n+codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n+\n+codegen_ssa_rlib_archive_build_failure = failed to build archive from rlib: {$error}\n+\n+codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n+\n+codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n+\n+codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n+\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {error}"}, {"sha": "88286c15f9ea4771d2add9c2c8ff8770c3283e6c", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -665,3 +665,36 @@ passes_missing_const_err =\n     attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n     .help = make the function or method const\n     .label = attribute specified here\n+\n+passes_dead_codes =\n+    { $multiple ->\n+      *[true] multiple {$descr}s are\n+       [false] { $num ->\n+         [one] {$descr} {$name_list} is\n+        *[other] {$descr}s {$name_list} are\n+       }\n+    } never {$participle}\n+\n+passes_change_fields_to_be_of_unit_type =\n+    consider changing the { $num ->\n+      [one] field\n+     *[other] fields\n+    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n+      [one] field\n+     *[other] fields\n+    }\n+\n+passes_parent_info =\n+    {$num ->\n+      [one] {$descr}\n+     *[other] {$descr}s\n+    } in this {$parent_descr}\n+\n+passes_ignored_derived_impls =\n+    `{$name}` has {$trait_list_len ->\n+      [one] a derived impl\n+     *[other] derived impls\n+    } for the {$trait_list_len ->\n+      [one] trait {$trait_list}, but this is\n+     *[other] traits {$trait_list}, but these are\n+    } intentionally ignored during dead code analysis"}, {"sha": "22f6fc700fad371be7c15ecd14ff14ecb4136aa3", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -11,8 +11,10 @@ use rustc_target::abi::TargetDataLayoutErrors;\n use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n+use std::fmt::Write;\n use std::num::ParseIntError;\n use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n \n pub struct DiagnosticArgFromDisplay<'a>(pub &'a dyn fmt::Display);\n \n@@ -58,6 +60,7 @@ into_diagnostic_arg_using_display!(\n     i128,\n     u128,\n     std::io::Error,\n+    std::boxed::Box<dyn std::error::Error>,\n     std::num::NonZeroU32,\n     hir::Target,\n     Edition,\n@@ -66,7 +69,8 @@ into_diagnostic_arg_using_display!(\n     ParseIntError,\n     StackProtector,\n     &TargetTriple,\n-    SplitDebuginfo\n+    SplitDebuginfo,\n+    ExitStatus,\n );\n \n impl IntoDiagnosticArg for bool {\n@@ -170,6 +174,37 @@ impl IntoDiagnosticArg for Level {\n     }\n }\n \n+#[derive(Clone)]\n+pub struct DiagnosticSymbolList(Vec<Symbol>);\n+\n+impl From<Vec<Symbol>> for DiagnosticSymbolList {\n+    fn from(v: Vec<Symbol>) -> Self {\n+        DiagnosticSymbolList(v)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for DiagnosticSymbolList {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        // FIXME: replace the logic here with a real list formatter\n+        let symbols = match &self.0[..] {\n+            [symbol] => format!(\"`{symbol}`\"),\n+            [symbol, last] => {\n+                format!(\"`{symbol}` and `{last}`\",)\n+            }\n+            [symbols @ .., last] => {\n+                let mut result = String::new();\n+                for symbol in symbols {\n+                    write!(result, \"`{symbol}`, \").unwrap();\n+                }\n+                write!(result, \"and `{last}`\").unwrap();\n+                result\n+            }\n+            [] => unreachable!(),\n+        };\n+        DiagnosticArgValue::Str(Cow::Owned(symbols))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;"}, {"sha": "a8fd1a17a5110d3ae10c194881752e0e9ddce67a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -376,7 +376,7 @@ pub use diagnostic::{\n     DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n-pub use diagnostic_impls::DiagnosticArgFromDisplay;\n+pub use diagnostic_impls::{DiagnosticArgFromDisplay, DiagnosticSymbolList};\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output."}, {"sha": "2c7b3bbf31c201531459586effe51e2cfab70725", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -55,8 +55,7 @@ pub enum MethodError<'tcx> {\n     // not-in-scope traits which may work.\n     PrivateMatch(DefKind, DefId, Vec<DefId>),\n \n-    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n-    // forgotten to import a trait.\n+    // Found a `Self: Sized` bound where `Self` is a trait object.\n     IllegalSizedBound(Vec<DefId>, bool, Span),\n \n     // Found a match, but the return type is wrong"}, {"sha": "e88701685bc6d47a5451a25e7a9d7733d4506988", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1019,7 +1019,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container_id(self.tcx)],\n-            //Some(Ok(p)) => p.iter().map(|p| p.item.container().id()).collect(),\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {"}, {"sha": "04ecd2757b427d3aa9e9cc97a2301fd5d6c5ebc7", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 97, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         match error {\n             MethodError::NoMatch(NoMatchData {\n-                static_candidates: mut static_sources,\n+                mut static_candidates,\n                 unsatisfied_predicates,\n                 out_of_scope_traits,\n                 lev_candidate,\n@@ -288,9 +288,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if generics.len() > 0 {\n                         let mut autoderef = self.autoderef(span, actual);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n-                            if let ty::Adt(adt_deref, _) = ty.kind() {\n+                            if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n-                                    .inherent_impls(adt_deref.did())\n+                                    .inherent_impls(adt_def.did())\n                                     .iter()\n                                     .filter_map(|def_id| self.associated_value(*def_id, item_name))\n                                     .count()\n@@ -348,15 +348,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 let ty_span = match actual.kind() {\n-                    ty::Param(param_type) => {\n-                        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n-                        let type_param = generics.type_param(param_type, self.tcx);\n-                        Some(self.tcx.def_span(type_param.def_id))\n-                    }\n+                    ty::Param(param_type) => Some(\n+                        param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n+                    ),\n                     ty::Adt(def, _) if def.did().is_local() => Some(tcx.def_span(def.did())),\n                     _ => None,\n                 };\n-\n                 if let Some(span) = ty_span {\n                     err.span_label(\n                         span,\n@@ -386,17 +383,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut custom_span_label = false;\n \n-                if !static_sources.is_empty() {\n+                if !static_candidates.is_empty() {\n                     err.note(\n                         \"found the following associated functions; to be used as methods, \\\n                          functions must have a `self` parameter\",\n                     );\n                     err.span_label(span, \"this is an associated function, not a method\");\n                     custom_span_label = true;\n                 }\n-                if static_sources.len() == 1 {\n+                if static_candidates.len() == 1 {\n                     let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n                             // When the \"method\" is resolved through dereferencing, we really want the\n                             // original type that has the associated function for accurate suggestions.\n                             // (#61411)\n@@ -422,9 +419,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n                     }\n \n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n-                } else if static_sources.len() > 1 {\n-                    report_candidates(span, &mut err, &mut static_sources, sugg_span);\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n+                } else if static_candidates.len() > 1 {\n+                    report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 }\n \n                 let mut bound_spans = vec![];\n@@ -496,24 +493,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let (ty::Param(_), ty::PredicateKind::Trait(p)) =\n                                 (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n+                                let hir = self.tcx.hir();\n                                 let node = match p.trait_ref.self_ty().kind() {\n                                     ty::Param(_) => {\n                                         // Account for `fn` items like in `issue-35677.rs` to\n                                         // suggest restricting its type params.\n-                                        let did = self.tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: self.body_id,\n-                                        });\n-                                        Some(\n-                                            self.tcx\n-                                                .hir()\n-                                                .get(self.tcx.hir().local_def_id_to_hir_id(did)),\n-                                        )\n+                                        let parent_body =\n+                                            hir.body_owner(hir::BodyId { hir_id: self.body_id });\n+                                        Some(hir.get(parent_body))\n+                                    }\n+                                    ty::Adt(def, _) => {\n+                                        def.did().as_local().map(|def_id| hir.get_by_def_id(def_id))\n                                     }\n-                                    ty::Adt(def, _) => def.did().as_local().map(|def_id| {\n-                                        self.tcx\n-                                            .hir()\n-                                            .get(self.tcx.hir().local_def_id_to_hir_id(def_id))\n-                                    }),\n                                     _ => None,\n                                 };\n                                 if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n@@ -605,7 +596,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .iter()\n                         .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n                         .filter_map(|(p, parent, c)| match c.code() {\n-                            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                            ObligationCauseCode::ImplDerivedObligation(data) => {\n                                 Some((&data.derived, p, parent, data.impl_def_id, data))\n                             }\n                             _ => None,\n@@ -620,22 +611,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match self.tcx.hir().get_if_local(impl_def_id) {\n                             // Unmet obligation comes from a `derive` macro, point at it once to\n                             // avoid multiple span labels pointing at the same place.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                ..\n-                            })) if matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                let span = ident.span.ctxt().outer_expn_data().call_site;\n-                                let mut spans: MultiSpan = span.into();\n-                                spans.push_span_label(span, derive_msg);\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             Some(Node::Item(hir::Item {\n                                 kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n                                 ..\n@@ -659,34 +634,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n \n-                            // Unmet obligation coming from a `trait`.\n-                            Some(Node::Item(hir::Item {\n-                                kind: hir::ItemKind::Trait(..),\n-                                ident,\n-                                span: item_span,\n-                                ..\n-                            })) if !matches!(\n-                                ident.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) =>\n-                            {\n-                                if let Some(pred) = parent_p {\n-                                    // Done to add the \"doesn't satisfy\" `span_label`.\n-                                    let _ = format_pred(*pred);\n-                                }\n-                                skip_list.insert(p);\n-                                let mut spans = if cause.span != *item_span {\n-                                    let mut spans: MultiSpan = cause.span.into();\n-                                    spans.push_span_label(cause.span, unsatisfied_msg);\n-                                    spans\n-                                } else {\n-                                    ident.span.into()\n-                                };\n-                                spans.push_span_label(ident.span, \"in this trait\");\n-                                let entry = spanned_predicates.entry(spans);\n-                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n-                            }\n-\n                             // Unmet obligation coming from an `impl`.\n                             Some(Node::Item(hir::Item {\n                                 kind:\n@@ -695,19 +642,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }),\n                                 span: item_span,\n                                 ..\n-                            })) if !matches!(\n-                                self_ty.span.ctxt().outer_expn_data().kind,\n-                                ExpnKind::Macro(MacroKind::Derive, _)\n-                            ) && !matches!(\n-                                of_trait.as_ref().map(|t| t\n-                                    .path\n-                                    .span\n-                                    .ctxt()\n-                                    .outer_expn_data()\n-                                    .kind),\n-                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n-                            ) =>\n-                            {\n+                            })) => {\n                                 let sized_pred =\n                                     unsatisfied_predicates.iter().any(|(pred, _, _)| {\n                                         match pred.kind().skip_binder() {\n@@ -759,7 +694,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let entry = spanned_predicates.entry(spans);\n                                 entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n-                            _ => {}\n+                            Some(_) => unreachable!(),\n+                            None => (),\n                         }\n                     }\n                     let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n@@ -863,7 +799,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                             .on_unimplemented_note(trait_ref, &obligation);\n                                         (message, label)\n                                     })\n-                                    .unwrap_or((None, None))\n+                                    .unwrap()\n                             } else {\n                                 (None, None)\n                             };\n@@ -972,7 +908,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n                 if let SelfSource::MethodCall(expr) = source {\n-                    if !self.suggest_field_call(span, rcvr_ty, expr, item_name, &mut err)\n+                    if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n                         && lev_candidate.is_none()\n                         && !custom_span_label\n                     {\n@@ -982,10 +918,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found(&mut err);\n                 }\n \n-                // Don't suggest (for example) `expr.field.method()` if `expr.method()`\n-                // doesn't exist due to unsatisfied predicates.\n+                // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n+                // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.check_for_field_method(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n                 }\n \n                 self.check_for_inner_self(&mut err, source, span, actual, item_name);\n@@ -1007,7 +943,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         source,\n                         out_of_scope_traits,\n                         &unsatisfied_predicates,\n-                        &static_sources,\n+                        &static_candidates,\n                         unsatisfied_bounds,\n                     );\n                 }\n@@ -1146,7 +1082,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n-    fn suggest_field_call(\n+    /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n+    /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n+    fn suggest_calling_field_as_fn(\n         &self,\n         span: Span,\n         rcvr_ty: Ty<'tcx>,\n@@ -1408,7 +1346,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn check_for_field_method(\n+    /// Suggest calling a method on a field i.e. `a.field.bar()` instead of `a.bar()`\n+    fn suggest_calling_method_on_field(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -2021,7 +1960,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let mut alt_rcvr_sugg = false;\n         if let (SelfSource::MethodCall(rcvr), false) = (source, unsatisfied_bounds) {\n-            debug!(?span, ?item_name, ?rcvr_ty, ?rcvr);\n+            debug!(\n+                \"suggest_traits_to_import: span={:?}, item_name={:?}, rcvr_ty={:?}, rcvr={:?}\",\n+                span, item_name, rcvr_ty, rcvr\n+            );\n             let skippable = [\n                 self.tcx.lang_items().clone_trait(),\n                 self.tcx.lang_items().deref_trait(),\n@@ -2060,7 +2002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // suggestions are generally misleading (see #94218).\n                         break;\n                     }\n-                    _ => {}\n+                    Err(_) => (),\n                 }\n \n                 for (rcvr_ty, pre) in &["}, {"sha": "07ee758b32c1fc6cd0bfb93d87bcfd1120577f2e", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -203,13 +203,20 @@ pub struct UnifyReceiverContext<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift, Default)]\n+#[derive(Clone, PartialEq, Eq, Hash, Lift, Default)]\n pub struct InternedObligationCauseCode<'tcx> {\n     /// `None` for `ObligationCauseCode::MiscObligation` (a common case, occurs ~60% of\n     /// the time). `Some` otherwise.\n     code: Option<Lrc<ObligationCauseCode<'tcx>>>,\n }\n \n+impl<'tcx> std::fmt::Debug for InternedObligationCauseCode<'tcx> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let cause: &ObligationCauseCode<'_> = self;\n+        cause.fmt(f)\n+    }\n+}\n+\n impl<'tcx> ObligationCauseCode<'tcx> {\n     #[inline(always)]\n     fn into(self) -> InternedObligationCauseCode<'tcx> {"}, {"sha": "5f108bf0ef30644a1849beab3e4bb6838a7f2d82", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -20,6 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n@@ -1282,6 +1283,12 @@ impl<'tcx> ParamTy {\n     pub fn to_ty(self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_ty_param(self.index, self.name)\n     }\n+\n+    pub fn span_from_generics(&self, tcx: TyCtxt<'tcx>, item_with_generics: DefId) -> Span {\n+        let generics = tcx.generics_of(item_with_generics);\n+        let type_param = generics.type_param(self, tcx);\n+        tcx.def_span(type_param.def_id)\n+    }\n }\n \n #[derive(Copy, Clone, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]"}, {"sha": "269d9f3b102c196d0c4279eee54ace23c52edc55", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -4,6 +4,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n+use rustc_hir::{BlockCheckMode, ExprKind, Node};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n@@ -517,24 +518,48 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     for &UnsafetyViolation { source_info, lint_root, kind, details } in violations.iter() {\n         let (description, note) = details.description_and_note();\n \n-        // Report an error.\n-        let unsafe_fn_msg =\n-            if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) { \" function or\" } else { \"\" };\n-\n         match kind {\n             UnsafetyViolationKind::General => {\n                 // once\n-                struct_span_err!(\n+                let unsafe_fn_msg = if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) {\n+                    \" function or\"\n+                } else {\n+                    \"\"\n+                };\n+\n+                let mut err = struct_span_err!(\n                     tcx.sess,\n                     source_info.span,\n                     E0133,\n                     \"{} is unsafe and requires unsafe{} block\",\n                     description,\n                     unsafe_fn_msg,\n-                )\n-                .span_label(source_info.span, description)\n-                .note(note)\n-                .emit();\n+                );\n+                err.span_label(source_info.span, description).note(note);\n+                let note_non_inherited = tcx.hir().parent_iter(lint_root).find(|(id, node)| {\n+                    if let Node::Expr(block) = node\n+                        && let ExprKind::Block(block, _) = block.kind\n+                        && let BlockCheckMode::UnsafeBlock(_) = block.rules\n+                    {\n+                        true\n+                    }\n+                    else if let Some(sig) = tcx.hir().fn_sig_by_hir_id(*id)\n+                        && sig.header.is_unsafe()\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                });\n+                if let Some((id, _)) = note_non_inherited {\n+                    let span = tcx.hir().span(id);\n+                    err.span_label(\n+                        tcx.sess.source_map().guess_head_span(span),\n+                        \"items do not inherit unsafety from separate enclosing items\",\n+                    );\n+                }\n+\n+                err.emit();\n             }\n             UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n                 UNSAFE_OP_IN_UNSAFE_FN,"}, {"sha": "21b487d8ca1e7213dd75b767fe50b79dbeab38a9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 84, "deletions": 91, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -4,7 +4,7 @@\n \n use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, Applicability, MultiSpan};\n+use rustc_errors::MultiSpan;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -18,7 +18,10 @@ use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use std::mem;\n \n-use crate::errors::UselessAssignment;\n+use crate::errors::{\n+    ChangeFieldsToBeOfUnitType, IgnoredDerivedImpls, MultipleDeadCodes, ParentInfo,\n+    UselessAssignment,\n+};\n \n // Any local node that may call something in its body block should be\n // explored. For example, if it's a live Node::Item that is a\n@@ -693,99 +696,89 @@ impl<'tcx> DeadVisitor<'tcx> {\n         parent_item: Option<LocalDefId>,\n         is_positional: bool,\n     ) {\n-        if let Some(&first_id) = dead_codes.first() {\n-            let tcx = self.tcx;\n-            let names: Vec<_> = dead_codes\n-                .iter()\n-                .map(|&def_id| tcx.item_name(def_id.to_def_id()).to_string())\n-                .collect();\n-            let spans: Vec<_> = dead_codes\n-                .iter()\n-                .map(|&def_id| match tcx.def_ident_span(def_id) {\n-                    Some(s) => s.with_ctxt(tcx.def_span(def_id).ctxt()),\n-                    None => tcx.def_span(def_id),\n+        let Some(&first_id) = dead_codes.first() else {\n+            return;\n+        };\n+        let tcx = self.tcx;\n+        let names: Vec<_> =\n+            dead_codes.iter().map(|&def_id| tcx.item_name(def_id.to_def_id())).collect();\n+        let spans: Vec<_> = dead_codes\n+            .iter()\n+            .map(|&def_id| match tcx.def_ident_span(def_id) {\n+                Some(s) => s.with_ctxt(tcx.def_span(def_id).ctxt()),\n+                None => tcx.def_span(def_id),\n+            })\n+            .collect();\n+\n+        let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n+        let num = dead_codes.len();\n+        let multiple = num > 6;\n+        let name_list = names.into();\n+\n+        let lint = if is_positional {\n+            lint::builtin::UNUSED_TUPLE_STRUCT_FIELDS\n+        } else {\n+            lint::builtin::DEAD_CODE\n+        };\n+\n+        let parent_info = if let Some(parent_item) = parent_item {\n+            let parent_descr = tcx.def_kind(parent_item).descr(parent_item.to_def_id());\n+            Some(ParentInfo {\n+                num,\n+                descr,\n+                parent_descr,\n+                span: tcx.def_ident_span(parent_item).unwrap(),\n+            })\n+        } else {\n+            None\n+        };\n+\n+        let encl_def_id = parent_item.unwrap_or(first_id);\n+        let ignored_derived_impls =\n+            if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n+                let trait_list = ign_traits\n+                    .iter()\n+                    .map(|(trait_id, _)| self.tcx.item_name(*trait_id))\n+                    .collect::<Vec<_>>();\n+                let trait_list_len = trait_list.len();\n+                Some(IgnoredDerivedImpls {\n+                    name: self.tcx.item_name(encl_def_id.to_def_id()),\n+                    trait_list: trait_list.into(),\n+                    trait_list_len,\n                 })\n-                .collect();\n-\n-            let descr = tcx.def_kind(first_id).descr(first_id.to_def_id());\n-            let span_len = dead_codes.len();\n-            let names = match &names[..] {\n-                _ if span_len > 6 => String::new(),\n-                [name] => format!(\"`{name}` \"),\n-                [names @ .., last] => {\n-                    format!(\n-                        \"{} and `{last}` \",\n-                        names.iter().map(|name| format!(\"`{name}`\")).join(\", \")\n-                    )\n-                }\n-                [] => unreachable!(),\n+            } else {\n+                None\n             };\n-            let msg = format!(\n-                \"{these}{descr}{s} {names}{are} never {participle}\",\n-                these = if span_len > 6 { \"multiple \" } else { \"\" },\n-                s = pluralize!(span_len),\n-                are = pluralize!(\"is\", span_len),\n-            );\n-\n-            tcx.struct_span_lint_hir(\n-                if is_positional {\n-                    lint::builtin::UNUSED_TUPLE_STRUCT_FIELDS\n-                } else {\n-                    lint::builtin::DEAD_CODE\n-                },\n-                tcx.hir().local_def_id_to_hir_id(first_id),\n-                MultiSpan::from_spans(spans.clone()),\n-                msg,\n-                |err| {\n-                    if is_positional {\n-                        err.multipart_suggestion(\n-                            &format!(\n-                                \"consider changing the field{s} to be of unit type to \\\n-                                      suppress this warning while preserving the field \\\n-                                      numbering, or remove the field{s}\",\n-                                s = pluralize!(span_len)\n-                            ),\n-                            spans.iter().map(|sp| (*sp, \"()\".to_string())).collect(),\n-                            // \"HasPlaceholders\" because applying this fix by itself isn't\n-                            // enough: All constructor calls have to be adjusted as well\n-                            Applicability::HasPlaceholders,\n-                        );\n-                    }\n \n-                    if let Some(parent_item) = parent_item {\n-                        let parent_descr = tcx.def_kind(parent_item).descr(parent_item.to_def_id());\n-                        err.span_label(\n-                            tcx.def_ident_span(parent_item).unwrap(),\n-                            format!(\"{descr}{s} in this {parent_descr}\", s = pluralize!(span_len)),\n-                        );\n-                    }\n+        let diag = if is_positional {\n+            MultipleDeadCodes::UnusedTupleStructFields {\n+                multiple,\n+                num,\n+                descr,\n+                participle,\n+                name_list,\n+                change_fields_suggestion: ChangeFieldsToBeOfUnitType { num, spans: spans.clone() },\n+                parent_info,\n+                ignored_derived_impls,\n+            }\n+        } else {\n+            MultipleDeadCodes::DeadCodes {\n+                multiple,\n+                num,\n+                descr,\n+                participle,\n+                name_list,\n+                parent_info,\n+                ignored_derived_impls,\n+            }\n+        };\n \n-                    let encl_def_id = parent_item.unwrap_or(first_id);\n-                    if let Some(ign_traits) = self.ignored_derived_traits.get(&encl_def_id) {\n-                        let traits_str = ign_traits\n-                            .iter()\n-                            .map(|(trait_id, _)| format!(\"`{}`\", self.tcx.item_name(*trait_id)))\n-                            .collect::<Vec<_>>()\n-                            .join(\" and \");\n-                        let plural_s = pluralize!(ign_traits.len());\n-                        let article = if ign_traits.len() > 1 { \"\" } else { \"a \" };\n-                        let is_are = if ign_traits.len() > 1 { \"these are\" } else { \"this is\" };\n-                        let msg = format!(\n-                            \"`{}` has {}derived impl{} for the trait{} {}, but {} \\\n-                            intentionally ignored during dead code analysis\",\n-                            self.tcx.item_name(encl_def_id.to_def_id()),\n-                            article,\n-                            plural_s,\n-                            plural_s,\n-                            traits_str,\n-                            is_are\n-                        );\n-                        err.note(&msg);\n-                    }\n-                    err\n-                },\n-            );\n-        }\n+        self.tcx.emit_spanned_lint(\n+            lint,\n+            tcx.hir().local_def_id_to_hir_id(first_id),\n+            MultiSpan::from_spans(spans.clone()),\n+            diag,\n+        );\n     }\n \n     fn warn_dead_fields_and_variants("}, {"sha": "d8bed700f520ac58b3ae420dcf024408a04919fe", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -4,7 +4,9 @@ use std::{\n };\n \n use rustc_ast::Label;\n-use rustc_errors::{error_code, Applicability, ErrorGuaranteed, IntoDiagnostic, MultiSpan};\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticSymbolList, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+};\n use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{MainDefinition, Ty};\n@@ -1446,3 +1448,59 @@ pub struct MissingConstErr {\n     #[label]\n     pub const_span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+pub enum MultipleDeadCodes<'tcx> {\n+    #[diag(passes_dead_codes)]\n+    DeadCodes {\n+        multiple: bool,\n+        num: usize,\n+        descr: &'tcx str,\n+        participle: &'tcx str,\n+        name_list: DiagnosticSymbolList,\n+        #[subdiagnostic]\n+        parent_info: Option<ParentInfo<'tcx>>,\n+        #[subdiagnostic]\n+        ignored_derived_impls: Option<IgnoredDerivedImpls>,\n+    },\n+    #[diag(passes_dead_codes)]\n+    UnusedTupleStructFields {\n+        multiple: bool,\n+        num: usize,\n+        descr: &'tcx str,\n+        participle: &'tcx str,\n+        name_list: DiagnosticSymbolList,\n+        #[subdiagnostic]\n+        change_fields_suggestion: ChangeFieldsToBeOfUnitType,\n+        #[subdiagnostic]\n+        parent_info: Option<ParentInfo<'tcx>>,\n+        #[subdiagnostic]\n+        ignored_derived_impls: Option<IgnoredDerivedImpls>,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(passes_parent_info)]\n+pub struct ParentInfo<'tcx> {\n+    pub num: usize,\n+    pub descr: &'tcx str,\n+    pub parent_descr: &'tcx str,\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(passes_ignored_derived_impls)]\n+pub struct IgnoredDerivedImpls {\n+    pub name: Symbol,\n+    pub trait_list: DiagnosticSymbolList,\n+    pub trait_list_len: usize,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_change_fields_to_be_of_unit_type, applicability = \"has-placeholders\")]\n+pub struct ChangeFieldsToBeOfUnitType {\n+    pub num: usize,\n+    #[suggestion_part(code = \"()\")]\n+    pub spans: Vec<Span>,\n+}"}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -27,6 +27,7 @@ pub struct OnUnimplementedDirective {\n }\n \n #[derive(Default)]\n+/// For the `#[rustc_on_unimplemented]` attribute\n pub struct OnUnimplementedNote {\n     pub message: Option<String>,\n     pub label: Option<String>,"}, {"sha": "e6ea2b1849b4c11bc627cfcffaa6796b95e0746b", "filename": "library/panic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Fpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Fpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2FCargo.toml?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -13,7 +13,7 @@ doc = false\n \n [dependencies]\n alloc = { path = \"../alloc\" }\n-cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n+cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n core = { path = \"../core\" }\n libc = { version = \"0.2\", default-features = false }\n compiler_builtins = \"0.1.0\""}, {"sha": "85386976d639a808b4464ecd7337e634b509a53c", "filename": "library/panic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Fpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Fpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2FCargo.toml?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -17,4 +17,4 @@ core = { path = \"../core\" }\n libc = { version = \"0.2\", default-features = false }\n unwind = { path = \"../unwind\" }\n compiler_builtins = \"0.1.0\"\n-cfg-if = \"0.1.8\"\n+cfg-if = \"1.0\""}, {"sha": "27320e8dbc5ad42738fecaeea8131444bbc961f0", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -40,7 +40,7 @@ pub mod test {\n         cli::{parse_opts, TestOpts},\n         filter_tests,\n         helpers::metrics::{Metric, MetricMap},\n-        options::{Concurrent, Options, RunIgnored, RunStrategy, ShouldPanic},\n+        options::{Options, RunIgnored, RunStrategy, ShouldPanic},\n         run_test, test_main, test_main_static,\n         test_result::{TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk},\n         time::{TestExecTime, TestTimeOptions},\n@@ -85,7 +85,7 @@ use event::{CompletedTest, TestEvent};\n use helpers::concurrency::get_concurrency;\n use helpers::exit_code::get_exit_code;\n use helpers::shuffle::{get_shuffle_seed, shuffle_tests};\n-use options::{Concurrent, RunStrategy};\n+use options::RunStrategy;\n use test_result::*;\n use time::TestExecTime;\n \n@@ -267,6 +267,19 @@ where\n         join_handle: Option<thread::JoinHandle<()>>,\n     }\n \n+    impl RunningTest {\n+        fn join(self, completed_test: &mut CompletedTest) {\n+            if let Some(join_handle) = self.join_handle {\n+                if let Err(_) = join_handle.join() {\n+                    if let TrOk = completed_test.result {\n+                        completed_test.result =\n+                            TrFailedMsg(\"panicked after reporting success\".to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // Use a deterministic hasher\n     type TestMap =\n         HashMap<TestId, RunningTest, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n@@ -366,10 +379,10 @@ where\n             let (id, test) = remaining.pop_front().unwrap();\n             let event = TestEvent::TeWait(test.desc.clone());\n             notify_about_test_event(event)?;\n-            let join_handle =\n-                run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone(), Concurrent::No);\n-            assert!(join_handle.is_none());\n-            let completed_test = rx.recv().unwrap();\n+            let join_handle = run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone());\n+            // Wait for the test to complete.\n+            let mut completed_test = rx.recv().unwrap();\n+            RunningTest { join_handle }.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -383,15 +396,8 @@ where\n \n                 let event = TestEvent::TeWait(desc.clone());\n                 notify_about_test_event(event)?; //here no pad\n-                let join_handle = run_test(\n-                    opts,\n-                    !opts.run_tests,\n-                    id,\n-                    test,\n-                    run_strategy,\n-                    tx.clone(),\n-                    Concurrent::Yes,\n-                );\n+                let join_handle =\n+                    run_test(opts, !opts.run_tests, id, test, run_strategy, tx.clone());\n                 running_tests.insert(id, RunningTest { join_handle });\n                 timeout_queue.push_back(TimeoutEntry { id, desc, timeout });\n                 pending += 1;\n@@ -423,14 +429,7 @@ where\n \n             let mut completed_test = res.unwrap();\n             let running_test = running_tests.remove(&completed_test.id).unwrap();\n-            if let Some(join_handle) = running_test.join_handle {\n-                if let Err(_) = join_handle.join() {\n-                    if let TrOk = completed_test.result {\n-                        completed_test.result =\n-                            TrFailedMsg(\"panicked after reporting success\".to_string());\n-                    }\n-                }\n-            }\n+            running_test.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -443,8 +442,10 @@ where\n         for (id, b) in filtered.benchs {\n             let event = TestEvent::TeWait(b.desc.clone());\n             notify_about_test_event(event)?;\n-            run_test(opts, false, id, b, run_strategy, tx.clone(), Concurrent::No);\n-            let completed_test = rx.recv().unwrap();\n+            let join_handle = run_test(opts, false, id, b, run_strategy, tx.clone());\n+            // Wait for the test to complete.\n+            let mut completed_test = rx.recv().unwrap();\n+            RunningTest { join_handle }.join(&mut completed_test);\n \n             let event = TestEvent::TeResult(completed_test);\n             notify_about_test_event(event)?;\n@@ -520,7 +521,6 @@ pub fn run_test(\n     test: TestDescAndFn,\n     strategy: RunStrategy,\n     monitor_ch: Sender<CompletedTest>,\n-    concurrency: Concurrent,\n ) -> Option<thread::JoinHandle<()>> {\n     let TestDescAndFn { desc, testfn } = test;\n \n@@ -538,7 +538,6 @@ pub fn run_test(\n     struct TestRunOpts {\n         pub strategy: RunStrategy,\n         pub nocapture: bool,\n-        pub concurrency: Concurrent,\n         pub time: Option<time::TestTimeOptions>,\n     }\n \n@@ -549,7 +548,6 @@ pub fn run_test(\n         testfn: Box<dyn FnOnce() -> Result<(), String> + Send>,\n         opts: TestRunOpts,\n     ) -> Option<thread::JoinHandle<()>> {\n-        let concurrency = opts.concurrency;\n         let name = desc.name.clone();\n \n         let runtest = move || match opts.strategy {\n@@ -576,7 +574,7 @@ pub fn run_test(\n         // the test synchronously, regardless of the concurrency\n         // level.\n         let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_family = \"wasm\");\n-        if concurrency == Concurrent::Yes && supports_threads {\n+        if supports_threads {\n             let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             let mut runtest = Arc::new(Mutex::new(Some(runtest)));\n             let runtest2 = runtest.clone();\n@@ -597,7 +595,7 @@ pub fn run_test(\n     }\n \n     let test_run_opts =\n-        TestRunOpts { strategy, nocapture: opts.nocapture, concurrency, time: opts.time_options };\n+        TestRunOpts { strategy, nocapture: opts.nocapture, time: opts.time_options };\n \n     match testfn {\n         DynBenchFn(benchfn) => {"}, {"sha": "75ec0b616e193b2403cb4cb77c87a1eb6accd6c2", "filename": "library/test/src/options.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Foptions.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1,12 +1,5 @@\n //! Enums denoting options for test execution.\n \n-/// Whether to execute tests concurrently or not\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Concurrent {\n-    Yes,\n-    No,\n-}\n-\n /// Number of times to run a benchmarked function\n #[derive(Clone, PartialEq, Eq)]\n pub enum BenchMode {"}, {"sha": "7b2e6707f9d11243b112b3b7ef5f2a3c71e37fdc", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -102,7 +102,7 @@ pub fn do_not_run_ignored_tests() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_ne!(result, TrOk);\n }\n@@ -125,7 +125,7 @@ pub fn ignored_tests_result_in_ignored() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrIgnored);\n }\n@@ -150,7 +150,7 @@ fn test_should_panic() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -175,7 +175,7 @@ fn test_should_panic_good_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrOk);\n }\n@@ -205,7 +205,7 @@ fn test_should_panic_bad_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg.to_string()));\n }\n@@ -239,7 +239,7 @@ fn test_should_panic_non_string_message_type() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n     assert_eq!(result, TrFailedMsg(failed_msg));\n }\n@@ -267,15 +267,7 @@ fn test_should_panic_but_succeeds() {\n             testfn: DynTestFn(Box::new(f)),\n         };\n         let (tx, rx) = channel();\n-        run_test(\n-            &TestOpts::new(),\n-            false,\n-            TestId(0),\n-            desc,\n-            RunStrategy::InProcess,\n-            tx,\n-            Concurrent::No,\n-        );\n+        run_test(&TestOpts::new(), false, TestId(0), desc, RunStrategy::InProcess, tx);\n         let result = rx.recv().unwrap().result;\n         assert_eq!(\n             result,\n@@ -306,7 +298,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n \n     let test_opts = TestOpts { time_options, ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let exec_time = rx.recv().unwrap().exec_time;\n     exec_time\n }\n@@ -345,7 +337,7 @@ fn time_test_failure_template(test_type: TestType) -> TestResult {\n \n     let test_opts = TestOpts { time_options: Some(time_options), ..TestOpts::new() };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx, Concurrent::No);\n+    run_test(&test_opts, false, TestId(0), desc, RunStrategy::InProcess, tx);\n     let result = rx.recv().unwrap().result;\n \n     result"}, {"sha": "32c4a7eb5c18cb0f0b2ff1c8debee4a2690265f8", "filename": "library/unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Funwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/library%2Funwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2FCargo.toml?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -17,7 +17,7 @@ doc = false\n core = { path = \"../core\" }\n libc = { version = \"0.2.79\", features = ['rustc-dep-of-std'], default-features = false }\n compiler_builtins = \"0.1.0\"\n-cfg-if = \"0.1.8\"\n+cfg-if = \"1.0\"\n \n [build-dependencies]\n cc = \"1.0.69\""}, {"sha": "ad22b66eda69ffddfecce85d399558b857a22e02", "filename": "src/test/run-make-fulldeps/libtest-json/output-default.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "ec98172eb1c4ee63b2aa607fb0ca87cd2b815b9d", "filename": "src/test/run-make-fulldeps/libtest-json/output-stdout-success.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -2,9 +2,9 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\", \"stdout\": \"print from successful test\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n-{ \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:15:5\\n\" }\n+{ \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\", \"stdout\": \"thread 'c' panicked at 'assertion failed: false', f.rs:15:5\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }\n { \"type\": \"test\", \"name\": \"d\", \"event\": \"ignored\", \"message\": \"msg\" }\n { \"type\": \"suite\", \"event\": \"failed\", \"passed\": 2, \"failed\": 1, \"ignored\": 1, \"measured\": 0, \"filtered_out\": 0, \"exec_time\": $TIME }"}, {"sha": "308f789082959c70a30503abd0d51c540ed3cb13", "filename": "src/test/ui/asm/aarch64/llvm-58384.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fllvm-58384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fllvm-58384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Faarch64%2Fllvm-58384.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -0,0 +1,16 @@\n+// only-aarch64\n+// run-pass\n+// needs-asm-support\n+\n+// Test that we properly work around this LLVM issue:\n+// https://github.com/llvm/llvm-project/issues/58384\n+\n+use std::arch::asm;\n+\n+fn main() {\n+    let a: i32;\n+    unsafe {\n+        asm!(\"\", inout(\"x0\") 435 => a);\n+    }\n+    assert_eq!(a, 435);\n+}"}, {"sha": "6ab1fb7b039bd6ec63c06fb4d12b478275296355", "filename": "src/test/ui/derives/clone-debug-dead-code-in-the-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -3,7 +3,7 @@\n #[derive(Debug)]\n pub struct Whatever {\n     pub field0: (),\n-    field1: (), //~ ERROR fields `field1`, `field2`, `field3` and `field4` are never read\n+    field1: (), //~ ERROR fields `field1`, `field2`, `field3`, and `field4` are never read\n     field2: (),\n     field3: (),\n     field4: (),"}, {"sha": "7f4f78cebc9189d72d6c168ad6ab763e7c1a9fea", "filename": "src/test/ui/derives/clone-debug-dead-code-in-the-same-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fclone-debug-dead-code-in-the-same-struct.stderr?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1,4 +1,4 @@\n-error: fields `field1`, `field2`, `field3` and `field4` are never read\n+error: fields `field1`, `field2`, `field3`, and `field4` are never read\n   --> $DIR/clone-debug-dead-code-in-the-same-struct.rs:6:5\n    |\n LL | pub struct Whatever {"}, {"sha": "2003e1e293a58c18a31b372068690631a14f0110", "filename": "src/test/ui/lint/dead-code/multiple-dead-codes-in-the-same-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -7,7 +7,7 @@ struct Bar {\n     b: usize, //~ ERROR field `b` is never read\n     #[deny(dead_code)]\n     c: usize, //~ ERROR fields `c` and `e` are never read\n-    d: usize, //~ WARN fields `d`, `f` and `g` are never read\n+    d: usize, //~ WARN fields `d`, `f`, and `g` are never read\n     #[deny(dead_code)]\n     e: usize,\n     f: usize,"}, {"sha": "0e5c78a7167975dc89aad27ace64ecdc41e2726a", "filename": "src/test/ui/lint/dead-code/multiple-dead-codes-in-the-same-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fmultiple-dead-codes-in-the-same-struct.stderr?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1,4 +1,4 @@\n-warning: fields `d`, `f` and `g` are never read\n+warning: fields `d`, `f`, and `g` are never read\n   --> $DIR/multiple-dead-codes-in-the-same-struct.rs:10:5\n    |\n LL | struct Bar {"}, {"sha": "14fb30be949dc2b45ca98d49790b0a34e79919dd", "filename": "src/test/ui/lint/dead-code/tuple-struct-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -11,7 +11,7 @@ struct SingleUnused(i32, [u8; LEN], String);\n //~| HELP: consider changing the field to be of unit type\n \n struct MultipleUnused(i32, f32, String, u8);\n-//~^ ERROR: fields `0`, `1`, `2` and `3` are never read\n+//~^ ERROR: fields `0`, `1`, `2`, and `3` are never read\n //~| NOTE: fields in this struct\n //~| HELP: consider changing the fields to be of unit type\n "}, {"sha": "b8ad5cbe4e9779d11e2fba8cecd43f27f4c86dcd", "filename": "src/test/ui/lint/dead-code/tuple-struct-field.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Ftuple-struct-field.stderr?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -16,7 +16,7 @@ help: consider changing the field to be of unit type to suppress this warning wh\n LL | struct SingleUnused(i32, (), String);\n    |                          ~~\n \n-error: fields `0`, `1`, `2` and `3` are never read\n+error: fields `0`, `1`, `2`, and `3` are never read\n   --> $DIR/tuple-struct-field.rs:13:23\n    |\n LL | struct MultipleUnused(i32, f32, String, u8);"}, {"sha": "513c8cf2add00d89b487a58590ef7be01e643e27", "filename": "src/test/ui/test-attrs/test-thread-capture.run.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-capture.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-capture.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-capture.run.stdout?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -10,7 +10,7 @@ fee\n fie\n foe\n fum\n-thread 'main' panicked at 'explicit panic', $DIR/test-thread-capture.rs:32:5\n+thread 'thready_fail' panicked at 'explicit panic', $DIR/test-thread-capture.rs:32:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n "}, {"sha": "8c905d1af8572b453845a4f9765a889697b42d55", "filename": "src/test/ui/test-attrs/test-thread-nocapture.run.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-nocapture.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-nocapture.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-thread-nocapture.run.stderr?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -1,2 +1,2 @@\n-thread 'main' panicked at 'explicit panic', $DIR/test-thread-nocapture.rs:32:5\n+thread 'thready_fail' panicked at 'explicit panic', $DIR/test-thread-nocapture.rs:32:5\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "6d797caa0f94d174d27185e3b3b4ea12b0a026f1", "filename": "src/test/ui/unsafe/unsafe-not-inherited.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -0,0 +1,26 @@\n+#![allow(unused, dead_code)]\n+\n+static mut FOO: u64 = 0;\n+\n+fn static_mod() {\n+    unsafe {static BAR: u64 = FOO;}\n+    //~^ ERROR: use of mutable static is unsafe\n+    //~| NOTE: use of mutable static\n+    //~| NOTE: mutable statics can be mutated by multiple threads\n+    //~| NOTE: items do not inherit unsafety\n+}\n+\n+unsafe fn unsafe_call() {}\n+fn foo() {\n+    unsafe {\n+    //~^ NOTE: items do not inherit unsafety\n+        fn bar() {\n+            unsafe_call();\n+            //~^ ERROR: call to unsafe function\n+            //~| NOTE: call to unsafe function\n+            //~| NOTE: consult the function's documentation\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3bc5ca5c9d151b6280f529612f7f9c333d22674a", "filename": "src/test/ui/unsafe/unsafe-not-inherited.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Funsafe-not-inherited.stderr?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -0,0 +1,24 @@\n+error[E0133]: use of mutable static is unsafe and requires unsafe function or block\n+  --> $DIR/unsafe-not-inherited.rs:6:31\n+   |\n+LL |     unsafe {static BAR: u64 = FOO;}\n+   |     ------                    ^^^ use of mutable static\n+   |     |\n+   |     items do not inherit unsafety from separate enclosing items\n+   |\n+   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/unsafe-not-inherited.rs:18:13\n+   |\n+LL |     unsafe {\n+   |     ------ items do not inherit unsafety from separate enclosing items\n+...\n+LL |             unsafe_call();\n+   |             ^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "97d038da702d5b727497f787702ad559fe87def8", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -10,6 +10,7 @@ regex = \"1\"\n miropt-test-tools = { path = \"../miropt-test-tools\" }\n lazy_static = \"1\"\n walkdir = \"2\"\n+ignore = \"0.4.18\"\n \n [[bin]]\n name = \"rust-tidy\""}, {"sha": "aee36f061c5d166f9edf592149767b2da5c3a028", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09508489efc223287731fe8abbd2a81bbf7adf8e/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=09508489efc223287731fe8abbd2a81bbf7adf8e", "patch": "@@ -2,6 +2,8 @@\n //! - the number of entries in each directory must be less than `ENTRY_LIMIT`\n //! - there are no stray `.stderr` files\n \n+use ignore::Walk;\n+use ignore::WalkBuilder;\n use std::fs;\n use std::path::Path;\n \n@@ -11,34 +13,39 @@ const ROOT_ENTRY_LIMIT: usize = 941;\n const ISSUES_ENTRY_LIMIT: usize = 2117;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n-    let dirs = walkdir::WalkDir::new(&path.join(\"test/ui\"))\n-        .into_iter()\n-        .filter_entry(|e| e.file_type().is_dir());\n-    for dir in dirs {\n-        if let Ok(dir) = dir {\n-            let dir_path = dir.path();\n+    for dir in Walk::new(&path.join(\"test/ui\")) {\n+        if let Ok(entry) = dir {\n+            if entry.file_type().map(|ft| ft.is_dir()).unwrap_or(false) {\n+                let dir_path = entry.path();\n+                // Use special values for these dirs.\n+                let is_root = path.join(\"test/ui\") == dir_path;\n+                let is_issues_dir = path.join(\"test/ui/issues\") == dir_path;\n+                let limit = if is_root {\n+                    ROOT_ENTRY_LIMIT\n+                } else if is_issues_dir {\n+                    ISSUES_ENTRY_LIMIT\n+                } else {\n+                    ENTRY_LIMIT\n+                };\n \n-            // Use special values for these dirs.\n-            let is_root = path.join(\"test/ui\") == dir_path;\n-            let is_issues_dir = path.join(\"test/ui/issues\") == dir_path;\n-            let limit = if is_root {\n-                ROOT_ENTRY_LIMIT\n-            } else if is_issues_dir {\n-                ISSUES_ENTRY_LIMIT\n-            } else {\n-                ENTRY_LIMIT\n-            };\n+                let count = WalkBuilder::new(&dir_path)\n+                    .max_depth(Some(1))\n+                    .build()\n+                    .into_iter()\n+                    .collect::<Vec<_>>()\n+                    .len()\n+                    - 1; // remove the dir itself\n \n-            let count = std::fs::read_dir(dir_path).unwrap().count();\n-            if count > limit {\n-                tidy_error!(\n-                    bad,\n-                    \"following path contains more than {} entries, \\\n-                    you should move the test to some relevant subdirectory (current: {}): {}\",\n-                    limit,\n-                    count,\n-                    dir_path.display()\n-                );\n+                if count > limit {\n+                    tidy_error!(\n+                        bad,\n+                        \"following path contains more than {} entries, \\\n+                            you should move the test to some relevant subdirectory (current: {}): {}\",\n+                        limit,\n+                        count,\n+                        dir_path.display()\n+                    );\n+                }\n             }\n         }\n     }"}]}